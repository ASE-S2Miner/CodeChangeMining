[{"original_method":"@Override\n      public boolean apply(TransMemoryResultItem tmResult)\n      {\n         return tmResult.getSimilarityPercent() >= approvedThreshold;\n      }","id":35000,"modified_method":"@Override\n      public boolean apply(TransMemoryResultItem tmResult)\n      {\n         return (int) tmResult.getSimilarityPercent() >= approvedThreshold;\n      }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TransUnitUpdateRequest createRequest(TransMemoryMerge action, HLocale hLocale, Map<Long, TransUnitUpdateRequest> requestMap, HTextFlow hTextFlowToBeFilled, TransMemoryResultItem tmResult)\n   {\n      if (tmResult == null)\n      {\n         return null;\n      }\n      Long tmSourceId = tmResult.getSourceIdList().get(0);\n      HTextFlow tmSource = textFlowDAO.findById(tmSourceId, false);\n      TransMemoryDetails tmDetail = getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmSource);\n      ContentState statusToSet = TransMemoryMergeStatusResolver.newInstance().workOutStatus(action, hTextFlowToBeFilled, tmDetail, tmResult);\n      if (statusToSet != null)\n      {\n         TransUnitUpdateRequest unfilledRequest = requestMap.get(hTextFlowToBeFilled.getId());\n         TransUnitUpdateRequest request = new TransUnitUpdateRequest(unfilledRequest.getTransUnitId(), tmResult.getTargetContents(), statusToSet, unfilledRequest.getBaseTranslationVersion());\n         request.addTargetComment(\"auto translated by TM merge\");\n         log.debug(\"auto translate from translation memory {}\", request);\n         return request;\n      }\n      return null;\n   }","id":35001,"modified_method":"private TransUnitUpdateRequest createRequest(TransMemoryMerge action, HLocale hLocale, Map<Long, TransUnitUpdateRequest> requestMap, HTextFlow hTextFlowToBeFilled, TransMemoryResultItem tmResult, HTextFlowTarget oldTarget)\n   {\n      if (tmResult == NULL_OBJECT)\n      {\n         return null;\n      }\n      Long tmSourceId = tmResult.getSourceIdList().get(0);\n      HTextFlow tmSource = textFlowDAO.findById(tmSourceId, false);\n      TransMemoryDetails tmDetail = getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmSource);\n      ContentState statusToSet = TransMemoryMergeStatusResolver.newInstance().workOutStatus(action, hTextFlowToBeFilled, tmDetail, tmResult, oldTarget);\n      //statusToSet is null means we need to skip/reject the auto translation\n      if (statusToSet != null)\n      {\n         TransUnitUpdateRequest unfilledRequest = requestMap.get(hTextFlowToBeFilled.getId());\n         TransUnitUpdateRequest request = new TransUnitUpdateRequest(unfilledRequest.getTransUnitId(), tmResult.getTargetContents(), statusToSet, unfilledRequest.getBaseTranslationVersion());\n         request.addTargetComment(buildTargetComment(tmDetail));\n         log.debug(\"auto translate from translation memory {}\", request);\n         return request;\n      }\n      return null;\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public UpdateTransUnitResult execute(TransMemoryMerge action, ExecutionContext context) throws ActionException\n   {\n      SecurityService.SecurityCheckResult securityCheckResult = securityServiceImpl.checkPermission(action, MODIFY);\n      HLocale hLocale = securityCheckResult.getLocale();\n      TranslationWorkspace workspace = securityCheckResult.getWorkspace();\n\n      Map<Long, TransUnitUpdateRequest> requestMap = transformToMap(action.getUpdateRequests());\n      List<HTextFlow> hTextFlows = textFlowDAO.findByIdList(Lists.newArrayList(requestMap.keySet()));\n\n      // FIXME this won't scale well (copy from GetTransMemoryHandler)\n      List<Long> idsWithTranslations = textFlowDAO.findIdsWithTranslations(hLocale.getLocaleId());\n\n      TransMemoryAboveThresholdPredicate predicate = new TransMemoryAboveThresholdPredicate(action.getThresholdPercent());\n\n      List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n      for (HTextFlow hTextFlow : hTextFlows)\n      {\n         HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale.getId());\n         if (hTextFlowTarget != null && hTextFlowTarget.getState() != ContentState.New)\n         {\n            log.warn(\"Text flow id {} is not untranslated. Ignored.\", hTextFlow.getId());\n            continue;\n         }\n         ArrayList<TransMemoryResultItem> tmResults = getTransMemoryHandler.searchTransMemory(hLocale, new TransMemoryQuery(hTextFlow.getContents(), SearchType.FUZZY_PLURAL), idsWithTranslations);\n         TransMemoryResultItem tmResult = findTMAboveThreshold(tmResults, predicate);\n         TransUnitUpdateRequest request = createRequest(action, hLocale, requestMap, hTextFlow, tmResult);\n         if (request != null)\n         {\n            updateRequests.add(request);\n         }\n      }\n\n      if (updateRequests.isEmpty())\n      {\n         return new UpdateTransUnitResult();\n      }\n      return updateTransUnitHandler.doTranslation(hLocale.getLocaleId(), workspace, updateRequests, action.getEditorClientId(), TransUnitUpdated.UpdateType.TMMerge);\n   }","id":35002,"modified_method":"@Override\n   public UpdateTransUnitResult execute(TransMemoryMerge action, ExecutionContext context) throws ActionException\n   {\n      SecurityService.SecurityCheckResult securityCheckResult = securityServiceImpl.checkPermission(action, MODIFY);\n      HLocale hLocale = securityCheckResult.getLocale();\n      TranslationWorkspace workspace = securityCheckResult.getWorkspace();\n\n      Map<Long, TransUnitUpdateRequest> requestMap = transformToMap(action.getUpdateRequests());\n      List<HTextFlow> hTextFlows = textFlowDAO.findByIdList(Lists.newArrayList(requestMap.keySet()));\n\n      // FIXME this won't scale well (copy from GetTransMemoryHandler)\n      List<Long> idsWithTranslations = textFlowDAO.findIdsWithTranslations(hLocale.getLocaleId());\n\n      TransMemoryAboveThresholdPredicate predicate = new TransMemoryAboveThresholdPredicate(action.getThresholdPercent());\n\n      List<TransUnitUpdateRequest> updateRequests = Lists.newArrayList();\n      for (HTextFlow hTextFlow : hTextFlows)\n      {\n         HTextFlowTarget hTextFlowTarget = hTextFlow.getTargets().get(hLocale.getId());\n         if (hTextFlowTarget != null && hTextFlowTarget.getState() == ContentState.Approved)\n         {\n            log.warn(\"Text flow id {} is approved. Ignored.\", hTextFlow.getId());\n            continue;\n         }\n         ArrayList<TransMemoryResultItem> tmResults = getTransMemoryHandler.searchTransMemory(hLocale, new TransMemoryQuery(hTextFlow.getContents(), SearchType.FUZZY_PLURAL), idsWithTranslations);\n         TransMemoryResultItem tmResult = findTMAboveThreshold(tmResults, predicate, hTextFlow, action.getThresholdPercent());\n         TransUnitUpdateRequest request = createRequest(action, hLocale, requestMap, hTextFlow, tmResult, hTextFlowTarget);\n         if (request != null)\n         {\n            updateRequests.add(request);\n         }\n      }\n\n      if (updateRequests.isEmpty())\n      {\n         return new UpdateTransUnitResult();\n      }\n      return updateTransUnitHandler.doTranslation(hLocale.getLocaleId(), workspace, updateRequests, action.getEditorClientId(), TransUnitUpdated.UpdateType.TMMerge);\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"private TransMemoryResultItem findTMAboveThreshold(ArrayList<TransMemoryResultItem> tmResults, TransMemoryAboveThresholdPredicate predicate)\n   {\n      Collection<TransMemoryResultItem> aboveThreshold = filter(tmResults, predicate);\n      if (aboveThreshold.size() > 0)\n      {\n         return aboveThreshold.iterator().next();\n      }\n      else\n      {\n         return null;\n      }\n   }","id":35003,"modified_method":"private static TransMemoryResultItem findTMAboveThreshold(ArrayList<TransMemoryResultItem> tmResults, TransMemoryAboveThresholdPredicate predicate, final HTextFlow hTextFlow, int thresholdPercent)\n   {\n\n      Collection<TransMemoryResultItem> aboveThreshold;\n\n      if (thresholdPercent == 100)\n      {\n         aboveThreshold = filter(tmResults, new ContentsIdenticalPredicate(hTextFlow.getContents()));\n      }\n      else\n      {\n         aboveThreshold = filter(tmResults, predicate);\n      }\n      if (aboveThreshold.size() > 0)\n      {\n         return aboveThreshold.iterator().next();\n      }\n      else\n      {\n         return NULL_OBJECT;\n      }\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void canAutoTranslateIfHasTMAboveThreshold() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      when(textFlowDAO.findIdsWithTranslations(hLocale.getLocaleId())).thenReturn(idsWithTranslations);\n      // Given: there are three TM results returned for text flow id 1, and the most matched one is text flow id 11\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryResultItem mostSimilarTM = tmResult(tmResultSource.getId(), 100);\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, tmQuery, idsWithTranslations))\n            .thenReturn(newArrayList(mostSimilarTM, tmResult(12L, 90), tmResult(13L, 80)));\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetail());\n\n      // When: execute the action\n      handler.execute(action, null);\n\n      // Then: we should have text flow auto translated by using the most similar TM\n      verify(updateTransUnitHandler).doTranslation(same(hLocale.getLocaleId()), same(workspace), updateRequestCaptor.capture(), same(action.getEditorClientId()), eq(TransUnitUpdated.UpdateType.TMMerge));\n      List<TransUnitUpdateRequest> updateRequest = updateRequestCaptor.getValue();\n      assertThat(updateRequest, Matchers.hasSize(1));\n      TransUnitUpdateRequest transUnitUpdateRequest = updateRequest.get(0);\n      assertThat(transUnitUpdateRequest.getNewContents(), Matchers.equalTo(mostSimilarTM.getTargetContents()));\n      assertThat(transUnitUpdateRequest.getTargetComment(), Matchers.equalTo(\"auto translated by TM merge\"));\n   }","id":35004,"modified_method":"@Test\n   public void canAutoTranslateIfHasTMAboveThreshold() throws ActionException\n   {\n      // Given: an action with threshold 80% and trans unit id is 1\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.New, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n      when(textFlowDAO.findIdsWithTranslations(hLocale.getLocaleId())).thenReturn(idsWithTranslations);\n      // Given: there are three TM results returned for text flow id 1, and the most matched one is text flow id 11\n      HTextFlow tmResultSource = TestFixture.makeApprovedHTextFlow(11L, hLocale);\n      TransMemoryResultItem mostSimilarTM = tmResult(tmResultSource.getId(), 100);\n      TransMemoryQuery tmQuery = new TransMemoryQuery(hTextFlow.getContents(), FUZZY_PLURAL);\n      when(getTransMemoryHandler.searchTransMemory(hLocale, tmQuery, idsWithTranslations))\n            .thenReturn(newArrayList(mostSimilarTM, tmResult(12L, 90), tmResult(13L, 80)));\n      when(textFlowDAO.findById(tmResultSource.getId(), false)).thenReturn(tmResultSource);\n      // Given: tm detail of text flow id 11\n      when(getTransMemoryDetailsHandler.getTransMemoryDetail(hLocale, tmResultSource)).thenReturn(tmDetail());\n\n      // When: execute the action\n      handler.execute(action, null);\n\n      // Then: we should have text flow auto translated by using the most similar TM\n      verify(updateTransUnitHandler).doTranslation(same(hLocale.getLocaleId()), same(workspace), updateRequestCaptor.capture(), same(action.getEditorClientId()), eq(TransUnitUpdated.UpdateType.TMMerge));\n      List<TransUnitUpdateRequest> updateRequest = updateRequestCaptor.getValue();\n      assertThat(updateRequest, Matchers.hasSize(1));\n      TransUnitUpdateRequest transUnitUpdateRequest = updateRequest.get(0);\n      assertThat(transUnitUpdateRequest.getNewContents(), Matchers.equalTo(mostSimilarTM.getTargetContents()));\n      assertThat(transUnitUpdateRequest.getTargetComment(), Matchers.equalTo(\"auto translated by TM merge from project: project a, version: master, DocId: pot/msg.pot\"));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void willIgnoreNotNewTextFlows() throws ActionException\n   {\n       // Given: text flow id 1 is not untranslated\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.NeedReview, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n\n      // When: execute the action\n      UpdateTransUnitResult result = handler.execute(action, null);\n\n      // Then: we should have EMPTY trans unit update request\n      verifyZeroInteractions(getTransMemoryHandler, getTransMemoryDetailsHandler, updateTransUnitHandler);\n      assertThat(result.getUpdateInfoList(), Matchers.<TransUnitUpdateInfo>empty());\n   }","id":35005,"modified_method":"@Test\n   public void willIgnoreApprovedTextFlows() throws ActionException\n   {\n       // Given: text flow id 1 is not untranslated\n      final long transUnitId = 1L;\n      TransMemoryMerge action = prepareActionAndMockSecurityService(80, transUnitId);\n\n      HTextFlow hTextFlow = TestFixture.makeHTextFlow(transUnitId, hLocale, ContentState.Approved, \"pot/a.po\");\n      when(textFlowDAO.findByIdList(newArrayList(transUnitId))).thenReturn(newArrayList(hTextFlow));\n\n      // When: execute the action\n      UpdateTransUnitResult result = handler.execute(action, null);\n\n      // Then: we should have EMPTY trans unit update request\n      verifyZeroInteractions(getTransMemoryHandler, getTransMemoryDetailsHandler, updateTransUnitHandler);\n      assertThat(result.getUpdateInfoList(), Matchers.<TransUnitUpdateInfo>empty());\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void proceedToMergeTM(int percentage, MergeOption differentProjectOption, MergeOption differentDocumentOption, MergeOption differentResIdOption)\n   {\n      Collection<TransUnit> newItems = getUntranslatedItems();\n\n      if (newItems.isEmpty())\n      {\n         eventBus.fireEvent(new NotificationEvent(Info, messages.noTranslationToMerge()));\n         display.hide();\n         return;\n      }\n\n      display.showProcessing();\n      TransMemoryMerge action = prepareTMMergeAction(newItems, percentage, differentProjectOption, differentDocumentOption, differentResIdOption);\n      dispatcher.execute(action, new AsyncCallback<UpdateTransUnitResult>()\n      {\n         @Override\n         public void onFailure(Throwable caught)\n         {\n            Log.warn(\"TM merge failed\", caught);\n            eventBus.fireEvent(new NotificationEvent(Error, messages.mergeTMFailed()));\n            display.hide();\n         }\n\n         @Override\n         public void onSuccess(UpdateTransUnitResult result)\n         {\n            if (result.getUpdateInfoList().isEmpty())\n            {\n               eventBus.fireEvent(new NotificationEvent(Info, messages.noTranslationToMerge()));\n            }\n            else\n            {\n               UndoLink undoLink = undoLinkProvider.get();\n               undoLink.prepareUndoFor(result);\n               NotificationEvent event = new NotificationEvent(Info, messages.mergeTMSuccess(), undoLink);\n               eventBus.fireEvent(event);\n            }\n            display.hide();\n         }\n      });\n   }","id":35006,"modified_method":"@Override\n   public void proceedToMergeTM(int percentage, MergeOption differentProjectOption, MergeOption differentDocumentOption, MergeOption differentResIdOption)\n   {\n      Collection<TransUnit> items = getNotApprovedItems();\n\n      if (items.isEmpty())\n      {\n         eventBus.fireEvent(new NotificationEvent(Info, messages.noTranslationToMerge()));\n         display.hide();\n         return;\n      }\n\n      display.showProcessing();\n      TransMemoryMerge action = prepareTMMergeAction(items, percentage, differentProjectOption, differentDocumentOption, differentResIdOption);\n      dispatcher.execute(action, new AsyncCallback<UpdateTransUnitResult>()\n      {\n         @Override\n         public void onFailure(Throwable caught)\n         {\n            Log.warn(\"TM merge failed\", caught);\n            eventBus.fireEvent(new NotificationEvent(Error, messages.mergeTMFailed()));\n            display.hide();\n         }\n\n         @Override\n         public void onSuccess(UpdateTransUnitResult result)\n         {\n            if (result.getUpdateInfoList().isEmpty())\n            {\n               eventBus.fireEvent(new NotificationEvent(Info, messages.noTranslationToMerge()));\n            }\n            else\n            {\n               UndoLink undoLink = undoLinkProvider.get();\n               undoLink.prepareUndoFor(result);\n               NotificationEvent event = new NotificationEvent(Info, messages.mergeTMSuccess(), undoLink);\n               eventBus.fireEvent(event);\n            }\n            display.hide();\n         }\n      });\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void canRequestTMMerge()\n   {\n      // Given:\n      // current table page has a list of trans units and 3 of them are in NEW status\n      // @formatter:off\n      List<TransUnit> currentPageRows = ImmutableList.<TransUnit>builder()\n            .add(makeTransUnit(1, ContentState.New))\n            .add(makeTransUnit(2, ContentState.Approved))\n            .add(makeTransUnit(3, ContentState.NeedReview))\n            .add(makeTransUnit(4, ContentState.New))\n            .add(makeTransUnit(5, ContentState.New))\n            .add(makeTransUnit(6, ContentState.NeedReview))\n            .build();\n      // @formatter:on\n      mockCurrentPageToReturn(currentPageRows);\n\n      // When:\n      presenter.proceedToMergeTM(80, MergeOption.IGNORE_CHECK, MergeOption.REJECT, MergeOption.FUZZY);\n\n      // Then:\n      InOrder inOrder = inOrder(display, dispatcher);\n      inOrder.verify(display).showProcessing();\n      inOrder.verify(dispatcher).execute(transMemoryMergeCaptor.capture(), callbackCaptor.capture());\n\n      TransMemoryMerge action = transMemoryMergeCaptor.getValue();\n      List<TransUnitUpdateRequest> updateRequests = action.getUpdateRequests();\n      assertThat(updateRequests, Matchers.hasSize(3));\n      assertThat(getIds(updateRequests), Matchers.contains(1L, 4L, 5L));\n      assertThat(action.getDifferentProjectOption(), Matchers.equalTo(MergeOption.IGNORE_CHECK));\n      assertThat(action.getDifferentDocumentOption(), Matchers.equalTo(MergeOption.REJECT));\n      assertThat(action.getDifferentContextOption(), Matchers.equalTo(MergeOption.FUZZY));\n   }","id":35007,"modified_method":"@Test\n   public void canRequestTMMerge()\n   {\n      // Given:\n      // current table page has a list of trans units and 3 of them are in NEW status\n      // @formatter:off\n      List<TransUnit> currentPageRows = ImmutableList.<TransUnit>builder()\n            .add(makeTransUnit(1, ContentState.New))\n            .add(makeTransUnit(2, ContentState.Approved))\n            .add(makeTransUnit(3, ContentState.NeedReview))\n            .add(makeTransUnit(4, ContentState.New))\n            .add(makeTransUnit(5, ContentState.New))\n            .add(makeTransUnit(6, ContentState.NeedReview))\n            .build();\n      // @formatter:on\n      mockCurrentPageToReturn(currentPageRows);\n\n      // When:\n      presenter.proceedToMergeTM(80, MergeOption.IGNORE_CHECK, MergeOption.REJECT, MergeOption.FUZZY);\n\n      // Then:\n      InOrder inOrder = inOrder(display, dispatcher);\n      inOrder.verify(display).showProcessing();\n      inOrder.verify(dispatcher).execute(transMemoryMergeCaptor.capture(), callbackCaptor.capture());\n\n      TransMemoryMerge action = transMemoryMergeCaptor.getValue();\n      List<TransUnitUpdateRequest> updateRequests = action.getUpdateRequests();\n      assertThat(updateRequests, Matchers.hasSize(5));\n      assertThat(getIds(updateRequests), Matchers.contains(1L, 3L, 4L, 5L, 6L));\n      assertThat(action.getDifferentProjectOption(), Matchers.equalTo(MergeOption.IGNORE_CHECK));\n      assertThat(action.getDifferentDocumentOption(), Matchers.equalTo(MergeOption.REJECT));\n      assertThat(action.getDifferentContextOption(), Matchers.equalTo(MergeOption.FUZZY));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void willIgnoreIfNoUntranslatedTextFlow() {\n      // Given:\n      // current table page has a list of trans units but NONE of them are untranslated\n      // @formatter:off\n      List<TransUnit> currentPageRows = ImmutableList.<TransUnit>builder()\n            .add(makeTransUnit(2, ContentState.Approved))\n            .add(makeTransUnit(3, ContentState.NeedReview))\n            .add(makeTransUnit(6, ContentState.NeedReview))\n            .build();\n      // @formatter:on\n      mockCurrentPageToReturn(currentPageRows);\n\n      // When:\n      presenter.proceedToMergeTM(80, MergeOption.IGNORE_CHECK, MergeOption.REJECT, MergeOption.FUZZY);\n\n      // Then:\n      verify(eventBus).fireEvent(notificationEventCaptor.capture());\n      verify(messages).noTranslationToMerge();\n      verify(display).hide();\n      verifyZeroInteractions(dispatcher, undoLinkProvider);\n   }","id":35008,"modified_method":"@Test\n   public void willIgnoreApprovedTextFlow() {\n      // Given:\n      // current table page has a list of trans units but all of them are approved\n      // @formatter:off\n      List<TransUnit> currentPageRows = ImmutableList.<TransUnit>builder()\n            .add(makeTransUnit(2, ContentState.Approved))\n            .add(makeTransUnit(3, ContentState.Approved))\n            .add(makeTransUnit(6, ContentState.Approved))\n            .build();\n      // @formatter:on\n      mockCurrentPageToReturn(currentPageRows);\n\n      // When:\n      presenter.proceedToMergeTM(80, MergeOption.IGNORE_CHECK, MergeOption.REJECT, MergeOption.FUZZY);\n\n      // Then:\n      verify(eventBus).fireEvent(notificationEventCaptor.capture());\n      verify(messages).noTranslationToMerge();\n      verify(display).hide();\n      verifyZeroInteractions(dispatcher, undoLinkProvider);\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ContentState workOutStatus(TransMemoryMerge action, HTextFlow tfToBeFilled, TransMemoryDetails tmDetail, TransMemoryResultItem tmResult)\n   {\n\n      if (tmResult.getSimilarityPercent() != 100)\n      {\n         needReview = true;\n      }\n      compareTextFlowResId(action, tfToBeFilled, tmDetail);\n      compareTextFlowMsgContext(action, tfToBeFilled, tmDetail);\n      compareDocId(action, tfToBeFilled, tmDetail);\n      compareProjectName(action, tfToBeFilled, tmDetail);\n\n      if (needSkip)\n      {\n         return null;\n      }\n      else if (needReview)\n      {\n         return ContentState.NeedReview;\n      }\n      return ContentState.Approved;\n   }","id":35009,"modified_method":"/**\n    * \n    * @param action TM merge action\n    * @param tfToBeFilled text flow to be filled\n    * @param tmDetail TM detail\n    * @param tmResult TM result\n    * @param oldTarget text flow target that may be null or has NEW or FUZZY\n    *           status\n    * \n    * @return content state to be set on auto translated target. If null means\n    *         we want to reject the auto translation via TM merge\n    */\n   public ContentState workOutStatus(TransMemoryMerge action, HTextFlow tfToBeFilled, TransMemoryDetails tmDetail, TransMemoryResultItem tmResult, HTextFlowTarget oldTarget)\n   {\n\n      if ((int) tmResult.getSimilarityPercent() != 100)\n      {\n         needReview = true;\n      }\n      compareTextFlowResId(action, tfToBeFilled, tmDetail);\n      compareTextFlowMsgContext(action, tfToBeFilled, tmDetail);\n      compareDocId(action, tfToBeFilled, tmDetail);\n      compareProjectName(action, tfToBeFilled, tmDetail);\n\n      if (needSkip)\n      {\n         return null;\n      }\n      else if (needReview)\n      {\n         // if there is an old translation and we only find TM needs review, we don't overwrite previous translation\n         if (oldTarget != null && oldTarget.getState() != ContentState.New)\n         {\n            return null;\n         }\n         return ContentState.NeedReview;\n      }\n      return ContentState.Approved;\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentResIdAndOptionIsIgnore() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, \"different res id\", msgContext);\n\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.IGNORE_CHECK);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), equalTo(ContentState.Approved));\n   }","id":35010,"modified_method":"@Test\n   public void differentResIdAndOptionIsIgnore() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, \"different res id\", msgContext);\n\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.IGNORE_CHECK);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), equalTo(ContentState.Approved));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentDocIdAndOptionIsReject() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, \"different doc id\", resId, msgContext);\n      action = mergeTMActionWhenDocIdIsDifferent(MergeOption.REJECT);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), is(nullValue()));\n   }","id":35011,"modified_method":"@Test\n   public void differentDocIdAndOptionIsReject() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, \"different doc id\", resId, msgContext);\n      action = mergeTMActionWhenDocIdIsDifferent(MergeOption.REJECT);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), is(nullValue()));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentDocIdAndOptionIsFuzzy() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, \"different doc id\", resId, msgContext);\n      action = mergeTMActionWhenDocIdIsDifferent(MergeOption.FUZZY);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), equalTo(ContentState.NeedReview));\n   }","id":35012,"modified_method":"@Test\n   public void differentDocIdAndOptionIsFuzzy() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, \"different doc id\", resId, msgContext);\n      action = mergeTMActionWhenDocIdIsDifferent(MergeOption.FUZZY);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), equalTo(ContentState.NeedReview));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentProjectNameAndOptionIsFuzzy() {\n      TransMemoryDetails tmDetail = tmDetail(\"different project name\", docId, resId, msgContext);\n      action = mergeTMActionWhenProjectNameIsDifferent(MergeOption.FUZZY);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), equalTo(ContentState.NeedReview));\n   }","id":35013,"modified_method":"@Test\n   public void differentProjectNameAndOptionIsFuzzy() {\n      TransMemoryDetails tmDetail = tmDetail(\"different project name\", docId, resId, msgContext);\n      action = mergeTMActionWhenProjectNameIsDifferent(MergeOption.FUZZY);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), equalTo(ContentState.NeedReview));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentResIdAndOptionIsFuzzy() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, \"different res id\", msgContext);\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.FUZZY);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), equalTo(ContentState.NeedReview));\n   }","id":35014,"modified_method":"@Test\n   public void differentResIdAndOptionIsFuzzy() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, \"different res id\", msgContext);\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.FUZZY);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), equalTo(ContentState.NeedReview));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void notOneHundredMatchWillBeSetAsFuzzy() {\n      action = mergeTMAction(MergeOption.IGNORE_CHECK, MergeOption.IGNORE_CHECK, MergeOption.IGNORE_CHECK);\n      ContentState result = resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(90));\n\n      assertThat(result, equalTo(ContentState.NeedReview));\n   }","id":35015,"modified_method":"@Test\n   public void notOneHundredMatchWillBeSetAsFuzzy() {\n      action = mergeTMAction(MergeOption.IGNORE_CHECK, MergeOption.IGNORE_CHECK, MergeOption.IGNORE_CHECK);\n      ContentState result = resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(90), null);\n\n      assertThat(result, equalTo(ContentState.NeedReview));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentMsgContextAndOptionIsReject() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, resId, \"different msg context\");\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.REJECT);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(80)), is(nullValue()));\n   }","id":35016,"modified_method":"@Test\n   public void differentMsgContextAndOptionIsReject() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, resId, \"different msg context\");\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.REJECT);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(80), null), is(nullValue()));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentProjectNameAndOptionIsReject() {\n      TransMemoryDetails tmDetail = tmDetail(\"different project name\", docId, resId, msgContext);\n      action = mergeTMActionWhenProjectNameIsDifferent(MergeOption.REJECT);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), is(nullValue()));\n   }","id":35017,"modified_method":"@Test\n   public void differentProjectNameAndOptionIsReject() {\n      TransMemoryDetails tmDetail = tmDetail(\"different project name\", docId, resId, msgContext);\n      action = mergeTMActionWhenProjectNameIsDifferent(MergeOption.REJECT);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), is(nullValue()));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentResIdAndOptionIsReject() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, \"different res id\", msgContext);\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.REJECT);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(80)), is(nullValue()));\n   }","id":35018,"modified_method":"@Test\n   public void differentResIdAndOptionIsReject() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, \"different res id\", msgContext);\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.REJECT);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(80), null), is(nullValue()));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentMsgContextAndOptionIsIgnore() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, resId, \"different msg context\");\n\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.IGNORE_CHECK);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), equalTo(ContentState.Approved));\n   }","id":35019,"modified_method":"@Test\n   public void differentMsgContextAndOptionIsIgnore() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, resId, \"different msg context\");\n\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.IGNORE_CHECK);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), equalTo(ContentState.Approved));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentMsgContextAndOptionIsFuzzy() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, resId, \"different msg context\");\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.FUZZY);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), equalTo(ContentState.NeedReview));\n   }","id":35020,"modified_method":"@Test\n   public void differentMsgContextAndOptionIsFuzzy() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, docId, resId, \"different msg context\");\n      action = mergeTMActionWhenResIdIsDifferent(MergeOption.FUZZY);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), equalTo(ContentState.NeedReview));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentDocIdAndOptionIsIgnore() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, \"different doc id\", resId, msgContext);\n      action = mergeTMActionWhenDocIdIsDifferent(MergeOption.IGNORE_CHECK);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), equalTo(ContentState.Approved));\n   }","id":35021,"modified_method":"@Test\n   public void differentDocIdAndOptionIsIgnore() {\n      TransMemoryDetails tmDetail = tmDetail(projectName, \"different doc id\", resId, msgContext);\n      action = mergeTMActionWhenDocIdIsDifferent(MergeOption.IGNORE_CHECK);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), equalTo(ContentState.Approved));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void differentProjectNameAndOptionIsIgnore() {\n      TransMemoryDetails tmDetail = tmDetail(\"different project name\", docId, resId, msgContext);\n      action = mergeTMActionWhenProjectNameIsDifferent(MergeOption.IGNORE_CHECK);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100)), equalTo(ContentState.Approved));\n   }","id":35022,"modified_method":"@Test\n   public void differentProjectNameAndOptionIsIgnore() {\n      TransMemoryDetails tmDetail = tmDetail(\"different project name\", docId, resId, msgContext);\n      action = mergeTMActionWhenProjectNameIsDifferent(MergeOption.IGNORE_CHECK);\n      assertThat(resolver.workOutStatus(action, textFlow, tmDetail, tmResultWithSimilarity(100), null), equalTo(ContentState.Approved));\n   }","commit_id":"17ec9492f87775287e71452aac8cf79a3b66aaff","url":"https://github.com/zanata/zanata-server"},{"original_method":"public DiffMatchPatchLabelGlossaryColumn(boolean displaySource, boolean displayTarget)\n   {\n      super(new DiffMatchPatchLabelCell());\n      this.displaySource = displaySource;\n      this.displayTarget = displayTarget;\n   }","id":35023,"modified_method":"public DiffMatchPatchLabelGlossaryColumn(boolean displaySource, boolean displayTarget)\n   {\n      super(new StaticWidgetCell<DiffMatchPatchLabel>());\n      this.displaySource = displaySource;\n      this.displayTarget = displayTarget;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void execute()\n   {\n      Log.info(\"ENTER DummyGetGlossaryCommand.execute()\");\n      String query = action.getQuery();\n      SearchType type = action.getSearchType();\n      ArrayList<GlossaryResultItem> matches = new ArrayList<GlossaryResultItem>();\n      matches.add(new GlossaryResultItem(\"<s>source1<\/s>\", \"<tr> &lt;suggestion 3<\/tr>\", new Long(3), 100));\n      matches.add(new GlossaryResultItem(\"<s>source1<\/s>\", \"<tr> &lt;suggestion 3<\/tr>\", new Long(3), 100));\n      matches.add(new GlossaryResultItem(\"<s>source1<\/s>\", \"<tr> &lt;suggestion 3<\/tr>\", new Long(3), 100));\n      matches.add(new GlossaryResultItem(\"<s>source1<\/s>\", \"<tr> &lt;suggestion 3<\/tr>\", new Long(3), 100));\n      callback.onSuccess(new GetGlossaryResult(action, matches));\n      Log.info(\"EXIT DummyGetGlossaryCommand.execute()\");\n   }","id":35024,"modified_method":"@Override\n   public void execute()\n   {\n      Log.info(\"ENTER DummyGetGlossaryCommand.execute()\");\n      ArrayList<GlossaryResultItem> matches = new ArrayList<GlossaryResultItem>();\n      matches.add(new GlossaryResultItem(\"<s>source1<\/s>\", \"<tr> &lt;suggestion 3<\/tr>\", 3, 100));\n      matches.add(new GlossaryResultItem(\"<s>source1<\/s>\", \"<tr> &lt;suggestion 3<\/tr>\", 3, 100));\n      matches.add(new GlossaryResultItem(\"<s>source1<\/s>\", \"<tr> &lt;suggestion 3<\/tr>\", 3, 100));\n      matches.add(new GlossaryResultItem(\"<s>source1<\/s>\", \"<tr> &lt;suggestion 3<\/tr>\", 3, 100));\n      callback.onSuccess(new GetGlossaryResult(action, matches));\n      Log.info(\"EXIT DummyGetGlossaryCommand.execute()\");\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void execute()\n   {\n      Log.info(\"ENTER DummyGetTranslationMemoryCommand.execute()\");\n      ArrayList<TransMemoryResultItem> matches = new ArrayList<TransMemoryResultItem>();\n      ArrayList<String> source = new ArrayList<String>();\n      source.add(\"<s>source1<\/s>\");\n      ArrayList<String> target = new ArrayList<String>();\n      target.add(\"<tr> &lt;target3<\/tr>\");\n      matches.add(new TransMemoryResultItem(source, target, new Long(3), 85));\n      matches.add(new TransMemoryResultItem(source, target, new Long(3), 85));\n      matches.add(new TransMemoryResultItem(source, target, new Long(3), 85));\n      matches.add(new TransMemoryResultItem(source, target, new Long(3), 85));\n      callback.onSuccess(new GetTranslationMemoryResult(action, matches));\n      Log.info(\"EXIT DummyGetTranslationMemoryCommand.execute()\");\n   }","id":35025,"modified_method":"@Override\n   public void execute()\n   {\n      Log.info(\"ENTER DummyGetTranslationMemoryCommand.execute()\");\n      ArrayList<TransMemoryResultItem> matches = new ArrayList<TransMemoryResultItem>();\n      ArrayList<String> source = new ArrayList<String>();\n      source.add(\"<s>source1<\/s>\");\n      ArrayList<String> target = new ArrayList<String>();\n      target.add(\"<tr> &lt;target3<\/tr>\");\n      matches.add(new TransMemoryResultItem(source, target, 3, 85));\n      matches.add(new TransMemoryResultItem(source, target, 3, 85));\n      matches.add(new TransMemoryResultItem(source, target, 3, 85));\n      matches.add(new TransMemoryResultItem(source, target, 3, 85));\n      callback.onSuccess(new GetTranslationMemoryResult(action, matches));\n      Log.info(\"EXIT DummyGetTranslationMemoryCommand.execute()\");\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public GetGlossaryResult execute(GetGlossary action, ExecutionContext context) throws ActionException\n   {\n      ZanataIdentity.instance().checkLoggedIn();\n\n      final String searchText = action.getQuery();\n      ShortString abbrev = new ShortString(searchText);\n      final SearchType searchType = action.getSearchType();\n      log.info(\"Fetching Glossary matches({0}) for \\\"{1}\\\"\", searchType, abbrev);\n\n      LocaleId localeID = action.getLocaleId();\n      HLocale hLocale = localeServiceImpl.getByLocaleId(localeID);\n      ArrayList<GlossaryResultItem> results;\n\n      try\n      {\n         List<HGlossaryEntry> entries = glossaryDAO.getEntriesByLocaleId(localeID);\n         List<Object[]> matches = glossaryDAO.getSearchResult(searchText, searchType, action.getSrcLocaleId(), MAX_RESULTS);\n\n         Map<GlossaryKey, GlossaryResultItem> matchesMap = new LinkedHashMap<GlossaryKey, GlossaryResultItem>();\n         for (Object[] match : matches)\n         {\n            float score = (Float) match[0];\n            HGlossaryTerm glossaryTerm = (HGlossaryTerm) match[1];\n            if (glossaryTerm == null)\n            {\n               continue;\n            }\n\n            String srcTermContent = glossaryTerm.getContent();\n\n            HGlossaryTerm targetTerm = null;\n            for (HGlossaryEntry entry : entries)\n            {\n               if (entry.getId() == glossaryTerm.getGlossaryEntry().getId())\n               {\n                  targetTerm = entry.getGlossaryTerms().get(hLocale);\n               }\n            }\n\n            if (targetTerm == null)\n            {\n               continue;\n            }\n\n            String targetTermContent = targetTerm.getContent();\n\n            int percent = (int) (100 * LevenshteinUtil.getSimilarity(searchText, srcTermContent));\n\n            GlossaryKey key = new GlossaryKey(targetTermContent, srcTermContent);\n            GlossaryResultItem item = matchesMap.get(key);\n            if (item == null)\n            {\n               item = new GlossaryResultItem(srcTermContent, targetTermContent, score, percent);\n               matchesMap.put(key, item);\n            }\n            item.addSourceId(glossaryTerm.getId());\n         }\n         results = new ArrayList<GlossaryResultItem>(matchesMap.values());\n      }\n      catch (ParseException e)\n      {\n         if (searchType == SearchType.FUZZY)\n         {\n            log.warn(\"Can't parse fuzzy query '\" + searchText + \"'\");\n         }\n         else\n         {\n            // escaping failed!\n            log.error(\"Can't parse query '\" + searchText + \"'\", e);\n         }\n         results = new ArrayList<GlossaryResultItem>(0);\n      }\n\n      /**\n       * NB just because this Comparator returns 0 doesn't mean the matches are\n       * identical.\n       */\n      Comparator<GlossaryResultItem> comp = new Comparator<GlossaryResultItem>()\n      {\n         @Override\n         public int compare(GlossaryResultItem m1, GlossaryResultItem m2)\n         {\n            int result;\n            result = compare(m1.getSimilarityPercent(), m2.getSimilarityPercent());\n            if (result != 0)\n               return -result;\n            result = compare(m1.getSource().length(), m2.getSource().length());\n            if (result != 0)\n               return result; // shorter matches are preferred, if similarity is\n                              // the same\n            result = compare(m1.getRelevanceScore(), m2.getRelevanceScore());\n            if (result != 0)\n               return -result;\n            return m1.getSource().compareTo(m2.getSource());\n         }\n\n         private int compare(int a, int b)\n         {\n            if (a < b)\n               return -1;\n            if (a > b)\n               return 1;\n            return 0;\n         }\n\n         private int compare(float a, float b)\n         {\n            if (a < b)\n               return -1;\n            if (a > b)\n               return 1;\n            return 0;\n         }\n\n      };\n\n      Collections.sort(results, comp);\n\n      log.info(\"Returning {0} Glossary matches for \\\"{1}\\\"\", results.size(), abbrev);\n      return new GetGlossaryResult(action, results);\n   }","id":35026,"modified_method":"@Override\n   public GetGlossaryResult execute(GetGlossary action, ExecutionContext context) throws ActionException\n   {\n      ZanataIdentity.instance().checkLoggedIn();\n\n      final String searchText = action.getQuery();\n      ShortString abbrev = new ShortString(searchText);\n      final SearchType searchType = action.getSearchType();\n      log.info(\"Fetching Glossary matches({0}) for \\\"{1}\\\"\", searchType, abbrev);\n\n      LocaleId localeID = action.getLocaleId();\n      HLocale hLocale = localeServiceImpl.getByLocaleId(localeID);\n      ArrayList<GlossaryResultItem> results;\n\n      try\n      {\n         List<HGlossaryEntry> entries = glossaryDAO.getEntriesByLocaleId(localeID);\n         List<Object[]> matches = glossaryDAO.getSearchResult(searchText, searchType, action.getSrcLocaleId(), MAX_RESULTS);\n\n         Map<GlossaryKey, GlossaryResultItem> matchesMap = new LinkedHashMap<GlossaryKey, GlossaryResultItem>();\n         for (Object[] match : matches)\n         {\n            float score = (Float) match[0];\n            HGlossaryTerm glossaryTerm = (HGlossaryTerm) match[1];\n            if (glossaryTerm == null)\n            {\n               continue;\n            }\n\n            String srcTermContent = glossaryTerm.getContent();\n\n            HGlossaryTerm targetTerm = null;\n            for (HGlossaryEntry entry : entries)\n            {\n               if (entry.getId() == glossaryTerm.getGlossaryEntry().getId())\n               {\n                  targetTerm = entry.getGlossaryTerms().get(hLocale);\n               }\n            }\n\n            if (targetTerm == null)\n            {\n               continue;\n            }\n\n            String targetTermContent = targetTerm.getContent();\n\n            double percent = 100 * LevenshteinUtil.getSimilarity(searchText, srcTermContent);\n\n            GlossaryKey key = new GlossaryKey(targetTermContent, srcTermContent);\n            GlossaryResultItem item = matchesMap.get(key);\n            if (item == null)\n            {\n               item = new GlossaryResultItem(srcTermContent, targetTermContent, score, percent);\n               matchesMap.put(key, item);\n            }\n            item.addSourceId(glossaryTerm.getId());\n         }\n         results = new ArrayList<GlossaryResultItem>(matchesMap.values());\n      }\n      catch (ParseException e)\n      {\n         if (searchType == SearchType.FUZZY)\n         {\n            log.warn(\"Can't parse fuzzy query '\" + searchText + \"'\");\n         }\n         else\n         {\n            // escaping failed!\n            log.error(\"Can't parse query '\" + searchText + \"'\", e);\n         }\n         results = new ArrayList<GlossaryResultItem>(0);\n      }\n\n      /**\n       * NB just because this Comparator returns 0 doesn't mean the matches are\n       * identical.\n       */\n      Comparator<GlossaryResultItem> comp = new Comparator<GlossaryResultItem>()\n      {\n         @Override\n         public int compare(GlossaryResultItem m1, GlossaryResultItem m2)\n         {\n            int result;\n            result = Double.compare(m1.getSimilarityPercent(), m2.getSimilarityPercent());\n            if (result != 0)\n               return -result;\n            result = compare(m1.getSource().length(), m2.getSource().length());\n            if (result != 0)\n               return result; // shorter matches are preferred, if similarity is\n                              // the same\n            result = Double.compare(m1.getRelevanceScore(), m2.getRelevanceScore());\n            if (result != 0)\n               return -result;\n            return m1.getSource().compareTo(m2.getSource());\n         }\n\n         private int compare(int a, int b)\n         {\n            if (a < b)\n               return -1;\n            if (a > b)\n               return 1;\n            return 0;\n         }\n\n      };\n\n      Collections.sort(results, comp);\n\n      log.info(\"Returning {0} Glossary matches for \\\"{1}\\\"\", results.size(), abbrev);\n      return new GetGlossaryResult(action, results);\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public GetTranslationMemoryResult execute(GetTranslationMemory action, ExecutionContext context) throws ActionException\n   {\n      ZanataIdentity.instance().checkLoggedIn();\n\n      log.info(\"Fetching matches for {0}\", action.getQuery());\n\n      LocaleId localeID = action.getLocaleId();\n      HLocale hLocale = localeServiceImpl.getByLocaleId(localeID);\n      ArrayList<TransMemoryResultItem> results;\n\n      try\n      {\n         // FIXME this won't scale well\n         List<Long> idsWithTranslations = textFlowDAO.findIdsWithTranslations(localeID);\n         List<Object[]> matches = textFlowDAO.getSearchResult(action.getQuery(), idsWithTranslations, MAX_RESULTS);\n         Map<TMKey, TransMemoryResultItem> matchesMap = new LinkedHashMap<TMKey, TransMemoryResultItem>(matches.size());\n         for (Object[] match : matches)\n         {\n            float score = (Float) match[0];\n            HTextFlow textFlow = (HTextFlow) match[1];\n            if (textFlow == null)\n            {\n               continue;\n            }\n            else\n            {\n               HProjectIteration projectIteration = textFlow.getDocument().getProjectIteration();\n               if (projectIteration.getStatus() == EntityStatus.OBSOLETE || projectIteration.getProject().getStatus() == EntityStatus.OBSOLETE)\n               {\n                  continue;\n               }\n            }\n            HTextFlowTarget target = textFlow.getTargets().get(hLocale);\n            // double check in case of caching issues\n            if (target == null || target.getState() != ContentState.Approved)\n            {\n               continue;\n            }\n\n            int percent;\n            if (action.getQuery().getSearchType() == SearchType.FUZZY_PLURAL)\n            {\n               percent = (int) (100 * LevenshteinUtil.getSimilarity(action.getQuery().getQueries(), textFlow.getContents()));\n            }\n            else\n            {\n               final String searchText = action.getQuery().getQueries().get(0);\n               percent = (int) (100 * LevenshteinUtil.getSimilarity(searchText, textFlow.getContents()));\n            }\n            ArrayList<String> textFlowContents = new ArrayList<String>(textFlow.getContents());\n            ArrayList<String> targetContents = new ArrayList<String>(target.getContents());\n            TMKey key = new TMKey(textFlowContents, targetContents);\n            TransMemoryResultItem item = matchesMap.get(key);\n            if (item == null)\n            {\n               item = new TransMemoryResultItem(textFlowContents, targetContents, score, percent);\n               matchesMap.put(key, item);\n            }\n            item.addSourceId(textFlow.getId());\n         }\n         results = new ArrayList<TransMemoryResultItem>(matchesMap.values());\n      }\n      catch (ParseException e)\n      {\n         if (action.getQuery().getSearchType() == SearchType.RAW)\n         {\n            // TODO tell the user\n            log.warn(\"Can't parse raw query \" + action.getQuery());\n         }\n         else\n         {\n            // escaping failed!\n            log.error(\"Can't parse query \" + action.getQuery(), e);\n         }\n         results = new ArrayList<TransMemoryResultItem>(0);\n      }\n\n      /**\n       * NB just because this Comparator returns 0 doesn't mean the matches are\n       * identical.\n       */\n      Comparator<TransMemoryResultItem> comp = new Comparator<TransMemoryResultItem>()\n      {\n\n         @Override\n         public int compare(TransMemoryResultItem m1, TransMemoryResultItem m2)\n         {\n            int result;\n            result = compare(m1.getSimilarityPercent(), m2.getSimilarityPercent());\n            if (result != 0)\n               return -result;\n            // FIXME compare List<String>, not String\n            result = compare(m1.getSource().length(), m2.getSource().length());\n            if (result != 0)\n               return result; // shorter matches are preferred, if similarity is\n                              // the same\n            result = compare(m1.getRelevanceScore(), m2.getRelevanceScore());\n            if (result != 0)\n               return -result;\n            // FIXME compare List<String>, not String\n            return m1.getSource().compareTo(m2.getSource());\n         }\n\n         private int compare(int a, int b)\n         {\n            if (a < b)\n               return -1;\n            if (a > b)\n               return 1;\n            return 0;\n         }\n\n         private int compare(float a, float b)\n         {\n            if (a < b)\n               return -1;\n            if (a > b)\n               return 1;\n            return 0;\n         }\n\n      };\n\n      Collections.sort(results, comp);\n\n      log.info(\"Returning {0} TM matches for {1}\", results.size(), action.getQuery());\n      return new GetTranslationMemoryResult(action, results);\n   }","id":35027,"modified_method":"@Override\n   public GetTranslationMemoryResult execute(GetTranslationMemory action, ExecutionContext context) throws ActionException\n   {\n      ZanataIdentity.instance().checkLoggedIn();\n\n      log.info(\"Fetching matches for {0}\", action.getQuery());\n\n      LocaleId localeID = action.getLocaleId();\n      HLocale hLocale = localeServiceImpl.getByLocaleId(localeID);\n      ArrayList<TransMemoryResultItem> results;\n\n      try\n      {\n         // FIXME this won't scale well\n         List<Long> idsWithTranslations = textFlowDAO.findIdsWithTranslations(localeID);\n         List<Object[]> matches = textFlowDAO.getSearchResult(action.getQuery(), idsWithTranslations, MAX_RESULTS);\n         Map<TMKey, TransMemoryResultItem> matchesMap = new LinkedHashMap<TMKey, TransMemoryResultItem>(matches.size());\n         for (Object[] match : matches)\n         {\n            float score = (Float) match[0];\n            HTextFlow textFlow = (HTextFlow) match[1];\n            if (textFlow == null)\n            {\n               continue;\n            }\n            else\n            {\n               HProjectIteration projectIteration = textFlow.getDocument().getProjectIteration();\n               if (projectIteration.getStatus() == EntityStatus.OBSOLETE || projectIteration.getProject().getStatus() == EntityStatus.OBSOLETE)\n               {\n                  continue;\n               }\n            }\n            HTextFlowTarget target = textFlow.getTargets().get(hLocale);\n            // double check in case of caching issues\n            if (target == null || target.getState() != ContentState.Approved)\n            {\n               continue;\n            }\n\n            double percent;\n            if (action.getQuery().getSearchType() == SearchType.FUZZY_PLURAL)\n            {\n               percent = 100 * LevenshteinUtil.getSimilarity(action.getQuery().getQueries(), textFlow.getContents());\n            }\n            else\n            {\n               final String searchText = action.getQuery().getQueries().get(0);\n               percent = 100 * LevenshteinUtil.getSimilarity(searchText, textFlow.getContents());\n            }\n            ArrayList<String> textFlowContents = new ArrayList<String>(textFlow.getContents());\n            ArrayList<String> targetContents = new ArrayList<String>(target.getContents());\n            TMKey key = new TMKey(textFlowContents, targetContents);\n            TransMemoryResultItem item = matchesMap.get(key);\n            if (item == null)\n            {\n               item = new TransMemoryResultItem(textFlowContents, targetContents, score, percent);\n               matchesMap.put(key, item);\n            }\n            item.addSourceId(textFlow.getId());\n         }\n         results = new ArrayList<TransMemoryResultItem>(matchesMap.values());\n      }\n      catch (ParseException e)\n      {\n         if (action.getQuery().getSearchType() == SearchType.RAW)\n         {\n            // TODO tell the user\n            log.warn(\"Can't parse raw query \" + action.getQuery());\n         }\n         else\n         {\n            // escaping failed!\n            log.error(\"Can't parse query \" + action.getQuery(), e);\n         }\n         results = new ArrayList<TransMemoryResultItem>(0);\n      }\n\n      /**\n       * NB just because this Comparator returns 0 doesn't mean the matches are\n       * identical.\n       */\n      Comparator<TransMemoryResultItem> comp = new Comparator<TransMemoryResultItem>()\n      {\n\n         @Override\n         public int compare(TransMemoryResultItem m1, TransMemoryResultItem m2)\n         {\n            int result;\n            result = Double.compare(m1.getSimilarityPercent(), m2.getSimilarityPercent());\n            if (result != 0)\n            {\n               // sort higher similarity first\n               return -result;\n            }\n            result = compare(m1.getSourceContents(), m2.getSourceContents());\n            // sort longer string lists first (more plural forms)\n            return -result;\n         }\n\n         private int compare(List<String> list1, List<String> list2)\n         {\n            for (int i = 0; i < list1.size() && i < list2.size(); i++)\n            {\n               String s1 = list1.get(i);\n               String s2 = list2.get(i);\n               int comp = s1.compareTo(s2);\n               if (comp != 0)\n               {\n                  return comp;\n               }\n            }\n            if (list1.size() < list2.size())\n            {\n               return -1;\n            }\n            else if (list1.size() > list2.size())\n            {\n               return 1;\n            }\n            return 0;\n         }\n\n      };\n\n      Collections.sort(results, comp);\n\n      log.info(\"Returning {0} TM matches for {1}\", results.size(), action.getQuery());\n      return new GetTranslationMemoryResult(action, results);\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * @param source\n    * @param target\n    * @param relevanceScore\n    * @param similarityPercent\n    */\n   public GlossaryResultItem(String source, String target, float relevanceScore, int similarityPercent)\n   {\n      super(relevanceScore, similarityPercent);\n      this.source = source;\n      this.target = target;\n   }","id":35028,"modified_method":"/**\n    * @param source\n    * @param target\n    * @param relevanceScore\n    * @param similarityPercent\n    */\n   public GlossaryResultItem(String source, String target, double relevanceScore, double similarityPercent)\n   {\n      super(relevanceScore, similarityPercent);\n      this.source = source;\n      this.target = target;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void highlight()\n   {\n      Element element = getElement().getFirstChildElement();\n      String text = plainText == null ? \"\" : plainText.replaceAll(\"\\n\", \"¶\\n\");\n      Highlighting.syntaxHighlight(text, element);\n      element.addClassName(\"cm-s-default\");\n   }","id":35029,"modified_method":"private void highlight()\n   {\n      Element preElement = getElement().getFirstChildElement();\n      String text = plainText == null ? \"\" : plainText.replaceAll(\"\\n\", \"¶\\n\");\n      Highlighting.syntaxHighlight(text, preElement);\n      preElement.addClassName(\"cm-s-default\");\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"public HighlightingLabelGlossaryColumn(boolean displaySource, boolean displayTarget)\n   {\n      super(new HighlightingLabelCell());\n      this.displaySource = displaySource;\n      this.displayTarget = displayTarget;\n   }","id":35030,"modified_method":"public HighlightingLabelGlossaryColumn(boolean displaySource, boolean displayTarget)\n   {\n      super(new StaticWidgetCell<HighlightingLabel>());\n      this.displaySource = displaySource;\n      this.displayTarget = displayTarget;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"public int getSimilarityPercent()\n   {\n      return similarityPercent;\n   }","id":35031,"modified_method":"public double getSimilarityPercent()\n   {\n      return similarityPercent;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected SearchResultItem(float relevanceScore, int similarityPercent)\n   {\n      this.relevanceScore = relevanceScore;\n      this.similarityPercent = similarityPercent;\n   }","id":35032,"modified_method":"protected SearchResultItem(double relevanceScore, double similarityPercent)\n   {\n      this.relevanceScore = relevanceScore;\n      this.similarityPercent = similarityPercent;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"public float getRelevanceScore()\n   {\n      return relevanceScore;\n   }","id":35033,"modified_method":"public double getRelevanceScore()\n   {\n      return relevanceScore;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public String getValue(T object)\n   {\n      return object.getSimilarityPercent() + \"%\";\n   }","id":35034,"modified_method":"@Override\n   public String getValue(T object)\n   {\n      return (int) object.getSimilarityPercent() + \"%\";\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * @param sourceContents\n    * @param targetContents\n    * @param relevanceScore\n    * @param similarityPercent\n    */\n   public TransMemoryResultItem(ArrayList<String> sourceContents, ArrayList<String> targetContents, float relevanceScore, int similarityPercent)\n   {\n      super(relevanceScore, similarityPercent);\n      this.sourceContents = sourceContents;\n      this.targetContents = targetContents;\n   }","id":35035,"modified_method":"/**\n    * @param sourceContents\n    * @param targetContents\n    * @param relevanceScore\n    * @param similarityPercent\n    */\n   public TransMemoryResultItem(ArrayList<String> sourceContents, ArrayList<String> targetContents, double relevanceScore, double similarityPercent)\n   {\n      super(relevanceScore, similarityPercent);\n      this.sourceContents = sourceContents;\n      this.targetContents = targetContents;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TransMemorySourceColumn()\n   {\n      super(new DiffMatchPatchLabelCell());\n   }","id":35036,"modified_method":"public TransMemorySourceColumn()\n   {\n      super(new StaticWidgetCell<VerticalPanel>());\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public DiffMatchPatchLabel getValue(TransMemoryResultItem object)\n   {\n      DiffMatchPatchLabel label = new DiffMatchPatchLabel();\n      // FIXME display multiple source/target strings\n      label.setOriginal(queries.get(0));\n      label.setText(object.getSource());\n      return label;\n   }","id":35037,"modified_method":"@Override\n   public VerticalPanel getValue(TransMemoryResultItem object)\n   {\n      VerticalPanel panel = new VerticalPanel();\n      ArrayList<String> sourceContents = object.getSourceContents();\n\n      // display multiple source/target strings\n      for (int i = 0; i < sourceContents.size(); i++)\n      {\n         String sourceContent = sourceContents.get(i);\n         String query;\n         if (queries.size() > i)\n         {\n            query = queries.get(i);\n         }\n         else\n         {\n            query = queries.get(0);\n         }\n         DiffMatchPatchLabel label = new DiffMatchPatchLabel();\n         label.setOriginal(query);\n         label.setText(sourceContent);\n         panel.add(label);\n      }\n      return panel;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"public TransMemoryTargetColumn()\n   {\n      super(new HighlightingLabelCell());\n   }","id":35038,"modified_method":"public TransMemoryTargetColumn()\n   {\n      super(new StaticWidgetCell<VerticalPanel>());\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public HighlightingLabel getValue(TransMemoryResultItem object)\n   {\n      HighlightingLabel label = new HighlightingLabel();\n      label.setText(object.getTarget());\n      return label;\n   }","id":35039,"modified_method":"@Override\n   public VerticalPanel getValue(TransMemoryResultItem object)\n   {\n      VerticalPanel panel = new VerticalPanel();\n      // display multiple source/target strings\n      for (String targetContent : object.getTargetContents())\n      {\n         HighlightingLabel label = new HighlightingLabel();\n         label.setText(targetContent);\n         panel.add(label);\n      }\n      return panel;\n   }","commit_id":"6d052f1be733567ae5863847fce97f8ea2bb0058","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void showAndHideTransparencyBar(CommonPreference<Integer> transparenPreference,\n\t\t\tBaseMapLayer[] layerToChange) {\n\t\tshowAndHideTransparencyBar(transparenPreference, layerToChange, SHOW_SEEKBAR_DELAY);\n\t}","id":35040,"modified_method":"public void showTransparencyBar(CommonPreference<Integer> transparenPreference,\n\t\t\tBaseMapLayer[] layerToChange) {\n\t\ttransparencyBarLayout.setVisibility(View.VISIBLE);\n\t\ttransparencyBar.setProgress(transparenPreference.get());\n\t\tthis.transparencyLayers = layerToChange;\n\t\tthis.settingsToTransparency = transparenPreference;\n\t}","commit_id":"3954769eabf01f2088d8b48e17cf437da2fa2670","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void showAndHideTransparencyBar(CommonPreference<Integer> transparenPreference,\n\t\t\tBaseMapLayer[] layerToChange, int delay) {\n\t\ttransparencyBar.setVisibility(View.VISIBLE);\n\t\ttransparencyBar.setProgress(transparenPreference.get());\n\t\tthis.transparencyLayers = layerToChange;\n\t\tthis.settingsToTransparency = transparenPreference;\n\t\tMessage msg = Message.obtain(showUIHandler, new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttransparencyBar.setVisibility(View.GONE);\n\t\t\t}\n\n\t\t});\n\t\tmsg.what = SHOW_SEEKBAR_MSG_ID;\n\t\tshowUIHandler.removeMessages(SHOW_SEEKBAR_MSG_ID);\n\t\tshowUIHandler.sendMessageDelayed(msg, delay);\n\t}","id":35041,"modified_method":"public void hideTransparencyBar(CommonPreference<Integer> transparenPreference) {\n\t\tif(this.settingsToTransparency  == transparenPreference) {\n\t\t\ttransparencyBarLayout.setVisibility(View.GONE);\n\t\t\tthis.settingsToTransparency = null;\n\t\t}\n\t}","commit_id":"3954769eabf01f2088d8b48e17cf437da2fa2670","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void initTransparencyBar(final OsmandMapTileView view, FrameLayout parent) {\n\t\tint minimumHeight = view.getResources().getDrawable(R.drawable.map_zoom_in).getMinimumHeight();\n\t\tandroid.widget.FrameLayout.LayoutParams params;\n\t\ttransparencyBar = new SeekBar(view.getContext());\n\t\ttransparencyBar.setVisibility(View.GONE);\n\t\ttransparencyBar.setMax(255);\n\t\tparams = new FrameLayout.LayoutParams((int) (scaleCoefficient * 100), LayoutParams.WRAP_CONTENT,\n\t\t\t\tGravity.BOTTOM | Gravity.CENTER);\n\t\tparams.setMargins(0, 0, 0, minimumHeight + 3);\n\t\tparent.addView(transparencyBar, params);\n\t\ttransparencyBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onStopTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onStartTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n\t\t\t\tif(settingsToTransparency != null && transparencyLayers != null){\n\t\t\t\t\tsettingsToTransparency.set(progress);\n\t\t\t\t\tfor(BaseMapLayer base : transparencyLayers){\n\t\t\t\t\t\tbase.setAlpha(progress);\n\t\t\t\t\t}\n\t\t\t\t\tMapControlsLayer.this.view.refreshMap();\n\t\t\t\t\tshowAndHideTransparencyBar(settingsToTransparency, transparencyLayers, SHOW_SEEKBAR_SECOND_DELAY);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","id":35042,"modified_method":"private void initTransparencyBar(final OsmandMapTileView view, FrameLayout parent) {\n\t\tint minimumHeight = view.getResources().getDrawable(R.drawable.map_zoom_in).getMinimumHeight();\n\t\tandroid.widget.FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT,\n\t\t\t\tGravity.BOTTOM | Gravity.CENTER);\n\t\tparams.setMargins(0, 0, 0, minimumHeight + 3);\n\t\ttransparencyBarLayout = new LinearLayout(view.getContext());\n\t\ttransparencyBarLayout.setVisibility(View.GONE);\n\t\tparent.addView(transparencyBarLayout, params);\n\n\t\ttransparencyBar = new SeekBar(view.getContext());\n\t\ttransparencyBar.setMax(255);\n\t\ttransparencyBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onStopTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onStartTrackingTouch(SeekBar seekBar) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {\n\t\t\t\tif (settingsToTransparency != null && transparencyLayers != null) {\n\t\t\t\t\tsettingsToTransparency.set(progress);\n\t\t\t\t\tfor (BaseMapLayer base : transparencyLayers) {\n\t\t\t\t\t\tbase.setAlpha(progress);\n\t\t\t\t\t}\n\t\t\t\t\tMapControlsLayer.this.view.refreshMap();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tandroid.widget.LinearLayout.LayoutParams prms = new LinearLayout.LayoutParams((int) (scaleCoefficient * 100),\n\t\t\t\tLayoutParams.WRAP_CONTENT);\n\t\ttransparencyBarLayout.addView(transparencyBar, prms);\n\t\tImageButton imageButton = new ImageButton(view.getContext());\n\t\tprms = new LinearLayout.LayoutParams(LayoutParams.WRAP_CONTENT, LayoutParams.WRAP_CONTENT);\n\t\tprms.setMargins((int) (2 * scaleCoefficient), (int) (2 * scaleCoefficient), 0, 0);\n\t\timageButton.setOnClickListener(new OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\ttransparencyBarLayout.setVisibility(View.GONE);\n\t\t\t}\n\t\t});\n\t\timageButton.setContentDescription(view.getContext().getString(R.string.close));\n\t\timageButton.setBackgroundResource(R.drawable.headliner_close);\n\t\ttransparencyBarLayout.addView(imageButton, prms);\n\t}","commit_id":"3954769eabf01f2088d8b48e17cf437da2fa2670","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void registerLayerContextMenuActions(final OsmandMapTileView mapView, ContextMenuAdapter adapter, final MapActivity mapActivity) {\n\t\tfinal MapActivityLayers layers = mapActivity.getMapLayers();\n\t\tOnContextMenuClick listener = new OnContextMenuClick() {\n\t\t\t@Override\n\t\t\tpublic void onContextMenuClick(int itemId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\tif (itemId == R.string.layer_map) {\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\tlayers.selectMapLayer(mapView);\n\t\t\t\t} else if(itemId == R.string.layer_overlay){\n\t\t\t\t\tif(overlayLayer.getMap() != null){\n\t\t\t\t\t\tsettings.MAP_OVERLAY.set(null);\n\t\t\t\t\t\tupdateMapLayers(mapView, null, layers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\t\tselectMapOverlayLayer(mapView, settings.MAP_OVERLAY, settings.MAP_OVERLAY_TRANSPARENCY, mapActivity, \n\t\t\t\t\t\t\t\toverlayLayer);\n\t\t\t\t\t}\n\t\t\t\t} else if(itemId == R.string.layer_underlay){\n\t\t\t\t\tif(underlayLayer.getMap() != null){\n\t\t\t\t\t\tsettings.MAP_UNDERLAY.set(null);\n\t\t\t\t\t\tupdateMapLayers(mapView, null, layers);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\t\tselectMapOverlayLayer(mapView, settings.MAP_UNDERLAY,settings.MAP_TRANSPARENCY,\n\t\t\t\t\t\t\t\tmapActivity, layers.getMapTileLayer(), layers.getMapVectorLayer());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tadapter.registerSelectedItem(R.string.layer_map, -1, R.drawable.list_activities_map_src, listener, 0);\n\t\tadapter.registerSelectedItem(R.string.layer_overlay, overlayLayer.getMap() != null ? 1 : 0, \n\t\t\t\tR.drawable.list_activities_overlay_map, listener, -1);\n\t\tadapter.registerSelectedItem(R.string.layer_underlay, underlayLayer.getMap() != null ? 1 : 0, \n\t\t\t\tR.drawable.list_activities_underlay_map, listener, -1);\n\t}","id":35043,"modified_method":"@Override\n\tpublic void registerLayerContextMenuActions(final OsmandMapTileView mapView, ContextMenuAdapter adapter, final MapActivity mapActivity) {\n\t\tfinal MapActivityLayers layers = mapActivity.getMapLayers();\n\t\tOnContextMenuClick listener = new OnContextMenuClick() {\n\t\t\t@Override\n\t\t\tpublic void onContextMenuClick(int itemId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\tif (itemId == R.string.layer_map) {\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\tlayers.selectMapLayer(mapView);\n\t\t\t\t} else if(itemId == R.string.layer_overlay){\n\t\t\t\t\tif(overlayLayer.getMap() != null){\n\t\t\t\t\t\tsettings.MAP_OVERLAY.set(null);\n\t\t\t\t\t\tupdateMapLayers(mapView, null, layers);\n\t\t\t\t\t\tlayers.getMapControlsLayer().hideTransparencyBar(settings.MAP_OVERLAY_TRANSPARENCY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\t\tselectMapOverlayLayer(mapView, settings.MAP_OVERLAY, settings.MAP_OVERLAY_TRANSPARENCY, mapActivity, \n\t\t\t\t\t\t\t\toverlayLayer);\n\t\t\t\t\t}\n\t\t\t\t} else if(itemId == R.string.layer_underlay){\n\t\t\t\t\tif(underlayLayer.getMap() != null){\n\t\t\t\t\t\tsettings.MAP_UNDERLAY.set(null);\n\t\t\t\t\t\tupdateMapLayers(mapView, null, layers);\n\t\t\t\t\t\tlayers.getMapControlsLayer().hideTransparencyBar(settings.MAP_TRANSPARENCY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\t\tselectMapOverlayLayer(mapView, settings.MAP_UNDERLAY,settings.MAP_TRANSPARENCY,\n\t\t\t\t\t\t\t\tmapActivity, layers.getMapTileLayer(), layers.getMapVectorLayer());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tadapter.registerSelectedItem(R.string.layer_map, -1, R.drawable.list_activities_map_src, listener, 0);\n\t\tadapter.registerSelectedItem(R.string.layer_overlay, overlayLayer.getMap() != null ? 1 : 0, \n\t\t\t\tR.drawable.list_activities_overlay_map, listener, -1);\n\t\tadapter.registerSelectedItem(R.string.layer_underlay, underlayLayer.getMap() != null ? 1 : 0, \n\t\t\t\tR.drawable.list_activities_underlay_map, listener, -1);\n\t}","commit_id":"3954769eabf01f2088d8b48e17cf437da2fa2670","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void selectMapOverlayLayer(final OsmandMapTileView mapView, \n\t\t\tfinal CommonPreference<String> mapPref, final CommonPreference<Integer> transparencyPref,\n\t\t\tfinal MapActivity activity,\n\t\t\tfinal BaseMapLayer... transparencyToChange){\n\t\tfinal OsmandSettings settings = app.getSettings();\n\t\tfinal MapActivityLayers layers = activity.getMapLayers();\n\t\tMap<String, String> entriesMap = settings.getTileSourceEntries();\n\t\tfinal ArrayList<String> keys = new ArrayList<String>(entriesMap.keySet());\n\t\tBuilder builder = new AlertDialog.Builder(activity);\n\t\tfinal String[] items = new String[entriesMap.size() + 1];\n\t\tint i = 0;\n\t\tfor(String it : entriesMap.values()){\n\t\t\titems[i++] = it;\n\t\t}\n\t\t\n\t\titems[i] = app.getString(R.string.install_more);\n\t\tbuilder.setSingleChoiceItems(items, -1, new DialogInterface.OnClickListener(){\n\t\t\t@Override\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\tif (which == items.length - 1){\n\t\t\t\t\tSettingsActivity.installMapLayers(activity, new ResultMatcher<TileSourceTemplate>() {\n\t\t\t\t\t\tTileSourceTemplate template = null;\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean publish(TileSourceTemplate object) {\n\t\t\t\t\t\t\tif(object == null){\n\t\t\t\t\t\t\t\tif(count == 1){\n\t\t\t\t\t\t\t\t\tmapPref.set(template.getName());\n\t\t\t\t\t\t\t\t\tlayers.getMapControlsLayer().showAndHideTransparencyBar(transparencyPref, transparencyToChange);\n\t\t\t\t\t\t\t\t\tupdateMapLayers(mapView, mapPref, layers);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tselectMapOverlayLayer(mapView, mapPref, transparencyPref, activity, transparencyToChange);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\t\ttemplate = object;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tmapPref.set(keys.get(which));\n\t\t\t\t\tlayers.getMapControlsLayer().showAndHideTransparencyBar(transparencyPref, transparencyToChange);\n\t\t\t\t\tupdateMapLayers(mapView, mapPref, layers);\n\t\t\t\t}\n\t\t\t\tdialog.dismiss();\n\t\t\t}\n\t\t\t\n\t\t});\n\t\tbuilder.show();\n\t}","id":35044,"modified_method":"public void selectMapOverlayLayer(final OsmandMapTileView mapView, \n\t\t\tfinal CommonPreference<String> mapPref, final CommonPreference<Integer> transparencyPref,\n\t\t\tfinal MapActivity activity,\n\t\t\tfinal BaseMapLayer... transparencyToChange){\n\t\tfinal OsmandSettings settings = app.getSettings();\n\t\tfinal MapActivityLayers layers = activity.getMapLayers();\n\t\tMap<String, String> entriesMap = settings.getTileSourceEntries();\n\t\tfinal ArrayList<String> keys = new ArrayList<String>(entriesMap.keySet());\n\t\tBuilder builder = new AlertDialog.Builder(activity);\n\t\tfinal String[] items = new String[entriesMap.size() + 1];\n\t\tint i = 0;\n\t\tfor(String it : entriesMap.values()){\n\t\t\titems[i++] = it;\n\t\t}\n\t\t\n\t\titems[i] = app.getString(R.string.install_more);\n\t\tbuilder.setSingleChoiceItems(items, -1, new DialogInterface.OnClickListener(){\n\t\t\t@Override\n\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\tif (which == items.length - 1){\n\t\t\t\t\tSettingsActivity.installMapLayers(activity, new ResultMatcher<TileSourceTemplate>() {\n\t\t\t\t\t\tTileSourceTemplate template = null;\n\t\t\t\t\t\tint count = 0;\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean publish(TileSourceTemplate object) {\n\t\t\t\t\t\t\tif(object == null){\n\t\t\t\t\t\t\t\tif(count == 1){\n\t\t\t\t\t\t\t\t\tmapPref.set(template.getName());\n\t\t\t\t\t\t\t\t\tlayers.getMapControlsLayer().showTransparencyBar(transparencyPref, transparencyToChange);\n\t\t\t\t\t\t\t\t\tupdateMapLayers(mapView, mapPref, layers);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tselectMapOverlayLayer(mapView, mapPref, transparencyPref, activity, transparencyToChange);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcount ++;\n\t\t\t\t\t\t\t\ttemplate = object;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tmapPref.set(keys.get(which));\n\t\t\t\t\tlayers.getMapControlsLayer().showTransparencyBar(transparencyPref, transparencyToChange);\n\t\t\t\t\tupdateMapLayers(mapView, mapPref, layers);\n\t\t\t\t}\n\t\t\t\tdialog.dismiss();\n\t\t\t}\n\t\t\t\n\t\t});\n\t\tbuilder.show();\n\t}","commit_id":"3954769eabf01f2088d8b48e17cf437da2fa2670","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void processInterceptors(EnterpriseBeanMetaData enterpriseBean, EJBComponentDescription ejbComponentDescription) {\n\n        EjbJarMetaData ejbJarMetaData = enterpriseBean.getEjbJarMetaData();\n        String ejbName = enterpriseBean.getEjbName();\n        InterceptorsMetaData applicableInterceptors = EjbJarMetaData.getInterceptors(ejbName, ejbJarMetaData);\n        if (applicableInterceptors != null) {\n            for (InterceptorMetaData interceptor : applicableInterceptors) {\n                // get (or create the interceptor description)\n                InterceptorDescription interceptorDescription = ejbComponentDescription.getClassInterceptor(interceptor.getInterceptorClass());\n                if (interceptorDescription == null) {\n                    interceptorDescription = new InterceptorDescription(interceptor.getInterceptorClass());\n                    ejbComponentDescription.addClassInterceptor(interceptorDescription);\n                }\n\n                // around-invoke(s) of the interceptor configured (if any) in the deployment descriptor\n                AroundInvokesMetaData aroundInvokes = interceptor.getAroundInvokes();\n                if (aroundInvokes != null) {\n                    for (AroundInvokeMetaData aroundInvoke : aroundInvokes) {\n                        String methodName = aroundInvoke.getMethodName();\n                        MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifier(Object.class, methodName, new Class<?>[]{InvocationContext.class});\n                        // TODO: This constructor for InterceptorMethodDescription needs a review. How does one get hold of the \"declaraingClass\"\n                        // for a DD based interceptor configuration. Why not just specify the instance class and then \"find\" the correct method\n                        // internally\n                        InterceptorMethodDescription aroundInvokeMethodDescription = new InterceptorMethodDescription(interceptor.getInterceptorClass(), methodIdentifier);\n                        // add the around-invoke to the interceptor description\n                        interceptorDescription.addAroundInvokeMethod(aroundInvokeMethodDescription);\n                    }\n                }\n\n                // post-construct(s) of the interceptor configured (if any) in the deployment descriptor\n                LifecycleCallbacksMetaData postConstructs = interceptor.getPostConstructs();\n                if (postConstructs != null) {\n                    for (LifecycleCallbackMetaData postConstruct : postConstructs) {\n                        String methodName = postConstruct.getMethodName();\n                        MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifier(Void.TYPE, methodName, new Class<?>[]{InvocationContext.class});\n                        // TODO: This constructor for InterceptorMethodDescription needs a review. How does one get hold of the \"declaraingClass\"\n                        // for a DD based interceptor configuration. Why not just specify the instance class and then \"find\" the correct method\n                        // internally\n                        InterceptorMethodDescription postConstructInterceptor = new InterceptorMethodDescription(interceptor.getInterceptorClass(), methodIdentifier);\n                        // add it to the interceptor description\n                        interceptorDescription.addPostConstruct(postConstructInterceptor);\n                    }\n                }\n\n                // pre-destroy(s) of the interceptor configured (if any) in the deployment descriptor\n                LifecycleCallbacksMetaData preDestroys = interceptor.getPreDestroys();\n                if (preDestroys != null) {\n                    for (LifecycleCallbackMetaData preDestroy : preDestroys) {\n                        String methodName = preDestroy.getMethodName();\n                        MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifier(Void.TYPE, methodName, new Class<?>[]{InvocationContext.class});\n                        // TODO: This constructor for InterceptorMethodDescription needs a review. How does one get hold of the \"declaraingClass\"\n                        // for a DD based interceptor configuration. Why not just specify the instance class and then \"find\" the correct method\n                        // internally\n                        InterceptorMethodDescription preDestroyInterceptor = new InterceptorMethodDescription(interceptor.getInterceptorClass(), methodIdentifier);\n                        // add it to the interceptor description\n                        interceptorDescription.addPreDestroy(preDestroyInterceptor);\n                    }\n                }\n            }\n        }\n\n    }","id":35045,"modified_method":"protected void processInterceptors(EnterpriseBeanMetaData enterpriseBean, EJBComponentDescription ejbComponentDescription) {\n\n        EjbJarMetaData ejbJarMetaData = enterpriseBean.getEjbJarMetaData();\n        String ejbName = enterpriseBean.getEjbName();\n        InterceptorsMetaData applicableInterceptors = EjbJarMetaData.getInterceptors(ejbName, ejbJarMetaData);\n        if (applicableInterceptors != null) {\n            for (InterceptorMetaData interceptor : applicableInterceptors) {\n                String interceptorClassName = interceptor.getInterceptorClass();\n                // get (or create the interceptor description)\n                InterceptorDescription interceptorDescription = ejbComponentDescription.getClassInterceptor(interceptorClassName);\n                if (interceptorDescription == null) {\n                    interceptorDescription = new InterceptorDescription(interceptorClassName);\n                    ejbComponentDescription.addClassInterceptor(interceptorDescription);\n                }\n                EEModuleClassDescription interceptorModuleClassDescription = ejbComponentDescription.getModuleDescription().getOrAddClassByName(interceptorClassName);\n                // around-invoke(s) of the interceptor configured (if any) in the deployment descriptor\n                AroundInvokesMetaData aroundInvokes = interceptor.getAroundInvokes();\n                if (aroundInvokes != null) {\n                    for (AroundInvokeMetaData aroundInvoke : aroundInvokes) {\n                        String methodName = aroundInvoke.getMethodName();\n                        MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifier(Object.class, methodName, new Class<?>[]{InvocationContext.class});\n                        interceptorModuleClassDescription.setAroundInvokeMethod(methodIdentifier);\n                    }\n                }\n\n                // post-construct(s) of the interceptor configured (if any) in the deployment descriptor\n                LifecycleCallbacksMetaData postConstructs = interceptor.getPostConstructs();\n                if (postConstructs != null) {\n                    for (LifecycleCallbackMetaData postConstruct : postConstructs) {\n                        String methodName = postConstruct.getMethodName();\n                        MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifier(Void.TYPE, methodName, new Class<?>[]{InvocationContext.class});\n                        // add it to the interceptor description\n                        interceptorModuleClassDescription.setPostConstructMethod(methodIdentifier);\n                    }\n                }\n\n                // pre-destroy(s) of the interceptor configured (if any) in the deployment descriptor\n                LifecycleCallbacksMetaData preDestroys = interceptor.getPreDestroys();\n                if (preDestroys != null) {\n                    for (LifecycleCallbackMetaData preDestroy : preDestroys) {\n                        String methodName = preDestroy.getMethodName();\n                        MethodIdentifier methodIdentifier = MethodIdentifier.getIdentifier(Void.TYPE, methodName, new Class<?>[]{InvocationContext.class});\n                        // add it to the interceptor description\n                        interceptorModuleClassDescription.setPreDestroyMethod(methodIdentifier);\n                    }\n                }\n            }\n        }\n\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testImplicitLocalBusinessInterface() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        when(deploymentUnit.getServiceName()).thenReturn(ServiceName.parse(\"test\"));\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        Class<?> ejbClass = ImplicitLocalBusinessInterfaceBean.class;\n        index(indexer, ejbClass);\n        index(indexer, MyInterface.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestModule\", \"TestApp\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        SessionBeanComponentDescription componentDescription = new StatelessComponentDescription(ejbClass.getSimpleName(), ejbClass.getName(), ejbJarDescription);\n        BusinessViewAnnotationProcessor processor = new BusinessViewAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(asSet(MyInterface.class.getName()), componentDescription.getViewClassNames());\n        assertEquals(MethodIntf.LOCAL, componentDescription.getMethodIntf(MyInterface.class.getName()));\n    }","id":35046,"modified_method":"@Test\n    public void testImplicitLocalBusinessInterface() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        when(deploymentUnit.getServiceName()).thenReturn(ServiceName.parse(\"test\"));\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        Class<?> ejbClass = ImplicitLocalBusinessInterfaceBean.class;\n        index(indexer, ejbClass);\n        index(indexer, MyInterface.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestModule\", \"TestApp\");\n\n        final ServiceName duServiceName = deploymentUnit.getServiceName();\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        SessionBeanComponentDescription componentDescription = new StatelessComponentDescription(ejbClass.getSimpleName(), ejbClass.getName(), ejbJarDescription, duServiceName);\n        BusinessViewAnnotationProcessor processor = new BusinessViewAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        List<ViewDescription> views = componentDescription.getViews();\n        assertNotNull(\"No views found\", views);\n        assertEquals(\"Unexpected number of views\", 1, views.size());\n        assertEquals(MyInterface.class.getName(), views.get(0).getViewClassName());\n        assertEquals(MethodIntf.LOCAL, componentDescription.getMethodIntf(MyInterface.class.getName()));\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void test1() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        when(deploymentUnit.getServiceName()).thenReturn(ServiceName.parse(\"test\"));\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        index(indexer, MyInterface.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestModule\", \"TestApp\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(MyBean.class.getSimpleName(), MyBean.class.getName(), ejbJarDescription);\n        BusinessViewAnnotationProcessor processor = new BusinessViewAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(asSet(MyInterface.class.getName()), componentDescription.getViewClassNames());\n        assertEquals(MethodIntf.LOCAL, componentDescription.getMethodIntf(MyInterface.class.getName()));\n    }","id":35047,"modified_method":"@Test\n    public void test1() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        when(deploymentUnit.getServiceName()).thenReturn(ServiceName.parse(\"test\"));\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        index(indexer, MyInterface.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestModule\", \"TestApp\");\n\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        final ServiceName duServiceName = deploymentUnit.getServiceName();\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(MyBean.class.getSimpleName(), MyBean.class.getName(), ejbJarDescription, duServiceName);\n\n        BusinessViewAnnotationProcessor processor = new BusinessViewAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        List<ViewDescription> views = componentDescription.getViews();\n        assertNotNull(\"No views found\", views);\n        assertEquals(\"Unexpected number of views\", 1, views.size());\n        assertEquals(MyInterface.class.getName(), views.get(0).getViewClassName());\n        assertEquals(MethodIntf.LOCAL, componentDescription.getMethodIntf(MyInterface.class.getName()));\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testImplicitNoInterface() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        when(deploymentUnit.getServiceName()).thenReturn(ServiceName.parse(\"test\"));\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        Class<?> ejbClass = ImplicitNoInterfaceBean.class;\n        index(indexer, ejbClass);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestModule\", \"TestApp\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        SessionBeanComponentDescription componentDescription = new StatelessComponentDescription(ImplicitNoInterfaceBean.class.getSimpleName(), ImplicitNoInterfaceBean.class.getName(), ejbJarDescription);\n        BusinessViewAnnotationProcessor processor = new BusinessViewAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertTrue(\"Bean should have no-interface view (EJB 3.1 FR 4.9.8 bullet 1.1)\", componentDescription.hasNoInterfaceView());\n        assertEquals(asSet(ImplicitNoInterfaceBean.class.getName()), componentDescription.getViewClassNames());\n        assertEquals(MethodIntf.LOCAL, componentDescription.getMethodIntf(ImplicitNoInterfaceBean.class.getName()));\n    }","id":35048,"modified_method":"@Test\n    public void testImplicitNoInterface() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        when(deploymentUnit.getServiceName()).thenReturn(ServiceName.parse(\"test\"));\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        Class<?> ejbClass = ImplicitNoInterfaceBean.class;\n        index(indexer, ejbClass);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestModule\", \"TestApp\");\n\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        final ServiceName duServiceName = deploymentUnit.getServiceName();\n        SessionBeanComponentDescription componentDescription = new StatelessComponentDescription(ImplicitNoInterfaceBean.class.getSimpleName(), ImplicitNoInterfaceBean.class.getName(), ejbJarDescription, duServiceName);\n        BusinessViewAnnotationProcessor processor = new BusinessViewAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertTrue(\"Bean should have no-interface view (EJB 3.1 FR 4.9.8 bullet 1.1)\", componentDescription.hasNoInterfaceView());\n        List<ViewDescription> views = componentDescription.getViews();\n        assertNotNull(\"No views found\", views);\n        assertEquals(\"Unexpected number of views\", 1, views.size());\n        assertEquals(ImplicitNoInterfaceBean.class.getName(), views.get(0).getViewClassName());\n        assertEquals(MethodIntf.LOCAL, componentDescription.getMethodIntf(ImplicitNoInterfaceBean.class.getName()));\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param componentName      the component name\n     * @param componentClassName the component instance class name\n     * @param moduleDescription  the EE module description\n     * @param classDescription   the component class' description\n     * @param deploymentUnitServiceName the service name of the DU containing this component\n     */\n    public ComponentDescription(final String componentName, final String componentClassName, final EEModuleDescription moduleDescription, final EEModuleClassDescription classDescription, final ServiceName deploymentUnitServiceName) {\n        this.moduleDescription = moduleDescription;\n        this.classDescription = classDescription;\n        serviceName = deploymentUnitServiceName.append(\"component\");\n        if (componentName == null) {\n            throw new IllegalArgumentException(\"name is null\");\n        }\n        if (componentClassName == null) {\n            throw new IllegalArgumentException(\"className is null\");\n        }\n        if (moduleDescription == null) {\n            throw new IllegalArgumentException(\"moduleName is null\");\n        }\n        if (classDescription == null) {\n            throw new IllegalArgumentException(\"classDescription is null\");\n        }\n        if (deploymentUnitServiceName == null) {\n            throw new IllegalArgumentException(\"deploymentUnitServiceName is null\");\n        }\n        this.componentName = componentName;\n        this.componentClassName = componentClassName;\n        configurators.addLast(FIRST_CONFIGURATOR);\n    }","id":35049,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param componentName      the component name\n     * @param componentClassName the component instance class name\n     * @param moduleDescription  the EE module description\n     * @param classDescription   the component class' description\n     * @param deploymentUnitServiceName the service name of the DU containing this component\n     */\n    public ComponentDescription(final String componentName, final String componentClassName, final EEModuleDescription moduleDescription, final EEModuleClassDescription classDescription, final ServiceName deploymentUnitServiceName) {\n        this.moduleDescription = moduleDescription;\n        this.classDescription = classDescription;\n        if (componentName == null) {\n            throw new IllegalArgumentException(\"name is null\");\n        }\n        if (componentClassName == null) {\n            throw new IllegalArgumentException(\"className is null\");\n        }\n        if (moduleDescription == null) {\n            throw new IllegalArgumentException(\"moduleName is null\");\n        }\n        if (classDescription == null) {\n            throw new IllegalArgumentException(\"classDescription is null\");\n        }\n        if (deploymentUnitServiceName == null) {\n            throw new IllegalArgumentException(\"deploymentUnitServiceName is null\");\n        }\n        serviceName = deploymentUnitServiceName.append(\"component\");\n        this.componentName = componentName;\n        this.componentClassName = componentClassName;\n        configurators.addLast(FIRST_CONFIGURATOR);\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public EJBComponentConfiguration(final EJBComponentDescription description) {\n        super(description, INIT_ME);\n\n        description.addDependency(EJBUtilities.SERVICE_NAME, ServiceBuilder.DependencyType.REQUIRED);\n\n        // CurrentInvocationContext\n        addCurrentInvocationContextInterceptorFactory();\n\n        transactionManagementType = description.getTransactionManagementType();\n\n        // CMTTx\n        if (transactionManagementType.equals(TransactionManagementType.CONTAINER)) {\n            // slurp some memory\n            txAttrs = new ConcurrentHashMap<MethodIntf, ConcurrentMap<String, ConcurrentMap<ArrayKey, TransactionAttributeType>>>();\n\n            addComponentSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                @Override\n                protected Interceptor create(Component component, InterceptorFactoryContext context) {\n                    return new CMTTxInterceptor((TransactionalComponent) component);\n                }\n            });\n        } else {\n            txAttrs = null;\n        }\n\n    }","id":35050,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public EJBComponentConfiguration(final EJBComponentDescription description, final EEModuleClassConfiguration ejbModuleClassConfiguration) {\n        super(description, ejbModuleClassConfiguration);\n\n        description.addDependency(EJBUtilities.SERVICE_NAME, ServiceBuilder.DependencyType.REQUIRED);\n\n        // CurrentInvocationContext\n        addCurrentInvocationContextInterceptorFactory();\n\n        transactionManagementType = description.getTransactionManagementType();\n\n        // CMTTx\n        if (transactionManagementType.equals(TransactionManagementType.CONTAINER)) {\n            // slurp some memory\n            txAttrs = new ConcurrentHashMap<MethodIntf, ConcurrentMap<String, ConcurrentMap<ArrayKey, TransactionAttributeType>>>();\n\n            addComponentSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                @Override\n                protected Interceptor create(Component component, InterceptorFactoryContext context) {\n                    return new CMTTxInterceptor((TransactionalComponent) component);\n                }\n            });\n        } else {\n            txAttrs = null;\n        }\n\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void addComponentSystemInterceptorFactory(InterceptorFactory interceptorFactory) {\n        super.getComponentSystemInterceptorFactories().add(interceptorFactory);\n    }","id":35051,"modified_method":"protected void addComponentSystemInterceptorFactory(InterceptorFactory interceptorFactory) {\n        throw new RuntimeException(\"NYI\");\n        // TODO: FIXME\n        //super.getComponentSystemInterceptorFactories().add(interceptorFactory);\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * If a bean is BMT then txAttrs won't be available.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testNoTxAttrs() throws Exception {\n        final EJBComponentConfiguration configuration = mock(EJBComponentConfiguration.class);\n        when(configuration.getTransactionManagementType()).thenReturn(TransactionManagementType.BEAN);\n\n        final EEModuleDescription eeModuleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(eeModuleDescription);\n\n        final EJBComponentDescription description = new EJBComponentDescription(\"Test\", \"TestBean\", ejbJarDescription) {\n            @Override\n            public MethodIntf getMethodIntf(String viewClassName) {\n                return MethodIntf.LOCAL;\n            }\n\n            @Override\n            protected ComponentConfiguration constructComponentConfiguration() {\n                return configuration;\n            }\n        };\n        Class<?> viewClass = TestBean.class;\n        Method viewMethod = TestBean.class.getMethod(\"someMethod\");\n        Method componentMethod = null;\n        description.processViewMethod(configuration, viewClass, viewMethod, componentMethod);\n        // no NPE means pass\n    }","id":35052,"modified_method":"/**\n     * If a bean is BMT then txAttrs won't be available.\n     *\n     * @throws Exception\n     */\n    @Test\n    public void testNoTxAttrs() throws Exception {\n        final EJBComponentConfiguration configuration = mock(EJBComponentConfiguration.class);\n        when(configuration.getTransactionManagementType()).thenReturn(TransactionManagementType.BEAN);\n\n        final EEModuleDescription eeModuleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(eeModuleDescription);\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestApp\",\"TestModule\");\n        final ServiceName duServiceName = Services.deploymentUnitName(\"Dummy Deployment Unit\");\n        final EJBComponentDescription description = new EJBComponentDescription(\"Test\", \"TestBean\", ejbJarDescription, duServiceName) {\n\n            @Override\n            public MethodIntf getMethodIntf(String viewClassName) {\n                return MethodIntf.LOCAL;\n            }\n        };\n        Class<?> viewClass = TestBean.class;\n        Method viewMethod = TestBean.class.getMethod(\"someMethod\");\n        Method componentMethod = null;\n        // TODO: Review this testcase\n        // description.processViewMethod(configuration, viewClass, viewMethod, componentMethod);\n        // no NPE means pass\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void mergeSessionBean(SessionBeanComponentDescription mergedBean, SessionBeanComponentDescription original, SessionBeanComponentDescription override) {\n\n        // mapped-name\n        if (override.getMappedName() != null) {\n            mergedBean.setMappedName(override.getMappedName());\n        } else {\n            mergedBean.setMappedName(original.getMappedName());\n        }\n\n        // tx type\n        if (override.getTransactionManagementType() != null) {\n            mergedBean.setTransactionManagementType(override.getTransactionManagementType());\n        } else {\n            if (original.getTransactionManagementType() != null) {\n                mergedBean.setTransactionManagementType(original.getTransactionManagementType());\n            }\n        }\n\n        // concurrency management type\n        ConcurrencyManagementType overrideConcurrencyMgmtType = override.getConcurrencyManagementType();\n        if (overrideConcurrencyMgmtType != null) {\n            if (overrideConcurrencyMgmtType == ConcurrencyManagementType.BEAN) {\n                mergedBean.beanManagedConcurrency();\n            } else {\n                mergedBean.containerManagedConcurrency();\n            }\n        } else {\n            ConcurrencyManagementType originalConcurrencyManagemenType = original.getConcurrencyManagementType();\n            if (originalConcurrencyManagemenType != null) {\n                if (originalConcurrencyManagemenType == ConcurrencyManagementType.BEAN) {\n                    mergedBean.beanManagedConcurrency();\n                } else {\n                    mergedBean.containerManagedConcurrency();\n                }\n            }\n        }\n\n        // bean level lock type\n        LockType overrideBeanLockType = override.getBeanLevelLockType();\n        if (overrideBeanLockType != null) {\n            mergedBean.setBeanLevelLockType(overrideBeanLockType);\n        } else {\n            LockType originalBeanLockType = original.getBeanLevelLockType();\n            if (originalBeanLockType != null) {\n                mergedBean.setBeanLevelLockType(originalBeanLockType);\n            }\n        }\n\n        // access timeout\n        AccessTimeout overrideAccessTimeout = override.getBeanLevelAccessTimeout();\n        if (overrideAccessTimeout != null) {\n            mergedBean.setBeanLevelAccessTimeout(overrideAccessTimeout);\n        } else {\n            AccessTimeout originalAccessTimeout = original.getBeanLevelAccessTimeout();\n            if (originalAccessTimeout != null) {\n                mergedBean.setBeanLevelAccessTimeout(originalAccessTimeout);\n            }\n        }\n\n        // views\n        Collection<String> overrideViews = override.getViewClassNames();\n        if (overrideViews != null && !overrideViews.isEmpty()) {\n            for (String view : overrideViews) {\n                MethodIntf viewType = override.getMethodIntf(view);\n                addView(mergedBean, view, viewType);\n            }\n        } else {\n            Collection<String> originalViews = original.getViewClassNames();\n            if (originalViews != null) {\n                for (String view : originalViews) {\n                    MethodIntf viewType = original.getMethodIntf(view);\n                    addView(mergedBean, view, viewType);\n                }\n\n            }\n        }\n    }","id":35053,"modified_method":"private static void mergeSessionBean(SessionBeanComponentDescription mergedBean, SessionBeanComponentDescription original, SessionBeanComponentDescription override) {\n\n        // mapped-name\n        if (override.getMappedName() != null) {\n            mergedBean.setMappedName(override.getMappedName());\n        } else {\n            mergedBean.setMappedName(original.getMappedName());\n        }\n\n        // tx type\n        if (override.getTransactionManagementType() != null) {\n            mergedBean.setTransactionManagementType(override.getTransactionManagementType());\n        } else {\n            if (original.getTransactionManagementType() != null) {\n                mergedBean.setTransactionManagementType(original.getTransactionManagementType());\n            }\n        }\n\n        // concurrency management type\n        ConcurrencyManagementType overrideConcurrencyMgmtType = override.getConcurrencyManagementType();\n        if (overrideConcurrencyMgmtType != null) {\n            if (overrideConcurrencyMgmtType == ConcurrencyManagementType.BEAN) {\n                mergedBean.beanManagedConcurrency();\n            } else {\n                mergedBean.containerManagedConcurrency();\n            }\n        } else {\n            ConcurrencyManagementType originalConcurrencyManagemenType = original.getConcurrencyManagementType();\n            if (originalConcurrencyManagemenType != null) {\n                if (originalConcurrencyManagemenType == ConcurrencyManagementType.BEAN) {\n                    mergedBean.beanManagedConcurrency();\n                } else {\n                    mergedBean.containerManagedConcurrency();\n                }\n            }\n        }\n\n        // bean level lock type\n        LockType overrideBeanLockType = override.getBeanLevelLockType();\n        if (overrideBeanLockType != null) {\n            mergedBean.setBeanLevelLockType(overrideBeanLockType);\n        } else {\n            LockType originalBeanLockType = original.getBeanLevelLockType();\n            if (originalBeanLockType != null) {\n                mergedBean.setBeanLevelLockType(originalBeanLockType);\n            }\n        }\n\n        // access timeout\n        AccessTimeout overrideAccessTimeout = override.getBeanLevelAccessTimeout();\n        if (overrideAccessTimeout != null) {\n            mergedBean.setBeanLevelAccessTimeout(overrideAccessTimeout);\n        } else {\n            AccessTimeout originalAccessTimeout = original.getBeanLevelAccessTimeout();\n            if (originalAccessTimeout != null) {\n                mergedBean.setBeanLevelAccessTimeout(originalAccessTimeout);\n            }\n        }\n\n        // views\n        Collection<ViewDescription> overrideViews = override.getViews();\n        if (overrideViews != null && !overrideViews.isEmpty()) {\n            for (ViewDescription view : overrideViews) {\n                String viewClassName = view.getViewClassName();\n                MethodIntf viewType = override.getMethodIntf(viewClassName);\n                addView(mergedBean, viewClassName, viewType);\n            }\n        } else {\n            Collection<ViewDescription> originalViews = original.getViews();\n            if (originalViews != null) {\n                for (ViewDescription view : originalViews) {\n                    String viewClassName = view.getViewClassName();\n                    MethodIntf viewType = original.getMethodIntf(viewClassName);\n                    addView(mergedBean, viewClassName, viewType);\n                }\n\n            }\n        }\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static SessionBeanComponentDescription createNewSessionBean(SessionBeanComponentDescription source, EjbJarDescription ejbModuleDescription) {\n        SessionBeanComponentDescription.SessionBeanType sessionBeanType = source.getSessionBeanType();\n        switch (sessionBeanType) {\n            case STATELESS:\n                return new StatelessComponentDescription(source.getComponentName(), source.getComponentClassName(), ejbModuleDescription);\n            case STATEFUL:\n                return new StatefulComponentDescription(source.getComponentName(), source.getComponentClassName(), ejbModuleDescription);\n            case SINGLETON:\n                return new SingletonComponentDescription(source.getComponentName(), source.getComponentClassName(), ejbModuleDescription);\n            default:\n                throw new IllegalArgumentException(\"Unknown session bean type: \" + sessionBeanType + \" for bean \" + source.getEJBName());\n        }\n    }","id":35054,"modified_method":"private static SessionBeanComponentDescription createNewSessionBean(SessionBeanComponentDescription source, EjbJarDescription ejbModuleDescription) {\n        SessionBeanComponentDescription.SessionBeanType sessionBeanType = source.getSessionBeanType();\n        ServiceName deploymentUnitServiceName = source.getServiceName().getParent();\n        switch (sessionBeanType) {\n            case STATELESS:\n                return new StatelessComponentDescription(source.getComponentName(), source.getComponentClassName(), ejbModuleDescription, deploymentUnitServiceName);\n            case STATEFUL:\n                return new StatefulComponentDescription(source.getComponentName(), source.getComponentClassName(), ejbModuleDescription, deploymentUnitServiceName);\n            case SINGLETON:\n                return new SingletonComponentDescription(source.getComponentName(), source.getComponentClassName(), ejbModuleDescription, deploymentUnitServiceName);\n            default:\n                throw new IllegalArgumentException(\"Unknown session bean type: \" + sessionBeanType + \" for bean \" + source.getEJBName());\n        }\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public MessageDrivenComponentConfiguration(final MessageDrivenComponentDescription description) {\n        super(description);\n\n        this.resourceAdapterName = description.getResourceAdapterName();\n        if (this.resourceAdapterName == null)\n            throw new IllegalArgumentException(\"No resource adapter name set in \" + description);\n\n        // See RaDeploymentParsingProcessor\n        String deploymentName = resourceAdapterName.substring(0, resourceAdapterName.indexOf(\".rar\"));\n        // See ResourceAdapterDeploymentService\n        this.raServiceName = ServiceName.of(deploymentName);\n        description.addDependency(raServiceName, ServiceBuilder.DependencyType.REQUIRED);\n\n        addComponentSystemInterceptorFactory(pooled());\n    }","id":35055,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public MessageDrivenComponentConfiguration(final MessageDrivenComponentDescription description, final EEModuleClassConfiguration ejbClassConfiguration) {\n        super(description, ejbClassConfiguration);\n\n        this.resourceAdapterName = description.getResourceAdapterName();\n        if (this.resourceAdapterName == null)\n            throw new IllegalArgumentException(\"No resource adapter name set in \" + description);\n\n        // See RaDeploymentParsingProcessor\n        String deploymentName = resourceAdapterName.substring(0, resourceAdapterName.indexOf(\".rar\"));\n        // See ResourceAdapterDeploymentService\n        this.raServiceName = ServiceName.of(deploymentName);\n        description.addDependency(raServiceName, ServiceBuilder.DependencyType.REQUIRED);\n\n        addComponentSystemInterceptorFactory(pooled());\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public SessionBeanComponentConfiguration(final SessionBeanComponentDescription description) {\n        super(description);\n\n        // Bean level @AccessTimeout\n        this.beanLevelAccessTimeout = description.getBeanLevelAccessTimeout();\n\n        if (description.allowsConcurrentAccess()) {\n            this.beanLevelLockType = description.getBeanLevelLockType();\n\n            // container managed concurrency interceptor\n            if (description.getConcurrencyManagementType() != ConcurrencyManagementType.BEAN) {\n                // Add ComponentInstance level interceptor\n                this.addComponentInstanceSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                    @Override\n                    protected Interceptor create(Component component, InterceptorFactoryContext context) {\n                        if (component instanceof LockableComponent) {\n                            return new ContainerManagedConcurrencyInterceptor((LockableComponent) component);\n                        } else {\n                            // TODO: This shouldn't be required\n                            return new Interceptor() {\n                                @Override\n                                public Object processInvocation(InterceptorContext interceptorContext) throws Exception {\n                                    return interceptorContext.proceed();\n                                }\n\n                            };\n                        }\n\n\n                    }\n                });\n            }\n\n        }\n    }","id":35056,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public SessionBeanComponentConfiguration(final SessionBeanComponentDescription description, final EEModuleClassConfiguration ejbClassConfiguration) {\n        super(description, ejbClassConfiguration);\n\n        // Bean level @AccessTimeout\n        this.beanLevelAccessTimeout = description.getBeanLevelAccessTimeout();\n\n        if (description.allowsConcurrentAccess()) {\n            this.beanLevelLockType = description.getBeanLevelLockType();\n\n            // container managed concurrency interceptor\n            if (description.getConcurrencyManagementType() != ConcurrencyManagementType.BEAN) {\n                // Add ComponentInstance level interceptor\n//                this.addComponentInstanceSystemInterceptorFactory(new ComponentInterceptorFactory() {\n//                    @Override\n//                    protected Interceptor create(Component component, InterceptorFactoryContext context) {\n//                        if (component instanceof LockableComponent) {\n//                            return new ContainerManagedConcurrencyInterceptor((LockableComponent) component);\n//                        } else {\n//                            // TODO: This shouldn't be required\n//                            return new Interceptor() {\n//                                @Override\n//                                public Object processInvocation(InterceptorContext interceptorContext) throws Exception {\n//                                    return interceptorContext.proceed();\n//                                }\n//\n//                            };\n//                        }\n//\n//\n//                    }\n//                });\n                throw new RuntimeException(\"Adding a interceptor at ComponentInstance level (for ex: locking interceptor) is not yet implemented\");\n            }\n\n        }\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private synchronized void destroySingletonInstance() {\n        if (this.singletonComponentInstance != null) {\n            this.destroyInstance(this.singletonComponentInstance);\n            this.singletonComponentInstance = null;\n        }\n    }","id":35057,"modified_method":"private synchronized void destroySingletonInstance() {\n        if (this.singletonComponentInstance != null) {\n            // TODO: Implement destroying an instance\n            logger.warn(\"Destorying of singleton instance not yet implemented\");\n            //this.destroyInstance(this.singletonComponentInstance);\n            this.singletonComponentInstance = null;\n        }\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected synchronized BasicComponentInstance constructComponentInstance(Object instance, InterceptorFactoryContext context) {\n        if (this.singletonComponentInstance != null) {\n            throw new IllegalStateException(\"A singleton component instance has already been created for bean: \" + this.getComponentName());\n        }\n        this.singletonComponentInstance = new SingletonComponentInstance(this, instance, context);\n        return this.singletonComponentInstance;\n    }","id":35058,"modified_method":"@Override\n    protected BasicComponentInstance constructComponentInstance() {\n        if (this.singletonComponentInstance != null) {\n            throw new IllegalStateException(\"A singleton component instance has already been created for bean: \" + this.getComponentName());\n        }\n        this.singletonComponentInstance = new SingletonComponentInstance(this);\n        return this.singletonComponentInstance;\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Object invoke(Serializable sessionId, Map<String, Object> contextData, Class<?> invokedBusinessInterface, Method beanMethod, Object[] args) throws Exception {\n        if (sessionId != null)\n            throw new IllegalArgumentException(\"Singleton \" + this + \" does not support sessions\");\n        if (invokedBusinessInterface != null)\n            throw new UnsupportedOperationException(\"invokedBusinessInterface != null\");\n        InterceptorContext context = new InterceptorContext();\n        context.putPrivateData(Component.class, this);\n        context.setContextData(contextData);\n        context.setMethod(beanMethod);\n        context.setParameters(args);\n        return getComponentInterceptor().processInvocation(context);\n    }","id":35059,"modified_method":"@Override\n    public Object invoke(Serializable sessionId, Map<String, Object> contextData, Class<?> invokedBusinessInterface, Method beanMethod, Object[] args) throws Exception {\n        if (sessionId != null)\n            throw new IllegalArgumentException(\"Singleton \" + this + \" does not support sessions\");\n        if (invokedBusinessInterface != null)\n            throw new UnsupportedOperationException(\"invokedBusinessInterface != null\");\n        InterceptorContext context = new InterceptorContext();\n        context.putPrivateData(Component.class, this);\n        context.setContextData(contextData);\n        context.setMethod(beanMethod);\n        context.setParameters(args);\n        throw new RuntimeException(\"invoke() not yet implemented\");\n        //return getComponentInterceptor().processInvocation(context);\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public SingletonComponentConfiguration(final SingletonComponentDescription description) {\n        super(description);\n\n        this.initOnStartup = description.isInitOnStartup();\n\n        // instance associating interceptor\n        this.addComponentSystemInterceptorFactory(new ImmediateInterceptorFactory(new SingletonComponentInstanceAssociationInterceptor()));\n\n        // BMT interceptor\n        if (TransactionManagementType.BEAN.equals(description.getTransactionManagementType())) {\n            addComponentSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                @Override\n                protected Interceptor create(final Component component, final InterceptorFactoryContext context) {\n                    return new SingletonBMTInterceptor((SingletonComponent) component);\n                }\n            });\n        }\n\n    }","id":35060,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public SingletonComponentConfiguration(final SingletonComponentDescription description, final EEModuleClassConfiguration ejbClassConfiguration) {\n        super(description, ejbClassConfiguration);\n\n        this.initOnStartup = description.isInitOnStartup();\n\n        // instance associating interceptor\n        this.addComponentSystemInterceptorFactory(new ImmediateInterceptorFactory(new SingletonComponentInstanceAssociationInterceptor()));\n\n        // BMT interceptor\n        if (TransactionManagementType.BEAN.equals(description.getTransactionManagementType())) {\n            addComponentSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                @Override\n                protected Interceptor create(final Component component, final InterceptorFactoryContext context) {\n                    return new SingletonBMTInterceptor((SingletonComponent) component);\n                }\n            });\n        }\n\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param component the component\n     * @param instance  the object instance\n     */\n    public SingletonComponentInstance(final SingletonComponent component, final Object instance, final InterceptorFactoryContext factoryContext) {\n        super(component, instance, factoryContext);\n    }","id":35061,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param component the component\n     */\n    public SingletonComponentInstance(final SingletonComponent component) {\n        super(component);\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public StatefulSessionComponentConfiguration(final StatefulComponentDescription description) {\n        super(description);\n\n        addComponentSystemInterceptorFactory(new ImmediateInterceptorFactory(new ComponentInstanceInterceptor()));\n\n        if(description.getTransactionManagementType().equals(TransactionManagementType.BEAN)) {\n            addComponentSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                @Override\n                protected Interceptor create(final Component component, final InterceptorFactoryContext context) {\n                    return new StatefulBMTInterceptor((StatefulSessionComponent) component);\n                }\n            });\n        } else {\n            addComponentInstanceSystemInterceptorFactory(new InterceptorFactory() {\n                @Override\n                public Interceptor create(InterceptorFactoryContext context) {\n                    return new StatefulSessionSynchronizationInterceptor();\n                }\n            });\n        }\n    }","id":35062,"modified_method":"public StatefulSessionComponentConfiguration(final StatefulComponentDescription description, final EEModuleClassConfiguration ejbClassConfiguration) {\n        super(description, ejbClassConfiguration);\n\n        addComponentSystemInterceptorFactory(new ImmediateInterceptorFactory(new ComponentInstanceInterceptor()));\n\n        if(description.getTransactionManagementType().equals(TransactionManagementType.BEAN)) {\n            addComponentSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                @Override\n                protected Interceptor create(final Component component, final InterceptorFactoryContext context) {\n                    return new StatefulBMTInterceptor((StatefulSessionComponent) component);\n                }\n            });\n        } else {\n//            addComponentInstanceSystemInterceptorFactory(new InterceptorFactory() {\n//                @Override\n//                public Interceptor create(InterceptorFactoryContext context) {\n//                    return new StatefulSessionSynchronizationInterceptor();\n//                }\n//            });\n            throw new RuntimeException(\"Adding a interceptor at ComponentInstance level (for ex: locking interceptor) is not yet implemented\");\n        }\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public StatelessSessionComponentConfiguration(final StatelessComponentDescription description) {\n        super(description);\n\n        addComponentSystemInterceptorFactory(pooled());\n\n        if(description.getTransactionManagementType().equals(TransactionManagementType.BEAN)) {\n            addComponentSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                @Override\n                protected Interceptor create(final Component component, final InterceptorFactoryContext context) {\n                    return new StatelessBMTInterceptor((StatelessSessionComponent) component);\n                }\n            });\n        }\n    }","id":35063,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param description the original component description\n     */\n    public StatelessSessionComponentConfiguration(final StatelessComponentDescription description, final EEModuleClassConfiguration ejbClassConfiguration) {\n        super(description, ejbClassConfiguration);\n\n        addComponentSystemInterceptorFactory(pooled());\n\n        if(description.getTransactionManagementType().equals(TransactionManagementType.BEAN)) {\n            addComponentSystemInterceptorFactory(new ComponentInterceptorFactory() {\n                @Override\n                protected Interceptor create(final Component component, final InterceptorFactoryContext context) {\n                    return new StatelessBMTInterceptor((StatelessSessionComponent) component);\n                }\n            });\n        }\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static DeploymentUnit mockDeploymentUnit(String duName) {\n        final Attachable attachable = new SimpleAttachable();\n        final DeploymentUnit deploymentUnit = mock(DeploymentUnit.class);\n        when(deploymentUnit.getName()).thenReturn(duName);\n        \n        when(deploymentUnit.getAttachment((AttachmentKey<Object>) any())).thenAnswer(new Answer() {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                AttachmentKey<?> key = (AttachmentKey<?>) invocation.getArguments()[0];\n                return attachable.getAttachment(key);\n            }\n        });\n        when(deploymentUnit.putAttachment((AttachmentKey<Object>) any(), any())).thenAnswer(new Answer() {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                AttachmentKey<Object> key = (AttachmentKey<Object>) invocation.getArguments()[0];\n                Object value = invocation.getArguments()[1];\n                return attachable.putAttachment(key, value);\n            }\n        });\n        return deploymentUnit;\n    }","id":35064,"modified_method":"public static DeploymentUnit mockDeploymentUnit(String duName) {\n        final Attachable attachable = new SimpleAttachable();\n        final DeploymentUnit deploymentUnit = mock(DeploymentUnit.class);\n        when(deploymentUnit.getName()).thenReturn(duName);\n        \n        when(deploymentUnit.getAttachment((AttachmentKey<Object>) any())).thenAnswer(new Answer() {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                AttachmentKey<?> key = (AttachmentKey<?>) invocation.getArguments()[0];\n                return attachable.getAttachment(key);\n            }\n        });\n        when(deploymentUnit.putAttachment((AttachmentKey<Object>) any(), any())).thenAnswer(new Answer() {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                AttachmentKey<Object> key = (AttachmentKey<Object>) invocation.getArguments()[0];\n                Object value = invocation.getArguments()[1];\n                return attachable.putAttachment(key, value);\n            }\n        });\n        ServiceName deploymentUnitServiceName = Services.deploymentUnitName(duName);\n        when(deploymentUnit.getServiceName()).thenReturn(deploymentUnitServiceName);\n        return deploymentUnit;\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testViews() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        index(indexer, ViewA.class);\n        index(indexer, ViewB.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription eeModuleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(eeModuleDescription);\n        SessionBeanComponentDescription componentDescription = new StatelessComponentDescription(MyBean.class.getSimpleName(), MyBean.class.getName(), ejbJarDescription);\n        Collection<String> views = new HashSet<String>();\n        views.add(ViewA.class.getName());\n        views.add(ViewB.class.getName());\n        componentDescription.addLocalBusinessInterfaceViews(views);\n\n        TransactionAttributeAnnotationProcessor processor = new TransactionAttributeAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(TransactionAttributeType.MANDATORY, componentDescription.getTransactionAttribute(MethodIntf.LOCAL, \"anyMethod\"));\n    }","id":35065,"modified_method":"@Test\n    public void testViews() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        index(indexer, ViewA.class);\n        index(indexer, ViewB.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final ServiceName duServiceName = deploymentUnit.getServiceName();\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        SessionBeanComponentDescription componentDescription = new StatelessComponentDescription(MyBean.class.getSimpleName(), MyBean.class.getName(), ejbJarDescription, duServiceName);\n        Collection<String> views = new HashSet<String>();\n        views.add(ViewA.class.getName());\n        views.add(ViewB.class.getName());\n        componentDescription.addLocalBusinessInterfaceViews(views);\n\n        TransactionAttributeAnnotationProcessor processor = new TransactionAttributeAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(TransactionAttributeType.MANDATORY, componentDescription.getTransactionAttribute(MethodIntf.LOCAL, \"anyMethod\"));\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void test1() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription eeModuleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(eeModuleDescription);\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(MyBean.class.getSimpleName(), MyBean.class.getName(), ejbJarDescription);\n        TransactionAttributeAnnotationProcessor processor = new TransactionAttributeAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(TransactionAttributeType.MANDATORY, componentDescription.getTransactionAttribute(MethodIntf.LOCAL, \"anyMethod\"));\n    }","id":35066,"modified_method":"@Test\n    public void test1() throws Exception {\n        DeploymentUnit deploymentUnit = mockDeploymentUnit();\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        final ServiceName duServiceName = deploymentUnit.getServiceName();\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(MyBean.class.getSimpleName(), MyBean.class.getName(), ejbJarDescription, duServiceName);\n        TransactionAttributeAnnotationProcessor processor = new TransactionAttributeAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(TransactionAttributeType.MANDATORY, componentDescription.getTransactionAttribute(MethodIntf.LOCAL, \"anyMethod\"));\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * EJB 3.1 FR 13.3.1, the default transaction management type is container-managed transaction demarcation.\n     */\n    @Test\n    public void testDefault() {\n        final EEModuleDescription eeModuleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(eeModuleDescription);\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(\"TestBean\", \"TestClass\", ejbJarDescription);\n        assertEquals(TransactionManagementType.CONTAINER, componentDescription.getTransactionManagementType());\n    }","id":35067,"modified_method":"/**\n     * EJB 3.1 FR 13.3.1, the default transaction management type is container-managed transaction demarcation.\n     */\n    @Test\n    public void testDefault() {\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        final ServiceName duServiceName = Services.deploymentUnitName(\"Dummy deployment unit\");\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(\"TestBean\", \"TestClass\", ejbJarDescription, duServiceName);\n        assertEquals(TransactionManagementType.CONTAINER, componentDescription.getTransactionManagementType());\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"private DeploymentUnit getDeploymentUnit() {\n        return new DeploymentUnit() {\n            private Map<AttachmentKey<?>, Object> attachments = new HashMap();\n\n            @Override\n            public ServiceName getServiceName() {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public DeploymentUnit getParent() {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public String getName() {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public ServiceRegistry getServiceRegistry() {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public boolean hasAttachment(AttachmentKey<?> key) {\n                return this.attachments.containsKey(key);\n            }\n\n            @Override\n            public <T> T getAttachment(AttachmentKey<T> key) {\n                if (key == null) {\n                    return null;\n                }\n                return key.cast(attachments.get(key));\n            }\n\n            @Override\n            public <T> List<T> getAttachmentList(AttachmentKey<? extends List<T>> key) {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public <T> T putAttachment(AttachmentKey<T> key, T value) {\n                if (key == null) {\n                    throw new IllegalArgumentException(\"key is null\");\n                }\n                return key.cast(attachments.put(key, key.cast(value)));\n            }\n\n            @Override\n            public <T> T removeAttachment(AttachmentKey<T> key) {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public <T> void addToAttachmentList(AttachmentKey<AttachmentList<T>> key, T value) {\n                throw new RuntimeException(\"NYI\");\n            }\n        };\n\n    }","id":35068,"modified_method":"private DeploymentUnit getDeploymentUnit(final String duName) {\n        return new DeploymentUnit() {\n            private Map<AttachmentKey<?>, Object> attachments = new HashMap();\n\n            @Override\n            public ServiceName getServiceName() {\n                return Services.deploymentUnitName(duName);\n            }\n\n            @Override\n            public DeploymentUnit getParent() {\n                return null;\n            }\n\n            @Override\n            public String getName() {\n                return duName;\n            }\n\n            @Override\n            public ServiceRegistry getServiceRegistry() {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public boolean hasAttachment(AttachmentKey<?> key) {\n                return this.attachments.containsKey(key);\n            }\n\n            @Override\n            public <T> T getAttachment(AttachmentKey<T> key) {\n                if (key == null) {\n                    return null;\n                }\n                return key.cast(attachments.get(key));\n            }\n\n            @Override\n            public <T> List<T> getAttachmentList(AttachmentKey<? extends List<T>> key) {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public <T> T putAttachment(AttachmentKey<T> key, T value) {\n                if (key == null) {\n                    throw new IllegalArgumentException(\"key is null\");\n                }\n                return key.cast(attachments.put(key, key.cast(value)));\n            }\n\n            @Override\n            public <T> T removeAttachment(AttachmentKey<T> key) {\n                throw new RuntimeException(\"NYI\");\n            }\n\n            @Override\n            public <T> void addToAttachmentList(AttachmentKey<AttachmentList<T>> key, T value) {\n                throw new RuntimeException(\"NYI\");\n            }\n        };\n\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * EJB 3.1 FR 13.3.6 The TransactionManagement annotation is applied to the enterprise bean class.\n     */\n    @Test\n    public void testSubClass() throws Exception {\n        DeploymentUnit deploymentUnit = this.getDeploymentUnit();\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        index(indexer, SubBean.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription eeModuleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(eeModuleDescription);\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(SubBean.class.getSimpleName(), SubBean.class.getName(), ejbJarDescription);\n        TransactionManagementAnnotationProcessor processor = new TransactionManagementAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(TransactionManagementType.CONTAINER, componentDescription.getTransactionManagementType());\n    }","id":35069,"modified_method":"/**\n     * EJB 3.1 FR 13.3.6 The TransactionManagement annotation is applied to the enterprise bean class.\n     */\n    @Test\n    public void testSubClass() throws Exception {\n        DeploymentUnit deploymentUnit = this.getDeploymentUnit(\"testSubClass dummy DU\");\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        index(indexer, SubBean.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final ServiceName duServiceName = deploymentUnit.getServiceName();\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(SubBean.class.getSimpleName(), SubBean.class.getName(), ejbJarDescription, duServiceName);\n        TransactionManagementAnnotationProcessor processor = new TransactionManagementAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(TransactionManagementType.CONTAINER, componentDescription.getTransactionManagementType());\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void test1() throws Exception {\n        DeploymentUnit deploymentUnit = this.getDeploymentUnit();\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        index(indexer, SubBean.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n        final EEModuleDescription eeModuleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(eeModuleDescription);\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(MyBean.class.getSimpleName(), MyBean.class.getName(), ejbJarDescription);\n        TransactionManagementAnnotationProcessor processor = new TransactionManagementAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(TransactionManagementType.BEAN, componentDescription.getTransactionManagementType());\n    }","id":35070,"modified_method":"@Test\n    public void test1() throws Exception {\n        DeploymentUnit deploymentUnit = this.getDeploymentUnit(\"test1 Dummy DU\");\n        // Mark the deployment unit as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        DeploymentPhaseContext phaseContext = null;\n        Indexer indexer = new Indexer();\n        index(indexer, MyBean.class);\n        index(indexer, SubBean.class);\n        CompositeIndex index = new CompositeIndex(Arrays.asList(indexer.complete()));\n\n\n        final EEModuleDescription moduleDescription = new EEModuleDescription(\"TestApp\", \"TestModule\");\n        final ServiceName duServiceName = deploymentUnit.getServiceName();\n        final EjbJarDescription ejbJarDescription = new EjbJarDescription(moduleDescription);\n        EJBComponentDescription componentDescription = new StatelessComponentDescription(MyBean.class.getSimpleName(), MyBean.class.getName(), ejbJarDescription, duServiceName);\n        TransactionManagementAnnotationProcessor processor = new TransactionManagementAnnotationProcessor();\n        processor.processComponentConfig(deploymentUnit, phaseContext, index, componentDescription);\n\n        assertEquals(TransactionManagementType.BEAN, componentDescription.getTransactionManagementType());\n    }","commit_id":"1af2b154ec4daa8436ba6f946ef54fe201062c6a","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\tpublic boolean destinationReached() {\n\t\tif (currentRoute != null) {\n\t\t\tif (currentRoute.currentPoints != null && !currentRoute.currentPoints.isEmpty()){\n\t\t\t\tlastReachedPoint = currentRoute.currentPoints.get(0);\n\t\t\t}\n\t\t\tFrameLayout layout = (FrameLayout) mapActivity.getLayout();\n\t\t\tFrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);\n\t\t\tparams.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;\n\t\t\tlayout.addView(deliveredView, params);\n\t\t\t//if it's possible to navigate to next point - navigation continues\n\t\t\treturn !currentRoute.navigateToNextPoint();\n\n\t\t}\n\n\t\treturn true;\n\t}","id":35071,"modified_method":"@Override\n\tpublic boolean destinationReached() {\n\t\tif (currentRoute != null) {\n\t\t\t//Check EVERYTHING\n\t\t\tif (currentRoute.currentPoints != null &&\n\t\t\t\t\tcurrentRoute.currentPoints.size() > 0 &&\n\t\t\t\t\tcurrentRoute.currentPoints.get(0).isNextNavigate) {\n\t\t\t\tFrameLayout layout = (FrameLayout) mapActivity.getLayout();\n\t\t\t\tFrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);\n\t\t\t\tparams.gravity = Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL;\n\t\t\t\tView deliveredView = createDeliveredView(currentRoute.currentPoints.get(0));\n\n\t\t\t\tif (deliveredView != null) {\n\t\t\t\t\tlayout.addView(deliveredView, params);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//if it's possible to navigate to next point - navigation continues\n\t\t\treturn !currentRoute.navigateToNextPoint();\n\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"fec8f58979d682b99f8f0c0bba2cfae288f20514","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void registerLayers(MapActivity activity) {\n\t\tsuper.registerLayers(activity);\n\t\tmapActivity = activity;\n\t\tprepareDeliveredView();\n\t\tif (routePointsLayer != null) {\n\t\t\tactivity.getMapView().removeLayer(routePointsLayer);\n\t\t}\n\n\t\troutePointsLayer = new RoutePointsLayer(activity, this);\n\t\tactivity.getMapView().addLayer(routePointsLayer, 5.5f);\n\t\tregisterWidget(activity);\n\t}","id":35072,"modified_method":"@Override\n\tpublic void registerLayers(MapActivity activity) {\n\t\tsuper.registerLayers(activity);\n\t\tmapActivity = activity;\n\t\tif (routePointsLayer != null) {\n\t\t\tactivity.getMapView().removeLayer(routePointsLayer);\n\t\t}\n\n\t\troutePointsLayer = new RoutePointsLayer(activity, this);\n\t\tactivity.getMapView().addLayer(routePointsLayer, 5.5f);\n\t\tregisterWidget(activity);\n\t}","commit_id":"fec8f58979d682b99f8f0c0bba2cfae288f20514","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void parseGPXFile(GPXFile gpx) {\n\t\t\tthis.gpx = gpx;\n\t\t\tRoute rt = getRoute();\n\t\t\tcurrentPoints.clear();\n\t\t\tif (rt != null) {\n\t\t\t\tTargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();\n\t\t\t\tString locName = targetPointsHelper.getPointNavigateDescription();\n\t\t\t\tfor (int i = 0; i < rt.points.size(); i++) {\n\t\t\t\t\tWptPt wptPt = rt.points.get(i);\n\t\t\t\t\tRoutePoint rtp = new RoutePoint();\n\t\t\t\t\trtp.gpxOrder = i;\n\t\t\t\t\trtp.wpt = wptPt;\n\t\t\t\t\tString delivered = wptPt.getExtensionsToRead().get(DELIVERED_KEY);\n\t\t\t\t\trtp.delivered = Boolean.parseBoolean(delivered);\n\n\t\t\t\t\tString time = wptPt.getExtensionsToRead().get(VISITED_KEY);\n\t\t\t\t\ttry {\n\t\t\t\t\t\trtp.visitedTime = Long.parseLong(time);\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t}\n\t\t\t\t\trtp.isNextNavigate = rtp.visitedTime == 0 && locName != null && locName.equals(wptPt.name);\n\t\t\t\t\tif (rtp.isNextNavigate) {\n\t\t\t\t\t\tlocName = null;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentPoints.add(rtp);\n\t\t\t\t}\n\t\t\t\tsortPoints();\n\t\t\t}\n\t\t}","id":35073,"modified_method":"private void parseGPXFile(GPXFile gpx) {\n\t\t\tthis.gpx = gpx;\n\t\t\tRoute rt = getRoute();\n\t\t\tcurrentPoints.clear();\n\t\t\tif (rt != null) {\n\t\t\t\tTargetPointsHelper targetPointsHelper = app.getTargetPointsHelper();\n\t\t\t\tString locName = targetPointsHelper.getPointNavigateDescription();\n\t\t\t\tfor (int i = 0; i < rt.points.size(); i++) {\n\t\t\t\t\tWptPt wptPt = rt.points.get(i);\n\t\t\t\t\tRoutePoint rtp = new RoutePoint(wptPt);\n\t\t\t\t\trtp.gpxOrder = i;\n\n\t\t\t\t\trtp.isNextNavigate = rtp.visitedTime == 0 && locName != null && locName.equals(wptPt.name);\n\t\t\t\t\tif (rtp.isNextNavigate) {\n\t\t\t\t\t\tlocName = null;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentPoints.add(rtp);\n\t\t\t\t}\n\t\t\t\tsortPoints();\n\t\t\t}\n\t\t}","commit_id":"fec8f58979d682b99f8f0c0bba2cfae288f20514","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setVisitedTime(long currentTimeMillis) {\n\t\t\tvisitedTime = currentTimeMillis;\n\t\t\twpt.getExtensionsToWrite().put(VISITED_KEY, visitedTime + \"\");\n\t\t}","id":35074,"modified_method":"public void setVisitedTime(long currentTimeMillis) {\n\t\t\tvisitedTime = currentTimeMillis;\n\t\t\twpt.getExtensionsToWrite().put(VISITED_KEY, visitedTime + \"\");\n\t\t\tsaveCurrentRoute();\n\t\t}","commit_id":"fec8f58979d682b99f8f0c0bba2cfae288f20514","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void saveGPXAsync() {\n\t\t\tnew AsyncTask<RoutePointsPlugin.SelectedRouteGpxFile, Void, Void>() {\n\n\t\t\t\tprotected void onPreExecute() {\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected Void doInBackground(RoutePointsPlugin.SelectedRouteGpxFile... params) {\n\t\t\t\t\tsaveFile();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tprotected void onPostExecute(Void result) {\n\t\t\t\t}\n\t\t\t}.execute(getCurrentRoute());\n\t\t}","id":35075,"modified_method":"public void saveGPXAsync() {\n\t\t\tnew AsyncTask<RoutePointsPlugin.SelectedRouteGpxFile, Void, Void>() {\n\t\t\t\t@Override\n\t\t\t\tprotected Void doInBackground(RoutePointsPlugin.SelectedRouteGpxFile... params) {\n\t\t\t\t\tsaveFile();\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}.execute(getCurrentRoute());\n\t\t}","commit_id":"fec8f58979d682b99f8f0c0bba2cfae288f20514","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void setDelivered(boolean d) {\n\t\t\twpt.getExtensionsToWrite().put(DELIVERED_KEY, String.valueOf(d));\n\t\t\tthis.delivered = d;\n\t\t}","id":35076,"modified_method":"public void setDelivered(boolean d) {\n\t\t\twpt.getExtensionsToWrite().put(DELIVERED_KEY, String.valueOf(d));\n\t\t\tthis.delivered = d;\n\t\t\tsaveCurrentRoute();\n\t\t}","commit_id":"fec8f58979d682b99f8f0c0bba2cfae288f20514","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void parseViews(HttpServletRequest request, Element view, ModelAndView modelView) throws ServletException {\n        Node node = view.getFirstChild();\n        while (node != null) {\n            if (node.getNodeType() == Node.ELEMENT_NODE && Namespaces.EXIST_NS.equals(node.getNamespaceURI())) {\n                URLRewrite urw = parseAction(request, (Element) node);\n                modelView.addView(urw);\n            }\n            node = node.getNextSibling();\n        }\n    }","id":35077,"modified_method":"private void parseViews(HttpServletRequest request, Element view, ModelAndView modelView) throws ServletException {\n        Node node = view.getFirstChild();\n        while (node != null) {\n            if (node.getNodeType() == Node.ELEMENT_NODE && Namespaces.EXIST_NS.equals(node.getNamespaceURI())) {\n                URLRewrite urw = parseAction(request, (Element) node);\n                if (urw != null)\n                    modelView.addView(urw);\n            }\n            node = node.getNextSibling();\n        }\n    }","commit_id":"c7b60b6a267096ea1933502eab73a6e81ea97bc7","url":"https://github.com/eXist-db/exist"},{"original_method":"public void setMispartitioned(boolean mispartitioned) {\n        m_mispartitioned = mispartitioned;\n    }","id":35078,"modified_method":"public void setMispartitioned(boolean mispartitioned, StoredProcedureInvocation invocation) {\n        m_mispartitioned = mispartitioned;\n        m_invocation = invocation;\n        m_commit = false;\n        m_response = null;\n    }","commit_id":"f9e1061ae5dfbd2ba6f7f33c968d9280c7c1cb1f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public int getSerializedSize()\n    {\n        int msgsize = super.getSerializedSize();\n        msgsize += 8 // txnId\n            + 8 // m_spHandle\n            + 8 // initiator HSId\n            + 8 // coordinator HSId\n            + 8 // client interface handle\n            + 8 // client connection id\n            + 1 // read only\n            + 1 // node recovering indication\n            + 1; // mispartitioned invocation\n\n        msgsize += m_response.getSerializedSize();\n\n        return msgsize;\n    }","id":35079,"modified_method":"@Override\n    public int getSerializedSize()\n    {\n        int msgsize = super.getSerializedSize();\n        msgsize += 8 // txnId\n            + 8 // m_spHandle\n            + 8 // initiator HSId\n            + 8 // coordinator HSId\n            + 8 // client interface handle\n            + 8 // client connection id\n            + 1 // read only\n            + 1 // node recovering indication\n            + 1; // mispartitioned invocation\n\n        if (m_mispartitioned) {\n            msgsize += m_invocation.getSerializedSize();\n        } else {\n            msgsize += m_response.getSerializedSize();\n        }\n\n        return msgsize;\n    }","commit_id":"f9e1061ae5dfbd2ba6f7f33c968d9280c7c1cb1f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void initFromBuffer(ByteBuffer buf) throws IOException\n    {\n        m_txnId = buf.getLong();\n        m_spHandle = buf.getLong();\n        m_initiatorHSId = buf.getLong();\n        m_coordinatorHSId = buf.getLong();\n        m_clientInterfaceHandle = buf.getLong();\n        m_connectionId = buf.getLong();\n        m_readOnly = buf.get() == 1;\n        m_recovering = buf.get() == 1;\n        m_mispartitioned = buf.get() == 1;\n        m_response = new ClientResponseImpl();\n        m_response.initFromBuffer(buf);\n        m_commit = (m_response.getStatus() == ClientResponseImpl.SUCCESS);\n        assert(buf.capacity() == buf.position());\n    }","id":35080,"modified_method":"@Override\n    public void initFromBuffer(ByteBuffer buf) throws IOException\n    {\n        m_txnId = buf.getLong();\n        m_spHandle = buf.getLong();\n        m_initiatorHSId = buf.getLong();\n        m_coordinatorHSId = buf.getLong();\n        m_clientInterfaceHandle = buf.getLong();\n        m_connectionId = buf.getLong();\n        m_readOnly = buf.get() == 1;\n        m_recovering = buf.get() == 1;\n        m_mispartitioned = buf.get() == 1;\n        if (m_mispartitioned) {\n            m_invocation = new StoredProcedureInvocation();\n            m_invocation.initFromBuffer(buf);\n            m_commit = false;\n        } else {\n            m_response = new ClientResponseImpl();\n            m_response.initFromBuffer(buf);\n            m_commit = (m_response.getStatus() == ClientResponseImpl.SUCCESS);\n        }\n        assert(buf.capacity() == buf.position());\n    }","commit_id":"f9e1061ae5dfbd2ba6f7f33c968d9280c7c1cb1f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void flattenToBuffer(ByteBuffer buf)\n    {\n        buf.put(VoltDbMessageFactory.INITIATE_RESPONSE_ID);\n        buf.putLong(m_txnId);\n        buf.putLong(m_spHandle);\n        buf.putLong(m_initiatorHSId);\n        buf.putLong(m_coordinatorHSId);\n        buf.putLong(m_clientInterfaceHandle);\n        buf.putLong(m_connectionId);\n        buf.put((byte) (m_readOnly == true ? 1 : 0));\n        buf.put((byte) (m_recovering == true ? 1 : 0));\n        buf.put((byte) (m_mispartitioned == true ? 1 : 0));\n        m_response.flattenToBuffer(buf);\n        assert(buf.capacity() == buf.position());\n        buf.limit(buf.position());\n    }","id":35081,"modified_method":"@Override\n    public void flattenToBuffer(ByteBuffer buf) throws IOException\n    {\n        buf.put(VoltDbMessageFactory.INITIATE_RESPONSE_ID);\n        buf.putLong(m_txnId);\n        buf.putLong(m_spHandle);\n        buf.putLong(m_initiatorHSId);\n        buf.putLong(m_coordinatorHSId);\n        buf.putLong(m_clientInterfaceHandle);\n        buf.putLong(m_connectionId);\n        buf.put((byte) (m_readOnly == true ? 1 : 0));\n        buf.put((byte) (m_recovering == true ? 1 : 0));\n        buf.put((byte) (m_mispartitioned == true ? 1 : 0));\n        if (m_mispartitioned) {\n            m_invocation.flattenToBuffer(buf);\n        } else {\n            m_response.flattenToBuffer(buf);\n        }\n        assert(buf.capacity() == buf.position());\n        buf.limit(buf.position());\n    }","commit_id":"f9e1061ae5dfbd2ba6f7f33c968d9280c7c1cb1f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Mostly copy-paste of old ExecutionSite.processInitiateTask() */\n    protected InitiateResponseMessage processInitiateTask(Iv2InitiateTaskMessage task,\n            SiteProcedureConnection siteConnection)\n    {\n        final InitiateResponseMessage response = new InitiateResponseMessage(task);\n\n        try {\n            Object[] callerParams = null;\n            /*\n             * Parameters are lazily deserialized. We may not find out until now\n             * that the parameter set is corrupt\n             */\n            try {\n                callerParams = task.getParameters();\n            } catch (RuntimeException e) {\n                Writer result = new StringWriter();\n                PrintWriter pw = new PrintWriter(result);\n                e.printStackTrace(pw);\n                response.setResults(\n                        new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                            new VoltTable[] {},\n                            \"Exception while deserializing procedure params\\n\" +\n                            result.toString()));\n            }\n            if (callerParams != null) {\n                ClientResponseImpl cr = null;\n                ProcedureRunner runner = siteConnection.getProcedureRunner(m_procName);\n                if (runner == null) {\n                    String error =\n                        \"Procedure \" + m_procName + \" is not present in the catalog. \"  +\n                        \"This can happen if a catalog update removing the procedure occurred \" +\n                        \"after the procedure was submitted \" +\n                        \"but before the procedure was executed.\";\n                    hostLog.debug(error);\n                    response.setResults(\n                            new ClientResponseImpl(\n                                ClientResponse.UNEXPECTED_FAILURE,\n                                new VoltTable[]{},\n                                error));\n                    return response;\n                }\n                runner.setupTransaction(m_txn);\n                cr = runner.call(task.getParameters());\n\n                m_txn.setHash(cr.getHash());\n\n                response.setResults(cr);\n                // record the results of write transactions to the transaction state\n                // this may be used to verify the DR replica cluster gets the same value\n                // skip for multi-partition txns because only 1 of k+1 partitions will\n                //  have the real results\n                if ((!task.isReadOnly()) && task.isSinglePartition()) {\n                    m_txn.storeResults(cr);\n                }\n            }\n        }\n        catch (final ExpectedProcedureException e) {\n            execLog.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n            response.setResults(\n                    new ClientResponseImpl(\n                        ClientResponse.GRACEFUL_FAILURE,\n                        new VoltTable[]{},\n                        e.toString()));\n        }\n        catch (final Exception e) {\n            // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n            // and converted them to error responses. Java errors are re-thrown, and not caught by this\n            // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n            hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n            VoltDB.crashLocalVoltDB(e.getMessage(), true, e);\n        }\n        return response;\n    }","id":35082,"modified_method":"/** Mostly copy-paste of old ExecutionSite.processInitiateTask() */\n    protected InitiateResponseMessage processInitiateTask(Iv2InitiateTaskMessage task,\n            SiteProcedureConnection siteConnection)\n    {\n        final InitiateResponseMessage response = new InitiateResponseMessage(task);\n\n        try {\n            Object[] callerParams = null;\n            /*\n             * Parameters are lazily deserialized. We may not find out until now\n             * that the parameter set is corrupt\n             */\n            try {\n                callerParams = task.getParameters();\n            } catch (RuntimeException e) {\n                Writer result = new StringWriter();\n                PrintWriter pw = new PrintWriter(result);\n                e.printStackTrace(pw);\n                response.setResults(\n                        new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                            new VoltTable[] {},\n                            \"Exception while deserializing procedure params\\n\" +\n                            result.toString()));\n            }\n            if (callerParams != null) {\n                ClientResponseImpl cr = null;\n                ProcedureRunner runner = siteConnection.getProcedureRunner(m_procName);\n                if (runner == null) {\n                    String error =\n                        \"Procedure \" + m_procName + \" is not present in the catalog. \"  +\n                        \"This can happen if a catalog update removing the procedure occurred \" +\n                        \"after the procedure was submitted \" +\n                        \"but before the procedure was executed.\";\n                    hostLog.debug(error);\n                    response.setResults(\n                            new ClientResponseImpl(\n                                ClientResponse.UNEXPECTED_FAILURE,\n                                new VoltTable[]{},\n                                error));\n                    return response;\n                }\n\n                // Check partitioning of the invocation\n                if (runner.checkPartition(m_txn)) {\n                    runner.setupTransaction(m_txn);\n                    cr = runner.call(task.getParameters());\n\n                    m_txn.setHash(cr.getHash());\n\n                    response.setResults(cr);\n                    // record the results of write transactions to the transaction state\n                    // this may be used to verify the DR replica cluster gets the same value\n                    // skip for multi-partition txns because only 1 of k+1 partitions will\n                    //  have the real results\n                    if ((!task.isReadOnly()) && task.isSinglePartition()) {\n                        m_txn.storeResults(cr);\n                    }\n                } else {\n                    // mis-partitioned invocation, reject it and let the ClientInterface restart it\n                    response.setMispartitioned(true, task.getStoredProcedureInvocation());\n                }\n            }\n        }\n        catch (final ExpectedProcedureException e) {\n            execLog.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n            response.setResults(\n                    new ClientResponseImpl(\n                        ClientResponse.GRACEFUL_FAILURE,\n                        new VoltTable[]{},\n                        e.toString()));\n        }\n        catch (final Exception e) {\n            // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n            // and converted them to error responses. Java errors are re-thrown, and not caught by this\n            // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n            hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n            VoltDB.crashLocalVoltDB(e.getMessage(), true, e);\n        }\n        return response;\n    }","commit_id":"f9e1061ae5dfbd2ba6f7f33c968d9280c7c1cb1f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void flattenToBuffer(ByteBuffer buf) throws IOException\n    {\n        buf.put(VoltDbMessageFactory.INITIATE_RESPONSE_ID);\n        buf.putLong(m_txnId);\n        buf.putLong(m_spHandle);\n        buf.putLong(m_initiatorHSId);\n        buf.putLong(m_coordinatorHSId);\n        buf.putLong(m_clientInterfaceHandle);\n        buf.putLong(m_connectionId);\n        buf.put((byte) (m_readOnly == true ? 1 : 0));\n        buf.put((byte) (m_recovering == true ? 1 : 0));\n        buf.put((byte) (m_mispartitioned == true ? 1 : 0));\n        if (m_mispartitioned) {\n            m_invocation.flattenToBuffer(buf);\n        } else {\n            m_response.flattenToBuffer(buf);\n        }\n        assert(buf.capacity() == buf.position());\n        buf.limit(buf.position());\n    }","id":35083,"modified_method":"@Override\n    public void flattenToBuffer(ByteBuffer buf) throws IOException\n    {\n        buf.put(VoltDbMessageFactory.INITIATE_RESPONSE_ID);\n        buf.putLong(m_txnId);\n        buf.putLong(m_spHandle);\n        buf.putLong(m_initiatorHSId);\n        buf.putLong(m_coordinatorHSId);\n        buf.putLong(m_clientInterfaceHandle);\n        buf.putLong(m_connectionId);\n        buf.put((byte) (m_readOnly == true ? 1 : 0));\n        buf.put((byte) (m_recovering == true ? 1 : 0));\n        buf.put((byte) (m_mispartitioned == true ? 1 : 0));\n        if (m_mispartitioned) {\n            m_invocation.flattenToBuffer(buf);\n            buf.putLong(m_currentHashinatorConfig.getFirst());\n            buf.putInt(m_currentHashinatorConfig.getSecond().length);\n            buf.put(m_currentHashinatorConfig.getSecond());\n        } else {\n            m_response.flattenToBuffer(buf);\n        }\n        assert(buf.capacity() == buf.position());\n        buf.limit(buf.position());\n    }","commit_id":"01ab15ccd479411687a93bf1a71ca6a4d164b679","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public int getSerializedSize()\n    {\n        int msgsize = super.getSerializedSize();\n        msgsize += 8 // txnId\n            + 8 // m_spHandle\n            + 8 // initiator HSId\n            + 8 // coordinator HSId\n            + 8 // client interface handle\n            + 8 // client connection id\n            + 1 // read only\n            + 1 // node recovering indication\n            + 1; // mispartitioned invocation\n\n        if (m_mispartitioned) {\n            msgsize += m_invocation.getSerializedSize();\n        } else {\n            msgsize += m_response.getSerializedSize();\n        }\n\n        return msgsize;\n    }","id":35084,"modified_method":"@Override\n    public int getSerializedSize()\n    {\n        int msgsize = super.getSerializedSize();\n        msgsize += 8 // txnId\n            + 8 // m_spHandle\n            + 8 // initiator HSId\n            + 8 // coordinator HSId\n            + 8 // client interface handle\n            + 8 // client connection id\n            + 1 // read only\n            + 1 // node recovering indication\n            + 1; // mispartitioned invocation\n\n        if (m_mispartitioned) {\n            msgsize += m_invocation.getSerializedSize()\n                       + 8 // current hashinator version\n                       + 4 // hashinator config length\n                       + m_currentHashinatorConfig.getSecond().length; // hashinator config\n        } else {\n            msgsize += m_response.getSerializedSize();\n        }\n\n        return msgsize;\n    }","commit_id":"01ab15ccd479411687a93bf1a71ca6a4d164b679","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void initFromBuffer(ByteBuffer buf) throws IOException\n    {\n        m_txnId = buf.getLong();\n        m_spHandle = buf.getLong();\n        m_initiatorHSId = buf.getLong();\n        m_coordinatorHSId = buf.getLong();\n        m_clientInterfaceHandle = buf.getLong();\n        m_connectionId = buf.getLong();\n        m_readOnly = buf.get() == 1;\n        m_recovering = buf.get() == 1;\n        m_mispartitioned = buf.get() == 1;\n        if (m_mispartitioned) {\n            m_invocation = new StoredProcedureInvocation();\n            m_invocation.initFromBuffer(buf);\n            m_commit = false;\n        } else {\n            m_response = new ClientResponseImpl();\n            m_response.initFromBuffer(buf);\n            m_commit = (m_response.getStatus() == ClientResponseImpl.SUCCESS);\n        }\n        assert(buf.capacity() == buf.position());\n    }","id":35085,"modified_method":"@Override\n    public void initFromBuffer(ByteBuffer buf) throws IOException\n    {\n        m_txnId = buf.getLong();\n        m_spHandle = buf.getLong();\n        m_initiatorHSId = buf.getLong();\n        m_coordinatorHSId = buf.getLong();\n        m_clientInterfaceHandle = buf.getLong();\n        m_connectionId = buf.getLong();\n        m_readOnly = buf.get() == 1;\n        m_recovering = buf.get() == 1;\n        m_mispartitioned = buf.get() == 1;\n        if (m_mispartitioned) {\n            m_invocation = new StoredProcedureInvocation();\n            m_invocation.initFromBuffer(buf);\n            long hashinatorVersion = buf.getLong();\n            byte[] hashinatorBytes = new byte[buf.getInt()];\n            buf.get(hashinatorBytes);\n            m_currentHashinatorConfig = Pair.of(hashinatorVersion, hashinatorBytes);\n            m_commit = false;\n        } else {\n            m_response = new ClientResponseImpl();\n            m_response.initFromBuffer(buf);\n            m_commit = (m_response.getStatus() == ClientResponseImpl.SUCCESS);\n        }\n        assert(buf.capacity() == buf.position());\n    }","commit_id":"01ab15ccd479411687a93bf1a71ca6a4d164b679","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void setMispartitioned(boolean mispartitioned, StoredProcedureInvocation invocation) {\n        m_mispartitioned = mispartitioned;\n        m_invocation = invocation;\n        m_commit = false;\n        m_response = new ClientResponseImpl(ClientResponse.TXN_RESTART, new VoltTable[]{}, \"Mispartitioned\");\n    }","id":35086,"modified_method":"public void setMispartitioned(boolean mispartitioned, StoredProcedureInvocation invocation,\n                                  Pair<Long, byte[]> currentHashinatorConfig) {\n        m_mispartitioned = mispartitioned;\n        m_invocation = invocation;\n        m_currentHashinatorConfig = currentHashinatorConfig;\n        m_commit = false;\n        m_response = new ClientResponseImpl(ClientResponse.TXN_RESTART, new VoltTable[]{}, \"Mispartitioned\");\n    }","commit_id":"01ab15ccd479411687a93bf1a71ca6a4d164b679","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/** Mostly copy-paste of old ExecutionSite.processInitiateTask() */\n    protected InitiateResponseMessage processInitiateTask(Iv2InitiateTaskMessage task,\n            SiteProcedureConnection siteConnection)\n    {\n        final InitiateResponseMessage response = new InitiateResponseMessage(task);\n\n        try {\n            Object[] callerParams = null;\n            /*\n             * Parameters are lazily deserialized. We may not find out until now\n             * that the parameter set is corrupt\n             */\n            try {\n                callerParams = task.getParameters();\n            } catch (RuntimeException e) {\n                Writer result = new StringWriter();\n                PrintWriter pw = new PrintWriter(result);\n                e.printStackTrace(pw);\n                response.setResults(\n                        new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                            new VoltTable[] {},\n                            \"Exception while deserializing procedure params\\n\" +\n                            result.toString()));\n            }\n            if (callerParams != null) {\n                ClientResponseImpl cr = null;\n                ProcedureRunner runner = siteConnection.getProcedureRunner(m_procName);\n                if (runner == null) {\n                    String error =\n                        \"Procedure \" + m_procName + \" is not present in the catalog. \"  +\n                        \"This can happen if a catalog update removing the procedure occurred \" +\n                        \"after the procedure was submitted \" +\n                        \"but before the procedure was executed.\";\n                    hostLog.debug(error);\n                    response.setResults(\n                            new ClientResponseImpl(\n                                ClientResponse.UNEXPECTED_FAILURE,\n                                new VoltTable[]{},\n                                error));\n                    return response;\n                }\n\n                // Check partitioning of the invocation\n                if (runner.checkPartition(m_txnState)) {\n                    runner.setupTransaction(m_txnState);\n                    cr = runner.call(task.getParameters());\n\n                    m_txnState.setHash(cr.getHash());\n\n                    response.setResults(cr);\n                    // record the results of write transactions to the transaction state\n                    // this may be used to verify the DR replica cluster gets the same value\n                    // skip for multi-partition txns because only 1 of k+1 partitions will\n                    //  have the real results\n                    if ((!task.isReadOnly()) && task.isSinglePartition()) {\n                        m_txnState.storeResults(cr);\n                    }\n                } else {\n                    // mis-partitioned invocation, reject it and let the ClientInterface restart it\n                    response.setMispartitioned(true, task.getStoredProcedureInvocation());\n                }\n            }\n        }\n        catch (final ExpectedProcedureException e) {\n            execLog.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n            response.setResults(\n                    new ClientResponseImpl(\n                        ClientResponse.GRACEFUL_FAILURE,\n                        new VoltTable[]{},\n                        e.toString()));\n        }\n        catch (final Exception e) {\n            // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n            // and converted them to error responses. Java errors are re-thrown, and not caught by this\n            // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n            hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n            VoltDB.crashLocalVoltDB(e.getMessage(), true, e);\n        }\n        return response;\n    }","id":35087,"modified_method":"/** Mostly copy-paste of old ExecutionSite.processInitiateTask() */\n    protected InitiateResponseMessage processInitiateTask(Iv2InitiateTaskMessage task,\n            SiteProcedureConnection siteConnection)\n    {\n        final InitiateResponseMessage response = new InitiateResponseMessage(task);\n\n        try {\n            Object[] callerParams = null;\n            /*\n             * Parameters are lazily deserialized. We may not find out until now\n             * that the parameter set is corrupt\n             */\n            try {\n                callerParams = task.getParameters();\n            } catch (RuntimeException e) {\n                Writer result = new StringWriter();\n                PrintWriter pw = new PrintWriter(result);\n                e.printStackTrace(pw);\n                response.setResults(\n                        new ClientResponseImpl(ClientResponse.GRACEFUL_FAILURE,\n                            new VoltTable[] {},\n                            \"Exception while deserializing procedure params\\n\" +\n                            result.toString()));\n            }\n            if (callerParams != null) {\n                ClientResponseImpl cr = null;\n                ProcedureRunner runner = siteConnection.getProcedureRunner(m_procName);\n                if (runner == null) {\n                    String error =\n                        \"Procedure \" + m_procName + \" is not present in the catalog. \"  +\n                        \"This can happen if a catalog update removing the procedure occurred \" +\n                        \"after the procedure was submitted \" +\n                        \"but before the procedure was executed.\";\n                    hostLog.debug(error);\n                    response.setResults(\n                            new ClientResponseImpl(\n                                ClientResponse.UNEXPECTED_FAILURE,\n                                new VoltTable[]{},\n                                error));\n                    return response;\n                }\n\n                // Check partitioning of the invocation\n                if (runner.checkPartition(m_txnState)) {\n                    runner.setupTransaction(m_txnState);\n                    cr = runner.call(task.getParameters());\n\n                    m_txnState.setHash(cr.getHash());\n\n                    response.setResults(cr);\n                    // record the results of write transactions to the transaction state\n                    // this may be used to verify the DR replica cluster gets the same value\n                    // skip for multi-partition txns because only 1 of k+1 partitions will\n                    //  have the real results\n                    if ((!task.isReadOnly()) && task.isSinglePartition()) {\n                        m_txnState.storeResults(cr);\n                    }\n                } else {\n                    // mis-partitioned invocation, reject it and let the ClientInterface restart it\n                    response.setMispartitioned(true, task.getStoredProcedureInvocation(),\n                                               TheHashinator.getCurrentVersionedConfig());\n                }\n            }\n        }\n        catch (final ExpectedProcedureException e) {\n            execLog.l7dlog( Level.TRACE, LogKeys.org_voltdb_ExecutionSite_ExpectedProcedureException.name(), e);\n            response.setResults(\n                    new ClientResponseImpl(\n                        ClientResponse.GRACEFUL_FAILURE,\n                        new VoltTable[]{},\n                        e.toString()));\n        }\n        catch (final Exception e) {\n            // Should not be able to reach here. VoltProcedure.call caught all invocation target exceptions\n            // and converted them to error responses. Java errors are re-thrown, and not caught by this\n            // exception clause. A truly unexpected exception reached this point. Crash. It's a defect.\n            hostLog.l7dlog( Level.ERROR, LogKeys.host_ExecutionSite_UnexpectedProcedureException.name(), e);\n            VoltDB.crashLocalVoltDB(e.getMessage(), true, e);\n        }\n        return response;\n    }","commit_id":"01ab15ccd479411687a93bf1a71ca6a4d164b679","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    protected void initFromBuffer(ByteBuffer buf) throws IOException\n    {\n        m_txnId = buf.getLong();\n        m_uniqueId = buf.getLong();\n        m_partitionId = buf.getInt();\n        int partitionCount = buf.getInt();\n        m_involvedPartitions = Sets.newHashSet();\n        for (int i = 0; i < partitionCount; i++) {\n            m_involvedPartitions.add(buf.getInt());\n        }\n        m_invocation = new StoredProcedureInvocation();\n        m_invocation.initFromBuffer(buf);\n    }","id":35088,"modified_method":"@Override\n    protected void initFromBuffer(ByteBuffer buf) throws IOException\n    {\n        m_txnId = buf.getLong();\n        m_uniqueId = buf.getLong();\n        m_partitionId = buf.getInt();\n        int partitionCount = buf.getInt();\n        m_involvedPartitions = Sets.newHashSet();\n        for (int i = 0; i < partitionCount; i++) {\n            m_involvedPartitions.add(buf.getInt());\n        }\n\n        if (buf.remaining() > 0) {\n            m_invocation = new StoredProcedureInvocation();\n            m_invocation.initFromBuffer(buf);\n        } else {\n            m_invocation = null;\n        }\n    }","commit_id":"26f5a833a9bbd24891d1de67023fd330f31af769","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public void flattenToBuffer(ByteBuffer buf) throws IOException\n    {\n        buf.put(VoltDbMessageFactory.MP_REPLAY_ID);\n        buf.putLong(m_txnId);\n        buf.putLong(m_uniqueId);\n        buf.putInt(m_partitionId);\n        buf.putInt(m_involvedPartitions.size());\n        for (int pid : m_involvedPartitions) {\n            buf.putInt(pid);\n        }\n        m_invocation.flattenToBuffer(buf);\n\n        assert(buf.capacity() == buf.position());\n        buf.limit(buf.position());\n    }","id":35089,"modified_method":"@Override\n    public void flattenToBuffer(ByteBuffer buf) throws IOException\n    {\n        buf.put(VoltDbMessageFactory.MP_REPLAY_ID);\n        buf.putLong(m_txnId);\n        buf.putLong(m_uniqueId);\n        buf.putInt(m_partitionId);\n        buf.putInt(m_involvedPartitions.size());\n        for (int pid : m_involvedPartitions) {\n            buf.putInt(pid);\n        }\n\n        if (m_invocation != null) {\n            m_invocation.flattenToBuffer(buf);\n        }\n\n        assert(buf.capacity() == buf.position());\n        buf.limit(buf.position());\n    }","commit_id":"26f5a833a9bbd24891d1de67023fd330f31af769","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public int getSerializedSize()\n    {\n        int size = super.getSerializedSize();\n        size +=   8 // m_txnId\n                + 8 // m_uniqueId\n                + 4 // m_partitionId\n                + 4 // m_involvedPartitions.size()\n                + 4 * m_involvedPartitions.size()\n                + m_invocation.getSerializedSize();\n        return size;\n    }","id":35090,"modified_method":"@Override\n    public int getSerializedSize()\n    {\n        int size = super.getSerializedSize();\n        size +=   8 // m_txnId\n                + 8 // m_uniqueId\n                + 4 // m_partitionId\n                + 4 // m_involvedPartitions.size()\n                + 4 * m_involvedPartitions.size();\n\n        if (m_invocation != null) {\n            size += m_invocation.getSerializedSize();\n        }\n\n        return size;\n    }","commit_id":"26f5a833a9bbd24891d1de67023fd330f31af769","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n  public void setContext(final Notifier ctx) {\n    this.context = ctx;\n    ResourceSet _resourceSet = EcoreUtil2.getResourceSet(ctx);\n    final XtextResourceSet resourceSet = ((XtextResourceSet) _resourceSet);\n    Module _findModule = ModuleProvider.findModule(resourceSet);\n    Project _project = _findModule.getProject();\n    this.project = _project;\n    boolean _equals = Objects.equal(this.project, null);\n    if (_equals) {\n      throw new IllegalStateException(\"project is null\");\n    }\n    GlobalSearchScope _projectScope = GlobalSearchScope.projectScope(this.project);\n    this.setScope(_projectScope);\n  }","id":35091,"modified_method":"@Override\n  public void setContext(final Notifier ctx) {\n    this.context = ctx;\n    ResourceSet _resourceSet = EcoreUtil2.getResourceSet(ctx);\n    final XtextResourceSet resourceSet = ((XtextResourceSet) _resourceSet);\n    final Module module = ModuleProvider.findModule(resourceSet);\n    boolean _equals = Objects.equal(module, null);\n    if (_equals) {\n      throw new IllegalStateException(\"module is null\");\n    } else {\n      Project _project = module.getProject();\n      this.project = _project;\n      GlobalSearchScope _projectScope = GlobalSearchScope.projectScope(this.project);\n      this.setScope(_projectScope);\n    }\n  }","commit_id":"3dd5eafe6a5c170f148f6d7c21003071a30f05ba","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void enqueue(final VirtualFile file, final BuildEvent.Type type) {\n    try {\n      boolean _notEquals = (!Objects.equal(file, null));\n      if (_notEquals) {\n        BuildEvent _buildEvent = new BuildEvent(file, type);\n        this.queue.put(_buildEvent);\n        this.alarm.cancelAllRequests();\n        final Runnable _function = new Runnable() {\n          @Override\n          public void run() {\n            XtextAutoBuilder.this.build();\n          }\n        };\n        this.alarm.addRequest(_function, 200);\n      }\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":35092,"modified_method":"protected void enqueue(final VirtualFile file, final BuildEvent.Type type) {\n    try {\n      boolean _and = false;\n      boolean _notEquals = (!Objects.equal(file, null));\n      if (!_notEquals) {\n        _and = false;\n      } else {\n        boolean _isDisposed = this.project.isDisposed();\n        boolean _not = (!_isDisposed);\n        _and = _not;\n      }\n      if (_and) {\n        BuildEvent _buildEvent = new BuildEvent(file, type);\n        this.queue.put(_buildEvent);\n        this.alarm.cancelAllRequests();\n        final Runnable _function = new Runnable() {\n          @Override\n          public void run() {\n            XtextAutoBuilder.this.build();\n          }\n        };\n        this.alarm.addRequest(_function, 200);\n      }\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"3dd5eafe6a5c170f148f6d7c21003071a30f05ba","url":"https://github.com/eclipse/xtext"},{"original_method":"public XtextCompilerComponent(Project project) {\n\t\tsuper(project);\n\t\tautoBuilder = new XtextAutoBuilder(project);\n\t\tEditorFactory.getInstance().getEventMulticaster().addDocumentListener(new DocumentAdapter() {\n\t\t\t@Override\n\t\t\tpublic void documentChanged(DocumentEvent event) {\n\t\t\t\tVirtualFile file = FileDocumentManager.getInstance().getFile(event.getDocument());\n\t\t\t\tautoBuilder.fileModified(file);\n\t\t\t}\n\t\t});\n\t\tVirtualFileManager.getInstance().addVirtualFileListener(new VirtualFileAdapter() {\n\t\t\t@Override\n\t\t\tpublic void contentsChanged(VirtualFileEvent event) {\n\t\t\t\tautoBuilder.fileModified(event.getFile());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void fileCreated(VirtualFileEvent event) {\n\t\t\t\tautoBuilder.fileAdded(event.getFile());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void fileDeleted(VirtualFileEvent event) {\n\t\t\t\tautoBuilder.fileDeleted(event.getFile());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void fileMoved(VirtualFileMoveEvent event) {\n\t\t\t\t// TODO deal with that!\n\t\t\t}\n\t\t});\n\t}","id":35093,"modified_method":"public XtextCompilerComponent(Project project) {\n\t\tsuper(project);\n\t\tautoBuilder = new XtextAutoBuilder(project);\n\t\tdocumentListener = new DocumentAdapter() {\n\t\t\t@Override\n\t\t\tpublic void documentChanged(DocumentEvent event) {\n\t\t\t\tVirtualFile file = FileDocumentManager.getInstance().getFile(event.getDocument());\n\t\t\t\tautoBuilder.fileModified(file);\n\t\t\t}\n\t\t};\n\t\tEditorFactory.getInstance().getEventMulticaster().addDocumentListener(documentListener);\n\t\tvirtualFileListener = new VirtualFileAdapter() {\n\t\t\t@Override\n\t\t\tpublic void contentsChanged(VirtualFileEvent event) {\n\t\t\t\tautoBuilder.fileModified(event.getFile());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void fileCreated(VirtualFileEvent event) {\n\t\t\t\tautoBuilder.fileAdded(event.getFile());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void fileDeleted(VirtualFileEvent event) {\n\t\t\t\tautoBuilder.fileDeleted(event.getFile());\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void fileMoved(VirtualFileMoveEvent event) {\n\t\t\t\t// TODO deal with that!\n\t\t\t}\n\t\t};\n\t\tVirtualFileManager.getInstance().addVirtualFileListener(virtualFileListener);\n\t}","commit_id":"3dd5eafe6a5c170f148f6d7c21003071a30f05ba","url":"https://github.com/eclipse/xtext"},{"original_method":"public PythonPathCache(Module module) {\n    module.getMessageBus().connect().subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n      public void beforeRootsChange(ModuleRootEvent event) {\n      }\n\n      public void rootsChanged(ModuleRootEvent event) {\n        myCache.clear();\n      }\n    });\n    VirtualFileManager.getInstance().addVirtualFileListener(new VirtualFileAdapter() {\n      @Override\n      public void fileCreated(VirtualFileEvent event) {\n        myCache.clear();\n      }\n\n      @Override\n      public void fileDeleted(VirtualFileEvent event) {\n        myCache.clear();\n      }\n\n      @Override\n      public void fileMoved(VirtualFileMoveEvent event) {\n        myCache.clear();\n      }\n\n      @Override\n      public void fileCopied(VirtualFileCopyEvent event) {\n        myCache.clear();\n      }\n\n      @Override\n      public void propertyChanged(VirtualFilePropertyEvent event) {\n        if (event.getPropertyName().equals(VirtualFile.PROP_NAME)) {\n          myCache.clear();\n        }\n      }\n    }, module);\n  }","id":35094,"modified_method":"public PythonPathCache(Module module) {\n    module.getMessageBus().connect().subscribe(ProjectTopics.PROJECT_ROOTS, new ModuleRootListener() {\n      public void beforeRootsChange(ModuleRootEvent event) {\n      }\n\n      public void rootsChanged(ModuleRootEvent event) {\n        myCache.clear();\n      }\n    });\n    VirtualFileManager.getInstance().addVirtualFileListener(new MyVirtualFileAdapter(), this);\n  }","commit_id":"e28829ea5a5fc8470d70376b71838bad6c31d778","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns the list of directories/files under different project roots which match the specified qualified name.\n   *\n   * @param moduleQualifiedName the qualified name to find\n   * @param foothold            the PSI element in the context of which the search is performed\n   * @return the list of matching directories or files, or an empty list if nothing was found\n   */\n  @NotNull\n  public static List<PsiElement> resolveModulesInRoots(@NotNull PyQualifiedName moduleQualifiedName, PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return Collections.emptyList();\n    PsiFile footholdFile = foothold.getContainingFile();\n    if (footholdFile == null || !footholdFile.isValid()) return Collections.emptyList();\n\n    if (moduleQualifiedName.getComponentCount() < 1) return Collections.emptyList();\n\n    PythonPathCache cache = null;\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n    if (module != null) {\n      cache = PythonPathCache.getInstance(module);\n      final List<PsiElement> cachedResults = cache.get(moduleQualifiedName);\n      if (cachedResults != null) {\n        return cachedResults;\n      }\n    }\n    ResolveInRootVisitor visitor = new ResolveInRootVisitor(moduleQualifiedName, foothold.getManager(), footholdFile);\n    visitRoots(foothold, visitor);\n    if (cache != null) {\n      cache.put(moduleQualifiedName, visitor.results);\n    }\n    return visitor.results;\n  }","id":35095,"modified_method":"/**\n   * Returns the list of directories/files under different project roots which match the specified qualified name.\n   *\n   * @param moduleQualifiedName the qualified name to find\n   * @param foothold            the PSI element in the context of which the search is performed\n   * @return the list of matching directories or files, or an empty list if nothing was found\n   */\n  @NotNull\n  public static List<PsiElement> resolveModulesInRoots(@NotNull PyQualifiedName moduleQualifiedName, PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return Collections.emptyList();\n    PsiFile footholdFile = foothold.getContainingFile();\n    if (footholdFile == null || !footholdFile.isValid()) return Collections.emptyList();\n\n    if (moduleQualifiedName.getComponentCount() < 1) return Collections.emptyList();\n\n    PythonPathCache cache = null;\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n    if (module != null) {\n      cache = PythonPathCache.getInstance(module);\n    }\n    else {\n      final Sdk sdk = PyBuiltinCache.findSdkForFile(footholdFile);\n      if (sdk != null) {\n        cache = PythonPathCache.getInstance(foothold.getProject(), sdk);\n      }\n    }\n    if (cache != null) {\n      final List<PsiElement> cachedResults = cache.get(moduleQualifiedName);\n      if (cachedResults != null) {\n        return cachedResults;\n      }\n    }\n    ResolveInRootVisitor visitor = new ResolveInRootVisitor(moduleQualifiedName, foothold.getManager(), footholdFile);\n    visitRoots(foothold, visitor);\n    if (cache != null) {\n      cache.put(moduleQualifiedName, visitor.results);\n    }\n    return visitor.results;\n  }","commit_id":"e28829ea5a5fc8470d70376b71838bad6c31d778","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DartAnalyzerService(final Project project) {\n    myProject = project;\n\n    LocalFileSystem.getInstance().addVirtualFileListener(new VirtualFileAdapter() {\n      public void beforePropertyChange(final VirtualFilePropertyEvent event) {\n        if (VirtualFile.PROP_NAME.equals(event.getPropertyName())) {\n          fileDeleted(event);\n        }\n      }\n\n      public void beforeFileMovement(final VirtualFileMoveEvent event) {\n        fileDeleted(event);\n      }\n\n      public void fileDeleted(final VirtualFileEvent event) {\n        if (FileUtilRt.extensionEquals(event.getFileName(), DartFileType.DEFAULT_EXTENSION)) {\n          myFileToSourceMap.remove(event.getFile());\n        }\n      }\n\n      public void propertyChanged(final VirtualFilePropertyEvent event) {\n        if (VirtualFile.PROP_NAME.equals(event.getPropertyName())) {\n          fileCreated(event);\n        }\n      }\n\n      public void fileMoved(final VirtualFileMoveEvent event) {\n        fileCreated(event);\n      }\n\n      public void fileCopied(final VirtualFileCopyEvent event) {\n        fileCreated(event);\n      }\n\n      public void fileCreated(final VirtualFileEvent event) {\n        if (FileUtilRt.extensionEquals(event.getFileName(), DartFileType.DEFAULT_EXTENSION)) {\n          myCreatedFiles.add(event.getFile());\n        }\n      }\n    });\n  }","id":35096,"modified_method":"public DartAnalyzerService(final Project project) {\n    myProject = project;\n\n    final VirtualFileAdapter listener = new VirtualFileAdapter() {\n      public void beforePropertyChange(final VirtualFilePropertyEvent event) {\n        if (VirtualFile.PROP_NAME.equals(event.getPropertyName())) {\n          fileDeleted(event);\n        }\n      }\n\n      public void beforeFileMovement(final VirtualFileMoveEvent event) {\n        fileDeleted(event);\n      }\n\n      public void fileDeleted(final VirtualFileEvent event) {\n        if (FileUtilRt.extensionEquals(event.getFileName(), DartFileType.DEFAULT_EXTENSION)) {\n          myFileToSourceMap.remove(event.getFile());\n        }\n      }\n\n      public void propertyChanged(final VirtualFilePropertyEvent event) {\n        if (VirtualFile.PROP_NAME.equals(event.getPropertyName())) {\n          fileCreated(event);\n        }\n      }\n\n      public void fileMoved(final VirtualFileMoveEvent event) {\n        fileCreated(event);\n      }\n\n      public void fileCopied(final VirtualFileCopyEvent event) {\n        fileCreated(event);\n      }\n\n      public void fileCreated(final VirtualFileEvent event) {\n        if (FileUtilRt.extensionEquals(event.getFileName(), DartFileType.DEFAULT_EXTENSION)) {\n          myCreatedFiles.add(event.getFile());\n        }\n      }\n    };\n\n    LocalFileSystem.getInstance().addVirtualFileListener(listener);\n\n    Disposer.register(project, new Disposable() {\n      public void dispose() {\n        LocalFileSystem.getInstance().removeVirtualFileListener(listener);\n      }\n    });\n  }","commit_id":"5185e998eca52b2ba2d4d3082c160ac49e22535c","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void dispose() {\n        Disposer.dispose(editorUI);\n        VirtualFileManager.getInstance().removeVirtualFileListener(this);\n        disposed = true;\n    }","id":35097,"modified_method":"public void dispose() {\n    disposed = true;\n  }","commit_id":"3fe78ffaaf364b8ee33fe252d524d7da95bf540f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"ImageEditorImpl(@NotNull Project project, @NotNull VirtualFile file) {\n        this.project = project;\n        this.file = file;\n\n        editorUI = new ImageEditorUI(this);\n\n        VirtualFileManager.getInstance().addVirtualFileListener(this);\n\n        setValue(file);\n    }","id":35098,"modified_method":"ImageEditorImpl(@NotNull Project project, @NotNull VirtualFile file) {\n    this.project = project;\n    this.file = file;\n\n    editorUI = new ImageEditorUI(this);\n    Disposer.register(this, editorUI);\n\n    VirtualFileManager.getInstance().addVirtualFileListener(new VirtualFileAdapter() {\n      @Override\n      public void propertyChanged(@NotNull VirtualFilePropertyEvent event) {\n        ImageEditorImpl.this.propertyChanged(event);\n      }\n\n      @Override\n      public void contentsChanged(@NotNull VirtualFileEvent event) {\n        ImageEditorImpl.this.contentsChanged(event);\n      }\n    }, this);\n\n    setValue(file);\n  }","commit_id":"3fe78ffaaf364b8ee33fe252d524d7da95bf540f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void contentsChanged(@NotNull VirtualFileEvent event) {\n        super.contentsChanged(event);\n        if (file.equals(event.getFile())) {\n            // Change document\n            file.refresh(true, false, new Runnable() {\n                public void run() {\n                    setValue(file);\n                }\n            });\n        }\n    }","id":35099,"modified_method":"void contentsChanged(@NotNull VirtualFileEvent event) {\n    if (file.equals(event.getFile())) {\n      // Change document\n      file.refresh(true, false, new Runnable() {\n        public void run() {\n          setValue(file);\n        }\n      });\n    }\n  }","commit_id":"3fe78ffaaf364b8ee33fe252d524d7da95bf540f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void propertyChanged(@NotNull VirtualFilePropertyEvent event) {\n        super.propertyChanged(event);\n        if (file.equals(event.getFile())) {\n            // Change document\n            file.refresh(true, false, new Runnable() {\n                public void run() {\n                    if (ImageFileTypeManager.getInstance().isImage(file)) {\n                        setValue(file);\n                    } else {\n                        setValue(null);\n                        // Close editor\n                        FileEditorManager editorManager = FileEditorManager.getInstance(project);\n                        editorManager.closeFile(file);\n                    }\n                }\n            });\n        }\n    }","id":35100,"modified_method":"void propertyChanged(@NotNull VirtualFilePropertyEvent event) {\n    if (file.equals(event.getFile())) {\n      // Change document\n      file.refresh(true, false, new Runnable() {\n        public void run() {\n          if (ImageFileTypeManager.getInstance().isImage(file)) {\n            setValue(file);\n          }\n          else {\n            setValue(null);\n            // Close editor\n            FileEditorManager editorManager = FileEditorManager.getInstance(project);\n            editorManager.closeFile(file);\n          }\n        }\n      });\n    }\n  }","commit_id":"3fe78ffaaf364b8ee33fe252d524d7da95bf540f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"ImageFileEditorImpl(@NotNull Project project, @NotNull VirtualFile file) {\n        imageEditor = ImageEditorManagerImpl.createImageEditor(project, file);\n\n        // Append file listener\n        VirtualFileManager.getInstance().addVirtualFileListener(imageEditor);\n\n        // Set background and grid default options\n        Options options = OptionsManager.getInstance().getOptions();\n        EditorOptions editorOptions = options.getEditorOptions();\n        GridOptions gridOptions = editorOptions.getGridOptions();\n        TransparencyChessboardOptions transparencyChessboardOptions = editorOptions.getTransparencyChessboardOptions();\n        imageEditor.setGridVisible(gridOptions.isShowDefault());\n        imageEditor.setTransparencyChessboardVisible(transparencyChessboardOptions.isShowDefault());\n    }","id":35101,"modified_method":"ImageFileEditorImpl(@NotNull Project project, @NotNull VirtualFile file) {\n    imageEditor = new ImageEditorImpl(project, file);\n    Disposer.register(this, imageEditor);\n\n    // Set background and grid default options\n    Options options = OptionsManager.getInstance().getOptions();\n    EditorOptions editorOptions = options.getEditorOptions();\n    GridOptions gridOptions = editorOptions.getGridOptions();\n    TransparencyChessboardOptions transparencyChessboardOptions = editorOptions.getTransparencyChessboardOptions();\n    imageEditor.setGridVisible(gridOptions.isShowDefault());\n    imageEditor.setTransparencyChessboardVisible(transparencyChessboardOptions.isShowDefault());\n  }","commit_id":"3fe78ffaaf364b8ee33fe252d524d7da95bf540f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n        VirtualFileManager.getInstance().removeVirtualFileListener(imageEditor);\n        ImageEditorManagerImpl.releaseImageEditor(imageEditor);\n    }","id":35102,"modified_method":"public void dispose() {\n  }","commit_id":"3fe78ffaaf364b8ee33fe252d524d7da95bf540f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Gets a set to bits.\n     */\n    public static Bits toSafeBits(LeafReader reader, @Nullable DocIdSet set) throws IOException {\n        if (set == null) {\n            return new Bits.MatchNoBits(reader.maxDoc());\n        }\n        Bits bits = set.bits();\n        if (bits != null) {\n            return bits;\n        }\n        DocIdSetIterator iterator = set.iterator();\n        if (iterator == null) {\n            return new Bits.MatchNoBits(reader.maxDoc());\n        }\n        return toBitSet(iterator, reader.maxDoc());\n    }","id":35103,"modified_method":"/**\n     * Get a build a {@link Bits} instance that will match all documents\n     * contained in {@code set}. Note that this is a potentially heavy\n     * operation as this might require to consume an iterator of this set\n     * entirely and to load it into a {@link BitSet}. Prefer using\n     * {@link #asSequentialAccessBits} if you only need to consume the\n     * {@link Bits} once and in order.\n     */\n    public static Bits toSafeBits(int maxDoc, @Nullable DocIdSet set) throws IOException {\n        if (set == null) {\n            return new Bits.MatchNoBits(maxDoc);\n        }\n        Bits bits = set.bits();\n        if (bits != null) {\n            return bits;\n        }\n        DocIdSetIterator iterator = set.iterator();\n        if (iterator == null) {\n            return new Bits.MatchNoBits(maxDoc);\n        }\n        return toBitSet(iterator, maxDoc);\n    }","commit_id":"8540a863aa8225b9e5c7c4a94c8d0523901502e8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void setNextReader(LeafReaderContext reader) {\n        try {\n            bits = DocIdSets.toSafeBits(reader.reader(), filter.getDocIdSet(reader, null));\n        } catch (IOException ioe) {\n            throw new AggregationExecutionException(\"Failed to aggregate filter aggregator [\" + name + \"]\", ioe);\n        }\n    }","id":35104,"modified_method":"@Override\n    public void setNextReader(LeafReaderContext reader) {\n        try {\n            bits = DocIdSets.asSequentialAccessBits(reader.reader().maxDoc(), filter.getDocIdSet(reader, null));\n        } catch (IOException ioe) {\n            throw new AggregationExecutionException(\"Failed to aggregate filter aggregator [\" + name + \"]\", ioe);\n        }\n    }","commit_id":"8540a863aa8225b9e5c7c4a94c8d0523901502e8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public FilterableTermsEnum(IndexReader reader, String field, int docsEnumFlag, @Nullable final Filter filter) throws IOException {\n        if ((docsEnumFlag != DocsEnum.FLAG_FREQS) && (docsEnumFlag != DocsEnum.FLAG_NONE)) {\n            throw new ElasticsearchIllegalArgumentException(\"invalid docsEnumFlag of \" + docsEnumFlag);\n        }\n        this.docsEnumFlag = docsEnumFlag;\n        if (filter == null) {\n            // Important - need to use the doc count that includes deleted docs\n            // or we have this issue: https://github.com/elasticsearch/elasticsearch/issues/7951\n            numDocs = reader.maxDoc();\n        }\n        List<LeafReaderContext> leaves = reader.leaves();\n        List<Holder> enums = Lists.newArrayListWithExpectedSize(leaves.size());\n        for (LeafReaderContext context : leaves) {\n            Terms terms = context.reader().terms(field);\n            if (terms == null) {\n                continue;\n            }\n            TermsEnum termsEnum = terms.iterator(null);\n            if (termsEnum == null) {\n                continue;\n            }\n            Bits bits = null;\n            if (filter != null) {\n                // we want to force apply deleted docs\n                DocIdSet docIdSet = filter.getDocIdSet(context, context.reader().getLiveDocs());\n                if (DocIdSets.isEmpty(docIdSet)) {\n                    // fully filtered, none matching, no need to iterate on this\n                    continue;\n                }\n                bits = DocIdSets.toSafeBits(context.reader(), docIdSet);\n                // Count how many docs are in our filtered set\n                // TODO make this lazy-loaded only for those that need it?\n                DocIdSetIterator iterator = docIdSet.iterator();\n                if (iterator != null) {\n                    while (iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                        numDocs++;\n                    }\n                }\n            }\n            enums.add(new Holder(termsEnum, bits));\n        }\n        this.enums = enums.toArray(new Holder[enums.size()]);\n    }","id":35105,"modified_method":"public FilterableTermsEnum(IndexReader reader, String field, int docsEnumFlag, @Nullable final Filter filter) throws IOException {\n        if ((docsEnumFlag != DocsEnum.FLAG_FREQS) && (docsEnumFlag != DocsEnum.FLAG_NONE)) {\n            throw new ElasticsearchIllegalArgumentException(\"invalid docsEnumFlag of \" + docsEnumFlag);\n        }\n        this.docsEnumFlag = docsEnumFlag;\n        if (filter == null) {\n            // Important - need to use the doc count that includes deleted docs\n            // or we have this issue: https://github.com/elasticsearch/elasticsearch/issues/7951\n            numDocs = reader.maxDoc();\n        }\n        List<LeafReaderContext> leaves = reader.leaves();\n        List<Holder> enums = Lists.newArrayListWithExpectedSize(leaves.size());\n        for (LeafReaderContext context : leaves) {\n            Terms terms = context.reader().terms(field);\n            if (terms == null) {\n                continue;\n            }\n            TermsEnum termsEnum = terms.iterator(null);\n            if (termsEnum == null) {\n                continue;\n            }\n            Bits bits = null;\n            if (filter != null) {\n                // we want to force apply deleted docs\n                DocIdSet docIdSet = filter.getDocIdSet(context, context.reader().getLiveDocs());\n                if (DocIdSets.isEmpty(docIdSet)) {\n                    // fully filtered, none matching, no need to iterate on this\n                    continue;\n                }\n                bits = DocIdSets.toSafeBits(context.reader().maxDoc(), docIdSet);\n                // Count how many docs are in our filtered set\n                // TODO make this lazy-loaded only for those that need it?\n                DocIdSetIterator iterator = docIdSet.iterator();\n                if (iterator != null) {\n                    while (iterator.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {\n                        numDocs++;\n                    }\n                }\n            }\n            enums.add(new Holder(termsEnum, bits));\n        }\n        this.enums = enums.toArray(new Holder[enums.size()]);\n    }","commit_id":"8540a863aa8225b9e5c7c4a94c8d0523901502e8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void setNextReader(LeafReaderContext reader) {\n        try {\n            for (int i = 0; i < filters.length; i++) {\n                bits[i] = DocIdSets.toSafeBits(reader.reader(), filters[i].filter.getDocIdSet(reader, null));\n            }\n        } catch (IOException ioe) {\n            throw new AggregationExecutionException(\"Failed to aggregate filter aggregator [\" + name + \"]\", ioe);\n        }\n    }","id":35106,"modified_method":"@Override\n    public void setNextReader(LeafReaderContext reader) {\n        try {\n            for (int i = 0; i < filters.length; i++) {\n                bits[i] = DocIdSets.asSequentialAccessBits(reader.reader().maxDoc(), filters[i].filter.getDocIdSet(reader, null));\n            }\n        } catch (IOException ioe) {\n            throw new AggregationExecutionException(\"Failed to aggregate filter aggregator [\" + name + \"]\", ioe);\n        }\n    }","commit_id":"8540a863aa8225b9e5c7c4a94c8d0523901502e8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n\n            Explanation subQueryExpl = subQueryWeight.explain(context, doc);\n            if (!subQueryExpl.isMatch()) {\n                return subQueryExpl;\n            }\n            // First: Gather explanations for all filters\n            List<ComplexExplanation> filterExplanations = new ArrayList<>();\n            float weightSum = 0;\n            for (FilterFunction filterFunction : filterFunctions) {\n\n                if (filterFunction.function instanceof WeightFactorFunction) {\n                    weightSum += ((WeightFactorFunction) filterFunction.function).getWeight();\n                } else {\n                    weightSum++;\n                }\n\n                Bits docSet = DocIdSets.toSafeBits(context.reader(),\n                        filterFunction.filter.getDocIdSet(context, context.reader().getLiveDocs()));\n                if (docSet.get(doc)) {\n                    filterFunction.function.setNextReader(context);\n                    Explanation functionExplanation = filterFunction.function.explainScore(doc, subQueryExpl.getValue());\n                    double factor = functionExplanation.getValue();\n                    float sc = CombineFunction.toFloat(factor);\n                    ComplexExplanation filterExplanation = new ComplexExplanation(true, sc, \"function score, product of:\");\n                    filterExplanation.addDetail(new Explanation(1.0f, \"match filter: \" + filterFunction.filter.toString()));\n                    filterExplanation.addDetail(functionExplanation);\n                    filterExplanations.add(filterExplanation);\n                }\n            }\n            if (filterExplanations.size() == 0) {\n                float sc = getBoost() * subQueryExpl.getValue();\n                Explanation res = new ComplexExplanation(true, sc, \"function score, no filter match, product of:\");\n                res.addDetail(subQueryExpl);\n                res.addDetail(new Explanation(getBoost(), \"queryBoost\"));\n                return res;\n            }\n\n            // Second: Compute the factor that would have been computed by the\n            // filters\n            double factor = 1.0;\n            switch (scoreMode) {\n            case First:\n\n                factor = filterExplanations.get(0).getValue();\n                break;\n            case Max:\n                factor = Double.NEGATIVE_INFINITY;\n                for (int i = 0; i < filterExplanations.size(); i++) {\n                    factor = Math.max(filterExplanations.get(i).getValue(), factor);\n                }\n                break;\n            case Min:\n                factor = Double.POSITIVE_INFINITY;\n                for (int i = 0; i < filterExplanations.size(); i++) {\n                    factor = Math.min(filterExplanations.get(i).getValue(), factor);\n                }\n                break;\n            case Multiply:\n                for (int i = 0; i < filterExplanations.size(); i++) {\n                    factor *= filterExplanations.get(i).getValue();\n                }\n                break;\n            default: // Avg / Total\n                double totalFactor = 0.0f;\n                for (int i = 0; i < filterExplanations.size(); i++) {\n                    totalFactor += filterExplanations.get(i).getValue();\n                }\n                if (weightSum != 0) {\n                    factor = totalFactor;\n                    if (scoreMode == ScoreMode.Avg) {\n                        factor /= weightSum;\n                    }\n                }\n            }\n            ComplexExplanation factorExplanaition = new ComplexExplanation(true, CombineFunction.toFloat(factor),\n                    \"function score, score mode [\" + scoreMode.toString().toLowerCase(Locale.ROOT) + \"]\");\n            for (int i = 0; i < filterExplanations.size(); i++) {\n                factorExplanaition.addDetail(filterExplanations.get(i));\n            }\n            return combineFunction.explain(getBoost(), subQueryExpl, factorExplanaition, maxBoost);\n        }","id":35107,"modified_method":"@Override\n        public Explanation explain(LeafReaderContext context, int doc) throws IOException {\n\n            Explanation subQueryExpl = subQueryWeight.explain(context, doc);\n            if (!subQueryExpl.isMatch()) {\n                return subQueryExpl;\n            }\n            // First: Gather explanations for all filters\n            List<ComplexExplanation> filterExplanations = new ArrayList<>();\n            float weightSum = 0;\n            for (FilterFunction filterFunction : filterFunctions) {\n\n                if (filterFunction.function instanceof WeightFactorFunction) {\n                    weightSum += ((WeightFactorFunction) filterFunction.function).getWeight();\n                } else {\n                    weightSum++;\n                }\n\n                Bits docSet = DocIdSets.asSequentialAccessBits(context.reader().maxDoc(),\n                        filterFunction.filter.getDocIdSet(context, context.reader().getLiveDocs()));\n                if (docSet.get(doc)) {\n                    filterFunction.function.setNextReader(context);\n                    Explanation functionExplanation = filterFunction.function.explainScore(doc, subQueryExpl.getValue());\n                    double factor = functionExplanation.getValue();\n                    float sc = CombineFunction.toFloat(factor);\n                    ComplexExplanation filterExplanation = new ComplexExplanation(true, sc, \"function score, product of:\");\n                    filterExplanation.addDetail(new Explanation(1.0f, \"match filter: \" + filterFunction.filter.toString()));\n                    filterExplanation.addDetail(functionExplanation);\n                    filterExplanations.add(filterExplanation);\n                }\n            }\n            if (filterExplanations.size() == 0) {\n                float sc = getBoost() * subQueryExpl.getValue();\n                Explanation res = new ComplexExplanation(true, sc, \"function score, no filter match, product of:\");\n                res.addDetail(subQueryExpl);\n                res.addDetail(new Explanation(getBoost(), \"queryBoost\"));\n                return res;\n            }\n\n            // Second: Compute the factor that would have been computed by the\n            // filters\n            double factor = 1.0;\n            switch (scoreMode) {\n            case First:\n\n                factor = filterExplanations.get(0).getValue();\n                break;\n            case Max:\n                factor = Double.NEGATIVE_INFINITY;\n                for (int i = 0; i < filterExplanations.size(); i++) {\n                    factor = Math.max(filterExplanations.get(i).getValue(), factor);\n                }\n                break;\n            case Min:\n                factor = Double.POSITIVE_INFINITY;\n                for (int i = 0; i < filterExplanations.size(); i++) {\n                    factor = Math.min(filterExplanations.get(i).getValue(), factor);\n                }\n                break;\n            case Multiply:\n                for (int i = 0; i < filterExplanations.size(); i++) {\n                    factor *= filterExplanations.get(i).getValue();\n                }\n                break;\n            default: // Avg / Total\n                double totalFactor = 0.0f;\n                for (int i = 0; i < filterExplanations.size(); i++) {\n                    totalFactor += filterExplanations.get(i).getValue();\n                }\n                if (weightSum != 0) {\n                    factor = totalFactor;\n                    if (scoreMode == ScoreMode.Avg) {\n                        factor /= weightSum;\n                    }\n                }\n            }\n            ComplexExplanation factorExplanaition = new ComplexExplanation(true, CombineFunction.toFloat(factor),\n                    \"function score, score mode [\" + scoreMode.toString().toLowerCase(Locale.ROOT) + \"]\");\n            for (int i = 0; i < filterExplanations.size(); i++) {\n                factorExplanaition.addDetail(filterExplanations.get(i));\n            }\n            return combineFunction.explain(getBoost(), subQueryExpl, factorExplanaition, maxBoost);\n        }","commit_id":"8540a863aa8225b9e5c7c4a94c8d0523901502e8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n            // we ignore scoreDocsInOrder parameter, because we need to score in\n            // order if documents are scored with a script. The\n            // ShardLookup depends on in order scoring.\n            Scorer subQueryScorer = subQueryWeight.scorer(context, acceptDocs);\n            if (subQueryScorer == null) {\n                return null;\n            }\n            for (int i = 0; i < filterFunctions.length; i++) {\n                FilterFunction filterFunction = filterFunctions[i];\n                filterFunction.function.setNextReader(context);\n                docSets[i] = DocIdSets.toSafeBits(context.reader(), filterFunction.filter.getDocIdSet(context, acceptDocs));\n            }\n            return new FiltersFunctionFactorScorer(this, subQueryScorer, scoreMode, filterFunctions, maxBoost, docSets, combineFunction, minScore);\n        }","id":35108,"modified_method":"@Override\n        public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {\n            // we ignore scoreDocsInOrder parameter, because we need to score in\n            // order if documents are scored with a script. The\n            // ShardLookup depends on in order scoring.\n            Scorer subQueryScorer = subQueryWeight.scorer(context, acceptDocs);\n            if (subQueryScorer == null) {\n                return null;\n            }\n            for (int i = 0; i < filterFunctions.length; i++) {\n                FilterFunction filterFunction = filterFunctions[i];\n                filterFunction.function.setNextReader(context);\n                docSets[i] = DocIdSets.asSequentialAccessBits(context.reader().maxDoc(), filterFunction.filter.getDocIdSet(context, acceptDocs));\n            }\n            return new FiltersFunctionFactorScorer(this, subQueryScorer, scoreMode, filterFunctions, maxBoost, docSets, combineFunction, minScore);\n        }","commit_id":"8540a863aa8225b9e5c7c4a94c8d0523901502e8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public void setNextReader(LeafReaderContext reader) {\n        if (replay == null) {\n            return;\n        }\n\n        globalOrdinals = valuesSource.globalOrdinalsValues(parentType);\n        assert globalOrdinals != null;\n        try {\n            DocIdSet parentDocIdSet = parentFilter.getDocIdSet(reader, null);\n            // The DocIdSets.toSafeBits(...) can convert to FixedBitSet, but this\n            // will only happen if the none filter cache is used. (which only happens in tests)\n            // Otherwise the filter cache will produce a bitset based filter.\n            parentDocs = DocIdSets.toSafeBits(reader.reader(), parentDocIdSet);\n            DocIdSet childDocIdSet = childFilter.getDocIdSet(reader, null);\n            if (globalOrdinals != null && !DocIdSets.isEmpty(childDocIdSet)) {\n                replay.add(reader);\n            }\n        } catch (IOException e) {\n            throw ExceptionsHelper.convertToElastic(e);\n        }\n    }","id":35109,"modified_method":"@Override\n    public void setNextReader(LeafReaderContext reader) {\n        if (replay == null) {\n            return;\n        }\n\n        globalOrdinals = valuesSource.globalOrdinalsValues(parentType);\n        assert globalOrdinals != null;\n        try {\n            DocIdSet parentDocIdSet = parentFilter.getDocIdSet(reader, null);\n            // The DocIdSets.toSafeBits(...) can convert to FixedBitSet, but this\n            // will only happen if the none filter cache is used. (which only happens in tests)\n            // Otherwise the filter cache will produce a bitset based filter.\n            parentDocs = DocIdSets.asSequentialAccessBits(reader.reader().maxDoc(), parentDocIdSet);\n            DocIdSet childDocIdSet = childFilter.getDocIdSet(reader, null);\n            if (globalOrdinals != null && !DocIdSets.isEmpty(childDocIdSet)) {\n                replay.add(reader);\n            }\n        } catch (IOException e) {\n            throw ExceptionsHelper.convertToElastic(e);\n        }\n    }","commit_id":"8540a863aa8225b9e5c7c4a94c8d0523901502e8","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Test Redirection 3xx (Response Code)\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc2616#section-10.3\">RFC 2616 (section 10.3)<\/a>\n     */\n    @Test\n    public void test10_3_RedirectHttp11Resource() throws Exception\n    {\n        // HTTP/1.1 - redirect with resource/content\n\n        StringBuffer req4 = new StringBuffer();\n        req4.append(\"GET /redirect/R2.txt HTTP/1.1\\n\");\n        req4.append(\"Host: localhost\\n\");\n        req4.append(\"Connection: close\\n\");\n        req4.append(\"\\n\");\n\n        HttpTester.Response response = http.request(req4);\n\n        String specId = \"10.3 Redirection HTTP/1.1 w/content\";\n        assertEquals(specId,HttpStatus.FOUND_302, response.getStatus());\n        assertEquals(specId,server.getScheme() + \"://localhost/tests/R2.txt\", response.get(\"Location\"));\n        assertEquals(specId,\"close\", response.get(\"Connection\"));\n        assertTrue(specId,response.get(\"Content-Length\") == null);\n    }","id":35110,"modified_method":"/**\n     * Test Redirection 3xx (Response Code)\n     * \n     * @see <a href=\"http://tools.ietf.org/html/rfc2616#section-10.3\">RFC 2616 (section 10.3)<\/a>\n     */\n    @Test\n    public void test10_3_RedirectHttp11Resource() throws Exception\n    {\n        // HTTP/1.1 - redirect with resource/content\n\n        StringBuffer req4 = new StringBuffer();\n        req4.append(\"GET /redirect/R2.txt HTTP/1.1\\n\");\n        req4.append(\"Host: localhost\\n\");\n        req4.append(\"Connection: close\\n\");\n        req4.append(\"\\n\");\n\n        HttpTester.Response response = http.request(req4);\n        \n        String specId = \"10.3 Redirection HTTP/1.1 w/content\";\n        assertThat(specId + \" [status]\",response.getStatus(),is(HttpStatus.FOUND_302));\n        assertThat(specId + \" [location]\",response.get(\"Location\"),is(server.getScheme() + \"://localhost/tests/R2.txt\"));\n        assertThat(specId + \" [connection]\",response.get(\"Connection\"),is(\"close\"));\n        assertThat(specId + \" [content-length]\",response.get(\"Content-Length\"), nullValue());\n    }","commit_id":"0476d4d28d6350616bb41525d0b6cbe1067d57aa","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String apply(String target, HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        response.setHeader(\"Location\",response.encodeRedirectURL(_location));\n        response.sendError(_statusCode);\n        return target;\n    }","id":35111,"modified_method":"@Override\n    public String apply(String target, HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        String location = response.encodeRedirectURL(_location);\n        response.setHeader(\"Location\",RedirectUtil.toRedirectURL(request,location));\n        response.setStatus(_statusCode);\n        response.getOutputStream().flush(); // no output / content\n        response.getOutputStream().close();\n        return target;\n    }","commit_id":"0476d4d28d6350616bb41525d0b6cbe1067d57aa","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    protected String apply(String target, HttpServletRequest request, HttpServletResponse response, Matcher matcher)\n            throws IOException\n    {\n        target=_replacement;\n        for (int g=1;g<=matcher.groupCount();g++)\n        {\n            String group = matcher.group(g);\n            target=target.replaceAll(\"\\\\$\"+g,group);\n        }\n\n        response.setHeader(\"Location\",response.encodeRedirectURL(target));\n        response.sendError(_statusCode);\n        return target;\n    }","id":35112,"modified_method":"@Override\n    protected String apply(String target, HttpServletRequest request, HttpServletResponse response, Matcher matcher)\n            throws IOException\n    {\n        target=_replacement;\n        for (int g=1;g<=matcher.groupCount();g++)\n        {\n            String group = matcher.group(g);\n            target=target.replaceAll(\"\\\\$\"+g,group);\n        }\n        \n        target = response.encodeRedirectURL(target);\n        response.setHeader(\"Location\",RedirectUtil.toRedirectURL(request,target));\n        response.setStatus(_statusCode);\n        response.getOutputStream().flush(); // no output / content\n        response.getOutputStream().close();\n        return target;\n    }","commit_id":"0476d4d28d6350616bb41525d0b6cbe1067d57aa","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void bind(ServletRequest request) {\n        MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);\n\n        checkStructuredDateDefinitions(request,mpvs);\n        autoCreateIfPossible(mpvs);\n        bindAssociations(mpvs); \n        if(request instanceof HttpServletRequestWrapper) {\n            request = ((HttpServletRequestWrapper)request).getRequest();\n        }\n        \n\t\tif (request instanceof MultipartHttpServletRequest) {\n\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\tbindMultipartFiles(multipartRequest.getFileMap(), mpvs);\n\t\t}\n\n        super.doBind(mpvs);\n    }","id":35113,"modified_method":"public void bind(ServletRequest request) {\n        MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request);\n\n        checkStructuredDateDefinitions(request,mpvs);\n        autoCreateIfPossible(mpvs);\n        bindAssociations(mpvs); \n        if(request instanceof HttpServletRequestWrapper) {\n            request = ((HttpServletRequestWrapper)request).getRequest();\n        }\n        else if(request instanceof GrailsHttpServletRequest) {\n            if(((GrailsHttpServletRequest)request).isMultiPart()) {\n                MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n                bindMultipartFiles(multipartRequest.getFileMap(), mpvs);\n            }            \n        }\n        else if (request instanceof MultipartHttpServletRequest) {\n\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\tbindMultipartFiles(multipartRequest.getFileMap(), mpvs);\n\t\t}\n\n        super.doBind(mpvs);\n    }","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public ServletRequest getDelegate() {\n    \treturn getRequest();\n    }","id":35114,"modified_method":"public HttpServletRequest getDelegate() {\n    \treturn (HttpServletRequest)getRequest();\n    }","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public HttpServletResponse getDelegate() {\n\t\treturn delegate;\t\t\n\t}","id":35115,"modified_method":"public HttpServletResponse getDelegate() {\n        return (HttpServletResponse)getResponse();\n    }","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public void sendError(int error) throws IOException {\n\t\tthis.delegate.sendError(error);\n\t}","id":35116,"modified_method":"public void sendError(int error) throws IOException {\n        this.redirected = true;\n        super.sendError(error);\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public GrailsHttpServletResponse(HttpServletResponse delegate) {\n\t\tsuper();\n\t\tthis.delegate = delegate;\n\t}","id":35117,"modified_method":"public GrailsHttpServletResponse(HttpServletResponse httpServletResponse) {\n        super(httpServletResponse);\n    }","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public PrintWriter getWriter(String contentType) throws IOException {\n\t\tsetContentType(contentType);\n\t\treturn this.delegate.getWriter();\n\t}","id":35118,"modified_method":"public PrintWriter getWriter(String contentType) throws IOException {\n\t\tsetContentType(contentType);\n\t\treturn super.getWriter();\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public void sendRedirect(String url) throws IOException {\n\t\tthis.redirected = true;\n\t\tthis.delegate.sendRedirect(url);\n\t}","id":35119,"modified_method":"public void sendRedirect(String url) throws IOException {\n\t\tthis.redirected = true;\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Executing redirect with response [\"+getResponse()+\"] to location [\"+url+\"]\");\n        }\n\n        super.sendRedirect(url);\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public ServletOutputStream getOutputStream(String contentType, String characterEncoding) throws IOException {\n\t\tsetContentType(contentType + \";charset=\" + characterEncoding);\n\t\treturn this.delegate.getOutputStream();\n\t}","id":35120,"modified_method":"public ServletOutputStream getOutputStream(String contentType, String characterEncoding) throws IOException {\n\t\tsetContentType(contentType + \";charset=\" + characterEncoding);\n\t\treturn super.getOutputStream();\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public void setContentType(String contentType) {\n\t\tif(!contentTypeSet) {\n\t\t\tthis.contentTypeSet = true;\n\t\t\tthis.delegate.setContentType(contentType);\n\t\t}\n\t}","id":35121,"modified_method":"public void setContentType(String contentType) {\n\t\tif(!contentTypeSet) {\n\t\t\tthis.contentTypeSet = true;\n\t\t\tsuper.setContentType(contentType);\n\t\t}\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public PrintWriter getWriter(String contentType, String characterEncoding) throws IOException {\n\t\tsetContentType(contentType + \";charset=\" + characterEncoding);\n\t\treturn this.delegate.getWriter();\n\t}","id":35122,"modified_method":"public PrintWriter getWriter(String contentType, String characterEncoding) throws IOException {\n\t\tsetContentType(contentType + \";charset=\" + characterEncoding);\n\t\treturn super.getWriter();\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public void sendError(int error, String message) throws IOException {\n\t\tthis.delegate.sendError(error, message);\n\t}","id":35123,"modified_method":"public void sendError(int error, String message) throws IOException {\n        this.redirected = true;\n        super.sendError(error, message);\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"protected void applyDecorator(Page page, Decorator decorator, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \tif(decorator.getURIPath().endsWith(\".gsp\")) {\n    \t\trequest.setAttribute(PAGE, page);\n            ServletContext context = filterConfig.getServletContext();\n            // see if the URI path (webapp) is set\n            if (decorator.getURIPath() != null) {\n                // in a security conscious environment, the servlet container\n                // may return null for a given URL\n                if (context.getContext(decorator.getURIPath()) != null) {\n                    context = context.getContext(decorator.getURIPath());\n                }\n            }    \t\t\n                      \n            RequestDispatcher rd = request.getRequestDispatcher(decorator.getURIPath());\n            if(!response.isCommitted()) {\n                if(LOG.isDebugEnabled()) {\n                \tLOG.debug(\"Rendering layout using forward: \" + decorator.getURIPath());\n                }            \t            \t\n            \trd.forward(request, response);\n            } \n            else {\n                if(LOG.isDebugEnabled()) {\n                \tLOG.debug(\"Rendering layout using include: \" + decorator.getURIPath());\n                }\n                request.setAttribute(GrailsApplicationAttributes.GSP_TO_RENDER,decorator.getURIPath());\n                rd.include(request,response);\n                request.removeAttribute(GrailsApplicationAttributes.GSP_TO_RENDER);\n            }\n            \n            // set the headers specified as decorator init params\n            while (decorator.getInitParameterNames().hasNext()) {\n                String initParam = (String) decorator.getInitParameterNames().next();\n                if (initParam.startsWith(\"header.\")) {\n                    response.setHeader(initParam.substring(initParam.indexOf('.')), decorator.getInitParameter(initParam));\n                }\n            }\n            request.removeAttribute(PAGE);        \t\t        \t\t\n    \t}\n    \telse {\n    \t\t\n    \t\tsuper.applyDecorator(page, decorator, request, response);\n    \t\t\n    \t}\n\t}","id":35124,"modified_method":"protected void applyDecorator(Page page, Decorator decorator, HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    \tif(decorator.getURIPath().endsWith(\".gsp\")) {\n    \t\trequest.setAttribute(PAGE, page);\n            ServletContext context = filterConfig.getServletContext();\n            // see if the URI path (webapp) is set\n            if (decorator.getURIPath() != null) {\n                // in a security conscious environment, the servlet container\n                // may return null for a given URL\n                if (context.getContext(decorator.getURIPath()) != null) {\n                    context = context.getContext(decorator.getURIPath());\n                }\n            }    \t\t\n                      \n            RequestDispatcher rd = request.getRequestDispatcher(decorator.getURIPath());\n            if(!response.isCommitted()) {\n                if(LOG.isDebugEnabled()) {\n                \tLOG.debug(\"Rendering layout using forward: \" + decorator.getURIPath());\n                }\n                if(response instanceof GrailsHttpServletResponse) {\n                    response = ((GrailsHttpServletResponse)response).getDelegate();\n                }\n                if(request instanceof GrailsHttpServletRequest)  {\n                    request = ((GrailsHttpServletRequest)request).getDelegate();\n                }\n                rd.forward(request, response);\n            } \n            else {\n                if(LOG.isDebugEnabled()) {\n                \tLOG.debug(\"Rendering layout using include: \" + decorator.getURIPath());\n                }\n                request.setAttribute(GrailsApplicationAttributes.GSP_TO_RENDER,decorator.getURIPath());\n                rd.include(request,response);\n                request.removeAttribute(GrailsApplicationAttributes.GSP_TO_RENDER);\n            }\n            \n            // set the headers specified as decorator init params\n            while (decorator.getInitParameterNames().hasNext()) {\n                String initParam = (String) decorator.getInitParameterNames().next();\n                if (initParam.startsWith(\"header.\")) {\n                    response.setHeader(initParam.substring(initParam.indexOf('.')), decorator.getInitParameter(initParam));\n                }\n            }\n            request.removeAttribute(PAGE);        \t\t        \t\t\n    \t}\n    \telse {\n    \t\t\n    \t\tsuper.applyDecorator(page, decorator, request, response);\n    \t\t\n    \t}\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"protected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tLocaleContextHolder.setLocale(request.getLocale());\n\t\tServletRequestAttributes requestAttributes = new GrailsWebRequest(request, response, getServletContext());\n\t\tRequestContextHolder.setRequestAttributes(requestAttributes);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Bound Grails request context to thread: \" + request);\n\t\t}\n\t\ttry {\n\t\t\tfilterChain.doFilter(request, response);\n\t\t}\n\t\tfinally {\n\t\t\trequestAttributes.requestCompleted();\n\t\t\tRequestContextHolder.setRequestAttributes(null);\n\t\t\tLocaleContextHolder.setLocale(null);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cleared Grails thread-bound request context: \" + request);\n\t\t\t}\n\t\t}\n\t}","id":35125,"modified_method":"protected void doFilterInternal(\n\t\t\tHttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\n\t\t\tthrows ServletException, IOException {\n\n\t\tLocaleContextHolder.setLocale(request.getLocale());\n\t\tGrailsWebRequest requestAttributes = new GrailsWebRequest(request, response, getServletContext());\n\t\tRequestContextHolder.setRequestAttributes(requestAttributes);\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Bound Grails request context to thread: \" + request);\n\t\t}\n\t\ttry {\n\t\t\tfilterChain.doFilter(requestAttributes.getCurrentRequest(), requestAttributes.getCurrentResponse());\n\t\t}\n\t\tfinally {\n\t\t\trequestAttributes.requestCompleted();\n\t\t\tRequestContextHolder.setRequestAttributes(null);\n\t\t\tLocaleContextHolder.setLocale(null);\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Cleared Grails thread-bound request context: \" + request);\n\t\t\t}\n\t\t}\n\t}","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"private Object redirectResponse(String actualUri, HttpServletResponse response) {\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Dynamic method [redirect] forwarding request to [\"+actualUri +\"]\");\n        }\n\n        try {\n            HttpServletResponse wrappedResponse =  WrappedResponseHolder.getWrappedResponse();\n            if(wrappedResponse != null ) response = wrappedResponse;\n\n            response.sendRedirect(response.encodeRedirectURL(actualUri));\n            \n        } catch (IOException e) {\n            throw new ControllerExecutionException(\"Error redirecting request for url [\"+actualUri +\"]: \" + e.getMessage(),e);\n        }\n        return null;\n    }","id":35126,"modified_method":"private Object redirectResponse(String actualUri, HttpServletResponse response) {\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Dynamic method [redirect] forwarding request to [\"+actualUri +\"]\");\n        }\n\n        try {\n\n            if(response instanceof HttpServletResponseWrapper) {\n                response = unwrapHttpServletResponse(response);\n            }\n\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Executing redirect with response [\"+response+\"]\");\n            }\n            String redirectUrl = response.encodeRedirectURL(actualUri);\n            response.sendRedirect(redirectUrl);\n\n        } catch (IOException e) {\n            throw new ControllerExecutionException(\"Error redirecting request for url [\"+actualUri +\"]: \" + e.getMessage(),e);\n        }\n        return null;\n    }","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"private void appendRequestParams(StringBuffer actualUriBuf, Map params, HttpServletRequest request) {\n        actualUriBuf.append('?');\n        for (Iterator i = params.keySet().iterator(); i.hasNext();) {\n            Object name = i.next();\n            if(name.equals(GrailsControllerClass.CONTROLLER) || name.equals(GrailsControllerClass.ACTION))\n                continue;\n            Object value = params.get(name);\n            appendRequestParam(actualUriBuf, name, value,request);\n            if(i.hasNext())\n                actualUriBuf.append('&');\n        }\n    }","id":35127,"modified_method":"private void appendRequestParams(StringBuffer actualUriBuf, Map params, HttpServletRequest request) {\n        if(params.size() > 0)\n            actualUriBuf.append('?');\n        \n        for (Iterator i = params.keySet().iterator(); i.hasNext();) {\n            Object name = i.next();\n            if(name.equals(GrailsControllerClass.CONTROLLER) || name.equals(GrailsControllerClass.ACTION))\n                continue;\n            Object value = params.get(name);\n            appendRequestParam(actualUriBuf, name, value,request);\n            if(i.hasNext())\n                actualUriBuf.append('&');\n        }\n    }","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public ModelAndView handleURI(String uri, GrailsWebRequest webRequest, Map params) {\n        if(uri == null)\n            throw new IllegalArgumentException(\"Controller URI [\" + uri + \"] cannot be null!\");\n        \n        this.webRequest = webRequest;\n\n        uri = configureStateForUri(uri);\n       \n        GrailsHttpServletRequest request = webRequest.getCurrentRequest();\n        GrailsHttpServletResponse response = webRequest.getCurrentResponse();\n\n        // if the action name is blank check its included as dispatch parameter\n        if(StringUtils.isBlank(actionName))\n        \turi = checkDispatchAction(request, uri);\n\n        if(uri.endsWith(\"/\"))\n            uri = uri.substring(0,uri.length() - 1);\n\n        // if the id is blank check if its a request parameter\n        if(StringUtils.isBlank(id) && request.getParameter(ID_PARAMETER) != null) {\n            id = request.getParameter(ID_PARAMETER);\n        }\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing request for controller [\"+controllerName+\"], action [\"+actionName+\"], and id [\"+id+\"]\");\n        }\n        if(LOG.isTraceEnabled()) {\n            LOG.trace(\"Extra params from uri [\"+extraParams+\"] \");\n        }\n        // Step 2: lookup the controller in the application.\n        GrailsControllerClass controllerClass = getControllerClassByURI(uri);\n\n        if (controllerClass == null) {\n            throw new UnknownControllerException(\"No controller found for URI [\" + uri + \"]!\");\n        }\n\n        // parse the uri in its individual tokens\n        controllerName = WordUtils.uncapitalize(controllerClass.getName());\n\n        // Step 3: load controller from application context.\n        GroovyObject controller = getControllerInstance(controllerClass);\n\n        if(!controllerClass.isHttpMethodAllowedForAction(controller, request.getMethod(), actionName)) {\n        \ttry {\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN);\n\t\t\t\treturn null;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ControllerExecutionException(\"I/O error sending 403 error\",e);\n\t\t\t}\n        }\n        \n        request.setAttribute( GrailsApplicationAttributes.CONTROLLER, controller );\n\n\n        // Step 3: if scaffolding retrieve scaffolder\n        GrailsScaffolder scaffolder = null;\n        if(controllerClass.isScaffolding())  {\n            scaffolder = (GrailsScaffolder)applicationContext.getBean( controllerClass.getFullName() + SCAFFOLDER );\n            if(scaffolder == null)\n                throw new IllegalStateException(\"Scaffolding set to true for controller [\"+controllerClass.getFullName()+\"] but no scaffolder available!\");\n        }\n\n        // Step 4: get closure property name for URI.\n        if(StringUtils.isBlank(actionName))\n            actionName = controllerClass.getClosurePropertyName(uri);\n\n        if (StringUtils.isBlank(actionName)) {\n            // Step 4a: Check if scaffolding\n            if( controllerClass.isScaffolding() && !scaffolder.supportsAction(actionName))\n                throw new NoClosurePropertyForURIException(\"Could not find closure property for URI [\" + uri + \"] for controller [\" + controllerClass.getFullName() + \"]!\");\n        }\n\n        // Step 4a: Set the action and controller name of the web request\n        webRequest.setActionName(actionName);\n        webRequest.setControllerName(controllerName);\n        \n        // populate additional params from url\n        Map controllerParams = (Map)controller.getProperty(GetParamsDynamicProperty.PROPERTY_NAME);\n        request.setControllerParams(controllerParams);\n        \n        if(!StringUtils.isBlank(id)) {\n            controllerParams.put(GrailsApplicationAttributes.ID_PARAM, id);\n        }\n        if(!extraParams.isEmpty()) {\n            for (Iterator i = extraParams.keySet().iterator(); i.hasNext();) {\n                String name = (String) i.next();\n                controllerParams.put(name,extraParams.get(name));\n            }\n        }\n\n        // set the flash scope instance to its next state and set on controller\n        FlashScope fs = this.grailsAttributes.getFlashScope(request);\n        fs.next();\n\n        // Step 4b: Set grails attributes in request scope\n        request.setAttribute(GrailsApplicationAttributes.REQUEST_SCOPE_ID,this.grailsAttributes);\n\n        // Step 5: get the view name for this URI.\n        String viewName = controllerClass.getViewByURI(uri);\n\n        // Step 5a: Check if there is a before interceptor if there is execute it\n        boolean executeAction = true;\n        if(controllerClass.isInterceptedBefore(controller,actionName)) {\n        \tClosure beforeInterceptor = controllerClass.getBeforeInterceptor(controller);\n        \tif(beforeInterceptor!= null) {\n        \t\tObject interceptorResult = beforeInterceptor.call();\n        \t\tif(interceptorResult instanceof Boolean) {\n        \t\t\texecuteAction = ((Boolean)interceptorResult).booleanValue();\n        \t\t}\n        \t}\n        }\n        // if the interceptor returned false don't execute the action\n        if(!executeAction)\n        \treturn null;\n        \n        // Step 6: get closure from closure property\n        Closure action;\n        try {\n        \taction = (Closure)controller.getProperty(actionName);\n            // Step 7: process the action\n            Object returnValue = handleAction( controller,action,request,response,params );\n\n\n            // Step 8: determine return value type and handle accordingly\n            initChainModel(controller);\n            if(response.isRedirected()) {\n            \t\treturn null;\n            }\n            \n            ModelAndView mv = handleActionResponse(controller,returnValue,actionName,viewName);\n            // Step 9: Check if there is after interceptor\n            if(controllerClass.isInterceptedAfter(controller,actionName)) {\n            \tClosure afterInterceptor = controllerClass.getAfterInterceptor(controller);\n                Map model = mv.getModel() != null ? mv.getModel() : Collections.EMPTY_MAP;\n                afterInterceptor.call(new Object[]{ model });\n            }\n            return mv;\n        }\n        catch(MissingPropertyException mpe) {\n            if(controllerClass.isScaffolding())\n                throw new IllegalStateException(\"Scaffolder supports action [\"+actionName +\"] for controller [\"+controllerClass.getFullName()+\"] but getAction returned null!\");\n            else {\n            \ttry {\n\t\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t\t\treturn null;\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new ControllerExecutionException(\"I/O error sending 404 error\",e);\n\t\t\t\t}\n            }\n        }\n\n    }","id":35128,"modified_method":"public ModelAndView handleURI(String uri, GrailsWebRequest webRequest, Map params) {\n        if(uri == null)\n            throw new IllegalArgumentException(\"Controller URI [\" + uri + \"] cannot be null!\");\n        \n        this.webRequest = webRequest;\n\n        uri = configureStateForUri(uri);\n       \n        GrailsHttpServletRequest request = webRequest.getCurrentRequest();\n        GrailsHttpServletResponse response = webRequest.getCurrentResponse();\n\n        // if the action name is blank check its included as dispatch parameter\n        if(StringUtils.isBlank(actionName))\n        \turi = checkDispatchAction(request, uri);\n\n        if(uri.endsWith(\"/\"))\n            uri = uri.substring(0,uri.length() - 1);\n\n        // if the id is blank check if its a request parameter\n        if(StringUtils.isBlank(id) && request.getParameter(ID_PARAMETER) != null) {\n            id = request.getParameter(ID_PARAMETER);\n        }\n        if(LOG.isDebugEnabled()) {\n            LOG.debug(\"Processing request for controller [\"+controllerName+\"], action [\"+actionName+\"], and id [\"+id+\"]\");\n        }\n        if(LOG.isTraceEnabled()) {\n            LOG.trace(\"Extra params from uri [\"+extraParams+\"] \");\n        }\n        // Step 2: lookup the controller in the application.\n        GrailsControllerClass controllerClass = getControllerClassByURI(uri);\n\n        if (controllerClass == null) {\n            throw new UnknownControllerException(\"No controller found for URI [\" + uri + \"]!\");\n        }\n\n        // parse the uri in its individual tokens\n        controllerName = WordUtils.uncapitalize(controllerClass.getName());\n\n        // Step 3: load controller from application context.\n        GroovyObject controller = getControllerInstance(controllerClass);\n\n        if(!controllerClass.isHttpMethodAllowedForAction(controller, request.getMethod(), actionName)) {\n        \ttry {\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN);\n\t\t\t\treturn null;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new ControllerExecutionException(\"I/O error sending 403 error\",e);\n\t\t\t}\n        }\n        \n        request.setAttribute( GrailsApplicationAttributes.CONTROLLER, controller );\n\n\n        // Step 3: if scaffolding retrieve scaffolder\n        GrailsScaffolder scaffolder = null;\n        if(controllerClass.isScaffolding())  {\n            scaffolder = (GrailsScaffolder)applicationContext.getBean( controllerClass.getFullName() + SCAFFOLDER );\n            if(scaffolder == null)\n                throw new IllegalStateException(\"Scaffolding set to true for controller [\"+controllerClass.getFullName()+\"] but no scaffolder available!\");\n        }\n\n        // Step 4: get closure property name for URI.\n        if(StringUtils.isBlank(actionName))\n            actionName = controllerClass.getClosurePropertyName(uri);\n\n        if (StringUtils.isBlank(actionName)) {\n            // Step 4a: Check if scaffolding\n            if( controllerClass.isScaffolding() && !scaffolder.supportsAction(actionName))\n                throw new NoClosurePropertyForURIException(\"Could not find closure property for URI [\" + uri + \"] for controller [\" + controllerClass.getFullName() + \"]!\");\n        }\n\n        // Step 4a: Set the action and controller name of the web request\n        webRequest.setActionName(actionName);\n        webRequest.setControllerName(controllerName);\n        \n        // populate additional params from url\n        Map controllerParams = (Map)controller.getProperty(GetParamsDynamicProperty.PROPERTY_NAME);\n        request.setControllerParams(controllerParams);\n        \n        if(!StringUtils.isBlank(id)) {\n            controllerParams.put(GrailsApplicationAttributes.ID_PARAM, id);\n        }\n        if(!extraParams.isEmpty()) {\n            for (Iterator i = extraParams.keySet().iterator(); i.hasNext();) {\n                String name = (String) i.next();\n                controllerParams.put(name,extraParams.get(name));\n            }\n        }\n\n        // set the flash scope instance to its next state and set on controller\n        FlashScope fs = this.grailsAttributes.getFlashScope(request);\n        fs.next();\n\n        // Step 4b: Set grails attributes in request scope\n        request.setAttribute(GrailsApplicationAttributes.REQUEST_SCOPE_ID,this.grailsAttributes);\n\n        // Step 5: get the view name for this URI.\n        String viewName = controllerClass.getViewByURI(uri);\n\n        // Step 5a: Check if there is a before interceptor if there is execute it\n        boolean executeAction = true;\n        if(controllerClass.isInterceptedBefore(controller,actionName)) {\n        \tClosure beforeInterceptor = controllerClass.getBeforeInterceptor(controller);\n        \tif(beforeInterceptor!= null) {\n        \t\tObject interceptorResult = beforeInterceptor.call();\n        \t\tif(interceptorResult instanceof Boolean) {\n        \t\t\texecuteAction = ((Boolean)interceptorResult).booleanValue();\n        \t\t}\n        \t}\n        }\n        // if the interceptor returned false don't execute the action\n        if(!executeAction)\n        \treturn null;\n        \n        // Step 6: get closure from closure property\n        Closure action;\n        try {\n        \taction = (Closure)controller.getProperty(actionName);\n            // Step 7: process the action\n            Object returnValue = handleAction( controller,action,request,response,params );\n\n\n            // Step 8: determine return value type and handle accordingly\n            initChainModel(controller);\n            if(response.isRedirected()) {\n                if(LOG.isDebugEnabled()) {\n                    LOG.debug(\"Response has been redirected, returning null model and view\");\n                }\n                invokeAfterInterceptor(controllerClass, controller, null);\n                return null;\n            }\n            else {\n\n                ModelAndView mv = handleActionResponse(controller,returnValue,actionName,viewName);\n                if(LOG.isDebugEnabled()) {\n                    LOG.debug(\"Action [\"+actionName+\"] executed, return model and view [\"+mv+\"]\");\n                }\n                invokeAfterInterceptor(controllerClass, controller, mv);\n                return mv;\n            }\n\n        }\n        catch(MissingPropertyException mpe) {\n            if(controllerClass.isScaffolding())\n                throw new IllegalStateException(\"Scaffolder supports action [\"+actionName +\"] for controller [\"+controllerClass.getFullName()+\"] but getAction returned null!\");\n            else {\n            \ttry {\n\t\t\t\t\tresponse.sendError(HttpServletResponse.SC_NOT_FOUND);\n\t\t\t\t\treturn null;\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new ControllerExecutionException(\"I/O error sending 404 error\",e);\n\t\t\t\t}\n            }\n        }\n\n    }","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        UrlMappingsHolder holder = lookupUrlMappings();\n\n        if(LOG.isTraceEnabled()) {\n            LOG.trace(\"Executing URL mapping filter\");\n        }\n        \n        UrlMapping[] mappings = holder.getUrlMappings();\n        String uri = urlHelper.getPathWithinApplication(request);\n        // filter doesn't apply to URLs with extensions for the moment, might add support\n        // later to include certain extensions\n        if(uri.substring(uri.lastIndexOf(SLASH)).indexOf(\".\") >-1) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n\n        UrlMappingInfo info = null;\n        for (int i = 0; i < mappings.length; i++) {\n\n            UrlMapping mapping = mappings[i];\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Attempting to match URI [\"+uri+\"] with pattern [\"+mapping.getUrlData().getUrlPattern()+\"]\");\n            \n            info = mapping.match(uri);\n\n            if(info!=null) {\n                break;\n            }\n        }\n\n        if(info!=null) {\n            String forwardUrl = buildDispatchUrlForMapping(request, info);\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Matched URI [\"+uri+\"] to URL mapping, forwarding to [\"+forwardUrl+\"] with response [\"+response.getClass()+\"]\");\n            }\n            //populateParamsForMapping(info);\n            RequestDispatcher dispatcher = request.getRequestDispatcher(forwardUrl);\n            RequestDispatcherWrapper wrapper = new RequestDispatcherWrapper(dispatcher);\n            WrappedResponseHolder.setWrappedResponse(response);\n\n            wrapper.include(request, response);\n        }\n        else {\n            if(filterChain!=null)\n                filterChain.doFilter(request, response);\n        }\n    }","id":35129,"modified_method":"protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        UrlMappingsHolder holder = lookupUrlMappings();\n\n        if(LOG.isTraceEnabled()) {\n            LOG.trace(\"Executing URL mapping filter\");\n        }\n        \n        UrlMapping[] mappings = holder.getUrlMappings();\n        String uri = urlHelper.getPathWithinApplication(request);\n        // filter doesn't apply to URLs with extensions for the moment, might add support\n        // later to include certain extensions\n        if(uri.substring(uri.lastIndexOf(SLASH)).indexOf(\".\") >-1) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n\n        UrlMappingInfo info = null;\n        for (int i = 0; i < mappings.length; i++) {\n\n            UrlMapping mapping = mappings[i];\n            if(LOG.isDebugEnabled())\n                LOG.debug(\"Attempting to match URI [\"+uri+\"] with pattern [\"+mapping.getUrlData().getUrlPattern()+\"]\");\n            \n            info = mapping.match(uri);\n\n            if(info!=null) {\n                break;\n            }\n        }\n\n        if(info!=null) {\n            String forwardUrl = buildDispatchUrlForMapping(request, info);\n            if(LOG.isDebugEnabled()) {\n                LOG.debug(\"Matched URI [\"+uri+\"] to URL mapping, forwarding to [\"+forwardUrl+\"] with response [\"+response.getClass()+\"]\");\n            }\n            //populateParamsForMapping(info);\n            RequestDispatcher dispatcher = request.getRequestDispatcher(forwardUrl);\n            RequestDispatcherWrapper wrapper = new RequestDispatcherWrapper(dispatcher);\n            try {\n                WrappedResponseHolder.setWrappedResponse(response);\n                wrapper.forward(request, response);                \n            }\n            finally {\n                WrappedResponseHolder.setWrappedResponse(null);\n            }\n\n\n\n        }\n        else {\n            if(filterChain!=null)\n                filterChain.doFilter(request, response);\n        }\n    }","commit_id":"feac61381f6017f977a800dd8a2016566f56d5ad","url":"https://github.com/grails/grails-core"},{"original_method":"public void actionPerformed(AnActionEvent event) {\n    DataContext dataContext = event.getDataContext();\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    VirtualFile file = PlatformDataKeys.VIRTUAL_FILE.getData(dataContext);\n    AntConfiguration antConfiguration = AntConfiguration.getInstance(project);\n    try {\n      antConfiguration.addBuildFile(file);\n      ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.ANT_BUILD).activate(null);\n    }\n    catch (AntNoFileException e) {\n      Messages.showWarningDialog(project, AntBundle.message(\"cannot.add.build.files.from.excluded.directories.error.message\",\n                                                            e.getFile().getPresentableUrl()),\n                                          AntBundle.message(\"cannot.add.build.file.dialog.title\"));\n    }\n  }","id":35130,"modified_method":"public void actionPerformed(AnActionEvent event) {\n    DataContext dataContext = event.getDataContext();\n    Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    VirtualFile file = PlatformDataKeys.VIRTUAL_FILE.getData(dataContext);\n    AntConfiguration antConfiguration = AntConfiguration.getInstance(project);\n    try {\n      antConfiguration.addBuildFile(file);\n      ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.ANT_BUILD).activate(null);\n    }\n    catch (AntNoFileException e) {\n      String message = e.getMessage();\n      if (message == null || message.length() == 0) {\n        message = AntBundle.message(\"cannot.add.build.files.from.excluded.directories.error.message\", e.getFile().getPresentableUrl());\n      }\n\n      Messages.showWarningDialog(project, message, AntBundle.message(\"cannot.add.build.file.dialog.title\"));\n    }\n  }","commit_id":"f34cac1379672214d4c0cc33af723dbcad26f322","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private AntBuildFileBase addBuildFileImpl(final VirtualFile file) throws AntNoFileException {\n    PsiFile xmlFile = myPsiManager.findFile(file);\n    if (!(xmlFile instanceof XmlFile)) {\n      throw new AntNoFileException(AntBundle.message(\"cant.add.file.error.message\"), file);\n    }\n    AntSupport.markFileAsAntFile(file, xmlFile.getProject(), true);\n    if (!AntDomFileDescription.isAntFile(((XmlFile)xmlFile))) {\n      throw new AntNoFileException(AntBundle.message(\"cant.add.file.error.message\"), file);\n    }\n    final AntBuildFileImpl buildFile = new AntBuildFileImpl((XmlFile)xmlFile, this);\n    xmlFile.putCopyableUserData(AntBuildFile.ANT_BUILD_FILE_KEY, buildFile);\n    synchronized (myBuildFiles) {\n      myBuildFilesArray = null;\n      myBuildFiles.add(buildFile);\n    }\n    return buildFile;\n  }","id":35131,"modified_method":"private AntBuildFileBase addBuildFileImpl(final VirtualFile file) throws AntNoFileException {\n    PsiFile xmlFile = myPsiManager.findFile(file);\n    if (!(xmlFile instanceof XmlFile)) {\n      throw new AntNoFileException(\"the file is not an xml file\", file);\n    }\n    AntSupport.markFileAsAntFile(file, xmlFile.getProject(), true);\n    if (!AntDomFileDescription.isAntFile(((XmlFile)xmlFile))) {\n      throw new AntNoFileException(\"the file is not recognized as an ANT file\", file);\n    }\n    final AntBuildFileImpl buildFile = new AntBuildFileImpl((XmlFile)xmlFile, this);\n    xmlFile.putCopyableUserData(AntBuildFile.ANT_BUILD_FILE_KEY, buildFile);\n    synchronized (myBuildFiles) {\n      myBuildFilesArray = null;\n      myBuildFiles.add(buildFile);\n    }\n    return buildFile;\n  }","commit_id":"f34cac1379672214d4c0cc33af723dbcad26f322","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AntNoFileException(final String message, final VirtualFile file) {\n    super(message + file.getPresentableUrl());\n    myFile = file;\n  }","id":35132,"modified_method":"public AntNoFileException(final String message, final VirtualFile file) {\n    super(AntBundle.message(\"cant.add.file.error.message\", file.getPresentableUrl(), message));\n    myFile = file;\n  }","commit_id":"f34cac1379672214d4c0cc33af723dbcad26f322","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void actionPerformed(AnActionEvent event) {\n    DataContext dataContext = event.getDataContext();\n    Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    VirtualFile file = CommonDataKeys.VIRTUAL_FILE.getData(dataContext);\n    AntConfiguration antConfiguration = AntConfiguration.getInstance(project);\n    try {\n      antConfiguration.addBuildFile(file);\n      ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.ANT_BUILD).activate(null);\n    }\n    catch (AntNoFileException e) {\n      String message = e.getMessage();\n      if (message == null || message.length() == 0) {\n        message = AntBundle.message(\"cannot.add.build.files.from.excluded.directories.error.message\", e.getFile().getPresentableUrl());\n      }\n\n      Messages.showWarningDialog(project, message, AntBundle.message(\"cannot.add.build.file.dialog.title\"));\n    }\n  }","id":35133,"modified_method":"public void actionPerformed(AnActionEvent event) {\n    final DataContext dataContext = event.getDataContext();\n    final Project project = CommonDataKeys.PROJECT.getData(dataContext);\n    if (project == null) {\n      return;\n    }\n\n    final Set<VirtualFile> files = new HashSet<VirtualFile>();\n    \n    VirtualFile[] contextFiles = CommonDataKeys.VIRTUAL_FILE_ARRAY.getData(dataContext);\n    if (contextFiles != null) {\n      files.addAll(Arrays.asList(contextFiles));\n    }\n    final VirtualFile singleFile = CommonDataKeys.VIRTUAL_FILE.getData(dataContext);\n    if (singleFile != null) {\n      files.add(singleFile);\n    }\n\n    if (files.isEmpty()) {\n      return;\n    }\n    \n    final AntConfiguration antConfiguration = AntConfiguration.getInstance(project);\n    int filesAdded = 0;\n    final StringBuilder errors = new StringBuilder();\n\n    for (VirtualFile file : files) {\n      try {\n        antConfiguration.addBuildFile(file);\n        filesAdded++;\n      }\n      catch (AntNoFileException e) {\n        String message = e.getMessage();\n        if (message == null || message.length() == 0) {\n          message = AntBundle.message(\"cannot.add.build.files.from.excluded.directories.error.message\", e.getFile().getPresentableUrl());\n        }\n        if (errors.length() > 0) {\n          errors.append(\"\\n\");\n        }\n        errors.append(message);\n      }\n    }\n\n    if (errors.length() > 0) {\n      Messages.showWarningDialog(project, errors.toString(), AntBundle.message(\"cannot.add.build.file.dialog.title\"));\n    }\n    if (filesAdded > 0) {\n      ToolWindowManager.getInstance(project).getToolWindow(ToolWindowId.ANT_BUILD).activate(null);\n    }\n  }","commit_id":"5b0413e2c34adc7728e445f023e7c3c8bb71eb0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    final long l = System.currentTimeMillis();\n    if (l % 3 == 0) {\n      Messages.showErrorDialog(\"Test error message.\", \"Test\");\n    }\n    else if (l % 5 == 0) {\n      Messages.showWarningDialog(\"Test warning message.\", \"Test\");\n    }\n    else {\n      Messages.showInfoMessage(\"Test info message.\", \"Test\");\n    }\n  }","id":35134,"modified_method":"@Override\n  public void actionPerformed(final AnActionEvent e) {\n    int r = myRandom.nextInt(10);\n    if (r < 3) {\n      String message = wrap(\"Test error message.\", r);\n      Messages.showErrorDialog(message, \"Test\");\n    }\n    else if (r < 6) {\n      String message = wrap(\"Test warning message.\", r);\n      Messages.showWarningDialog(message, \"Test\");\n    }\n    else {\n      String message = wrap(\"Test info message.\", r);\n      Messages.showInfoMessage(message, \"Test\");\n    }\n  }","commit_id":"28b46c87bb2695f86d62dffece753391775890b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean notIgnored(VirtualFile file) {\n    return belongsToThisRepository(file) && !myChangeListManager.isIgnoredFile(file);\n  }","id":35135,"modified_method":"private boolean notIgnored(@Nullable VirtualFile file) {\n    return file != null && belongsToThisRepository(file) && !myChangeListManager.isIgnoredFile(file);\n  }","commit_id":"48ecf0a5fbcc357905c452cbab5aff62e5bbc078","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void after(List<? extends VFileEvent> events) {\n    boolean indexChanged = false;\n    Set<VirtualFile> filesToRefresh = new HashSet<VirtualFile>();\n\n    for (VFileEvent event : events) {\n      if (indexChanged) {\n        break;\n      }\n      VirtualFile file = event.getFile();\n      if (file == null) {\n        continue;\n      }\n      String path = file.getPath();\n      if (myRepositoryFiles.isIndexFile(path)) {\n        indexChanged = true;\n      }\n      else if (isCreateDeleteEvent(event) && notIgnored(file)) {\n        filesToRefresh.add(file);\n      }\n    }\n\n    // if index has changed, no need to refresh specific files - we get the full status of all files\n    if (indexChanged) {\n      myDirtyScopeManager.dirDirtyRecursively(myRoot);\n      synchronized (LOCK) {\n        myReady = false;\n      }\n    } else {\n      synchronized (LOCK) {\n        myPossiblyUntrackedFiles.addAll(filesToRefresh);\n      }\n    }\n  }","id":35136,"modified_method":"@Override\n  public void after(List<? extends VFileEvent> events) {\n    boolean indexChanged = false;\n    Set<VirtualFile> filesToRefresh = new HashSet<VirtualFile>();\n\n    for (VFileEvent event : events) {\n      if (indexChanged) {\n        break;\n      }\n      VirtualFile file = event.getFile();\n      if (file == null) {\n        continue;\n      }\n      String path = file.getPath();\n      if (myRepositoryFiles.isIndexFile(path)) {\n        indexChanged = true;\n      }\n      else {\n        VirtualFile affectedFile = getAffectedFile(event);\n        if (notIgnored(affectedFile)) {\n          filesToRefresh.add(affectedFile);\n        }\n      }\n    }\n\n    // if index has changed, no need to refresh specific files - we get the full status of all files\n    if (indexChanged) {\n      myDirtyScopeManager.dirDirtyRecursively(myRoot);\n      synchronized (LOCK) {\n        myReady = false;\n      }\n    } else {\n      synchronized (LOCK) {\n        myPossiblyUntrackedFiles.addAll(filesToRefresh);\n      }\n    }\n  }","commit_id":"48ecf0a5fbcc357905c452cbab5aff62e5bbc078","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean notIgnored(VirtualFile file) {\n    return belongsToThisRepository(file) && !myChangeListManager.isIgnoredFile(file);\n  }","id":35137,"modified_method":"private boolean notIgnored(@Nullable VirtualFile file) {\n    return file != null && belongsToThisRepository(file) && !myChangeListManager.isIgnoredFile(file);\n  }","commit_id":"b9cd9117a6f362607f649687aba8a460137843b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void after(List<? extends VFileEvent> events) {\n    boolean indexChanged = false;\n    Set<VirtualFile> filesToRefresh = new HashSet<VirtualFile>();\n\n    for (VFileEvent event : events) {\n      if (indexChanged) {\n        break;\n      }\n      VirtualFile file = event.getFile();\n      if (file == null) {\n        continue;\n      }\n      String path = file.getPath();\n      if (myRepositoryFiles.isIndexFile(path)) {\n        indexChanged = true;\n      }\n      else if (isCreateDeleteEvent(event) && notIgnored(file)) {\n        filesToRefresh.add(file);\n      }\n    }\n\n    // if index has changed, no need to refresh specific files - we get the full status of all files\n    if (indexChanged) {\n      myDirtyScopeManager.dirDirtyRecursively(myRoot);\n      synchronized (LOCK) {\n        myReady = false;\n      }\n    } else {\n      synchronized (LOCK) {\n        myPossiblyUntrackedFiles.addAll(filesToRefresh);\n      }\n    }\n  }","id":35138,"modified_method":"@Override\n  public void after(List<? extends VFileEvent> events) {\n    boolean indexChanged = false;\n    Set<VirtualFile> filesToRefresh = new HashSet<VirtualFile>();\n\n    for (VFileEvent event : events) {\n      if (indexChanged) {\n        break;\n      }\n      VirtualFile file = event.getFile();\n      if (file == null) {\n        continue;\n      }\n      String path = file.getPath();\n      if (myRepositoryFiles.isIndexFile(path)) {\n        indexChanged = true;\n      }\n      else {\n        VirtualFile affectedFile = getAffectedFile(event);\n        if (notIgnored(affectedFile)) {\n          filesToRefresh.add(affectedFile);\n        }\n      }\n    }\n\n    // if index has changed, no need to refresh specific files - we get the full status of all files\n    if (indexChanged) {\n      myDirtyScopeManager.dirDirtyRecursively(myRoot);\n      synchronized (LOCK) {\n        myReady = false;\n      }\n    } else {\n      synchronized (LOCK) {\n        myPossiblyUntrackedFiles.addAll(filesToRefresh);\n      }\n    }\n  }","commit_id":"b9cd9117a6f362607f649687aba8a460137843b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@BeforeMethod\n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myChangeProvider = (GitChangeProvider) GitVcs.getInstance(myProject).getChangeProvider();\n\n    myFiles = GitTestUtil.createFileStructure(myProject, myRepo, \"a.txt\", \"b.txt\", \"dir/c.txt\", \"dir/subdir/d.txt\");\n    myRepo.addCommit();\n    myRepo.refresh();\n\n    afile = myFiles.get(\"a.txt\"); // the file is commonly used, so save it in a field.\n    myRootDir = myRepo.getVFRootDir();\n\n    myDirtyScope = new MockDirtyScope(myProject, GitVcs.getInstance(myProject));\n  }","id":35139,"modified_method":"@BeforeMethod\n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    myChangeProvider = (GitChangeProvider) GitVcs.getInstance(myProject).getChangeProvider();\n\n    myFiles = GitTestUtil.createFileStructure(myProject, myRepo, \"a.txt\", \"b.txt\", \"dir/c.txt\", \"dir/subdir/d.txt\");\n    myRepo.addCommit();\n    myRepo.refresh();\n\n    afile = myFiles.get(\"a.txt\"); // the file is commonly used, so save it in a field.\n    myRootDir = myRepo.getVFRootDir();\n    mySubDir = myRootDir.findChild(\"dir\");\n\n    myDirtyScope = new MockDirtyScope(myProject, GitVcs.getInstance(myProject));\n  }","commit_id":"3e66007a171a65b82330a9a03c8d3cf573f7b99b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean notIgnored(VirtualFile file) {\n    return belongsToThisRepository(file) && !myChangeListManager.isIgnoredFile(file);\n  }","id":35140,"modified_method":"private boolean notIgnored(@Nullable VirtualFile file) {\n    return file != null && belongsToThisRepository(file) && !myChangeListManager.isIgnoredFile(file);\n  }","commit_id":"3e66007a171a65b82330a9a03c8d3cf573f7b99b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Resets the list of untracked files after retrieving the full list of them from Git.\n   */\n  public void rescanAll() throws VcsException {\n    Set<VirtualFile> untrackedFiles = Git.untrackedFiles(myProject, myRoot, null);\n    synchronized (LOCK) {\n      myDefinitelyUntrackedFiles = untrackedFiles;\n      myPossiblyUntrackedFiles.clear();\n      myPossiblyTrackedFiles.clear();\n      myReady = true;\n    }\n  }","id":35141,"modified_method":"/**\n   * Resets the list of untracked files after retrieving the full list of them from Git.\n   */\n  private void rescanAll() throws VcsException {\n    Set<VirtualFile> untrackedFiles = Git.untrackedFiles(myProject, myRoot, null);\n    synchronized (LOCK) {\n      myDefinitelyUntrackedFiles = untrackedFiles;\n      myPossiblyUntrackedFiles.clear();\n      myPossiblyTrackedFiles.clear();\n      myReady = true;\n    }\n  }","commit_id":"3e66007a171a65b82330a9a03c8d3cf573f7b99b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void before(List<? extends VFileEvent> events) {\n  }","id":35142,"modified_method":"@Override\n  public void before(List<? extends VFileEvent> events) {\n    for (VFileEvent event : events) {\n      // only moved files to preserve old location\n      if (event instanceof  VFileMoveEvent) {\n        VirtualFile file = event.getFile();\n        if (notIgnored(file)) {\n          myPossiblyUntrackedFiles.add(file);\n        }\n      }\n    }\n  }","commit_id":"3e66007a171a65b82330a9a03c8d3cf573f7b99b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void after(List<? extends VFileEvent> events) {\n    boolean indexChanged = false;\n    Set<VirtualFile> filesToRefresh = new HashSet<VirtualFile>();\n\n    for (VFileEvent event : events) {\n      if (indexChanged) {\n        break;\n      }\n      VirtualFile file = event.getFile();\n      if (file == null) {\n        continue;\n      }\n      String path = file.getPath();\n      if (myRepositoryFiles.isIndexFile(path)) {\n        indexChanged = true;\n      }\n      else if (isCreateDeleteEvent(event) && notIgnored(file)) {\n        filesToRefresh.add(file);\n      }\n    }\n\n    // if index has changed, no need to refresh specific files - we get the full status of all files\n    if (indexChanged) {\n      myDirtyScopeManager.dirDirtyRecursively(myRoot);\n      synchronized (LOCK) {\n        myReady = false;\n      }\n    } else {\n      synchronized (LOCK) {\n        myPossiblyUntrackedFiles.addAll(filesToRefresh);\n      }\n    }\n  }","id":35143,"modified_method":"@Override\n  public void after(List<? extends VFileEvent> events) {\n    boolean indexChanged = false;\n    Set<VirtualFile> filesToRefresh = new HashSet<VirtualFile>();\n\n    for (VFileEvent event : events) {\n      if (indexChanged) {\n        break;\n      }\n      VirtualFile file = event.getFile();\n      if (file == null) {\n        continue;\n      }\n      String path = file.getPath();\n      if (myRepositoryFiles.isIndexFile(path)) {\n        indexChanged = true;\n      } \n      else {\n        filesToRefresh.addAll(getAffectedFilesFromEvent(event));\n      }\n    }\n\n    // if index has changed, no need to refresh specific files - we get the full status of all files\n    if (indexChanged) {\n      myDirtyScopeManager.dirDirtyRecursively(myRoot);\n      synchronized (LOCK) {\n        myReady = false;\n      }\n    } else {\n      synchronized (LOCK) {\n        myPossiblyUntrackedFiles.addAll(filesToRefresh);\n      }\n    }\n  }","commit_id":"3e66007a171a65b82330a9a03c8d3cf573f7b99b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private EventRequest findRequest(@NotNull DebugProcessImpl debugProcess, Class requestClass) {\n    Set reqSet = debugProcess.getRequestsManager().findRequests(this);\n    for (Iterator iterator = reqSet.iterator(); iterator.hasNext();) {\n      EventRequest eventRequest = (EventRequest) iterator.next();\n      if(eventRequest.getClass().equals(requestClass)) {\n        return eventRequest;\n      }\n    }\n\n    return null;\n  }","id":35144,"modified_method":"@Nullable\n  static <T extends EventRequest> T findRequest(@NotNull DebugProcessImpl debugProcess, Class<T> requestClass, Requestor requestor) {\n    Set<EventRequest> requests = debugProcess.getRequestsManager().findRequests(requestor);\n    for (EventRequest eventRequest : requests) {\n      if (eventRequest.getClass().equals(requestClass)) {\n        return (T)eventRequest;\n      }\n    }\n    return null;\n  }","commit_id":"940ac51b75fbde9acf3e7173d32ba14446337397","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void createRequestForPreparedClass(@NotNull DebugProcessImpl debugProcess, @NotNull ReferenceType classType) {\n    try {\n      boolean hasMethod = false;\n      for (Iterator iterator = classType.allMethods().iterator(); iterator.hasNext();) {\n        Method method = (Method)iterator.next();\n        String signature = method.signature();\n        String name = method.name();\n\n        if (getMethodName().equals(name) && mySignature.getName(debugProcess).equals(signature)) {\n          hasMethod = true;\n          break;\n        }\n      }\n\n      if(!hasMethod) {\n        debugProcess.getRequestsManager().setInvalid(\n          this, DebuggerBundle.message(\"error.invalid.breakpoint.method.not.found\", classType.name())\n        );\n        return;\n      }\n\n      RequestManagerImpl requestManager = debugProcess.getRequestsManager();\n      if (isWatchEntry()) {\n        MethodEntryRequest entryRequest = (MethodEntryRequest)findRequest(debugProcess, MethodEntryRequest.class);\n        if (entryRequest == null) {\n          entryRequest = requestManager.createMethodEntryRequest(this);\n        }\n        else {\n          entryRequest.disable();\n        }\n        //entryRequest.addClassFilter(myClassQualifiedName);\n        // use addClassFilter(ReferenceType) in order to stop on subclasses also!\n        entryRequest.addClassFilter(classType);\n        debugProcess.getRequestsManager().enableRequest(entryRequest);\n      }\n      if (isWatchExit()) {\n        MethodExitRequest exitRequest = (MethodExitRequest)findRequest(debugProcess, MethodExitRequest.class);\n        if (exitRequest == null) {\n          exitRequest = requestManager.createMethodExitRequest(this);\n        }\n        else {\n          exitRequest.disable();\n        }\n        //exitRequest.addClassFilter(myClassQualifiedName);\n        exitRequest.addClassFilter(classType);\n        debugProcess.getRequestsManager().enableRequest(exitRequest);\n      }\n    }\n    catch (Exception e) {\n      LOG.debug(e);\n    }\n  }","id":35145,"modified_method":"protected void createRequestForPreparedClass(@NotNull DebugProcessImpl debugProcess, @NotNull ReferenceType classType) {\n    try {\n      boolean hasMethod = false;\n      for (Iterator iterator = classType.allMethods().iterator(); iterator.hasNext();) {\n        Method method = (Method)iterator.next();\n        String signature = method.signature();\n        String name = method.name();\n\n        if (getMethodName().equals(name) && mySignature.getName(debugProcess).equals(signature)) {\n          hasMethod = true;\n          break;\n        }\n      }\n\n      if(!hasMethod) {\n        debugProcess.getRequestsManager().setInvalid(\n          this, DebuggerBundle.message(\"error.invalid.breakpoint.method.not.found\", classType.name())\n        );\n        return;\n      }\n\n      RequestManagerImpl requestManager = debugProcess.getRequestsManager();\n      if (isWatchEntry()) {\n        MethodEntryRequest entryRequest = findRequest(debugProcess, MethodEntryRequest.class, this);\n        if (entryRequest == null) {\n          entryRequest = requestManager.createMethodEntryRequest(this);\n        }\n        else {\n          entryRequest.disable();\n        }\n        //entryRequest.addClassFilter(myClassQualifiedName);\n        // use addClassFilter(ReferenceType) in order to stop on subclasses also!\n        entryRequest.addClassFilter(classType);\n        debugProcess.getRequestsManager().enableRequest(entryRequest);\n      }\n      if (isWatchExit()) {\n        MethodExitRequest exitRequest = findRequest(debugProcess, MethodExitRequest.class, this);\n        if (exitRequest == null) {\n          exitRequest = requestManager.createMethodExitRequest(this);\n        }\n        else {\n          exitRequest.disable();\n        }\n        //exitRequest.addClassFilter(myClassQualifiedName);\n        exitRequest.addClassFilter(classType);\n        debugProcess.getRequestsManager().enableRequest(exitRequest);\n      }\n    }\n    catch (Exception e) {\n      LOG.debug(e);\n    }\n  }","commit_id":"940ac51b75fbde9acf3e7173d32ba14446337397","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void createRequest(DebugProcessImpl debugProcess) {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    if (!isEnabled() || !debugProcess.isAttached() || debugProcess.areBreakpointsMuted() || !debugProcess.getRequestsManager().findRequests(this).isEmpty()) {\n      return;\n    }\n    try {\n      RequestManagerImpl requestManager = debugProcess.getRequestsManager();\n      if (isWatchEntry()) {\n        MethodEntryRequest entryRequest = (MethodEntryRequest)findRequest(debugProcess, MethodEntryRequest.class);\n        if (entryRequest == null) {\n          entryRequest = requestManager.createMethodEntryRequest(this);\n        }\n        else {\n          entryRequest.disable();\n        }\n        entryRequest.addClassFilter(getClassPattern());\n        debugProcess.getRequestsManager().enableRequest(entryRequest);\n      }\n      if (isWatchExit()) {\n        MethodExitRequest exitRequest = (MethodExitRequest)findRequest(debugProcess, MethodExitRequest.class);\n        if (exitRequest == null) {\n          exitRequest = requestManager.createMethodExitRequest(this);\n        }\n        else {\n          exitRequest.disable();\n        }\n        exitRequest.addClassFilter(getClassPattern());\n        debugProcess.getRequestsManager().enableRequest(exitRequest);\n      }\n    }\n    catch (Exception e) {\n      LOG.debug(e);\n    }\n  }","id":35146,"modified_method":"public void createRequest(DebugProcessImpl debugProcess) {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    if (!isEnabled() || !debugProcess.isAttached() || debugProcess.areBreakpointsMuted() || !debugProcess.getRequestsManager().findRequests(this).isEmpty()) {\n      return;\n    }\n    try {\n      RequestManagerImpl requestManager = debugProcess.getRequestsManager();\n      if (isWatchEntry()) {\n        MethodEntryRequest entryRequest = MethodBreakpoint.findRequest(debugProcess, MethodEntryRequest.class, this);\n        if (entryRequest == null) {\n          entryRequest = requestManager.createMethodEntryRequest(this);\n        }\n        else {\n          entryRequest.disable();\n        }\n        entryRequest.addClassFilter(getClassPattern());\n        debugProcess.getRequestsManager().enableRequest(entryRequest);\n      }\n      if (isWatchExit()) {\n        MethodExitRequest exitRequest = MethodBreakpoint.findRequest(debugProcess, MethodExitRequest.class, this);\n        if (exitRequest == null) {\n          exitRequest = requestManager.createMethodExitRequest(this);\n        }\n        else {\n          exitRequest.disable();\n        }\n        exitRequest.addClassFilter(getClassPattern());\n        debugProcess.getRequestsManager().enableRequest(exitRequest);\n      }\n    }\n    catch (Exception e) {\n      LOG.debug(e);\n    }\n  }","commit_id":"940ac51b75fbde9acf3e7173d32ba14446337397","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Well get the output stream (if any) for this type of transport. Typically this\n     * will be called only when Streaming is being used on an outbound endpoint\n     * \n     * @param endpoint the endpoint that releates to this Dispatcher\n     * @param message the current message being processed\n     * @return the output stream to use for this request or null if the transport\n     *         does not support streaming\n     * @throws org.mule.umo.UMOException\n     */\n    public OutputStream getOutputStream(UMOImmutableEndpoint endpoint, UMOMessage message)\n        throws UMOException\n    {\n        String address = endpoint.getEndpointURI().getAddress();\n        String writeToDirectory = message.getStringProperty(FileConnector.PROPERTY_WRITE_TO_DIRECTORY, null); \n         if (writeToDirectory == null) { \n             writeToDirectory = connector.getWriteToDirectory(); \n         } \n         if (writeToDirectory!=null) { \n             address = connector.getFilenameParser().getFilename(message, writeToDirectory); \n         } \n        \n        String filename = message.getStringProperty(FileConnector.PROPERTY_FILENAME, null);\n\n        try\n        {\n            if (filename == null)\n            {\n                String outPattern = message.getStringProperty(FileConnector.PROPERTY_OUTPUT_PATTERN, null);\n                if (outPattern == null)\n                {\n                    outPattern = connector.getOutputPattern();\n                }\n                filename = generateFilename(message, outPattern);\n            }\n\n            if (filename == null)\n            {\n                throw new IOException(\"Filename is null\");\n            }\n\n            File file = FileUtils.createFile(address + \"/\" + filename);\n            if (logger.isInfoEnabled())\n            {\n                logger.info(\"Writing file to: \" + file.getAbsolutePath());\n            }\n\n            return new FileOutputStream(file, MapUtils.getBooleanValue(endpoint.getProperties(),\n                \"outputAppend\", connector.isOutputAppend()));\n        }\n        catch (IOException e)\n        {\n            throw new DispatchException(new Message(Messages.STREAMING_FAILED_NO_STREAM), message, endpoint,\n                e);\n        }\n    }","id":35147,"modified_method":"/**\n     * Well get the output stream (if any) for this type of transport. Typically this\n     * will be called only when Streaming is being used on an outbound endpoint\n     * \n     * @param endpoint the endpoint that releates to this Dispatcher\n     * @param message the current message being processed\n     * @return the output stream to use for this request or null if the transport\n     *         does not support streaming\n     * @throws org.mule.umo.UMOException\n     */\n    public OutputStream getOutputStream(UMOImmutableEndpoint endpoint, UMOMessage message)\n        throws UMOException\n    {\n        String address = endpoint.getEndpointURI().getAddress();\n        String writeToDirectory = message.getStringProperty(\n            FileConnector.PROPERTY_WRITE_TO_DIRECTORY, null);\n        if (writeToDirectory == null)\n        {\n            writeToDirectory = connector.getWriteToDirectory();\n        }\n        if (writeToDirectory != null)\n        {\n            address = connector.getFilenameParser().getFilename(message, writeToDirectory);\n        }\n\n        String filename = null;\n        String outPattern = message.getStringProperty(FileConnector.PROPERTY_OUTPUT_PATTERN, null);\n        if (outPattern == null)\n        {\n            outPattern = connector.getOutputPattern();\n        }\n        try\n        {\n            if (outPattern != null)\n            {\n                filename = generateFilename(message, outPattern);\n            }\n            else\n            {\n                filename = message.getStringProperty(FileConnector.PROPERTY_FILENAME, null);\n                if (filename == null)\n                {\n                    filename = generateFilename(message, null);\n                }\n            }\n\n            if (filename == null)\n            {\n                throw new IOException(\"Filename is null\");\n            }\n            File file = FileUtils.createFile(address + \"/\" + filename);\n            if (logger.isInfoEnabled())\n            {\n                logger.info(\"Writing file to: \" + file.getAbsolutePath());\n            }\n\n            return new FileOutputStream(file, MapUtils.getBooleanValue(endpoint.getProperties(),\n                \"outputAppend\", connector.isOutputAppend()));\n        }\n        catch (IOException e)\n        {\n            throw new DispatchException(new Message(Messages.STREAMING_FAILED_NO_STREAM), message,\n                endpoint, e);\n        }\n    }","commit_id":"e76fb1e607e071c7ac7863e5dca60eb7cd194f33","url":"https://github.com/mulesoft/mule"},{"original_method":"public UMOMessage route(UMOMessage message, UMOSession session, boolean synchronous)\n        throws RoutingException\n    {\n        String endpointName = message.getStringProperty(getSelectorProperty(), null);\n        if (endpointName == null)\n        {\n            throw new IllegalArgumentException(\"selectorProperty '\" + getSelectorProperty()\n                                               + \"' must be set on message in order to route it.\");\n        }\n\n        UMOEndpoint ep = lookupEndpoint(endpointName);\n        if (ep == null)\n        {\n            throw new CouldNotRouteOutboundMessageException(\n                MessageFactory.createStaticMessage(\"No endpoint found with the name \" + endpointName), message, ep);\n        }\n\n        try\n        {\n            if (synchronous)\n            {\n                return send(session, message, ep);\n            }\n            else\n            {\n                dispatch(session, message, ep);\n                return null;\n            }\n        }\n        catch (UMOException e)\n        {\n            throw new CouldNotRouteOutboundMessageException(message, ep, e);\n        }\n    }","id":35148,"modified_method":"public UMOMessage route(UMOMessage message, UMOSession session, boolean synchronous)\n        throws RoutingException\n    {\n        String endpointName;\n        if (extractorEnabled)\n        {\n            if (null == getPropertyExtractor())\n            {\n                throw new IllegalArgumentException(\"No property extractor specified\");\n            }\n            Object property = getPropertyExtractor().getProperty(getSelectorProperty(), message);\n            if (!(property instanceof String))\n            {\n                throw new IllegalArgumentException(\"No property for \" + getSelectorProperty());\n            }\n            endpointName = (String) property;\n        }\n        else\n        {\n            endpointName = message.getStringProperty(getSelectorProperty(), null);\n        }\n        if (endpointName == null)\n        {\n            throw new IllegalArgumentException(\"selectorProperty '\" + getSelectorProperty()\n                                               + \"' must be set on message in order to route it.\");\n        }\n\n        UMOEndpoint ep = lookupEndpoint(endpointName);\n        if (ep == null)\n        {\n            throw new CouldNotRouteOutboundMessageException(\n                MessageFactory.createStaticMessage(\"No endpoint found with the name \" + endpointName), message, ep);\n        }\n\n        try\n        {\n            if (synchronous)\n            {\n                return send(session, message, ep);\n            }\n            else\n            {\n                dispatch(session, message, ep);\n                return null;\n            }\n        }\n        catch (UMOException e)\n        {\n            throw new CouldNotRouteOutboundMessageException(message, ep, e);\n        }\n    }","commit_id":"8836115edcf494cd39cfd9df134b7e948d9d2f8f","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        super.init();\n        registerBeanDefinitionParser(\"xml-jxpath-filter\", new ChildDefinitionParser(\"filter\", JXPathFilter.class));\n        registerBeanDefinitionParser(\"is-xml-filter\", new ChildDefinitionParser(\"filter\", IsXmlFilter.class));\n        registerBeanDefinitionParser(\"xml-message-splitter\", new RouterDefinitionParser(\"router\", FilteringXmlMessageSplitter.class));\n        registerBeanDefinitionParser(\"xml-round-robin-splitter\", new RouterDefinitionParser(\"router\", RoundRobinXmlSplitter.class).addAlias(\"endpointFiltering\", \"enableEndpointFiltering\"));\n        registerBeanDefinitionParser(\"dom-to-xml\", new OrphanDefinitionParser(DomDocumentToXml.class, false));\n        registerBeanDefinitionParser(\"xml-jxpath-extractor\", new OrphanDefinitionParser(JXPathExtractor.class, false));\n        registerBeanDefinitionParser(\"object-to-xml\", new OrphanDefinitionParser(ObjectToXml.class, false));\n        registerBeanDefinitionParser(\"xml-to-dom\", new OrphanDefinitionParser(XmlToDomDocument.class, false));\n        registerBeanDefinitionParser(\"xml-to-object\", new OrphanDefinitionParser(XmlToObject.class, false));\n        registerBeanDefinitionParser(\"xml-xslt\", new XsltTransformerDefinitionParser());\n        registerBeanDefinitionParser(\"namespace\", new ChildMapEntryDefinitionParser(\"namespaces\", \"prefix\", \"uri\"));\n        registerBeanDefinitionParser(\"context-property\", new ChildMapEntryDefinitionParser(\"contextProperties\", \"key\", \"value\"));\n    }","id":35149,"modified_method":"public void init()\n    {\n        super.init();\n        registerBeanDefinitionParser(\"xml-jxpath-filter\", new ChildDefinitionParser(\"filter\", JXPathFilter.class));\n        registerBeanDefinitionParser(\"is-xml-filter\", new ChildDefinitionParser(\"filter\", IsXmlFilter.class));\n        registerBeanDefinitionParser(\"xml-message-splitter\", new RouterDefinitionParser(\"router\", FilteringXmlMessageSplitter.class));\n        registerBeanDefinitionParser(\"xml-round-robin-splitter\", new RouterDefinitionParser(\"router\", RoundRobinXmlSplitter.class).addAlias(\"endpointFiltering\", \"enableEndpointFiltering\"));\n        registerBeanDefinitionParser(\"dom-to-xml\", new OrphanDefinitionParser(DomDocumentToXml.class, false));\n        registerBeanDefinitionParser(\"xml-jxpath-extractor\", new OrphanDefinitionParser(JXPathExtractor.class, false));\n        registerBeanDefinitionParser(\"object-to-xml\", new OrphanDefinitionParser(ObjectToXml.class, false));\n        registerBeanDefinitionParser(\"xml-to-dom\", new OrphanDefinitionParser(XmlToDomDocument.class, false));\n        registerBeanDefinitionParser(\"xml-to-object\", new OrphanDefinitionParser(XmlToObject.class, false));\n        registerBeanDefinitionParser(\"xml-xslt\", new XsltTransformerDefinitionParser());\n        registerBeanDefinitionParser(\"xml-jxpath-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", JXPathPropertyExtractor.class));\n        registerBeanDefinitionParser(\"xml-dom4j-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", Dom4jPropertyExtractor.class));\n        registerBeanDefinitionParser(\"xml-jdom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", JDomPropertyExtractor.class));\n        registerBeanDefinitionParser(\"namespace\", new ChildMapEntryDefinitionParser(\"namespaces\", \"prefix\", \"uri\"));\n        registerBeanDefinitionParser(\"context-property\", new ChildMapEntryDefinitionParser(\"contextProperties\", \"key\", \"value\"));\n    }","commit_id":"8836115edcf494cd39cfd9df134b7e948d9d2f8f","url":"https://github.com/mulesoft/mule"},{"original_method":"protected boolean returnException(MuleEvent event, HttpMethod httpMethod)\n    {\n        return httpMethod.getStatusCode() >= ERROR_STATUS_CODE_RANGE_START\n                && !BooleanUtils.toBoolean((String) event.getMessage().getProperty(HttpConnector.HTTP_DISABLE_STATUS_CODE_EXCEPTION_CHECK));\n    }","id":35150,"modified_method":"protected boolean returnException(MuleEvent event, HttpMethod httpMethod)\n    {\n        String disableCheck = (String) event.getMessage().getProperty(HttpConnector.HTTP_DISABLE_STATUS_CODE_EXCEPTION_CHECK, PropertyScope.INVOCATION);\n        if (disableCheck == null)\n        {\n            disableCheck = (String) event.getMessage().getProperty(HttpConnector.HTTP_DISABLE_STATUS_CODE_EXCEPTION_CHECK, PropertyScope.OUTBOUND); \n        }\n        return httpMethod.getStatusCode() >= ERROR_STATUS_CODE_RANGE_START\n                && !BooleanUtils.toBoolean(disableCheck);\n    }","commit_id":"6ac964e70d08dc96e68a4ef443db2f070e4b60ae","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public Object transform(MuleMessage msg, String outputEncoding) throws TransformerException\n    {\n        Object src = msg.getPayload();\n\n        String endpointString = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, PropertyScope.OUTBOUND, null);\n        if (endpointString == null)\n        {\n            endpointString = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, PropertyScope.INVOCATION, null); \n        }\n        if (endpointString == null)\n        {\n            throw new TransformerException(\n                    HttpMessages.eventPropertyNotSetCannotProcessRequest(\n                            MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n\n        String method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, PropertyScope.INVOCATION, null);\n        if (method == null)\n        {\n            method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, PropertyScope.OUTBOUND, \"POST\");\n        }\n        try\n        {\n            //Allow Expressions to be embedded\n            endpointString = endpointString.replaceAll(\"%23\", \"#\");\n            endpointString = muleContext.getExpressionManager().parse(endpointString, msg, true);\n            URI uri = new URI(endpointString);\n            HttpMethod httpMethod;\n\n            if (HttpConstants.METHOD_GET.equals(method))\n            {\n                httpMethod = new GetMethod(uri.toString());\n                String paramName = URLEncoder.encode(msg.getStringProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY, PropertyScope.OUTBOUND,\n                                                                           HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY), outputEncoding);\n\n                String paramValue;\n                Boolean encode =  msg.getProperty(HttpConnector.HTTP_ENCODE_PARAMVALUE, PropertyScope.INVOCATION, null);\n                if (encode == null)\n                {\n                    encode = msg.getProperty(HttpConnector.HTTP_ENCODE_PARAMVALUE, PropertyScope.OUTBOUND, true);\n                }\n                \n                if (encode)\n                {\n                    paramValue = URLEncoder.encode(src.toString(), outputEncoding);\n                }\n                else\n                {\n                    paramValue = src.toString();\n                }\n\n                String query = uri.getRawQuery();\n                if (!(src instanceof NullPayload) && !StringUtils.EMPTY.equals(src))\n                {\n                    if (query == null)\n                    {\n                        query = paramName + \"=\" + paramValue;\n                    }\n                    else\n                    {\n                        query += \"&\" + paramName + \"=\" + paramValue;\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            }\n            else if (HttpConstants.METHOD_POST.equalsIgnoreCase(method))\n            {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                String paramName = msg.getStringProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, PropertyScope.OUTBOUND, null);\n\n                if (src instanceof Map)\n                {\n                    for (Iterator iterator = ((Map)src).entrySet().iterator(); iterator.hasNext();)\n                    {\n                        Map.Entry entry = (Map.Entry)iterator.next();\n                        postMethod.addParameter(entry.getKey().toString(), entry.getValue().toString());\n                    }\n                }\n                else if(paramName!=null)\n                {\n                    postMethod.addParameter(paramName, src.toString());\n\n                }\n                else\n                {\n                    // Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod, msg);\n                    setupEntityMethod(src, outputEncoding, msg, uri, postMethod);\n                }\n\n                httpMethod = postMethod;\n            }\n            else if (HttpConstants.METHOD_PUT.equalsIgnoreCase(method))\n            {\n                PutMethod putMethod = new PutMethod(uri.toString());\n\n                setupEntityMethod(src, outputEncoding, msg, uri, putMethod);\n\n                httpMethod = putMethod;\n            }\n            else if (HttpConstants.METHOD_DELETE.equalsIgnoreCase(method))\n            {\n                httpMethod = new DeleteMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_HEAD.equalsIgnoreCase(method))\n            {\n                httpMethod = new HeadMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_OPTIONS.equalsIgnoreCase(method))\n            {\n                httpMethod = new OptionsMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_TRACE.equalsIgnoreCase(method))\n            {\n                httpMethod = new TraceMethod(uri.toString());\n            }\n            else\n            {\n                throw new TransformerException(HttpMessages.unsupportedMethod(method));\n            }\n\n            // Allow the user to set HttpMethodParams as an object on the message\n            HttpMethodParams params = (HttpMethodParams) msg.removeProperty(HttpConnector.HTTP_PARAMS_PROPERTY);\n            if (params != null)\n            {\n                httpMethod.setParams(params);\n            }\n            else\n            {\n                // TODO we should probably set other properties here\n                String httpVersion = msg.getStringProperty(HttpConnector.HTTP_VERSION_PROPERTY, PropertyScope.OUTBOUND,\n                                                           HttpConstants.HTTP11);\n                if (HttpConstants.HTTP10.equals(httpVersion))\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_0);\n                }\n                else\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_1);\n                }\n            }\n\n            setHeaders(httpMethod, msg);\n\n            return httpMethod;\n        }\n        catch (Exception e)\n        {\n            throw new TransformerException(this, e);\n        }\n    }","id":35151,"modified_method":"@Override\n    public Object transform(MuleMessage msg, String outputEncoding) throws TransformerException\n    {\n        Object src = msg.getPayload();\n\n        String endpointString = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, PropertyScope.OUTBOUND, null);\n        if (endpointString == null)\n        {\n            endpointString = msg.getStringProperty(MuleProperties.MULE_ENDPOINT_PROPERTY, PropertyScope.INVOCATION, null); \n        }\n        if (endpointString == null)\n        {\n            throw new TransformerException(\n                    HttpMessages.eventPropertyNotSetCannotProcessRequest(\n                            MuleProperties.MULE_ENDPOINT_PROPERTY), this);\n        }\n\n        String method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, PropertyScope.INVOCATION, null);\n        if (method == null)\n        {\n            method = msg.getStringProperty(HttpConnector.HTTP_METHOD_PROPERTY, PropertyScope.OUTBOUND, \"POST\");\n        }\n        try\n        {\n            //Allow Expressions to be embedded\n            endpointString = endpointString.replaceAll(\"%23\", \"#\");\n            endpointString = muleContext.getExpressionManager().parse(endpointString, msg, true);\n            URI uri = new URI(endpointString);\n            HttpMethod httpMethod;\n\n            if (HttpConstants.METHOD_GET.equals(method))\n            {\n                httpMethod = new GetMethod(uri.toString());\n                String getBodyParam = msg.getStringProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY, PropertyScope.INVOCATION,\n                                                                  HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                if (getBodyParam == null)\n                {\n                    msg.getStringProperty(HttpConnector.HTTP_GET_BODY_PARAM_PROPERTY, PropertyScope.OUTBOUND,\n                                          HttpConnector.DEFAULT_HTTP_GET_BODY_PARAM_PROPERTY);\n                }\n                String paramName = URLEncoder.encode(getBodyParam, outputEncoding);\n\n                String paramValue;\n                Boolean encode =  msg.getProperty(HttpConnector.HTTP_ENCODE_PARAMVALUE, PropertyScope.INVOCATION, null);\n                if (encode == null)\n                {\n                    encode = msg.getProperty(HttpConnector.HTTP_ENCODE_PARAMVALUE, PropertyScope.OUTBOUND, true);\n                }\n                \n                if (encode)\n                {\n                    paramValue = URLEncoder.encode(src.toString(), outputEncoding);\n                }\n                else\n                {\n                    paramValue = src.toString();\n                }\n\n                String query = uri.getRawQuery();\n                if (!(src instanceof NullPayload) && !StringUtils.EMPTY.equals(src))\n                {\n                    if (query == null)\n                    {\n                        query = paramName + \"=\" + paramValue;\n                    }\n                    else\n                    {\n                        query += \"&\" + paramName + \"=\" + paramValue;\n                    }\n                }\n                httpMethod.setQueryString(query);\n\n            }\n            else if (HttpConstants.METHOD_POST.equalsIgnoreCase(method))\n            {\n                PostMethod postMethod = new PostMethod(uri.toString());\n                String paramName = msg.getStringProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, PropertyScope.OUTBOUND, null);\n                if (paramName == null)\n                {\n                    paramName = msg.getStringProperty(HttpConnector.HTTP_POST_BODY_PARAM_PROPERTY, PropertyScope.INVOCATION, null);\n                }\n\n                if (src instanceof Map)\n                {\n                    for (Iterator iterator = ((Map)src).entrySet().iterator(); iterator.hasNext();)\n                    {\n                        Map.Entry entry = (Map.Entry)iterator.next();\n                        postMethod.addParameter(entry.getKey().toString(), entry.getValue().toString());\n                    }\n                }\n                else if(paramName!=null)\n                {\n                    postMethod.addParameter(paramName, src.toString());\n\n                }\n                else\n                {\n                    // Call method to manage the parameter array\n                    addParameters(uri.getQuery(), postMethod, msg);\n                    setupEntityMethod(src, outputEncoding, msg, uri, postMethod);\n                }\n\n                httpMethod = postMethod;\n            }\n            else if (HttpConstants.METHOD_PUT.equalsIgnoreCase(method))\n            {\n                PutMethod putMethod = new PutMethod(uri.toString());\n\n                setupEntityMethod(src, outputEncoding, msg, uri, putMethod);\n\n                httpMethod = putMethod;\n            }\n            else if (HttpConstants.METHOD_DELETE.equalsIgnoreCase(method))\n            {\n                httpMethod = new DeleteMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_HEAD.equalsIgnoreCase(method))\n            {\n                httpMethod = new HeadMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_OPTIONS.equalsIgnoreCase(method))\n            {\n                httpMethod = new OptionsMethod(uri.toString());\n            }\n            else if (HttpConstants.METHOD_TRACE.equalsIgnoreCase(method))\n            {\n                httpMethod = new TraceMethod(uri.toString());\n            }\n            else\n            {\n                throw new TransformerException(HttpMessages.unsupportedMethod(method));\n            }\n\n            // Allow the user to set HttpMethodParams as an object on the message\n            HttpMethodParams params = (HttpMethodParams) msg.removeProperty(HttpConnector.HTTP_PARAMS_PROPERTY);\n            if (params != null)\n            {\n                httpMethod.setParams(params);\n            }\n            else\n            {\n                // TODO we should probably set other properties here\n                String httpVersion = msg.getStringProperty(HttpConnector.HTTP_VERSION_PROPERTY, PropertyScope.OUTBOUND,\n                                                           HttpConstants.HTTP11);\n                if (HttpConstants.HTTP10.equals(httpVersion))\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_0);\n                }\n                else\n                {\n                    httpMethod.getParams().setVersion(HttpVersion.HTTP_1_1);\n                }\n            }\n\n            setHeaders(httpMethod, msg);\n\n            return httpMethod;\n        }\n        catch (Exception e)\n        {\n            throw new TransformerException(this, e);\n        }\n    }","commit_id":"6ac964e70d08dc96e68a4ef443db2f070e4b60ae","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    @NotNull\n    public File getExistedJarFile() {\n        return assertFileExists(getKotlinPaths().getRuntimePath());\n    }","id":35152,"modified_method":"@Override\n    @NotNull\n    public File getExistedJarFile() {\n        return assertFileExists(PathUtil.getKotlinPathsForIdeaPlugin().getRuntimePath());\n    }","commit_id":"d2b948dc2ca11ab3a29abf1b5d9779a58a7756fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public File getExistedSourcesJarFile() {\n        return assertFileExists(getKotlinPaths().getRuntimeSourcesPath());\n    }","id":35153,"modified_method":"@Override\n    public File getExistedSourcesJarFile() {\n        return assertFileExists(PathUtil.getKotlinPathsForIdeaPlugin().getRuntimeSourcesPath());\n    }","commit_id":"d2b948dc2ca11ab3a29abf1b5d9779a58a7756fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public File getExistedJarFile() {\n        return assertFileExists(getKotlinPaths().getJsLibJarPath());\n    }","id":35154,"modified_method":"@NotNull\n    @Override\n    public File getExistedJarFile() {\n        return assertFileExists(PathUtil.getKotlinPathsForIdeaPlugin().getJsLibJarPath());\n    }","commit_id":"d2b948dc2ca11ab3a29abf1b5d9779a58a7756fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public File getJsFile() {\n        return assertFileExists(getKotlinPaths().getJsLibJsPath());\n    }","id":35155,"modified_method":"@NotNull\n    public File getJsFile() {\n        return assertFileExists(PathUtil.getKotlinPathsForIdeaPlugin().getJsLibJsPath());\n    }","commit_id":"d2b948dc2ca11ab3a29abf1b5d9779a58a7756fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static KotlinPaths getKotlinPathsForIdeaPlugin() {\n        return new KotlinPathsFromHomeDir(getCompilerPathForIdeaPlugin());\n    }","id":35156,"modified_method":"@NotNull\n    public static KotlinPaths getKotlinPathsForIdeaPlugin() {\n        return ApplicationManager.getApplication().isUnitTestMode()\n            ? getKotlinPathsForDistDirectory()\n            : new KotlinPathsFromHomeDir(getCompilerPathForIdeaPlugin());\n    }","commit_id":"d2b948dc2ca11ab3a29abf1b5d9779a58a7756fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static CompilerEnvironment getEnvironmentFor(@NotNull CompileContext compileContext, @NotNull Module module, boolean tests) {\n        VirtualFile mainOutput = compileContext.getModuleOutputDirectory(module);\n        VirtualFile outputDirectoryForTests = compileContext.getModuleOutputDirectoryForTests(module);\n        File outputDir = tests ? toNullableIoFile(outputDirectoryForTests) : toNullableIoFile(mainOutput);\n        KotlinPaths kotlinPaths = ApplicationManager.getApplication().isUnitTestMode()\n                                        ? PathUtil.getKotlinPathsForDistDirectory()\n                                        : PathUtil.getKotlinPathsForIdeaPlugin();\n        return CompilerEnvironment.getEnvironmentFor(kotlinPaths, outputDir);\n    }","id":35157,"modified_method":"@NotNull\n    public static CompilerEnvironment getEnvironmentFor(@NotNull CompileContext compileContext, @NotNull Module module, boolean tests) {\n        VirtualFile mainOutput = compileContext.getModuleOutputDirectory(module);\n        VirtualFile outputDirectoryForTests = compileContext.getModuleOutputDirectoryForTests(module);\n        File outputDir = tests ? toNullableIoFile(outputDirectoryForTests) : toNullableIoFile(mainOutput);\n        KotlinPaths kotlinPaths = PathUtil.getKotlinPathsForIdeaPlugin();\n        return CompilerEnvironment.getEnvironmentFor(kotlinPaths, outputDir);\n    }","commit_id":"d2b948dc2ca11ab3a29abf1b5d9779a58a7756fb","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public ChooseCompilerSourcePanel(@Nullable Project project) {\n        useBundledKotlinRadioButton.setText(useBundledKotlinRadioButton.getText() + \" - \" + JetPluginUtil.getPluginVersion());\n\n        initialStandaloneLabelText = useStandaloneKotlinRadioButton.getText();\n\n        kotlinStandalonePathField.setEditable(false);\n        kotlinStandalonePathField.addBrowseFolderListener(\n                \"Kotlin Compiler\", \"Choose folder with Kotlin compiler installation\", project,\n                new FileChooserDescriptor(false, true, false, false, false, false) {\n                    @Override\n                    public boolean isFileSelectable(VirtualFile file) {\n                        if (!super.isFileSelectable(file)) {\n                            return false;\n                        }\n\n                        return PathUtil.KOTLIN_HOME_DIRECTORY_FINDER.fun(com.intellij.util.PathUtil.getLocalPath(file)) != null;\n                    }\n                });\n\n        kotlinStandalonePathField.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n            @Override\n            protected void textChanged(final DocumentEvent e) {\n                updateStandaloneVersion();\n                updateComponents();\n            }\n        });\n\n        useStandaloneKotlinRadioButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(@NotNull ActionEvent e) {\n                updateComponents();\n            }\n        });\n        useBundledKotlinRadioButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(@NotNull ActionEvent e) {\n                updateComponents();\n            }\n        });\n\n        updateStandaloneVersion();\n        updateComponents();\n    }","id":35158,"modified_method":"public ChooseCompilerSourcePanel() {\n        bundledPluginVersion.setText(bundledPluginVersion.getText() + \" - \" + JetPluginUtil.getPluginVersion());\n    }","commit_id":"f98ae185965a002e0d77140e780343f532387925","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public CreateJavaLibraryDialog(@Nullable Project project, @NotNull String title, VirtualFile contextDirectory) {\n        super(project);\n\n        setTitle(title);\n\n        init();\n\n        compilerSourcePanel = new ChooseCompilerSourcePanel(project);\n        compilerSourcePanel.addValidityListener(new ValidityListener() {\n            @Override\n            public void validityChanged(boolean isValid) {\n                updateComponents();\n            }\n        });\n        compilerSourcePanelPlace.add(compilerSourcePanel.getContentPane(), BorderLayout.CENTER, 0);\n\n        copyIntoPanel = new CopyIntoPanel(project, contextDirectory);\n        copyIntoPanel.addValidityListener(new ValidityListener() {\n            @Override\n            public void validityChanged(boolean isValid) {\n                updateComponents();\n            }\n        });\n        copyIntoPanelPlace.add(copyIntoPanel.getContentPane(), BorderLayout.CENTER);\n\n        contentPane.setMinimumSize(new Dimension(380, 180));\n\n        copyLibraryCheckbox.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(@NotNull ActionEvent e) {\n                updateComponents();\n            }\n        });\n\n        updateComponents();\n    }","id":35159,"modified_method":"public CreateJavaLibraryDialog(@Nullable Project project, @NotNull String title, VirtualFile contextDirectory) {\n        super(project);\n\n        setTitle(title);\n\n        init();\n\n        ChooseCompilerSourcePanel compilerSourcePanel = new ChooseCompilerSourcePanel();\n        compilerSourcePanelPlace.add(compilerSourcePanel.getContentPane(), BorderLayout.CENTER, 0);\n\n        copyIntoPanel = new CopyIntoPanel(project, contextDirectory);\n        copyIntoPanel.addValidityListener(new ValidityListener() {\n            @Override\n            public void validityChanged(boolean isValid) {\n                updateComponents();\n            }\n        });\n        copyIntoPanelPlace.add(copyIntoPanel.getContentPane(), BorderLayout.CENTER);\n\n        copyLibraryCheckbox.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(@NotNull ActionEvent e) {\n                updateComponents();\n            }\n        });\n\n        updateComponents();\n    }","commit_id":"f98ae185965a002e0d77140e780343f532387925","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void updateComponents() {\n        copyIntoPanel.setEnabled(copyLibraryCheckbox.isSelected());\n        setOKActionEnabled(!(compilerSourcePanel.hasErrors() || copyIntoPanel.hasErrors()));\n    }","id":35160,"modified_method":"private void updateComponents() {\n        copyIntoPanel.setEnabled(copyLibraryCheckbox.isSelected());\n        setOKActionEnabled(!copyIntoPanel.hasErrors());\n    }","commit_id":"f98ae185965a002e0d77140e780343f532387925","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void updateComponents() {\n        copyIntoPanel.setEnabled(copyLibraryCheckbox.isSelected() ||\n                                 ECMAScript3JavaScriptRuntimeCheckBox.isSelected());\n\n        setOKActionEnabled(!(compilerSourcePanel.hasErrors() || copyIntoPanel.hasErrors()));\n    }","id":35161,"modified_method":"private void updateComponents() {\n        copyIntoPanel.setEnabled(copyLibraryCheckbox.isSelected() ||\n                                 ECMAScript3JavaScriptRuntimeCheckBox.isSelected());\n\n        setOKActionEnabled(!copyIntoPanel.hasErrors());\n    }","commit_id":"f98ae185965a002e0d77140e780343f532387925","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public CreateJavaScriptLibraryDialog(@Nullable Project project, @NotNull String title, VirtualFile contextDirectory) {\n        super(project);\n\n        setTitle(title);\n\n        init();\n\n        compilerSourcePanel = new ChooseCompilerSourcePanel(project);\n        compilerSourcePanel.addValidityListener(new ValidityListener() {\n            @Override\n            public void validityChanged(boolean isValid) {\n                updateComponents();\n            }\n        });\n        compilerSourcePanelPlace.add(compilerSourcePanel.getContentPane(), BorderLayout.CENTER);\n\n        copyIntoPanel = new CopyIntoPanel(project, contextDirectory);\n        copyIntoPanel.addValidityListener(new ValidityListener() {\n            @Override\n            public void validityChanged(boolean isValid) {\n                updateComponents();\n            }\n        });\n        copyIntoPanelPlace.add(copyIntoPanel.getContentPane(), BorderLayout.CENTER);\n\n        contentPane.setMinimumSize(new Dimension(380, 180));\n\n        ActionListener updateComponentsListener = new ActionListener() {\n            @Override\n            public void actionPerformed(@NotNull ActionEvent e) {\n                updateComponents();\n            }\n        };\n\n        copyLibraryCheckbox.addActionListener(updateComponentsListener);\n        ECMAScript3JavaScriptRuntimeCheckBox.addActionListener(updateComponentsListener);\n\n        updateComponents();\n    }","id":35162,"modified_method":"public CreateJavaScriptLibraryDialog(@Nullable Project project, @NotNull String title, VirtualFile contextDirectory) {\n        super(project);\n\n        setTitle(title);\n\n        init();\n\n        ChooseCompilerSourcePanel compilerSourcePanel = new ChooseCompilerSourcePanel();\n        compilerSourcePanelPlace.add(compilerSourcePanel.getContentPane(), BorderLayout.CENTER);\n\n        copyIntoPanel = new CopyIntoPanel(project, contextDirectory);\n        copyIntoPanel.addValidityListener(new ValidityListener() {\n            @Override\n            public void validityChanged(boolean isValid) {\n                updateComponents();\n            }\n        });\n        copyIntoPanelPlace.add(copyIntoPanel.getContentPane(), BorderLayout.CENTER);\n\n        ActionListener updateComponentsListener = new ActionListener() {\n            @Override\n            public void actionPerformed(@NotNull ActionEvent e) {\n                updateComponents();\n            }\n        };\n\n        copyLibraryCheckbox.addActionListener(updateComponentsListener);\n        ECMAScript3JavaScriptRuntimeCheckBox.addActionListener(updateComponentsListener);\n\n        updateComponents();\n    }","commit_id":"f98ae185965a002e0d77140e780343f532387925","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    @Override\n    public NewLibraryConfiguration createNewLibrary(@NotNull JComponent parentComponent, @Nullable VirtualFile contextDirectory) {\n        CreateJavaScriptLibraryDialog dialog = new CreateJavaScriptLibraryDialog(null, \"Create Kotlin JavaScript Library\", contextDirectory);\n        dialog.show();\n\n        if (dialog.isOK()) {\n            String standaloneCompilerPath = dialog.getStandaloneCompilerPath();\n            KotlinPaths paths = standaloneCompilerPath == null ?\n                                PathUtil.getKotlinPathsForIdeaPlugin() :\n                                PathUtil.getKotlinStandaloneCompilerPaths(standaloneCompilerPath);\n\n            File libraryFile = paths.getJsLibJarPath();\n            if (!libraryFile.exists()) {\n                Messages.showErrorDialog(String.format(\"JavaScript standard library was not found in %s\", paths.getLibPath()),\n                                         JAVA_SCRIPT_LIBRARY_CREATION);\n                return null;\n            }\n\n            String copyIntoPath = dialog.getCopyIntoPath();\n            if (copyIntoPath != null) {\n                List<File> copyFiles = new ArrayList<File>();\n\n                if (dialog.isCopyLibraryFiles()) copyFiles.add(libraryFile);\n                if (dialog.isCopyECMA3()) copyFiles.add(paths.getJsLibJsPath());\n\n                Map<File,File> copiedFiles =\n                        FileUIUtils.copyWithOverwriteDialog(parentComponent, JAVA_SCRIPT_LIBRARY_CREATION, copyIntoPath, copyFiles);\n                if (copiedFiles == null) {\n                    return null;\n                }\n\n                if (dialog.isCopyLibraryFiles()) {\n                    libraryFile = copiedFiles.get(libraryFile);\n                }\n            }\n\n            final String libraryFileUrl = VfsUtil.getUrlForLibraryRoot(libraryFile);\n            return new NewLibraryConfiguration(LIBRARY_NAME + \"-\" +  dialog.getVersion(), getDownloadableLibraryType(), new LibraryVersionProperties()) {\n                @Override\n                public void addRoots(@NotNull LibraryEditor editor) {\n                    editor.addRoot(libraryFileUrl, OrderRootType.SOURCES);\n                }\n            };\n        }\n\n        return null;\n    }","id":35163,"modified_method":"@Nullable\n    @Override\n    public NewLibraryConfiguration createNewLibrary(@NotNull JComponent parentComponent, @Nullable VirtualFile contextDirectory) {\n        CreateJavaScriptLibraryDialog dialog = new CreateJavaScriptLibraryDialog(null, \"Create Kotlin JavaScript Library\", contextDirectory);\n        dialog.show();\n\n        if (dialog.isOK()) {\n            KotlinPaths paths = PathUtil.getKotlinPathsForIdeaPlugin();\n\n            File libraryFile = paths.getJsLibJarPath();\n            if (!libraryFile.exists()) {\n                Messages.showErrorDialog(String.format(\"JavaScript standard library was not found in %s\", paths.getLibPath()),\n                                         JAVA_SCRIPT_LIBRARY_CREATION);\n                return null;\n            }\n\n            String libraryName = LIBRARY_NAME;\n\n            String copyIntoPath = dialog.getCopyIntoPath();\n            if (copyIntoPath != null) {\n                List<File> copyFiles = new ArrayList<File>();\n\n                if (dialog.isCopyLibraryFiles()) copyFiles.add(libraryFile);\n                if (dialog.isCopyECMA3()) copyFiles.add(paths.getJsLibJsPath());\n\n                Map<File,File> copiedFiles =\n                        FileUIUtils.copyWithOverwriteDialog(parentComponent, JAVA_SCRIPT_LIBRARY_CREATION, copyIntoPath, copyFiles);\n                if (copiedFiles == null) {\n                    return null;\n                }\n\n                if (dialog.isCopyLibraryFiles()) {\n                    libraryFile = copiedFiles.get(libraryFile);\n                    libraryName = LIBRARY_NAME + \"-\" + JetPluginUtil.getPluginVersion();\n                }\n            }\n\n            final String libraryFileUrl = VfsUtil.getUrlForLibraryRoot(libraryFile);\n            return new NewLibraryConfiguration(libraryName, getDownloadableLibraryType(), new LibraryVersionProperties()) {\n                @Override\n                public void addRoots(@NotNull LibraryEditor editor) {\n                    editor.addRoot(libraryFileUrl, OrderRootType.SOURCES);\n                }\n            };\n        }\n\n        return null;\n    }","commit_id":"f98ae185965a002e0d77140e780343f532387925","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    @Override\n    public NewLibraryConfiguration createNewLibrary(@NotNull JComponent parentComponent, @Nullable VirtualFile contextDirectory) {\n        CreateJavaLibraryDialog dialog = new CreateJavaLibraryDialog(null, \"Create Kotlin Java Runtime Library\", contextDirectory);\n        dialog.show();\n\n        if (dialog.isOK()) {\n            String standaloneCompilerPath = dialog.getStandaloneCompilerPath();\n            KotlinPaths paths = standaloneCompilerPath == null ?\n                                      PathUtil.getKotlinPathsForIdeaPlugin() :\n                                      PathUtil.getKotlinStandaloneCompilerPaths(standaloneCompilerPath);\n\n            File libraryFile = paths.getRuntimePath();\n            if (!libraryFile.exists()) {\n                Messages.showErrorDialog(\n                        parentComponent,\n                        String.format(\"Java Runtime library was not found in '%s'.\" , paths.getLibPath()),\n                        JAVA_RUNTIME_LIBRARY_CREATION);\n                return null;\n            }\n\n            String copyIntoPath = dialog.getCopyIntoPath();\n            if (copyIntoPath != null) {\n                libraryFile = FileUIUtils.copyWithOverwriteDialog(parentComponent, JAVA_RUNTIME_LIBRARY_CREATION, copyIntoPath, libraryFile);\n                if (libraryFile == null) {\n                    return null;\n                }\n            }\n\n            final String libraryFileUrl = VfsUtil.getUrlForLibraryRoot(libraryFile);\n            return new NewLibraryConfiguration(LIBRARY_NAME + \"-\" + dialog.getVersion(), getDownloadableLibraryType(), new LibraryVersionProperties()) {\n                @Override\n                public void addRoots(@NotNull LibraryEditor editor) {\n                    editor.addRoot(libraryFileUrl, OrderRootType.CLASSES);\n                    editor.addRoot(libraryFileUrl + \"src\", OrderRootType.SOURCES);\n                }\n            };\n        }\n\n        return null;\n    }","id":35164,"modified_method":"@Nullable\n    @Override\n    public NewLibraryConfiguration createNewLibrary(@NotNull JComponent parentComponent, @Nullable VirtualFile contextDirectory) {\n        CreateJavaLibraryDialog dialog = new CreateJavaLibraryDialog(null, \"Create Kotlin Java Runtime Library\", contextDirectory);\n        dialog.show();\n\n        if (dialog.isOK()) {\n            KotlinPaths paths = PathUtil.getKotlinPathsForIdeaPlugin();\n\n            File libraryFile = paths.getRuntimePath();\n            if (!libraryFile.exists()) {\n                Messages.showErrorDialog(\n                        parentComponent,\n                        String.format(\"Java Runtime library was not found in '%s'.\" , paths.getLibPath()),\n                        JAVA_RUNTIME_LIBRARY_CREATION);\n                return null;\n            }\n\n            String libraryName = LIBRARY_NAME;\n\n            String copyIntoPath = dialog.getCopyIntoPath();\n            if (copyIntoPath != null) {\n                libraryFile = FileUIUtils.copyWithOverwriteDialog(parentComponent, JAVA_RUNTIME_LIBRARY_CREATION, copyIntoPath, libraryFile);\n                if (libraryFile == null) {\n                    return null;\n                }\n\n                libraryName = LIBRARY_NAME + \"-\" + JetPluginUtil.getPluginVersion();\n            }\n\n            final String libraryFileUrl = VfsUtil.getUrlForLibraryRoot(libraryFile);\n            return new NewLibraryConfiguration(libraryName, getDownloadableLibraryType(), new LibraryVersionProperties()) {\n                @Override\n                public void addRoots(@NotNull LibraryEditor editor) {\n                    editor.addRoot(libraryFileUrl, OrderRootType.CLASSES);\n                    editor.addRoot(libraryFileUrl + \"src\", OrderRootType.SOURCES);\n                }\n            };\n        }\n\n        return null;\n    }","commit_id":"f98ae185965a002e0d77140e780343f532387925","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    protected FunctionDescriptor doSubstitute(@NotNull TypeSubstitutor originalSubstitutor,\n            @NotNull DeclarationDescriptor newOwner,\n            @NotNull Modality newModality,\n            @NotNull Visibility newVisibility,\n            @Nullable FunctionDescriptor original,\n            boolean copyOverrides,\n            @NotNull Kind kind\n    ) {\n        FunctionDescriptorImpl substitutedDescriptor = createSubstitutedCopy(newOwner, original, kind);\n\n        List<TypeParameterDescriptor> originalTypeParameters = getTypeParameters();\n        List<TypeParameterDescriptor> substitutedTypeParameters = new ArrayList<TypeParameterDescriptor>(originalTypeParameters.size());\n        TypeSubstitutor substitutor = DescriptorSubstitutor.substituteTypeParameters(\n                originalTypeParameters, originalSubstitutor, substitutedDescriptor, substitutedTypeParameters\n        );\n\n        JetType substitutedReceiverParameterType = null;\n        if (extensionReceiverParameter != null) {\n            substitutedReceiverParameterType = substitutor.substitute(getExtensionReceiverParameter().getType(), Variance.IN_VARIANCE);\n            if (substitutedReceiverParameterType == null) {\n                return null;\n            }\n        }\n\n        ReceiverParameterDescriptor substitutedExpectedThis = null;\n        if (dispatchReceiverParameter != null) {\n            // When generating fake-overridden member it's dispatch receiver parameter has type of Base, and it's correct.\n            // E.g.\n            // class Base { fun foo() }\n            // class Derived : Base\n            // val x: Base\n            // if (x is Derived) {\n            //    // `x` shouldn't be marked as smart-cast\n            //    // but it would if fake-overridden `foo` had `Derived` as it's dispatch receiver parameter type\n            //    x.foo()\n            // }\n            substitutedExpectedThis = dispatchReceiverParameter.substitute(substitutor);\n            if (substitutedExpectedThis == null) {\n                return null;\n            }\n        }\n\n        List<ValueParameterDescriptor> substitutedValueParameters = getSubstitutedValueParameters(substitutedDescriptor, this, substitutor);\n        if (substitutedValueParameters == null) {\n            return null;\n        }\n\n        JetType substitutedReturnType = substitutor.substitute(getReturnType(), Variance.OUT_VARIANCE);\n        if (substitutedReturnType == null) {\n            return null;\n        }\n\n        substitutedDescriptor.initialize(\n                substitutedReceiverParameterType,\n                substitutedExpectedThis,\n                substitutedTypeParameters,\n                substitutedValueParameters,\n                substitutedReturnType,\n                newModality,\n                newVisibility\n        );\n        if (copyOverrides) {\n            for (FunctionDescriptor overriddenFunction : overriddenFunctions) {\n                OverridingUtil.bindOverride(substitutedDescriptor, overriddenFunction.substitute(substitutor));\n            }\n        }\n        return substitutedDescriptor;\n    }","id":35165,"modified_method":"@Nullable\n    protected FunctionDescriptor doSubstitute(@NotNull TypeSubstitutor originalSubstitutor,\n            @NotNull DeclarationDescriptor newOwner,\n            @NotNull Modality newModality,\n            @NotNull Visibility newVisibility,\n            @Nullable FunctionDescriptor original,\n            boolean copyOverrides,\n            @NotNull Kind kind\n    ) {\n        return doSubstitute(originalSubstitutor,\n                newOwner, newModality, newVisibility, original, copyOverrides, kind,\n                getValueParameters(), getExtensionReceiverParameterType(), getReturnType()\n        );\n    }","commit_id":"c01c59d562b6051d6d1a6ba2eed1b7fd08fddbc9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public static List<ValueParameterDescriptor> getSubstitutedValueParameters(FunctionDescriptor substitutedDescriptor, @NotNull FunctionDescriptor functionDescriptor, @NotNull TypeSubstitutor substitutor) {\n        List<ValueParameterDescriptor> result = new ArrayList<ValueParameterDescriptor>();\n        List<ValueParameterDescriptor> unsubstitutedValueParameters = functionDescriptor.getValueParameters();\n        for (ValueParameterDescriptor unsubstitutedValueParameter : unsubstitutedValueParameters) {\n            // TODO : Lazy?\n            JetType substitutedType = substitutor.substitute(unsubstitutedValueParameter.getType(), Variance.IN_VARIANCE);\n            JetType varargElementType = unsubstitutedValueParameter.getVarargElementType();\n            JetType substituteVarargElementType = varargElementType == null ? null : substitutor.substitute(varargElementType, Variance.IN_VARIANCE);\n            if (substitutedType == null) return null;\n            result.add(new ValueParameterDescriptorImpl(\n                    substitutedDescriptor,\n                    unsubstitutedValueParameter,\n                    unsubstitutedValueParameter.getIndex(),\n                    unsubstitutedValueParameter.getAnnotations(),\n                    unsubstitutedValueParameter.getName(),\n                    substitutedType,\n                    unsubstitutedValueParameter.declaresDefaultValue(),\n                    substituteVarargElementType,\n                    SourceElement.NO_SOURCE\n                    )\n            );\n        }\n        return result;\n    }","id":35166,"modified_method":"@Nullable\n    public static List<ValueParameterDescriptor> getSubstitutedValueParameters(\n            FunctionDescriptor substitutedDescriptor,\n            @NotNull List<ValueParameterDescriptor> unsubstitutedValueParameters,\n            @NotNull TypeSubstitutor substitutor\n    ) {\n        List<ValueParameterDescriptor> result = new ArrayList<ValueParameterDescriptor>();\n        for (ValueParameterDescriptor unsubstitutedValueParameter : unsubstitutedValueParameters) {\n            // TODO : Lazy?\n            JetType substitutedType = substitutor.substitute(unsubstitutedValueParameter.getType(), Variance.IN_VARIANCE);\n            JetType varargElementType = unsubstitutedValueParameter.getVarargElementType();\n            JetType substituteVarargElementType = varargElementType == null ? null : substitutor.substitute(varargElementType, Variance.IN_VARIANCE);\n            if (substitutedType == null) return null;\n            result.add(new ValueParameterDescriptorImpl(\n                    substitutedDescriptor,\n                    unsubstitutedValueParameter,\n                    unsubstitutedValueParameter.getIndex(),\n                    unsubstitutedValueParameter.getAnnotations(),\n                    unsubstitutedValueParameter.getName(),\n                    substitutedType,\n                    unsubstitutedValueParameter.declaresDefaultValue(),\n                    substituteVarargElementType,\n                    SourceElement.NO_SOURCE\n                    )\n            );\n        }\n        return result;\n    }","commit_id":"c01c59d562b6051d6d1a6ba2eed1b7fd08fddbc9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    @NotNull\n    public JavaMethodDescriptor enhance(\n            @Nullable JetType enhancedReceiverType,\n            @NotNull List<JetType> enhancedValueParametersTypes,\n            @NotNull JetType enhancedReturnType\n    ) {\n        JavaMethodDescriptor enhancedMethod = createSubstitutedCopy(getContainingDeclaration(), getOriginal(), getKind());\n        enhancedMethod.initialize(\n                enhancedReceiverType,\n                getDispatchReceiverParameter(),\n                getTypeParameters(),\n                DescriptorsPackage.createEnhancedValueParameters(enhancedValueParametersTypes, getValueParameters(), enhancedMethod),\n                enhancedReturnType,\n                getModality(),\n                getVisibility()\n        );\n        for (FunctionDescriptor overridden : getOverriddenDescriptors()) {\n            enhancedMethod.addOverriddenDescriptor(overridden);\n        }\n\n        return enhancedMethod;\n    }","id":35167,"modified_method":"@Override\n    @NotNull\n    public JavaMethodDescriptor enhance(\n            @Nullable JetType enhancedReceiverType,\n            @NotNull List<JetType> enhancedValueParametersTypes,\n            @NotNull JetType enhancedReturnType\n    ) {\n        List<ValueParameterDescriptor> enhancedValueParameters =\n                DescriptorsPackage.createEnhancedValueParameters(enhancedValueParametersTypes, getValueParameters(), this);\n\n        // We use `doSubstitute` here because it does exactly what we need:\n        // 1. creates full copy of descriptor\n        // 2. copies method's type parameters (with new containing declaration) and properly substitute to them in value parameters, return type and etc.\n        JavaMethodDescriptor enhancedMethod = (JavaMethodDescriptor) doSubstitute(\n                TypeSubstitutor.EMPTY, getContainingDeclaration(), getModality(), getVisibility(), getOriginal(),\n                /* copyOverrides = */ false, getKind(),\n                enhancedValueParameters, enhancedReceiverType, enhancedReturnType\n        );\n\n        assert enhancedMethod != null : \"null after substitution while enhancing \" + toString();\n\n        for (FunctionDescriptor overridden : getOverriddenDescriptors()) {\n            enhancedMethod.addOverriddenDescriptor(overridden);\n        }\n\n        return enhancedMethod;\n    }","commit_id":"c01c59d562b6051d6d1a6ba2eed1b7fd08fddbc9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private PropertyDescriptor doSubstitute(\n            @NotNull TypeSubstitutor originalSubstitutor,\n            @NotNull DeclarationDescriptor newOwner,\n            @NotNull Modality newModality,\n            @NotNull Visibility newVisibility,\n            @Nullable PropertyDescriptor original,\n            boolean copyOverrides,\n            @NotNull Kind kind\n    ) {\n        PropertyDescriptorImpl substitutedDescriptor = createSubstitutedCopy(newOwner, newModality, newVisibility, original, kind);\n\n        List<TypeParameterDescriptor> originalTypeParameters = getTypeParameters();\n        List<TypeParameterDescriptor> substitutedTypeParameters = new ArrayList<TypeParameterDescriptor>(originalTypeParameters.size());\n        TypeSubstitutor substitutor = DescriptorSubstitutor.substituteTypeParameters(\n                originalTypeParameters, originalSubstitutor, substitutedDescriptor, substitutedTypeParameters\n        );\n\n        JetType originalOutType = getType();\n        JetType outType = substitutor.substitute(originalOutType, Variance.OUT_VARIANCE);\n        if (outType == null) {\n            return null; // TODO : tell the user that the property was projected out\n        }\n\n\n        ReceiverParameterDescriptor substitutedDispatchReceiver;\n        ReceiverParameterDescriptor dispatchReceiver = getDispatchReceiverParameter();\n        if (dispatchReceiver != null) {\n            substitutedDispatchReceiver = dispatchReceiver.substitute(substitutor);\n            if (substitutedDispatchReceiver == null) return null;\n        }\n        else {\n            substitutedDispatchReceiver = null;\n        }\n\n        JetType substitutedReceiverType;\n        if (extensionReceiverParameter != null) {\n            substitutedReceiverType = substitutor.substitute(extensionReceiverParameter.getType(), Variance.IN_VARIANCE);\n            if (substitutedReceiverType == null) return null;\n        }\n        else {\n            substitutedReceiverType = null;\n        }\n\n        substitutedDescriptor.setType(outType, substitutedTypeParameters, substitutedDispatchReceiver, substitutedReceiverType);\n\n        PropertyGetterDescriptorImpl newGetter = getter == null ? null : new PropertyGetterDescriptorImpl(\n                substitutedDescriptor, getter.getAnnotations(), newModality, convertVisibility(getter.getVisibility(), newVisibility),\n                getter.hasBody(), getter.isDefault(), kind, original == null ? null : original.getGetter(), SourceElement.NO_SOURCE\n        );\n        if (newGetter != null) {\n            JetType returnType = getter.getReturnType();\n            newGetter.initialize(returnType != null ? substitutor.substitute(returnType, Variance.OUT_VARIANCE) : null);\n        }\n        PropertySetterDescriptorImpl newSetter = setter == null ? null : new PropertySetterDescriptorImpl(\n                substitutedDescriptor, setter.getAnnotations(), newModality, convertVisibility(setter.getVisibility(), newVisibility),\n                setter.hasBody(), setter.isDefault(), kind, original == null ? null : original.getSetter(), SourceElement.NO_SOURCE\n        );\n        if (newSetter != null) {\n            List<ValueParameterDescriptor> substitutedValueParameters = FunctionDescriptorImpl.getSubstitutedValueParameters(newSetter, setter, substitutor);\n            if (substitutedValueParameters == null) {\n                // The setter is projected out, e.g. in this case:\n                //     trait Tr<T> { var v: T }\n                //     fun test(tr: Tr<out Any?>) { ... }\n                // we want to tell the user that although the property is declared as a var,\n                // it can not be assigned to because of the projection\n                substitutedDescriptor.setSetterProjectedOut(true);\n                substitutedValueParameters = Collections.<ValueParameterDescriptor>singletonList(\n                        PropertySetterDescriptorImpl.createSetterParameter(newSetter, getBuiltIns(newOwner).getNothingType())\n                );\n            }\n            if (substitutedValueParameters.size() != 1) {\n                throw new IllegalStateException();\n            }\n            newSetter.initialize(substitutedValueParameters.get(0));\n        }\n\n        substitutedDescriptor.initialize(newGetter, newSetter);\n\n        if (copyOverrides) {\n            for (PropertyDescriptor propertyDescriptor : overriddenProperties) {\n                OverridingUtil.bindOverride(substitutedDescriptor, propertyDescriptor.substitute(substitutor));\n            }\n        }\n\n        return substitutedDescriptor;\n    }","id":35168,"modified_method":"@Nullable\n    private PropertyDescriptor doSubstitute(\n            @NotNull TypeSubstitutor originalSubstitutor,\n            @NotNull DeclarationDescriptor newOwner,\n            @NotNull Modality newModality,\n            @NotNull Visibility newVisibility,\n            @Nullable PropertyDescriptor original,\n            boolean copyOverrides,\n            @NotNull Kind kind\n    ) {\n        PropertyDescriptorImpl substitutedDescriptor = createSubstitutedCopy(newOwner, newModality, newVisibility, original, kind);\n\n        List<TypeParameterDescriptor> originalTypeParameters = getTypeParameters();\n        List<TypeParameterDescriptor> substitutedTypeParameters = new ArrayList<TypeParameterDescriptor>(originalTypeParameters.size());\n        TypeSubstitutor substitutor = DescriptorSubstitutor.substituteTypeParameters(\n                originalTypeParameters, originalSubstitutor, substitutedDescriptor, substitutedTypeParameters\n        );\n\n        JetType originalOutType = getType();\n        JetType outType = substitutor.substitute(originalOutType, Variance.OUT_VARIANCE);\n        if (outType == null) {\n            return null; // TODO : tell the user that the property was projected out\n        }\n\n\n        ReceiverParameterDescriptor substitutedDispatchReceiver;\n        ReceiverParameterDescriptor dispatchReceiver = getDispatchReceiverParameter();\n        if (dispatchReceiver != null) {\n            substitutedDispatchReceiver = dispatchReceiver.substitute(substitutor);\n            if (substitutedDispatchReceiver == null) return null;\n        }\n        else {\n            substitutedDispatchReceiver = null;\n        }\n\n        JetType substitutedReceiverType;\n        if (extensionReceiverParameter != null) {\n            substitutedReceiverType = substitutor.substitute(extensionReceiverParameter.getType(), Variance.IN_VARIANCE);\n            if (substitutedReceiverType == null) return null;\n        }\n        else {\n            substitutedReceiverType = null;\n        }\n\n        substitutedDescriptor.setType(outType, substitutedTypeParameters, substitutedDispatchReceiver, substitutedReceiverType);\n\n        PropertyGetterDescriptorImpl newGetter = getter == null ? null : new PropertyGetterDescriptorImpl(\n                substitutedDescriptor, getter.getAnnotations(), newModality, convertVisibility(getter.getVisibility(), newVisibility),\n                getter.hasBody(), getter.isDefault(), kind, original == null ? null : original.getGetter(), SourceElement.NO_SOURCE\n        );\n        if (newGetter != null) {\n            JetType returnType = getter.getReturnType();\n            newGetter.initialize(returnType != null ? substitutor.substitute(returnType, Variance.OUT_VARIANCE) : null);\n        }\n        PropertySetterDescriptorImpl newSetter = setter == null ? null : new PropertySetterDescriptorImpl(\n                substitutedDescriptor, setter.getAnnotations(), newModality, convertVisibility(setter.getVisibility(), newVisibility),\n                setter.hasBody(), setter.isDefault(), kind, original == null ? null : original.getSetter(), SourceElement.NO_SOURCE\n        );\n        if (newSetter != null) {\n            List<ValueParameterDescriptor> substitutedValueParameters = FunctionDescriptorImpl.getSubstitutedValueParameters(\n                    newSetter, setter.getValueParameters(), substitutor\n            );\n            if (substitutedValueParameters == null) {\n                // The setter is projected out, e.g. in this case:\n                //     trait Tr<T> { var v: T }\n                //     fun test(tr: Tr<out Any?>) { ... }\n                // we want to tell the user that although the property is declared as a var,\n                // it can not be assigned to because of the projection\n                substitutedDescriptor.setSetterProjectedOut(true);\n                substitutedValueParameters = Collections.<ValueParameterDescriptor>singletonList(\n                        PropertySetterDescriptorImpl.createSetterParameter(newSetter, getBuiltIns(newOwner).getNothingType())\n                );\n            }\n            if (substitutedValueParameters.size() != 1) {\n                throw new IllegalStateException();\n            }\n            newSetter.initialize(substitutedValueParameters.get(0));\n        }\n\n        substitutedDescriptor.initialize(newGetter, newSetter);\n\n        if (copyOverrides) {\n            for (PropertyDescriptor propertyDescriptor : overriddenProperties) {\n                OverridingUtil.bindOverride(substitutedDescriptor, propertyDescriptor.substitute(substitutor));\n            }\n        }\n\n        return substitutedDescriptor;\n    }","commit_id":"c01c59d562b6051d6d1a6ba2eed1b7fd08fddbc9","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static boolean isSubtypeOfClass(@NotNull JetType type, @NotNull DeclarationDescriptor superClass) {\n        DeclarationDescriptor descriptor = type.getConstructor().getDeclarationDescriptor();\n        if (descriptor != null && superClass == descriptor.getOriginal()) {\n            return true;\n        }\n        for (JetType superType : type.getConstructor().getSupertypes()) {\n            if (isSubtypeOfClass(superType, superClass)) {\n                return true;\n            }\n        }\n        return false;\n    }","id":35169,"modified_method":"private static boolean isSubtypeOfClass(@NotNull JetType type, @NotNull DeclarationDescriptor superClass) {\n        DeclarationDescriptor descriptor = type.getConstructor().getDeclarationDescriptor();\n        if (descriptor != null) {\n            DeclarationDescriptor originalDescriptor = descriptor.getOriginal();\n            if (originalDescriptor instanceof ClassifierDescriptor\n                     && superClass instanceof ClassifierDescriptor\n                     && ((ClassifierDescriptor) superClass).getTypeConstructor().equals(((ClassifierDescriptor) originalDescriptor).getTypeConstructor())) {\n                return true;\n            }\n        }\n\n        for (JetType superType : type.getConstructor().getSupertypes()) {\n            if (isSubtypeOfClass(superType, superClass)) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"53a1abf2e6a195b792cfd37c96ed454a7951dcd8","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/** the constructor */\n    public DataResultFilterNode(Node node, ExplorerManager em) {\n        super(node, new DataResultFilterChildren(node, em));\n        this.sourceEm = em;\n        getActionsDIV = new GetPopupActionsDisplayableItemVisitor();\n        getPreferredActionsDIV = new GetPreferredActionsDisplayableItemNodeVisitor();\n    }","id":35170,"modified_method":"/** the constructor */\n    public DataResultFilterNode(Node node, ExplorerManager em) {\n        super(node, new DataResultFilterChildren(node, em));\n        this.sourceEm = em;\n        getActionsDIV = new GetPopupActionsDisplayableItemNodeVisitor();\n        getPreferredActionsDIV = new GetPreferredActionsDisplayableItemNodeVisitor();\n    }","commit_id":"91fca6db73499dd6a93e6f8c83cc110a0f978902","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * Right click action for the nodes that we want to pass to the directory\n     * table and the output view.\n     *\n     * @param popup\n     * @return actions\n     */\n    @Override\n    public Action[] getActions(boolean popup) {\n\n        List<Action> actions = new ArrayList<Action>();\n        \n        DisplayableItem nodeItem = this.getOriginal().getLookup().lookup(DisplayableItem.class);\n        actions.addAll(nodeItem.accept(getActionsDIV));\n        \n        //actions.add(new IndexContentFilesAction(nodeContent, \"Index\"));\n\n        return actions.toArray(new Action[actions.size()]);\n    }","id":35171,"modified_method":"/**\n     * Right click action for the nodes that we want to pass to the directory\n     * table and the output view.\n     *\n     * @param popup\n     * @return actions\n     */\n    @Override\n    public Action[] getActions(boolean popup) {\n\n        List<Action> actions = new ArrayList<Action>();\n        \n        final DisplayableItemNode originalNode = (DisplayableItemNode) this.getOriginal();\n        actions.addAll(originalNode.accept(getActionsDIV));\n        \n        //actions.add(new IndexContentFilesAction(nodeContent, \"Index\"));\n\n        return actions.toArray(new Action[actions.size()]);\n    }","commit_id":"91fca6db73499dd6a93e6f8c83cc110a0f978902","url":"https://github.com/sleuthkit/autopsy"},{"original_method":"/**\n     * @return true iff a given function descriptor should be compiled to a method with boxed return type regardless of whether return type\n     * of that descriptor is nullable or not. This happens when a function returning a value of a primitive type overrides another function\n     * with a non-primitive return type. In that case the generated method's return type should be boxed: otherwise it's not possible to use\n     * this class from Java since javac issues errors when loading the class (incompatible return types)\n     */\n    private static boolean forceBoxedReturnType(@NotNull FunctionDescriptor descriptor) {\n        //noinspection ConstantConditions\n        if (!KotlinBuiltIns.getInstance().isPrimitiveType(descriptor.getReturnType())) return false;\n\n        for (FunctionDescriptor overridden : descriptor.getOverriddenDescriptors()) {\n            //noinspection ConstantConditions\n            if (!KotlinBuiltIns.getInstance().isPrimitiveType(overridden.getOriginal().getReturnType())) return true;\n        }\n\n        return false;\n    }","id":35172,"modified_method":"/**\n     * @return true iff a given function descriptor should be compiled to a method with boxed return type regardless of whether return type\n     * of that descriptor is nullable or not. This happens when a function returning a value of a primitive type overrides another function\n     * with a non-primitive return type. In that case the generated method's return type should be boxed: otherwise it's not possible to use\n     * this class from Java since javac issues errors when loading the class (incompatible return types)\n     */\n    private static boolean forceBoxedReturnType(@NotNull FunctionDescriptor descriptor) {\n        //noinspection ConstantConditions\n        if (!KotlinBuiltIns.getInstance().isPrimitiveType(descriptor.getReturnType())) return false;\n\n        for (FunctionDescriptor overridden : OverrideResolver.getAllOverriddenDescriptors(descriptor)) {\n            //noinspection ConstantConditions\n            if (!KotlinBuiltIns.getInstance().isPrimitiveType(overridden.getOriginal().getReturnType())) return true;\n        }\n\n        return false;\n    }","commit_id":"2b5bc6b63dda0c71f57d78d52cf94981f8ef5531","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static <D extends CallableDescriptor> boolean overrides(@NotNull D f, @NotNull D g) {\n        CallableDescriptor originalG = g.getOriginal();\n        for (CallableDescriptor overriddenFunction : getAllOverriddenDescriptors(f)) {\n            if (originalG.equals(overriddenFunction.getOriginal())) return true;\n        }\n        return false;\n    }","id":35173,"modified_method":"public static <D extends CallableDescriptor> boolean overrides(@NotNull D f, @NotNull D g) {\n        CallableDescriptor originalG = g.getOriginal();\n        for (D overriddenFunction : getAllOverriddenDescriptors(f)) {\n            if (originalG.equals(overriddenFunction.getOriginal())) return true;\n        }\n        return false;\n    }","commit_id":"2b5bc6b63dda0c71f57d78d52cf94981f8ef5531","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void collectAllOverriddenDescriptors(@NotNull CallableDescriptor current, @NotNull Set<CallableDescriptor> result) {\n        if (result.contains(current)) return;\n        for (CallableDescriptor descriptor : current.getOriginal().getOverriddenDescriptors()) {\n            collectAllOverriddenDescriptors(descriptor, result);\n            result.add(descriptor);\n        }\n    }","id":35174,"modified_method":"private static <D extends CallableDescriptor> void collectAllOverriddenDescriptors(@NotNull D current, @NotNull Set<D> result) {\n        if (result.contains(current)) return;\n        for (CallableDescriptor callableDescriptor : current.getOriginal().getOverriddenDescriptors()) {\n            @SuppressWarnings(\"unchecked\")\n            D descriptor = (D) callableDescriptor;\n            collectAllOverriddenDescriptors(descriptor, result);\n            result.add(descriptor);\n        }\n    }","commit_id":"2b5bc6b63dda0c71f57d78d52cf94981f8ef5531","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public static Set<CallableDescriptor> getAllOverriddenDescriptors(@NotNull CallableDescriptor f) {\n        Set<CallableDescriptor> result = new LinkedHashSet<CallableDescriptor>();\n        collectAllOverriddenDescriptors(f.getOriginal(), result);\n        return result;\n    }","id":35175,"modified_method":"@NotNull\n    @SuppressWarnings(\"unchecked\")\n    public static <D extends CallableDescriptor> Set<D> getAllOverriddenDescriptors(@NotNull D f) {\n        Set<D> result = new LinkedHashSet<D>();\n        collectAllOverriddenDescriptors((D) f.getOriginal(), result);\n        return result;\n    }","commit_id":"2b5bc6b63dda0c71f57d78d52cf94981f8ef5531","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  private static Couple<Map<String, Color>> computeBgColors(@NotNull FileAnnotation fileAnnotation) {\n    final Map<String, Color> commitOrderColors = new HashMap<String, Color>();\n    final Map<String, Color> commitAuthorColors = new HashMap<String, Color>();\n    final Map<String, Color> authorColors = new HashMap<String, Color>();\n    final List<VcsFileRevision> fileRevisionList = fileAnnotation.getRevisions();\n    if (fileRevisionList != null) {\n      final int colorsCount = BG_COLORS.length;\n      final int revisionsCount = fileRevisionList.size();\n\n      for (int i = 0; i < fileRevisionList.size(); i++) {\n        VcsFileRevision revision = fileRevisionList.get(i);\n        final String number = revision.getRevisionNumber().asString();\n        final String author = revision.getAuthor();\n        if (number == null) continue;\n\n        if (!commitAuthorColors.containsKey(number)) {\n          if (author != null && !authorColors.containsKey(author)) {\n            final int index = authorColors.size();\n            Color color = BG_COLORS[index * BG_COLORS_PRIME % colorsCount];\n            authorColors.put(author, color);\n          }\n\n          commitAuthorColors.put(number, authorColors.get(author));\n        }\n        if (!commitOrderColors.containsKey(number)) {\n          Color color = BG_COLORS[colorsCount * i / revisionsCount];\n          commitOrderColors.put(number, color);\n        }\n      }\n    }\n    return Couple.of(commitOrderColors.size() > 1 ? commitOrderColors : null,\n                     commitAuthorColors.size() > 1 ? commitAuthorColors : null);\n  }","id":35176,"modified_method":"@NotNull\n  private static Couple<Map<VcsRevisionNumber, Color>> computeBgColors(@NotNull FileAnnotation fileAnnotation) {\n    final Map<VcsRevisionNumber, Color> commitOrderColors = new HashMap<VcsRevisionNumber, Color>();\n    final Map<VcsRevisionNumber, Color> commitAuthorColors = new HashMap<VcsRevisionNumber, Color>();\n    final Map<String, Color> authorColors = new HashMap<String, Color>();\n    final List<VcsFileRevision> fileRevisionList = fileAnnotation.getRevisions();\n    if (fileRevisionList != null) {\n      final int colorsCount = BG_COLORS.length;\n      final int revisionsCount = fileRevisionList.size();\n\n      for (int i = 0; i < fileRevisionList.size(); i++) {\n        VcsFileRevision revision = fileRevisionList.get(i);\n        final VcsRevisionNumber number = revision.getRevisionNumber();\n        final String author = revision.getAuthor();\n        if (number == null) continue;\n\n        if (!commitAuthorColors.containsKey(number)) {\n          if (author != null && !authorColors.containsKey(author)) {\n            final int index = authorColors.size();\n            Color color = BG_COLORS[index * BG_COLORS_PRIME % colorsCount];\n            authorColors.put(author, color);\n          }\n\n          commitAuthorColors.put(number, authorColors.get(author));\n        }\n        if (!commitOrderColors.containsKey(number)) {\n          Color color = BG_COLORS[colorsCount * i / revisionsCount];\n          commitOrderColors.put(number, color);\n        }\n      }\n    }\n    return Couple.of(commitOrderColors.size() > 1 ? commitOrderColors : null,\n                     commitAuthorColors.size() > 1 ? commitAuthorColors : null);\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doAnnotate(final Editor editor,\n                                final Project project,\n                                final VirtualFile file,\n                                final FileAnnotation fileAnnotation,\n                                final AbstractVcs vcs, final boolean onCurrentRevision) {\n    final UpToDateLineNumberProvider getUpToDateLineNumber = new UpToDateLineNumberProviderImpl(editor.getDocument(), project);\n    editor.getGutter().closeAllAnnotations();\n    final VcsAnnotationLocalChangesListener listener = ProjectLevelVcsManager.getInstance(project).getAnnotationLocalChangesListener();\n\n    fileAnnotation.setCloser(new Runnable() {\n      @Override\n      public void run() {\n        if (project.isDisposed()) return;\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            if (project.isDisposed()) return;\n            editor.getGutter().closeAllAnnotations();\n          }\n        });\n      }\n    });\n    if (onCurrentRevision) {\n      listener.registerAnnotation(file, fileAnnotation);\n    }\n\n    // be careful, not proxies but original items are put there (since only their presence not behaviour is important)\n    Collection<ActiveAnnotationGutter> annotations = editor.getUserData(KEY_IN_EDITOR);\n    if (annotations == null) {\n      annotations = new HashSet<ActiveAnnotationGutter>();\n      editor.putUserData(KEY_IN_EDITOR, annotations);\n    }\n\n    final EditorGutterComponentEx editorGutter = (EditorGutterComponentEx)editor.getGutter();\n    final List<AnnotationFieldGutter> gutters = new ArrayList<AnnotationFieldGutter>();\n    final AnnotationSourceSwitcher switcher = fileAnnotation.getAnnotationSourceSwitcher();\n    final List<AnAction> additionalActions = new ArrayList<AnAction>();\n    if (vcs.getCommittedChangesProvider() != null) {\n      additionalActions.add(new ShowDiffFromAnnotation(getUpToDateLineNumber, fileAnnotation, vcs, file));\n    }\n    additionalActions.add(new CopyRevisionNumberFromAnnotateAction(getUpToDateLineNumber, fileAnnotation));\n    final AnnotationPresentation presentation =\n      new AnnotationPresentation(fileAnnotation, switcher, editorGutter,\n                                 additionalActions.toArray(new AnAction[additionalActions.size()]));\n\n    final Couple<Map<String, Color>> bgColorMap = Registry.is(\"vcs.show.colored.annotations\") ? computeBgColors(fileAnnotation) : null;\n    final Map<String, Integer> historyIds = Registry.is(\"vcs.show.history.numbers\") ? computeLineNumbers(fileAnnotation) : null;\n\n    if (switcher != null) {\n      switcher.switchTo(switcher.getDefaultSource());\n      final LineAnnotationAspect revisionAspect = switcher.getRevisionAspect();\n      final CurrentRevisionAnnotationFieldGutter currentRevisionGutter =\n        new CurrentRevisionAnnotationFieldGutter(fileAnnotation, editor, revisionAspect, presentation, bgColorMap);\n      final MergeSourceAvailableMarkerGutter mergeSourceGutter =\n        new MergeSourceAvailableMarkerGutter(fileAnnotation, editor, null, presentation, bgColorMap);\n\n      presentation.addSourceSwitchListener(currentRevisionGutter);\n      presentation.addSourceSwitchListener(mergeSourceGutter);\n\n      currentRevisionGutter.consume(switcher.getDefaultSource());\n      mergeSourceGutter.consume(switcher.getDefaultSource());\n\n      gutters.add(currentRevisionGutter);\n      gutters.add(mergeSourceGutter);\n    }\n\n    final LineAnnotationAspect[] aspects = fileAnnotation.getAspects();\n    for (LineAnnotationAspect aspect : aspects) {\n      gutters.add(new AnnotationFieldGutter(fileAnnotation, editor, aspect, presentation, bgColorMap));\n    }\n\n\n    if (historyIds != null) {\n      gutters.add(new HistoryIdColumn(fileAnnotation, editor, presentation, bgColorMap, historyIds));\n    }\n    gutters.add(new HighlightedAdditionalColumn(fileAnnotation, editor, null, presentation, bgColorMap));\n    final AnnotateActionGroup actionGroup = new AnnotateActionGroup(gutters, editorGutter);\n    presentation.addAction(actionGroup, 1);\n    gutters.add(new ExtraFieldGutter(fileAnnotation, editor, presentation, bgColorMap, actionGroup));\n\n    presentation.addAction(new AnnotateCurrentRevisionAction(fileAnnotation, vcs));\n    presentation.addAction(new AnnotatePreviousRevisionAction(fileAnnotation, vcs));\n    addActionsFromExtensions(presentation, fileAnnotation);\n\n    for (AnAction action : presentation.getActions()) {\n      if (action instanceof LineNumberListener) {\n        presentation.addLineNumberListener((LineNumberListener)action);\n      }\n    }\n\n    for (AnnotationFieldGutter gutter : gutters) {\n      final AnnotationGutterLineConvertorProxy proxy = new AnnotationGutterLineConvertorProxy(getUpToDateLineNumber, gutter);\n      if (gutter.isGutterAction()) {\n        editor.getGutter().registerTextAnnotation(proxy, proxy);\n      }\n      else {\n        editor.getGutter().registerTextAnnotation(proxy);\n      }\n      annotations.add(gutter);\n    }\n  }","id":35177,"modified_method":"public static void doAnnotate(final Editor editor,\n                                final Project project,\n                                final VirtualFile file,\n                                final FileAnnotation fileAnnotation,\n                                final AbstractVcs vcs, final boolean onCurrentRevision) {\n    final UpToDateLineNumberProvider getUpToDateLineNumber = new UpToDateLineNumberProviderImpl(editor.getDocument(), project);\n    editor.getGutter().closeAllAnnotations();\n    final VcsAnnotationLocalChangesListener listener = ProjectLevelVcsManager.getInstance(project).getAnnotationLocalChangesListener();\n\n    fileAnnotation.setCloser(new Runnable() {\n      @Override\n      public void run() {\n        if (project.isDisposed()) return;\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            if (project.isDisposed()) return;\n            editor.getGutter().closeAllAnnotations();\n          }\n        });\n      }\n    });\n    if (onCurrentRevision) {\n      listener.registerAnnotation(file, fileAnnotation);\n    }\n\n    // be careful, not proxies but original items are put there (since only their presence not behaviour is important)\n    Collection<ActiveAnnotationGutter> annotations = editor.getUserData(KEY_IN_EDITOR);\n    if (annotations == null) {\n      annotations = new HashSet<ActiveAnnotationGutter>();\n      editor.putUserData(KEY_IN_EDITOR, annotations);\n    }\n\n    final EditorGutterComponentEx editorGutter = (EditorGutterComponentEx)editor.getGutter();\n    final List<AnnotationFieldGutter> gutters = new ArrayList<AnnotationFieldGutter>();\n    final AnnotationSourceSwitcher switcher = fileAnnotation.getAnnotationSourceSwitcher();\n    final List<AnAction> additionalActions = new ArrayList<AnAction>();\n    if (vcs.getCommittedChangesProvider() != null) {\n      additionalActions.add(new ShowDiffFromAnnotation(getUpToDateLineNumber, fileAnnotation, vcs, file));\n    }\n    additionalActions.add(new CopyRevisionNumberFromAnnotateAction(getUpToDateLineNumber, fileAnnotation));\n    final AnnotationPresentation presentation =\n      new AnnotationPresentation(fileAnnotation, switcher, editorGutter,\n                                 additionalActions.toArray(new AnAction[additionalActions.size()]));\n\n    final Couple<Map<VcsRevisionNumber, Color>> bgColorMap =\n      Registry.is(\"vcs.show.colored.annotations\") ? computeBgColors(fileAnnotation) : null;\n    final Map<String, Integer> historyIds = Registry.is(\"vcs.show.history.numbers\") ? computeLineNumbers(fileAnnotation) : null;\n\n    if (switcher != null) {\n      switcher.switchTo(switcher.getDefaultSource());\n      final LineAnnotationAspect revisionAspect = switcher.getRevisionAspect();\n      final CurrentRevisionAnnotationFieldGutter currentRevisionGutter =\n        new CurrentRevisionAnnotationFieldGutter(fileAnnotation, editor, revisionAspect, presentation, bgColorMap);\n      final MergeSourceAvailableMarkerGutter mergeSourceGutter =\n        new MergeSourceAvailableMarkerGutter(fileAnnotation, editor, null, presentation, bgColorMap);\n\n      presentation.addSourceSwitchListener(currentRevisionGutter);\n      presentation.addSourceSwitchListener(mergeSourceGutter);\n\n      currentRevisionGutter.consume(switcher.getDefaultSource());\n      mergeSourceGutter.consume(switcher.getDefaultSource());\n\n      gutters.add(currentRevisionGutter);\n      gutters.add(mergeSourceGutter);\n    }\n\n    final LineAnnotationAspect[] aspects = fileAnnotation.getAspects();\n    for (LineAnnotationAspect aspect : aspects) {\n      gutters.add(new AnnotationFieldGutter(fileAnnotation, editor, aspect, presentation, bgColorMap));\n    }\n\n\n    if (historyIds != null) {\n      gutters.add(new HistoryIdColumn(fileAnnotation, editor, presentation, bgColorMap, historyIds));\n    }\n    gutters.add(new HighlightedAdditionalColumn(fileAnnotation, editor, null, presentation, bgColorMap));\n    final AnnotateActionGroup actionGroup = new AnnotateActionGroup(gutters, editorGutter);\n    presentation.addAction(actionGroup, 1);\n    gutters.add(new ExtraFieldGutter(fileAnnotation, editor, presentation, bgColorMap, actionGroup));\n\n    presentation.addAction(new AnnotateCurrentRevisionAction(fileAnnotation, vcs));\n    presentation.addAction(new AnnotatePreviousRevisionAction(fileAnnotation, vcs));\n    addActionsFromExtensions(presentation, fileAnnotation);\n\n    for (AnAction action : presentation.getActions()) {\n      if (action instanceof LineNumberListener) {\n        presentation.addLineNumberListener((LineNumberListener)action);\n      }\n    }\n\n    for (AnnotationFieldGutter gutter : gutters) {\n      final AnnotationGutterLineConvertorProxy proxy = new AnnotationGutterLineConvertorProxy(getUpToDateLineNumber, gutter);\n      if (gutter.isGutterAction()) {\n        editor.getGutter().registerTextAnnotation(proxy, proxy);\n      }\n      else {\n        editor.getGutter().registerTextAnnotation(proxy);\n      }\n      annotations.add(gutter);\n    }\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public Color getBgColor(int line, Editor editor) {\n    ColorMode type = ShowAnnotationColorsAction.getType();\n    Map<String, Color> colorMap = type == ColorMode.AUTHOR ? myColorScheme.second : myColorScheme.first;\n    if (colorMap == null || type == ColorMode.NONE) return null;\n    final VcsRevisionNumber number = myAnnotation.getLineRevisionNumber(line);\n    if (number == null) return null;\n    return colorMap.get(number.asString());\n  }","id":35178,"modified_method":"@Nullable\n  public Color getBgColor(int line, Editor editor) {\n    ColorMode type = ShowAnnotationColorsAction.getType();\n    Map<VcsRevisionNumber, Color> colorMap = type == ColorMode.AUTHOR ? myColorScheme.second : myColorScheme.first;\n    if (colorMap == null || type == ColorMode.NONE) return null;\n    final VcsRevisionNumber number = myAnnotation.getLineRevisionNumber(line);\n    if (number == null) return null;\n    return colorMap.get(number);\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"AnnotationFieldGutter(FileAnnotation annotation,\n                        Editor editor,\n                        LineAnnotationAspect aspect,\n                        final TextAnnotationPresentation presentation,\n                        Couple<Map<String, Color>> colorScheme) {\n    myAnnotation = annotation;\n    myEditor = editor;\n    myAspect = aspect;\n    myPresentation = presentation;\n    myIsGutterAction = myAspect instanceof EditorGutterAction;\n    myColorScheme = colorScheme;\n  }","id":35179,"modified_method":"AnnotationFieldGutter(FileAnnotation annotation,\n                        Editor editor,\n                        LineAnnotationAspect aspect,\n                        final TextAnnotationPresentation presentation,\n                        Couple<Map<VcsRevisionNumber, Color>> colorScheme) {\n    myAnnotation = annotation;\n    myEditor = editor;\n    myAspect = aspect;\n    myPresentation = presentation;\n    myIsGutterAction = myAspect instanceof EditorGutterAction;\n    myColorScheme = colorScheme;\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"CurrentRevisionAnnotationFieldGutter(FileAnnotation annotation,\n                                       Editor editor,\n                                       LineAnnotationAspect aspect,\n                                       TextAnnotationPresentation highlighting,\n                                       Couple<Map<String, Color>> colorScheme) {\n    super(annotation, editor, aspect, highlighting, colorScheme);\n  }","id":35180,"modified_method":"CurrentRevisionAnnotationFieldGutter(FileAnnotation annotation,\n                                       Editor editor,\n                                       LineAnnotationAspect aspect,\n                                       TextAnnotationPresentation highlighting,\n                                       Couple<Map<VcsRevisionNumber, Color>> colorScheme) {\n    super(annotation, editor, aspect, highlighting, colorScheme);\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ExtraFieldGutter(FileAnnotation fileAnnotation,\n                          Editor editor,\n                          AnnotationPresentation presentation,\n                          Couple<Map<String, Color>> bgColorMap, AnnotateActionGroup actionGroup) {\n    super(fileAnnotation, editor, null, presentation, bgColorMap);\n    myActionGroup = actionGroup;\n  }","id":35181,"modified_method":"public ExtraFieldGutter(FileAnnotation fileAnnotation,\n                          Editor editor,\n                          AnnotationPresentation presentation,\n                          Couple<Map<VcsRevisionNumber, Color>> bgColorMap, AnnotateActionGroup actionGroup) {\n    super(fileAnnotation, editor, null, presentation, bgColorMap);\n    myActionGroup = actionGroup;\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(revision, changeset);\n  }","id":35182,"modified_method":"@Override\n  public int hashCode() {\n    // if short revision number is not empty, then short changeset is enough, a.e. annotations\n    return Objects.hashCode(revision, revision.isEmpty() ? changeset : getShortHash(changeset));\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int compareTo(VcsRevisionNumber o) {\n    // boundary cases\n    if (this == o) {\n      return 0;\n    }\n    if (!(o instanceof HgRevisionNumber)) {\n      return -1;\n    }\n    final HgRevisionNumber other = (HgRevisionNumber) o;\n    if (changeset.equals(other.changeset)) {\n      return 0;\n    }\n\n    // One of the revisions is local. Local is \"greater\" than any from the history.\n    if (changeset.isEmpty()) {\n      return 1;\n    }\n    if (other.changeset.isEmpty()) {\n      return -1;\n    }\n\n    // compare revision numbers.\n    final int revCompare = java.lang.Long.valueOf(getRevisionNumber()).compareTo(java.lang.Long.valueOf(other.getRevisionNumber()));\n    if (revCompare != 0) {\n      return revCompare;\n    }\n    // If they are equal, the working revision is greater.\n    if (isWorkingVersion) {\n      return other.isWorkingVersion ? 0 : 1;\n    } else {\n      return other.isWorkingVersion ? -1 : 0;\n    }\n  }","id":35183,"modified_method":"public int compareTo(VcsRevisionNumber o) {\n    // boundary cases\n    if (this == o) {\n      return 0;\n    }\n    if (!(o instanceof HgRevisionNumber)) {\n      return -1;\n    }\n    final HgRevisionNumber other = (HgRevisionNumber) o;\n    if (changeset.equals(other.changeset)) {\n      return 0;\n    }\n\n    // One of the revisions is local. Local is \"greater\" than any from the history.\n    if (changeset.isEmpty()) {\n      return 1;\n    }\n    if (other.changeset.isEmpty()) {\n      return -1;\n    }\n\n    // compare revision numbers.\n    final int revCompare = java.lang.Long.valueOf(getRevisionNumber()).compareTo(java.lang.Long.valueOf(other.getRevisionNumber()));\n    if (revCompare != 0) {\n      return revCompare;\n    }\n    else if (getShortHash(changeset).equals(getShortHash(other.changeset))) {\n      //if local revision numbers are equal then it's enough to compare 12 symbols hash; collisions couldn't occur\n      return 0;\n    }\n    // If they are equal, the working revision is greater.\n    if (isWorkingVersion) {\n      return other.isWorkingVersion ? 0 : 1;\n    } else {\n      return other.isWorkingVersion ? -1 : 0;\n    }\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"HighlightedAdditionalColumn(FileAnnotation annotation,\n                              Editor editor,\n                              LineAnnotationAspect aspect,\n                              TextAnnotationPresentation presentation,\n                              Couple<Map<String, Color>> colorScheme) {\n    super(annotation, editor, aspect, presentation, colorScheme);\n  }","id":35184,"modified_method":"HighlightedAdditionalColumn(FileAnnotation annotation,\n                              Editor editor,\n                              LineAnnotationAspect aspect,\n                              TextAnnotationPresentation presentation,\n                              Couple<Map<VcsRevisionNumber, Color>> colorScheme) {\n    super(annotation, editor, aspect, presentation, colorScheme);\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"HistoryIdColumn(FileAnnotation annotation,\n                  final Editor editor,\n                  final TextAnnotationPresentation presentation,\n                  Couple<Map<String, Color>> colorScheme,\n                  Map<String, Integer> ids) {\n    super(annotation, editor, null, presentation, colorScheme);\n    myHistoryIds = ids;\n  }","id":35185,"modified_method":"HistoryIdColumn(FileAnnotation annotation,\n                  final Editor editor,\n                  final TextAnnotationPresentation presentation,\n                  Couple<Map<VcsRevisionNumber, Color>> colorScheme,\n                  Map<String, Integer> ids) {\n    super(annotation, editor, null, presentation, colorScheme);\n    myHistoryIds = ids;\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"MergeSourceAvailableMarkerGutter(FileAnnotation annotation,\n                                   Editor editor,\n                                   LineAnnotationAspect aspect,\n                                   TextAnnotationPresentation highlighting,\n                                   Couple<Map<String, Color>> colorScheme) {\n    super(annotation, editor, aspect, highlighting, colorScheme);\n  }","id":35186,"modified_method":"MergeSourceAvailableMarkerGutter(FileAnnotation annotation,\n                                   Editor editor,\n                                   LineAnnotationAspect aspect,\n                                   TextAnnotationPresentation highlighting,\n                                   Couple<Map<VcsRevisionNumber, Color>> colorScheme) {\n    super(annotation, editor, aspect, highlighting, colorScheme);\n  }","commit_id":"59faf4f5588cff7ed09f9df01aa1d12848f64490","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getRevisionName(final ContentRevision revision, final File ioFile) {\n    String revisionName = revision.getRevisionNumber().asString();\n    if (revisionName.length() > 0) {\n      return MessageFormat.format(REVISION_NAME_TEMPLATE, revisionName);\n    }\n    return new Date(ioFile.lastModified()).toString();\n  }","id":35187,"modified_method":"private static String getRevisionName(final AirContentRevision revision) {\n    final String revisionName = revision.getRevisionNumber();\n    if (revisionName != null) {\n      return MessageFormat.format(REVISION_NAME_TEMPLATE, revisionName);\n    }\n    return new Date(revision.getPath().lastModified()).toString();\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TextFilePatch buildDeletedFile(String basePath, ContentRevision beforeRevision, final ProgressIndicator ind) throws VcsException {\n    final String content = beforeRevision.getContent();\n    if (content == null) {\n      throw new VcsException(\"Failed to fetch old content for deleted file \" + beforeRevision.getFile().getPath());\n    }\n    String[] lines = new LineTokenizer(content).execute();\n    TextFilePatch result = buildPatchHeading(basePath, beforeRevision, beforeRevision);\n    PatchHunk hunk = new PatchHunk(0, lines.length, -1, -1);\n    for(String line: lines) {\n      checkCanceled(ind);\n      addLineToHunk(hunk, line, PatchLine.Type.REMOVE);\n    }\n    result.addHunk(hunk);\n    return result;\n  }","id":35188,"modified_method":"private TextFilePatch buildDeletedFile(String basePath, AirContentRevision beforeRevision, final ProgressIndicator ind) throws VcsException {\n    final String content = beforeRevision.getContentAsString();\n    if (content == null) {\n      throw new VcsException(\"Failed to fetch old content for deleted file \" + beforeRevision.getPath());\n    }\n    String[] lines = new LineTokenizer(content).execute();\n    TextFilePatch result = buildPatchHeading(basePath, beforeRevision, beforeRevision);\n    PatchHunk hunk = new PatchHunk(0, lines.length, -1, -1);\n    for(String line: lines) {\n      checkCanceled(ind);\n      addLineToHunk(hunk, line, PatchLine.Type.REMOVE);\n    }\n    result.addHunk(hunk);\n    return result;\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getRelativePath(final String basePath, final File ioFile) {\n    String relPath = FileUtil.getRelativePath(new File(basePath), ioFile);\n    if (relPath == null) relPath = ioFile.getPath();\n    return relPath.replace(File.separatorChar, '/');\n  }","id":35189,"modified_method":"private String getRelativePath(final String basePath, final String secondPath) {\n    final String baseModified = FileUtil.toSystemIndependentName(basePath);\n    final String secondModified = FileUtil.toSystemIndependentName(secondPath);\n    \n    final String relPath = FileUtil.getRelativePath(baseModified, secondModified, '/', myIsCaseSensitive);\n    if (relPath == null) return secondModified;\n    return relPath;\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<FilePatch> buildPatch(final Collection<Change> changes, final String basePath, final boolean reversePatch) throws VcsException {\n    final ProgressIndicator ind = ProgressManager.getInstance().getProgressIndicator();\n    \n    List<FilePatch> result = new ArrayList<FilePatch>();\n    for(Change c: changes) {\n      checkCanceled(ind);\n\n      final ContentRevision beforeRevision;\n      final ContentRevision afterRevision;\n      if (reversePatch) {\n        beforeRevision = c.getAfterRevision();\n        afterRevision = c.getBeforeRevision();\n      }\n      else {\n        beforeRevision = c.getBeforeRevision();\n        afterRevision = c.getAfterRevision();\n      }\n      if (beforeRevision != null && beforeRevision.getFile().isDirectory()) {\n        continue;\n      }\n      if (afterRevision != null && afterRevision.getFile().isDirectory()) {\n        continue;\n      }\n\n      if (beforeRevision instanceof BinaryContentRevision || afterRevision instanceof BinaryContentRevision) {\n        result.add(buildBinaryPatch(basePath, (BinaryContentRevision) beforeRevision, (BinaryContentRevision) afterRevision));\n        continue;\n      }\n\n      if (beforeRevision == null) {\n        result.add(buildAddedFile(basePath, afterRevision, ind));\n        continue;\n      }\n      if (afterRevision == null) {\n        result.add(buildDeletedFile(basePath, beforeRevision, ind));\n        continue;\n      }\n\n      final String beforeContent = beforeRevision.getContent();\n      if (beforeContent == null) {\n        throw new VcsException(\"Failed to fetch old content for changed file \" + beforeRevision.getFile().getPath());\n      }\n      final String afterContent = afterRevision.getContent();\n      if (afterContent == null) {\n        throw new VcsException(\"Failed to fetch new content for changed file \" + afterRevision.getFile().getPath());\n      }\n      String[] beforeLines = new LineTokenizer(beforeContent).execute();\n      String[] afterLines = new LineTokenizer(afterContent).execute();\n\n      DiffFragment[] woFormattingBlocks = DiffPolicy.LINES_WO_FORMATTING.buildFragments(beforeContent, afterContent);\n      DiffFragment[] step1lineFragments = new DiffCorrection.TrueLineBlocks(ComparisonPolicy.DEFAULT).correctAndNormalize(woFormattingBlocks);\n      ArrayList<LineFragment> fragments = new DiffFragmentsProcessor().process(step1lineFragments);\n\n      if (fragments.size() > 1 || (fragments.size() == 1 && fragments.get(0).getType() != null && fragments.get(0).getType() != TextDiffTypeEnum.NONE)) {\n        TextFilePatch patch = buildPatchHeading(basePath, beforeRevision, afterRevision);\n        result.add(patch);\n\n        int lastLine1 = 0;\n        int lastLine2 = 0;\n\n        while(fragments.size() > 0) {\n          checkCanceled(ind);\n\n          List<LineFragment> adjacentFragments = getAdjacentFragments(fragments);\n          if (adjacentFragments.size() > 0) {\n            LineFragment first = adjacentFragments.get(0);\n            LineFragment last = adjacentFragments.get(adjacentFragments.size()-1);\n\n            final int start1 = first.getStartingLine1();\n            final int start2 = first.getStartingLine2();\n            final int end1 = last.getStartingLine1() + last.getModifiedLines1();\n            final int end2 = last.getStartingLine2() + last.getModifiedLines2();\n            int contextStart1 = Math.max(start1 - CONTEXT_LINES, lastLine1);\n            int contextStart2 = Math.max(start2 - CONTEXT_LINES, lastLine2);\n            int contextEnd1 = Math.min(end1 + CONTEXT_LINES, beforeLines.length);\n            int contextEnd2 = Math.min(end2 + CONTEXT_LINES, afterLines.length);\n\n            PatchHunk hunk = new PatchHunk(contextStart1, contextEnd1, contextStart2, contextEnd2);\n            patch.addHunk(hunk);\n\n            for(LineFragment fragment: adjacentFragments) {\n              checkCanceled(ind);\n              \n              for(int i=contextStart1; i<fragment.getStartingLine1(); i++) {\n                addLineToHunk(hunk, beforeLines [i], PatchLine.Type.CONTEXT);\n              }\n              for(int i=fragment.getStartingLine1(); i<fragment.getStartingLine1()+fragment.getModifiedLines1(); i++) {\n                addLineToHunk(hunk, beforeLines [i], PatchLine.Type.REMOVE);\n              }\n              for(int i=fragment.getStartingLine2(); i<fragment.getStartingLine2()+fragment.getModifiedLines2(); i++) {\n                addLineToHunk(hunk, afterLines[i], PatchLine.Type.ADD);\n              }\n              contextStart1 = fragment.getStartingLine1()+fragment.getModifiedLines1();\n            }\n            for(int i=contextStart1; i<contextEnd1; i++) {\n              addLineToHunk(hunk, beforeLines [i], PatchLine.Type.CONTEXT);\n            }\n          }\n        }\n      } else if (! beforeRevision.getFile().equals(afterRevision.getFile())) {\n        result.add(buildMovedFile(basePath, beforeRevision, afterRevision, beforeLines));\n      }\n    }\n    return result;\n  }","id":35190,"modified_method":"public static List<FilePatch> buildPatch(final Collection<Change> changes, final String basePath, final boolean reversePatch) throws VcsException {\n    final Collection<BeforeAfter<AirContentRevision>> revisions = new ArrayList<BeforeAfter<AirContentRevision>>(changes.size());\n    for (Change change : changes) {\n      revisions.add(new BeforeAfter<AirContentRevision>(convertRevision(change.getBeforeRevision()), convertRevision(change.getAfterRevision())));\n    }\n    return buildPatch(revisions, basePath, reversePatch, SystemInfo.isFileSystemCaseSensitive);\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TextFilePatch buildAddedFile(final String basePath, final ContentRevision afterRevision, final ProgressIndicator ind) throws VcsException {\n    final String content = afterRevision.getContent();\n    if (content == null) {\n      throw new VcsException(\"Failed to fetch content for added file \" + afterRevision.getFile().getPath());\n    }\n    String[] lines = new LineTokenizer(content).execute();\n    TextFilePatch result = buildPatchHeading(basePath, afterRevision, afterRevision);\n    PatchHunk hunk = new PatchHunk(-1, -1, 0, lines.length);\n    for(String line: lines) {\n      checkCanceled(ind);\n      addLineToHunk(hunk, line, PatchLine.Type.ADD);\n    }\n    result.addHunk(hunk);\n    return result;\n  }","id":35191,"modified_method":"private TextFilePatch buildAddedFile(final String basePath, final AirContentRevision afterRevision, final ProgressIndicator ind) throws VcsException {\n    final String content = afterRevision.getContentAsString();\n    if (content == null) {\n      throw new VcsException(\"Failed to fetch content for added file \" + afterRevision.getPath());\n    }\n    String[] lines = new LineTokenizer(content).execute();\n    TextFilePatch result = buildPatchHeading(basePath, afterRevision, afterRevision);\n    PatchHunk hunk = new PatchHunk(-1, -1, 0, lines.length);\n    for(String line: lines) {\n      checkCanceled(ind);\n      addLineToHunk(hunk, line, PatchLine.Type.ADD);\n    }\n    result.addHunk(hunk);\n    return result;\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void setPatchHeading(final FilePatch result, final String basePath,\n                                      @NotNull final ContentRevision beforeRevision,\n                                      @NotNull final ContentRevision afterRevision) {\n    File beforeFile = beforeRevision.getFile().getIOFile();\n    result.setBeforeName(getRelativePath(basePath, beforeFile));\n    result.setBeforeVersionId(getRevisionName(beforeRevision, beforeFile));\n\n    File afterFile = afterRevision.getFile().getIOFile();\n    result.setAfterName(getRelativePath(basePath, afterFile));\n    result.setAfterVersionId(getRevisionName(afterRevision, afterFile));\n  }","id":35192,"modified_method":"private void setPatchHeading(final FilePatch result, final String basePath,\n                                      @NotNull final AirContentRevision beforeRevision,\n                                      @NotNull final AirContentRevision afterRevision) {\n    result.setBeforeName(getRelativePath(basePath, beforeRevision.getPath().getPath()));\n    result.setBeforeVersionId(getRevisionName(beforeRevision));\n\n    result.setAfterName(getRelativePath(basePath, afterRevision.getPath().getPath()));\n    result.setAfterVersionId(getRevisionName(afterRevision));\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TextFilePatch buildMovedFile(final String basePath, final ContentRevision beforeRevision,\n                                              final ContentRevision afterRevision, final String[] lines) throws VcsException {\n    final TextFilePatch result = buildPatchHeading(basePath, beforeRevision, afterRevision);\n    final PatchHunk hunk = new PatchHunk(0, 0, 0, 0);\n    result.addHunk(hunk);\n    return result;\n  }","id":35193,"modified_method":"private TextFilePatch buildMovedFile(final String basePath, final AirContentRevision beforeRevision,\n                                              final AirContentRevision afterRevision, final String[] lines) throws VcsException {\n    final TextFilePatch result = buildPatchHeading(basePath, beforeRevision, afterRevision);\n    final PatchHunk hunk = new PatchHunk(0, 0, 0, 0);\n    result.addHunk(hunk);\n    return result;\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static TextFilePatch buildPatchHeading(final String basePath, final ContentRevision beforeRevision, final ContentRevision afterRevision) {\n    TextFilePatch result = new TextFilePatch();\n    setPatchHeading(result, basePath, beforeRevision, afterRevision);\n    return result;\n  }","id":35194,"modified_method":"private TextFilePatch buildPatchHeading(final String basePath, final AirContentRevision beforeRevision, final AirContentRevision afterRevision) {\n    TextFilePatch result = new TextFilePatch();\n    setPatchHeading(result, basePath, beforeRevision, afterRevision);\n    return result;\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static FilePatch buildBinaryPatch(final String basePath,\n                                            final BinaryContentRevision beforeRevision,\n                                            final BinaryContentRevision afterRevision) throws VcsException {\n    ContentRevision headingBeforeRevision = beforeRevision != null ? beforeRevision : afterRevision;\n    ContentRevision headingAfterRevision = afterRevision != null ? afterRevision : beforeRevision;\n    byte[] beforeContent = beforeRevision != null ? beforeRevision.getBinaryContent() : null;\n    byte[] afterContent = afterRevision != null ? afterRevision.getBinaryContent() : null;\n    BinaryFilePatch patch = new BinaryFilePatch(beforeContent, afterContent);\n    setPatchHeading(patch, basePath, headingBeforeRevision, headingAfterRevision);\n    return patch;\n  }","id":35195,"modified_method":"private FilePatch buildBinaryPatch(final String basePath,\n                                            final AirContentRevision beforeRevision,\n                                            final AirContentRevision afterRevision) throws VcsException {\n    AirContentRevision headingBeforeRevision = beforeRevision != null ? beforeRevision : afterRevision;\n    AirContentRevision headingAfterRevision = afterRevision != null ? afterRevision : beforeRevision;\n    byte[] beforeContent = beforeRevision != null ? beforeRevision.getContentAsBytes() : null;\n    byte[] afterContent = afterRevision != null ? afterRevision.getContentAsBytes() : null;\n    BinaryFilePatch patch = new BinaryFilePatch(beforeContent, afterContent);\n    setPatchHeading(patch, basePath, headingBeforeRevision, headingAfterRevision);\n    return patch;\n  }","commit_id":"06fad4133cbcd7fa36261d26f920e1b941bbaab6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void loadContent() throws IOException {\n    if (myContent != null) return;\n    \n    final VcsFileSystem vcsFileSystem = ((VcsFileSystem)getFileSystem());\n\n    try {\n      myFileRevision.loadContent();\n      fireBeforeContentsChange();\n\n      myModificationStamp++;\n      setRevision(myFileRevision.getRevisionNumber().asString());\n      myContent = myFileRevision.getContent();\n      myCharset = new CharsetToolkit(myContent).guessEncoding(myContent.length);\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          vcsFileSystem.fireContentsChanged(this, VcsVirtualFile.this, 0);\n        }\n      });\n\n    }\n    catch (VcsException e) {\n      myContentLoadFailed = true;\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          vcsFileSystem.fireBeforeFileDeletion(this, VcsVirtualFile.this);\n        }\n      });\n      myContent = ArrayUtil.EMPTY_BYTE_ARRAY;\n      setRevision(\"0\");\n\n      Messages.showMessageDialog(\n        VcsBundle.message(\"message.text.could.not.load.virtual.file.content\", getPresentableUrl(), e.getLocalizedMessage()),\n                                 VcsBundle.message(\"message.title.could.not.load.content\"),\n                                 Messages.getInformationIcon());\n\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          vcsFileSystem.fireFileDeleted(this, VcsVirtualFile.this, getName(), getParent());\n        }\n      });\n\n    }\n    catch (ProcessCanceledException ex) {\n      myContent = null;\n    }\n\n  }","id":35196,"modified_method":"private void loadContent() throws IOException {\n    if (myContent != null) return;\n    \n    final VcsFileSystem vcsFileSystem = ((VcsFileSystem)getFileSystem());\n\n    try {\n      myFileRevision.loadContent();\n      fireBeforeContentsChange();\n\n      myModificationStamp++;\n      final VcsRevisionNumber revisionNumber = myFileRevision.getRevisionNumber();\n      if (revisionNumber instanceof ShortVcsRevisionNumber) {\n        setRevision(((ShortVcsRevisionNumber) revisionNumber).toShortString());\n      }\n      else {\n        setRevision(revisionNumber.asString());\n      }\n      myContent = myFileRevision.getContent();\n      myCharset = new CharsetToolkit(myContent).guessEncoding(myContent.length);\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          vcsFileSystem.fireContentsChanged(this, VcsVirtualFile.this, 0);\n        }\n      });\n\n    }\n    catch (VcsException e) {\n      myContentLoadFailed = true;\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          vcsFileSystem.fireBeforeFileDeletion(this, VcsVirtualFile.this);\n        }\n      });\n      myContent = ArrayUtil.EMPTY_BYTE_ARRAY;\n      setRevision(\"0\");\n\n      Messages.showMessageDialog(\n        VcsBundle.message(\"message.text.could.not.load.virtual.file.content\", getPresentableUrl(), e.getLocalizedMessage()),\n                                 VcsBundle.message(\"message.title.could.not.load.content\"),\n                                 Messages.getInformationIcon());\n\n      ApplicationManager.getApplication().runWriteAction(new Runnable() {\n        public void run() {\n          vcsFileSystem.fireFileDeleted(this, VcsVirtualFile.this, getName(), getParent());\n        }\n      });\n\n    }\n    catch (ProcessCanceledException ex) {\n      myContent = null;\n    }\n\n  }","commit_id":"e4deac98b983b7a11ad9459afc3190fe1ad33355","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void doAnnotate(final Editor editor,\n                                final Project project,\n                                final VirtualFile file,\n                                final FileAnnotation fileAnnotation,\n                                final AbstractVcs vcs, final boolean onCurrentRevision) {\n    final UpToDateLineNumberProvider getUpToDateLineNumber = new UpToDateLineNumberProviderImpl(editor.getDocument(), project);\n    editor.getGutter().closeAllAnnotations();\n    final VcsAnnotationLocalChangesListener listener = ProjectLevelVcsManager.getInstance(project).getAnnotationLocalChangesListener();\n\n    fileAnnotation.setCloser(new Runnable() {\n      @Override\n      public void run() {\n        if (project.isDisposed()) return;\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            if (project.isDisposed()) return;\n            editor.getGutter().closeAllAnnotations();\n          }\n        });\n      }\n    });\n    if (onCurrentRevision) {\n      listener.registerAnnotation(file, fileAnnotation);\n    }\n\n    // be careful, not proxies but original items are put there (since only their presence not behaviour is important)\n    Collection<ActiveAnnotationGutter> annotations = editor.getUserData(KEY_IN_EDITOR);\n    if (annotations == null) {\n      annotations = new HashSet<ActiveAnnotationGutter>();\n      editor.putUserData(KEY_IN_EDITOR, annotations);\n    }\n\n    final EditorGutterComponentEx editorGutter = (EditorGutterComponentEx)editor.getGutter();\n    final List<AnnotationFieldGutter> gutters = new ArrayList<AnnotationFieldGutter>();\n    final AnnotationSourceSwitcher switcher = fileAnnotation.getAnnotationSourceSwitcher();\n    final List<AnAction> additionalActions = new ArrayList<AnAction>();\n    if (vcs.getCommittedChangesProvider() != null) {\n      additionalActions.add(new ShowDiffFromAnnotation(getUpToDateLineNumber, fileAnnotation, vcs, file));\n    }\n    additionalActions.add(new CopyRevisionNumberFromAnnotateAction(getUpToDateLineNumber, fileAnnotation));\n    final AnnotationPresentation presentation =\n      new AnnotationPresentation(fileAnnotation, switcher, editorGutter,\n                                 additionalActions.toArray(new AnAction[additionalActions.size()]));\n\n    final Couple<Map<VcsRevisionNumber, Color>> bgColorMap =\n      Registry.is(\"vcs.show.colored.annotations\") ? computeBgColors(fileAnnotation) : null;\n    final Map<String, Integer> historyIds = Registry.is(\"vcs.show.history.numbers\") ? computeLineNumbers(fileAnnotation) : null;\n\n    if (switcher != null) {\n      switcher.switchTo(switcher.getDefaultSource());\n      final LineAnnotationAspect revisionAspect = switcher.getRevisionAspect();\n      final CurrentRevisionAnnotationFieldGutter currentRevisionGutter =\n        new CurrentRevisionAnnotationFieldGutter(fileAnnotation, editor, revisionAspect, presentation, bgColorMap);\n      final MergeSourceAvailableMarkerGutter mergeSourceGutter =\n        new MergeSourceAvailableMarkerGutter(fileAnnotation, editor, null, presentation, bgColorMap);\n\n      presentation.addSourceSwitchListener(currentRevisionGutter);\n      presentation.addSourceSwitchListener(mergeSourceGutter);\n\n      currentRevisionGutter.consume(switcher.getDefaultSource());\n      mergeSourceGutter.consume(switcher.getDefaultSource());\n\n      gutters.add(currentRevisionGutter);\n      gutters.add(mergeSourceGutter);\n    }\n\n    final LineAnnotationAspect[] aspects = fileAnnotation.getAspects();\n    for (LineAnnotationAspect aspect : aspects) {\n      gutters.add(new AnnotationFieldGutter(fileAnnotation, editor, aspect, presentation, bgColorMap));\n    }\n\n\n    if (historyIds != null) {\n      gutters.add(new HistoryIdColumn(fileAnnotation, editor, presentation, bgColorMap, historyIds));\n    }\n    gutters.add(new HighlightedAdditionalColumn(fileAnnotation, editor, null, presentation, bgColorMap));\n    final AnnotateActionGroup actionGroup = new AnnotateActionGroup(gutters, editorGutter);\n    presentation.addAction(actionGroup, 1);\n    gutters.add(new ExtraFieldGutter(fileAnnotation, editor, presentation, bgColorMap, actionGroup));\n\n    presentation.addAction(new AnnotateCurrentRevisionAction(getUpToDateLineNumber, fileAnnotation, vcs));\n    presentation.addAction(new AnnotatePreviousRevisionAction(getUpToDateLineNumber, fileAnnotation, vcs));\n    addActionsFromExtensions(presentation, fileAnnotation);\n\n    for (AnAction action : presentation.getActions()) {\n      if (action instanceof LineNumberListener) {\n        presentation.addLineNumberListener((LineNumberListener)action);\n      }\n    }\n\n    for (AnnotationFieldGutter gutter : gutters) {\n      final AnnotationGutterLineConvertorProxy proxy = new AnnotationGutterLineConvertorProxy(getUpToDateLineNumber, gutter);\n      if (gutter.isGutterAction()) {\n        editor.getGutter().registerTextAnnotation(proxy, proxy);\n      }\n      else {\n        editor.getGutter().registerTextAnnotation(proxy);\n      }\n      annotations.add(gutter);\n    }\n  }","id":35197,"modified_method":"public static void doAnnotate(final Editor editor,\n                                final Project project,\n                                final VirtualFile file,\n                                final FileAnnotation fileAnnotation,\n                                final AbstractVcs vcs, final boolean onCurrentRevision) {\n    final UpToDateLineNumberProvider getUpToDateLineNumber = new UpToDateLineNumberProviderImpl(editor.getDocument(), project);\n    editor.getGutter().closeAllAnnotations();\n    final VcsAnnotationLocalChangesListener listener = ProjectLevelVcsManager.getInstance(project).getAnnotationLocalChangesListener();\n\n    fileAnnotation.setCloser(new Runnable() {\n      @Override\n      public void run() {\n        if (project.isDisposed()) return;\n        UIUtil.invokeLaterIfNeeded(new Runnable() {\n          @Override\n          public void run() {\n            if (project.isDisposed()) return;\n            editor.getGutter().closeAllAnnotations();\n          }\n        });\n      }\n    });\n    if (onCurrentRevision) {\n      listener.registerAnnotation(file, fileAnnotation);\n    }\n\n    // be careful, not proxies but original items are put there (since only their presence not behaviour is important)\n    Collection<ActiveAnnotationGutter> annotations = editor.getUserData(KEY_IN_EDITOR);\n    if (annotations == null) {\n      annotations = new HashSet<ActiveAnnotationGutter>();\n      editor.putUserData(KEY_IN_EDITOR, annotations);\n    }\n\n    final EditorGutterComponentEx editorGutter = (EditorGutterComponentEx)editor.getGutter();\n    final List<AnnotationFieldGutter> gutters = new ArrayList<AnnotationFieldGutter>();\n    final AnnotationSourceSwitcher switcher = fileAnnotation.getAnnotationSourceSwitcher();\n    final List<AnAction> additionalActions = new ArrayList<AnAction>();\n    if (vcs.getCommittedChangesProvider() != null) {\n      additionalActions.add(new ShowDiffFromAnnotation(getUpToDateLineNumber, fileAnnotation, vcs, file));\n    }\n    additionalActions.add(new CopyRevisionNumberFromAnnotateAction(getUpToDateLineNumber, fileAnnotation));\n    final AnnotationPresentation presentation =\n      new AnnotationPresentation(fileAnnotation, switcher, editorGutter,\n                                 additionalActions.toArray(new AnAction[additionalActions.size()]));\n\n    final Couple<Map<VcsRevisionNumber, Color>> bgColorMap =\n      Registry.is(\"vcs.show.colored.annotations\") ? computeBgColors(fileAnnotation) : null;\n    final Map<VcsRevisionNumber, Integer> historyIds = Registry.is(\"vcs.show.history.numbers\") ? computeLineNumbers(fileAnnotation) : null;\n\n    if (switcher != null) {\n      switcher.switchTo(switcher.getDefaultSource());\n      final LineAnnotationAspect revisionAspect = switcher.getRevisionAspect();\n      final CurrentRevisionAnnotationFieldGutter currentRevisionGutter =\n        new CurrentRevisionAnnotationFieldGutter(fileAnnotation, editor, revisionAspect, presentation, bgColorMap);\n      final MergeSourceAvailableMarkerGutter mergeSourceGutter =\n        new MergeSourceAvailableMarkerGutter(fileAnnotation, editor, null, presentation, bgColorMap);\n\n      presentation.addSourceSwitchListener(currentRevisionGutter);\n      presentation.addSourceSwitchListener(mergeSourceGutter);\n\n      currentRevisionGutter.consume(switcher.getDefaultSource());\n      mergeSourceGutter.consume(switcher.getDefaultSource());\n\n      gutters.add(currentRevisionGutter);\n      gutters.add(mergeSourceGutter);\n    }\n\n    final LineAnnotationAspect[] aspects = fileAnnotation.getAspects();\n    for (LineAnnotationAspect aspect : aspects) {\n      gutters.add(new AnnotationFieldGutter(fileAnnotation, editor, aspect, presentation, bgColorMap));\n    }\n\n\n    if (historyIds != null) {\n      gutters.add(new HistoryIdColumn(fileAnnotation, editor, presentation, bgColorMap, historyIds));\n    }\n    gutters.add(new HighlightedAdditionalColumn(fileAnnotation, editor, null, presentation, bgColorMap));\n    final AnnotateActionGroup actionGroup = new AnnotateActionGroup(gutters, editorGutter);\n    presentation.addAction(actionGroup, 1);\n    gutters.add(new ExtraFieldGutter(fileAnnotation, editor, presentation, bgColorMap, actionGroup));\n\n    presentation.addAction(new AnnotateCurrentRevisionAction(getUpToDateLineNumber, fileAnnotation, vcs));\n    presentation.addAction(new AnnotatePreviousRevisionAction(getUpToDateLineNumber, fileAnnotation, vcs));\n    addActionsFromExtensions(presentation, fileAnnotation);\n\n    for (AnAction action : presentation.getActions()) {\n      if (action instanceof LineNumberListener) {\n        presentation.addLineNumberListener((LineNumberListener)action);\n      }\n    }\n\n    for (AnnotationFieldGutter gutter : gutters) {\n      final AnnotationGutterLineConvertorProxy proxy = new AnnotationGutterLineConvertorProxy(getUpToDateLineNumber, gutter);\n      if (gutter.isGutterAction()) {\n        editor.getGutter().registerTextAnnotation(proxy, proxy);\n      }\n      else {\n        editor.getGutter().registerTextAnnotation(proxy);\n      }\n      annotations.add(gutter);\n    }\n  }","commit_id":"5e1973701bf61e01087bb070c1ddb2cb42d310a1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Map<String, Integer> computeLineNumbers(@NotNull FileAnnotation fileAnnotation) {\n    final SortedList<VcsFileRevision> revisions = new SortedList<VcsFileRevision>(new Comparator<VcsFileRevision>() {\n      @Override\n      public int compare(VcsFileRevision o1, VcsFileRevision o2) {\n        try {\n          final int result = o1.getRevisionDate().compareTo(o2.getRevisionDate());\n          return result != 0 ? result : o1.getRevisionNumber().compareTo(o2.getRevisionNumber());\n        }\n        catch (Exception e) {\n          return 0;\n        }\n      }\n    });\n    final Map<String, Integer> numbers = new HashMap<String, Integer>();\n    final List<VcsFileRevision> fileRevisionList = fileAnnotation.getRevisions();\n    if (fileRevisionList != null) {\n      revisions.addAll(fileRevisionList);\n      for (VcsFileRevision revision : fileRevisionList) {\n        final String revNumber = revision.getRevisionNumber().asString();\n        if (!numbers.containsKey(revNumber)) {\n          final int num = revisions.indexOf(revision);\n          if (num != -1) {\n            numbers.put(revNumber, num + 1);\n          }\n        }\n      }\n    }\n    return numbers.size() < 2 ? null : numbers;\n  }","id":35198,"modified_method":"@Nullable\n  private static Map<VcsRevisionNumber, Integer> computeLineNumbers(@NotNull FileAnnotation fileAnnotation) {\n    final Map<VcsRevisionNumber, Integer> numbers = new HashMap<VcsRevisionNumber, Integer>();\n    final List<VcsFileRevision> fileRevisionList = fileAnnotation.getRevisions();\n    if (fileRevisionList != null) {\n      int size = fileRevisionList.size();\n      for (int i = 0; i < size; i++) {\n        VcsFileRevision revision = fileRevisionList.get(i);\n        final VcsRevisionNumber number = revision.getRevisionNumber();\n\n        numbers.put(number, size - i);\n      }\n    }\n    return numbers.size() < 2 ? null : numbers;\n  }","commit_id":"5e1973701bf61e01087bb070c1ddb2cb42d310a1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"HistoryIdColumn(FileAnnotation annotation,\n                  final Editor editor,\n                  final TextAnnotationPresentation presentation,\n                  Couple<Map<VcsRevisionNumber, Color>> colorScheme,\n                  Map<String, Integer> ids) {\n    super(annotation, editor, null, presentation, colorScheme);\n    myHistoryIds = ids;\n  }","id":35199,"modified_method":"HistoryIdColumn(FileAnnotation annotation,\n                  final Editor editor,\n                  final TextAnnotationPresentation presentation,\n                  Couple<Map<VcsRevisionNumber, Color>> colorScheme,\n                  Map<VcsRevisionNumber, Integer> ids) {\n    super(annotation, editor, null, presentation, colorScheme);\n    myHistoryIds = ids;\n  }","commit_id":"5e1973701bf61e01087bb070c1ddb2cb42d310a1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getLineText(int line, Editor editor) {\n    if (!isAvailable()) return \"\";\n    final VcsRevisionNumber revisionNumber = myAnnotation.getLineRevisionNumber(line);\n    if (revisionNumber != null) {\n      final Integer num = myHistoryIds.get(revisionNumber.asString());\n      if (num != null) {\n        final String size = String.valueOf(myHistoryIds.size());\n        String value = num.toString();\n        while (value.length() < size.length()) {\n          value = \" \" + value;\n        }\n        return value;\n      }\n    }\n    return \"\";\n  }","id":35200,"modified_method":"@Override\n  public String getLineText(int line, Editor editor) {\n    if (!isAvailable()) return \"\";\n    final VcsRevisionNumber revisionNumber = myAnnotation.getLineRevisionNumber(line);\n    if (revisionNumber != null) {\n      final Integer num = myHistoryIds.get(revisionNumber);\n      if (num != null) {\n        final String size = String.valueOf(myHistoryIds.size());\n        String value = num.toString();\n        while (value.length() < size.length()) {\n          value = \" \" + value;\n        }\n        return value;\n      }\n    }\n    return \"\";\n  }","commit_id":"5e1973701bf61e01087bb070c1ddb2cb42d310a1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected Object[] buildChildren(@NotNull HierarchyNodeDescriptor descriptor) {\n    final List<PyHierarchyNodeDescriptor> descriptors = new ArrayList<PyHierarchyNodeDescriptor>();\n    if (descriptor instanceof PyHierarchyNodeDescriptor) {\n      final PyHierarchyNodeDescriptor pyDescriptor = (PyHierarchyNodeDescriptor)descriptor;\n      final PsiElement element = pyDescriptor.getPsiElement();\n      final boolean isCallable = element instanceof PyFunction || element instanceof PyClass || element instanceof PyFile;\n      HierarchyNodeDescriptor nodeDescriptor = getBaseDescriptor();\n      if (!(element instanceof PyElement) || !isCallable || nodeDescriptor == null) {\n        return ArrayUtil.EMPTY_OBJECT_ARRAY;\n      }\n\n      final List<PsiElement> callees = new ArrayList<PsiElement>();\n\n      PyCallDataManager[] functionManagers = {\n        // TODO: Add dynamic call data manager\n        PyStaticCallDataManager.getInstance(myProject),\n      };\n\n      for (PyCallDataManager functionManager : functionManagers) {\n        callees.addAll(functionManager.getCallees((PyElement)element));\n      }\n\n      final Map<PsiElement, PyHierarchyNodeDescriptor> calleeToDescriptorMap = new HashMap<PsiElement, PyHierarchyNodeDescriptor>();\n      PsiElement baseClass = element instanceof PyFunction ? ((PyFunction)element).getContainingClass() : null;\n\n      for (PsiElement callee : callees) {\n        if (baseClass != null && !isInScope(baseClass, callee, myScopeType)) continue;\n\n        PyHierarchyNodeDescriptor calleeDescriptor = calleeToDescriptorMap.get(callee);\n        if (calleeDescriptor == null) {\n          calleeDescriptor = new PyHierarchyNodeDescriptor(descriptor, callee, false);\n          calleeToDescriptorMap.put(callee, calleeDescriptor);\n          descriptors.add(calleeDescriptor);\n        }\n      }\n\n    }\n    return ArrayUtil.toObjectArray(descriptors);\n  }","id":35201,"modified_method":"@NotNull\n  @Override\n  protected Object[] buildChildren(@NotNull HierarchyNodeDescriptor descriptor) {\n    final List<PyHierarchyNodeDescriptor> descriptors = new ArrayList<PyHierarchyNodeDescriptor>();\n    if (descriptor instanceof PyHierarchyNodeDescriptor) {\n      final PyHierarchyNodeDescriptor pyDescriptor = (PyHierarchyNodeDescriptor)descriptor;\n      final PsiElement element = pyDescriptor.getPsiElement();\n      final boolean isCallable = element instanceof PyFunction || element instanceof PyClass || element instanceof PyFile;\n      HierarchyNodeDescriptor nodeDescriptor = getBaseDescriptor();\n      if (!(element instanceof PyElement) || !isCallable || nodeDescriptor == null) {\n        return ArrayUtil.EMPTY_OBJECT_ARRAY;\n      }\n\n      final List<PsiElement> callees = new ArrayList<PsiElement>();\n\n      PyCallDataManager[] functionManagers = {\n        // TODO: Add dynamic call data manager\n        PyStaticCallDataManager.getInstance(myProject),\n      };\n\n      for (PyCallDataManager functionManager : functionManagers) {\n        callees.addAll(functionManager.getCallees((PyElement)element));\n      }\n\n      final Map<PsiElement, PyHierarchyNodeDescriptor> calleeToDescriptorMap = new HashMap<PsiElement, PyHierarchyNodeDescriptor>();\n      PsiElement baseClass = element instanceof PyFunction ? ((PyFunction)element).getContainingClass() : null;\n\n      for (PsiElement callee : callees) {\n        if (isInScope(baseClass, callee, myScopeType)) {\n          PyHierarchyNodeDescriptor calleeDescriptor = calleeToDescriptorMap.get(callee);\n          if (calleeDescriptor == null) {\n            calleeDescriptor = new PyHierarchyNodeDescriptor(descriptor, callee, false);\n            calleeToDescriptorMap.put(callee, calleeDescriptor);\n            descriptors.add(calleeDescriptor);\n          }\n        }\n      }\n\n    }\n    return ArrayUtil.toObjectArray(descriptors);\n  }","commit_id":"4dc1fe67e5dd5d9fbe0783d962d01434156b825f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  protected Object[] buildChildren(@NotNull HierarchyNodeDescriptor descriptor) {\n    final List<PyHierarchyNodeDescriptor> descriptors = new ArrayList<PyHierarchyNodeDescriptor>();\n    if (descriptor instanceof PyHierarchyNodeDescriptor) {\n      final PyHierarchyNodeDescriptor pyDescriptor = (PyHierarchyNodeDescriptor)descriptor;\n      final PsiElement element = pyDescriptor.getPsiElement();\n      final boolean isCallable = element instanceof PyFunction || element instanceof PyClass || element instanceof PyFile;\n      HierarchyNodeDescriptor nodeDescriptor = getBaseDescriptor();\n      if (!(element instanceof PyElement) || !isCallable || nodeDescriptor == null) {\n        return ArrayUtil.EMPTY_OBJECT_ARRAY;\n      }\n\n      final List<PsiElement> callers = new ArrayList<PsiElement>();\n\n      PyCallDataManager[] functionManagers = {\n        // TODO: Add dynamic call data manager\n        PyStaticCallDataManager.getInstance(myProject),\n      };\n\n      for (PyCallDataManager functionManager : functionManagers) {\n        callers.addAll(functionManager.getCallers((PyElement)element));\n      }\n\n      final HashMap<PsiElement, PyHierarchyNodeDescriptor> callerToDescriptorMap = new HashMap<PsiElement, PyHierarchyNodeDescriptor>();\n      PsiElement baseClass = element instanceof PyFunction ? ((PyFunction)element).getContainingClass() : null;\n\n      for (PsiElement caller : callers) {\n        if (baseClass != null && !isInScope(baseClass, caller, myScopeType)) continue;\n\n        PyHierarchyNodeDescriptor callerDescriptor = callerToDescriptorMap.get(caller);\n        if (callerDescriptor == null) {\n          callerDescriptor = new PyHierarchyNodeDescriptor(descriptor, caller, false);\n          callerToDescriptorMap.put(caller, callerDescriptor);\n          descriptors.add(callerDescriptor);\n        }\n      }\n\n    }\n    return ArrayUtil.toObjectArray(descriptors);\n  }","id":35202,"modified_method":"@NotNull\n  @Override\n  protected Object[] buildChildren(@NotNull HierarchyNodeDescriptor descriptor) {\n    final List<PyHierarchyNodeDescriptor> descriptors = new ArrayList<PyHierarchyNodeDescriptor>();\n    if (descriptor instanceof PyHierarchyNodeDescriptor) {\n      final PyHierarchyNodeDescriptor pyDescriptor = (PyHierarchyNodeDescriptor)descriptor;\n      final PsiElement element = pyDescriptor.getPsiElement();\n      final boolean isCallable = element instanceof PyFunction || element instanceof PyClass || element instanceof PyFile;\n      HierarchyNodeDescriptor nodeDescriptor = getBaseDescriptor();\n      if (!(element instanceof PyElement) || !isCallable || nodeDescriptor == null) {\n        return ArrayUtil.EMPTY_OBJECT_ARRAY;\n      }\n\n      final List<PsiElement> callers = new ArrayList<PsiElement>();\n\n      PyCallDataManager[] functionManagers = {\n        // TODO: Add dynamic call data manager\n        PyStaticCallDataManager.getInstance(myProject),\n      };\n\n      for (PyCallDataManager functionManager : functionManagers) {\n        callers.addAll(functionManager.getCallers((PyElement)element));\n      }\n\n      final HashMap<PsiElement, PyHierarchyNodeDescriptor> callerToDescriptorMap = new HashMap<PsiElement, PyHierarchyNodeDescriptor>();\n      PsiElement baseClass = element instanceof PyFunction ? ((PyFunction)element).getContainingClass() : null;\n\n      for (PsiElement caller : callers) {\n        if (isInScope(baseClass, caller, myScopeType)) {\n          PyHierarchyNodeDescriptor callerDescriptor = callerToDescriptorMap.get(caller);\n          if (callerDescriptor == null) {\n            callerDescriptor = new PyHierarchyNodeDescriptor(descriptor, caller, false);\n            callerToDescriptorMap.put(caller, callerDescriptor);\n            descriptors.add(callerDescriptor);\n          }\n        }\n      }\n\n    }\n    return ArrayUtil.toObjectArray(descriptors);\n  }","commit_id":"4dc1fe67e5dd5d9fbe0783d962d01434156b825f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addSubMembers(@NotNull final Project project,\n                                    @Nullable final SearchScope scope,\n                                    @NotNull final Set<TypeHierarchyItem> visited,\n                                    @NotNull final List<TypeHierarchyItem> hierarchyItems,\n                                    @NotNull final List<DartComponent> components,\n                                    @NotNull final TypeHierarchyItem currentItem,\n                                    final boolean addItem) {\n    if (!visited.add(currentItem)) {\n      return;\n    }\n    if (addItem) {\n      final Element element = currentItem.getMemberElement();\n      if (element != null) {\n        final Location location = element.getLocation();\n        final DartComponent component = DartServerOverrideMarkerProvider.findDartComponent(project, location);\n        if (component != null && (scope == null || isInScope(scope, component))) {\n          components.add(component);\n        }\n      }\n    }\n    for (int subIndex : currentItem.getSubclasses()) {\n      final TypeHierarchyItem subItem = hierarchyItems.get(subIndex);\n      addSubMembers(project, scope, visited, hierarchyItems, components, subItem, true);\n    }\n  }","id":35203,"modified_method":"private static void addSubMembers(@NotNull final Project project,\n                                    @NotNull final SearchScope scope,\n                                    @NotNull final Set<TypeHierarchyItem> visited,\n                                    @NotNull final List<TypeHierarchyItem> hierarchyItems,\n                                    @NotNull final List<DartComponent> components,\n                                    @NotNull final TypeHierarchyItem currentItem,\n                                    final boolean addItem) {\n    if (!visited.add(currentItem)) {\n      return;\n    }\n    if (addItem) {\n      final Element element = currentItem.getMemberElement();\n      if (element != null) {\n        final Location location = element.getLocation();\n        final DartComponent component = DartServerOverrideMarkerProvider.findDartComponent(project, location);\n        if (component != null && isInScope(scope, component)) {\n          components.add(component);\n        }\n      }\n    }\n    for (int subIndex : currentItem.getSubclasses()) {\n      final TypeHierarchyItem subItem = hierarchyItems.get(subIndex);\n      addSubMembers(project, scope, visited, hierarchyItems, components, subItem, true);\n    }\n  }","commit_id":"540ebd216a886f2e28094e346184ee52909ea296","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void addSubClasses(@NotNull final Project project,\n                                    @Nullable final SearchScope scope,\n                                    @NotNull final Set<TypeHierarchyItem> visited,\n                                    @NotNull final List<TypeHierarchyItem> hierarchyItems,\n                                    @NotNull final List<DartComponent> components,\n                                    @NotNull final TypeHierarchyItem currentItem,\n                                    final boolean addItem) {\n    if (!visited.add(currentItem)) {\n      return;\n    }\n    if (addItem) {\n      final Element element = currentItem.getClassElement();\n      final Location location = element.getLocation();\n      final DartComponent component = DartServerOverrideMarkerProvider.findDartComponent(project, location);\n      if (component != null && (scope == null || isInScope(scope, component))) {\n        components.add(component);\n      }\n    }\n    for (int subIndex : currentItem.getSubclasses()) {\n      final TypeHierarchyItem subItem = hierarchyItems.get(subIndex);\n      addSubClasses(project, scope, visited, hierarchyItems, components, subItem, true);\n    }\n  }","id":35204,"modified_method":"private static void addSubClasses(@NotNull final Project project,\n                                    @NotNull final SearchScope scope,\n                                    @NotNull final Set<TypeHierarchyItem> visited,\n                                    @NotNull final List<TypeHierarchyItem> hierarchyItems,\n                                    @NotNull final List<DartComponent> components,\n                                    @NotNull final TypeHierarchyItem currentItem,\n                                    final boolean addItem) {\n    if (!visited.add(currentItem)) {\n      return;\n    }\n    if (addItem) {\n      final Element element = currentItem.getClassElement();\n      final Location location = element.getLocation();\n      final DartComponent component = DartServerOverrideMarkerProvider.findDartComponent(project, location);\n      if (component != null && isInScope(scope, component)) {\n        components.add(component);\n      }\n    }\n    for (int subIndex : currentItem.getSubclasses()) {\n      final TypeHierarchyItem subItem = hierarchyItems.get(subIndex);\n      addSubClasses(project, scope, visited, hierarchyItems, components, subItem, true);\n    }\n  }","commit_id":"540ebd216a886f2e28094e346184ee52909ea296","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private static LineMarkerInfo createMarkerClass(@NotNull final DartComponentName name) {\n    final VirtualFile file = name.getContainingFile().getVirtualFile();\n    final int nameOffset = name.getTextOffset();\n    return new LineMarkerInfo<PsiElement>(name, name.getTextRange(), AllIcons.Gutter.OverridenMethod, Pass.UPDATE_ALL,\n                                          new Function<PsiElement, String>() {\n                                            @Override\n                                            public String fun(PsiElement element) {\n                                              return DaemonBundle.message(\"class.is.subclassed.too.many\");\n                                            }\n                                          }, new GutterIconNavigationHandler<PsiElement>() {\n      @Override\n      public void navigate(MouseEvent e, PsiElement elt) {\n        final List<TypeHierarchyItem> items = DartAnalysisServerService.getInstance().search_getTypeHierarchy(file, nameOffset, false);\n        if (items.isEmpty()) {\n          return;\n        }\n        // TODO(scheglov) Consider using just Element(s), not PsiElement(s) for better performance\n        final List<DartComponent> components = DartInheritorsSearcher.getSubClasses(name.getProject(), null, items);\n        PsiElementListNavigator.openTargets(e, DartResolveUtil.getComponentNameArray(components),\n                                            DaemonBundle.message(\"navigation.title.subclass\", name.getName(), components.size()),\n                                            \"Subclasses of \" + name.getName(), new DefaultPsiElementCellRenderer());\n      }\n    }, GutterIconRenderer.Alignment.RIGHT);\n  }","id":35205,"modified_method":"@NotNull\n  private static LineMarkerInfo createMarkerClass(@NotNull final DartComponentName name) {\n    final VirtualFile file = name.getContainingFile().getVirtualFile();\n    final int nameOffset = name.getTextOffset();\n    return new LineMarkerInfo<PsiElement>(name, name.getTextRange(), AllIcons.Gutter.OverridenMethod, Pass.UPDATE_ALL,\n                                          new Function<PsiElement, String>() {\n                                            @Override\n                                            public String fun(PsiElement element) {\n                                              return DaemonBundle.message(\"class.is.subclassed.too.many\");\n                                            }\n                                          }, new GutterIconNavigationHandler<PsiElement>() {\n      @Override\n      public void navigate(MouseEvent e, PsiElement elt) {\n        final List<TypeHierarchyItem> items = DartAnalysisServerService.getInstance().search_getTypeHierarchy(file, nameOffset, false);\n        if (items.isEmpty()) {\n          return;\n        }\n        // TODO(scheglov) Consider using just Element(s), not PsiElement(s) for better performance\n        final List<DartComponent> components =\n          DartInheritorsSearcher.getSubClasses(name.getProject(), GlobalSearchScope.allScope(name.getProject()), items);\n        PsiElementListNavigator.openTargets(e, DartResolveUtil.getComponentNameArray(components),\n                                            DaemonBundle.message(\"navigation.title.subclass\", name.getName(), components.size()),\n                                            \"Subclasses of \" + name.getName(), new DefaultPsiElementCellRenderer());\n      }\n    }, GutterIconRenderer.Alignment.RIGHT);\n  }","commit_id":"540ebd216a886f2e28094e346184ee52909ea296","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  private static LineMarkerInfo createMarkerMember(@NotNull final DartComponentName name) {\n    final VirtualFile file = name.getContainingFile().getVirtualFile();\n    final int nameOffset = name.getTextOffset();\n    return new LineMarkerInfo<PsiElement>(name, name.getTextRange(), AllIcons.Gutter.OverridenMethod, Pass.UPDATE_ALL,\n                                          new Function<PsiElement, String>() {\n                                            @Override\n                                            public String fun(PsiElement element) {\n                                              return DaemonBundle.message(\"method.is.overridden.too.many\");\n                                            }\n                                          }, new GutterIconNavigationHandler<PsiElement>() {\n      @Override\n      public void navigate(MouseEvent e, PsiElement elt) {\n        final List<TypeHierarchyItem> items = DartAnalysisServerService.getInstance().search_getTypeHierarchy(file, nameOffset, false);\n        if (items.isEmpty()) {\n          return;\n        }\n        // TODO(scheglov) Consider using just Element(s), not PsiElement(s) for better performance\n        final List<DartComponent> components = DartInheritorsSearcher.getSubMembers(name.getProject(), null, items);\n        PsiElementListNavigator.openTargets(e, DartResolveUtil.getComponentNameArray(components),\n                                            DaemonBundle.message(\"navigation.title.overrider.method\", name.getName(), components.size()),\n                                            \"Overriding methods of \" + name.getName(),\n                                            new DefaultPsiElementCellRenderer());\n      }\n    }, GutterIconRenderer.Alignment.RIGHT);\n  }","id":35206,"modified_method":"@NotNull\n  private static LineMarkerInfo createMarkerMember(@NotNull final DartComponentName name) {\n    final VirtualFile file = name.getContainingFile().getVirtualFile();\n    final int nameOffset = name.getTextOffset();\n    return new LineMarkerInfo<PsiElement>(name, name.getTextRange(), AllIcons.Gutter.OverridenMethod, Pass.UPDATE_ALL,\n                                          new Function<PsiElement, String>() {\n                                            @Override\n                                            public String fun(PsiElement element) {\n                                              return DaemonBundle.message(\"method.is.overridden.too.many\");\n                                            }\n                                          }, new GutterIconNavigationHandler<PsiElement>() {\n      @Override\n      public void navigate(MouseEvent e, PsiElement elt) {\n        final List<TypeHierarchyItem> items = DartAnalysisServerService.getInstance().search_getTypeHierarchy(file, nameOffset, false);\n        if (items.isEmpty()) {\n          return;\n        }\n        // TODO(scheglov) Consider using just Element(s), not PsiElement(s) for better performance\n        final List<DartComponent> components =\n          DartInheritorsSearcher.getSubMembers(name.getProject(), GlobalSearchScope.allScope(name.getProject()), items);\n        PsiElementListNavigator.openTargets(e, DartResolveUtil.getComponentNameArray(components),\n                                            DaemonBundle.message(\"navigation.title.overrider.method\", name.getName(), components.size()),\n                                            \"Overriding methods of \" + name.getName(),\n                                            new DefaultPsiElementCellRenderer());\n      }\n    }, GutterIconRenderer.Alignment.RIGHT);\n  }","commit_id":"540ebd216a886f2e28094e346184ee52909ea296","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"/** Applies a touch down event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event. */\n\tpublic boolean touchDown (int screenX, int screenY, int pointer, int button) {\n\t\tif (screenX < viewport.getScreenX() || screenX >= viewport.getScreenX() + viewport.getScreenWidth()) return false;\n\t\tif (Gdx.graphics.getHeight() - screenY < viewport.getScreenY()\n\t\t\t|| Gdx.graphics.getHeight() - screenY >= viewport.getScreenY() + viewport.getScreenHeight()) return false;\n\n\t\tpointerTouched[pointer] = true;\n\t\tpointerScreenX[pointer] = screenX;\n\t\tpointerScreenY[pointer] = screenY;\n\n\t\tscreenToStageCoordinates(tempCoords.set(screenX, screenY));\n\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\n\t\tevent.setType(Type.touchDown);\n\t\tevent.setStage(this);\n\t\tevent.setStageX(tempCoords.x);\n\t\tevent.setStageY(tempCoords.y);\n\t\tevent.setPointer(pointer);\n\t\tevent.setButton(button);\n\n\t\tActor target = hit(tempCoords.x, tempCoords.y, true);\n\t\tif (target == null) target = root;\n\n\t\ttarget.fire(event);\n\t\tboolean handled = event.isHandled();\n\t\tPools.free(event);\n\t\treturn handled;\n\t}","id":35207,"modified_method":"/** Applies a touch down event to the stage and returns true if an actor in the scene {@link Event#handle() handled} the event. */\n\tpublic boolean touchDown (int screenX, int screenY, int pointer, int button) {\n\t\tif (screenX < viewport.getScreenX() || screenX >= viewport.getScreenX() + viewport.getScreenWidth()) return false;\n\t\tif (Gdx.graphics.getHeight() - screenY < viewport.getScreenY()\n\t\t\t|| Gdx.graphics.getHeight() - screenY >= viewport.getScreenY() + viewport.getScreenHeight()) return false;\n\n\t\tpointerTouched[pointer] = true;\n\t\tpointerScreenX[pointer] = screenX;\n\t\tpointerScreenY[pointer] = screenY;\n\n\t\tscreenToStageCoordinates(tempCoords.set(screenX, screenY));\n\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\n\t\tevent.setType(Type.touchDown);\n\t\tevent.setStage(this);\n\t\tevent.setStageX(tempCoords.x);\n\t\tevent.setStageY(tempCoords.y);\n\t\tevent.setPointer(pointer);\n\t\tevent.setButton(button);\n\n\t\tActor target = hit(tempCoords.x, tempCoords.y, true);\n\t\tif (target == null) {\n\t\t\tif (root.getTouchable() == Touchable.enabled) root.fire(event);\n\t\t} else {\n\t\t\ttarget.fire(event);\n\t\t}\n\n\t\tboolean handled = event.isHandled();\n\t\tPools.free(event);\n\t\treturn handled;\n\t}","commit_id":"9f42296daf6ffe03f0af7b8ff6d7c0c911dbce19","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void fireEvent( Model model, ModelBuildingRequest request, ModelProblemCollector problems,\n                            ModelBuildingEventCatapult catapult )\n        throws ModelBuildingException\n    {\n        List<ModelBuildingListener> listeners = request.getModelBuildingListeners();\n\n        if ( !listeners.isEmpty() )\n        {\n            ModelBuildingEvent event = new DefaultModelBuildingEvent( model, request, problems );\n\n            for ( ModelBuildingListener listener : listeners )\n            {\n                catapult.fire( listener, event );\n            }\n        }\n    }","id":35208,"modified_method":"private void fireEvent( Model model, ModelBuildingRequest request, ModelProblemCollector problems,\n                            ModelBuildingEventCatapult catapult )\n        throws ModelBuildingException\n    {\n        ModelBuildingListener listener = request.getModelBuildingListener();\n\n        if ( listener != null )\n        {\n            ModelBuildingEvent event = new DefaultModelBuildingEvent( model, request, problems );\n\n            catapult.fire( listener, event );\n        }\n    }","commit_id":"1e33cb56fe48d66e09e29f298a35a35f8c15c204","url":"https://github.com/apache/maven"},{"original_method":"public ModelBuildingRequest setModelBuildingListeners( List<? extends ModelBuildingListener> modelBuildingListeners )\n    {\n        if ( modelBuildingListeners != null )\n        {\n            this.modelBuildingListeners = new ArrayList<ModelBuildingListener>( modelBuildingListeners );\n        }\n        else\n        {\n            this.modelBuildingListeners = null;\n        }\n\n        return this;\n    }","id":35209,"modified_method":"public ModelBuildingRequest setModelBuildingListener( ModelBuildingListener modelBuildingListener )\n    {\n        this.modelBuildingListener = modelBuildingListener;\n\n        return this;\n    }","commit_id":"1e33cb56fe48d66e09e29f298a35a35f8c15c204","url":"https://github.com/apache/maven"},{"original_method":"public List<ModelBuildingListener> getModelBuildingListeners()\n    {\n        if ( modelBuildingListeners == null )\n        {\n            modelBuildingListeners = new ArrayList<ModelBuildingListener>();\n        }\n\n        return modelBuildingListeners;\n    }","id":35210,"modified_method":"public ModelBuildingListener getModelBuildingListener()\n    {\n        return modelBuildingListener;\n    }","commit_id":"1e33cb56fe48d66e09e29f298a35a35f8c15c204","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * This is used for pom-less execution like running archetype:generate.\n     * \n     * I am taking out the profile handling and the interpolation of the base directory until we\n     * spec this out properly.\n     */\n    public ProjectBuildingResult buildStandaloneSuperProject( ProjectBuildingRequest config )\n        throws ProjectBuildingException\n    {\n        ModelBuildingRequest request = getModelBuildingRequest( config, null );\n\n        DefaultModelBuildingListener listener = new DefaultModelBuildingListener( projectBuildingHelper, config );\n        request.setModelBuildingListeners( Arrays.asList( listener ) );\n\n        request.setModelSource( new UrlModelSource( getClass().getResource( \"standalone.xml\" ) ) );\n\n        ModelBuildingResult result;\n        try\n        {\n            result = modelBuilder.build( request );\n        }\n        catch ( ModelBuildingException e )\n        {\n            throw new ProjectBuildingException( \"[standalone]\", \"Failed to build standalone project\", e );\n        }\n\n        MavenProject standaloneProject = new MavenProject( result.getEffectiveModel(), repositorySystem, this, config );\n\n        standaloneProject.setActiveProfiles( result.getActiveExternalProfiles() );\n        standaloneProject.setInjectedProfileIds( \"external\", getProfileIds( result.getActiveExternalProfiles() ) );\n        standaloneProject.setRemoteArtifactRepositories( listener.getRemoteRepositories() );\n        standaloneProject.setPluginArtifactRepositories( listener.getPluginRepositories() );\n\n        standaloneProject.setExecutionRoot( true );\n\n        return new DefaultProjectBuildingResult( standaloneProject, result.getProblems(), null );\n    }","id":35211,"modified_method":"/**\n     * This is used for pom-less execution like running archetype:generate.\n     * \n     * I am taking out the profile handling and the interpolation of the base directory until we\n     * spec this out properly.\n     */\n    public ProjectBuildingResult buildStandaloneSuperProject( ProjectBuildingRequest config )\n        throws ProjectBuildingException\n    {\n        ModelBuildingRequest request = getModelBuildingRequest( config, null );\n\n        DefaultModelBuildingListener listener = new DefaultModelBuildingListener( projectBuildingHelper, config );\n        request.setModelBuildingListener( listener );\n\n        request.setModelSource( new UrlModelSource( getClass().getResource( \"standalone.xml\" ) ) );\n\n        ModelBuildingResult result;\n        try\n        {\n            result = modelBuilder.build( request );\n        }\n        catch ( ModelBuildingException e )\n        {\n            throw new ProjectBuildingException( \"[standalone]\", \"Failed to build standalone project\", e );\n        }\n\n        MavenProject standaloneProject = new MavenProject( result.getEffectiveModel(), repositorySystem, this, config );\n\n        standaloneProject.setActiveProfiles( result.getActiveExternalProfiles() );\n        standaloneProject.setInjectedProfileIds( \"external\", getProfileIds( result.getActiveExternalProfiles() ) );\n        standaloneProject.setRemoteArtifactRepositories( listener.getRemoteRepositories() );\n        standaloneProject.setPluginArtifactRepositories( listener.getPluginRepositories() );\n\n        standaloneProject.setExecutionRoot( true );\n\n        return new DefaultProjectBuildingResult( standaloneProject, result.getProblems(), null );\n    }","commit_id":"1e33cb56fe48d66e09e29f298a35a35f8c15c204","url":"https://github.com/apache/maven"},{"original_method":"private ProjectBuildingResult build( File pomFile, boolean localProject, ProjectBuildingRequest configuration )\n        throws ProjectBuildingException\n    {\n\n        ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();\n\n        try\n        {\n            MavenProject project = configuration.getProject();\n\n            List<ModelProblem> modelProblems = null;\n\n            if ( project == null )\n            {\n                ModelBuildingRequest request = getModelBuildingRequest( configuration, null );\n    \n                DefaultModelBuildingListener listener = new DefaultModelBuildingListener( projectBuildingHelper, configuration );\n                request.setModelBuildingListeners( Arrays.asList( listener ) );\n    \n                if ( localProject )\n                {\n                    request.setPomFile( pomFile );\n                }\n                else\n                {\n                    request.setModelSource( new FileModelSource( pomFile ) );\n                }\n    \n                ModelBuildingResult result;\n                try\n                {\n                    result = modelBuilder.build( request );\n                }\n                catch ( ModelBuildingException e )\n                {\n                    throw new ProjectBuildingException( e.getModelId(), e.getMessage(), pomFile, e );\n                }\n\n                modelProblems = result.getProblems();\n\n                project = toProject( result, configuration, listener );\n            }\n\n            if ( configuration.isProcessPlugins() && configuration.isProcessPluginConfiguration() )\n            {\n                RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();\n                repositoryRequest.setLocalRepository( configuration.getLocalRepository() );\n                repositoryRequest.setRemoteRepositories( project.getPluginArtifactRepositories() );\n                repositoryRequest.setCache( configuration.getRepositoryCache() );\n                repositoryRequest.setOffline( configuration.isOffline() );\n\n                for ( Plugin plugin : project.getBuildPlugins() )\n                {\n                    try\n                    {\n                        lifecycle.populateDefaultConfigurationForPlugin( plugin, repositoryRequest );\n                    }\n                    catch ( LifecycleExecutionException e )\n                    {\n                        if ( modelProblems == null )\n                        {\n                            modelProblems = new ArrayList<ModelProblem>();\n                        }\n\n                        modelProblems.add( new DefaultModelProblem( e.getMessage(), ModelProblem.Severity.WARNING,\n                                                                    project.getModel(), e ) );\n                    }\n                }\n            }\n\n            ArtifactResolutionResult artifactResult = null;\n\n            if ( configuration.isResolveDependencies() )\n            {\n                Artifact artifact = new ProjectArtifact( project );\n\n                ArtifactResolutionRequest artifactRequest = new ArtifactResolutionRequest()\n                    .setArtifact( artifact )\n                    .setResolveRoot( false )\n                    .setResolveTransitively( true )\n                    .setCache( configuration.getRepositoryCache() )\n                    .setLocalRepository( configuration.getLocalRepository() )\n                    .setRemoteRepositories( project.getRemoteArtifactRepositories() )\n                    .setOffline( configuration.isOffline() )\n                    .setManagedVersionMap( project.getManagedVersionMap() );\n                // FIXME setTransferListener\n\n                artifactResult = repositorySystem.resolve( artifactRequest );\n\n                project.setArtifacts( artifactResult.getArtifacts() );\n            }\n\n            return new DefaultProjectBuildingResult( project, modelProblems, artifactResult );\n        }\n        finally\n        {\n            Thread.currentThread().setContextClassLoader( oldContextClassLoader );\n        }\n    }","id":35212,"modified_method":"private ProjectBuildingResult build( File pomFile, boolean localProject, ProjectBuildingRequest configuration )\n        throws ProjectBuildingException\n    {\n\n        ClassLoader oldContextClassLoader = Thread.currentThread().getContextClassLoader();\n\n        try\n        {\n            MavenProject project = configuration.getProject();\n\n            List<ModelProblem> modelProblems = null;\n\n            if ( project == null )\n            {\n                ModelBuildingRequest request = getModelBuildingRequest( configuration, null );\n    \n                DefaultModelBuildingListener listener = new DefaultModelBuildingListener( projectBuildingHelper, configuration );\n                request.setModelBuildingListener( listener );\n    \n                if ( localProject )\n                {\n                    request.setPomFile( pomFile );\n                }\n                else\n                {\n                    request.setModelSource( new FileModelSource( pomFile ) );\n                }\n    \n                ModelBuildingResult result;\n                try\n                {\n                    result = modelBuilder.build( request );\n                }\n                catch ( ModelBuildingException e )\n                {\n                    throw new ProjectBuildingException( e.getModelId(), e.getMessage(), pomFile, e );\n                }\n\n                modelProblems = result.getProblems();\n\n                project = toProject( result, configuration, listener );\n            }\n\n            if ( configuration.isProcessPlugins() && configuration.isProcessPluginConfiguration() )\n            {\n                RepositoryRequest repositoryRequest = new DefaultRepositoryRequest();\n                repositoryRequest.setLocalRepository( configuration.getLocalRepository() );\n                repositoryRequest.setRemoteRepositories( project.getPluginArtifactRepositories() );\n                repositoryRequest.setCache( configuration.getRepositoryCache() );\n                repositoryRequest.setOffline( configuration.isOffline() );\n\n                for ( Plugin plugin : project.getBuildPlugins() )\n                {\n                    try\n                    {\n                        lifecycle.populateDefaultConfigurationForPlugin( plugin, repositoryRequest );\n                    }\n                    catch ( LifecycleExecutionException e )\n                    {\n                        if ( modelProblems == null )\n                        {\n                            modelProblems = new ArrayList<ModelProblem>();\n                        }\n\n                        modelProblems.add( new DefaultModelProblem( e.getMessage(), ModelProblem.Severity.WARNING,\n                                                                    project.getModel(), e ) );\n                    }\n                }\n            }\n\n            ArtifactResolutionResult artifactResult = null;\n\n            if ( configuration.isResolveDependencies() )\n            {\n                Artifact artifact = new ProjectArtifact( project );\n\n                ArtifactResolutionRequest artifactRequest = new ArtifactResolutionRequest()\n                    .setArtifact( artifact )\n                    .setResolveRoot( false )\n                    .setResolveTransitively( true )\n                    .setCache( configuration.getRepositoryCache() )\n                    .setLocalRepository( configuration.getLocalRepository() )\n                    .setRemoteRepositories( project.getRemoteArtifactRepositories() )\n                    .setOffline( configuration.isOffline() )\n                    .setManagedVersionMap( project.getManagedVersionMap() );\n                // FIXME setTransferListener\n\n                artifactResult = repositorySystem.resolve( artifactRequest );\n\n                project.setArtifacts( artifactResult.getArtifacts() );\n            }\n\n            return new DefaultProjectBuildingResult( project, modelProblems, artifactResult );\n        }\n        finally\n        {\n            Thread.currentThread().setContextClassLoader( oldContextClassLoader );\n        }\n    }","commit_id":"1e33cb56fe48d66e09e29f298a35a35f8c15c204","url":"https://github.com/apache/maven"},{"original_method":"private boolean build( List<ProjectBuildingResult> results, List<InterimResult> interimResults,\n                           List<File> pomFiles, boolean isRoot, boolean recursive, ProjectBuildingRequest config,\n                           ReactorModelPool reactorModelPool, ReactorModelCache modelCache )\n    {\n        boolean errors = false;\n\n        for ( File pomFile : pomFiles )\n        {\n            ModelBuildingRequest request = getModelBuildingRequest( config, reactorModelPool );\n\n            request.setPomFile( pomFile );\n            request.setTwoPhaseBuilding( true );\n            request.setModelCache( modelCache );\n\n            DefaultModelBuildingListener listener = new DefaultModelBuildingListener( projectBuildingHelper, config );\n            request.setModelBuildingListeners( Arrays.asList( listener ) );\n\n            try\n            {\n                ModelBuildingResult result = modelBuilder.build( request );\n\n                Model model = result.getEffectiveModel();\n\n                interimResults.add( new InterimResult( pomFile, request, result, listener, isRoot ) );\n\n                if ( recursive && !model.getModules().isEmpty() )\n                {\n                    File basedir = pomFile.getParentFile();\n\n                    List<File> moduleFiles = new ArrayList<File>();\n\n                    for ( String module : model.getModules() )\n                    {\n                        if ( StringUtils.isEmpty( module ) )\n                        {\n                            continue;\n                        }\n\n                        File moduleFile = new File( basedir, module );\n\n                        if ( moduleFile.isDirectory() )\n                        {\n                            moduleFile = new File( moduleFile, Maven.POMv4 );\n                        }\n\n                        if ( !moduleFile.isFile() )\n                        {\n                            ModelProblem problem =\n                                new DefaultModelProblem( \"Child module \" + moduleFile + \" of \" + pomFile\n                                    + \" does not exist\", ModelProblem.Severity.ERROR, model );\n                            result.getProblems().add( problem );\n\n                            errors = true;\n\n                            continue;\n                        }\n\n                        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n                        {\n                            // we don't canonicalize on unix to avoid interfering with symlinks\n                            try\n                            {\n                                moduleFile = moduleFile.getCanonicalFile();\n                            }\n                            catch ( IOException e )\n                            {\n                                moduleFile = moduleFile.getAbsoluteFile();\n                            }\n                        }\n                        else\n                        {\n                            moduleFile = new File( moduleFile.toURI().normalize() );\n                        }\n\n                        moduleFiles.add( moduleFile );\n                    }\n\n                    if ( build( results, interimResults, moduleFiles, false, recursive, config, reactorModelPool,\n                                 modelCache ) )\n                    {\n                        errors = true;\n                    }\n                }\n            }\n            catch ( ModelBuildingException e )\n            {\n                results.add( new DefaultProjectBuildingResult( e.getModelId(), pomFile, e.getProblems() ) );\n\n                errors = true;\n            }\n        }\n\n        return errors;\n    }","id":35213,"modified_method":"private boolean build( List<ProjectBuildingResult> results, List<InterimResult> interimResults,\n                           List<File> pomFiles, boolean isRoot, boolean recursive, ProjectBuildingRequest config,\n                           ReactorModelPool reactorModelPool, ReactorModelCache modelCache )\n    {\n        boolean errors = false;\n\n        for ( File pomFile : pomFiles )\n        {\n            ModelBuildingRequest request = getModelBuildingRequest( config, reactorModelPool );\n\n            request.setPomFile( pomFile );\n            request.setTwoPhaseBuilding( true );\n            request.setModelCache( modelCache );\n\n            DefaultModelBuildingListener listener = new DefaultModelBuildingListener( projectBuildingHelper, config );\n            request.setModelBuildingListener( listener );\n\n            try\n            {\n                ModelBuildingResult result = modelBuilder.build( request );\n\n                Model model = result.getEffectiveModel();\n\n                interimResults.add( new InterimResult( pomFile, request, result, listener, isRoot ) );\n\n                if ( recursive && !model.getModules().isEmpty() )\n                {\n                    File basedir = pomFile.getParentFile();\n\n                    List<File> moduleFiles = new ArrayList<File>();\n\n                    for ( String module : model.getModules() )\n                    {\n                        if ( StringUtils.isEmpty( module ) )\n                        {\n                            continue;\n                        }\n\n                        File moduleFile = new File( basedir, module );\n\n                        if ( moduleFile.isDirectory() )\n                        {\n                            moduleFile = new File( moduleFile, Maven.POMv4 );\n                        }\n\n                        if ( !moduleFile.isFile() )\n                        {\n                            ModelProblem problem =\n                                new DefaultModelProblem( \"Child module \" + moduleFile + \" of \" + pomFile\n                                    + \" does not exist\", ModelProblem.Severity.ERROR, model );\n                            result.getProblems().add( problem );\n\n                            errors = true;\n\n                            continue;\n                        }\n\n                        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n                        {\n                            // we don't canonicalize on unix to avoid interfering with symlinks\n                            try\n                            {\n                                moduleFile = moduleFile.getCanonicalFile();\n                            }\n                            catch ( IOException e )\n                            {\n                                moduleFile = moduleFile.getAbsoluteFile();\n                            }\n                        }\n                        else\n                        {\n                            moduleFile = new File( moduleFile.toURI().normalize() );\n                        }\n\n                        moduleFiles.add( moduleFile );\n                    }\n\n                    if ( build( results, interimResults, moduleFiles, false, recursive, config, reactorModelPool,\n                                 modelCache ) )\n                    {\n                        errors = true;\n                    }\n                }\n            }\n            catch ( ModelBuildingException e )\n            {\n                results.add( new DefaultProjectBuildingResult( e.getModelId(), pomFile, e.getProblems() ) );\n\n                errors = true;\n            }\n        }\n\n        return errors;\n    }","commit_id":"1e33cb56fe48d66e09e29f298a35a35f8c15c204","url":"https://github.com/apache/maven"},{"original_method":"private Actor fireEnterAndExit (Actor overLast, int screenX, int screenY, int pointer) {\n\t\t// Find the actor under the point.\n\t\tscreenToStageCoordinates(tempCoords.set(screenX, screenY));\n\t\tActor over = hit(tempCoords.x, tempCoords.y, true);\n\t\tif (over == overLast) return overLast;\n\n\t\tInputEvent event = Pools.obtain(InputEvent.class);\n\t\tevent.setStage(this);\n\t\tevent.setStageX(tempCoords.x);\n\t\tevent.setStageY(tempCoords.y);\n\t\tevent.setPointer(pointer);\n\t\t// Exit overLast.\n\t\tif (overLast != null) {\n\t\t\tevent.setType(InputEvent.Type.exit);\n\t\t\tevent.setRelatedActor(over);\n\t\t\toverLast.fire(event);\n\t\t}\n\t\t// Enter over.\n\t\tif (over != null) {\n\t\t\tevent.setType(InputEvent.Type.enter);\n\t\t\tevent.setRelatedActor(overLast);\n\t\t\tover.fire(event);\n\t\t}\n\t\tPools.free(event);\n\t\treturn over;\n\t}","id":35214,"modified_method":"private Actor fireEnterAndExit (Actor overLast, int screenX, int screenY, int pointer) {\n\t\t// Find the actor under the point.\n\t\tscreenToStageCoordinates(tempCoords.set(screenX, screenY));\n\t\tActor over = hit(tempCoords.x, tempCoords.y, true);\n\t\tif (over == overLast) return overLast;\n\n\t\t// Exit overLast.\n\t\tif (overLast != null) {\n\t\t\tInputEvent event = Pools.obtain(InputEvent.class);\n\t\t\tevent.setStage(this);\n\t\t\tevent.setStageX(tempCoords.x);\n\t\t\tevent.setStageY(tempCoords.y);\n\t\t\tevent.setPointer(pointer);\n\t\t\tevent.setType(InputEvent.Type.exit);\n\t\t\tevent.setRelatedActor(over);\n\t\t\toverLast.fire(event);\n\t\t\tPools.free(event);\n\t\t}\n\t\t// Enter over.\n\t\tif (over != null) {\n\t\t\tInputEvent event = Pools.obtain(InputEvent.class);\n\t\t\tevent.setStage(this);\n\t\t\tevent.setStageX(tempCoords.x);\n\t\t\tevent.setStageY(tempCoords.y);\n\t\t\tevent.setPointer(pointer);\n\t\t\tevent.setType(InputEvent.Type.enter);\n\t\t\tevent.setRelatedActor(overLast);\n\t\t\tover.fire(event);\n\t\t\tPools.free(event);\n\t\t}\n\t\treturn over;\n\t}","commit_id":"558ea89ccb917903e6fdf35039ea150168154374","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void initialize () {\n\t\tsetModal(true);\n\n\t\tdefaults().space(6);\n\t\tadd(contentTable = new Table(skin)).expand().fill();\n\t\trow();\n\t\tadd(buttonTable = new Table(skin));\n\n\t\tcontentTable.defaults().space(6);\n\t\tbuttonTable.defaults().space(6);\n\n\t\tbuttonTable.addListener(new ChangeListener() {\n\t\t\tpublic void changed (ChangeEvent event, Actor actor) {\n\t\t\t\twhile (actor.getParent() != buttonTable)\n\t\t\t\t\tactor = actor.getParent();\n\t\t\t\tresult(values.get(actor));\n\t\t\t\tif (!cancelHide) hide();\n\t\t\t\tcancelHide = false;\n\t\t\t}\n\t\t});\n\n\t\taddListener(new FocusListener() {\n\t\t\tpublic void keyboardFocusChanged (FocusEvent event, Actor actor, boolean focused) {\n\t\t\t\tif (!focused) {\n\t\t\t\t\tStage stage = getStage();\n\t\t\t\t\tif (isModal && stage.getRoot().getChildren().peek() == Dialog.this) { // This dialog is the top most actor.\n\t\t\t\t\t\tif (!event.getRelatedActor().isDescendantOf(Dialog.this)) event.cancel();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic void scrollFocusChanged (FocusEvent event, Actor actor, boolean focused) {\n\n\t\t\t}\n\t\t});\n\t}","id":35215,"modified_method":"private void initialize () {\n\t\tsetModal(true);\n\n\t\tdefaults().space(6);\n\t\tadd(contentTable = new Table(skin)).expand().fill();\n\t\trow();\n\t\tadd(buttonTable = new Table(skin));\n\n\t\tcontentTable.defaults().space(6);\n\t\tbuttonTable.defaults().space(6);\n\n\t\tbuttonTable.addListener(new ChangeListener() {\n\t\t\tpublic void changed (ChangeEvent event, Actor actor) {\n\t\t\t\twhile (actor.getParent() != buttonTable)\n\t\t\t\t\tactor = actor.getParent();\n\t\t\t\tresult(values.get(actor));\n\t\t\t\tif (!cancelHide) hide();\n\t\t\t\tcancelHide = false;\n\t\t\t}\n\t\t});\n\n\t\taddListener(new FocusListener() {\n\t\t\tpublic void keyboardFocusChanged (FocusEvent event, Actor actor, boolean focused) {\n\t\t\t\tif (!focused) focusChanged(event);\n\t\t\t}\n\n\t\t\tpublic void scrollFocusChanged (FocusEvent event, Actor actor, boolean focused) {\n\t\t\t\tif (!focused) focusChanged(event);\n\t\t\t}\n\n\t\t\tprivate void focusChanged (FocusEvent event) {\n\t\t\t\tStage stage = getStage();\n\t\t\t\tif (isModal && stage.getRoot().getChildren().peek() == Dialog.this) { // This dialog is the top most actor.\n\t\t\t\t\tActor newFocusedActor = event.getRelatedActor();\n\t\t\t\t\tif (newFocusedActor == null || !newFocusedActor.isDescendantOf(Dialog.this)) event.cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}","commit_id":"d66cf0a8596bc8f23ee39fb0b46759710d589a2b","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Sets the actor that will receive scroll events.\r\n\t * @param actor May be null. */\r\n\tpublic void setScrollFocus (Actor actor) {\r\n\t\tif (scrollFocus == actor) return;\r\n\t\tFocusEvent event = Pools.obtain(FocusEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(FocusEvent.Type.scroll);\r\n\t\tif (scrollFocus != null) {\r\n\t\t\tevent.setFocused(false);\r\n\t\t\tscrollFocus.fire(event);\r\n\t\t}\r\n\t\tscrollFocus = actor;\r\n\t\tif (scrollFocus != null) {\r\n\t\t\tevent.setFocused(true);\r\n\t\t\tscrollFocus.fire(event);\r\n\t\t}\r\n\t\tPools.free(event);\r\n\t}","id":35216,"modified_method":"/** Sets the actor that will receive scroll events.\r\n\t * @param actor May be null. */\r\n\tpublic void setScrollFocus (Actor actor) {\r\n\t\tif (scrollFocus == actor) return;\r\n\t\tFocusEvent event = Pools.obtain(FocusEvent.class);\r\n\t\tevent.setStage(this);\r\n\t\tevent.setType(FocusEvent.Type.scroll);\r\n\t\tActor oldScrollFocus = keyboardFocus;\r\n\t\tif (oldScrollFocus != null) {\r\n\t\t\tevent.setFocused(false);\r\n\t\t\tevent.setRelatedActor(actor);\r\n\t\t\toldScrollFocus.fire(event);\r\n\t\t}\r\n\t\tif (!event.isCancelled()) {\r\n\t\t\tscrollFocus = actor;\r\n\t\t\tif (actor != null) {\r\n\t\t\t\tevent.setFocused(true);\r\n\t\t\t\tevent.setRelatedActor(oldScrollFocus);\r\n\t\t\t\tactor.fire(event);\r\n\t\t\t\tif (event.isCancelled()) setScrollFocus(oldScrollFocus);\r\n\t\t\t}\r\n\t\t}\r\n\t\tPools.free(event);\r\n\t}","commit_id":"d66cf0a8596bc8f23ee39fb0b46759710d589a2b","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void checkout(BuildListener listener) throws Exception {\n            try {\n                for (int retryCount=project.getScmCheckoutRetryCount(); ; retryCount--) {\n                    // for historical reasons, null in the scm field means CVS, so we need to explicitly set this to something\n                    // in case check out fails and leaves a broken changelog.xml behind.\n                    // see http://www.nabble.com/CVSChangeLogSet.parse-yields-SAXParseExceptions-when-parsing-bad-*AccuRev*-changelog.xml-files-td22213663.html\n                    AbstractBuild.this.scm = new NullChangeLogParser();\n\n                    try {\n                        if (project.checkout(AbstractBuild.this,launcher,listener,new File(getRootDir(),\"changelog.xml\"))) {\n                            // check out succeeded\n                            SCM scm = project.getScm();\n\n                            AbstractBuild.this.scm = scm.createChangeLogParser();\n                            AbstractBuild.this.changeSet = AbstractBuild.this.calcChangeSet();\n\n                            for (SCMListener l : Jenkins.getInstance().getSCMListeners())\n                                l.onChangeLogParsed(AbstractBuild.this,listener,changeSet);\n                            return;\n                        }\n                    } catch (AbortException e) {\n                        listener.error(e.getMessage());\n                    } catch (IOException e) {\n                        // checkout error not yet reported\n                        e.printStackTrace(listener.getLogger());\n                    }\n\n                    if (retryCount == 0)   // all attempts failed\n                        throw new RunnerAbortedException();\n\n                    listener.getLogger().println(\"Retrying after 10 seconds\");\n                    Thread.sleep(10000);\n                }\n            } catch (InterruptedException e) {\n                listener.getLogger().println(Messages.AbstractProject_ScmAborted());\n                LOGGER.log(Level.INFO, AbstractBuild.this + \" aborted\", e);\n                throw new RunnerAbortedException();\n            }\n        }","id":35217,"modified_method":"private void checkout(BuildListener listener) throws Exception {\n            try {\n                for (int retryCount=project.getScmCheckoutRetryCount(); ; retryCount--) {\n                    // for historical reasons, null in the scm field means CVS, so we need to explicitly set this to something\n                    // in case check out fails and leaves a broken changelog.xml behind.\n                    // see http://www.nabble.com/CVSChangeLogSet.parse-yields-SAXParseExceptions-when-parsing-bad-*AccuRev*-changelog.xml-files-td22213663.html\n                    AbstractBuild.this.scm = new NullChangeLogParser();\n\n                    try {\n                        if (project.checkout(AbstractBuild.this,launcher,listener,new File(getRootDir(),\"changelog.xml\"))) {\n                            // check out succeeded\n                            SCM scm = project.getScm();\n\n                            AbstractBuild.this.scm = scm.createChangeLogParser();\n                            ChangeLogSet<? extends Entry> cs = AbstractBuild.this.calcChangeSet();\n                            AbstractBuild.this.changeSet = new SoftReference(cs);\n\n                            for (SCMListener l : Jenkins.getInstance().getSCMListeners())\n                                l.onChangeLogParsed(AbstractBuild.this,listener,cs);\n                            return;\n                        }\n                    } catch (AbortException e) {\n                        listener.error(e.getMessage());\n                    } catch (IOException e) {\n                        // checkout error not yet reported\n                        e.printStackTrace(listener.getLogger());\n                    }\n\n                    if (retryCount == 0)   // all attempts failed\n                        throw new RunnerAbortedException();\n\n                    listener.getLogger().println(\"Retrying after 10 seconds\");\n                    Thread.sleep(10000);\n                }\n            } catch (InterruptedException e) {\n                listener.getLogger().println(Messages.AbstractProject_ScmAborted());\n                LOGGER.log(Level.INFO, AbstractBuild.this + \" aborted\", e);\n                throw new RunnerAbortedException();\n            }\n        }","commit_id":"f4b68262cef98b7b043d8100686e6c83980b4a4c","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Gets the changes incorporated into this build.\n     *\n     * @return never null.\n     */\n    @Exported\n    public ChangeLogSet<? extends Entry> getChangeSet() {\n        if (scm==null) {\n            // for historical reason, null means CVS.\n            try {\n                Class<?> c = Jenkins.getInstance().getPluginManager().uberClassLoader.loadClass(\"hudson.scm.CVSChangeLogParser\");\n                scm = (ChangeLogParser)c.newInstance();\n            } catch (ClassNotFoundException e) {\n                // if CVS isn't available, fall back to something non-null.\n                scm = new NullChangeLogParser();\n            } catch (InstantiationException e) {\n                scm = new NullChangeLogParser();\n                throw (Error)new InstantiationError().initCause(e);\n            } catch (IllegalAccessException e) {\n                scm = new NullChangeLogParser();\n                throw (Error)new IllegalAccessError().initCause(e);\n            }\n        }\n\n        if (changeSet==null) // cached value\n            try {\n                changeSet = calcChangeSet();\n            } finally {\n                // defensive check. if the calculation fails (such as through an exception),\n                // set a dummy value so that it'll work the next time. the exception will\n                // be still reported, giving the plugin developer an opportunity to fix it.\n                if (changeSet==null)\n                    changeSet=ChangeLogSet.createEmpty(this);\n            }\n        return changeSet;\n    }","id":35218,"modified_method":"/**\n     * Gets the changes incorporated into this build.\n     *\n     * @return never null.\n     */\n    @Exported\n    public ChangeLogSet<? extends Entry> getChangeSet() {\n        synchronized (changeSetLock) {\n            if (scm==null) {\n                // for historical reason, null means CVS.\n                try {\n                    Class<?> c = Jenkins.getInstance().getPluginManager().uberClassLoader.loadClass(\"hudson.scm.CVSChangeLogParser\");\n                    scm = (ChangeLogParser)c.newInstance();\n                } catch (ClassNotFoundException e) {\n                    // if CVS isn't available, fall back to something non-null.\n                    scm = NullChangeLogParser.INSTANCE;\n                } catch (InstantiationException e) {\n                    scm = NullChangeLogParser.INSTANCE;\n                    throw (Error)new InstantiationError().initCause(e);\n                } catch (IllegalAccessException e) {\n                    scm = NullChangeLogParser.INSTANCE;\n                    throw (Error)new IllegalAccessError().initCause(e);\n                }\n            }\n    \n            ChangeLogSet result = changeSet != null ? changeSet.get() : null;\n            if (result == null) {\n                try {\n                    result = calcChangeSet();\n                } finally {\n                    // defensive check. if the calculation fails (such as through an exception),\n                    // set a dummy value so that it'll work the next time. the exception will\n                    // be still reported, giving the plugin developer an opportunity to fix it.\n                    if (result == null) {\n                        result = ChangeLogSet.createEmpty(this);\n                    }\n                }\n                changeSet = new WeakReference<ChangeLogSet<? extends Entry>>(result);\n            }\n            return result;\n        }\n    }","commit_id":"f4b68262cef98b7b043d8100686e6c83980b4a4c","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Gets the changes incorporated into this build.\n     *\n     * @return never null.\n     */\n    @Exported\n    public ChangeLogSet<? extends Entry> getChangeSet() {\n        if (scm==null) {\n            // for historical reason, null means CVS.\n            try {\n                Class<?> c = Jenkins.getInstance().getPluginManager().uberClassLoader.loadClass(\"hudson.scm.CVSChangeLogParser\");\n                scm = (ChangeLogParser)c.newInstance();\n            } catch (ClassNotFoundException e) {\n                // if CVS isn't available, fall back to something non-null.\n                scm = new NullChangeLogParser();\n            } catch (InstantiationException e) {\n                scm = new NullChangeLogParser();\n                throw (Error)new InstantiationError().initCause(e);\n            } catch (IllegalAccessException e) {\n                scm = new NullChangeLogParser();\n                throw (Error)new IllegalAccessError().initCause(e);\n            }\n        }\n\n        if (changeSet==null) // cached value\n            try {\n                changeSet = calcChangeSet();\n            } finally {\n                // defensive check. if the calculation fails (such as through an exception),\n                // set a dummy value so that it'll work the next time. the exception will\n                // be still reported, giving the plugin developer an opportunity to fix it.\n                if (changeSet==null)\n                    changeSet=ChangeLogSet.createEmpty(this);\n            }\n        return changeSet;\n    }","id":35219,"modified_method":"/**\n     * Gets the changes incorporated into this build.\n     *\n     * @return never null.\n     */\n    @Exported\n    public ChangeLogSet<? extends Entry> getChangeSet() {\n        if (scm==null) {\n            // for historical reason, null means CVS.\n            try {\n                Class<?> c = Jenkins.getInstance().getPluginManager().uberClassLoader.loadClass(\"hudson.scm.CVSChangeLogParser\");\n                scm = (ChangeLogParser)c.newInstance();\n            } catch (ClassNotFoundException e) {\n                // if CVS isn't available, fall back to something non-null.\n                scm = new NullChangeLogParser();\n            } catch (InstantiationException e) {\n                scm = new NullChangeLogParser();\n                throw (Error)new InstantiationError().initCause(e);\n            } catch (IllegalAccessException e) {\n                scm = new NullChangeLogParser();\n                throw (Error)new IllegalAccessError().initCause(e);\n            }\n        }\n\n        if (changeSet == null || changeSet.get() == null) // cached value\n            try {\n                changeSet = new WeakReference<ChangeLogSet<? extends Entry>>(calcChangeSet());\n            } finally {\n                // defensive check. if the calculation fails (such as through an exception),\n                // set a dummy value so that it'll work the next time. the exception will\n                // be still reported, giving the plugin developer an opportunity to fix it.\n                if (changeSet==null)\n                    changeSet=new WeakReference<ChangeLogSet<? extends Entry>>(ChangeLogSet.createEmpty(this));\n            }\n        return changeSet.get();\n    }","commit_id":"f30aa47615d2ae84b6de2c2e171c142f4425c67a","url":"https://github.com/kohsuke/hudson"},{"original_method":"private void checkout(BuildListener listener) throws Exception {\n            try {\n                for (int retryCount=project.getScmCheckoutRetryCount(); ; retryCount--) {\n                    // for historical reasons, null in the scm field means CVS, so we need to explicitly set this to something\n                    // in case check out fails and leaves a broken changelog.xml behind.\n                    // see http://www.nabble.com/CVSChangeLogSet.parse-yields-SAXParseExceptions-when-parsing-bad-*AccuRev*-changelog.xml-files-td22213663.html\n                    AbstractBuild.this.scm = new NullChangeLogParser();\n\n                    try {\n                        if (project.checkout(AbstractBuild.this,launcher,listener,new File(getRootDir(),\"changelog.xml\"))) {\n                            // check out succeeded\n                            SCM scm = project.getScm();\n\n                            AbstractBuild.this.scm = scm.createChangeLogParser();\n                            AbstractBuild.this.changeSet = AbstractBuild.this.calcChangeSet();\n\n                            for (SCMListener l : Jenkins.getInstance().getSCMListeners())\n                                l.onChangeLogParsed(AbstractBuild.this,listener,changeSet);\n                            return;\n                        }\n                    } catch (AbortException e) {\n                        listener.error(e.getMessage());\n                    } catch (IOException e) {\n                        // checkout error not yet reported\n                        e.printStackTrace(listener.getLogger());\n                    }\n\n                    if (retryCount == 0)   // all attempts failed\n                        throw new RunnerAbortedException();\n\n                    listener.getLogger().println(\"Retrying after 10 seconds\");\n                    Thread.sleep(10000);\n                }\n            } catch (InterruptedException e) {\n                listener.getLogger().println(Messages.AbstractProject_ScmAborted());\n                LOGGER.log(Level.INFO, AbstractBuild.this + \" aborted\", e);\n                throw new RunnerAbortedException();\n            }\n        }","id":35220,"modified_method":"private void checkout(BuildListener listener) throws Exception {\n            try {\n                for (int retryCount=project.getScmCheckoutRetryCount(); ; retryCount--) {\n                    // for historical reasons, null in the scm field means CVS, so we need to explicitly set this to something\n                    // in case check out fails and leaves a broken changelog.xml behind.\n                    // see http://www.nabble.com/CVSChangeLogSet.parse-yields-SAXParseExceptions-when-parsing-bad-*AccuRev*-changelog.xml-files-td22213663.html\n                    AbstractBuild.this.scm = new NullChangeLogParser();\n\n                    try {\n                        if (project.checkout(AbstractBuild.this,launcher,listener,new File(getRootDir(),\"changelog.xml\"))) {\n                            // check out succeeded\n                            SCM scm = project.getScm();\n\n                            AbstractBuild.this.scm = scm.createChangeLogParser();\n                            AbstractBuild.this.changeSet = new WeakReference<ChangeLogSet<? extends Entry>>(AbstractBuild.this.calcChangeSet());\n\n                            for (SCMListener l : Jenkins.getInstance().getSCMListeners())\n                                l.onChangeLogParsed(AbstractBuild.this,listener,getChangeSet());\n                            return;\n                        }\n                    } catch (AbortException e) {\n                        listener.error(e.getMessage());\n                    } catch (IOException e) {\n                        // checkout error not yet reported\n                        e.printStackTrace(listener.getLogger());\n                    }\n\n                    if (retryCount == 0)   // all attempts failed\n                        throw new RunnerAbortedException();\n\n                    listener.getLogger().println(\"Retrying after 10 seconds\");\n                    Thread.sleep(10000);\n                }\n            } catch (InterruptedException e) {\n                listener.getLogger().println(Messages.AbstractProject_ScmAborted());\n                LOGGER.log(Level.INFO, AbstractBuild.this + \" aborted\", e);\n                throw new RunnerAbortedException();\n            }\n        }","commit_id":"f30aa47615d2ae84b6de2c2e171c142f4425c67a","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n\t * Set the Hibernate CacheProvider to use for the SessionFactory.\n\t * Allows for using a Spring-managed CacheProvider instance.\n\t * <p>Note: If this is set, the Hibernate settings should not define a\n\t * cache provider to avoid meaningless double configuration.\n\t * @see LocalCacheProviderProxy\n\t */\n\tpublic void setCacheProvider(CacheProvider cacheProvider) {\n\t\tthis.cacheProvider = cacheProvider;\n\t}","id":35221,"modified_method":"/**\n\t * Set the Hibernate CacheProvider to use for the SessionFactory.\n\t * Allows for using a Spring-managed CacheProvider instance.\n\t * <p>Note: If this is set, the Hibernate settings should not define a\n\t * cache provider to avoid meaningless double configuration.\n\t * @deprecated as of Spring 3.0, following Hibernate 3.3's deprecation\n\t * of the CacheProvider SPI\n\t * @see #setCacheRegionFactory\n\t */\n\t@Deprecated\n\tpublic void setCacheProvider(CacheProvider cacheProvider) {\n\t\tthis.cacheProvider = cacheProvider;\n\t}","commit_id":"eb0b4f0cbd6d981e6864d4f02bc04b678be4cd1c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t@SuppressWarnings(\"unchecked\")\n\tprotected SessionFactory buildSessionFactory() throws Exception {\n\t\t// Create Configuration instance.\n\t\tConfiguration config = newConfiguration();\n\n\t\tDataSource dataSource = getDataSource();\n\t\tif (dataSource != null) {\n\t\t\t// Make given DataSource available for SessionFactory configuration.\n\t\t\tconfigTimeDataSourceHolder.set(dataSource);\n\t\t}\n\t\tif (this.jtaTransactionManager != null) {\n\t\t\t// Make Spring-provided JTA TransactionManager available.\n\t\t\tconfigTimeTransactionManagerHolder.set(this.jtaTransactionManager);\n\t\t}\n\t\tif (this.cacheProvider != null) {\n\t\t\t// Make Spring-provided Hibernate CacheProvider available.\n\t\t\tconfigTimeCacheProviderHolder.set(this.cacheProvider);\n\t\t}\n\t\tif (this.lobHandler != null) {\n\t\t\t// Make given LobHandler available for SessionFactory configuration.\n\t\t\t// Do early because because mapping resource might refer to custom types.\n\t\t\tconfigTimeLobHandlerHolder.set(this.lobHandler);\n\t\t}\n\n\t\t// Analogous to Hibernate EntityManager's Ejb3Configuration:\n\t\t// Hibernate doesn't allow setting the bean ClassLoader explicitly,\n\t\t// so we need to expose it as thread context ClassLoader accordingly.\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tboolean overrideClassLoader =\n\t\t\t\t(this.beanClassLoader != null && !this.beanClassLoader.equals(threadContextClassLoader));\n\t\tif (overrideClassLoader) {\n\t\t\tcurrentThread.setContextClassLoader(this.beanClassLoader);\n\t\t}\n\n\t\ttry {\n\t\t\tif (isExposeTransactionAwareSessionFactory()) {\n\t\t\t\t// Set Hibernate 3.1+ CurrentSessionContext implementation,\n\t\t\t\t// providing the Spring-managed Session as current Session.\n\t\t\t\t// Can be overridden by a custom value for the corresponding Hibernate property.\n\t\t\t\tconfig.setProperty(\n\t\t\t\t\t\tEnvironment.CURRENT_SESSION_CONTEXT_CLASS, SpringSessionContext.class.getName());\n\t\t\t}\n\n\t\t\tif (this.jtaTransactionManager != null) {\n\t\t\t\t// Set Spring-provided JTA TransactionManager as Hibernate property.\n\t\t\t\tconfig.setProperty(\n\t\t\t\t\t\tEnvironment.TRANSACTION_STRATEGY, JTATransactionFactory.class.getName());\n\t\t\t\tconfig.setProperty(\n\t\t\t\t\t\tEnvironment.TRANSACTION_MANAGER_STRATEGY, LocalTransactionManagerLookup.class.getName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Makes the Hibernate Session aware of the presence of a Spring-managed transaction.\n\t\t\t\t// Also sets connection release mode to ON_CLOSE by default.\n\t\t\t\tconfig.setProperty(\n\t\t\t\t\t\tEnvironment.TRANSACTION_STRATEGY, SpringTransactionFactory.class.getName());\n\t\t\t}\n\n\t\t\tif (this.entityInterceptor != null) {\n\t\t\t\t// Set given entity interceptor at SessionFactory level.\n\t\t\t\tconfig.setInterceptor(this.entityInterceptor);\n\t\t\t}\n\n\t\t\tif (this.namingStrategy != null) {\n\t\t\t\t// Pass given naming strategy to Hibernate Configuration.\n\t\t\t\tconfig.setNamingStrategy(this.namingStrategy);\n\t\t\t}\n\n\t\t\tif (this.typeDefinitions != null) {\n\t\t\t\t// Register specified Hibernate type definitions.\n\t\t\t\t// Use reflection for compatibility with both Hibernate 3.3 and 3.5:\n\t\t\t\t// the returned Mappings object changed from a class to an interface.\n\t\t\t\tMethod createMappings = Configuration.class.getMethod(\"createMappings\");\n\t\t\t\tMethod addTypeDef = createMappings.getReturnType().getMethod(\n\t\t\t\t\t\t\"addTypeDef\", String.class, String.class, Properties.class);\n\t\t\t\tObject mappings = ReflectionUtils.invokeMethod(createMappings, config);\n\t\t\t\tfor (TypeDefinitionBean typeDef : this.typeDefinitions) {\n\t\t\t\t\tReflectionUtils.invokeMethod(addTypeDef, mappings,\n\t\t\t\t\t\t\ttypeDef.getTypeName(), typeDef.getTypeClass(), typeDef.getParameters());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.filterDefinitions != null) {\n\t\t\t\t// Register specified Hibernate FilterDefinitions.\n\t\t\t\tfor (FilterDefinition filterDef : this.filterDefinitions) {\n\t\t\t\t\tconfig.addFilterDefinition(filterDef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.configLocations != null) {\n\t\t\t\tfor (Resource resource : this.configLocations) {\n\t\t\t\t\t// Load Hibernate configuration from given location.\n\t\t\t\t\tconfig.configure(resource.getURL());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.hibernateProperties != null) {\n\t\t\t\t// Add given Hibernate properties to Configuration.\n\t\t\t\tconfig.addProperties(this.hibernateProperties);\n\t\t\t}\n\n\t\t\tif (dataSource != null) {\n\t\t\t\tClass providerClass = LocalDataSourceConnectionProvider.class;\n\t\t\t\tif (isUseTransactionAwareDataSource() || dataSource instanceof TransactionAwareDataSourceProxy) {\n\t\t\t\t\tproviderClass = TransactionAwareDataSourceConnectionProvider.class;\n\t\t\t\t}\n\t\t\t\telse if (config.getProperty(Environment.TRANSACTION_MANAGER_STRATEGY) != null) {\n\t\t\t\t\tproviderClass = LocalJtaDataSourceConnectionProvider.class;\n\t\t\t\t}\n\t\t\t\t// Set Spring-provided DataSource as Hibernate ConnectionProvider.\n\t\t\t\tconfig.setProperty(Environment.CONNECTION_PROVIDER, providerClass.getName());\n\t\t\t}\n\n\t\t\tif (this.cacheProvider != null) {\n\t\t\t\t// Expose Spring-provided Hibernate CacheProvider.\n\t\t\t\tconfig.setProperty(Environment.CACHE_PROVIDER, LocalCacheProviderProxy.class.getName());\n\t\t\t}\n\n\t\t\tif (this.mappingResources != null) {\n\t\t\t\t// Register given Hibernate mapping definitions, contained in resource files.\n\t\t\t\tfor (String mapping : this.mappingResources) {\n\t\t\t\t\tResource resource = new ClassPathResource(mapping.trim(), this.beanClassLoader);\n\t\t\t\t\tconfig.addInputStream(resource.getInputStream());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mappingLocations != null) {\n\t\t\t\t// Register given Hibernate mapping definitions, contained in resource files.\n\t\t\t\tfor (Resource resource : this.mappingLocations) {\n\t\t\t\t\tconfig.addInputStream(resource.getInputStream());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.cacheableMappingLocations != null) {\n\t\t\t\t// Register given cacheable Hibernate mapping definitions, read from the file system.\n\t\t\t\tfor (Resource resource : this.cacheableMappingLocations) {\n\t\t\t\t\tconfig.addCacheableFile(resource.getFile());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mappingJarLocations != null) {\n\t\t\t\t// Register given Hibernate mapping definitions, contained in jar files.\n\t\t\t\tfor (Resource resource : this.mappingJarLocations) {\n\t\t\t\t\tconfig.addJar(resource.getFile());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mappingDirectoryLocations != null) {\n\t\t\t\t// Register all Hibernate mapping definitions in the given directories.\n\t\t\t\tfor (Resource resource : this.mappingDirectoryLocations) {\n\t\t\t\t\tFile file = resource.getFile();\n\t\t\t\t\tif (!file.isDirectory()) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Mapping directory location [\" + resource + \"] does not denote a directory\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig.addDirectory(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tell Hibernate to eagerly compile the mappings that we registered,\n\t\t\t// for availability of the mapping information in further processing.\n\t\t\tpostProcessMappings(config);\n\t\t\tconfig.buildMappings();\n\n\t\t\tif (this.entityCacheStrategies != null) {\n\t\t\t\t// Register cache strategies for mapped entities.\n\t\t\t\tfor (Enumeration classNames = this.entityCacheStrategies.propertyNames(); classNames.hasMoreElements();) {\n\t\t\t\t\tString className = (String) classNames.nextElement();\n\t\t\t\t\tString[] strategyAndRegion =\n\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(this.entityCacheStrategies.getProperty(className));\n\t\t\t\t\tif (strategyAndRegion.length > 1) {\n\t\t\t\t\t\tconfig.setCacheConcurrencyStrategy(className, strategyAndRegion[0], strategyAndRegion[1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (strategyAndRegion.length > 0) {\n\t\t\t\t\t\tconfig.setCacheConcurrencyStrategy(className, strategyAndRegion[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.collectionCacheStrategies != null) {\n\t\t\t\t// Register cache strategies for mapped collections.\n\t\t\t\tfor (Enumeration collRoles = this.collectionCacheStrategies.propertyNames(); collRoles.hasMoreElements();) {\n\t\t\t\t\tString collRole = (String) collRoles.nextElement();\n\t\t\t\t\tString[] strategyAndRegion =\n\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(this.collectionCacheStrategies.getProperty(collRole));\n\t\t\t\t\tif (strategyAndRegion.length > 1) {\n\t\t\t\t\t\tconfig.setCollectionCacheConcurrencyStrategy(collRole, strategyAndRegion[0], strategyAndRegion[1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (strategyAndRegion.length > 0) {\n\t\t\t\t\t\tconfig.setCollectionCacheConcurrencyStrategy(collRole, strategyAndRegion[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.eventListeners != null) {\n\t\t\t\t// Register specified Hibernate event listeners.\n\t\t\t\tfor (Map.Entry<String, Object> entry : this.eventListeners.entrySet()) {\n\t\t\t\t\tString listenerType = entry.getKey();\n\t\t\t\t\tObject listenerObject = entry.getValue();\n\t\t\t\t\tif (listenerObject instanceof Collection) {\n\t\t\t\t\t\tCollection<Object> listeners = (Collection<Object>) listenerObject;\n\t\t\t\t\t\tEventListeners listenerRegistry = config.getEventListeners();\n\t\t\t\t\t\tObject[] listenerArray =\n\t\t\t\t\t\t\t\t(Object[]) Array.newInstance(listenerRegistry.getListenerClassFor(listenerType), listeners.size());\n\t\t\t\t\t\tlistenerArray = listeners.toArray(listenerArray);\n\t\t\t\t\t\tconfig.setListeners(listenerType, listenerArray);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconfig.setListener(listenerType, listenerObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Perform custom post-processing in subclasses.\n\t\t\tpostProcessConfiguration(config);\n\n\t\t\t// Build SessionFactory instance.\n\t\t\tlogger.info(\"Building new Hibernate SessionFactory\");\n\t\t\tthis.configuration = config;\n\t\t\treturn newSessionFactory(config);\n\t\t}\n\n\t\tfinally {\n\t\t\tif (dataSource != null) {\n\t\t\t\t// Reset DataSource holder.\n\t\t\t\tconfigTimeDataSourceHolder.set(null);\n\t\t\t}\n\t\t\tif (this.jtaTransactionManager != null) {\n\t\t\t\t// Reset TransactionManager holder.\n\t\t\t\tconfigTimeTransactionManagerHolder.set(null);\n\t\t\t}\n\t\t\tif (this.cacheProvider != null) {\n\t\t\t\t// Reset CacheProvider holder.\n\t\t\t\tconfigTimeCacheProviderHolder.set(null);\n\t\t\t}\n\t\t\tif (this.lobHandler != null) {\n\t\t\t\t// Reset LobHandler holder.\n\t\t\t\tconfigTimeLobHandlerHolder.set(null);\n\t\t\t}\n\t\t\tif (overrideClassLoader) {\n\t\t\t\t// Reset original thread context ClassLoader.\n\t\t\t\tcurrentThread.setContextClassLoader(threadContextClassLoader);\n\t\t\t}\n\t\t}\n\t}","id":35222,"modified_method":"@Override\n\t@SuppressWarnings(\"unchecked\")\n\tprotected SessionFactory buildSessionFactory() throws Exception {\n\t\t// Create Configuration instance.\n\t\tConfiguration config = newConfiguration();\n\n\t\tDataSource dataSource = getDataSource();\n\t\tif (dataSource != null) {\n\t\t\t// Make given DataSource available for SessionFactory configuration.\n\t\t\tconfigTimeDataSourceHolder.set(dataSource);\n\t\t}\n\t\tif (this.jtaTransactionManager != null) {\n\t\t\t// Make Spring-provided JTA TransactionManager available.\n\t\t\tconfigTimeTransactionManagerHolder.set(this.jtaTransactionManager);\n\t\t}\n\t\tif (this.cacheRegionFactory != null) {\n\t\t\t// Make Spring-provided Hibernate RegionFactory available.\n\t\t\tconfigTimeRegionFactoryHolder.set(this.cacheRegionFactory);\n\t\t}\n\t\tif (this.cacheProvider != null) {\n\t\t\t// Make Spring-provided Hibernate CacheProvider available.\n\t\t\tconfigTimeCacheProviderHolder.set(this.cacheProvider);\n\t\t}\n\t\tif (this.lobHandler != null) {\n\t\t\t// Make given LobHandler available for SessionFactory configuration.\n\t\t\t// Do early because because mapping resource might refer to custom types.\n\t\t\tconfigTimeLobHandlerHolder.set(this.lobHandler);\n\t\t}\n\n\t\t// Analogous to Hibernate EntityManager's Ejb3Configuration:\n\t\t// Hibernate doesn't allow setting the bean ClassLoader explicitly,\n\t\t// so we need to expose it as thread context ClassLoader accordingly.\n\t\tThread currentThread = Thread.currentThread();\n\t\tClassLoader threadContextClassLoader = currentThread.getContextClassLoader();\n\t\tboolean overrideClassLoader =\n\t\t\t\t(this.beanClassLoader != null && !this.beanClassLoader.equals(threadContextClassLoader));\n\t\tif (overrideClassLoader) {\n\t\t\tcurrentThread.setContextClassLoader(this.beanClassLoader);\n\t\t}\n\n\t\ttry {\n\t\t\tif (isExposeTransactionAwareSessionFactory()) {\n\t\t\t\t// Set Hibernate 3.1+ CurrentSessionContext implementation,\n\t\t\t\t// providing the Spring-managed Session as current Session.\n\t\t\t\t// Can be overridden by a custom value for the corresponding Hibernate property.\n\t\t\t\tconfig.setProperty(\n\t\t\t\t\t\tEnvironment.CURRENT_SESSION_CONTEXT_CLASS, SpringSessionContext.class.getName());\n\t\t\t}\n\n\t\t\tif (this.jtaTransactionManager != null) {\n\t\t\t\t// Set Spring-provided JTA TransactionManager as Hibernate property.\n\t\t\t\tconfig.setProperty(\n\t\t\t\t\t\tEnvironment.TRANSACTION_STRATEGY, JTATransactionFactory.class.getName());\n\t\t\t\tconfig.setProperty(\n\t\t\t\t\t\tEnvironment.TRANSACTION_MANAGER_STRATEGY, LocalTransactionManagerLookup.class.getName());\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Makes the Hibernate Session aware of the presence of a Spring-managed transaction.\n\t\t\t\t// Also sets connection release mode to ON_CLOSE by default.\n\t\t\t\tconfig.setProperty(\n\t\t\t\t\t\tEnvironment.TRANSACTION_STRATEGY, SpringTransactionFactory.class.getName());\n\t\t\t}\n\n\t\t\tif (this.entityInterceptor != null) {\n\t\t\t\t// Set given entity interceptor at SessionFactory level.\n\t\t\t\tconfig.setInterceptor(this.entityInterceptor);\n\t\t\t}\n\n\t\t\tif (this.namingStrategy != null) {\n\t\t\t\t// Pass given naming strategy to Hibernate Configuration.\n\t\t\t\tconfig.setNamingStrategy(this.namingStrategy);\n\t\t\t}\n\n\t\t\tif (this.typeDefinitions != null) {\n\t\t\t\t// Register specified Hibernate type definitions.\n\t\t\t\t// Use reflection for compatibility with both Hibernate 3.3 and 3.5:\n\t\t\t\t// the returned Mappings object changed from a class to an interface.\n\t\t\t\tMethod createMappings = Configuration.class.getMethod(\"createMappings\");\n\t\t\t\tMethod addTypeDef = createMappings.getReturnType().getMethod(\n\t\t\t\t\t\t\"addTypeDef\", String.class, String.class, Properties.class);\n\t\t\t\tObject mappings = ReflectionUtils.invokeMethod(createMappings, config);\n\t\t\t\tfor (TypeDefinitionBean typeDef : this.typeDefinitions) {\n\t\t\t\t\tReflectionUtils.invokeMethod(addTypeDef, mappings,\n\t\t\t\t\t\t\ttypeDef.getTypeName(), typeDef.getTypeClass(), typeDef.getParameters());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.filterDefinitions != null) {\n\t\t\t\t// Register specified Hibernate FilterDefinitions.\n\t\t\t\tfor (FilterDefinition filterDef : this.filterDefinitions) {\n\t\t\t\t\tconfig.addFilterDefinition(filterDef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.configLocations != null) {\n\t\t\t\tfor (Resource resource : this.configLocations) {\n\t\t\t\t\t// Load Hibernate configuration from given location.\n\t\t\t\t\tconfig.configure(resource.getURL());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.hibernateProperties != null) {\n\t\t\t\t// Add given Hibernate properties to Configuration.\n\t\t\t\tconfig.addProperties(this.hibernateProperties);\n\t\t\t}\n\n\t\t\tif (dataSource != null) {\n\t\t\t\tClass providerClass = LocalDataSourceConnectionProvider.class;\n\t\t\t\tif (isUseTransactionAwareDataSource() || dataSource instanceof TransactionAwareDataSourceProxy) {\n\t\t\t\t\tproviderClass = TransactionAwareDataSourceConnectionProvider.class;\n\t\t\t\t}\n\t\t\t\telse if (config.getProperty(Environment.TRANSACTION_MANAGER_STRATEGY) != null) {\n\t\t\t\t\tproviderClass = LocalJtaDataSourceConnectionProvider.class;\n\t\t\t\t}\n\t\t\t\t// Set Spring-provided DataSource as Hibernate ConnectionProvider.\n\t\t\t\tconfig.setProperty(Environment.CONNECTION_PROVIDER, providerClass.getName());\n\t\t\t}\n\n\t\t\tif (this.cacheRegionFactory != null) {\n\t\t\t\t// Expose Spring-provided Hibernate RegionFactory.\n\t\t\t\tconfig.setProperty(Environment.CACHE_REGION_FACTORY, LocalRegionFactoryProxy.class.getName());\n\t\t\t}\n\t\t\telse if (this.cacheProvider != null) {\n\t\t\t\t// Expose Spring-provided Hibernate CacheProvider.\n\t\t\t\tconfig.setProperty(Environment.CACHE_PROVIDER, LocalCacheProviderProxy.class.getName());\n\t\t\t}\n\n\t\t\tif (this.mappingResources != null) {\n\t\t\t\t// Register given Hibernate mapping definitions, contained in resource files.\n\t\t\t\tfor (String mapping : this.mappingResources) {\n\t\t\t\t\tResource resource = new ClassPathResource(mapping.trim(), this.beanClassLoader);\n\t\t\t\t\tconfig.addInputStream(resource.getInputStream());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mappingLocations != null) {\n\t\t\t\t// Register given Hibernate mapping definitions, contained in resource files.\n\t\t\t\tfor (Resource resource : this.mappingLocations) {\n\t\t\t\t\tconfig.addInputStream(resource.getInputStream());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.cacheableMappingLocations != null) {\n\t\t\t\t// Register given cacheable Hibernate mapping definitions, read from the file system.\n\t\t\t\tfor (Resource resource : this.cacheableMappingLocations) {\n\t\t\t\t\tconfig.addCacheableFile(resource.getFile());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mappingJarLocations != null) {\n\t\t\t\t// Register given Hibernate mapping definitions, contained in jar files.\n\t\t\t\tfor (Resource resource : this.mappingJarLocations) {\n\t\t\t\t\tconfig.addJar(resource.getFile());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.mappingDirectoryLocations != null) {\n\t\t\t\t// Register all Hibernate mapping definitions in the given directories.\n\t\t\t\tfor (Resource resource : this.mappingDirectoryLocations) {\n\t\t\t\t\tFile file = resource.getFile();\n\t\t\t\t\tif (!file.isDirectory()) {\n\t\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\t\"Mapping directory location [\" + resource + \"] does not denote a directory\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig.addDirectory(file);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Tell Hibernate to eagerly compile the mappings that we registered,\n\t\t\t// for availability of the mapping information in further processing.\n\t\t\tpostProcessMappings(config);\n\t\t\tconfig.buildMappings();\n\n\t\t\tif (this.entityCacheStrategies != null) {\n\t\t\t\t// Register cache strategies for mapped entities.\n\t\t\t\tfor (Enumeration classNames = this.entityCacheStrategies.propertyNames(); classNames.hasMoreElements();) {\n\t\t\t\t\tString className = (String) classNames.nextElement();\n\t\t\t\t\tString[] strategyAndRegion =\n\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(this.entityCacheStrategies.getProperty(className));\n\t\t\t\t\tif (strategyAndRegion.length > 1) {\n\t\t\t\t\t\tconfig.setCacheConcurrencyStrategy(className, strategyAndRegion[0], strategyAndRegion[1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (strategyAndRegion.length > 0) {\n\t\t\t\t\t\tconfig.setCacheConcurrencyStrategy(className, strategyAndRegion[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.collectionCacheStrategies != null) {\n\t\t\t\t// Register cache strategies for mapped collections.\n\t\t\t\tfor (Enumeration collRoles = this.collectionCacheStrategies.propertyNames(); collRoles.hasMoreElements();) {\n\t\t\t\t\tString collRole = (String) collRoles.nextElement();\n\t\t\t\t\tString[] strategyAndRegion =\n\t\t\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(this.collectionCacheStrategies.getProperty(collRole));\n\t\t\t\t\tif (strategyAndRegion.length > 1) {\n\t\t\t\t\t\tconfig.setCollectionCacheConcurrencyStrategy(collRole, strategyAndRegion[0], strategyAndRegion[1]);\n\t\t\t\t\t}\n\t\t\t\t\telse if (strategyAndRegion.length > 0) {\n\t\t\t\t\t\tconfig.setCollectionCacheConcurrencyStrategy(collRole, strategyAndRegion[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.eventListeners != null) {\n\t\t\t\t// Register specified Hibernate event listeners.\n\t\t\t\tfor (Map.Entry<String, Object> entry : this.eventListeners.entrySet()) {\n\t\t\t\t\tString listenerType = entry.getKey();\n\t\t\t\t\tObject listenerObject = entry.getValue();\n\t\t\t\t\tif (listenerObject instanceof Collection) {\n\t\t\t\t\t\tCollection<Object> listeners = (Collection<Object>) listenerObject;\n\t\t\t\t\t\tEventListeners listenerRegistry = config.getEventListeners();\n\t\t\t\t\t\tObject[] listenerArray =\n\t\t\t\t\t\t\t\t(Object[]) Array.newInstance(listenerRegistry.getListenerClassFor(listenerType), listeners.size());\n\t\t\t\t\t\tlistenerArray = listeners.toArray(listenerArray);\n\t\t\t\t\t\tconfig.setListeners(listenerType, listenerArray);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tconfig.setListener(listenerType, listenerObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Perform custom post-processing in subclasses.\n\t\t\tpostProcessConfiguration(config);\n\n\t\t\t// Build SessionFactory instance.\n\t\t\tlogger.info(\"Building new Hibernate SessionFactory\");\n\t\t\tthis.configuration = config;\n\t\t\treturn newSessionFactory(config);\n\t\t}\n\n\t\tfinally {\n\t\t\tif (dataSource != null) {\n\t\t\t\tconfigTimeDataSourceHolder.set(null);\n\t\t\t}\n\t\t\tif (this.jtaTransactionManager != null) {\n\t\t\t\tconfigTimeTransactionManagerHolder.set(null);\n\t\t\t}\n\t\t\tif (this.cacheRegionFactory != null) {\n\t\t\t\tconfigTimeCacheProviderHolder.set(null);\n\t\t\t}\n\t\t\tif (this.cacheProvider != null) {\n\t\t\t\tconfigTimeCacheProviderHolder.set(null);\n\t\t\t}\n\t\t\tif (this.lobHandler != null) {\n\t\t\t\tconfigTimeLobHandlerHolder.set(null);\n\t\t\t}\n\t\t\tif (overrideClassLoader) {\n\t\t\t\t// Reset original thread context ClassLoader.\n\t\t\t\tcurrentThread.setContextClassLoader(threadContextClassLoader);\n\t\t\t}\n\t\t}\n\t}","commit_id":"eb0b4f0cbd6d981e6864d4f02bc04b678be4cd1c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Specify the Hibernate Configuration class to use.\n\t * Default is \"org.hibernate.cfg.Configuration\"; any subclass of\n\t * this default Hibernate Configuration class can be specified.\n\t * <p>Can be set to \"org.hibernate.cfg.AnnotationConfiguration\" for\n\t * using Hibernate3 annotation support (initially only available as\n\t * alpha download separate from the main Hibernate3 distribution).\n\t * <p>Annotated packages and annotated classes can be specified via the\n\t * corresponding tags in \"hibernate.cfg.xml\" then, so this will usually\n\t * be combined with a \"configLocation\" property that points at such a\n\t * standard Hibernate configuration file.\n\t * @see #setConfigLocation\n\t * @see org.hibernate.cfg.Configuration\n\t * @see org.hibernate.cfg.AnnotationConfiguration\n\t */\n\tpublic void setConfigurationClass(Class configurationClass) {\n\t\tif (configurationClass == null || !Configuration.class.isAssignableFrom(configurationClass)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"configurationClass must be assignable to [org.hibernate.cfg.Configuration]\");\n\t\t}\n\t\tthis.configurationClass = configurationClass;\n\t}","id":35223,"modified_method":"/**\n\t * Specify the Hibernate Configuration class to use.\n\t * Default is \"org.hibernate.cfg.Configuration\"; any subclass of\n\t * this default Hibernate Configuration class can be specified.\n\t * <p>Can be set to \"org.hibernate.cfg.AnnotationConfiguration\" for\n\t * using Hibernate3 annotation support (initially only available as\n\t * alpha download separate from the main Hibernate3 distribution).\n\t * <p>Annotated packages and annotated classes can be specified via the\n\t * corresponding tags in \"hibernate.cfg.xml\" then, so this will usually\n\t * be combined with a \"configLocation\" property that points at such a\n\t * standard Hibernate configuration file.\n\t * @see #setConfigLocation\n\t * @see org.hibernate.cfg.Configuration\n\t * @see org.hibernate.cfg.AnnotationConfiguration\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void setConfigurationClass(Class<?> configurationClass) {\n\t\tif (configurationClass == null || !Configuration.class.isAssignableFrom(configurationClass)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"'configurationClass' must be assignable to [org.hibernate.cfg.Configuration]\");\n\t\t}\n\t\tthis.configurationClass = (Class<? extends Configuration>) configurationClass;\n\t}","commit_id":"eb0b4f0cbd6d981e6864d4f02bc04b678be4cd1c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute schema creation script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaExport class, to be invoked on application setup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a JDBC\n\t * connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#generateSchemaCreationScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaExport#create\n\t */\n\tpublic void createDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Creating database schema for Hibernate SessionFactory\");\n\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\thibernateTemplate.execute(\n\t\t\tnew HibernateCallback() {\n\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\tString[] sql = getConfiguration().generateSchemaCreationScript(dialect);\n\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}","id":35224,"modified_method":"/**\n\t * Execute schema creation script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaExport class, to be invoked on application setup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a JDBC\n\t * connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#generateSchemaCreationScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaExport#create\n\t */\n\tpublic void createDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Creating database schema for Hibernate SessionFactory\");\n\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\thibernateTemplate.execute(\n\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\tsession.doWork(new Work() {\n\t\t\t\t\t\tpublic void execute(Connection connection) throws SQLException {\n\t\t\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\t\t\tString[] sql = getConfiguration().generateSchemaCreationScript(dialect);\n\t\t\t\t\t\t\texecuteSchemaScript(connection, sql);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}","commit_id":"eb0b4f0cbd6d981e6864d4f02bc04b678be4cd1c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute schema update script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaUpdate class, for automatically executing schema update scripts\n\t * on application startup. Can also be invoked manually.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a JDBC\n\t * connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see #setSchemaUpdate\n\t * @see org.hibernate.cfg.Configuration#generateSchemaUpdateScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaUpdate\n\t */\n\tpublic void updateDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Updating database schema for Hibernate SessionFactory\");\n\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\thibernateTemplate.setFlushMode(HibernateTemplate.FLUSH_NEVER);\n\t\thibernateTemplate.execute(\n\t\t\tnew HibernateCallback() {\n\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\tDatabaseMetadata metadata = new DatabaseMetadata(con, dialect);\n\t\t\t\t\tString[] sql = getConfiguration().generateSchemaUpdateScript(dialect, metadata);\n\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}","id":35225,"modified_method":"/**\n\t * Execute schema update script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaUpdate class, for automatically executing schema update scripts\n\t * on application startup. Can also be invoked manually.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a JDBC\n\t * connection to perform the script.\n\t * @throws DataAccessException in case of script execution errors\n\t * @see #setSchemaUpdate\n\t * @see org.hibernate.cfg.Configuration#generateSchemaUpdateScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaUpdate\n\t */\n\tpublic void updateDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Updating database schema for Hibernate SessionFactory\");\n\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\thibernateTemplate.setFlushMode(HibernateTemplate.FLUSH_NEVER);\n\t\thibernateTemplate.execute(\n\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\tsession.doWork(new Work() {\n\t\t\t\t\t\tpublic void execute(Connection connection) throws SQLException {\n\t\t\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\t\t\tDatabaseMetadata metadata = new DatabaseMetadata(connection, dialect);\n\t\t\t\t\t\t\tString[] sql = getConfiguration().generateSchemaUpdateScript(dialect, metadata);\n\t\t\t\t\t\t\texecuteSchemaScript(connection, sql);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}","commit_id":"eb0b4f0cbd6d981e6864d4f02bc04b678be4cd1c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute schema drop script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaExport class, to be invoked on application setup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a JDBC\n\t * connection to perform the script.\n\t * @throws org.springframework.dao.DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#generateDropSchemaScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaExport#drop\n\t */\n\tpublic void dropDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Dropping database schema for Hibernate SessionFactory\");\n\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\thibernateTemplate.execute(\n\t\t\tnew HibernateCallback() {\n\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\tConnection con = session.connection();\n\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\tString[] sql = getConfiguration().generateDropSchemaScript(dialect);\n\t\t\t\t\texecuteSchemaScript(con, sql);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}","id":35226,"modified_method":"/**\n\t * Execute schema drop script, determined by the Configuration object\n\t * used for creating the SessionFactory. A replacement for Hibernate's\n\t * SchemaExport class, to be invoked on application setup.\n\t * <p>Fetch the LocalSessionFactoryBean itself rather than the exposed\n\t * SessionFactory to be able to invoke this method, e.g. via\n\t * <code>LocalSessionFactoryBean lsfb = (LocalSessionFactoryBean) ctx.getBean(\"&mySessionFactory\");<\/code>.\n\t * <p>Uses the SessionFactory that this bean generates for accessing a JDBC\n\t * connection to perform the script.\n\t * @throws org.springframework.dao.DataAccessException in case of script execution errors\n\t * @see org.hibernate.cfg.Configuration#generateDropSchemaScript\n\t * @see org.hibernate.tool.hbm2ddl.SchemaExport#drop\n\t */\n\tpublic void dropDatabaseSchema() throws DataAccessException {\n\t\tlogger.info(\"Dropping database schema for Hibernate SessionFactory\");\n\t\tHibernateTemplate hibernateTemplate = new HibernateTemplate(getSessionFactory());\n\t\thibernateTemplate.execute(\n\t\t\tnew HibernateCallback<Object>() {\n\t\t\t\tpublic Object doInHibernate(Session session) throws HibernateException, SQLException {\n\t\t\t\t\tsession.doWork(new Work() {\n\t\t\t\t\t\tpublic void execute(Connection connection) throws SQLException {\n\t\t\t\t\t\t\tDialect dialect = Dialect.getDialect(getConfiguration().getProperties());\n\t\t\t\t\t\t\tString[] sql = getConfiguration().generateDropSchemaScript(dialect);\n\t\t\t\t\t\t\texecuteSchemaScript(connection, sql);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t}","commit_id":"eb0b4f0cbd6d981e6864d4f02bc04b678be4cd1c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Subclasses can override this method to perform custom initialization\n\t * of the Configuration instance used for SessionFactory creation.\n\t * The properties of this LocalSessionFactoryBean will be applied to\n\t * the Configuration object that gets returned here.\n\t * <p>The default implementation creates a new Configuration instance.\n\t * A custom implementation could prepare the instance in a specific way,\n\t * or use a custom Configuration subclass.\n\t * @return the Configuration instance\n\t * @throws HibernateException in case of Hibernate initialization errors\n\t * @see org.hibernate.cfg.Configuration#Configuration()\n\t */\n\tprotected Configuration newConfiguration() throws HibernateException {\n\t\treturn (Configuration) BeanUtils.instantiateClass(this.configurationClass);\n\t}","id":35227,"modified_method":"/**\n\t * Subclasses can override this method to perform custom initialization\n\t * of the Configuration instance used for SessionFactory creation.\n\t * The properties of this LocalSessionFactoryBean will be applied to\n\t * the Configuration object that gets returned here.\n\t * <p>The default implementation creates a new Configuration instance.\n\t * A custom implementation could prepare the instance in a specific way,\n\t * or use a custom Configuration subclass.\n\t * @return the Configuration instance\n\t * @throws HibernateException in case of Hibernate initialization errors\n\t * @see org.hibernate.cfg.Configuration#Configuration()\n\t */\n\tprotected Configuration newConfiguration() throws HibernateException {\n\t\treturn BeanUtils.instantiateClass(this.configurationClass);\n\t}","commit_id":"eb0b4f0cbd6d981e6864d4f02bc04b678be4cd1c","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Constructs a new <code>TestContextManager<\/code> for the specified\n\t * {@link Class test class} and automatically\n\t * {@link #registerTestExecutionListeners(TestExecutionListener...)\n\t * registers} the {@link TestExecutionListener TestExecutionListeners}\n\t * configured for the test class via the {@link TestExecutionListeners\n\t * &#064;TestExecutionListeners} annotation.\n\t * \n\t * @param testClass the test class to be managed\n\t * @param defaultContextLoaderClassName the name of the default\n\t * <code>ContextLoader<\/code> class to use (may be <code>null<\/code>)\n\t * @see #registerTestExecutionListeners(TestExecutionListener...)\n\t * @see #retrieveTestExecutionListeners(Class)\n\t */\n\tpublic TestContextManager(Class<?> testClass, String defaultContextLoaderClassName) {\n\t\tthis.testContext = new TestContext(testClass, contextCache, defaultContextLoaderClassName);\n\t\tregisterTestExecutionListeners(retrieveTestExecutionListeners(testClass));\n\t}","id":35228,"modified_method":"/**\n\t * Constructs a new <code>TestContextManager<\/code> for the specified {@link Class test class}\n\t * and automatically {@link #registerTestExecutionListeners registers} the\n\t * {@link TestExecutionListener TestExecutionListeners} configured for the test class\n\t * via the {@link TestExecutionListeners &#064;TestExecutionListeners} annotation.\n\t * @param testClass the test class to be managed\n\t * @param defaultContextLoaderClassName the name of the default\n\t * <code>ContextLoader<\/code> class to use (may be <code>null<\/code>)\n\t * @see #registerTestExecutionListeners(TestExecutionListener...)\n\t * @see #retrieveTestExecutionListeners(Class)\n\t */\n\tpublic TestContextManager(Class<?> testClass, String defaultContextLoaderClassName) {\n\t\tthis.testContext = new TestContext(testClass, contextCache, defaultContextLoaderClassName);\n\t\tregisterTestExecutionListeners(retrieveTestExecutionListeners(testClass));\n\t}","commit_id":"3f0462510e4edefc7d6ef830b0ea61e1ff623fd4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Retrieves an array of newly instantiated {@link TestExecutionListener\n\t * TestExecutionListeners} for the specified {@link Class class}. If\n\t * {@link TestExecutionListeners &#064;TestExecutionListeners} is not\n\t * <em>present<\/em> on the supplied class, the default listeners will be\n\t * returned.\n\t * <p>\n\t * Note that the {@link TestExecutionListeners#inheritListeners()\n\t * inheritListeners} flag of {@link TestExecutionListeners\n\t * &#064;TestExecutionListeners} will be taken into consideration.\n\t * Specifically, if the <code>inheritListeners<\/code> flag is set to\n\t * <code>true<\/code>, listeners defined in the annotated class will be\n\t * appended to the listeners defined in superclasses.\n\t * \n\t * @param clazz the test class for which the listeners should be retrieved\n\t * @return an array of TestExecutionListeners for the specified class\n\t */\n\tprivate TestExecutionListener[] retrieveTestExecutionListeners(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tClass<TestExecutionListeners> annotationType = TestExecutionListeners.class;\n\t\tList<Class<? extends TestExecutionListener>> classesList = new ArrayList<Class<? extends TestExecutionListener>>();\n\t\tClass<?> declaringClass = AnnotationUtils.findAnnotationDeclaringClass(annotationType, clazz);\n\t\tboolean defaultListeners = false;\n\n\t\t// Use defaults?\n\t\tif (declaringClass == null) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"@TestExecutionListeners is not present for class [\" + clazz + \"]: using defaults.\");\n\t\t\t}\n\t\t\tclassesList.addAll(getDefaultTestExecutionListenerClasses());\n\t\t\tdefaultListeners = true;\n\t\t}\n\t\telse {\n\t\t\t// Traverse the class hierarchy...\n\t\t\twhile (declaringClass != null) {\n\t\t\t\tTestExecutionListeners testExecutionListeners = declaringClass.getAnnotation(annotationType);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Retrieved @TestExecutionListeners [\" + testExecutionListeners\n\t\t\t\t\t\t\t+ \"] for declaring class [\" + declaringClass + \"].\");\n\t\t\t\t}\n\n\t\t\t\tClass<? extends TestExecutionListener>[] valueListenerClasses = testExecutionListeners.value();\n\t\t\t\tClass<? extends TestExecutionListener>[] listenerClasses = testExecutionListeners.listeners();\n\t\t\t\tif (!ObjectUtils.isEmpty(valueListenerClasses) && !ObjectUtils.isEmpty(listenerClasses)) {\n\t\t\t\t\tString msg = String.format(\n\t\t\t\t\t\t\"Test class [%s] has been configured with @TestExecutionListeners' 'value' [%s] and 'listeners' [%s] attributes. Use one or the other, but not both.\",\n\t\t\t\t\t\tdeclaringClass, ObjectUtils.nullSafeToString(valueListenerClasses),\n\t\t\t\t\t\tObjectUtils.nullSafeToString(listenerClasses));\n\t\t\t\t\tlogger.error(msg);\n\t\t\t\t\tthrow new IllegalStateException(msg);\n\t\t\t\t}\n\t\t\t\telse if (!ObjectUtils.isEmpty(valueListenerClasses)) {\n\t\t\t\t\tlistenerClasses = valueListenerClasses;\n\t\t\t\t}\n\n\t\t\t\tif (listenerClasses != null) {\n\t\t\t\t\tclassesList.addAll(0, Arrays.<Class<? extends TestExecutionListener>> asList(listenerClasses));\n\t\t\t\t}\n\t\t\t\tdeclaringClass = (testExecutionListeners.inheritListeners() ? AnnotationUtils.findAnnotationDeclaringClass(\n\t\t\t\t\tannotationType, declaringClass.getSuperclass())\n\t\t\t\t\t\t: null);\n\t\t\t}\n\t\t}\n\n\t\tList<TestExecutionListener> listeners = new ArrayList<TestExecutionListener>(classesList.size());\n\t\tfor (Class<? extends TestExecutionListener> listenerClass : classesList) {\n\t\t\ttry {\n\t\t\t\tlisteners.add((TestExecutionListener) BeanUtils.instantiateClass(listenerClass));\n\t\t\t}\n\t\t\tcatch (NoClassDefFoundError err) {\n\t\t\t\tif (defaultListeners) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Could not instantiate default TestExecutionListener class [\"\n\t\t\t\t\t\t\t\t+ listenerClass.getName()\n\t\t\t\t\t\t\t\t+ \"]. Specify custom listener classes or make the default listener classes available.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn listeners.toArray(new TestExecutionListener[listeners.size()]);\n\t}","id":35229,"modified_method":"/**\n\t * Retrieve an array of newly instantiated {@link TestExecutionListener TestExecutionListeners}\n\t * for the specified {@link Class class}. If {@link TestExecutionListeners &#064;TestExecutionListeners}\n\t * is not <em>present<\/em> on the supplied class, the default listeners will be returned.\n\t * <p>Note that the {@link TestExecutionListeners#inheritListeners() inheritListeners} flag of\n\t * {@link TestExecutionListeners &#064;TestExecutionListeners} will be taken into consideration.\n\t * Specifically, if the <code>inheritListeners<\/code> flag is set to <code>true<\/code>, listeners\n\t * defined in the annotated class will be appended to the listeners defined in superclasses.\n\t * @param clazz the test class for which the listeners should be retrieved\n\t * @return an array of TestExecutionListeners for the specified class\n\t */\n\tprivate TestExecutionListener[] retrieveTestExecutionListeners(Class<?> clazz) {\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tClass<TestExecutionListeners> annotationType = TestExecutionListeners.class;\n\t\tList<Class<? extends TestExecutionListener>> classesList = new ArrayList<Class<? extends TestExecutionListener>>();\n\t\tClass<?> declaringClass = AnnotationUtils.findAnnotationDeclaringClass(annotationType, clazz);\n\t\tboolean defaultListeners = false;\n\n\t\t// Use defaults?\n\t\tif (declaringClass == null) {\n\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\tlogger.info(\"@TestExecutionListeners is not present for class [\" + clazz + \"]: using defaults.\");\n\t\t\t}\n\t\t\tclassesList.addAll(getDefaultTestExecutionListenerClasses());\n\t\t\tdefaultListeners = true;\n\t\t}\n\t\telse {\n\t\t\t// Traverse the class hierarchy...\n\t\t\twhile (declaringClass != null) {\n\t\t\t\tTestExecutionListeners testExecutionListeners = declaringClass.getAnnotation(annotationType);\n\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\tlogger.trace(\"Retrieved @TestExecutionListeners [\" + testExecutionListeners\n\t\t\t\t\t\t\t+ \"] for declaring class [\" + declaringClass + \"].\");\n\t\t\t\t}\n\n\t\t\t\tClass<? extends TestExecutionListener>[] valueListenerClasses = testExecutionListeners.value();\n\t\t\t\tClass<? extends TestExecutionListener>[] listenerClasses = testExecutionListeners.listeners();\n\t\t\t\tif (!ObjectUtils.isEmpty(valueListenerClasses) && !ObjectUtils.isEmpty(listenerClasses)) {\n\t\t\t\t\tString msg = String.format(\n\t\t\t\t\t\t\"Test class [%s] has been configured with @TestExecutionListeners' 'value' [%s] \" +\n\t\t\t\t\t\t\t\t\"and 'listeners' [%s] attributes. Use one or the other, but not both.\",\n\t\t\t\t\t\tdeclaringClass, ObjectUtils.nullSafeToString(valueListenerClasses),\n\t\t\t\t\t\tObjectUtils.nullSafeToString(listenerClasses));\n\t\t\t\t\tlogger.error(msg);\n\t\t\t\t\tthrow new IllegalStateException(msg);\n\t\t\t\t}\n\t\t\t\telse if (!ObjectUtils.isEmpty(valueListenerClasses)) {\n\t\t\t\t\tlistenerClasses = valueListenerClasses;\n\t\t\t\t}\n\n\t\t\t\tif (listenerClasses != null) {\n\t\t\t\t\tclassesList.addAll(0, Arrays.<Class<? extends TestExecutionListener>> asList(listenerClasses));\n\t\t\t\t}\n\t\t\t\tdeclaringClass = (testExecutionListeners.inheritListeners() ?\n\t\t\t\t\t\tAnnotationUtils.findAnnotationDeclaringClass(annotationType, declaringClass.getSuperclass()) : null);\n\t\t\t}\n\t\t}\n\n\t\tList<TestExecutionListener> listeners = new ArrayList<TestExecutionListener>(classesList.size());\n\t\tfor (Class<? extends TestExecutionListener> listenerClass : classesList) {\n\t\t\ttry {\n\t\t\t\tlisteners.add(BeanUtils.instantiateClass(listenerClass));\n\t\t\t}\n\t\t\tcatch (NoClassDefFoundError err) {\n\t\t\t\tif (defaultListeners) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(\"Could not instantiate default TestExecutionListener class [\"\n\t\t\t\t\t\t\t\t+ listenerClass.getName()\n\t\t\t\t\t\t\t\t+ \"]. Specify custom listener classes or make the default listener classes available.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow err;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn listeners.toArray(new TestExecutionListener[listeners.size()]);\n\t}","commit_id":"3f0462510e4edefc7d6ef830b0ea61e1ff623fd4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Gets an {@link Collections#unmodifiableList(List) unmodifiable} copy of\n\t * the {@link TestExecutionListener TestExecutionListeners} registered for\n\t * this <code>TestContextManager<\/code>.\n\t */\n\tpublic final List<TestExecutionListener> getTestExecutionListeners() {\n\t\treturn Collections.unmodifiableList(this.testExecutionListeners);\n\t}","id":35230,"modified_method":"/**\n\t * Get the current {@link TestExecutionListener TestExecutionListeners}\n\t * registered for this <code>TestContextManager<\/code>.\n\t * <p>Allows for modifications, e.g. adding a listener to the beginning of the list.\n\t * However, make sure to keep the list stable while actually executing tests.\n\t */\n\tpublic final List<TestExecutionListener> getTestExecutionListeners() {\n\t\treturn this.testExecutionListeners;\n\t}","commit_id":"3f0462510e4edefc7d6ef830b0ea61e1ff623fd4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Register the supplied {@link TestExecutionListener\n\t * TestExecutionListeners} by appending them to the set of listeners used by\n\t * this <code>TestContextManager<\/code>.\n\t */\n\tpublic void registerTestExecutionListeners(TestExecutionListener... testExecutionListeners) {\n\t\tfor (TestExecutionListener listener : testExecutionListeners) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Registering TestExecutionListener [\" + listener + \"]\");\n\t\t\t}\n\t\t\tthis.testExecutionListeners.add(listener);\n\t\t}\n\t}","id":35231,"modified_method":"/**\n\t * Register the supplied {@link TestExecutionListener TestExecutionListeners}\n\t * by appending them to the set of listeners used by this <code>TestContextManager<\/code>.\n\t */\n\tpublic void registerTestExecutionListeners(TestExecutionListener... testExecutionListeners) {\n\t\tfor (TestExecutionListener listener : testExecutionListeners) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"Registering TestExecutionListener: \" + listener);\n\t\t\t}\n\t\t\tthis.testExecutionListeners.add(listener);\n\t\t}\n\t}","commit_id":"3f0462510e4edefc7d6ef830b0ea61e1ff623fd4","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set the PersistenceProvider implementation class to use for creating the\n\t * EntityManagerFactory. If not specified, the persistence provider will be\n\t * taken from the JpaVendorAdapter (if any) or retrieved through scanning\n\t * (as far as possible).\n\t * @see JpaVendorAdapter#getPersistenceProvider()\n\t * @see javax.persistence.spi.PersistenceProvider\n\t * @see javax.persistence.Persistence\n\t */\n\tpublic void setPersistenceProviderClass(Class<? extends PersistenceProvider> persistenceProviderClass) {\n\t\tAssert.isAssignable(PersistenceProvider.class, persistenceProviderClass);\n\t\tthis.persistenceProvider = (PersistenceProvider) BeanUtils.instantiateClass(persistenceProviderClass);\n\t}","id":35232,"modified_method":"/**\n\t * Set the PersistenceProvider implementation class to use for creating the\n\t * EntityManagerFactory. If not specified, the persistence provider will be\n\t * taken from the JpaVendorAdapter (if any) or retrieved through scanning\n\t * (as far as possible).\n\t * @see JpaVendorAdapter#getPersistenceProvider()\n\t * @see javax.persistence.spi.PersistenceProvider\n\t * @see javax.persistence.Persistence\n\t */\n\tpublic void setPersistenceProviderClass(Class<? extends PersistenceProvider> persistenceProviderClass) {\n\t\tAssert.isAssignable(PersistenceProvider.class, persistenceProviderClass);\n\t\tthis.persistenceProvider = BeanUtils.instantiateClass(persistenceProviderClass);\n\t}","commit_id":"57f90ad4ef78614afb173c6c8b5c12f220f41988","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tprotected EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException {\n\t\tPersistenceUnitManager managerToUse = this.persistenceUnitManager;\n\t\tif (this.persistenceUnitManager == null) {\n\t\t\tthis.internalPersistenceUnitManager.afterPropertiesSet();\n\t\t\tmanagerToUse = this.internalPersistenceUnitManager;\n\t\t}\n\n\t\tthis.persistenceUnitInfo = determinePersistenceUnitInfo(managerToUse);\n\t\tJpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter();\n\t\tif (jpaVendorAdapter != null && this.persistenceUnitInfo instanceof MutablePersistenceUnitInfo) {\n\t\t\t((MutablePersistenceUnitInfo) this.persistenceUnitInfo).setPersistenceProviderPackageName(\n\t\t\t\t\tjpaVendorAdapter.getPersistenceProviderRootPackage());\n\t\t}\n\n\t\tPersistenceProvider provider = getPersistenceProvider();\n\t\tif (provider == null) {\n\t\t\tString providerClassName = this.persistenceUnitInfo.getPersistenceProviderClassName();\n\t\t\tif (providerClassName == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"No PersistenceProvider specified in EntityManagerFactory configuration, \" +\n\t\t\t\t\t\t\"and chosen PersistenceUnitInfo does not specify a provider class name either\");\n\t\t\t}\n\t\t\tClass providerClass = ClassUtils.resolveClassName(providerClassName, getBeanClassLoader());\n\t\t\tprovider = (PersistenceProvider) BeanUtils.instantiateClass(providerClass);\n\t\t}\n\t\tif (provider == null) {\n\t\t\tthrow new IllegalStateException(\"Unable to determine persistence provider. \" +\n\t\t\t\t\t\"Please check configuration of \" + getClass().getName() + \"; \" +\n\t\t\t\t\t\"ideally specify the appropriate JpaVendorAdapter class for this provider.\");\n\t\t}\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Building JPA container EntityManagerFactory for persistence unit '\" +\n\t\t\t\t\tthis.persistenceUnitInfo.getPersistenceUnitName() + \"'\");\n\t\t}\n\t\tthis.nativeEntityManagerFactory =\n\t\t\t\tprovider.createContainerEntityManagerFactory(this.persistenceUnitInfo, getJpaPropertyMap());\n\t\tpostProcessEntityManagerFactory(this.nativeEntityManagerFactory, this.persistenceUnitInfo);\n\n\t\treturn this.nativeEntityManagerFactory;\n\t}","id":35233,"modified_method":"@Override\n\tprotected EntityManagerFactory createNativeEntityManagerFactory() throws PersistenceException {\n\t\tPersistenceUnitManager managerToUse = this.persistenceUnitManager;\n\t\tif (this.persistenceUnitManager == null) {\n\t\t\tthis.internalPersistenceUnitManager.afterPropertiesSet();\n\t\t\tmanagerToUse = this.internalPersistenceUnitManager;\n\t\t}\n\n\t\tthis.persistenceUnitInfo = determinePersistenceUnitInfo(managerToUse);\n\t\tJpaVendorAdapter jpaVendorAdapter = getJpaVendorAdapter();\n\t\tif (jpaVendorAdapter != null && this.persistenceUnitInfo instanceof MutablePersistenceUnitInfo) {\n\t\t\t((MutablePersistenceUnitInfo) this.persistenceUnitInfo).setPersistenceProviderPackageName(\n\t\t\t\t\tjpaVendorAdapter.getPersistenceProviderRootPackage());\n\t\t}\n\n\t\tPersistenceProvider provider = getPersistenceProvider();\n\t\tif (provider == null) {\n\t\t\tString providerClassName = this.persistenceUnitInfo.getPersistenceProviderClassName();\n\t\t\tif (providerClassName == null) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"No PersistenceProvider specified in EntityManagerFactory configuration, \" +\n\t\t\t\t\t\t\"and chosen PersistenceUnitInfo does not specify a provider class name either\");\n\t\t\t}\n\t\t\tClass<?> providerClass = ClassUtils.resolveClassName(providerClassName, getBeanClassLoader());\n\t\t\tprovider = (PersistenceProvider) BeanUtils.instantiateClass(providerClass);\n\t\t}\n\t\tif (provider == null) {\n\t\t\tthrow new IllegalStateException(\"Unable to determine persistence provider. \" +\n\t\t\t\t\t\"Please check configuration of \" + getClass().getName() + \"; \" +\n\t\t\t\t\t\"ideally specify the appropriate JpaVendorAdapter class for this provider.\");\n\t\t}\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Building JPA container EntityManagerFactory for persistence unit '\" +\n\t\t\t\t\tthis.persistenceUnitInfo.getPersistenceUnitName() + \"'\");\n\t\t}\n\t\tthis.nativeEntityManagerFactory =\n\t\t\t\tprovider.createContainerEntityManagerFactory(this.persistenceUnitInfo, getJpaPropertyMap());\n\t\tpostProcessEntityManagerFactory(this.nativeEntityManagerFactory, this.persistenceUnitInfo);\n\n\t\treturn this.nativeEntityManagerFactory;\n\t}","commit_id":"57f90ad4ef78614afb173c6c8b5c12f220f41988","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected final void setUp() throws Exception {\n        super.setUp();\n\n         Log4jConfigurer.initLogging(\"file:./test/persistence/log4j.properties\");\n        ExpandoMetaClass.enableGlobally();\n        PluginManagerHolder.setPluginManager(null);\n\n        onSetUp();\n\n        ConfigObject config = new ConfigSlurper().parse(\"hibernate.cache.use_second_level_cache=true\\n\" +\n                \"hibernate.cache.use_query_cache=true\\n\" +\n                \"hibernate.cache.provider_class='org.hibernate.cache.EhCacheProvider'\\n\" +\n                \"hibernate.show_sql=true\\n\" +\n                \"hibernate.use_sql_comments=false\\n\" +                \n                \"dataSource {\\n\" +\n                \"dbCreate = \\\"create-drop\\\" \\n\" +\n                \"url = \\\"jdbc:hsqldb:mem:devDB\\\"\\n\" +\n                \"logSql = true\\n\" +\n                \"pooling = false                          \\n\" +\n                \"driverClassName = \\\"org.hsqldb.jdbcDriver\\\"\\t\\n\" +\n                \"username = \\\"sa\\\"\\n\" +\n                \"password = \\\"\\\"\\n\" +\n                \"}\");\n        ConfigurationHolder.setConfig(config);\n        for (int i = 0; i < gcl.getLoadedClasses().length; i++) {\n            Class aClass = gcl.getLoadedClasses()[i];\n            GroovySystem.getMetaClassRegistry().removeMetaClass(aClass);\n        }\n        ga = new DefaultGrailsApplication(gcl.getLoadedClasses(),gcl);\n        ApplicationHolder.setApplication(ga);\n\n        MockApplicationContext mc = new MockApplicationContext();\n        mc.registerMockBean(GrailsApplication.APPLICATION_ID, ga);\n        mc.registerMockBean(\"messageSource\", new StaticMessageSource());\n        mc.registerMockBean(PluginMetaManager.BEAN_ID, new DefaultPluginMetaManager(new Resource[0]));\n       \n        GrailsRuntimeConfigurator grc = new GrailsRuntimeConfigurator(ga, mc);\n        this.applicationContext = grc.configure(new MockServletContext());\n        this.sessionFactory = (SessionFactory)this.applicationContext.getBean(GrailsRuntimeConfigurator.SESSION_FACTORY_BEAN);\n\n        if(!TransactionSynchronizationManager.hasResource(this.sessionFactory)) {\n            this.session = this.sessionFactory.openSession();\n            TransactionSynchronizationManager.bindResource(this.sessionFactory, new SessionHolder(session));\n        }\n\n\n    }","id":35234,"modified_method":"protected final void setUp() throws Exception {\n        super.setUp();\n\n         Log4jConfigurer.initLogging(\"file:./test/persistence/log4j.properties\");\n        ExpandoMetaClass.enableGlobally();\n        PluginManagerHolder.setPluginManager(null);\n\n        onSetUp();\n\n        ConfigObject config = new ConfigSlurper().parse(\"hibernate.cache.use_second_level_cache=true\\n\" +\n                \"hibernate.cache.use_query_cache=true\\n\" +\n                \"hibernate.cache.provider_class='org.hibernate.cache.EhCacheProvider'\\n\" +\n                \"dataSource {\\n\" +\n                \"dbCreate = \\\"create-drop\\\" \\n\" +\n                \"url = \\\"jdbc:hsqldb:mem:devDB\\\"\\n\" +\n                \"pooling = false                          \\n\" +\n                \"driverClassName = \\\"org.hsqldb.jdbcDriver\\\"\\t\\n\" +\n                \"username = \\\"sa\\\"\\n\" +\n                \"password = \\\"\\\"\\n\" +\n                \"}\");\n        ConfigurationHolder.setConfig(config);\n        for (int i = 0; i < gcl.getLoadedClasses().length; i++) {\n            Class aClass = gcl.getLoadedClasses()[i];\n            GroovySystem.getMetaClassRegistry().removeMetaClass(aClass);\n        }\n        ga = new DefaultGrailsApplication(gcl.getLoadedClasses(),gcl);\n        ApplicationHolder.setApplication(ga);\n\n        MockApplicationContext mc = new MockApplicationContext();\n        mc.registerMockBean(GrailsApplication.APPLICATION_ID, ga);\n        mc.registerMockBean(\"messageSource\", new StaticMessageSource());\n        mc.registerMockBean(PluginMetaManager.BEAN_ID, new DefaultPluginMetaManager(new Resource[0]));\n       \n        GrailsRuntimeConfigurator grc = new GrailsRuntimeConfigurator(ga, mc);\n        this.applicationContext = grc.configure(new MockServletContext());\n        this.sessionFactory = (SessionFactory)this.applicationContext.getBean(GrailsRuntimeConfigurator.SESSION_FACTORY_BEAN);\n\n        if(!TransactionSynchronizationManager.hasResource(this.sessionFactory)) {\n            this.session = this.sessionFactory.openSession();\n            TransactionSynchronizationManager.bindResource(this.sessionFactory, new SessionHolder(session));\n        }\n\n\n    }","commit_id":"0da55819c672aad9246e59b1380e7d16dc55505c","url":"https://github.com/grails/grails-core"},{"original_method":"protected SessionFactory newSessionFactory(Configuration config) throws HibernateException {\n        SessionFactory sf = super.newSessionFactory(config);\n        GrailsHibernateUtil.configureHibernateDomainClasses(sf, getGrailsApplication());\n        return sf;\n    }","id":35235,"modified_method":"protected SessionFactory newSessionFactory(Configuration config) throws HibernateException {\n        SessionFactory sf = super.newSessionFactory(config);\n        GrailsApplication application = getGrailsApplication();\n        if(application!=null)\n            GrailsHibernateUtil.configureHibernateDomainClasses(sf, application);\n        return sf;\n    }","commit_id":"0da55819c672aad9246e59b1380e7d16dc55505c","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Overrides default behaviour to allow for a configurable configuration class \n\t */\n\tprotected Configuration newConfiguration() {\n\t\tGrailsDomainConfiguration config = (GrailsDomainConfiguration)BeanUtils.instantiateClass(configClass);\n\t\tconfig.setGrailsApplication(grailsApplication);\n        if(currentSessionContextClass != null) {\n            ((Configuration)config).setProperty(Environment.CURRENT_SESSION_CONTEXT_CLASS, currentSessionContextClass.getName());\n            // don't allow Spring's LocaalSessionFactoryBean to override setting\n            setExposeTransactionAwareSessionFactory(false);\n        }\n        return (Configuration)config;\n\t}","id":35236,"modified_method":"/**\n\t * Overrides default behaviour to allow for a configurable configuration class \n\t */\n\tprotected Configuration newConfiguration() {\n        Object config = BeanUtils.instantiateClass(configClass);\n        if(config instanceof GrailsDomainConfiguration) {\n            GrailsDomainConfiguration grailsConfig = (GrailsDomainConfiguration) config;\n            grailsConfig.setGrailsApplication(grailsApplication);\n        }\n        if(currentSessionContextClass != null) {\n            ((Configuration)config).setProperty(Environment.CURRENT_SESSION_CONTEXT_CLASS, currentSessionContextClass.getName());\n            // don't allow Spring's LocaalSessionFactoryBean to override setting\n            setExposeTransactionAwareSessionFactory(false);\n        }\n        return (Configuration)config;\n\t}","commit_id":"0da55819c672aad9246e59b1380e7d16dc55505c","url":"https://github.com/grails/grails-core"},{"original_method":"private static void setCascadeBehaviour(GrailsDomainClassProperty grailsProperty, Property prop) {\n        String cascadeStrategy = \"none\";\n        // set to cascade all for the moment\n        GrailsDomainClass domainClass = grailsProperty.getDomainClass();\n        ColumnConfig cc = getColumnConfig(grailsProperty);\n        GrailsDomainClass referenced = grailsProperty.getReferencedDomainClass();\n        if(cc!=null && cc.getCascade() != null) {\n            cascadeStrategy = cc.getCascade();\n        }\n        else if(grailsProperty.isAssociation()) {\n            if(grailsProperty.isOneToOne()) {\n                if(referenced!=null&&referenced.isOwningClass(domainClass.getClazz()))\n                    cascadeStrategy = CASCADE_ALL;\n            }\n            else if(grailsProperty.isOneToMany()) {\n                if(referenced!=null&&referenced.isOwningClass(domainClass.getClazz()))\n                    cascadeStrategy = CASCADE_ALL;\n                else\n                    cascadeStrategy = CASCADE_SAVE_UPDATE;\n            }\n            else if(grailsProperty.isManyToMany()) {\n                if(referenced!=null&&referenced.isOwningClass(domainClass.getClazz()))\n                    cascadeStrategy = CASCADE_SAVE_UPDATE;\n            }\n            else if(grailsProperty.isManyToOne()) {\n                if(referenced!=null&&referenced.isOwningClass(domainClass.getClazz()))\n                    cascadeStrategy = CASCADE_ALL;\n                else\n                    cascadeStrategy = CASCADE_MERGE;\n            }\n        }\n        else if( Map.class.isAssignableFrom(grailsProperty.getType())) {\n            referenced = grailsProperty.getReferencedDomainClass();\n            if(referenced!=null&&referenced.isOwningClass(grailsProperty.getDomainClass().getClazz())) {\n                cascadeStrategy = CASCADE_ALL;\n            }\n            else {\n                cascadeStrategy = CASCADE_SAVE_UPDATE;\n            }\n        }\n        logCascadeMapping(grailsProperty, cascadeStrategy, referenced);\n        prop.setCascade(cascadeStrategy);\n    }","id":35237,"modified_method":"private static void setCascadeBehaviour(GrailsDomainClassProperty grailsProperty, Property prop) {\n        String cascadeStrategy = \"none\";\n        // set to cascade all for the moment\n        GrailsDomainClass domainClass = grailsProperty.getDomainClass();\n        ColumnConfig cc = getColumnConfig(grailsProperty);\n        GrailsDomainClass referenced = grailsProperty.getReferencedDomainClass();\n        if(cc!=null && cc.getCascade() != null) {\n            cascadeStrategy = cc.getCascade();\n        }\n        else if(grailsProperty.isAssociation()) {\n            if(grailsProperty.isOneToOne()) {\n                if(referenced!=null&&referenced.isOwningClass(domainClass.getClazz()))\n                    cascadeStrategy = CASCADE_ALL;\n            }\n            else if(grailsProperty.isOneToMany()) {\n                if(referenced!=null&&referenced.isOwningClass(domainClass.getClazz()))\n                    cascadeStrategy = CASCADE_ALL;\n                else\n                    cascadeStrategy = CASCADE_SAVE_UPDATE;\n            }\n            else if(grailsProperty.isManyToMany()) {\n                if(referenced!=null&&referenced.isOwningClass(domainClass.getClazz()))\n                    cascadeStrategy = CASCADE_SAVE_UPDATE;\n            }\n            else if(grailsProperty.isManyToOne() ) {\n                if(referenced!=null&&referenced.isOwningClass(domainClass.getClazz()))\n                    cascadeStrategy = CASCADE_ALL;\n                else\n                    cascadeStrategy = CASCADE_NONE;\n            }\n        }\n        else if( Map.class.isAssignableFrom(grailsProperty.getType())) {\n            referenced = grailsProperty.getReferencedDomainClass();\n            if(referenced!=null&&referenced.isOwningClass(grailsProperty.getDomainClass().getClazz())) {\n                cascadeStrategy = CASCADE_ALL;\n            }\n            else {\n                cascadeStrategy = CASCADE_SAVE_UPDATE;\n            }\n        }\n        logCascadeMapping(grailsProperty, cascadeStrategy, referenced);\n        prop.setCascade(cascadeStrategy);\n    }","commit_id":"0da55819c672aad9246e59b1380e7d16dc55505c","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Binds a property to Hibernate runtime meta model. Deals with cascade strategy based on the Grails domain model\n     *\n\t * @param grailsProperty The grails property instance\n\t * @param prop The Hibernate property\n\t * @param mappings The Hibernate mappings\n\t */\n\tprivate static void bindProperty(GrailsDomainClassProperty grailsProperty, Property prop, Mappings mappings) {\n\t\t// set the property name\n\t\tprop.setName( grailsProperty.getName() );\n\n\t\tprop.setInsertable(true);\n\t\tprop.setUpdateable(true);\n\t\tprop.setPropertyAccessorName( mappings.getDefaultAccess() );\n\t\tprop.setOptional( grailsProperty.isOptional() );\n\n        setCascadeBehaviour(grailsProperty, prop);\n\n        // lazy to true\n\t\tprop.setLazy(true);\n\n\t}","id":35238,"modified_method":"/**\n     * Binds a property to Hibernate runtime meta model. Deals with cascade strategy based on the Grails domain model\n     *\n\t * @param grailsProperty The grails property instance\n\t * @param prop The Hibernate property\n\t * @param mappings The Hibernate mappings\n\t */\n\tprivate static void bindProperty(GrailsDomainClassProperty grailsProperty, Property prop, Mappings mappings) {\n\t\t// set the property name\n\t\tprop.setName( grailsProperty.getName() );\n        if(isBidirectionalManyToOneWithListMapping(grailsProperty, prop)) {\n            prop.setInsertable(false);\n            prop.setUpdateable(false);\n        }\n        else {\n            prop.setInsertable(true);\n            prop.setUpdateable(true);\n        }\n\n\t\tprop.setPropertyAccessorName( mappings.getDefaultAccess() );\n\t\tprop.setOptional( grailsProperty.isOptional() );\n\n        setCascadeBehaviour(grailsProperty, prop);\n\n        // lazy to true\n\t\tprop.setLazy(true);\n\n\t}","commit_id":"0da55819c672aad9246e59b1380e7d16dc55505c","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Binds a Column instance to the Hibernate meta model\n\t * @param grailsProp The Grails domain class property\n     * @param column The column to bind\n     * @param path\n     * @param table The table name\n     */\n\tprivate static void bindColumn(GrailsDomainClassProperty grailsProp, Column column, String path, Table table) {\n\t\tif(grailsProp.isAssociation()) {\n\t\t\t// Only use conventional naming when the column has not been explicitly mapped.\n\t\t\tif (column.getName() == null) {\n                String columnName = getColumnNameForPropertyAndPath(grailsProp, path);\n                if(!grailsProp.isBidirectional() && grailsProp.isOneToMany()) {\n                    String prefix = namingStrategy.classToTableName(grailsProp.getDomainClass().getName());\n                    column.setName(prefix+ UNDERSCORE +columnName + FOREIGN_KEY_SUFFIX);\n                } else {\n\n                    if(grailsProp.isInherited() && isBidirectionalManyToOne(grailsProp)) {\n                        column.setName( namingStrategy.propertyToColumnName(grailsProp.getDomainClass().getName()) + '_'+ columnName + FOREIGN_KEY_SUFFIX );\n                    }\n                    else {\n                        column.setName( columnName + FOREIGN_KEY_SUFFIX );\n                    }\n\n                }\n            }\n            if(grailsProp.isManyToMany())\n                column.setNullable(false);\n            else if((grailsProp.isOneToOne()||grailsProp.isManyToOne()) && grailsProp.isBidirectional() && !grailsProp.isOwningSide()) {\n                column.setNullable(true);                \n            }\n            else {\n                column.setNullable(grailsProp.isOptional());\n            }\n        } else {\n            String columnName = getColumnNameForPropertyAndPath(grailsProp, path);\n            column.setName(columnName);\n\t\t\tcolumn.setNullable(grailsProp.isOptional());\n\n            // Use the constraints for this property to more accurately define\n            // the column's length, precision, and scale\n            ConstrainedProperty constrainedProperty = getConstrainedProperty(grailsProp);\n            if (constrainedProperty != null) {\n                if (String.class.isAssignableFrom(grailsProp.getType()) || byte[].class.isAssignableFrom(grailsProp.getType())) {\n                    bindStringColumnConstraints(column, constrainedProperty);\n                }\n\n                if (Number.class.isAssignableFrom(grailsProp.getType())) {\n                    bindNumericColumnConstraints(column, constrainedProperty);\n                }\n            }\n\t\t}\n\n        ConstrainedProperty cp = getConstrainedProperty(grailsProp);\n        if(cp!=null&&cp.hasAppliedConstraint(UniqueConstraint.UNIQUE_CONSTRAINT)) {\n            UniqueConstraint uc = (UniqueConstraint)cp.getAppliedConstraint(UniqueConstraint.UNIQUE_CONSTRAINT);\n            if(uc != null && uc.isUnique() && !uc.isUniqueWithinGroup()) {\n                column.setUnique(true);\n            }\n        }\n        else {\n            Object val =  cp != null ? cp.getMetaConstraintValue(UniqueConstraint.UNIQUE_CONSTRAINT) : null;\n            if(val instanceof Boolean) {\n                column.setUnique(((Boolean)val).booleanValue());\n            }\n        }\n\n\n        bindIndex(grailsProp, column, table);\n\n        if(!grailsProp.getDomainClass().isRoot()) {\n\t\t\tif(LOG.isDebugEnabled())\n\t\t\t\tLOG.debug(\"[GrailsDomainBinder] Sub class property [\" + grailsProp.getName() + \"] for column name [\"+column.getName()+\"] in table [\"+table.getName()+\"] set to nullable\");\n\t\t\tcolumn.setNullable(true);\n\t\t}\n\n\t\tif(LOG.isDebugEnabled())\n\t\t\tLOG.debug(\"[GrailsDomainBinder] bound property [\" + grailsProp.getName() + \"] to column name [\"+column.getName()+\"] in table [\"+table.getName()+\"]\");\n\t}","id":35239,"modified_method":"/**\n\t * Binds a Column instance to the Hibernate meta model\n\t * @param grailsProp The Grails domain class property\n     * @param column The column to bind\n     * @param path\n     * @param table The table name\n     */\n\tprivate static void bindColumn(GrailsDomainClassProperty grailsProp, Column column, String path, Table table) {\n\t\tif(grailsProp.isAssociation()) {\n\t\t\t// Only use conventional naming when the column has not been explicitly mapped.\n\t\t\tif (column.getName() == null) {\n                String columnName = getColumnNameForPropertyAndPath(grailsProp, path);\n                if(!grailsProp.isBidirectional() && grailsProp.isOneToMany()) {\n                    String prefix = namingStrategy.classToTableName(grailsProp.getDomainClass().getName());\n                    column.setName(prefix+ UNDERSCORE +columnName + FOREIGN_KEY_SUFFIX);\n                } else {\n\n                    if(grailsProp.isInherited() && isBidirectionalManyToOne(grailsProp)) {\n                        column.setName( namingStrategy.propertyToColumnName(grailsProp.getDomainClass().getName()) + '_'+ columnName + FOREIGN_KEY_SUFFIX );\n                    }\n                    else {\n                        column.setName( columnName + FOREIGN_KEY_SUFFIX );\n                    }\n\n                }\n            }\n            if(grailsProp.isManyToMany())\n                column.setNullable(false);\n            else if(grailsProp.isOneToOne() && grailsProp.isBidirectional() && !grailsProp.isOwningSide()) {\n                column.setNullable(true);\n            }\n            else {\n                column.setNullable(grailsProp.isOptional());\n            }\n        } else {\n            String columnName = getColumnNameForPropertyAndPath(grailsProp, path);\n            column.setName(columnName);\n\t\t\tcolumn.setNullable(grailsProp.isOptional());\n\n            // Use the constraints for this property to more accurately define\n            // the column's length, precision, and scale\n            ConstrainedProperty constrainedProperty = getConstrainedProperty(grailsProp);\n            if (constrainedProperty != null) {\n                if (String.class.isAssignableFrom(grailsProp.getType()) || byte[].class.isAssignableFrom(grailsProp.getType())) {\n                    bindStringColumnConstraints(column, constrainedProperty);\n                }\n\n                if (Number.class.isAssignableFrom(grailsProp.getType())) {\n                    bindNumericColumnConstraints(column, constrainedProperty);\n                }\n            }\n\t\t}\n\n        ConstrainedProperty cp = getConstrainedProperty(grailsProp);\n        if(cp!=null&&cp.hasAppliedConstraint(UniqueConstraint.UNIQUE_CONSTRAINT)) {\n            UniqueConstraint uc = (UniqueConstraint)cp.getAppliedConstraint(UniqueConstraint.UNIQUE_CONSTRAINT);\n            if(uc != null && uc.isUnique() && !uc.isUniqueWithinGroup()) {\n                column.setUnique(true);\n            }\n        }\n        else {\n            Object val =  cp != null ? cp.getMetaConstraintValue(UniqueConstraint.UNIQUE_CONSTRAINT) : null;\n            if(val instanceof Boolean) {\n                column.setUnique(((Boolean)val).booleanValue());\n            }\n        }\n\n\n        bindIndex(grailsProp, column, table);\n\n        if(!grailsProp.getDomainClass().isRoot()) {\n\t\t\tif(LOG.isDebugEnabled())\n\t\t\t\tLOG.debug(\"[GrailsDomainBinder] Sub class property [\" + grailsProp.getName() + \"] for column name [\"+column.getName()+\"] in table [\"+table.getName()+\"] set to nullable\");\n\t\t\tcolumn.setNullable(true);\n\t\t}\n\n\t\tif(LOG.isDebugEnabled())\n\t\t\tLOG.debug(\"[GrailsDomainBinder] bound property [\" + grailsProp.getName() + \"] to column name [\"+column.getName()+\"] in table [\"+table.getName()+\"]\");\n\t}","commit_id":"0da55819c672aad9246e59b1380e7d16dc55505c","url":"https://github.com/grails/grails-core"},{"original_method":"private static void bindListSecondPass(GrailsDomainClassProperty property, Mappings mappings, Map persistentClasses, org.hibernate.mapping.List list, Map inheritedMetas) {\n        bindCollectionSecondPass( property, mappings, persistentClasses, list,inheritedMetas );\n\n        String columnName = getColumnNameForPropertyAndPath(property, \"\")+ UNDERSCORE +IndexedCollection.DEFAULT_INDEX_COLUMN_NAME;\n\n        SimpleValue iv = new SimpleValue( list.getCollectionTable() );\n        bindSimpleValue(\"integer\", iv, true,columnName, mappings);\n        iv.setTypeName( \"integer\" );\n        list.setIndex( iv );\n        list.setInverse(false);\n\n        if(property.isBidirectional()) {\n            String entityName;\n            Value element = list.getElement();\n            if(element instanceof ManyToOne) {\n                ManyToOne manyToOne = (ManyToOne) element;\n                entityName = manyToOne.getReferencedEntityName();\n            }\n            else {\n                entityName = ( (OneToMany) element).getReferencedEntityName();\n            }\n\n            PersistentClass referenced = mappings.getClass( entityName );\n            IndexBackref ib = new IndexBackref();\n            ib.setName( UNDERSCORE + property.getName() + \"IndexBackref\" );\n            ib.setUpdateable( false );\n            ib.setSelectable( false );\n            ib.setCollectionRole( list.getRole() );\n            ib.setEntityName( list.getOwner().getEntityName() );\n            ib.setValue( list.getIndex() );\n            referenced.addProperty( ib );\n        }\n\n    }","id":35240,"modified_method":"private static void bindListSecondPass(GrailsDomainClassProperty property, Mappings mappings, Map persistentClasses, org.hibernate.mapping.List list, Map inheritedMetas) {\n        bindCollectionSecondPass( property, mappings, persistentClasses, list,inheritedMetas );\n\n        String columnName = getColumnNameForPropertyAndPath(property, \"\")+ UNDERSCORE +IndexedCollection.DEFAULT_INDEX_COLUMN_NAME;\n\n        SimpleValue iv = new SimpleValue( list.getCollectionTable() );\n        bindSimpleValue(\"integer\", iv, true,columnName, mappings);\n        iv.setTypeName( \"integer\" );\n        list.setIndex( iv );\n        list.setBaseIndex(0);\n        list.setInverse(false);\n\n        Value v = list.getElement();\n        v.createForeignKey();\n\n\n        if(property.isBidirectional()) {\n\n\n\n            String entityName;\n            Value element = list.getElement();\n            if(element instanceof ManyToOne) {\n                ManyToOne manyToOne = (ManyToOne) element;\n                entityName = manyToOne.getReferencedEntityName();\n            }\n            else {\n                entityName = ( (OneToMany) element).getReferencedEntityName();\n            }\n\n            PersistentClass referenced = mappings.getClass( entityName );\n\n            Backref prop = new Backref();\n            prop.setEntityName(property.getDomainClass().getFullName());\n            prop.setName(UNDERSCORE + property.getDomainClass().getShortName() + UNDERSCORE + property.getName() + \"Backref\" );\n            prop.setSelectable( false );\n            prop.setUpdateable( false );\n            prop.setInsertable( true );\n            prop.setCollectionRole( list.getRole() );\n            prop.setValue( list.getKey() );\n\n            DependantValue value = (DependantValue) prop.getValue();\n            value.setNullable(false);\n            value.setUpdateable(true);\n            prop.setOptional( false );\n\n            referenced.addProperty( prop );\n            \n            IndexBackref ib = new IndexBackref();\n            ib.setName( UNDERSCORE + property.getName() + \"IndexBackref\" );\n            ib.setUpdateable( false );\n            ib.setSelectable( false );\n            ib.setCollectionRole( list.getRole() );\n            ib.setEntityName( list.getOwner().getEntityName() );\n            ib.setValue( list.getIndex() );\n            referenced.addProperty( ib );\n        }\n\n    }","commit_id":"0da55819c672aad9246e59b1380e7d16dc55505c","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * Returns a new instance of the specified {@link JRExporter} class.\n\t * @see #setExporterClass(Class)\n\t * @see BeanUtils#instantiateClass(Class)\n\t */\n\t@Override\n\tprotected JRExporter createExporter() {\n\t\treturn (JRExporter) BeanUtils.instantiateClass(this.exporterClass);\n\t}","id":35241,"modified_method":"/**\n\t * Returns a new instance of the specified {@link JRExporter} class.\n\t * @see #setExporterClass(Class)\n\t * @see BeanUtils#instantiateClass(Class)\n\t */\n\t@Override\n\tprotected JRExporter createExporter() {\n\t\treturn BeanUtils.instantiateClass(this.exporterClass);\n\t}","commit_id":"8c8eca7e059e139fd990b1d6d59187665bd4ca3e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set the {@link JRExporter} implementation <code>Class<\/code> to use. Throws\n\t * {@link IllegalArgumentException} if the <code>Class<\/code> doesn't implement\n\t * {@link JRExporter}. Required setting, as it does not have a default.\n\t */\n\tpublic void setExporterClass(Class exporterClass) {\n\t\tif (!(JRExporter.class.isAssignableFrom(exporterClass))) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Exporter class [\" + exporterClass.getName() + \"] does not implement JRExporter\");\n\t\t}\n\t\tthis.exporterClass = exporterClass;\n\t}","id":35242,"modified_method":"/**\n\t * Set the {@link JRExporter} implementation <code>Class<\/code> to use. Throws\n\t * {@link IllegalArgumentException} if the <code>Class<\/code> doesn't implement\n\t * {@link JRExporter}. Required setting, as it does not have a default.\n\t */\n\tpublic void setExporterClass(Class<? extends JRExporter> exporterClass) {\n\t\tAssert.isAssignable(JRExporter.class, exporterClass);\n\t\tthis.exporterClass = exporterClass;\n\t}","commit_id":"8c8eca7e059e139fd990b1d6d59187665bd4ca3e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Creates a new <code>JasperReportsMultiFormatView<\/code> instance\n\t * with a default set of mappings.\n\t */\n\tpublic JasperReportsMultiFormatView() {\n\t\tthis.formatMappings = new HashMap<String, Class>(4);\n\t\tthis.formatMappings.put(\"csv\", JasperReportsCsvView.class);\n\t\tthis.formatMappings.put(\"html\", JasperReportsHtmlView.class);\n\t\tthis.formatMappings.put(\"pdf\", JasperReportsPdfView.class);\n\t\tthis.formatMappings.put(\"xls\", JasperReportsXlsView.class);\n\t}","id":35243,"modified_method":"/**\n\t * Creates a new <code>JasperReportsMultiFormatView<\/code> instance\n\t * with a default set of mappings.\n\t */\n\tpublic JasperReportsMultiFormatView() {\n\t\tthis.formatMappings = new HashMap<String, Class<? extends AbstractJasperReportsView>>(4);\n\t\tthis.formatMappings.put(\"csv\", JasperReportsCsvView.class);\n\t\tthis.formatMappings.put(\"html\", JasperReportsHtmlView.class);\n\t\tthis.formatMappings.put(\"pdf\", JasperReportsPdfView.class);\n\t\tthis.formatMappings.put(\"xls\", JasperReportsXlsView.class);\n\t}","commit_id":"8c8eca7e059e139fd990b1d6d59187665bd4ca3e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Set the mappings of format discriminators to view class names.\n\t * The default mappings are:\n\t * <p><ul>\n\t * <li><code>csv<\/code> - <code>JasperReportsCsvView<\/code><\/li>\n\t * <li><code>html<\/code> - <code>JasperReportsHtmlView<\/code><\/li>\n\t * <li><code>pdf<\/code> - <code>JasperReportsPdfView<\/code><\/li>\n\t * <li><code>xls<\/code> - <code>JasperReportsXlsView<\/code><\/li>\n\t * <\/ul>\n\t */\n\tpublic void setFormatMappings(Map<String, Class> formatMappings) {\n\t\tif (CollectionUtils.isEmpty(formatMappings)) {\n\t\t\tthrow new IllegalArgumentException(\"'formatMappings' must not be empty\");\n\t\t}\n\t\tthis.formatMappings = formatMappings;\n\t}","id":35244,"modified_method":"/**\n\t * Set the mappings of format discriminators to view class names.\n\t * The default mappings are:\n\t * <p><ul>\n\t * <li><code>csv<\/code> - <code>JasperReportsCsvView<\/code><\/li>\n\t * <li><code>html<\/code> - <code>JasperReportsHtmlView<\/code><\/li>\n\t * <li><code>pdf<\/code> - <code>JasperReportsPdfView<\/code><\/li>\n\t * <li><code>xls<\/code> - <code>JasperReportsXlsView<\/code><\/li>\n\t * <\/ul>\n\t */\n\tpublic void setFormatMappings(Map<String, Class<? extends AbstractJasperReportsView>> formatMappings) {\n\t\tif (CollectionUtils.isEmpty(formatMappings)) {\n\t\t\tthrow new IllegalArgumentException(\"'formatMappings' must not be empty\");\n\t\t}\n\t\tthis.formatMappings = formatMappings;\n\t}","commit_id":"8c8eca7e059e139fd990b1d6d59187665bd4ca3e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Locates the format key in the model using the configured discriminator key and uses this\n\t * key to lookup the appropriate view class from the mappings. The rendering of the\n\t * report is then delegated to an instance of that view class.\n\t */\n\t@Override\n\tprotected void renderReport(JasperPrint populatedReport, Map<String, Object> model, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tString format = (String) model.get(this.formatKey);\n\t\tif (format == null) {\n\t\t\tthrow new IllegalArgumentException(\"No format format found in model\");\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rendering report using format mapping key [\" + format + \"]\");\n\t\t}\n\n\t\tClass viewClass = this.formatMappings.get(format);\n\t\tif (viewClass == null) {\n\t\t\tthrow new IllegalArgumentException(\"Format discriminator [\" + format + \"] is not a configured mapping\");\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rendering report using view class [\" + viewClass.getName() + \"]\");\n\t\t}\n\n\t\tAbstractJasperReportsView view = (AbstractJasperReportsView) BeanUtils.instantiateClass(viewClass);\n\t\t// Can skip most initialization since all relevant URL processing\n\t\t// has been done - just need to convert parameters on the sub view.\n\t\tview.setExporterParameters(getExporterParameters());\n\t\tview.setConvertedExporterParameters(getConvertedExporterParameters());\n\n\t\t// Prepare response and render report.\n\t\tpopulateContentDispositionIfNecessary(response, format);\n\t\tview.renderReport(populatedReport, model, response);\n\t}","id":35245,"modified_method":"/**\n\t * Locates the format key in the model using the configured discriminator key and uses this\n\t * key to lookup the appropriate view class from the mappings. The rendering of the\n\t * report is then delegated to an instance of that view class.\n\t */\n\t@Override\n\tprotected void renderReport(JasperPrint populatedReport, Map<String, Object> model, HttpServletResponse response)\n\t\t\tthrows Exception {\n\n\t\tString format = (String) model.get(this.formatKey);\n\t\tif (format == null) {\n\t\t\tthrow new IllegalArgumentException(\"No format format found in model\");\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rendering report using format mapping key [\" + format + \"]\");\n\t\t}\n\n\t\tClass<? extends AbstractJasperReportsView> viewClass = this.formatMappings.get(format);\n\t\tif (viewClass == null) {\n\t\t\tthrow new IllegalArgumentException(\"Format discriminator [\" + format + \"] is not a configured mapping\");\n\t\t}\n\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Rendering report using view class [\" + viewClass.getName() + \"]\");\n\t\t}\n\n\t\tAbstractJasperReportsView view = BeanUtils.instantiateClass(viewClass);\n\t\t// Can skip most initialization since all relevant URL processing\n\t\t// has been done - just need to convert parameters on the sub view.\n\t\tview.setExporterParameters(getExporterParameters());\n\t\tview.setConvertedExporterParameters(getConvertedExporterParameters());\n\n\t\t// Prepare response and render report.\n\t\tpopulateContentDispositionIfNecessary(response, format);\n\t\tview.renderReport(populatedReport, model, response);\n\t}","commit_id":"8c8eca7e059e139fd990b1d6d59187665bd4ca3e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testExporterParametersAreCarriedAcross() throws Exception {\n\t\tif (!canCompileReport) {\n\t\t\treturn;\n\t\t}\n\n\t\tJasperReportsMultiFormatView view = (JasperReportsMultiFormatView) getView(UNCOMPILED_REPORT);\n\n\t\tMap<String, Class> mappings = new HashMap<String, Class>();\n\t\tmappings.put(\"test\", ExporterParameterTestView.class);\n\n\t\tMap<String, String> exporterParameters = new HashMap<String, String>();\n\n\t\t// test view class performs the assertions - robh\n\t\texporterParameters.put(ExporterParameterTestView.TEST_PARAM, \"foo\");\n\n\t\tview.setExporterParameters(exporterParameters);\n\t\tview.setFormatMappings(mappings);\n\t\tview.initApplicationContext();\n\n\t\tMap<String, Object> model = getBaseModel();\n\t\tmodel.put(getDiscriminatorKey(), \"test\");\n\n\t\tview.render(model, request, response);\n\t}","id":35246,"modified_method":"public void testExporterParametersAreCarriedAcross() throws Exception {\n\t\tif (!canCompileReport) {\n\t\t\treturn;\n\t\t}\n\n\t\tJasperReportsMultiFormatView view = (JasperReportsMultiFormatView) getView(UNCOMPILED_REPORT);\n\n\t\tMap<String, Class<? extends AbstractJasperReportsView>> mappings =\n\t\t\t\tnew HashMap<String, Class<? extends AbstractJasperReportsView>>();\n\t\tmappings.put(\"test\", ExporterParameterTestView.class);\n\n\t\tMap<String, String> exporterParameters = new HashMap<String, String>();\n\n\t\t// test view class performs the assertions - robh\n\t\texporterParameters.put(ExporterParameterTestView.TEST_PARAM, \"foo\");\n\n\t\tview.setExporterParameters(exporterParameters);\n\t\tview.setFormatMappings(mappings);\n\t\tview.initApplicationContext();\n\n\t\tMap<String, Object> model = getBaseModel();\n\t\tmodel.put(getDiscriminatorKey(), \"test\");\n\n\t\tview.render(model, request, response);\n\t}","commit_id":"8c8eca7e059e139fd990b1d6d59187665bd4ca3e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected AbstractJasperReportsView getViewImplementation() {\n\t\tJasperReportsMultiFormatView view = new JasperReportsMultiFormatView();\n\t\tview.setFormatKey(\"fmt\");\n\t\tMap<String, Class> mappings = new HashMap<String, Class>();\n\t\tmappings.put(\"csv\", JasperReportsCsvView.class);\n\t\tmappings.put(\"comma-separated\", JasperReportsCsvView.class);\n\t\tmappings.put(\"html\", JasperReportsHtmlView.class);\n\t\tview.setFormatMappings(mappings);\n\t\treturn view;\n\t}","id":35247,"modified_method":"protected AbstractJasperReportsView getViewImplementation() {\n\t\tJasperReportsMultiFormatView view = new JasperReportsMultiFormatView();\n\t\tview.setFormatKey(\"fmt\");\n\t\tMap<String, Class<? extends AbstractJasperReportsView>> mappings =\n\t\t\t\tnew HashMap<String, Class<? extends AbstractJasperReportsView>>();\n\t\tmappings.put(\"csv\", JasperReportsCsvView.class);\n\t\tmappings.put(\"comma-separated\", JasperReportsCsvView.class);\n\t\tmappings.put(\"html\", JasperReportsHtmlView.class);\n\t\tview.setFormatMappings(mappings);\n\t\treturn view;\n\t}","commit_id":"8c8eca7e059e139fd990b1d6d59187665bd4ca3e","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void shutdown(DataSource dataSource, String databaseName) {\n\t\tConnection connection = JdbcUtils.getConnection(dataSource);\n\t\tStatement stmt = null;\n\t\ttry {\n\t\t\tstmt = connection.createStatement();\n\t\t\tstmt.execute(\"SHUTDOWN\");\n\t\t} catch (SQLException e) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Could not shutdown embedded database\", e);\n\t\t\t}\n\t\t} finally {\n\t\t\tJdbcUtils.closeStatement(stmt);\n\t\t}\n\t}","id":35248,"modified_method":"public void shutdown(DataSource dataSource, String databaseName) {\n\t\ttry {\n\t\t\tConnection connection = dataSource.getConnection();\n\t\t\tStatement stmt = connection.createStatement();\n\t\t\tstmt.execute(\"SHUTDOWN\");\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Could not shutdown embedded database\", ex);\n\t\t\t}\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Purges the in-memory database, to prevent it from hanging around after\n\t * being shut down\n\t * @param databaseName\n\t */\n\tprivate void purgeDatabase(String databaseName) {\n\t\t// TODO: update this code once Derby adds a proper way to remove an in-memory db\n\t\t// (see http://wiki.apache.org/db-derby/InMemoryBackEndPrimer for details)\n\t\ttry {\n\t\t\tVFMemoryStorageFactory.purgeDatabase(new File(databaseName).getCanonicalPath());\n\t\t} catch (IOException ioe) {\n\t\t\tlogger.warn(\"Could not purge in-memory Derby database\", ioe);\n\t\t}\n\t}","id":35249,"modified_method":"/**\n\t * Purge the in-memory database, to prevent it from hanging around after\n\t * being shut down.\n\t */\n\tprivate void purgeDatabase(String databaseName) {\n\t\t// TODO: update this code once Derby adds a proper way to remove an in-memory db\n\t\t// (see http://wiki.apache.org/db-derby/InMemoryBackEndPrimer for details)\n\t\ttry {\n\t\t\tVFMemoryStorageFactory.purgeDatabase(new File(databaseName).getCanonicalPath());\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tlogger.warn(\"Could not purge in-memory Derby database\", ex);\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {\n\t\tproperties.setDriverClass(org.apache.derby.jdbc.EmbeddedDriver.class);\n\t\tproperties.setUrl(String.format(URL_TEMPLATE, databaseName, \"create=true\"));\n\t\tproperties.setUsername(\"sa\");\n\t\tproperties.setPassword(\"\");\n\t}","id":35250,"modified_method":"public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {\n\t\tproperties.setDriverClass(EmbeddedDriver.class);\n\t\tproperties.setUrl(String.format(URL_TEMPLATE, databaseName, \"create=true\"));\n\t\tproperties.setUsername(\"sa\");\n\t\tproperties.setPassword(\"\");\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void shutdown(DataSource dataSource, String databaseName) {\n\t\tConnection connection = null;\n\t\ttry {\n\t\t\tSimpleDriverDataSource shutdownDataSource = new SimpleDriverDataSource();\n\t\t\tshutdownDataSource.setDriverClass(EmbeddedDriver.class);\n\t\t\tshutdownDataSource.setUrl(String.format(URL_TEMPLATE, databaseName, \"shutdown=true\"));\n\t\t\tconnection = shutdownDataSource.getConnection();\n\t\t} catch (SQLException e) {\n\t\t\tif (SHUTDOWN_CODE.equals(e.getSQLState())) {\n\t\t\t\tpurgeDatabase(databaseName);\n\t\t\t} else {\n\t\t\t\tlogger.warn(\"Could not shutdown in-memory Derby database\", e);\n\t\t\t}\n\t\t} finally {\n\t\t\tJdbcUtils.closeConnection(connection);\n\t\t}\n\t}","id":35251,"modified_method":"public void shutdown(DataSource dataSource, String databaseName) {\n\t\ttry {\n\t\t\tnew EmbeddedDriver().connect(\n\t\t\t\t\tString.format(URL_TEMPLATE, databaseName, \"shutdown=true\"), new Properties());\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tif (SHUTDOWN_CODE.equals(ex.getSQLState())) {\n\t\t\t\tpurgeDatabase(databaseName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.warn(\"Could not shutdown in-memory Derby database\", ex);\n\t\t\t}\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Get the singleton {@link DerbyEmbeddedDatabaseConfigurer} instance.\n\t * @return the configurer\n\t * @throws ClassNotFoundException if Derby is not on the classpath\n\t */\n\tpublic static synchronized DerbyEmbeddedDatabaseConfigurer getInstance() throws ClassNotFoundException {\n\t\tif (INSTANCE == null) {\n\t\t\t// disable log file\n\t\t\tSystem.setProperty(\"derby.stream.error.method\", \n\t\t\t\t\tDerbyEmbeddedDatabaseConfigurer.class.getName() + \".getNoopOutputStream\");\n\t\t\tClassUtils.forName(\"org.apache.derby.jdbc.EmbeddedDriver\", DerbyEmbeddedDatabaseConfigurer.class\n\t\t\t\t\t.getClassLoader());\n\t\t\tINSTANCE = new DerbyEmbeddedDatabaseConfigurer();\n\t\t}\n\t\treturn INSTANCE;\n\t}","id":35252,"modified_method":"/**\n\t * Get the singleton {@link DerbyEmbeddedDatabaseConfigurer} instance.\n\t * @return the configurer\n\t * @throws ClassNotFoundException if Derby is not on the classpath\n\t */\n\tpublic static synchronized DerbyEmbeddedDatabaseConfigurer getInstance() throws ClassNotFoundException {\n\t\tif (INSTANCE == null) {\n\t\t\t// disable log file\n\t\t\tSystem.setProperty(\"derby.stream.error.method\", \n\t\t\t\t\tDerbyEmbeddedDatabaseConfigurer.class.getName() + \".getNoopOutputStream\");\n\t\t\tINSTANCE = new DerbyEmbeddedDatabaseConfigurer();\n\t\t}\n\t\treturn INSTANCE;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Sets the name of the embedded database\n\t * Defaults to 'testdb' if not called.\n\t * @param databaseName the database name\n\t * @return this, for fluent call chaining\n\t */\n\tpublic EmbeddedDatabaseBuilder name(String databaseName) {\n\t\tdatabaseFactory.setDatabaseName(databaseName);\n\t\treturn this;\n\t}","id":35253,"modified_method":"/**\n\t * Sets the name of the embedded database\n\t * Defaults to 'testdb' if not called.\n\t * @param databaseName the database name\n\t * @return this, for fluent call chaining\n\t */\n\tpublic EmbeddedDatabaseBuilder name(String databaseName) {\n\t\tthis.databaseFactory.setDatabaseName(databaseName);\n\t\treturn this;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Creates a new embedded database builder.\n\t */\n\tpublic EmbeddedDatabaseBuilder() {\n\t\tinit(new DefaultResourceLoader());\n\t}","id":35254,"modified_method":"/**\n\t * Create a new embedded database builder.\n\t */\n\tpublic EmbeddedDatabaseBuilder() {\n\t\tthis(new DefaultResourceLoader());\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Build the embedded database.\n\t * @return the embedded database\n\t */\n\tpublic EmbeddedDatabase build() {\n\t\treturn databaseFactory.getDatabase();\n\t}","id":35255,"modified_method":"/**\n\t * Build the embedded database.\n\t * @return the embedded database\n\t */\n\tpublic EmbeddedDatabase build() {\n\t\treturn this.databaseFactory.getDatabase();\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Factory method that creates a EmbeddedDatabaseBuilder that loads SQL resources relative to the provided class.\n\t * @param clazz the class to load relative to\n\t * @return the embedded database builder\n\t */\n\tpublic static EmbeddedDatabaseBuilder relativeTo(final Class<?> clazz) {\n\t\tResourceLoader loader = new ResourceLoader() {\n\t\t\tpublic ClassLoader getClassLoader() {\n\t\t\t\treturn getClass().getClassLoader();\n\t\t\t}\n\n\t\t\tpublic Resource getResource(String location) {\n\t\t\t\treturn new ClassPathResource(location, clazz);\n\t\t\t}\t\t\t\n\t\t};\n\t\treturn new EmbeddedDatabaseBuilder(loader);\n\t}","id":35256,"modified_method":"/**\n\t * Factory method that creates a EmbeddedDatabaseBuilder that loads SQL resources\n\t * relative to the provided class.\n\t * @param clazz the class to load relative to\n\t * @return the embedded database builder\n\t */\n\tpublic static EmbeddedDatabaseBuilder relativeTo(Class clazz) {\n\t\treturn new EmbeddedDatabaseBuilder(new ClassRelativeResourceLoader(clazz));\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Sets the type of embedded database.\n\t * Defaults to HSQL if not called.\n\t * @param databaseType the database type\n\t * @return this, for fluent call chaining\n\t */\n\tpublic EmbeddedDatabaseBuilder type(EmbeddedDatabaseType databaseType) {\n\t\tdatabaseFactory.setDatabaseType(databaseType);\n\t\treturn this;\n\t}","id":35257,"modified_method":"/**\n\t * Sets the type of embedded database.\n\t * Defaults to HSQL if not called.\n\t * @param databaseType the database type\n\t * @return this, for fluent call chaining\n\t */\n\tpublic EmbeddedDatabaseBuilder type(EmbeddedDatabaseType databaseType) {\n\t\tthis.databaseFactory.setDatabaseType(databaseType);\n\t\treturn this;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private EmbeddedDatabaseBuilder(ResourceLoader loader) {\n\t\tinit(loader);\n\t}","id":35258,"modified_method":"/**\n\t * Create a new embedded database builder withfor the given ResourceLoader.\n\t * @param resourceLoader the ResourceLoader to delegate to\n\t */\n\tpublic EmbeddedDatabaseBuilder(ResourceLoader resourceLoader) {\n\t\tthis.databaseFactory = new EmbeddedDatabaseFactory();\n\t\tthis.databasePopulator = new ResourceDatabasePopulator();\n\t\tthis.databaseFactory.setDatabasePopulator(this.databasePopulator);\n\t\tthis.resourceLoader = resourceLoader;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Adds a SQL script to execute to populate the database.\n\t * @param sqlResource the sql resource location\n\t * @return this, for fluent call chaining\n\t */\n\tpublic EmbeddedDatabaseBuilder script(String sqlResource) {\n\t\tdatabasePopulator.addScript(resourceLoader.getResource(sqlResource));\n\t\treturn this;\n\t}","id":35259,"modified_method":"/**\n\t * Adds a SQL script to execute to populate the database.\n\t * @param sqlResource the sql resource location\n\t * @return this, for fluent call chaining\n\t */\n\tpublic EmbeddedDatabaseBuilder script(String sqlResource) {\n\t\tthis.databasePopulator.addScript(resourceLoader.getResource(sqlResource));\n\t\treturn this;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) throws IllegalStateException {\n\t\tAssert.notNull(type, \"The EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\tswitch (type) {\n\t\t\tcase HSQL:\n\t\t\t\treturn HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\tcase H2:\n\t\t\t\treturn H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\tcase DERBY:\n\t\t\t\treturn DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\tdefault:\n\t\t\t\tthrow new UnsupportedOperationException(\"Other embedded database types not yet supported\");\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tthrow new IllegalStateException(\"Drivers for test database type [\" + type\n\t\t\t\t\t+ \"] are not available in the classpath\", e);\n\t\t}\n\t}","id":35260,"modified_method":"public static EmbeddedDatabaseConfigurer getConfigurer(EmbeddedDatabaseType type) throws IllegalStateException {\n\t\tAssert.notNull(type, \"EmbeddedDatabaseType is required\");\n\t\ttry {\n\t\t\tswitch (type) {\n\t\t\t\tcase HSQL:\n\t\t\t\t\treturn HsqlEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase H2:\n\t\t\t\t\treturn H2EmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tcase DERBY:\n\t\t\t\t\treturn DerbyEmbeddedDatabaseConfigurer.getInstance();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new UnsupportedOperationException(\"Other embedded database types not yet supported\");\n\t\t\t}\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tthrow new IllegalStateException(\"Driver for test database type [\" + type +\n\t\t\t\t\t\"] is not available in the classpath\", ex);\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public PrintWriter getLogWriter() throws SQLException {\n\t\t\treturn dataSource.getLogWriter();\n\t\t}","id":35261,"modified_method":"public PrintWriter getLogWriter() throws SQLException {\n\t\t\treturn this.dataSource.getLogWriter();\n\t\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void setLogWriter(PrintWriter out) throws SQLException {\n\t\t\tdataSource.setLogWriter(out);\n\t\t}","id":35262,"modified_method":"public void setLogWriter(PrintWriter out) throws SQLException {\n\t\t\tthis.dataSource.setLogWriter(out);\n\t\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Sets the strategy that will be used to configure the embedded database instance.\n\t * Call this when you wish to use an embedded database type not already supported.\n\t * @param configurer the embedded database configurer\n\t */\n\tpublic void setDatabaseConfigurer(EmbeddedDatabaseConfigurer configurer) {\n\t\tthis.databaseConfigurer = configurer;\n\t}","id":35263,"modified_method":"/**\n\t * Set the strategy that will be used to configure the embedded database instance.\n\t * Call this when you wish to use an embedded database type not already supported.\n\t * @param configurer the embedded database configurer\n\t */\n\tpublic void setDatabaseConfigurer(EmbeddedDatabaseConfigurer configurer) {\n\t\tAssert.notNull(configurer, \"EmbeddedDatabaseConfigurer is required\");\n\t\tthis.databaseConfigurer = configurer;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Sets the type of embedded database to use. Call this when you wish to configure one of the pre-supported types.\n\t * Defaults to HSQL.\n\t * @param type the test database type\n\t */\n\tpublic void setDatabaseType(EmbeddedDatabaseType type) {\n\t\tsetDatabaseConfigurer(EmbeddedDatabaseConfigurerFactory.getConfigurer(type));\n\t}","id":35264,"modified_method":"/**\n\t * Set the type of embedded database to use. Call this when you wish to configure\n\t * one of the pre-supported types. Defaults to HSQL.\n\t * @param type the test database type\n\t */\n\tpublic void setDatabaseType(EmbeddedDatabaseType type) {\n\t\tthis.databaseConfigurer = EmbeddedDatabaseConfigurerFactory.getConfigurer(type);\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Hook to shutdown the embedded database. Subclasses may call to force shutdown.\n\t * After calling, {@link #getDataSource()} returns null. Does nothing if no embedded database has been initialized.\n\t */\n\tprotected void shutdownDatabase() {\n\t\tif (dataSource != null) {\n\t\t\tdatabaseConfigurer.shutdown(dataSource, databaseName);\n\t\t\tdataSource = null;\n\t\t}\n\t}","id":35265,"modified_method":"/**\n\t * Hook to shutdown the embedded database. Subclasses may call to force shutdown.\n\t * After calling, {@link #getDataSource()} returns null. Does nothing if no embedded database has been initialized.\n\t */\n\tprotected void shutdownDatabase() {\n\t\tif (this.dataSource != null) {\n\t\t\tthis.databaseConfigurer.shutdown(this.dataSource, this.databaseName);\n\t\t\tthis.dataSource = null;\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Sets the name of the database. Defaults to 'testdb'.\n\t * @param name of the test database\n\t */\n\tpublic void setDatabaseName(String name) {\n\t\tAssert.notNull(name, \"The testDatabaseName is required\");\n\t\tdatabaseName = name;\n\t}","id":35266,"modified_method":"/**\n\t * Set the name of the database. Defaults to \"testdb\".\n\t * @param databaseName name of the test database\n\t */\n\tpublic void setDatabaseName(String databaseName) {\n\t\tAssert.notNull(databaseName, \"Database name is required\");\n\t\tthis.databaseName = databaseName;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Connection getConnection() throws SQLException {\n\t\t\treturn dataSource.getConnection();\n\t\t}","id":35267,"modified_method":"public Connection getConnection() throws SQLException {\n\t\t\treturn this.dataSource.getConnection();\n\t\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Hook that gets the datasource that provides the connectivity to the embedded database.\n\t * Returns null if the datasource has not been initialized or the database has been shutdown.\n\t * Subclasses may call to access the datasource instance directly.\n\t * @return the datasource\n\t */\n\tprotected DataSource getDataSource() {\n\t\treturn dataSource;\n\t}","id":35268,"modified_method":"/**\n\t * Hook that gets the DataSource that provides the connectivity to the embedded database.\n\t * <p>Returns null if the DataSource has not been initialized or the database has been shut down.\n\t * Subclasses may call to access the datasource instance directly.\n\t */\n\tprotected DataSource getDataSource() {\n\t\treturn this.dataSource;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void populateDatabase() {\n\t\tConnection connection = JdbcUtils.getConnection(dataSource);\n\t\ttry {\n\t\t\tdatabasePopulator.populate(connection);\n\t\t} catch (SQLException e) {\n\t\t\tthrow new RuntimeException(\"SQLException occurred populating embedded database\", e);\n\t\t} finally {\n\t\t\tJdbcUtils.closeConnection(connection);\n\t\t}\n\t}","id":35269,"modified_method":"private void populateDatabase() {\n\t\ttry {\n\t\t\tConnection connection = this.dataSource.getConnection();\n\t\t\ttry {\n\t\t\t\tthis.databasePopulator.populate(connection);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\ttry {\n\t\t\t\t\tconnection.close();\n\t\t\t\t}\n\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\t// ignore\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (SQLException ex) {\n\t\t\tthrow new DataAccessResourceFailureException(\"Failed to populate database\", ex);\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public int getLoginTimeout() throws SQLException {\n\t\t\treturn dataSource.getLoginTimeout();\n\t\t}","id":35270,"modified_method":"public int getLoginTimeout() throws SQLException {\n\t\t\treturn this.dataSource.getLoginTimeout();\n\t\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public boolean isWrapperFor(Class<?> iface) throws SQLException {\n\t\t\treturn dataSource.isWrapperFor(iface);\n\t\t}","id":35271,"modified_method":"public boolean isWrapperFor(Class<?> iface) throws SQLException {\n\t\t\treturn this.dataSource.isWrapperFor(iface);\n\t\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Sets the factory to use to create the DataSource instance that connects to the embedded database\n\t * Defaults to {@link SimpleDriverDataSourceFactory}.\n\t * @param dataSourceFactory the data source factory\n\t */\n\tpublic void setDataSourceFactory(DataSourceFactory dataSourceFactory) {\n\t\tAssert.notNull(dataSourceFactory, \"The DataSourceFactory is required\");\n\t\tthis.dataSourceFactory = dataSourceFactory;\n\t}","id":35272,"modified_method":"/**\n\t * Set the factory to use to create the DataSource instance that connects to the embedded database.\n\t * Defaults to {@link SimpleDriverDataSourceFactory}.\n\t * @param dataSourceFactory the data source factory\n\t */\n\tpublic void setDataSourceFactory(DataSourceFactory dataSourceFactory) {\n\t\tAssert.notNull(dataSourceFactory, \"DataSourceFactory is required\");\n\t\tthis.dataSourceFactory = dataSourceFactory;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void setLoginTimeout(int seconds) throws SQLException {\n\t\t\tdataSource.setLoginTimeout(seconds);\n\t\t}","id":35273,"modified_method":"public void setLoginTimeout(int seconds) throws SQLException {\n\t\t\tthis.dataSource.setLoginTimeout(seconds);\n\t\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Factory method that returns the embedded database instance.\n\t */\n\tpublic EmbeddedDatabase getDatabase() {\n\t\tif (dataSource == null) {\n\t\t\tinitDatabase();\n\t\t}\n\t\treturn new EmbeddedDataSourceProxy(dataSource);\n\t}","id":35274,"modified_method":"/**\n\t * Factory method that returns the embedded database instance.\n\t */\n\tpublic EmbeddedDatabase getDatabase() {\n\t\tif (this.dataSource == null) {\n\t\t\tinitDatabase();\n\t\t}\n\t\treturn new EmbeddedDataSourceProxy(this.dataSource);\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public <T> T unwrap(Class<T> iface) throws SQLException {\n\t\t\treturn dataSource.unwrap(iface);\n\t\t}","id":35275,"modified_method":"public <T> T unwrap(Class<T> iface) throws SQLException {\n\t\t\treturn this.dataSource.unwrap(iface);\n\t\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public Connection getConnection(String username, String password) throws SQLException {\n\t\t\treturn dataSource.getConnection(username, password);\n\t\t}","id":35276,"modified_method":"public Connection getConnection(String username, String password) throws SQLException {\n\t\t\treturn this.dataSource.getConnection(username, password);\n\t\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Sets the strategy that will be used to populate the embedded database. Defaults to null.\n\t * @param populator the database populator\n\t */\n\tpublic void setDatabasePopulator(DatabasePopulator populator) {\n\t\tAssert.notNull(populator, \"The DatabasePopulator is required\");\n\t\tdatabasePopulator = populator;\n\t}","id":35277,"modified_method":"/**\n\t * Set the strategy that will be used to populate the embedded database. Defaults to null.\n\t * @param populator the database populator\n\t */\n\tpublic void setDatabasePopulator(DatabasePopulator populator) {\n\t\tAssert.notNull(populator, \"DatabasePopulator is required\");\n\t\tthis.databasePopulator = populator;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Hook to initialize the embedded database. Subclasses may call to force initialization. After calling this method,\n\t * {@link #getDataSource()} returns the DataSource providing connectivity to the db.\n\t */\n\tprotected void initDatabase() {\n\t\t// create the embedded database source first\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Created embedded database '\" + databaseName + \"'\");\n\t\t}\n\t\tdatabaseConfigurer.configureConnectionProperties(dataSourceFactory.getConnectionProperties(), databaseName);\n\t\tdataSource = dataSourceFactory.getDataSource();\n\t\tif (databasePopulator != null) {\n\t\t\t// now populate the database\n\t\t\tpopulateDatabase();\n\t\t}\n\t}","id":35278,"modified_method":"/**\n\t * Hook to initialize the embedded database. Subclasses may call to force initialization. After calling this method,\n\t * {@link #getDataSource()} returns the DataSource providing connectivity to the db.\n\t */\n\tprotected void initDatabase() {\n\t\t// Create the embedded database source first\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Creating embedded database '\" + this.databaseName + \"'\");\n\t\t}\n\t\tif (this.databaseConfigurer == null) {\n\t\t\tthis.databaseConfigurer = EmbeddedDatabaseConfigurerFactory.getConfigurer(EmbeddedDatabaseType.HSQL);\n\t\t}\n\t\tthis.databaseConfigurer.configureConnectionProperties(\n\t\t\t\tthis.dataSourceFactory.getConnectionProperties(), this.databaseName);\n\t\tthis.dataSource = this.dataSourceFactory.getDataSource();\n\n\t\t// Now populate the database\n\t\tif (this.databasePopulator != null) {\n\t\t\tpopulateDatabase();\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {\n\t\tproperties.setDriverClass(driverClass);\n\t\tproperties.setUrl(String.format(\"jdbc:h2:mem:%s;DB_CLOSE_DELAY=-1\", databaseName));\n\t\tproperties.setUsername(\"sa\");\n\t\tproperties.setPassword(\"\");\n\t}","id":35279,"modified_method":"public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {\n\t\tproperties.setDriverClass(this.driverClass);\n\t\tproperties.setUrl(String.format(\"jdbc:h2:mem:%s;DB_CLOSE_DELAY=-1\", databaseName));\n\t\tproperties.setUsername(\"sa\");\n\t\tproperties.setPassword(\"\");\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {\n\t\tproperties.setDriverClass(driverClass);\n\t\tproperties.setUrl(\"jdbc:hsqldb:mem:\" + databaseName);\n\t\tproperties.setUsername(\"sa\");\n\t\tproperties.setPassword(\"\");\n\t}","id":35280,"modified_method":"public void configureConnectionProperties(ConnectionProperties properties, String databaseName) {\n\t\tproperties.setDriverClass(this.driverClass);\n\t\tproperties.setUrl(\"jdbc:hsqldb:mem:\" + databaseName);\n\t\tproperties.setUsername(\"sa\");\n\t\tproperties.setPassword(\"\");\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private EncodedResource applyEncodingIfNecessary(Resource script) {\n\t\tif (script instanceof EncodedResource) {\n\t\t\treturn (EncodedResource) script;\n\t\t} else {\n\t\t\treturn new EncodedResource(script, sqlScriptEncoding);\n\t\t}\n\t}","id":35281,"modified_method":"private EncodedResource applyEncodingIfNecessary(Resource script) {\n\t\tif (script instanceof EncodedResource) {\n\t\t\treturn (EncodedResource) script;\n\t\t}\n\t\telse {\n\t\t\treturn new EncodedResource(script, this.sqlScriptEncoding);\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void populate(Connection connection) throws SQLException {\n\t\tfor (Resource script : scripts) {\n\t\t\texecuteSqlScript(connection, applyEncodingIfNecessary(script), false);\n\t\t}\n\t}","id":35282,"modified_method":"public void populate(Connection connection) throws SQLException {\n\t\tfor (Resource script : this.scripts) {\n\t\t\texecuteSqlScript(connection, applyEncodingIfNecessary(script), false);\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Execute the given SQL script. <p>The script will normally be loaded by classpath. There should be one statement\n\t * per line. Any semicolons will be removed. <b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param template the SimpleJdbcTemplate with which to perform JDBC operations\n\t * @param resource the resource (potentially associated with a specific encoding) to load the SQL script from.\n\t * @param continueOnError whether or not to continue without throwing an exception in the event of an error.\n\t */\n\tprivate void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError)\n\t\t\tthrows SQLException {\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Executing SQL script from \" + resource);\n\t\t}\n\t\tlong startTime = System.currentTimeMillis();\n\t\tList<String> statements = new LinkedList<String>();\n\t\tString script;\n\t\ttry {\n\t\t\tscript = readScript(resource);\n\t\t} catch (IOException e) {\n\t\t\tthrow new CannotReadScriptException(resource, e);\n\t\t}\n\t\tchar delimiter = ';';\n\t\tif (!containsSqlScriptDelimiters(script, delimiter)) {\n\t\t\tdelimiter = '\\n';\n\t\t}\n\t\tsplitSqlScript(script, delimiter, statements);\n\t\tint lineNumber = 0;\n\t\tfor (String statement : statements) {\n\t\t\tlineNumber++;\n\t\t\tStatement stmt = null;\n\t\t\ttry {\n\t\t\t\tstmt = connection.createStatement();\n\t\t\t\tint rowsAffected = stmt.executeUpdate(statement);\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(rowsAffected + \" rows affected by SQL: \" + statement);\n\t\t\t\t}\n\t\t\t} catch (SQLException e) {\n\t\t\t\tif (continueOnError) {\n\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\tlogger.warn(\"Line \" + lineNumber + \" statement failed: \" + statement, e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tJdbcUtils.closeStatement(stmt);\n\t\t\t}\n\t\t}\n\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Done executing SQL script from \" + resource + \" in \" + elapsedTime + \" ms.\");\n\t\t}\n\t}","id":35283,"modified_method":"/**\n\t * Execute the given SQL script. <p>The script will normally be loaded by classpath. There should be one statement\n\t * per line. Any semicolons will be removed. <b>Do not use this method to execute DDL if you expect rollback.<\/b>\n\t * @param template the SimpleJdbcTemplate with which to perform JDBC operations\n\t * @param resource the resource (potentially associated with a specific encoding) to load the SQL script from.\n\t * @param continueOnError whether or not to continue without throwing an exception in the event of an error.\n\t */\n\tprivate void executeSqlScript(Connection connection, EncodedResource resource, boolean continueOnError)\n\t\t\tthrows SQLException {\n\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Executing SQL script from \" + resource);\n\t\t}\n\t\tlong startTime = System.currentTimeMillis();\n\t\tList<String> statements = new LinkedList<String>();\n\t\tString script;\n\t\ttry {\n\t\t\tscript = readScript(resource);\n\t\t} catch (IOException e) {\n\t\t\tthrow new CannotReadScriptException(resource, e);\n\t\t}\n\t\tchar delimiter = ';';\n\t\tif (!containsSqlScriptDelimiters(script, delimiter)) {\n\t\t\tdelimiter = '\\n';\n\t\t}\n\t\tsplitSqlScript(script, delimiter, statements);\n\t\tint lineNumber = 0;\n\t\tStatement stmt = connection.createStatement();\n\t\ttry {\n\t\t\tfor (String statement : statements) {\n\t\t\t\tlineNumber++;\n\t\t\t\ttry {\n\t\t\t\t\tint rowsAffected = stmt.executeUpdate(statement);\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(rowsAffected + \" rows affected by SQL: \" + statement);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (SQLException ex) {\n\t\t\t\t\tif (continueOnError) {\n\t\t\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\t\t\tlogger.warn(\"Line \" + lineNumber + \" statement failed: \" + statement, ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tstmt.close();\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tlogger.debug(\"Could not close JDBC Statement\", ex);\n\t\t\t}\n\t\t}\n\t\tlong elapsedTime = System.currentTimeMillis() - startTime;\n\t\tif (logger.isInfoEnabled()) {\n\t\t\tlogger.info(\"Done executing SQL script from \" + resource + \" in \" + elapsedTime + \" ms.\");\n\t\t}\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Specify the JDBC Driver implementation class to use.\n\t * <p>An instance of this Driver class will be created and held\n\t * within the SimpleDriverDataSource.\n\t * @see #setDriver\n\t */\n\tpublic void setDriverClass(Class driverClass) {\n\t\tthis.driver = (Driver) BeanUtils.instantiateClass(driverClass);\n\t}","id":35284,"modified_method":"/**\n\t * Specify the JDBC Driver implementation class to use.\n\t * <p>An instance of this Driver class will be created and held\n\t * within the SimpleDriverDataSource.\n\t * @see #setDriver\n\t */\n\tpublic void setDriverClass(Class<? extends Driver> driverClass) {\n\t\tthis.driver = BeanUtils.instantiateClass(driverClass);\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public DataSource getDataSource() {\n\t\treturn dataSource;\n\t}","id":35285,"modified_method":"public DataSource getDataSource() {\n\t\treturn this.dataSource;\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public ConnectionProperties getConnectionProperties() {\n\t\treturn new ConnectionProperties() {\n\t\t\tpublic void setDriverClass(Class<?> driverClass) {\n\t\t\t\tdataSource.setDriverClass(driverClass);\n\t\t\t}\n\n\t\t\tpublic void setUrl(String url) {\n\t\t\t\tdataSource.setUrl(url);\n\t\t\t}\n\n\t\t\tpublic void setUsername(String username) {\n\t\t\t\tdataSource.setUsername(username);\n\t\t\t}\n\n\t\t\tpublic void setPassword(String password) {\n\t\t\t\tdataSource.setPassword(password);\n\t\t\t}\n\t\t};\n\t}","id":35286,"modified_method":"public ConnectionProperties getConnectionProperties() {\n\t\treturn new ConnectionProperties() {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tpublic void setDriverClass(Class driverClass) {\n\t\t\t\tAssert.isAssignable(Driver.class, driverClass);\n\t\t\t\tdataSource.setDriverClass((Class<? extends Driver>) driverClass);\n\t\t\t}\n\t\t\tpublic void setUrl(String url) {\n\t\t\t\tdataSource.setUrl(url);\n\t\t\t}\n\t\t\tpublic void setUsername(String username) {\n\t\t\t\tdataSource.setUsername(username);\n\t\t\t}\n\t\t\tpublic void setPassword(String password) {\n\t\t\t\tdataSource.setPassword(password);\n\t\t\t}\n\t\t};\n\t}","commit_id":"e9823b57b4ff5a8a0b82e56b5720a96b5e5bbbd3","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public boolean appliesTo(ColumnFamily current) throws InvalidRequestException\n        {\n            if (current == null)\n                return conditions.isEmpty();\n\n            for (ColumnCondition condition : conditions.values())\n                if (!condition.appliesTo(rowPrefix, current, now))\n                    return false;\n            return true;\n        }","id":35287,"modified_method":"public boolean appliesTo(ColumnFamily current) throws InvalidRequestException\n        {\n            if (current == null)\n                return conditions.isEmpty();\n\n            for (ColumnCondition.WithVariables condition : conditions.values())\n                if (!condition.appliesTo(rowPrefix, current, now))\n                    return false;\n            return true;\n        }","commit_id":"167380fb0d7fa3fc6dc9879c839419babaea2a16","url":"https://github.com/apache/cassandra"},{"original_method":"public void addConditions(Collection<ColumnCondition> conds, List<ByteBuffer> variables) throws InvalidRequestException\n        {\n            for (ColumnCondition condition : conds)\n            {\n                // We will need the variables in appliesTo but with protocol batches, each condition in this object can have a\n                // different list of variables. So attach them to the condition directly, it's not particulary elegant but its simpler\n                ColumnCondition previous = conditions.put(condition.column.name, condition.attach(variables));\n                // If 2 conditions are actually equal, let it slide\n                if (previous != null && !previous.equalsTo(condition))\n                    throw new InvalidRequestException(\"Duplicate and incompatible conditions for column \" + condition.column.name);\n            }\n        }","id":35288,"modified_method":"public void addConditions(Collection<ColumnCondition> conds, List<ByteBuffer> variables) throws InvalidRequestException\n        {\n            for (ColumnCondition condition : conds)\n            {\n                // We will need the variables in appliesTo but with protocol batches, each condition in this object can have a\n                // different list of variables.\n                ColumnCondition.WithVariables current = condition.with(variables);\n                ColumnCondition.WithVariables previous = conditions.put(condition.column.name, current);\n                // If 2 conditions are actually equal, let it slide\n                if (previous != null && !previous.equalsTo(current))\n                    throw new InvalidRequestException(\"Duplicate and incompatible conditions for column \" + condition.column.name);\n            }\n        }","commit_id":"167380fb0d7fa3fc6dc9879c839419babaea2a16","url":"https://github.com/apache/cassandra"},{"original_method":"public ColumnCondition attach(List<ByteBuffer> variables)\n    {\n        this.variables = variables;\n        return this;\n    }","id":35289,"modified_method":"public ColumnCondition.WithVariables with(List<ByteBuffer> variables)\n    {\n        return new WithVariables(variables);\n    }","commit_id":"167380fb0d7fa3fc6dc9879c839419babaea2a16","url":"https://github.com/apache/cassandra"},{"original_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(FieldsChangeSequenceMeta)smi;\n\t\tdata=(FieldsChangeSequenceData)sdi;\n\n\t\tObject[] r=getRow();    // get row, set busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(first)\n\t\t{\n\t\t\t// get the RowMeta\n\t\t\tdata.previousMeta = getInputRowMeta().clone();\n\t\t\tdata.nextIndexField = data.previousMeta .size();\n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\t\t\t\n\t\t\tif(meta.getFieldName()==null || meta.getFieldName().length>0)\n\t\t\t{\n\t\t\t\tdata.fieldnr=meta.getFieldName().length;\n\t\t\t\tdata.fieldnrs=new int[data.fieldnr];\n\t\t\t\tdata.previousValues=new Object[data.fieldnr];\n\t\t\t\t\n\t\t\t\tfor (int i=0;i<data.fieldnr;i++)\n\t\t\t\t{\n\t\t\t\t\tdata.fieldnrs[i]=data.previousMeta.indexOfValue(meta.getFieldName()[i] );\n\t\t\t\t\tif (data.fieldnrs[i]<0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.CanNotFindField\",meta.getFieldName()[i]));\n\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.CanNotFindField\",meta.getFieldName()[i]));\n\t\t\t\t\t}\n\t \t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tdata.fieldnr=data.previousMeta.size();\n\t\t\t\tdata.fieldnrs=new int[data.fieldnr];\n\t\t\t\tdata.previousValues=new Object[data.fieldnr];\n\t\t\t\tfor(int i=0;i<data.previousMeta.size();i++)\n\t\t\t\t{\n\t\t\t\t\tdata.fieldnrs[i]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdata.startAt=Const.toInt(environmentSubstitute(meta.getStart()), 1);\n\t\t\tdata.incrementBy=Const.toInt(environmentSubstitute(meta.getIncrement()), 1);\n\t\t\tdata.seq=data.startAt;\n\t\t} // end if first\n\t\t\n\n\t\ttry\n\t\t{\n\t\t\tboolean change=false;\n\t\t\t\n\t\t   \t// Loop through fields\n\t\t\tfor(int i=0;i<data.fieldnr;i++)\n\t\t\t{\n\t\t\t\tif(!first)\n\t\t\t\t{\n\t\t\t\t\tif(!data.previousValues[i].equals(r[data.fieldnrs[i]])) change=true;\n\t\t\t\t}\n\t\t\t\tdata.previousValues[i]=r[data.fieldnrs[i]];\n\t\t\t}\n\t\t\tif(first) first=false;\n\t\t\t\n\t\t\tif(change) data.seq=data.startAt;\n\t\t\t\n\t\t    if (log.isRowLevel()) logRowlevel(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.ReadRow\")+getLinesRead()+\" : \"+getInputRowMeta().getString(r)); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t\t\n\t\t\t// build a value!\t\n\t\t\tr[data.nextIndexField]=data.seq;\n\t\t\t\n\t\t\tputRow(data.outputRowMeta, r);     // copy row to possible alternate rowset(s).\n\t\t\tdata.seq+=data.incrementBy;\t\t\n\t\t\t\n\t        if (log.isRowLevel()) logRowlevel(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.WriteRow\")+getLinesWritten()+\" : \"+getInputRowMeta().getString(r)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\n\t        if (checkFeedback(getLinesRead())) \n\t\t\t{\n\t\t\t\tif(log.isBasic()) logBasic(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.LineNumber\")+getLinesRead()); //$NON-NLS-1$\n\t\t\t}\n\t\t\t\n\t\t}catch(Exception e) {\n\t        boolean sendToErrorRow=false;\n\t        String errorMessage = null;\n        \tif (getStepMeta().isDoingErrorHandling())\n        \t{\n                sendToErrorRow = true;\n                errorMessage = e.toString();\n        \t}\n        \telse\n        \t{\n\t            logError(BaseMessages.getString(PKG, \"FieldsChangeSequence.ErrorInStepRunning\")+e.getMessage()); //$NON-NLS-1$\n\t            setErrors(1);\n\t            stopAll();\n\t            setOutputDone();  // signal end to receiver(s)\n\t            return false;\n        \t}\n        \tif (sendToErrorRow)\n        \t{\n        \t   // Simply add this row to the error row\n        \t   putError(getInputRowMeta(),r, 1, errorMessage, meta.getResultFieldName(), \"FieldsChangeSequence001\");\n        \t}\n        }\n\t\treturn true;\n\t}","id":35290,"modified_method":"public boolean processRow(StepMetaInterface smi, StepDataInterface sdi) throws KettleException\n\t{\n\t\tmeta=(FieldsChangeSequenceMeta)smi;\n\t\tdata=(FieldsChangeSequenceData)sdi;\n\n\t\tObject[] r=getRow();    // get row, set busy!\n\t\tif (r==null)  // no more input to be expected...\n\t\t{\n\t\t\tsetOutputDone();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif(first)\n\t\t{\n\t\t\t// get the RowMeta\n\t\t\tdata.previousMeta = getInputRowMeta().clone();\n\t\t\tdata.nextIndexField = data.previousMeta .size();\n            data.outputRowMeta = getInputRowMeta().clone();\n            meta.getFields(data.outputRowMeta, getStepname(), null, null, this);\n\t\t\t\n\t\t\tif(meta.getFieldName()==null || meta.getFieldName().length>0)\n\t\t\t{\n\t\t\t\tdata.fieldnr=meta.getFieldName().length;\n\t\t\t\tdata.fieldnrs=new int[data.fieldnr];\n\t\t\t\tdata.previousValues=new Object[data.fieldnr];\n\t\t\t\tdata.fieldnrsMeta = new ValueMeta[data.fieldnr];\n\t\t\t\tfor (int i=0;i<data.fieldnr;i++)\n\t\t\t\t{\n\t\t\t\t\tdata.fieldnrs[i]=data.previousMeta.indexOfValue(meta.getFieldName()[i] );\n\t\t\t\t\tif (data.fieldnrs[i]<0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.CanNotFindField\",meta.getFieldName()[i]));\n\t\t\t\t\t\tthrow new KettleException(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.CanNotFindField\",meta.getFieldName()[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdata.fieldnrsMeta[i]=data.previousMeta.getValueMeta(data.fieldnrs[i]);\n\t \t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\tdata.fieldnr=data.previousMeta.size();\n\t\t\t\tdata.fieldnrs=new int[data.fieldnr];\n\t\t\t\tdata.previousValues=new Object[data.fieldnr];\n\t\t\t\tdata.fieldnrsMeta = new ValueMeta[data.fieldnr];\n\t\t\t\tfor(int i=0;i<data.previousMeta.size();i++)\n\t\t\t\t{\n\t\t\t\t\tdata.fieldnrs[i]=i;\n\t\t\t\t\tdata.fieldnrsMeta[i]=data.previousMeta.getValueMeta(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tdata.startAt=Const.toInt(environmentSubstitute(meta.getStart()), 1);\n\t\t\tdata.incrementBy=Const.toInt(environmentSubstitute(meta.getIncrement()), 1);\n\t\t\tdata.seq=data.startAt;\n\t\t} // end if first\n\t\t\n\n\t\ttry\n\t\t{\n\t\t\tboolean change=false;\n\t\t\t\n\t\t   \t// Loop through fields\n\t\t\tfor(int i=0;i<data.fieldnr;i++)\n\t\t\t{\n\t\t\t\tif(!first)\n\t\t\t\t{\n\t\t\t\t\tif(data.fieldnrsMeta[i].compare(data.previousValues[i], r[data.fieldnrs[i]])!=0) change=true;\n\t\t\t\t}\n\t\t\t\tdata.previousValues[i]=r[data.fieldnrs[i]];\n\t\t\t}\n\t\t\tif(first) first=false;\n\t\t\t\n\t\t\tif(change) data.seq=data.startAt;\n\t\t\t\n\t\t    if (log.isRowLevel()) logRowlevel(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.ReadRow\")+getLinesRead()+\" : \"+getInputRowMeta().getString(r)); //$NON-NLS-1$ //$NON-NLS-2$\n\n\t\t    //reserve room and add value!\n\t\t\tObject[] outputRowData=RowDataUtil.addValueData(r,data.nextIndexField, data.seq);\n\t\t\t\n\t\t\tputRow(data.outputRowMeta, outputRowData);     // copy row to possible alternate rowset(s).\n\t\t\t\n\t\t\tdata.seq+=data.incrementBy;\t\t\n\t\t\t\n\t        if (log.isRowLevel()) logRowlevel(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.WriteRow\")+getLinesWritten()+\" : \"+getInputRowMeta().getString(r)); //$NON-NLS-1$ //$NON-NLS-2$\n\t\t\t\n\t        if (checkFeedback(getLinesRead())) \n\t\t\t{\n\t\t\t\tif(log.isBasic()) logBasic(BaseMessages.getString(PKG, \"FieldsChangeSequence.Log.LineNumber\")+getLinesRead()); //$NON-NLS-1$\n\t\t\t}\n\t\t\t\n\t\t}catch(Exception e) {\n\t        boolean sendToErrorRow=false;\n\t        String errorMessage = null;\n        \tif (getStepMeta().isDoingErrorHandling())\n        \t{\n                sendToErrorRow = true;\n                errorMessage = e.toString();\n        \t}\n        \telse\n        \t{\n\t            logError(BaseMessages.getString(PKG, \"FieldsChangeSequence.ErrorInStepRunning\")+e.getMessage()); //$NON-NLS-1$\n\t            logError(Const.getStackTracker(e));\n\t            setErrors(1);\n\t            stopAll();\n\t            setOutputDone();  // signal end to receiver(s)\n\t            return false;\n        \t}\n        \tif (sendToErrorRow)\n        \t{\n        \t   // Simply add this row to the error row\n        \t   putError(getInputRowMeta(),r, 1, errorMessage, meta.getResultFieldName(), \"FieldsChangeSequence001\");\n        \t}\n        }\n\t\treturn true;\n\t}","commit_id":"cdf07af5de5626782b9a23ee91613806d9a12eef","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private boolean shouldPersistMeasure(Resource resource, Measure measure) {\n    Metric metric = measure.getMetric();\n    return measure.getPersistenceMode().useDatabase() && !(\n        ResourceUtils.isEntity(resource) &&\n            metric.isOptimizedBestValue() == Boolean.TRUE &&\n            metric.getBestValue() != null &&\n            metric.getBestValue().equals(measure.getValue()) &&\n            !measure.hasOptionalData());\n  }","id":35291,"modified_method":"private boolean shouldPersistMeasure(Resource resource, Measure measure) {\n    Metric metric = measure.getMetric();\n    return measure.getPersistenceMode().useDatabase() && !(\n        ResourceUtils.isEntity(resource) &&\n            metric.isOptimizedBestValue() == Boolean.TRUE &&\n            metric.getBestValue() != null &&\n            Double.compare(metric.getBestValue(), measure.getValue())==0 &&\n            !measure.hasOptionalData());\n  }","commit_id":"db2c24f023c8ab6dfbd473269086c61847720dea","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @return whether the metric is of a numeric type (int, percentage...)\n   */\n  public boolean isNumericType() {\n    return ValueType.INT.equals(type)\n        || ValueType.FLOAT.equals(type)\n        || ValueType.PERCENT.equals(type)\n        || ValueType.BOOL.equals(type)\n        || ValueType.MILLISEC.equals(type);\n  }","id":35292,"modified_method":"/**\n   * @return whether the metric is of a numeric type (int, percentage...)\n   */\n  public boolean isNumericType() {\n    return ValueType.INT.equals(type)\n        || ValueType.FLOAT.equals(type)\n        || ValueType.PERCENT.equals(type)\n        || ValueType.BOOL.equals(type)\n        || ValueType.MILLISEC.equals(type)\n        || ValueType.RATING.equals(type);\n  }","commit_id":"db2c24f023c8ab6dfbd473269086c61847720dea","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void goToPrevious() {\n    if (mySearchEntries.size() == 0) return;\n    addToHistory();\n    EditorCell selectedCell = myEditor.getDeepestSelectedCell();\n    int selectionStart = 0;\n    if (selectedCell instanceof EditorCell_Label) {\n      EditorCell_Label labelCell = (EditorCell_Label) selectedCell;\n      selectionStart = labelCell.getSelectionStart();\n    }\n    SearchEntry entryToSelect = null;\n    for (ListIterator<SearchEntry> it = mySearchEntries.listIterator(mySearchEntries.size()); it.hasPrevious() && entryToSelect == null; ) {\n      SearchEntry currentEntry = it.previous();\n      if (currentEntry.getStartLabel().equals(selectedCell)) {\n        while (entryToSelect == null) {\n          if (!currentEntry.getStartLabel().equals(selectedCell) || selectionStart >= currentEntry.getFirstRange().getEndPosition()) {\n            entryToSelect = currentEntry;\n          }\n          if (it.hasPrevious()) {\n            currentEntry = it.previous();\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    if (entryToSelect == null) {\n      entryToSelect = mySearchEntries.get(mySearchEntries.size() - 1);\n    }\n    entryToSelect.select();\n  }","id":35293,"modified_method":"@Override\n  public void goToPrevious() {\n    if (mySearchEntries.size() == 0) return;\n    addToHistory();\n    EditorCell selectedCell = myEditor.getDeepestSelectedCell();\n    int selectionStart = 0;\n    if (selectedCell instanceof EditorCell_Label) {\n      EditorCell_Label labelCell = (EditorCell_Label) selectedCell;\n      selectionStart = labelCell.getSelectionStart();\n    }\n    SearchEntry entryToSelect = null;\n    for (ListIterator<SearchEntry> it = mySearchEntries.listIterator(mySearchEntries.size()); it.hasPrevious() && entryToSelect == null; ) {\n      SearchEntry currentEntry = it.previous();\n      if (CellTraversalUtil.compare(selectedCell, currentEntry.getStartLabel()) >= 0) {\n        while (entryToSelect == null) {\n          if (!currentEntry.getStartLabel().equals(selectedCell) || selectionStart >= currentEntry.getFirstRange().getEndPosition()) {\n            entryToSelect = currentEntry;\n          }\n          if (it.hasPrevious()) {\n            currentEntry = it.previous();\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    if (entryToSelect == null) {\n      entryToSelect = mySearchEntries.get(mySearchEntries.size() - 1);\n    }\n    entryToSelect.select();\n  }","commit_id":"5fa5365471e871fdafae8cfd383a9561234adcd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void goToNext() {\n    if (mySearchEntries.size() == 0) return;\n    addToHistory();\n    EditorCell selectedCell = myEditor.getDeepestSelectedCell();\n    int selectionEnd = -1;\n    if (selectedCell instanceof EditorCell_Label) {\n      EditorCell_Label labelCell = (EditorCell_Label) selectedCell;\n      selectionEnd = labelCell.getSelectionEnd();\n    }\n    SearchEntry entryToSelect = null;\n    for (ListIterator<SearchEntry> it = mySearchEntries.listIterator(); it.hasNext() && entryToSelect == null; ) {\n      SearchEntry currentEntry = it.next();\n      if (currentEntry.getStartLabel().equals(selectedCell)) {\n        while (entryToSelect == null) {\n          if (!currentEntry.getStartLabel().equals(selectedCell) || selectionEnd <= currentEntry.getFirstRange().getStartPosition()) {\n            entryToSelect = currentEntry;\n          }\n          if (it.hasNext()) {\n            currentEntry = it.next();\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    if (entryToSelect == null) {\n      entryToSelect = mySearchEntries.get(0);\n    }\n    entryToSelect.select();\n  }","id":35294,"modified_method":"@Override\n  public void goToNext() {\n    if (mySearchEntries.size() == 0) return;\n    addToHistory();\n    EditorCell selectedCell = myEditor.getDeepestSelectedCell();\n    int selectionEnd = -1;\n    if (selectedCell instanceof EditorCell_Label) {\n      EditorCell_Label labelCell = (EditorCell_Label) selectedCell;\n      selectionEnd = labelCell.getSelectionEnd();\n    }\n    SearchEntry entryToSelect = null;\n    for (ListIterator<SearchEntry> it = mySearchEntries.listIterator(); it.hasNext() && entryToSelect == null; ) {\n      SearchEntry currentEntry = it.next();\n      if (CellTraversalUtil.compare(selectedCell, currentEntry.getStartLabel()) <= 0) {\n        while (entryToSelect == null) {\n          if (!currentEntry.getStartLabel().equals(selectedCell) || selectionEnd <= currentEntry.getFirstRange().getStartPosition()) {\n            entryToSelect = currentEntry;\n          }\n          if (it.hasNext()) {\n            currentEntry = it.next();\n          } else {\n            break;\n          }\n        }\n      }\n    }\n    if (entryToSelect == null) {\n      entryToSelect = mySearchEntries.get(0);\n    }\n    entryToSelect.select();\n  }","commit_id":"5fa5365471e871fdafae8cfd383a9561234adcd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean setAppliesTo(CFMetaData cfm, Iterator<Column> iter, Set<ByteBuffer> elements)\n        {\n            Set<ByteBuffer> remaining = new HashSet<>(elements);\n            while (iter.hasNext())\n            {\n                if (remaining.isEmpty())\n                    return false;\n\n                if (!remaining.remove(collectionKey(cfm, iter.next())))\n                    return false;\n            }\n            return remaining.isEmpty();\n        }","id":35295,"modified_method":"private boolean setAppliesTo(SetType type, CFMetaData cfm, Iterator<Column> iter, Set<ByteBuffer> elements)\n        {\n            Set<ByteBuffer> remaining = new TreeSet<>(type.elements);\n            remaining.addAll(elements);\n            while (iter.hasNext())\n            {\n                if (remaining.isEmpty())\n                    return false;\n\n                if (!remaining.remove(collectionKey(cfm, iter.next())))\n                    return false;\n            }\n            return remaining.isEmpty();\n        }","commit_id":"17278b3a343575f4c32414cfffb52cdc2e7c7d00","url":"https://github.com/apache/cassandra"},{"original_method":"private boolean mapAppliesTo(CFMetaData cfm, Iterator<Column> iter, Map<ByteBuffer, ByteBuffer> elements)\n        {\n            Map<ByteBuffer, ByteBuffer> remaining = new HashMap<>(elements);\n            while (iter.hasNext())\n            {\n                if (remaining.isEmpty())\n                    return false;\n\n                Column c = iter.next();\n                if (!remaining.remove(collectionKey(cfm, c)).equals(c.value()))\n                    return false;\n            }\n            return remaining.isEmpty();\n        }","id":35296,"modified_method":"private boolean mapAppliesTo(MapType type, CFMetaData cfm, Iterator<Column> iter, Map<ByteBuffer, ByteBuffer> elements)\n        {\n            Map<ByteBuffer, ByteBuffer> remaining = new TreeMap<>(type.keys);\n            remaining.putAll(elements);\n            while (iter.hasNext())\n            {\n                if (remaining.isEmpty())\n                    return false;\n\n                Column c = iter.next();\n                ByteBuffer previous = remaining.remove(collectionKey(cfm, c));\n                if (previous == null || type.values.compare(previous, c.value()) != 0)\n                    return false;\n            }\n            return remaining.isEmpty();\n        }","commit_id":"17278b3a343575f4c32414cfffb52cdc2e7c7d00","url":"https://github.com/apache/cassandra"},{"original_method":"private boolean listAppliesTo(CFMetaData cfm, Iterator<Column> iter, List<ByteBuffer> elements)\n        {\n            for (ByteBuffer e : elements)\n                if (!iter.hasNext() || !iter.next().value().equals(e))\n                    return false;\n            // We must not have more elements than expected\n            return !iter.hasNext();\n        }","id":35297,"modified_method":"private boolean listAppliesTo(ListType type, CFMetaData cfm, Iterator<Column> iter, List<ByteBuffer> elements)\n        {\n            for (ByteBuffer e : elements)\n                if (!iter.hasNext() || type.elements.compare(iter.next().value(), e) != 0)\n                    return false;\n            // We must not have more elements than expected\n            return !iter.hasNext();\n        }","commit_id":"17278b3a343575f4c32414cfffb52cdc2e7c7d00","url":"https://github.com/apache/cassandra"},{"original_method":"private boolean collectionAppliesTo(CollectionType type, ColumnNameBuilder rowPrefix, ColumnFamily current, final long now) throws InvalidRequestException\n        {\n            ColumnNameBuilder collectionPrefix = copyOrUpdatePrefix(current.metadata(), rowPrefix).add(column.name.key);\n            // We are testing for collection equality, so we need to have the expected values *and* only those.\n            ColumnSlice[] collectionSlice = new ColumnSlice[]{ new ColumnSlice(collectionPrefix.build(), collectionPrefix.buildAsEndOfRange()) };\n            // Filter live columns, this makes things simpler afterwards\n            Iterator<Column> iter = Iterators.filter(current.iterator(collectionSlice), new Predicate<Column>()\n            {\n                public boolean apply(Column c)\n                {\n                    // we only care about live columns\n                    return c.isLive(now);\n                }\n            });\n\n            Term.Terminal v = value.bind(variables);\n            if (v == null)\n                return !iter.hasNext();\n\n            switch (type.kind)\n            {\n                case LIST: return listAppliesTo(current.metadata(), iter, ((Lists.Value)v).elements);\n                case SET: return setAppliesTo(current.metadata(), iter, ((Sets.Value)v).elements);\n                case MAP: return mapAppliesTo(current.metadata(), iter, ((Maps.Value)v).map);\n            }\n            throw new AssertionError();\n        }","id":35298,"modified_method":"private boolean collectionAppliesTo(CollectionType type, ColumnNameBuilder rowPrefix, ColumnFamily current, final long now) throws InvalidRequestException\n        {\n            ColumnNameBuilder collectionPrefix = copyOrUpdatePrefix(current.metadata(), rowPrefix).add(column.name.key);\n            // We are testing for collection equality, so we need to have the expected values *and* only those.\n            ColumnSlice[] collectionSlice = new ColumnSlice[]{ new ColumnSlice(collectionPrefix.build(), collectionPrefix.buildAsEndOfRange()) };\n            // Filter live columns, this makes things simpler afterwards\n            Iterator<Column> iter = Iterators.filter(current.iterator(collectionSlice), new Predicate<Column>()\n            {\n                public boolean apply(Column c)\n                {\n                    // we only care about live columns\n                    return c.isLive(now);\n                }\n            });\n\n            Term.Terminal v = value.bind(variables);\n            if (v == null)\n                return !iter.hasNext();\n\n            switch (type.kind)\n            {\n                case LIST: return listAppliesTo((ListType)type, current.metadata(), iter, ((Lists.Value)v).elements);\n                case SET: return setAppliesTo((SetType)type, current.metadata(), iter, ((Sets.Value)v).elements);\n                case MAP: return mapAppliesTo((MapType)type, current.metadata(), iter, ((Maps.Value)v).map);\n            }\n            throw new AssertionError();\n        }","commit_id":"17278b3a343575f4c32414cfffb52cdc2e7c7d00","url":"https://github.com/apache/cassandra"},{"original_method":"public void removeFrom(ObjectContainer container, ClientContext context) {\n\t\tblockFetchContext.removeFrom(container);\n\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\tSplitFileFetcherSegment segment = segments[i];\n\t\t\tsegments[i] = null;\n\t\t\tcontainer.activate(segment, 1);\n\t\t\tsegment.removeFrom(container, context);\n\t\t}\n\t\tcontainer.delete(this);\n\t}","id":35299,"modified_method":"public void removeFrom(ObjectContainer container, ClientContext context) {\n\t\tblockFetchContext.removeFrom(container);\n\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\tSplitFileFetcherSegment segment = segments[i];\n\t\t\tsegments[i] = null;\n\t\t\tcontainer.activate(segment, 1);\n\t\t\tsegment.fetcherFinished(container, context);\n\t\t}\n\t\tcontainer.delete(this);\n\t}","commit_id":"17e2c2f1a974fae98c84caed60337c8dd2416935","url":"https://github.com/freenet/fred"},{"original_method":"public void onEncodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+this);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tsynchronized(this) {\n\t\t\t// Now insert *ALL* blocks on which we had at least one failure, and didn't eventually succeed\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\tif(dataBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dataBuckets[i] != dataBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" : ours is \"+dataBuckets[i]+\" codec's is \"+dataBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(dataBuckets[i]) == container.ext().getID(dataBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+dataBuckets[i]+\"=\"+container.ext().getID(dataBuckets[i])+\" and \"+dataBlockStatus[i]+\"=\"+container.ext().getID(dataBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(dataBuckets[i])?\"stored \":\"\")+(container.ext().isActive(dataBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(dataBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(dataBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = dataBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+dataBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dataRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tdataBuckets[i].data = null; // So that it doesn't remove the data\n\t\t\t\t} else {\n\t\t\t\t\tdataBuckets[i].data.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tdataBuckets[i].removeFrom(container);\n\t\t\t\tdataBuckets[i] = null;\n\t\t\t\tif(persistent && dataKeys[i] != null)\n\t\t\t\t\tdataKeys[i].removeFrom(container);\n\t\t\t\tdataKeys[i] = null;\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\t// Check buckets will already be active because the FEC codec\n\t\t\t\t// has been using them.\n\t\t\t\tif(checkBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkBuckets[i] != checkBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Check block \"+i+\" : ours is \"+checkBuckets[i]+\" codec's is \"+checkBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(checkBuckets[i]) == container.ext().getID(checkBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+checkBuckets[i]+\"=\"+container.ext().getID(checkBuckets[i])+\" and \"+checkBlockStatus[i]+\"=\"+container.ext().getID(checkBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(checkBuckets[i])?\"stored \":\"\")+(container.ext().isActive(checkBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(checkBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(checkBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tcheckBuckets[i] = (MinimalSplitfileBlock) checkBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = checkBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+checkBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmaybeAddToBinaryBlob(data, i, true, container, context);\n\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(checkRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tcheckBuckets[i].data = null;\n\t\t\t\t} else {\n\t\t\t\t\tdata.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcheckBuckets[i].removeFrom(container);\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t\tif(persistent && checkKeys[i] != null)\n\t\t\t\t\tcheckKeys[i].removeFrom(container);\n\t\t\t\tcheckKeys[i] = null;\n\t\t\t}\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t}\n\t\t// Defer the completion until we have generated healing blocks if we are collecting binary blobs.\n\t\tif(isCollectingBinaryBlob(parent)) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t}","id":35300,"modified_method":"public void onEncodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\ttry {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t}\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Encoded \"+this);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\tsynchronized(this) {\n\t\t\t// Now insert *ALL* blocks on which we had at least one failure, and didn't eventually succeed\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\tif(dataBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(dataBuckets[i] != dataBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" : ours is \"+dataBuckets[i]+\" codec's is \"+dataBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(dataBuckets[i]) == container.ext().getID(dataBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+dataBuckets[i]+\"=\"+container.ext().getID(dataBuckets[i])+\" and \"+dataBlockStatus[i]+\"=\"+container.ext().getID(dataBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(dataBuckets[i])?\"stored \":\"\")+(container.ext().isActive(dataBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(dataBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(dataBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(dataBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tdataBuckets[i] = (MinimalSplitfileBlock) dataBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = dataBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Data bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+dataBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dataRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tdataBuckets[i].data = null; // So that it doesn't remove the data\n\t\t\t\t} else {\n\t\t\t\t\tdataBuckets[i].data.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tdataBuckets[i].removeFrom(container);\n\t\t\t\tdataBuckets[i] = null;\n\t\t\t\tif(persistent && dataKeys[i] != null)\n\t\t\t\t\tdataKeys[i].removeFrom(container);\n\t\t\t\tdataKeys[i] = null;\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tboolean heal = false;\n\t\t\t\t// Check buckets will already be active because the FEC codec\n\t\t\t\t// has been using them.\n\t\t\t\tif(checkBuckets[i] == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" is null in onEncodedSegment on \"+this);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(checkBuckets[i] != checkBlockStatus[i]) {\n\t\t\t\t\tLogger.error(this, \"Check block \"+i+\" : ours is \"+checkBuckets[i]+\" codec's is \"+checkBlockStatus[i]);\n\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\tif(container.ext().getID(checkBuckets[i]) == container.ext().getID(checkBlockStatus[i]))\n\t\t\t\t\t\t\tLogger.error(this, \"DB4O BUG DETECTED: SAME UID FOR TWO OBJECTS: \"+checkBuckets[i]+\"=\"+container.ext().getID(checkBuckets[i])+\" and \"+checkBlockStatus[i]+\"=\"+container.ext().getID(checkBlockStatus[i])+\" ... attempting workaround ...\");\n\t\t\t\t\t\tLogger.error(this, \"Ours is \"+(container.ext().isStored(checkBuckets[i])?\"stored \":\"\")+(container.ext().isActive(checkBuckets[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBuckets[i]));\n\t\t\t\t\t\tLogger.error(this, \"Theirs is \"+(container.ext().isStored(checkBlockStatus[i])?\"stored \":\"\")+(container.ext().isActive(checkBlockStatus[i])?\"active \":\"\")+\" UUID \"+container.ext().getID(checkBlockStatus[i]));\n\t\t\t\t\t}\n\t\t\t\t\tcheckBuckets[i] = (MinimalSplitfileBlock) checkBlockStatus[i];\n\t\t\t\t}\n\t\t\t\tBucket data = checkBuckets[i].getData();\n\t\t\t\tif(data == null) {\n\t\t\t\t\tLogger.error(this, \"Check bucket \"+i+\" has null contents in onEncodedSegment on \"+this+\" for block \"+checkBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be stored\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Splitfile block appears not to be active\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tmaybeAddToBinaryBlob(data, i, true, container, context);\n\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(checkRetries[i] > 0)\n\t\t\t\t\theal = true;\n\t\t\t\tif(heal) {\n\t\t\t\t\tqueueHeal(data, container, context);\n\t\t\t\t\tcheckBuckets[i].data = null;\n\t\t\t\t} else {\n\t\t\t\t\tdata.free();\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcheckBuckets[i].removeFrom(container);\n\t\t\t\tcheckBuckets[i] = null;\n\t\t\t\tif(persistent && checkKeys[i] != null)\n\t\t\t\t\tcheckKeys[i].removeFrom(container);\n\t\t\t\tcheckKeys[i] = null;\n\t\t\t}\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.store(this);\n\t\t}\n\t\t// Defer the completion until we have generated healing blocks if we are collecting binary blobs.\n\t\tif(isCollectingBinaryBlob(parent)) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t\t} finally {\n\t\tencoderFinished(container, context);\n\t\t}\n\t}","commit_id":"17e2c2f1a974fae98c84caed60337c8dd2416935","url":"https://github.com/freenet/fred"},{"original_method":"public void removeFrom(ObjectContainer container, ClientContext context) {\n\t\tif(decodedData != null)\n\t\t\tfreeDecodedData(container);\n\t\tremoveSubSegments(container, context);\n\t\tfor(int i=0;i<dataKeys.length;i++) {\n\t\t\tif(dataKeys[i] != null) dataKeys[i].removeFrom(container);\n\t\t\tdataKeys[i] = null;\n\t\t}\n\t\tfor(int i=0;i<checkKeys.length;i++) {\n\t\t\tif(checkKeys[i] != null) checkKeys[i].removeFrom(container);\n\t\t\tcheckKeys[i] = null;\n\t\t}\n\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\tMinimalSplitfileBlock block = dataBuckets[i];\n\t\t\tif(block.data != null) {\n\t\t\t\tLogger.error(this, \"Data block \"+i+\" still present in removeFrom()! on \"+this);\n\t\t\t\tblock.data.free();\n\t\t\t}\n\t\t\tblock.removeFrom(container);\n\t\t}\n\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\tMinimalSplitfileBlock block = checkBuckets[i];\n\t\t\tif(block.data != null) {\n\t\t\t\tLogger.error(this, \"Check block \"+i+\" still present in removeFrom()! on \"+this);\n\t\t\t\tblock.data.free();\n\t\t\t}\n\t\t\tblock.removeFrom(container);\n\t\t}\n\t\terrors.removeFrom(container);\n\t\tcontainer.delete(this);\n\t}","id":35301,"modified_method":"public void removeFrom(ObjectContainer container, ClientContext context) {\n\t\tif(decodedData != null)\n\t\t\tfreeDecodedData(container);\n\t\tremoveSubSegments(container, context);\n\t\tfor(int i=0;i<dataKeys.length;i++) {\n\t\t\tif(dataKeys[i] != null) dataKeys[i].removeFrom(container);\n\t\t\tdataKeys[i] = null;\n\t\t}\n\t\tfor(int i=0;i<checkKeys.length;i++) {\n\t\t\tif(checkKeys[i] != null) checkKeys[i].removeFrom(container);\n\t\t\tcheckKeys[i] = null;\n\t\t}\n\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\tMinimalSplitfileBlock block = dataBuckets[i];\n\t\t\tif(block == null) continue;\n\t\t\tif(block.data != null) {\n\t\t\t\tLogger.error(this, \"Data block \"+i+\" still present in removeFrom()! on \"+this);\n\t\t\t\tblock.data.free();\n\t\t\t}\n\t\t\tblock.removeFrom(container);\n\t\t}\n\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\tMinimalSplitfileBlock block = checkBuckets[i];\n\t\t\tif(block == null) continue;\n\t\t\tif(block.data != null) {\n\t\t\t\tLogger.error(this, \"Check block \"+i+\" still present in removeFrom()! on \"+this);\n\t\t\t\tblock.data.free();\n\t\t\t}\n\t\t\tblock.removeFrom(container);\n\t\t}\n\t\tcontainer.activate(errors, 1);\n\t\terrors.removeFrom(container);\n\t\tcontainer.delete(this);\n\t}","commit_id":"17e2c2f1a974fae98c84caed60337c8dd2416935","url":"https://github.com/freenet/fred"},{"original_method":"public void onDecodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(context, 1);\n\t\t}\n\t\tif(codec == null)\n\t\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length, context.mainExecutor);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\ttry {\n\t\t\tif(persistent) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\t// The FECCodec won't set them.\n\t\t\t\t\t// But they should be active.\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Data block \"+i+\" is \"+dataBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is not stored!\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is inactive! : \"+dataBuckets[i]);\n\t\t\t\t\tif(dataBuckets[i] == null)\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is null!\");\n\t\t\t\t\telse if(dataBuckets[i].data == null)\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" has null data!\");\n\t\t\t\t\telse\n\t\t\t\t\t\tdataBuckets[i].data.storeTo(container);\n\t\t\t\t\tcontainer.store(dataBuckets[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isCollectingBinaryBlob(parent)) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\tBucket data = dataBlockStatus[i].getData();\n\t\t\t\t\tif(data == null) \n\t\t\t\t\t\tthrow new NullPointerException(\"Data bucket \"+i+\" of \"+dataBuckets.length+\" is null\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmaybeAddToBinaryBlob(data, i, false, container, context);\n\t\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecodedData = context.getBucketFactory(persistent).makeBucket(maxBlockLength * dataBuckets.length);\n\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from \"+dataBuckets.length+\" data blocks\");\n\t\t\tOutputStream os = decodedData.getOutputStream();\n\t\t\tlong osSize = 0;\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from block \"+i);\n\t\t\t\tSplitfileBlock status = dataBuckets[i];\n\t\t\t\tif(status == null) throw new NullPointerException();\n\t\t\t\tBucket data = status.getData();\n\t\t\t\tif(data == null) \n\t\t\t\t\tthrow new NullPointerException(\"Data bucket \"+i+\" of \"+dataBuckets.length+\" is null\");\n\t\t\t\tif(persistent) container.activate(data, 1);\n\t\t\t\tlong copied = BucketTools.copyTo(data, os, Long.MAX_VALUE);\n\t\t\t\tosSize += copied;\n\t\t\t\tif(i != dataBuckets.length-1 && copied != 32768)\n\t\t\t\t\tLogger.error(this, \"Copied only \"+copied+\" bytes from \"+data+\" (bucket \"+i+\")\");\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Copied \"+copied+\" bytes from bucket \"+i);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Copied data (\"+osSize+\")\");\n\t\t\tos.close();\n\t\t\t// Must set finished BEFORE calling parentFetcher.\n\t\t\t// Otherwise a race is possible that might result in it not seeing our finishing.\n\t\t\tfinished = true;\n\t\t\tif(persistent) container.store(this);\n\t\t\tif(codec == null || !isCollectingBinaryBlob(parent))\n\t\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\t// Leave active before queueing\n\t\t} catch (IOException e) {\n\t\t\tLogger.normal(this, \"Caught bucket error?: \"+e, e);\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t\tfailureException = new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t}\n\t\t\tif(persistent) container.store(this);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\treturn;\n\t\t}\n\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t\t\tcontainer.deactivate(parent, 1);\n\t\t\t\tcontainer.deactivate(context, 1);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Now heal\n\n\t\t/** Splitfile healing:\n\t\t * Any block which we have tried and failed to download should be \n\t\t * reconstructed and reinserted.\n\t\t */\n\n\t\t// Encode any check blocks we don't have\n\t\tcodec.addToQueue(new FECJob(codec, context.fecQueue, dataBuckets, checkBuckets, 32768, context.getBucketFactory(persistent), this, false, parent.getPriorityClass(), persistent),\n\t\t\t\tcontext.fecQueue, container);\n\t\tif(persistent) {\n\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t\tcontainer.deactivate(parent, 1);\n\t\t\tcontainer.deactivate(context, 1);\n\t\t}\n\t}","id":35302,"modified_method":"public void onDecodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(context, 1);\n\t\t}\n\t\tif(codec == null)\n\t\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length, context.mainExecutor);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\ttry {\n\t\t\tif(persistent) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\t// The FECCodec won't set them.\n\t\t\t\t\t// But they should be active.\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Data block \"+i+\" is \"+dataBuckets[i]);\n\t\t\t\t\tif(!container.ext().isStored(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is not stored!\");\n\t\t\t\t\telse if(!container.ext().isActive(dataBuckets[i]))\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is inactive! : \"+dataBuckets[i]);\n\t\t\t\t\tif(dataBuckets[i] == null)\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" is null!\");\n\t\t\t\t\telse if(dataBuckets[i].data == null)\n\t\t\t\t\t\tLogger.error(this, \"Data block \"+i+\" has null data!\");\n\t\t\t\t\telse\n\t\t\t\t\t\tdataBuckets[i].data.storeTo(container);\n\t\t\t\t\tcontainer.store(dataBuckets[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isCollectingBinaryBlob(parent)) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\tBucket data = dataBlockStatus[i].getData();\n\t\t\t\t\tif(data == null) \n\t\t\t\t\t\tthrow new NullPointerException(\"Data bucket \"+i+\" of \"+dataBuckets.length+\" is null\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmaybeAddToBinaryBlob(data, i, false, container, context);\n\t\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\t\tfail(e, container, context, false);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecodedData = context.getBucketFactory(persistent).makeBucket(maxBlockLength * dataBuckets.length);\n\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from \"+dataBuckets.length+\" data blocks\");\n\t\t\tOutputStream os = decodedData.getOutputStream();\n\t\t\tlong osSize = 0;\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from block \"+i);\n\t\t\t\tSplitfileBlock status = dataBuckets[i];\n\t\t\t\tif(status == null) throw new NullPointerException();\n\t\t\t\tBucket data = status.getData();\n\t\t\t\tif(data == null) \n\t\t\t\t\tthrow new NullPointerException(\"Data bucket \"+i+\" of \"+dataBuckets.length+\" is null\");\n\t\t\t\tif(persistent) container.activate(data, 1);\n\t\t\t\tlong copied = BucketTools.copyTo(data, os, Long.MAX_VALUE);\n\t\t\t\tosSize += copied;\n\t\t\t\tif(i != dataBuckets.length-1 && copied != 32768)\n\t\t\t\t\tLogger.error(this, \"Copied only \"+copied+\" bytes from \"+data+\" (bucket \"+i+\")\");\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Copied \"+copied+\" bytes from bucket \"+i);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Copied data (\"+osSize+\")\");\n\t\t\tos.close();\n\t\t\t// Must set finished BEFORE calling parentFetcher.\n\t\t\t// Otherwise a race is possible that might result in it not seeing our finishing.\n\t\t\tfinished = true;\n\t\t\tif(persistent) container.store(this);\n\t\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT || !isCollectingBinaryBlob(parent))\n\t\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\t// Leave active before queueing\n\t\t} catch (IOException e) {\n\t\t\tLogger.normal(this, \"Caught bucket error?: \"+e, e);\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t\tfailureException = new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t}\n\t\t\tif(persistent) container.store(this);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tencoderFinished(container, context);\n\t\t\treturn;\n\t\t}\n\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t\t\tcontainer.deactivate(parent, 1);\n\t\t\t\tcontainer.deactivate(context, 1);\n\t\t\t}\n\t\t\tencoderFinished(container, context);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Now heal\n\n\t\t/** Splitfile healing:\n\t\t * Any block which we have tried and failed to download should be \n\t\t * reconstructed and reinserted.\n\t\t */\n\n\t\t// Encode any check blocks we don't have\n\t\ttry {\n\t\tcodec.addToQueue(new FECJob(codec, context.fecQueue, dataBuckets, checkBuckets, 32768, context.getBucketFactory(persistent), this, false, parent.getPriorityClass(), persistent),\n\t\t\t\tcontext.fecQueue, container);\n\t\tif(persistent) {\n\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t\tcontainer.deactivate(parent, 1);\n\t\t\tcontainer.deactivate(context, 1);\n\t\t}\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tencoderFinished(container, context);\n\t\t}\n\t}","commit_id":"17e2c2f1a974fae98c84caed60337c8dd2416935","url":"https://github.com/freenet/fred"},{"original_method":"public void start(ObjectContainer container, ClientContext context) throws InsertException {\n\t\t// Always called by parent, so don't activate or deactivate parent.\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(parent.parent, 1);\n\t\t}\n\t\tif (logMINOR) {\n\t\t\tif(parent == null) throw new NullPointerException();\n\t\t\tLogger.minor(this, \"Starting segment \" + segNo + \" of \" + parent\n\t\t\t\t\t+ \" (\" + parent.dataLength + \"): \" + this + \" ( finished=\"\n\t\t\t\t\t+ finished + \" encoded=\" + encoded + \" hasURIs=\" + hasURIs\n\t\t\t\t\t+ ')');\n\t\t}\n\t\tboolean fin = true;\n\n\t\tfor (int i = 0; i < dataBlockInserters.length; i++) {\n\t\t\tif (dataBlocks[i] != null) { // else already finished on creation\n\t\t\t\tdataBlockInserters[i] = new SingleBlockInserter(parent.parent,\n\t\t\t\t\t\tdataBlocks[i], (short) -1, FreenetURI.EMPTY_CHK_URI,\n\t\t\t\t\t\tblockInsertContext, this, false, CHKBlock.DATA_LENGTH,\n\t\t\t\t\t\ti, getCHKOnly, false, false, parent.token, container, context, persistent, false);\n\t\t\t\tdataBlockInserters[i].schedule(container, context);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(dataBlockInserters[i], 1);\n\t\t\t\tfin = false;\n\t\t\t} else {\n\t\t\t\tparent.parent.completedBlock(true, container, context);\n\t\t\t}\n\t\t}\n\t\t// parent.parent.notifyClients();\n\t\tstarted = true;\n\t\tif (!encoded) {\n\t\t\tif (logMINOR)\n\t\t\t\tLogger.minor(this, \"Segment \" + segNo + \" of \" + parent + \" (\"\n\t\t\t\t\t\t+ parent.dataLength + \") is not encoded\");\n\t\t\tFECCodec splitfileAlgo = FECCodec.getCodec(this.splitfileAlgo,\n\t\t\t\t\tdataBlocks.length, checkBlocks.length, context.mainExecutor);\n\t\t\t\tif (logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Encoding segment \" + segNo + \" of \"\n\t\t\t\t\t\t\t+ parent + \" (\" + parent.dataLength + \") persistent=\"+persistent);\n\t\t\t\t// Encode blocks\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tif(!encoded){\n\t\t\t\t\t\t// FIXME necessary??? the queue is persistence aware, won't it activate them...?\n\t\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\t\tfor(int i=0;i<dataBlocks.length;i++)\n\t\t\t\t\t\t\t\tcontainer.activate(dataBlocks[i], 5);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsplitfileAlgo.addToQueue(new FECJob(splitfileAlgo, context.fecQueue, dataBlocks, checkBlocks, CHKBlock.DATA_LENGTH, blockInsertContext.persistentBucketFactory, this, false, parent.parent.getPriorityClass(), persistent), context.fecQueue, container);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\tfin = false;\n\t\t} else {\n\t\t\tfor (int i = 0; i < checkBlockInserters.length; i++) {\n\t\t\t\tif (checkBlocks[i] != null) {\n\t\t\t\t\tcheckBlockInserters[i] = new SingleBlockInserter(\n\t\t\t\t\t\t\tparent.parent, checkBlocks[i], (short) -1,\n\t\t\t\t\t\t\tFreenetURI.EMPTY_CHK_URI, blockInsertContext, this,\n\t\t\t\t\t\t\tfalse, CHKBlock.DATA_LENGTH, i + dataBlocks.length,\n\t\t\t\t\t\t\tgetCHKOnly, false, false, parent.token, container, context, persistent, false);\n\t\t\t\t\tcheckBlockInserters[i].schedule(container, context);\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.deactivate(checkBlockInserters[i], 1);\n\t\t\t\t\tfin = false;\n\t\t\t\t} else\n\t\t\t\t\tparent.parent.completedBlock(true, container, context);\n\t\t\t}\n\t\t\tonEncodedSegment(container, context, null, dataBlocks, checkBlocks, null, null);\n\t\t}\n\t\tif (hasURIs) {\n\t\t\tparent.segmentHasURIs(this, container, context);\n\t\t}\n\t\tboolean fetchable;\n\t\tsynchronized (this) {\n\t\t\tfetchable = (blocksCompleted > dataBlocks.length);\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.store(this);\n\t\tif (fetchable)\n\t\t\tparent.segmentFetchable(this, container);\n\t\tif (fin)\n\t\t\tfinish(container, context, parent);\n\t\tif (finished) {\n\t\t\tparent.segmentFinished(this, container, context);\n\t\t}\n\t}","id":35303,"modified_method":"public void start(ObjectContainer container, ClientContext context) throws InsertException {\n\t\t// Always called by parent, so don't activate or deactivate parent.\n\t\tif(persistent) {\n\t\t\tcontainer.activate(parent, 1);\n\t\t\tcontainer.activate(parent.parent, 1);\n\t\t}\n\t\tif (logMINOR) {\n\t\t\tif(parent == null) throw new NullPointerException();\n\t\t\tLogger.minor(this, \"Starting segment \" + segNo + \" of \" + parent\n\t\t\t\t\t+ \" (\" + parent.dataLength + \"): \" + this + \" ( finished=\"\n\t\t\t\t\t+ finished + \" encoded=\" + encoded + \" hasURIs=\" + hasURIs\n\t\t\t\t\t+ ')');\n\t\t}\n\t\tboolean fin = true;\n\n\t\tfor (int i = 0; i < dataBlockInserters.length; i++) {\n\t\t\tif (dataBlocks[i] != null) { // else already finished on creation\n\t\t\t\tdataBlockInserters[i] = new SingleBlockInserter(parent.parent,\n\t\t\t\t\t\tdataBlocks[i], (short) -1, FreenetURI.EMPTY_CHK_URI,\n\t\t\t\t\t\tblockInsertContext, this, false, CHKBlock.DATA_LENGTH,\n\t\t\t\t\t\ti, getCHKOnly, false, false, parent.token, container, context, persistent, false);\n\t\t\t\tdataBlockInserters[i].schedule(container, context);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(dataBlockInserters[i], 1);\n\t\t\t\tfin = false;\n\t\t\t} else {\n\t\t\t\tparent.parent.completedBlock(true, container, context);\n\t\t\t}\n\t\t}\n\t\t// parent.parent.notifyClients();\n\t\tstarted = true;\n\t\tFECJob job = null;\n\t\tFECCodec splitfileAlgo = null;\n\t\tif (!encoded) {\n\t\t\tif (logMINOR)\n\t\t\t\tLogger.minor(this, \"Segment \" + segNo + \" of \" + parent + \" (\"\n\t\t\t\t\t\t+ parent.dataLength + \") is not encoded\");\n\t\t\tsplitfileAlgo = FECCodec.getCodec(this.splitfileAlgo,\n\t\t\t\t\tdataBlocks.length, checkBlocks.length, context.mainExecutor);\n\t\t\t\tif (logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Encoding segment \" + segNo + \" of \"\n\t\t\t\t\t\t\t+ parent + \" (\" + parent.dataLength + \") persistent=\"+persistent);\n\t\t\t\t// Encode blocks\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tif(!encoded){\n\t\t\t\t\t\t// FIXME necessary??? the queue is persistence aware, won't it activate them...?\n\t\t\t\t\t\tif(persistent) {\n\t\t\t\t\t\t\tfor(int i=0;i<dataBlocks.length;i++)\n\t\t\t\t\t\t\t\tcontainer.activate(dataBlocks[i], 5);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjob = new FECJob(splitfileAlgo, context.fecQueue, dataBlocks, checkBlocks, CHKBlock.DATA_LENGTH, blockInsertContext.persistentBucketFactory, this, false, parent.parent.getPriorityClass(), persistent);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t\tfin = false;\n\t\t} else {\n\t\t\tfor (int i = 0; i < checkBlockInserters.length; i++) {\n\t\t\t\tif (checkBlocks[i] != null) {\n\t\t\t\t\tcheckBlockInserters[i] = new SingleBlockInserter(\n\t\t\t\t\t\t\tparent.parent, checkBlocks[i], (short) -1,\n\t\t\t\t\t\t\tFreenetURI.EMPTY_CHK_URI, blockInsertContext, this,\n\t\t\t\t\t\t\tfalse, CHKBlock.DATA_LENGTH, i + dataBlocks.length,\n\t\t\t\t\t\t\tgetCHKOnly, false, false, parent.token, container, context, persistent, false);\n\t\t\t\t\tcheckBlockInserters[i].schedule(container, context);\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.deactivate(checkBlockInserters[i], 1);\n\t\t\t\t\tfin = false;\n\t\t\t\t} else\n\t\t\t\t\tparent.parent.completedBlock(true, container, context);\n\t\t\t}\n\t\t\tonEncodedSegment(container, context, null, dataBlocks, checkBlocks, null, null);\n\t\t}\n\t\tif (hasURIs) {\n\t\t\tparent.segmentHasURIs(this, container, context);\n\t\t}\n\t\tboolean fetchable;\n\t\tsynchronized (this) {\n\t\t\tfetchable = (blocksCompleted > dataBlocks.length);\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.store(this);\n\t\tif (fetchable)\n\t\t\tparent.segmentFetchable(this, container);\n\t\tif (fin)\n\t\t\tfinish(container, context, parent);\n\t\tif (finished) {\n\t\t\tparent.segmentFinished(this, container, context);\n\t\t}\n\t\tif(job != null) {\n\t\t\tsplitfileAlgo.addToQueue(job, context.fecQueue, container);\n\t\t}\n\t}","commit_id":"640a63d8e4211a13d50e1c5fe7f4498d3ad05861","url":"https://github.com/freenet/fred"},{"original_method":"public void onSuccess(Bucket data, int blockNo, SplitFileFetcherSubSegment seg, ClientKeyBlock block, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tboolean decodeNow = false;\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Fetched block \"+blockNo+\" on \"+seg);\n\t\tif(parentFetcher.parent instanceof ClientGetter)\n\t\t\t((ClientGetter)parentFetcher.parent).addKeyToBinaryBlob(block, container, context);\n\t\t// No need to unregister key, because it will be cleared in tripPendingKey().\n\t\tboolean dontNotify;\n\t\tsynchronized(this) {\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tif(dataKeys[blockNo] == null) {\n\t\t\t\t\tif(!startedDecode) Logger.error(this, \"Block already finished: \"+blockNo);\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdataRetries[blockNo] = 0; // Prevent healing of successfully fetched block.\n\t\t\t\tdataKeys[blockNo] = null;\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(dataBuckets[blockNo], 1);\n\t\t\t\tdataBuckets[blockNo].setData(data);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(dataBuckets[blockNo]);\n\t\t\t} else if(blockNo < checkKeys.length + dataKeys.length) {\n\t\t\t\tblockNo -= dataKeys.length;\n\t\t\t\tif(checkKeys[blockNo] == null) {\n\t\t\t\t\tif(!startedDecode) Logger.error(this, \"Check block already finished: \"+blockNo);\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcheckRetries[blockNo] = 0; // Prevent healing of successfully fetched block.\n\t\t\t\tcheckKeys[blockNo] = null;\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(checkBuckets[blockNo], 1);\n\t\t\t\tcheckBuckets[blockNo].setData(data);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(checkBuckets[blockNo]);\n\t\t\t} else\n\t\t\t\tLogger.error(this, \"Unrecognized block number: \"+blockNo, new Exception(\"error\"));\n\t\t\tif(startedDecode) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tfetchedBlocks++;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetched \"+fetchedBlocks+\" blocks in onSuccess(\"+blockNo+\")\");\n\t\t\t\tdecodeNow = (fetchedBlocks >= minFetched);\n\t\t\t\tif(decodeNow) {\n\t\t\t\t\tstartedDecode = true;\n\t\t\t\t\tfinishing = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdontNotify = !scheduled;\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tparentFetcher.parent.completedBlock(dontNotify, container, context);\n\t\tseg.possiblyRemoveFromParent(container);\n\t\tif(decodeNow) {\n\t\t\tremoveSubSegments(container);\n\t\t\tdecode(container, context);\n\t\t}\n\t}","id":35304,"modified_method":"public void onSuccess(Bucket data, int blockNo, SplitFileFetcherSubSegment seg, ClientKeyBlock block, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tif(data == null) throw new NullPointerException();\n\t\tboolean decodeNow = false;\n\t\tlogMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Fetched block \"+blockNo+\" on \"+seg);\n\t\tif(parentFetcher.parent instanceof ClientGetter)\n\t\t\t((ClientGetter)parentFetcher.parent).addKeyToBinaryBlob(block, container, context);\n\t\t// No need to unregister key, because it will be cleared in tripPendingKey().\n\t\tboolean dontNotify;\n\t\tsynchronized(this) {\n\t\t\tif(finished) {\n\t\t\t\tLogger.error(this, \"onSuccess() when already finished\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tif(dataKeys[blockNo] == null) {\n\t\t\t\t\tif(!startedDecode) Logger.error(this, \"Block already finished: \"+blockNo);\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tdataRetries[blockNo] = 0; // Prevent healing of successfully fetched block.\n\t\t\t\tdataKeys[blockNo] = null;\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(dataBuckets[blockNo], 1);\n\t\t\t\tdataBuckets[blockNo].setData(data);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(dataBuckets[blockNo]);\n\t\t\t} else if(blockNo < checkKeys.length + dataKeys.length) {\n\t\t\t\tblockNo -= dataKeys.length;\n\t\t\t\tif(checkKeys[blockNo] == null) {\n\t\t\t\t\tif(!startedDecode) Logger.error(this, \"Check block already finished: \"+blockNo);\n\t\t\t\t\tdata.free();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcheckRetries[blockNo] = 0; // Prevent healing of successfully fetched block.\n\t\t\t\tcheckKeys[blockNo] = null;\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(checkBuckets[blockNo], 1);\n\t\t\t\tcheckBuckets[blockNo].setData(data);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.set(checkBuckets[blockNo]);\n\t\t\t} else\n\t\t\t\tLogger.error(this, \"Unrecognized block number: \"+blockNo, new Exception(\"error\"));\n\t\t\tif(startedDecode) {\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tfetchedBlocks++;\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Fetched \"+fetchedBlocks+\" blocks in onSuccess(\"+blockNo+\")\");\n\t\t\t\tdecodeNow = (fetchedBlocks >= minFetched);\n\t\t\t\tif(decodeNow) {\n\t\t\t\t\tstartedDecode = true;\n\t\t\t\t\tfinishing = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdontNotify = !scheduled;\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.set(this);\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tcontainer.activate(parentFetcher.parent, 1);\n\t\t}\n\t\tparentFetcher.parent.completedBlock(dontNotify, container, context);\n\t\tseg.possiblyRemoveFromParent(container);\n\t\tif(decodeNow) {\n\t\t\tremoveSubSegments(container);\n\t\t\tdecode(container, context);\n\t\t}\n\t\tif(persistent) {\n\t\t\tcontainer.deactivate(parentFetcher.parent, 1);\n\t\t\tcontainer.deactivate(parentFetcher, 1);\n\t\t}\n\t}","commit_id":"4610289416e2f529fc27953d1b165aeb05fcb98a","url":"https://github.com/freenet/fred"},{"original_method":"public void decode(ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\t// Now decode\n\t\tif(logMINOR) Logger.minor(this, \"Decoding \"+SplitFileFetcherSegment.this);\n\n\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length, context.mainExecutor);\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\t\n\t\tif(splitfileType != Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\tFECQueue queue = context.fecQueue;\n\t\t\tcodec.addToQueue(new FECJob(codec, queue, dataBuckets, checkBuckets, CHKBlock.DATA_LENGTH, context.getBucketFactory(parentFetcher.parent.persistent()), this, true, parentFetcher.parent.getPriorityClass(), parentFetcher.parent.persistent()), \n\t\t\t\t\tqueue, container);\n\t\t\t// Now have all the data blocks (not necessarily all the check blocks)\n\t\t}\n\t}","id":35305,"modified_method":"public void decode(ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\t// Now decode\n\t\tif(logMINOR) Logger.minor(this, \"Decoding \"+SplitFileFetcherSegment.this);\n\n\t\tif(codec == null)\n\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length, context.mainExecutor);\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\t\n\t\t// Activate buckets\n\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(dataBuckets[i], 1);\n\t\t}\n\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(checkBuckets[i], 1);\n\t\t}\n\t\t\n\t\tif(splitfileType != Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\tFECQueue queue = context.fecQueue;\n\t\t\t// Double-check...\n\t\t\tint count = 0;\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tif(dataBuckets[i].getData() != null)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tfor(int i=0;i<checkBuckets.length;i++) {\n\t\t\t\tif(checkBuckets[i].getData() != null)\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tif(count < dataBuckets.length) {\n\t\t\t\tLogger.error(this, \"Attempting to decode but only \"+count+\" of \"+dataBuckets.length+\" blocks available!\");\n\t\t\t}\n\t\t\tcodec.addToQueue(new FECJob(codec, queue, dataBuckets, checkBuckets, CHKBlock.DATA_LENGTH, context.getBucketFactory(parentFetcher.parent.persistent()), this, true, parentFetcher.parent.getPriorityClass(), parentFetcher.parent.persistent()), \n\t\t\t\t\tqueue, container);\n\t\t\t// Now have all the data blocks (not necessarily all the check blocks)\n\t\t}\n\t}","commit_id":"4610289416e2f529fc27953d1b165aeb05fcb98a","url":"https://github.com/freenet/fred"},{"original_method":"/** A request has failed non-fatally, so the block may be retried \n\t * @param container */\n\tpublic void onNonFatalFailure(FetchException e, int blockNo, SplitFileFetcherSubSegment seg, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tRequestScheduler sched = context.getFetchScheduler(false);\n\t\tint tries;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tboolean failed = false;\n\t\tboolean cooldown = false;\n\t\tClientCHK key;\n\t\tSplitFileFetcherSubSegment sub = null;\n\t\tsynchronized(this) {\n\t\t\tif(isFinished(container)) return;\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tkey = dataKeys[blockNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++dataRetries[blockNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(dataCooldownTimes[blockNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" data block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdataCooldownTimes[blockNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint checkNo = blockNo - dataKeys.length;\n\t\t\t\tkey = checkKeys[checkNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++checkRetries[checkNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(checkCooldownTimes[checkNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" check block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcheckCooldownTimes[checkNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tif(failed) {\n\t\t\tonFatalFailure(e, blockNo, seg, container, context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries);\n\t\t\treturn;\n\t\t}\n\t\tif(cooldown) {\n\t\t\t// Register to the next sub-segment before removing from the old one.\n\t\t\tsub.getScheduler(context).addPendingKey(key, sub);\n\t\t\tseg.unregisterKey(key.getNodeKey(), context, container);\n\t\t} else {\n\t\t\t// If we are here we are going to retry\n\t\t\t// Unregister from the old sub-segment before registering on the new.\n\t\t\tseg.unregisterKey(key.getNodeKey(), context, container);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\tsub.add(blockNo, false, container, context, false);\n\t\t}\n\t}","id":35306,"modified_method":"/** A request has failed non-fatally, so the block may be retried \n\t * @param container */\n\tpublic void onNonFatalFailure(FetchException e, int blockNo, SplitFileFetcherSubSegment seg, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(blockFetchContext, 1);\n\t\t}\n\t\tRequestScheduler sched = context.getFetchScheduler(false);\n\t\tint tries;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tboolean failed = false;\n\t\tboolean cooldown = false;\n\t\tClientCHK key;\n\t\tSplitFileFetcherSubSegment sub = null;\n\t\tsynchronized(this) {\n\t\t\tif(isFinished(container)) return;\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tkey = dataKeys[blockNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++dataRetries[blockNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(dataCooldownTimes[blockNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" data block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdataCooldownTimes[blockNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint checkNo = blockNo - dataKeys.length;\n\t\t\t\tkey = checkKeys[checkNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++checkRetries[checkNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(checkCooldownTimes[checkNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" check block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcheckCooldownTimes[checkNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tif(failed) {\n\t\t\tonFatalFailure(e, blockNo, seg, container, context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries);\n\t\t\treturn;\n\t\t}\n\t\tif(cooldown) {\n\t\t\t// Register to the next sub-segment before removing from the old one.\n\t\t\tsub.getScheduler(context).addPendingKey(key, sub);\n\t\t\tseg.unregisterKey(key.getNodeKey(), context, container);\n\t\t} else {\n\t\t\t// If we are here we are going to retry\n\t\t\t// Unregister from the old sub-segment before registering on the new.\n\t\t\tseg.unregisterKey(key.getNodeKey(), context, container);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\tsub.add(blockNo, false, container, context, false);\n\t\t}\n\t}","commit_id":"4610289416e2f529fc27953d1b165aeb05fcb98a","url":"https://github.com/freenet/fred"},{"original_method":"public void onDecodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\ttry {\n\t\t\tif(isCollectingBinaryBlob()) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(dataBlockStatus[i], 1);\n\t\t\t\t\tBucket data = dataBlockStatus[i].getData();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmaybeAddToBinaryBlob(data, i, false, container, context);\n\t\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\t\tfail(e, container, context);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecodedData = context.getBucketFactory(parentFetcher.parent.persistent()).makeBucket(-1);\n\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from data blocks\");\n\t\t\tOutputStream os = decodedData.getOutputStream();\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tSplitfileBlock status = dataBuckets[i];\n\t\t\t\tif(persistent) container.activate(status, 1);\n\t\t\t\tBucket data = status.getData();\n\t\t\t\tif(persistent) container.activate(data, 1);\n\t\t\t\tBucketTools.copyTo(data, os, Long.MAX_VALUE);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Copied data\");\n\t\t\tos.close();\n\t\t\t// Must set finished BEFORE calling parentFetcher.\n\t\t\t// Otherwise a race is possible that might result in it not seeing our finishing.\n\t\t\tfinished = true;\n\t\t\tif(codec == null || !isCollectingBinaryBlob())\n\t\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent) container.set(this);\n\t\t} catch (IOException e) {\n\t\t\tLogger.normal(this, \"Caught bucket error?: \"+e, e);\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t\tfailureException = new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t}\n\t\t\tif(persistent) container.set(this);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\treturn;\n\t\t}\n\n\t\t// Now heal\n\n\t\t/** Splitfile healing:\n\t\t * Any block which we have tried and failed to download should be \n\t\t * reconstructed and reinserted.\n\t\t */\n\n\t\t// Encode any check blocks we don't have\n\t\tif(codec != null) {\n\t\t\tcodec.addToQueue(new FECJob(codec, context.fecQueue, dataBuckets, checkBuckets, 32768, context.getBucketFactory(parentFetcher.parent.persistent()), this, false, parentFetcher.parent.getPriorityClass(), parentFetcher.parent.persistent()),\n\t\t\t\t\tcontext.fecQueue, container);\n\t\t}\n\t}","id":35307,"modified_method":"public void onDecodedSegment(ObjectContainer container, ClientContext context, FECJob job, Bucket[] dataBuckets2, Bucket[] checkBuckets2, SplitfileBlock[] dataBlockStatus, SplitfileBlock[] checkBlockStatus) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tcontainer.activate(parentFetcher.parent, 1);\n\t\t\tcontainer.activate(context, 1);\n\t\t}\n\t\t// Because we use SplitfileBlock, we DON'T have to copy here.\n\t\t// See FECCallback comments for explanation.\n\t\ttry {\n\t\t\tif(isCollectingBinaryBlob()) {\n\t\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(dataBlockStatus[i], 1);\n\t\t\t\t\tBucket data = dataBlockStatus[i].getData();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tmaybeAddToBinaryBlob(data, i, false, container, context);\n\t\t\t\t\t} catch (FetchException e) {\n\t\t\t\t\t\tfail(e, container, context);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdecodedData = context.getBucketFactory(parentFetcher.parent.persistent()).makeBucket(-1);\n\t\t\tif(logMINOR) Logger.minor(this, \"Copying data from data blocks\");\n\t\t\tOutputStream os = decodedData.getOutputStream();\n\t\t\tfor(int i=0;i<dataBuckets.length;i++) {\n\t\t\t\tSplitfileBlock status = dataBuckets[i];\n\t\t\t\tif(persistent) container.activate(status, 1);\n\t\t\t\tBucket data = status.getData();\n\t\t\t\tif(persistent) container.activate(data, 1);\n\t\t\t\tBucketTools.copyTo(data, os, Long.MAX_VALUE);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Copied data\");\n\t\t\tos.close();\n\t\t\t// Must set finished BEFORE calling parentFetcher.\n\t\t\t// Otherwise a race is possible that might result in it not seeing our finishing.\n\t\t\tfinished = true;\n\t\t\tif(codec == null || !isCollectingBinaryBlob())\n\t\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\tif(persistent) container.set(this);\n\t\t} catch (IOException e) {\n\t\t\tLogger.normal(this, \"Caught bucket error?: \"+e, e);\n\t\t\tsynchronized(this) {\n\t\t\t\tfinished = true;\n\t\t\t\tfailureException = new FetchException(FetchException.BUCKET_ERROR);\n\t\t\t}\n\t\t\tif(persistent) container.set(this);\n\t\t\tparentFetcher.segmentFinished(SplitFileFetcherSegment.this, container, context);\n\t\t\treturn;\n\t\t}\n\n\t\t// Now heal\n\n\t\t/** Splitfile healing:\n\t\t * Any block which we have tried and failed to download should be \n\t\t * reconstructed and reinserted.\n\t\t */\n\n\t\t// Encode any check blocks we don't have\n\t\tif(codec == null)\n\t\t\tcodec = FECCodec.getCodec(splitfileType, dataKeys.length, checkKeys.length, context.mainExecutor);\n\n\t\t\tcodec.addToQueue(new FECJob(codec, context.fecQueue, dataBuckets, checkBuckets, 32768, context.getBucketFactory(parentFetcher.parent.persistent()), this, false, parentFetcher.parent.getPriorityClass(), parentFetcher.parent.persistent()),\n\t\t\t\t\tcontext.fecQueue, container);\n\t}","commit_id":"4610289416e2f529fc27953d1b165aeb05fcb98a","url":"https://github.com/freenet/fred"},{"original_method":"public void modifyObject(InternalFactHandle factHandle,\n                             ModifyPreviousTuples modifyPreviousTuples,\n                             PropagationContext context,\n                             InternalWorkingMemory wm) {\n        RightTuple rightTuple = modifyPreviousTuples.peekRightTuple();\n\n        // if the peek is for a different OTN we assume that it is after the current one and then this is an assert\n        while ( rightTuple != null &&\n                (( BetaNode ) rightTuple.getRightTupleSink()).getRightInputOtnId().before( getRightInputOtnId() ) ) {\n            modifyPreviousTuples.removeRightTuple();\n\n            // we skipped this node, due to alpha hashing, so retract now\n            rightTuple.setPropagationContext( context );\n            retractRightTuple( rightTuple,\n                               context,\n                               wm );\n            rightTuple = modifyPreviousTuples.peekRightTuple();\n        }\n\n        if ( rightTuple != null && (( BetaNode ) rightTuple.getRightTupleSink()).getRightInputOtnId().equals(getRightInputOtnId()) ) {\n            modifyPreviousTuples.removeRightTuple();\n            modifyRightTuple( rightTuple, context, wm );\n        } else {\n            // RightTuple does not exist for this node, so create and continue as assert\n            assertObject( factHandle, context, wm );\n        }\n    }","id":35308,"modified_method":"public void modifyObject(InternalFactHandle factHandle,\n                             ModifyPreviousTuples modifyPreviousTuples,\n                             PropagationContext context,\n                             InternalWorkingMemory wm) {\n        RightTuple rightTuple = modifyPreviousTuples.peekRightTuple();\n\n        // if the peek is for a different OTN we assume that it is after the current one and then this is an assert\n        while ( rightTuple != null &&\n                rightTuple.getRightTupleSink().getRightInputOtnId().before( getRightInputOtnId() ) ) {\n            modifyPreviousTuples.removeRightTuple();\n\n            // we skipped this node, due to alpha hashing, so retract now\n            rightTuple.setPropagationContext( context );\n            retractRightTuple( rightTuple,\n                               context,\n                               wm );\n            rightTuple = modifyPreviousTuples.peekRightTuple();\n        }\n\n        if ( rightTuple != null && rightTuple.getRightTupleSink().getRightInputOtnId().equals(getRightInputOtnId()) ) {\n            modifyPreviousTuples.removeRightTuple();\n            modifyRightTuple( rightTuple, context, wm );\n        } else {\n            // RightTuple does not exist for this node, so create and continue as assert\n            assertObject( factHandle, context, wm );\n        }\n    }","commit_id":"5744ff8fc246f320c4185c1101e291a7d73fe4c3","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void doRightDelete(PropagationContext pctx, InternalWorkingMemory wm, RightTuple rightTuple) {\n        rightTuple.setPropagationContext( pctx );\n        BetaMemory bm = BetaNode.getBetaMemory((BetaNode) rightTuple.getRightTupleSink(), wm);\n        (( BetaNode ) rightTuple.getRightTupleSink()).doDeleteRightTuple( rightTuple, wm, bm );\n    }","id":35309,"modified_method":"public void doRightDelete(PropagationContext pctx, InternalWorkingMemory wm, RightTuple rightTuple) {\n        rightTuple.setPropagationContext( pctx );\n        rightTuple.getRightTupleSink().retractRightTuple( rightTuple, pctx, wm );\n    }","commit_id":"82e187c208adbf1a19aaa14c17eee1bbb3b08d27","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private static FormBuilder updateBuilderWithPrincipalData(FormBuilder builder, Map<String, String> fields) {\n    builder = builder.setIndent(IdeBorderFactory.TITLED_BORDER_INDENT);\n    for (CommonField field : CommonField.values()) {\n      String value = fields.get(field.getShortName());\n      if (value == null) {\n        continue;\n      }\n      String label = String.format(\"<html>%s (<b>%s<\/b>)<\/html>\", field.getShortName(), field.getLongName());\n      builder = builder.addLabeledComponent(label, new JBLabel(value));\n    }\n    return builder.setIndent(0);\n  }","id":35310,"modified_method":"private static void updateBuilderWithPrincipalData(FormBuilder builder, Map<String, String> fields) {\n    builder = builder.setIndent(IdeBorderFactory.TITLED_BORDER_INDENT);\n    for (CommonField field : CommonField.values()) {\n      String value = fields.get(field.getShortName());\n      if (value == null) {\n        continue;\n      }\n      String label = String.format(\"<html>%s (<b>%s<\/b>)<\/html>\", field.getShortName(), field.getLongName());\n      builder = builder.addLabeledComponent(label, new JBLabel(value));\n    }\n    builder.setIndent(0);\n  }","commit_id":"573eb8b8d294b5fa9f3011cd94e7b4b0348a3a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CertificateInfoPanel(@NotNull X509Certificate certificate) {\n    myCertificateWrapper = new CertificateWrapper(certificate);\n    setLayout(new BorderLayout());\n\n    FormBuilder builder = FormBuilder.createFormBuilder();\n\n    // I'm not using separate panels and form builders to preserve alignment of labels\n    builder = updateBuilderWithTitle(builder, \"Issued To\");\n    builder = updateBuilderWithPrincipalData(builder, myCertificateWrapper.getSubjectFields());\n    builder = updateBuilderWithTitle(builder, \"Issued By\");\n    builder = updateBuilderWithPrincipalData(builder, myCertificateWrapper.getIssuerFields());\n    builder = updateBuilderWithTitle(builder, \"Validity Period\");\n    String notBefore = DATE_FORMAT.format(myCertificateWrapper.getNotBefore());\n    String notAfter = DATE_FORMAT.format(myCertificateWrapper.getNotAfter());\n    builder = builder\n      .setIndent(IdeBorderFactory.TITLED_BORDER_INDENT)\n      .addLabeledComponent(\"Valid from:\", createColoredComponent(notBefore, \"not yet valid\", myCertificateWrapper.isNotYetValid()))\n      .addLabeledComponent(\"Valid until:\", createColoredComponent(notAfter, \"expired\", myCertificateWrapper.isExpired()));\n    builder = builder.setIndent(0);\n    builder = updateBuilderWithTitle(builder, \"Fingerprints\");\n    builder = builder.setIndent(IdeBorderFactory.TITLED_BORDER_INDENT);\n    builder = builder.addLabeledComponent(\"SHA-256:\", getTextPane(formatHex(myCertificateWrapper.getSha256Fingerprint())));\n    builder = builder.addLabeledComponent(\"SHA-1:\", getTextPane(formatHex(myCertificateWrapper.getSha1Fingerprint())));\n    add(builder.getPanel(), BorderLayout.NORTH);\n\n    SimpleColoredComponent component = new SimpleColoredComponent();\n  }","id":35311,"modified_method":"public CertificateInfoPanel(@NotNull X509Certificate certificate) {\n    myCertificateWrapper = new CertificateWrapper(certificate);\n    setLayout(new BorderLayout());\n\n    FormBuilder builder = FormBuilder.createFormBuilder();\n\n    // I'm not using separate panels and form builders to preserve alignment of labels\n    updateBuilderWithTitle(builder, \"Issued To\");\n    updateBuilderWithPrincipalData(builder, myCertificateWrapper.getSubjectFields());\n    updateBuilderWithTitle(builder, \"Issued By\");\n    updateBuilderWithPrincipalData(builder, myCertificateWrapper.getIssuerFields());\n    updateBuilderWithTitle(builder, \"Validity Period\");\n    String notBefore = DATE_FORMAT.format(myCertificateWrapper.getNotBefore());\n    String notAfter = DATE_FORMAT.format(myCertificateWrapper.getNotAfter());\n    builder = builder\n      .setIndent(IdeBorderFactory.TITLED_BORDER_INDENT)\n      .addLabeledComponent(\"Valid from:\", createColoredComponent(notBefore, \"not yet valid\", myCertificateWrapper.isNotYetValid()))\n      .addLabeledComponent(\"Valid until:\", createColoredComponent(notAfter, \"expired\", myCertificateWrapper.isExpired()));\n    builder.setIndent(0);\n    updateBuilderWithTitle(builder, \"Fingerprints\");\n    builder.setIndent(IdeBorderFactory.TITLED_BORDER_INDENT);\n    builder.addLabeledComponent(\"SHA-256:\", getTextPane(formatHex(myCertificateWrapper.getSha256Fingerprint())));\n    builder.addLabeledComponent(\"SHA-1:\", getTextPane(formatHex(myCertificateWrapper.getSha1Fingerprint())));\n    add(builder.getPanel(), BorderLayout.NORTH);\n  }","commit_id":"573eb8b8d294b5fa9f3011cd94e7b4b0348a3a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static FormBuilder updateBuilderWithTitle(FormBuilder builder, String title) {\n    return builder.addComponent(new TitledSeparator(title), IdeBorderFactory.TITLED_BORDER_TOP_INSET);\n  }","id":35312,"modified_method":"private static void updateBuilderWithTitle(FormBuilder builder, String title) {\n    builder.addComponent(new TitledSeparator(title), IdeBorderFactory.TITLED_BORDER_TOP_INSET);\n  }","commit_id":"573eb8b8d294b5fa9f3011cd94e7b4b0348a3a9b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static File unzip( Class<?> testClass, String resource ) throws IOException\n    {\n        File dir = TargetDirectory.forTest( testClass ).makeGraphDbDir();\n        try ( InputStream source = testClass.getResourceAsStream( resource ) )\n        {\n            if ( source == null )\n            {\n                throw new FileNotFoundException( \"Could not find resource '\" + resource + \"' to unzip\" );\n            }\n            ZipInputStream zipStream = new ZipInputStream( source );\n            ZipEntry entry;\n            byte[] scratch = new byte[8096];\n            while ( (entry = zipStream.getNextEntry()) != null )\n            {\n                if ( entry.isDirectory() )\n                {\n                    new File( dir, entry.getName() ).mkdirs();\n                }\n                else\n                {\n                    try ( OutputStream file =\n                                  new BufferedOutputStream( new FileOutputStream( new File( dir, entry.getName() ) ) ) )\n                    {\n                        long toCopy = entry.getSize();\n                        while ( toCopy > 0 )\n                        {\n                            int read = zipStream.read( scratch );\n                            file.write( scratch, 0, read );\n                            toCopy -= read;\n                        }\n                    }\n                }\n                zipStream.closeEntry();\n            }\n        }\n        return dir;\n    }","id":35313,"modified_method":"public static File unzip( File targetDir, Class<?> testClass, String resource ) throws IOException\n    {\n        try ( InputStream source = testClass.getResourceAsStream( resource ) )\n        {\n            if ( source == null )\n            {\n                throw new FileNotFoundException( \"Could not find resource '\" + resource + \"' to unzip\" );\n            }\n            ZipInputStream zipStream = new ZipInputStream( source );\n            ZipEntry entry;\n            byte[] scratch = new byte[8096];\n            while ( (entry = zipStream.getNextEntry()) != null )\n            {\n                if ( entry.isDirectory() )\n                {\n                    new File( targetDir, entry.getName() ).mkdirs();\n                }\n                else\n                {\n                    try ( OutputStream file =\n                                  new BufferedOutputStream(\n                                          new FileOutputStream( new File( targetDir, entry.getName() ) ) ) )\n                    {\n                        long toCopy = entry.getSize();\n                        while ( toCopy > 0 )\n                        {\n                            int read = zipStream.read( scratch );\n                            file.write( scratch, 0, read );\n                            toCopy -= read;\n                        }\n                    }\n                }\n                zipStream.closeEntry();\n            }\n        }\n        return targetDir;\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldRunWithDelay() throws Throwable\n    {\n        // Given\n        life.start();\n\n        final AtomicLong runTime = new AtomicLong();\n        final CountDownLatch latch = new CountDownLatch( 1 );\n\n        long time = System.currentTimeMillis();\n\n        scheduler.schedule( new JobScheduler.Group( \"group\", POOLED ), new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                runTime.set( System.currentTimeMillis() );\n                latch.countDown();\n            }\n        }, 100, TimeUnit.MILLISECONDS );\n\n        latch.await();\n\n        assertTrue( time + 100 <= runTime.get() );\n    }","id":35314,"modified_method":"@Test\n    public void shouldRunWithDelay() throws Throwable\n    {\n        // Given\n        life.start();\n\n        final AtomicLong runTime = new AtomicLong();\n        final CountDownLatch latch = new CountDownLatch( 1 );\n\n        long time = System.nanoTime();\n\n        scheduler.schedule( new JobScheduler.Group( \"group\", POOLED ), new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                runTime.set( System.nanoTime() );\n                latch.countDown();\n            }\n        }, 100, TimeUnit.MILLISECONDS );\n\n        latch.await();\n\n        assertTrue( time + TimeUnit.MILLISECONDS.toNanos( 100 ) <= runTime.get() );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void migratingOlderDataAndThanStartAClusterUsingTheNewerDataShouldWork() throws Throwable\n        {\n            // migrate the store using a single instance\n            File dir = store.prepareDirectory();\n            GraphDatabaseFactory factory = new TestGraphDatabaseFactory();\n            GraphDatabaseBuilder builder = factory.newEmbeddedDatabaseBuilder( dir.getAbsolutePath() );\n            builder.setConfig( GraphDatabaseSettings.allow_store_upgrade, \"true\" );\n            builder.setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" );\n            GraphDatabaseService db = builder.newGraphDatabase();\n            try\n            {\n                checkInstance( store, (GraphDatabaseAPI) db );\n            }\n            finally\n            {\n                db.shutdown();\n            }\n\n            assertConsistentStore( dir );\n\n            // start the cluster with the db migrated from the old instance\n            File haDir = new File( dir.getParentFile(), \"ha-stuff\" );\n            FileUtils.deleteRecursively( haDir );\n            ClusterManager clusterManager = new ClusterManager(\n                    new ClusterManager.Builder( haDir ).withSeedDir( dir ).withProvider( clusterOfSize( 2 ) )\n            );\n\n            clusterManager.start();\n\n            ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();\n            HighlyAvailableGraphDatabase master, slave;\n            try\n            {\n                cluster.await( allSeesAllAsAvailable() );\n\n                master = cluster.getMaster();\n                checkInstance( store, master );\n                slave = cluster.getAnySlave();\n                checkInstance( store, slave );\n            }\n            finally\n            {\n                clusterManager.shutdown();\n            }\n\n            assertConsistentStore( new File( master.getStoreDir() ) );\n            assertConsistentStore( new File( slave.getStoreDir() ) );\n        }","id":35315,"modified_method":"@Test\n        public void migratingOlderDataAndThanStartAClusterUsingTheNewerDataShouldWork() throws Throwable\n        {\n            // migrate the store using a single instance\n            File dir = store.prepareDirectory( testDir.graphDbDir() );\n            GraphDatabaseFactory factory = new TestGraphDatabaseFactory();\n            GraphDatabaseBuilder builder = factory.newEmbeddedDatabaseBuilder( dir );\n            builder.setConfig( GraphDatabaseSettings.allow_store_upgrade, \"true\" );\n            builder.setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" );\n            GraphDatabaseService db = builder.newGraphDatabase();\n            try\n            {\n                checkInstance( store, (GraphDatabaseAPI) db );\n            }\n            finally\n            {\n                db.shutdown();\n            }\n\n            assertConsistentStore( dir );\n\n            // start the cluster with the db migrated from the old instance\n            File haDir = new File( dir.getParentFile(), \"ha-stuff\" );\n            FileUtils.deleteRecursively( haDir );\n            ClusterManager clusterManager = new ClusterManager(\n                    new ClusterManager.Builder( haDir ).withSeedDir( dir ).withProvider( clusterOfSize( 2 ) )\n            );\n\n            clusterManager.start();\n\n            ClusterManager.ManagedCluster cluster = clusterManager.getDefaultCluster();\n            HighlyAvailableGraphDatabase master, slave;\n            try\n            {\n                cluster.await( allSeesAllAsAvailable() );\n\n                master = cluster.getMaster();\n                checkInstance( store, master );\n                slave = cluster.getAnySlave();\n                checkInstance( store, slave );\n            }\n            finally\n            {\n                clusterManager.shutdown();\n            }\n\n            assertConsistentStore( new File( master.getStoreDir() ) );\n            assertConsistentStore( new File( slave.getStoreDir() ) );\n        }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void migratingFromANotCleanlyShutdownStoreShouldNotStartAndFail() throws Throwable\n        {\n            // migrate the store using a single instance\n            File dir = AbstractNeo4jTestCase.unzip( StoreUpgradeIntegrationTest.class, \"0.A.3-to-be-recovered.zip\" );\n            new File( dir, \"messages.log\" ).delete(); // clear the log\n            GraphDatabaseFactory factory = new TestGraphDatabaseFactory();\n            GraphDatabaseBuilder builder = factory.newEmbeddedDatabaseBuilder(dir.getAbsolutePath());\n            builder.setConfig(GraphDatabaseSettings.allow_store_upgrade, \"true\");\n            builder.setConfig(GraphDatabaseSettings.pagecache_memory, \"8m\");\n            try {\n                GraphDatabaseService db = builder.newGraphDatabase();\n                db.shutdown();\n                fail(\"It should have failed.\");\n            } catch (RuntimeException ex) {\n                final UpgradingStoreVersionNotFoundException expected =\n                        new UpgradingStoreVersionNotFoundException( \"neostore.nodestore.db\" );\n                final Throwable cause = ex.getCause().getCause().getCause();\n                assertEquals(expected.getClass(), cause.getClass());\n                assertEquals(expected.getMessage(), cause.getMessage());\n            }\n        }","id":35316,"modified_method":"@Test\n        public void migratingFromANotCleanlyShutdownStoreShouldNotStartAndFail() throws Throwable\n        {\n            // migrate the store using a single instance\n            File dir = AbstractNeo4jTestCase.unzip( testDir.graphDbDir(), getClass(), \"0.A.3-to-be-recovered.zip\" );\n            new File( dir, \"messages.log\" ).delete(); // clear the log\n            GraphDatabaseFactory factory = new TestGraphDatabaseFactory();\n            GraphDatabaseBuilder builder = factory.newEmbeddedDatabaseBuilder( dir );\n            builder.setConfig( GraphDatabaseSettings.allow_store_upgrade, \"true\" );\n            builder.setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" );\n            try\n            {\n                GraphDatabaseService db = builder.newGraphDatabase();\n                db.shutdown();\n                fail( \"It should have failed.\" );\n            }\n            catch ( RuntimeException ex )\n            {\n                final UpgradingStoreVersionNotFoundException expected =\n                        new UpgradingStoreVersionNotFoundException( \"neostore.nodestore.db\" );\n                final Throwable cause = ex.getCause().getCause().getCause();\n                assertEquals( expected.getClass(), cause.getClass() );\n                assertEquals( expected.getMessage(), cause.getMessage() );\n            }\n        }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void embeddedDatabaseShouldStartOnOlderStoreWhenUpgradeIsEnabled() throws Throwable\n        {\n            File dir = store.prepareDirectory();\n\n            GraphDatabaseFactory factory = new TestGraphDatabaseFactory();\n            GraphDatabaseBuilder builder = factory.newEmbeddedDatabaseBuilder( dir.getAbsolutePath() );\n            builder.setConfig( GraphDatabaseSettings.allow_store_upgrade, \"true\" );\n            builder.setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" );\n            GraphDatabaseService db = builder.newGraphDatabase();\n            try\n            {\n                checkInstance( store, (GraphDatabaseAPI) db );\n\n            }\n            finally\n            {\n                db.shutdown();\n            }\n\n            assertConsistentStore( dir );\n        }","id":35317,"modified_method":"@Test\n        public void embeddedDatabaseShouldStartOnOlderStoreWhenUpgradeIsEnabled() throws Throwable\n        {\n            File dir = store.prepareDirectory( testDir.graphDbDir() );\n\n            GraphDatabaseFactory factory = new TestGraphDatabaseFactory();\n            GraphDatabaseBuilder builder = factory.newEmbeddedDatabaseBuilder( dir );\n            builder.setConfig( GraphDatabaseSettings.allow_store_upgrade, \"true\" );\n            builder.setConfig( GraphDatabaseSettings.pagecache_memory, \"8m\" );\n            GraphDatabaseService db = builder.newGraphDatabase();\n            try\n            {\n                checkInstance( store, (GraphDatabaseAPI) db );\n\n            }\n            finally\n            {\n                db.shutdown();\n            }\n\n            assertConsistentStore( dir );\n        }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n        public void serverDatabaseShouldStartOnOlderStoreWhenUpgradeIsEnabled() throws Throwable\n        {\n            File dir = store.prepareDirectory();\n\n            File configFile = new File( dir, \"neo4j.properties\" );\n            Properties props = new Properties();\n            props.setProperty( Configurator.DATABASE_LOCATION_PROPERTY_KEY, dir.getAbsolutePath() );\n            props.setProperty( Configurator.DB_TUNING_PROPERTY_FILE_KEY, configFile.getAbsolutePath() );\n            props.setProperty( GraphDatabaseSettings.allow_store_upgrade.name(), \"true\" );\n            props.setProperty( GraphDatabaseSettings.pagecache_memory.name(), \"8m\" );\n            props.store( new FileWriter( configFile ), \"\" );\n\n            try\n            {\n                System.setProperty( Configurator.NEO_SERVER_CONFIG_FILE_KEY, configFile.getAbsolutePath() );\n\n                Bootstrapper bootstrapper = new CommunityBootstrapper();\n                bootstrapper.start();\n                try\n                {\n                    NeoServer server = bootstrapper.getServer();\n                    Database database = server.getDatabase();\n                    assertTrue( database.isRunning() );\n                    checkInstance( store, database.getGraph() );\n                }\n                finally\n                {\n                    bootstrapper.stop();\n                }\n            }\n            finally\n            {\n                System.clearProperty( Configurator.NEO_SERVER_CONFIG_FILE_KEY );\n            }\n\n            assertConsistentStore( dir );\n        }","id":35318,"modified_method":"@Test\n        public void serverDatabaseShouldStartOnOlderStoreWhenUpgradeIsEnabled() throws Throwable\n        {\n            File dir = store.prepareDirectory( testDir.graphDbDir() );\n\n            File configFile = new File( dir, \"neo4j.properties\" );\n            Properties props = new Properties();\n            props.setProperty( Configurator.DATABASE_LOCATION_PROPERTY_KEY, dir.getAbsolutePath() );\n            props.setProperty( Configurator.DB_TUNING_PROPERTY_FILE_KEY, configFile.getAbsolutePath() );\n            props.setProperty( GraphDatabaseSettings.allow_store_upgrade.name(), \"true\" );\n            props.setProperty( GraphDatabaseSettings.pagecache_memory.name(), \"8m\" );\n            props.store( new FileWriter( configFile ), \"\" );\n\n            try\n            {\n                System.setProperty( Configurator.NEO_SERVER_CONFIG_FILE_KEY, configFile.getAbsolutePath() );\n\n                Bootstrapper bootstrapper = new CommunityBootstrapper();\n                bootstrapper.start();\n                try\n                {\n                    NeoServer server = bootstrapper.getServer();\n                    Database database = server.getDatabase();\n                    assertTrue( database.isRunning() );\n                    checkInstance( store, database.getGraph() );\n                }\n                finally\n                {\n                    bootstrapper.stop();\n                }\n            }\n            finally\n            {\n                System.clearProperty( Configurator.NEO_SERVER_CONFIG_FILE_KEY );\n            }\n\n            assertConsistentStore( dir );\n        }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public long indexes()\n        {\n            return indexCounts.length;\n        }","id":35319,"modified_method":"public File prepareDirectory( File targetDir ) throws IOException\n        {\n            AbstractNeo4jTestCase.unzip( targetDir, StoreUpgradeIntegrationTest.class, resourceName );\n            new File( targetDir, \"messages.log\" ).delete(); // clear the log\n            return targetDir;\n        }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void setup() throws IOException\n    {\n        prepareSampleLegacyDatabase( version, fileSystem, workingDirectory );\n        assertTrue( allStoreFilesHaveVersion( fileSystem, workingDirectory, version ) );\n    }","id":35320,"modified_method":"@Before\n    public void setup() throws IOException\n    {\n        workingDirectory = testDir.directory( version );\n        prepareSampleLegacyDatabase( version, fileSystem, workingDirectory );\n        assertTrue( allStoreFilesHaveVersion( fileSystem, workingDirectory, version ) );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StoreUpgradeOnStartupTest( String version )\n    {\n        this.version = version;\n        workingDirectory = TargetDirectory.forTest( getClass() ).cleanDirectory( version );\n    }","id":35321,"modified_method":"public StoreUpgradeOnStartupTest( String version )\n    {\n        this.version = version;\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private GraphDatabaseService createGraphDatabaseService()\n    {\n        return new TestGraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( workingDirectory.getPath() )\n                .setConfig( GraphDatabaseSettings.allow_store_upgrade, \"true\" )\n                .newGraphDatabase();\n    }","id":35322,"modified_method":"private GraphDatabaseService createGraphDatabaseService()\n    {\n        return new TestGraphDatabaseFactory()\n                .newEmbeddedDatabaseBuilder( workingDirectory )\n                .setConfig( GraphDatabaseSettings.allow_store_upgrade, \"true\" )\n                .newGraphDatabase();\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void before() throws Exception\n    {\n        dir = AbstractNeo4jTestCase.unzip( getClass(), \"0.A.1-db.zip\" );\n    }","id":35323,"modified_method":"@Before\n    public void before() throws Exception\n    {\n        dir = AbstractNeo4jTestCase.unzip( testDir.graphDbDir(), getClass(), \"0.A.1-db.zip\" );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void createSomeDataAndCrash( File store, FileSystemAbstraction fileSystem ) throws IOException\n    {\n        final GraphDatabaseService db =\n                new TestGraphDatabaseFactory().setFileSystem( fileSystem ).newImpermanentDatabase( store );\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode();\n            tx.success();\n        }\n\n        File crashed = new File( store.getParent(), \"crashed\" );\n        fileSystem.mkdirs( crashed );\n        fileSystem.copyRecursively( store, crashed );\n\n        db.shutdown();\n\n        fileSystem.deleteRecursively( store );\n        fileSystem.mkdirs( store );\n        fileSystem.copyRecursively( crashed, store );\n        fileSystem.deleteRecursively( crashed );\n    }","id":35324,"modified_method":"private void createSomeDataAndCrash( File store, FileSystemAbstraction fileSystem ) throws IOException\n    {\n        final GraphDatabaseService db =\n                new TestGraphDatabaseFactory().setFileSystem( fileSystem ).newImpermanentDatabase( store );\n\n        try ( Transaction tx = db.beginTx() )\n        {\n            db.createNode();\n            tx.success();\n        }\n\n        File crashed = new File( store.getParent(), \"crashed\" );\n\n        File[] files = fileSystem.listFiles( store );\n        for ( File file : files )\n        {\n            try\n            {\n                fileSystem.copyFile( file, new File( crashed, file.getName() ) );\n            }\n            catch ( IOException ioex )\n            {\n                // ignore files that cannot be copied due to locking on Windows\n            }\n        }\n\n        db.shutdown();\n\n        fileSystem.deleteRecursively( store );\n        fileSystem.copyRecursively( crashed, store );\n        fileSystem.deleteRecursively( crashed );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotDoAnythingIfNoDBPresent() throws Exception\n    {\n        AssertableLogProvider logProvider = new AssertableLogProvider();\n        Config config = buildProperties();\n        PerformRecoveryIfNecessary task = new PerformRecoveryIfNecessary( config, new HashMap<String, String>(), logProvider );\n\n        assertThat( \"Recovery task runs successfully.\", task.run(), is( true ) );\n        assertThat( \"No database should have been created.\", new File( storeDirectory ).exists(), is( false ) );\n        logProvider.assertNoLoggingOccurred();\n    }","id":35325,"modified_method":"@Test\n    public void shouldNotDoAnythingIfNoDBPresent() throws Exception\n    {\n        AssertableLogProvider logProvider = new AssertableLogProvider();\n        Config config = buildProperties();\n        PerformRecoveryIfNecessary task =\n                new PerformRecoveryIfNecessary( config, new HashMap<String,String>(), logProvider );\n\n        assertThat( \"Recovery task runs successfully.\", task.run(), is( true ) );\n        assertThat( \"No database should have been created.\", storeDirectory.exists(), is( false ) );\n        logProvider.assertNoLoggingOccurred();\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void doesNotPrintAnythingIfDatabaseWasCorrectlyShutdown() throws Exception\n    {\n        // Given\n        AssertableLogProvider logProvider = new AssertableLogProvider();\n        Config config = buildProperties();\n        new TestGraphDatabaseFactory().newEmbeddedDatabase( storeDirectory ).shutdown();\n\n        PerformRecoveryIfNecessary task = new PerformRecoveryIfNecessary( config, new HashMap<String, String>(), logProvider );\n\n        assertThat( \"Recovery task should run successfully.\", task.run(), is( true ) );\n        assertThat( \"Database should exist.\", new File( storeDirectory ).exists(), is( true ) );\n        logProvider.assertNoLoggingOccurred();\n    }","id":35326,"modified_method":"@Test\n    public void doesNotPrintAnythingIfDatabaseWasCorrectlyShutdown() throws Exception\n    {\n        // Given\n        AssertableLogProvider logProvider = new AssertableLogProvider();\n        Config config = buildProperties();\n        new TestGraphDatabaseFactory().newEmbeddedDatabase( storeDirectory ).shutdown();\n\n        PerformRecoveryIfNecessary task =\n                new PerformRecoveryIfNecessary( config, new HashMap<String,String>(), logProvider );\n\n        assertThat( \"Recovery task should run successfully.\", task.run(), is( true ) );\n        assertThat( \"Database should exist.\", storeDirectory.exists(), is( true ) );\n        logProvider.assertNoLoggingOccurred();\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldPerformRecoveryIfNecessary() throws Exception\n    {\n        // Given\n        AssertableLogProvider logProvider = new AssertableLogProvider();\n        StoreRecoverer recoverer = new StoreRecoverer();\n        Config config = buildProperties();\n        new TestGraphDatabaseFactory().newEmbeddedDatabase( storeDirectory ).shutdown();\n        // Make this look incorrectly shut down\n        createSomeDataAndCrash( new File( storeDirectory ), new DefaultFileSystemAbstraction() );\n\n        assertThat(\"Store should need recovery\", recoverer.recoveryNeededAt(new File( storeDirectory )), is(true));\n\n        // Run recovery\n        PerformRecoveryIfNecessary task = new PerformRecoveryIfNecessary(config, new HashMap<String,String>(), logProvider );\n        assertThat(\"Recovery task should run successfully.\", task.run(), is(true));\n        assertThat(\"Database should exist.\", new File( storeDirectory ).exists(), is(true));\n\n        logProvider.assertAtLeastOnce(\n                inLog( PerformRecoveryIfNecessary.class ).warn( \"Detected incorrectly shut down database, performing recovery..\" )\n        );\n        assertThat(\"Store should be recovered\", recoverer.recoveryNeededAt( new File( storeDirectory )), is(false));\n\t}","id":35327,"modified_method":"@Test\n    public void shouldPerformRecoveryIfNecessary() throws Exception\n    {\n        // Given\n        AssertableLogProvider logProvider = new AssertableLogProvider();\n        StoreRecoverer recoverer = new StoreRecoverer();\n        Config config = buildProperties();\n        new TestGraphDatabaseFactory().newEmbeddedDatabase( storeDirectory ).shutdown();\n        // Make this look incorrectly shut down\n        createSomeDataAndCrash( storeDirectory, new DefaultFileSystemAbstraction() );\n\n        assertThat( \"Store should need recovery\", recoverer.recoveryNeededAt( storeDirectory ), is( true ) );\n\n        // Run recovery\n        PerformRecoveryIfNecessary task =\n                new PerformRecoveryIfNecessary( config, new HashMap<String,String>(), logProvider );\n        assertThat( \"Recovery task should run successfully.\", task.run(), is( true ) );\n        assertThat( \"Database should exist.\", storeDirectory.exists(), is( true ) );\n\n        logProvider.assertAtLeastOnce(\n                inLog( PerformRecoveryIfNecessary.class )\n                        .warn( \"Detected incorrectly shut down database, performing recovery..\" )\n        );\n        assertThat( \"Store should be recovered\", recoverer.recoveryNeededAt( storeDirectory ), is( false ) );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldNotPerformRecoveryIfNoNeostorePresent() throws Exception\n    {\n        // Given\n        new File( storeDirectory ).mkdirs();\n        new File( storeDirectory, \"unrelated_file\").createNewFile();\n\n        // When\n        boolean actual = new StoreRecoverer().recoveryNeededAt( new File( storeDirectory ), 0 );\n\n        // Then\n        assertThat(\"Recovery should not be needed\", actual,\n                is(false));\n    }","id":35328,"modified_method":"@Test\n    public void shouldNotPerformRecoveryIfNoNeostorePresent() throws Exception\n    {\n        // Given\n        storeDirectory.mkdirs();\n        new File( storeDirectory, \"unrelated_file\" ).createNewFile();\n\n        // When\n        boolean actual = new StoreRecoverer().recoveryNeededAt( storeDirectory, 0 );\n\n        // Then\n        assertThat( \"Recovery should not be needed\", actual,\n                is( false ) );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Config buildProperties() throws IOException\n    {\n        FileUtils.deleteRecursively( new File( homeDirectory ) );\n        new File( homeDirectory + \"/conf\" ).mkdirs();\n\n        Properties databaseProperties = new Properties();\n\n        String databasePropertiesFileName = homeDirectory + \"/conf/neo4j.properties\";\n        databaseProperties.store( new FileWriter( databasePropertiesFileName ), null );\n\n        Config serverProperties = new Config( MapUtil.stringMap(\n                Configurator.DATABASE_LOCATION_PROPERTY_KEY, storeDirectory,\n                Configurator.DB_TUNING_PROPERTY_FILE_KEY, databasePropertiesFileName ) );\n\n        return serverProperties;\n    }","id":35329,"modified_method":"private Config buildProperties() throws IOException\n    {\n        FileUtils.deleteRecursively( homeDirectory );\n        new File( homeDirectory + \"/conf\" ).mkdirs();\n\n        Properties databaseProperties = new Properties();\n\n        String databasePropertiesFileName = homeDirectory + \"/conf/neo4j.properties\";\n        databaseProperties.store( new FileWriter( databasePropertiesFileName ), null );\n\n        Config serverProperties = new Config( MapUtil.stringMap(\n                Configurator.DATABASE_LOCATION_PROPERTY_KEY, storeDirectory.getAbsolutePath(),\n                Configurator.DB_TUNING_PROPERTY_FILE_KEY, databasePropertiesFileName ) );\n\n        return serverProperties;\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Before\n    public void createDirs()\n    {\n        homeDirectory = testDir.directory().getAbsolutePath();\n        storeDirectory = new File(homeDirectory, \"data\" + File.separator + \"graph.db\").getAbsolutePath();\n    }","id":35330,"modified_method":"@Before\n    public void createDirs()\n    {\n        homeDirectory = testDir.directory();\n        storeDirectory = new File( homeDirectory, \"data\" + File.separator + \"graph.db\" );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldUpgradeDatabase() throws IOException\n    {\n        // Given\n        Config serverConfig = buildProperties( true );\n        prepareSampleLegacyDatabase( STORE_DIRECTORY );\n\n        Monitor monitor = mock( Monitor.class );\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        AssertableLogProvider assertableLogProvider = new AssertableLogProvider();\n        LogProvider logProvider = new DuplicatingLogProvider( FormattedLogProvider.toOutputStream( outputStream ), assertableLogProvider );\n\n        PerformUpgradeIfNecessary upgrader = new PerformUpgradeIfNecessary( serverConfig,\n        \t\tloadNeo4jProperties(), logProvider, monitor );\n\n        // When\n        boolean success = upgrader.run();\n\n        // Then\n        if( !success )\n        {\n            System.out.write(outputStream.toByteArray());\n            fail();\n        }\n\n        InOrder order = inOrder( monitor );\n        order.verify( monitor, times( 1 ) ).migrationNeeded();\n        order.verify( monitor, times( 1 ) ).migrationCompleted();\n        order.verifyNoMoreInteractions();\n\n        assertableLogProvider.assertContainsMessageContaining( \"Migration completed\" );\n    }","id":35331,"modified_method":"@Test\n    public void shouldUpgradeDatabase() throws IOException\n    {\n        // Given\n        Config serverConfig = buildProperties( true );\n        prepareSampleLegacyDatabase( storeDir );\n\n        Monitor monitor = mock( Monitor.class );\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n        AssertableLogProvider assertableLogProvider = new AssertableLogProvider();\n        LogProvider logProvider = new DuplicatingLogProvider( FormattedLogProvider.toOutputStream( outputStream ),\n                assertableLogProvider );\n\n        PerformUpgradeIfNecessary upgrader = new PerformUpgradeIfNecessary( serverConfig,\n                loadNeo4jProperties(), logProvider, monitor );\n\n        // When\n        boolean success = upgrader.run();\n\n        // Then\n        if ( !success )\n        {\n            System.out.write( outputStream.toByteArray() );\n            fail();\n        }\n\n        InOrder order = inOrder( monitor );\n        order.verify( monitor, times( 1 ) ).migrationNeeded();\n        order.verify( monitor, times( 1 ) ).migrationCompleted();\n        order.verifyNoMoreInteractions();\n\n        assertableLogProvider.assertContainsMessageContaining( \"Migration completed\" );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Config buildProperties(boolean allowStoreUpgrade) throws IOException\n    {\n        FileUtils.deleteRecursively( HOME_DIRECTORY );\n        assertTrue( CONF_DIRECTORY.mkdirs() );\n\n        Properties databaseProperties = new Properties();\n        if (allowStoreUpgrade)\n        {\n            databaseProperties.setProperty( GraphDatabaseSettings.allow_store_upgrade.name(), \"true\" );\n        }\n\n        databaseProperties.store( new FileWriter( NEO4J_PROPERTIES.getAbsolutePath() ), null );\n\n        Config serverProperties = new Config ( MapUtil.stringMap(\n                Configurator.DATABASE_LOCATION_PROPERTY_KEY, STORE_DIRECTORY.getPath(),\n                Configurator.DB_TUNING_PROPERTY_FILE_KEY, NEO4J_PROPERTIES.getAbsolutePath() ) );\n\n        return serverProperties;\n    }","id":35332,"modified_method":"private Config buildProperties( boolean allowStoreUpgrade ) throws IOException\n    {\n        FileUtils.deleteRecursively( homeDir );\n        assertTrue( confDir.mkdirs() );\n\n        Properties databaseProperties = new Properties();\n        if ( allowStoreUpgrade )\n        {\n            databaseProperties.setProperty( GraphDatabaseSettings.allow_store_upgrade.name(), \"true\" );\n        }\n\n        databaseProperties.store( new FileWriter( neo4jProperties.getAbsolutePath() ), null );\n\n        Config serverProperties = new Config( MapUtil.stringMap(\n                Configurator.DATABASE_LOCATION_PROPERTY_KEY, storeDir.getPath(),\n                Configurator.DB_TUNING_PROPERTY_FILE_KEY, neo4jProperties.getAbsolutePath() ) );\n\n        return serverProperties;\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Map<String,String> loadNeo4jProperties() throws IOException\n    {\n        return MapUtil.load( new File( NEO4J_PROPERTIES.getAbsolutePath() ) );\n    }","id":35333,"modified_method":"private Map<String,String> loadNeo4jProperties() throws IOException\n    {\n        return MapUtil.load( new File( neo4jProperties.getAbsolutePath() ) );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldGiveHelpfulMessageIfAutoUpgradeParameterNotSet() throws IOException\n    {\n        Config serverProperties = buildProperties( false );\n        prepareSampleLegacyDatabase( STORE_DIRECTORY );\n\n        Monitor monitor = mock( Monitor.class );\n        PerformUpgradeIfNecessary upgrader = new PerformUpgradeIfNecessary( serverProperties,\n        \t\tloadNeo4jProperties(), NullLogProvider.getInstance(), monitor );\n\n        boolean exit = upgrader.run();\n\n        assertEquals( false, exit );\n\n        verify( monitor, times( 1 ) ).migrationNeeded();\n        verify( monitor, times( 1 ) ).migrationNotAllowed();\n        verifyNoMoreInteractions( monitor );\n    }","id":35334,"modified_method":"@Test\n    public void shouldGiveHelpfulMessageIfAutoUpgradeParameterNotSet() throws IOException\n    {\n        Config serverProperties = buildProperties( false );\n        prepareSampleLegacyDatabase( storeDir );\n\n        Monitor monitor = mock( Monitor.class );\n        PerformUpgradeIfNecessary upgrader = new PerformUpgradeIfNecessary( serverProperties,\n                loadNeo4jProperties(), NullLogProvider.getInstance(), monitor );\n\n        boolean exit = upgrader.run();\n\n        assertEquals( false, exit );\n\n        verify( monitor, times( 1 ) ).migrationNeeded();\n        verify( monitor, times( 1 ) ).migrationNotAllowed();\n        verifyNoMoreInteractions( monitor );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Test\n    public void shouldExitImmediatelyIfStoreIsAlreadyAtLatestVersion() throws IOException\n    {\n        Config serverConfig = buildProperties( false );\n        GraphDatabaseBuilder builder =\n                new TestGraphDatabaseFactory().newEmbeddedDatabaseBuilder( STORE_DIRECTORY.getPath() );\n        builder.newGraphDatabase().shutdown();\n\n        Monitor monitor = mock( Monitor.class );\n        PerformUpgradeIfNecessary upgrader = new PerformUpgradeIfNecessary( serverConfig,\n        \t\tloadNeo4jProperties(), NullLogProvider.getInstance(), monitor );\n\n        boolean exit = upgrader.run();\n\n        assertEquals( true, exit );\n\n        verifyNoMoreInteractions( monitor );\n    }","id":35335,"modified_method":"@Test\n    public void shouldExitImmediatelyIfStoreIsAlreadyAtLatestVersion() throws IOException\n    {\n        Config serverConfig = buildProperties( false );\n        GraphDatabaseBuilder builder =\n                new TestGraphDatabaseFactory().newEmbeddedDatabaseBuilder( storeDir );\n        builder.newGraphDatabase().shutdown();\n\n        Monitor monitor = mock( Monitor.class );\n        PerformUpgradeIfNecessary upgrader = new PerformUpgradeIfNecessary( serverConfig,\n                loadNeo4jProperties(), NullLogProvider.getInstance(), monitor );\n\n        boolean exit = upgrader.run();\n\n        assertEquals( true, exit );\n\n        verifyNoMoreInteractions( monitor );\n    }","commit_id":"15fd5802cff03534ab05a226dbfba84b75f88622","url":"https://github.com/neo4j/neo4j"},{"original_method":"public File getDecompressedReport(DbSession session, long id) {\n    Connection connection = session.getConnection();\n    InputStream reportDataStream = null;\n    PreparedStatement ps = null;\n    File directory = null;\n\n    try {\n      ps = connection.prepareStatement(SELECT_REPORT_DATA);\n      ps.setLong(1, id);\n\n      ResultSet rs = ps.executeQuery();\n      if (rs.next()) {\n        reportDataStream = rs.getBinaryStream(1);\n        directory = tempFolder.newDir();\n        ZipUtils.unzip(reportDataStream, directory);\n      }\n    } catch (SQLException e) {\n      throw new IllegalStateException(String.format(\"Failed to read report '%d' in the database\", id), e);\n    } catch (IOException e) {\n      throw new IllegalStateException(String.format(\"Failed to decompress report '%d'\", id), e);\n    } finally {\n      IOUtils.closeQuietly(reportDataStream);\n      DatabaseUtils.closeQuietly(ps);\n    }\n\n    return directory;\n  }","id":35336,"modified_method":"@CheckForNull\n  public File getDecompressedReport(DbSession session, long id) {\n    Connection connection = session.getConnection();\n    InputStream reportDataStream = null;\n    PreparedStatement ps = null;\n    File directory = null;\n\n    try {\n      ps = connection.prepareStatement(SELECT_REPORT_DATA);\n      ps.setLong(1, id);\n\n      ResultSet rs = ps.executeQuery();\n      if (rs.next()) {\n        reportDataStream = rs.getBinaryStream(1);\n        if (reportDataStream != null) {\n          directory = tempFolder.newDir();\n          ZipUtils.unzip(reportDataStream, directory);\n        }\n      }\n    } catch (SQLException e) {\n      throw new IllegalStateException(String.format(\"Failed to read report '%d' in the database\", id), e);\n    } catch (IOException e) {\n      throw new IllegalStateException(String.format(\"Failed to decompress report '%d'\", id), e);\n    } finally {\n      IOUtils.closeQuietly(reportDataStream);\n      DatabaseUtils.closeQuietly(ps);\n    }\n\n    return directory;\n  }","commit_id":"a76be79d65c9eb278688887a068cc5dacc857d28","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<ComputationStep> steps() {\n    List<ComputationStep> steps = Lists.newArrayList();\n    // project & views\n    // FIXME this step must be fixed before being reactivated\n//    steps.add(pico.getComponentByType(DigestReportStep.class));\n    // project only\n    steps.add(pico.getComponentByType(SynchronizeProjectPermissionsStep.class));\n    // project & views\n    steps.add(pico.getComponentByType(SwitchSnapshotStep.class));\n    // project only\n    steps.add(pico.getComponentByType(InvalidatePreviewCacheStep.class));\n    // project & views\n    steps.add(pico.getComponentByType(ComponentIndexationInDatabaseStep.class));\n    // project & views\n    steps.add(pico.getComponentByType(DataCleanerStep.class));\n    // project only\n    steps.add(pico.getComponentByType(IndexProjectIssuesStep.class));\n    // project only\n    steps.add(pico.getComponentByType(IndexSourceLinesStep.class));\n\n    return ImmutableList.copyOf(steps);\n  }","id":35337,"modified_method":"public List<ComputationStep> steps() {\n    List<ComputationStep> steps = Lists.newArrayList();\n    // project & views\n    steps.add(pico.getComponentByType(DigestReportStep.class));\n    // project only\n    steps.add(pico.getComponentByType(SynchronizeProjectPermissionsStep.class));\n    // project & views\n    steps.add(pico.getComponentByType(SwitchSnapshotStep.class));\n    // project only\n    steps.add(pico.getComponentByType(InvalidatePreviewCacheStep.class));\n    // project & views\n    steps.add(pico.getComponentByType(ComponentIndexationInDatabaseStep.class));\n    // project & views\n    steps.add(pico.getComponentByType(DataCleanerStep.class));\n    // project only\n    steps.add(pico.getComponentByType(IndexProjectIssuesStep.class));\n    // project only\n    steps.add(pico.getComponentByType(IndexSourceLinesStep.class));\n\n    return ImmutableList.copyOf(steps);\n  }","commit_id":"a76be79d65c9eb278688887a068cc5dacc857d28","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void steps_returned_in_the_right_order() throws Exception {\n    List<Class<? extends ComputationStep>> wishStepsClasses = Lists.newArrayList(\n//      DigestReportStep.class,\n      SynchronizeProjectPermissionsStep.class,\n      SwitchSnapshotStep.class,\n      InvalidatePreviewCacheStep.class,\n      ComponentIndexationInDatabaseStep.class,\n      DataCleanerStep.class,\n      IndexProjectIssuesStep.class,\n      IndexSourceLinesStep.class\n      );\n    List<ComputationStep> steps = sut.steps();\n\n    assertThat(steps).hasSize(wishStepsClasses.size());\n    for (int i = 0; i < steps.size(); i++) {\n      assertThat(steps.get(i)).isInstanceOf(wishStepsClasses.get(i));\n    }\n  }","id":35338,"modified_method":"@Test\n  public void steps_returned_in_the_right_order() throws Exception {\n    List<Class<? extends ComputationStep>> wishStepsClasses = Lists.newArrayList(\n      DigestReportStep.class,\n      SynchronizeProjectPermissionsStep.class,\n      SwitchSnapshotStep.class,\n      InvalidatePreviewCacheStep.class,\n      ComponentIndexationInDatabaseStep.class,\n      DataCleanerStep.class,\n      IndexProjectIssuesStep.class,\n      IndexSourceLinesStep.class\n      );\n    List<ComputationStep> steps = sut.steps();\n\n    assertThat(steps).hasSize(wishStepsClasses.size());\n    for (int i = 0; i < steps.size(); i++) {\n      assertThat(steps.get(i)).isInstanceOf(wishStepsClasses.get(i));\n    }\n  }","commit_id":"a76be79d65c9eb278688887a068cc5dacc857d28","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public String getDescription() {\n    return \"Uncompress analysis report\";\n  }","id":35339,"modified_method":"@Override\n  public String getDescription() {\n    return \"Decompress analysis report\";\n  }","commit_id":"a76be79d65c9eb278688887a068cc5dacc857d28","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Installs the given library file to the active sketchbook. The contents of\n   * the library are extracted to a temporary folder before being moved.\n   */\n  protected int installLibrary(File libFile) {\n    try {\n      String libName = guessLibraryName(libFile);\n\n      File tmpFolder = Base.createTempFolder(libName, \"uncompressed\");\n      unzip(libFile, tmpFolder);\n      \n      return installLibraries(Library.list(tmpFolder));\n    } catch (IOException e) {\n      Base.showWarning(\"Trouble creating temporary folder\",\n           \"Could not create a place to store libary's uncompressed contents,\\n\" + \n           \"so it won't be installed.\", e);\n    }\n    \n    return 0;\n  }","id":35340,"modified_method":"/**\n   * Installs the given library file to the active sketchbook. The contents of\n   * the library are extracted to a temporary folder before being moved.\n   */\n  protected int installLibrary(File libFile) {\n    \n    String libName = guessLibraryName(libFile);\n    \n    File tmpFolder = null;\n    \n    try {\n      tmpFolder = Base.createTempFolder(libName, \"uncompressed\");\n    } catch (IOException e) {\n      Base.showWarning(\"Trouble creating temporary folder\",\n           \"Could not create a place to store libary's uncompressed contents,\\n\" + \n           \"so it won't be installed.\", e);\n    }\n    \n    Exception e = null;\n    boolean errorEncountered = false;\n    unzip(libFile, tmpFolder);\n    try {  \n      ArrayList<Library> discoveredLibs = Library.list(tmpFolder);\n      if (discoveredLibs.isEmpty()) {\n        // No libraries found. It's okay though, the author might not have not\n        // read the library guidelines and placed all their folders in the base\n        // directory of the their zip file. If this is the case, let's help them\n        // out, rather than complain about it.\n        \n        File newLibFolder = getUniqueName(tmpFolder, libName);\n        if (newLibFolder.mkdirs()) {\n          for (File f : tmpFolder.listFiles()) {\n            if (!f.equals(newLibFolder)) {\n              if (!f.renameTo(new File(newLibFolder, f.getName()))) {\n                // The file wasn't moved for whatever reason\n                errorEncountered = true;\n              }\n            }\n          }\n          discoveredLibs = Library.list(tmpFolder);\n        } else {\n          // We couldn't make the directory to move the library to\n          errorEncountered = true;\n        }\n        \n      }\n      \n      // Do this, or windows won't let us move the files we just moved again.\n      System.gc();\n      \n      if (!errorEncountered) {\n        return installLibraries(discoveredLibs);\n      }\n    } catch (IOException ioe) {\n      e = ioe;\n    }\n    \n    Base.showWarning(\"Trouble discovering libraries\",\n                     \"Could not find libraries in the downloaded file.\\n\" + \n                     \"This may be a one time error, please try again.\", e);\n    \n    return 0;\n  }","commit_id":"306cca7c30c28c9e9ece974af71981ecde01581e","url":"https://github.com/processing/processing"},{"original_method":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        // Step 1: Expand Jetty resources into the package output directory.\n        getLog().info(\"Expanding Jetty Resources ...\");\n        Artifact jettyArtifact = resolveJettyArtifact();\n        unzip(jettyArtifact.getFile(), this.outputPackageDirectory);\n\n        // Step 2: Get the WAR dependencies and expand them in the package output directory.\n        getLog().info(\"Expanding WAR dependencies ...\");\n        File webappsDirectory = new File(this.outputPackageDirectory, \"webapps\");\n        for (Map.Entry<String, Artifact> warArtifactEntry : resolveWarArtifacts().entrySet()) {\n            getLog().info(\"  ... Unzipping WAR: \" + warArtifactEntry.getValue().getFile());\n            unzip(warArtifactEntry.getValue().getFile(), new File(webappsDirectory, warArtifactEntry.getKey()));\n        }\n\n        // Step 3: Copy all JARs dependencies to the expanded WAR directory in WEB-INF/lib\n        getLog().info(\"Copying JAR dependencies ...\");\n        File xwikiWebappDirectory = new File(webappsDirectory, \"xwiki\");\n        File webInfDirectory = new File(xwikiWebappDirectory, \"WEB-INF\");\n        File libDirectory = new File(webInfDirectory, \"lib\");\n        createDirectory(libDirectory);\n        for (Artifact artifact : resolveJarArtifacts()) {\n            getLog().info(\"  ... Copying JAR: \" + artifact.getFile());\n            copyFile(artifact.getFile(), libDirectory);\n        }\n\n        // Step 4: Copy compiled classes in the WEB-INF/Classes directory. This allows the tests to provide custom\n        //         code, for example to override existing components for the test purpose. As an example the link\n        //         checker might want to override the HTTP Checker component so that checks are not done over the\n        //         internet since the tests need to execute in a stable environment to prevent false positives.\n        getLog().info(\"Copying Java Classes ...\");\n        File classesDirectory = new File(webInfDirectory, \"classes\");\n        if (this.outputClassesDirectory.exists()) {\n            copyDirectory(this.outputClassesDirectory, classesDirectory);\n        }\n\n        // Step 5: Generate and copy config files.\n        getLog().info(\"Copying Configuration files ...\");\n        generateConfigurationFiles(webInfDirectory);\n\n        // Step 6: Copy HSQLDB JDBC Driver\n        getLog().info(\"Copying HSQLDB JDBC Driver JAR ...\");\n        Artifact hsqldbArtifact = resolveHSQLDBArtifact();\n        copyFile(hsqldbArtifact.getFile(), libDirectory);\n\n        // Step 7: Unzip the Colibri Skin\n        getLog().info(\"Copying Colibri Skin ...\");\n        File skinsDirectory = new File(xwikiWebappDirectory, \"skins\");\n        Artifact colibriArtifact = resolveColibriArtifact();\n        unzip(colibriArtifact.getFile(), skinsDirectory);\n\n        // Step 8: Import specified XAR files into the database\n        getLog().info(\"Import XAR dependencies ...\");\n        importXARs(webInfDirectory);\n    }","id":35341,"modified_method":"@Override\n    public void execute() throws MojoExecutionException, MojoFailureException\n    {\n        // Step 1: Expand Jetty resources into the package output directory.\n        getLog().info(\"Expanding Jetty Resources ...\");\n        Artifact jettyArtifact = resolveJettyArtifact();\n        unzip(jettyArtifact.getFile(), this.outputPackageDirectory);\n\n        // Step 2: Get the WAR dependencies and expand them in the package output directory.\n        getLog().info(\"Expanding WAR dependencies ...\");\n        File webappsDirectory = new File(this.outputPackageDirectory, \"webapps\");\n        for (Map.Entry<String, Artifact> warArtifactEntry : resolveWarArtifacts().entrySet()) {\n            getLog().info(\"  ... Unzipping WAR: \" + warArtifactEntry.getValue().getFile());\n            unzip(warArtifactEntry.getValue().getFile(), new File(webappsDirectory, warArtifactEntry.getKey()));\n        }\n\n        // Step 3: Copy all JARs dependencies to the expanded WAR directory in WEB-INF/lib\n        getLog().info(\"Copying JAR dependencies ...\");\n        File xwikiWebappDirectory = new File(webappsDirectory, \"xwiki\");\n        File webInfDirectory = new File(xwikiWebappDirectory, \"WEB-INF\");\n        File libDirectory = new File(webInfDirectory, \"lib\");\n        createDirectory(libDirectory);\n        for (Artifact artifact : resolveJarArtifacts()) {\n            getLog().info(\"  ... Copying JAR: \" + artifact.getFile());\n            copyFile(artifact.getFile(), libDirectory);\n        }\n\n        // Step 4: Copy compiled classes in the WEB-INF/Classes directory. This allows the tests to provide custom\n        //         code, for example to override existing components for the test purpose. As an example the link\n        //         checker might want to override the HTTP Checker component so that checks are not done over the\n        //         internet since the tests need to execute in a stable environment to prevent false positives.\n        getLog().info(\"Copying Java Classes ...\");\n        File classesDirectory = new File(webInfDirectory, \"classes\");\n        if (this.outputClassesDirectory.exists()) {\n            copyDirectory(this.outputClassesDirectory, classesDirectory);\n        }\n\n        // Step 5: Generate and copy config files.\n        getLog().info(\"Copying Configuration files ...\");\n        generateConfigurationFiles(webInfDirectory);\n\n        // Step 6: Copy HSQLDB JDBC Driver\n        getLog().info(\"Copying HSQLDB JDBC Driver JAR ...\");\n        Artifact hsqldbArtifact = resolveHSQLDBArtifact();\n        copyFile(hsqldbArtifact.getFile(), libDirectory);\n\n        // Step 7: Unzip the specified Skins. If no skin is specified then unzip the Colibri skin only.\n        getLog().info(\"Copying Skins ...\");\n        File skinsDirectory = new File(xwikiWebappDirectory, \"skins\");\n        if (this.skinArtifactItems != null) {\n            for (SkinArtifactItem skinArtifactItem : this.skinArtifactItems) {\n                Artifact skinArtifact = resolveArtifactItem(skinArtifactItem);\n                unzip(skinArtifact.getFile(), skinsDirectory);\n            }\n        } else {\n            Artifact colibriArtifact = resolveArtifact(\"org.xwiki.platform\", \"xwiki-platform-colibri\",\n                this.project.getVersion(), \"zip\");\n            unzip(colibriArtifact.getFile(), skinsDirectory);\n        }\n\n        // Step 8: Import specified XAR files into the database\n        getLog().info(\"Import XAR dependencies ...\");\n        importXARs(webInfDirectory);\n    }","commit_id":"a0f6da79d2dad76edc9868898ae70b45e281eeaf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private Artifact resolveColibriArtifact() throws MojoExecutionException\n    {\n        Artifact colibriArtifact = this.factory.createArtifact(\"org.xwiki.platform\", \"xwiki-platform-colibri\",\n            this.project.getVersion(), \"\", \"zip\");\n        resolveArtifact(colibriArtifact);\n        return colibriArtifact;\n    }","id":35342,"modified_method":"private Artifact resolveArtifact(String groupId, String artifactId, String version, String type)\n        throws MojoExecutionException\n    {\n        Artifact artifact = this.factory.createArtifact(groupId, artifactId, version, \"\", type);\n        resolveArtifact(artifact);\n        return artifact;\n    }","commit_id":"a0f6da79d2dad76edc9868898ae70b45e281eeaf","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public File createDist(WrapperConfiguration configuration) throws Exception {\n        URI distributionUrl = configuration.getDistribution();\n        boolean alwaysDownload = configuration.isAlwaysDownload();\n        boolean alwaysUnpack = configuration.isAlwaysUnpack();\n\n        PathAssembler.LocalDistribution localDistribution = pathAssembler.getDistribution(configuration);\n        File gradleHome = localDistribution.getGradleHome();\n        if (!alwaysDownload && !alwaysUnpack && gradleHome.isDirectory()) {\n            return gradleHome;\n        }\n        File localZipFile = localDistribution.getDistZip();\n        if (alwaysDownload || !localZipFile.exists()) {\n            File tmpZipFile = new File(localZipFile.getParentFile(), localZipFile.getName() + \".part\");\n            tmpZipFile.delete();\n            System.out.println(\"Downloading \" + distributionUrl);\n            download.download(distributionUrl, tmpZipFile);\n            tmpZipFile.renameTo(localZipFile);\n        }\n        if (gradleHome.isDirectory()) {\n            System.out.println(\"Deleting directory \" + gradleHome.getAbsolutePath());\n            deleteDir(gradleHome);\n        }\n        File distDest = gradleHome.getParentFile();\n        System.out.println(\"Unzipping \" + localZipFile.getAbsolutePath() + \" to \" + distDest.getAbsolutePath());\n        unzip(localZipFile, distDest);\n        if (!gradleHome.isDirectory()) {\n            throw new RuntimeException(String.format(\n                    \"Gradle distribution '%s' does not contain expected root directory '%s'.\", distributionUrl,\n                    gradleHome.getName()));\n        }\n        setExecutablePermissions(gradleHome);\n        return gradleHome;\n    }","id":35343,"modified_method":"public File createDist(WrapperConfiguration configuration) throws Exception {\n        URI distributionUrl = configuration.getDistribution();\n        boolean alwaysDownload = configuration.isAlwaysDownload();\n        boolean alwaysUnpack = configuration.isAlwaysUnpack();\n\n        PathAssembler.LocalDistribution localDistribution = pathAssembler.getDistribution(configuration);\n\n        File localZipFile = localDistribution.getZipFile();\n        boolean downloaded = false;\n        if (alwaysDownload || !localZipFile.exists()) {\n            File tmpZipFile = new File(localZipFile.getParentFile(), localZipFile.getName() + \".part\");\n            tmpZipFile.delete();\n            System.out.println(\"Downloading \" + distributionUrl);\n            download.download(distributionUrl, tmpZipFile);\n            tmpZipFile.renameTo(localZipFile);\n            downloaded = true;\n        }\n\n        File distDir = localDistribution.getDistributionDir();\n        List<File> dirs = listDirs(distDir);\n\n        if (downloaded || alwaysUnpack || dirs.isEmpty()) {\n            for (File dir : dirs) {\n                System.out.println(\"Deleting directory \" + dir.getAbsolutePath());\n                deleteDir(dir);\n            }\n            System.out.println(\"Unzipping \" + localZipFile.getAbsolutePath() + \" to \" + distDir.getAbsolutePath());\n            unzip(localZipFile, distDir);\n            dirs = listDirs(distDir);\n            if (dirs.isEmpty()) {\n                throw new RuntimeException(String.format(\"Gradle distribution '%s' does not contain any directories. Expected to find exactly 1 directory.\", distributionUrl));\n            }\n            setExecutablePermissions(dirs.get(0));\n        }\n        if (dirs.size() != 1) {\n            throw new RuntimeException(String.format(\"Gradle distribution '%s' contains too many directories. Expected to find exactly 1 directory.\", distributionUrl));\n        }\n        return dirs.get(0);\n    }","commit_id":"74387f57596935744150048dd92c3ec11ace1036","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Determines the local locations for the distribution to use given the supplied configuration. \n     */\n    public LocalDistribution getDistribution(WrapperConfiguration configuration) {\n        File gradleHome = gradleHome(configuration.getDistributionBase(), configuration.getDistributionPath(), configuration.getDistribution());\n        File distZip = distZip(configuration.getZipBase(), configuration.getZipPath(), configuration.getDistribution());\n        return new LocalDistribution(gradleHome, distZip);\n    }","id":35344,"modified_method":"/**\n     * Determines the local locations for the distribution to use given the supplied configuration. \n     */\n    public LocalDistribution getDistribution(WrapperConfiguration configuration) {\n        String baseName = getDistName(configuration.getDistribution());\n        String distName = removeExtension(baseName);\n        String rootDirName = rootDirName(distName, configuration);\n        File distDir = new File(getBaseDir(configuration.getDistributionBase()), configuration.getDistributionPath() + \"/\" + rootDirName);\n        File distZip = new File(getBaseDir(configuration.getZipBase()), configuration.getZipPath() + \"/\" + rootDirName + \"/\" + baseName);\n        return new LocalDistribution(distDir, distZip);\n    }","commit_id":"74387f57596935744150048dd92c3ec11ace1036","url":"https://github.com/gradle/gradle"},{"original_method":"public LocalDistribution(File gradleHome, File distZip) {\n            this.gradleHome = gradleHome;\n            this.distZip = distZip;\n        }","id":35345,"modified_method":"public LocalDistribution(File distDir, File distZip) {\n            this.distDir = distDir;\n            this.distZip = distZip;\n        }","commit_id":"74387f57596935744150048dd92c3ec11ace1036","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void gradleHomeWithGradleUserHomeBase() throws Exception {\n        configuration.setDistribution(new URI(\"http://server/dist/gradle-0.9-bin.zip\"));\n        \n        File gradleHome = pathAssembler.getDistribution(configuration).getGradleHome();\n        assertEquals(file(TEST_GRADLE_USER_HOME + \"/somePath/gradle-0.9\"), gradleHome);\n    }","id":35346,"modified_method":"@Test\n    public void distributionDirWithGradleUserHomeBase() throws Exception {\n        configuration.setDistribution(new URI(\"http://server/dist/gradle-0.9-bin.zip\"));\n        \n        File distributionDir = pathAssembler.getDistribution(configuration).getDistributionDir();\n        assertThat(distributionDir.getName(), matchesRegexp(\"[a-z0-9]+\"));\n        assertThat(distributionDir.getParentFile(), equalTo(file(TEST_GRADLE_USER_HOME + \"/somePath/gradle-0.9-bin\")));\n    }","commit_id":"74387f57596935744150048dd92c3ec11ace1036","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void distZipWithProjectBase() throws Exception {\n        configuration.setZipBase(PathAssembler.PROJECT_STRING);\n        configuration.setDistribution(new URI(\"http://server/dist/gradle-1.0.zip\"));\n\n        File dist = pathAssembler.getDistribution(configuration).getDistZip();\n        assertEquals(file(currentDirPath() + \"/somePath/gradle-1.0.zip\"), dist);\n    }","id":35347,"modified_method":"@Test\n    public void distZipWithProjectBase() throws Exception {\n        configuration.setZipBase(PathAssembler.PROJECT_STRING);\n        configuration.setDistribution(new URI(\"http://server/dist/gradle-1.0.zip\"));\n\n        File dist = pathAssembler.getDistribution(configuration).getZipFile();\n        assertThat(dist.getName(), equalTo(\"gradle-1.0.zip\"));\n        assertThat(dist.getParentFile().getName(), matchesRegexp(\"[a-z0-9]+\"));\n        assertThat(dist.getParentFile().getParentFile(), equalTo(file(currentDirPath() + \"/somePath/gradle-1.0\")));\n    }","commit_id":"74387f57596935744150048dd92c3ec11ace1036","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void distZipWithGradleUserHomeBase() throws Exception {\n        configuration.setDistribution(new URI(\"http://server/dist/gradle-1.0.zip\"));\n\n        File dist = pathAssembler.getDistribution(configuration).getDistZip();\n        assertEquals(file(TEST_GRADLE_USER_HOME + \"/somePath/gradle-1.0.zip\"), dist);\n    }","id":35348,"modified_method":"@Test\n    public void distZipWithGradleUserHomeBase() throws Exception {\n        configuration.setDistribution(new URI(\"http://server/dist/gradle-1.0.zip\"));\n\n        File dist = pathAssembler.getDistribution(configuration).getZipFile();\n        assertThat(dist.getName(), equalTo(\"gradle-1.0.zip\"));\n        assertThat(dist.getParentFile().getName(), matchesRegexp(\"[a-z0-9]+\"));\n        assertThat(dist.getParentFile().getParentFile(), equalTo(file(TEST_GRADLE_USER_HOME + \"/somePath/gradle-1.0\")));\n    }","commit_id":"74387f57596935744150048dd92c3ec11ace1036","url":"https://github.com/gradle/gradle"},{"original_method":"public int run(String[] args) {\n    if (parseArgs(args) != 0) {\n      return -1;\n    }\n    if (!setFsDefaultName()) {\n      return -2;\n    }\n    if (!verifyFilesystem()) {\n      return -3;\n    }\n    if (!notRunning()) {\n      return -4;\n    }\n\n    try {\n      LOG.info(\"Starting upgrade\" + (readOnly ? \" check\" : \"\"));\n\n      // See if there is a file system version file\n      String versionStr = FSUtils.getVersion(fs, FSUtils.getRootDir(this.conf));\n      if (versionStr == null) {\n        throw new IOException(\"File system version file \" +\n            HConstants.VERSION_FILE_NAME +\n            \" does not exist. No upgrade possible.\" + MIGRATION_LINK);\n      }\n      if (versionStr.compareTo(HConstants.FILE_SYSTEM_VERSION) == 0) {\n        LOG.info(\"No upgrade necessary.\");\n        return 0;\n      }\n      float version = Float.parseFloat(versionStr);\n      if (version == HBASE_0_1_VERSION ||\n          Integer.valueOf(versionStr).intValue() < PREVIOUS_VERSION) {\n        String msg = \"Cannot upgrade from \" + versionStr + \" to \" +\n        HConstants.FILE_SYSTEM_VERSION + \" you must install hbase-0.2.x, run \" +\n        \"the upgrade tool, reinstall this version and run this utility again.\" +\n        MIGRATION_LINK;\n        System.out.println(msg);\n        throw new IOException(msg);\n      }\n\n      migrate4To6();\n\n      if (!readOnly) {\n        // Set file system version\n        LOG.info(\"Setting file system version.\");\n        FSUtils.setVersion(fs, FSUtils.getRootDir(this.conf));\n        LOG.info(\"Upgrade successful.\");\n      } else if (this.migrationNeeded) {\n        LOG.info(\"Upgrade needed.\");\n      }\n      return 0;\n    } catch (Exception e) {\n      LOG.fatal(\"Upgrade\" +  (readOnly ? \" check\" : \"\") + \" failed\", e);\n      return -1;\n    }\n  }","id":35349,"modified_method":"public int run(String[] args) {\n    if (parseArgs(args) != 0) {\n      return -1;\n    }\n    if (!setFsDefaultName()) {\n      return -2;\n    }\n    if (!verifyFilesystem()) {\n      return -3;\n    }\n    if (!notRunning()) {\n      return -4;\n    }\n\n    try {\n      LOG.info(\"Starting upgrade\" + (readOnly ? \" check\" : \"\"));\n\n      // See if there is a file system version file\n      String versionStr = FSUtils.getVersion(fs, FSUtils.getRootDir(this.conf));\n      if (versionStr == null) {\n        throw new IOException(\"File system version file \" +\n            HConstants.VERSION_FILE_NAME +\n            \" does not exist. No upgrade possible.\" + MIGRATION_LINK);\n      }\n      if (versionStr.compareTo(HConstants.FILE_SYSTEM_VERSION) == 0) {\n        LOG.info(\"No upgrade necessary.\");\n        return 0;\n      }\n      float version = Float.parseFloat(versionStr);\n      if (version == HBASE_0_1_VERSION ||\n          Integer.valueOf(versionStr).intValue() < PREVIOUS_VERSION) {\n        String msg = \"Cannot upgrade from \" + versionStr + \" to \" +\n        HConstants.FILE_SYSTEM_VERSION + \" you must install an earlier hbase, run \" +\n        \"the upgrade tool, reinstall this version and run this utility again.\" +\n        MIGRATION_LINK;\n        System.out.println(msg);\n        throw new IOException(msg);\n      }\n\n      migrate6to7();\n\n      if (!readOnly) {\n        // Set file system version\n        LOG.info(\"Setting file system version.\");\n        FSUtils.setVersion(fs, FSUtils.getRootDir(this.conf));\n        LOG.info(\"Upgrade successful.\");\n      } else if (this.migrationNeeded) {\n        LOG.info(\"Upgrade needed.\");\n      }\n      return 0;\n    } catch (Exception e) {\n      LOG.fatal(\"Upgrade\" +  (readOnly ? \" check\" : \"\") + \" failed\", e);\n      return -1;\n    }\n  }","commit_id":"10c33cc48d0df175aa1c4c9c6a50e5ece7dc81bb","url":"https://github.com/apache/hbase"},{"original_method":"private void verify() throws IOException {\n    // Delete any cached connections.  Need to do this because connection was\n    // created earlier when no master was around.  The fact that there was no\n    // master gets cached.  Need to delete so we go get master afresh.\n    HConnectionManager.deleteConnectionInfo(conf, false);\n    \n    LOG.info(\"Start a cluster against migrated FS\");\n    // Up number of retries.  Needed while cluster starts up. Its been set to 1\n    // above.\n    final int retries = 5;\n    this.conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER_KEY, retries);\n    \n    MiniHBaseCluster cluster = new MiniHBaseCluster(this.conf, 1);\n    try {\n      HBaseAdmin hb = new HBaseAdmin(this.conf);\n      assertTrue(hb.isMasterRunning());\n      HTableDescriptor [] tables = hb.listTables();\n      boolean foundTable = false;\n      for (int i = 0; i < tables.length; i++) {\n        if (Bytes.equals(Bytes.toBytes(TABLENAME), tables[i].getName())) {\n          foundTable = true;\n          break;\n        }\n      }\n      assertTrue(foundTable);\n      LOG.info(TABLENAME + \" exists.  Now waiting till startcode \" +\n        \"changes before opening a scanner\");\n      waitOnStartCodeChange(retries);\n      // Delete again so we go get it all fresh.\n      HConnectionManager.deleteConnectionInfo(conf, false);\n      HTable t = new HTable(this.conf, TABLENAME);\n      int count = 0;\n      LOG.info(\"OPENING SCANNER\");\n      Scan scan = new Scan();\n      scan.addColumns(TABLENAME_COLUMNS);\n      ResultScanner s = t.getScanner(scan);\n      try {\n        for (Result r: s) {\n          if (r == null || r.size() == 0) {\n            break;\n          }\n          count++;\n          if (count % 1000 == 0 && count > 0) {\n            LOG.info(\"Iterated over \" + count + \" rows.\");\n          }\n        }\n        assertEquals(EXPECTED_COUNT, count);\n      } finally {\n        s.close();\n      }\n    } finally {\n      HConnectionManager.deleteConnectionInfo(conf, false);\n      cluster.shutdown();\n    }\n  }","id":35350,"modified_method":"private void verify() throws IOException {\n    // Delete any cached connections.  Need to do this because connection was\n    // created earlier when no master was around.  The fact that there was no\n    // master gets cached.  Need to delete so we go get master afresh.\n    HConnectionManager.deleteConnectionInfo(conf, false);\n    \n    LOG.info(\"Start a cluster against migrated FS\");\n    // Up number of retries.  Needed while cluster starts up. Its been set to 1\n    // above.\n    final int retries = 5;\n    this.conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER_KEY, retries);\n    \n    MiniHBaseCluster cluster = new MiniHBaseCluster(this.conf, 1);\n    try {\n      HBaseAdmin hb = new HBaseAdmin(this.conf);\n      assertTrue(hb.isMasterRunning());\n      HTableDescriptor [] tables = hb.listTables();\n      boolean foundTable = false;\n      /*\n      for (int i = 0; i < tables.length; i++) {\n        if (Bytes.equals(Bytes.toBytes(TABLENAME), tables[i].getName())) {\n          foundTable = true;\n          break;\n        }\n      }\n      assertTrue(foundTable);\n      LOG.info(TABLENAME + \" exists.  Now waiting till startcode \" +\n        \"changes before opening a scanner\");\n      waitOnStartCodeChange(retries);\n      // Delete again so we go get it all fresh.\n      HConnectionManager.deleteConnectionInfo(conf, false);\n      HTable t = new HTable(this.conf, TABLENAME);\n      int count = 0;\n      LOG.info(\"OPENING SCANNER\");\n      Scan scan = new Scan();\n      scan.addColumns(TABLENAME_COLUMNS);\n      ResultScanner s = t.getScanner(scan);\n      try {\n        for (Result r: s) {\n          if (r == null || r.size() == 0) {\n            break;\n          }\n          count++;\n          if (count % 1000 == 0 && count > 0) {\n            LOG.info(\"Iterated over \" + count + \" rows.\");\n          }\n        }\n        assertEquals(EXPECTED_COUNT, count);\n      } finally {\n        s.close();\n      }\n      \n    */\n    } finally {\n      HConnectionManager.deleteConnectionInfo(conf, false);\n      cluster.shutdown();\n    }\n  }","commit_id":"10c33cc48d0df175aa1c4c9c6a50e5ece7dc81bb","url":"https://github.com/apache/hbase"},{"original_method":"private void loadTestData(final FileSystem dfs, final Path rootDir)\n  throws IOException {\n    FileSystem localfs = FileSystem.getLocal(conf);\n    // Get path for zip file.  If running this test in eclipse, define\n    // the system property src.testdata for your test run.\n    String srcTestdata = System.getProperty(\"src.testdata\");\n    if (srcTestdata == null) {\n      throw new NullPointerException(\"Define src.test system property\");\n    }\n    Path data = new Path(srcTestdata, \"HADOOP-2478-testdata-v0.1.zip\");\n    if (!localfs.exists(data)) {\n      throw new FileNotFoundException(data.toString());\n    }\n    FSDataInputStream hs = localfs.open(data);\n    ZipInputStream zip = new ZipInputStream(hs);\n    unzip(zip, dfs, rootDir);\n    zip.close();\n    hs.close();\n  }","id":35351,"modified_method":"private Path loadTestData(final FileSystem dfs, final Path rootDir)\n  throws IOException {\n    String hbasedir = \"hbase-0.19-two-small-tables\";\n    InputStream is = this.getClass().getClassLoader().\n      getResourceAsStream(\"data/\" + hbasedir + \".zip\");\n    ZipInputStream zip = new ZipInputStream(is);\n    try {\n      unzip(zip, dfs, rootDir);\n    } finally {\n      zip.close();\n    }\n    return new Path(rootDir, hbasedir);\n  }","commit_id":"10c33cc48d0df175aa1c4c9c6a50e5ece7dc81bb","url":"https://github.com/apache/hbase"},{"original_method":"public Session getSession() throws PortalException, SystemException {\n\t\tSession session = getCachedSession();\n\n\t\tif (session != null) {\n\t\t\treturn session;\n\t\t}\n\n\t\tSessionImpl sessionImpl =\n\t\t\t(SessionImpl)_cmisRepositoryHandler.getSession();\n\n\t\tsession = sessionImpl.getSession();\n\n\t\tsetCachedSession(session);\n\n\t\treturn session;\n\t}","id":35352,"modified_method":"public Session getSession() throws PortalException, SystemException {\n\t\tSession session = getCachedSession();\n\n\t\tif (session != null) {\n\t\t\treturn session;\n\t\t}\n\n\t\tSessionImpl sessionImpl =\n\t\t\t(SessionImpl)_cmisRepositoryHandler.getSession();\n\n\t\tsession = sessionImpl.getSession();\n\n\t\tsetCachedSession(session);\n\n\t\t_initRepositoryDetector();\n\n\t\treturn session;\n\t}","commit_id":"03e8e9628fa611d7fdf1a1556ed936bfd9ad5a7d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Hits doSearch(SearchContext searchContext, Query query)\n\t\tthrows Exception {\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tSession session = getSession();\n\n\t\tRepositoryInfo repositoryInfo = session.getRepositoryInfo();\n\n\t\tRepositoryCapabilities repositoryCapabilities =\n\t\t\trepositoryInfo.getCapabilities();\n\n\t\tQueryConfig queryConfig = searchContext.getQueryConfig();\n\n\t\tCapabilityQuery capabilityQuery =\n\t\t\trepositoryCapabilities.getQueryCapability();\n\n\t\tqueryConfig.setAttribute(\"capabilityQuery\", capabilityQuery.value());\n\n\t\tString productName = repositoryInfo.getProductName();\n\t\tString productVersion = repositoryInfo.getProductVersion();\n\n\t\tqueryConfig.setAttribute(\"repositoryProductName\", productName);\n\t\tqueryConfig.setAttribute(\"repositoryProductVersion\", productVersion);\n\n\t\tString queryString = CMISSearchQueryBuilderUtil.buildQuery(\n\t\t\tsearchContext, query);\n\n\t\tif (productName.contains(\"Nuxeo\") && productVersion.contains(\"5.4\")) {\n\t\t\tqueryString +=\n\t\t\t\t\" AND (\" + PropertyIds.IS_LATEST_VERSION + \" = true)\";\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"CMIS search query: \" + queryString);\n\t\t}\n\n\t\tItemIterable<QueryResult> queryResults = session.query(\n\t\t\tqueryString, false);\n\n\t\tint start = searchContext.getStart();\n\t\tint end = searchContext.getEnd();\n\n\t\tif ((start == QueryUtil.ALL_POS) && (end == QueryUtil.ALL_POS)) {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tint total = 0;\n\n\t\tList<com.liferay.portal.kernel.search.Document> documents =\n\t\t\tnew ArrayList<com.liferay.portal.kernel.search.Document>();\n\t\tList<String> snippets = new ArrayList<String>();\n\t\tList<Float> scores = new ArrayList<Float>();\n\n\t\tfor (QueryResult queryResult : queryResults) {\n\t\t\ttotal++;\n\n\t\t\tif (total <= start) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((total > end) && (end != QueryUtil.ALL_POS)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcom.liferay.portal.kernel.search.Document document =\n\t\t\t\tnew DocumentImpl();\n\n\t\t\tString objectId = queryResult.getPropertyValueByQueryName(\n\t\t\t\tPropertyIds.OBJECT_ID);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Search result object ID \" + objectId);\n\t\t\t}\n\n\t\t\tFileEntry fileEntry = null;\n\n\t\t\ttry {\n\t\t\t\tfileEntry = toFileEntry(objectId, true);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tThrowable cause = e.getCause();\n\n\t\t\t\t\tif (cause != null) {\n\t\t\t\t\t\tcause = cause.getCause();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cause instanceof CmisObjectNotFoundException) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Search result ignored for CMIS document which \" +\n\t\t\t\t\t\t\t\t\"has a version with an invalid object ID \" +\n\t\t\t\t\t\t\t\t\tcause.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Search result ignored for invalid object ID\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttotal--;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ENTRY_CLASS_NAME, fileEntry.getModelClassName());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ENTRY_CLASS_PK, fileEntry.getFileEntryId());\n\t\t\tdocument.addKeyword(Field.TITLE, fileEntry.getTitle());\n\n\t\t\tdocuments.add(document);\n\n\t\t\tif (queryConfig.isScoreEnabled()) {\n\t\t\t\tObject scoreObj = queryResult.getPropertyValueByQueryName(\n\t\t\t\t\t\"HITS\");\n\n\t\t\t\tif (scoreObj != null) {\n\t\t\t\t\tscores.add(Float.valueOf(scoreObj.toString()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tscores.add(1.0f);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscores.add(1.0f);\n\t\t\t}\n\n\t\t\tsnippets.add(StringPool.BLANK);\n\t\t}\n\n\t\tfloat searchTime =\n\t\t\t(float)(System.currentTimeMillis() - startTime) / Time.SECOND;\n\n\t\tHits hits = new HitsImpl();\n\n\t\thits.setDocs(\n\t\t\tdocuments.toArray(\n\t\t\t\tnew com.liferay.portal.kernel.search.Document[\n\t\t\t\t\tdocuments.size()]));\n\t\thits.setLength(total);\n\t\thits.setQuery(query);\n\t\thits.setQueryTerms(new String[0]);\n\t\thits.setScores(scores.toArray(new Float[scores.size()]));\n\t\thits.setSearchTime(searchTime);\n\t\thits.setSnippets(snippets.toArray(new String[snippets.size()]));\n\t\thits.setStart(startTime);\n\n\t\treturn hits;\n\t}","id":35353,"modified_method":"protected Hits doSearch(SearchContext searchContext, Query query)\n\t\tthrows Exception {\n\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tSession session = getSession();\n\n\t\tRepositoryInfo repositoryInfo = session.getRepositoryInfo();\n\n\t\tRepositoryCapabilities repositoryCapabilities =\n\t\t\trepositoryInfo.getCapabilities();\n\n\t\tQueryConfig queryConfig = searchContext.getQueryConfig();\n\n\t\tCapabilityQuery capabilityQuery =\n\t\t\trepositoryCapabilities.getQueryCapability();\n\n\t\tqueryConfig.setAttribute(\"capabilityQuery\", capabilityQuery.value());\n\n\t\tString productName = repositoryInfo.getProductName();\n\t\tString productVersion = repositoryInfo.getProductVersion();\n\n\t\tqueryConfig.setAttribute(\"repositoryProductName\", productName);\n\t\tqueryConfig.setAttribute(\"repositoryProductVersion\", productVersion);\n\n\t\tString queryString = CMISSearchQueryBuilderUtil.buildQuery(\n\t\t\tsearchContext, query);\n\n\t\tif (_repositoryDetector.isNuxeo5_4()) {\n\t\t\tqueryString +=\n\t\t\t\t\" AND (\" + PropertyIds.IS_LATEST_VERSION + \" = true)\";\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"CMIS search query: \" + queryString);\n\t\t}\n\n\t\tItemIterable<QueryResult> queryResults;\n\t\tif (_repositoryDetector.isNuxeo5_5OrHigher()) {\n\t\t\tqueryResults = session.query(queryString, true);\n\t\t}\n\t\telse {\n\t\t\tqueryResults = session.query(queryString, false);\n\t\t}\n\n\t\tint start = searchContext.getStart();\n\t\tint end = searchContext.getEnd();\n\n\t\tif ((start == QueryUtil.ALL_POS) && (end == QueryUtil.ALL_POS)) {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tint total = 0;\n\n\t\tList<com.liferay.portal.kernel.search.Document> documents =\n\t\t\tnew ArrayList<com.liferay.portal.kernel.search.Document>();\n\t\tList<String> snippets = new ArrayList<String>();\n\t\tList<Float> scores = new ArrayList<Float>();\n\n\t\tfor (QueryResult queryResult : queryResults) {\n\t\t\ttotal++;\n\n\t\t\tif (total <= start) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((total > end) && (end != QueryUtil.ALL_POS)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcom.liferay.portal.kernel.search.Document document =\n\t\t\t\tnew DocumentImpl();\n\n\t\t\tString objectId = queryResult.getPropertyValueByQueryName(\n\t\t\t\tPropertyIds.OBJECT_ID);\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Search result object ID \" + objectId);\n\t\t\t}\n\n\t\t\tFileEntry fileEntry = null;\n\n\t\t\ttry {\n\t\t\t\tfileEntry = toFileEntry(objectId, true);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\tThrowable cause = e.getCause();\n\n\t\t\t\t\tif (cause != null) {\n\t\t\t\t\t\tcause = cause.getCause();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cause instanceof CmisObjectNotFoundException) {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Search result ignored for CMIS document which \" +\n\t\t\t\t\t\t\t\t\"has a version with an invalid object ID \" +\n\t\t\t\t\t\t\t\t\tcause.getMessage());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\t\"Search result ignored for invalid object ID\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ttotal--;\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ENTRY_CLASS_NAME, fileEntry.getModelClassName());\n\t\t\tdocument.addKeyword(\n\t\t\t\tField.ENTRY_CLASS_PK, fileEntry.getFileEntryId());\n\t\t\tdocument.addKeyword(Field.TITLE, fileEntry.getTitle());\n\n\t\t\tdocuments.add(document);\n\n\t\t\tif (queryConfig.isScoreEnabled()) {\n\t\t\t\tObject scoreObj = queryResult.getPropertyValueByQueryName(\n\t\t\t\t\t\"HITS\");\n\n\t\t\t\tif (scoreObj != null) {\n\t\t\t\t\tscores.add(Float.valueOf(scoreObj.toString()));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tscores.add(1.0f);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscores.add(1.0f);\n\t\t\t}\n\n\t\t\tsnippets.add(StringPool.BLANK);\n\t\t}\n\n\t\tfloat searchTime =\n\t\t\t(float)(System.currentTimeMillis() - startTime) / Time.SECOND;\n\n\t\tHits hits = new HitsImpl();\n\n\t\thits.setDocs(\n\t\t\tdocuments.toArray(\n\t\t\t\tnew com.liferay.portal.kernel.search.Document[\n\t\t\t\t\tdocuments.size()]));\n\t\thits.setLength(total);\n\t\thits.setQuery(query);\n\t\thits.setQueryTerms(new String[0]);\n\t\thits.setScores(scores.toArray(new Float[scores.size()]));\n\t\thits.setSearchTime(searchTime);\n\t\thits.setSnippets(snippets.toArray(new String[snippets.size()]));\n\t\thits.setStart(startTime);\n\n\t\treturn hits;\n\t}","commit_id":"03e8e9628fa611d7fdf1a1556ed936bfd9ad5a7d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic FileEntry addFileEntry(\n\t\t\tlong folderId, String sourceFileName, String mimeType, String title,\n\t\t\tString description, String changeLog, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tif (size == 0) {\n\t\t\t\tthrow new FileNameException();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitle = sourceFileName;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tSession session = getSession();\n\n\t\t\tvalidateTitle(session, folderId, title);\n\n\t\t\torg.apache.chemistry.opencmis.client.api.Folder cmisFolder =\n\t\t\t\tgetCmisFolder(session, folderId);\n\n\t\t\tMap<String, Object> properties = new HashMap<String, Object>();\n\n\t\t\tproperties.put(PropertyIds.NAME, title);\n\t\t\tproperties.put(\n\t\t\t\tPropertyIds.OBJECT_TYPE_ID, BaseTypeId.CMIS_DOCUMENT.value());\n\n\t\t\tContentStream contentStream = new ContentStreamImpl(\n\t\t\t\ttitle, BigInteger.valueOf(size), mimeType, is);\n\n\t\t\treturn toFileEntry(\n\t\t\t\tcmisFolder.createDocument(properties, contentStream, null));\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tprocessException(e);\n\n\t\t\tthrow new RepositoryException(e);\n\t\t}\n\t}","id":35354,"modified_method":"@Override\n\tpublic FileEntry addFileEntry(\n\t\t\tlong folderId, String sourceFileName, String mimeType, String title,\n\t\t\tString description, String changeLog, InputStream is, long size,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (Validator.isNull(title)) {\n\t\t\tif (size == 0) {\n\t\t\t\tthrow new FileNameException();\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttitle = sourceFileName;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tSession session = getSession();\n\n\t\t\tvalidateTitle(session, folderId, title);\n\n\t\t\torg.apache.chemistry.opencmis.client.api.Folder cmisFolder =\n\t\t\t\tgetCmisFolder(session, folderId);\n\n\t\t\tMap<String, Object> properties = new HashMap<String, Object>();\n\n\t\t\tproperties.put(PropertyIds.NAME, title);\n\t\t\tproperties.put(\n\t\t\t\tPropertyIds.OBJECT_TYPE_ID, BaseTypeId.CMIS_DOCUMENT.value());\n\n\t\t\tContentStream contentStream = new ContentStreamImpl(\n\t\t\t\ttitle, BigInteger.valueOf(size), mimeType, is);\n\n\t\t\tDocument doc;\n\t\t\tif (_repositoryDetector.isNuxeo5_5OrHigher()) {\n\t\t\t\tdoc = cmisFolder.createDocument(properties, contentStream,\n\t\t\t\t\tVersioningState.NONE);\n\n\t\t\t\tdoc.checkIn(true, Collections.EMPTY_MAP, null, \"\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdoc = cmisFolder.createDocument(properties, contentStream,\n\t\t\t\t\tnull);\n\t\t\t}\n\t\t\treturn toFileEntry(doc);\n\t\t}\n\t\tcatch (PortalException pe) {\n\t\t\tthrow pe;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tprocessException(e);\n\n\t\t\tthrow new RepositoryException(e);\n\t\t}\n\t}","commit_id":"03e8e9628fa611d7fdf1a1556ed936bfd9ad5a7d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * @throws IllegalArgumentException\n\t *             if no resource can be provided for the given input.\n\t */\n\tpublic Resource createResource(IEditorInput editorInput) {\n\t\ttry {\n\t\t\tif (editorInput instanceof IStorageEditorInput) {\n\t\t\t\tIStorage storage = ((IStorageEditorInput) editorInput).getStorage();\n\t\t\t\tResource result = createResource(storage);\n\t\t\t\tif (result != null)\n\t\t\t\t\treturn result;\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\tthrow new WrappedException(e);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Couldn't create EMF Resource for input \" + editorInput);\n\t}","id":35355,"modified_method":"/**\n\t * @throws IllegalArgumentException\n\t *             if no resource can be provided for the given input.\n\t */\n\tpublic Resource createResource(IEditorInput editorInput) {\n\t\ttry {\n\t\t\tif (editorInput instanceof IStorageEditorInput) {\n\t\t\t\tIStorage storage = ((IStorageEditorInput) editorInput).getStorage();\n\t\t\t\tResource result = createResource(storage);\n\t\t\t\tif (result != null)\n\t\t\t\t\treturn result;\n\t\t\t} else if (editorInput instanceof IURIEditorInput) {\n\t\t\t\tResource result = createResource(((IURIEditorInput) editorInput).getURI());\n\t\t\t\tif (result != null)\n\t\t\t\t\treturn result;\n\t\t\t}\n\t\t} catch (CoreException e) {\n\t\t\tthrow new WrappedException(e);\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Couldn't create EMF Resource for input \" + editorInput);\n\t}","commit_id":"c72dab98c1e655e0cd2da76d4f8562b6ae1a16c6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected boolean setDocumentContent(IDocument document, IEditorInput editorInput, String encoding)\n\t\t\tthrows CoreException {\n\t\tboolean result = super.setDocumentContent(document, editorInput, encoding);\n\t\tif (result) {\n\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\t\t\tXtextResource xtextResource = (XtextResource) resourceForEditorInputFactory.createResource(editorInput);\n\t\t\tloadResource(xtextResource, xtextDocument.get(), encoding);\n\t\t\txtextDocument.setInput(xtextResource);\n\t\t}\n\t\treturn result;\n\t}","id":35356,"modified_method":"@Override\n\tprotected boolean setDocumentContent(IDocument document, IEditorInput editorInput, String encoding)\n\t\t\tthrows CoreException {\n\t\tboolean result;\n\t\tif (editorInput instanceof IURIEditorInput) {\n\t\t\tjava.net.URI uri= ((IURIEditorInput) editorInput).getURI();\n\t\t\ttry {\n\t\t\t\tInputStream contentStream = null;\n\t\t\t\ttry {\n\t\t\t\t\tcontentStream = uri.toURL().openStream();\n\t\t\t\t\tsetDocumentContent(document, contentStream, encoding);\n\t\t\t\t} finally {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (contentStream != null)\n\t\t\t\t\t\t\tcontentStream.close();\n\t\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException ex) {\n\t\t\t\tString message= (ex.getMessage() != null ? ex.getMessage() : \"\"); //$NON-NLS-1$\n\t\t\t\tIStatus s= new Status(IStatus.ERROR, PlatformUI.PLUGIN_ID, IStatus.OK, message, ex);\n\t\t\t\tthrow new CoreException(s);\n\t\t\t} \n\t\t\tresult = true;\n\t\t} else {\n\t\t\tresult = super.setDocumentContent(document, editorInput, encoding);\n\t\t}\n\t\tif (result) {\n\t\t\tXtextDocument xtextDocument = (XtextDocument) document;\n\t\t\tXtextResource xtextResource = (XtextResource) resourceForEditorInputFactory.createResource(editorInput);\n\t\t\tloadResource(xtextResource, xtextDocument.get(), encoding);\n\t\t\txtextDocument.setInput(xtextResource);\n\t\t}\n\t\treturn result;\n\t}","commit_id":"c72dab98c1e655e0cd2da76d4f8562b6ae1a16c6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected IDocument createDocument(Object element) throws CoreException {\n\t\tIDocument document = super.createDocument(element);\n\t\tif (document != null) {\n\t\t\tIDocumentPartitioner partitioner = documentPartitioner.get();\n\t\t\tpartitioner.connect(document);\n\t\t\tdocument.setDocumentPartitioner(partitioner);\n\t\t}\n\t\treturn document;\n\t}","id":35357,"modified_method":"@Override\n\tprotected IDocument createDocument(Object element) throws CoreException {\n\t\tIDocument document = null;\n\t\tif (element instanceof IURIEditorInput) {\n\t\t\tdocument= createEmptyDocument();\n\t\t\tif (setDocumentContent(document, (IEditorInput) element, Charset.defaultCharset().name())) {\n\t\t\t\tsetupDocument(element, document);\n\t\t\t}\n\t\t} else {\n\t\t\tdocument = super.createDocument(element);\n\t\t}\n\t\tif (document != null) {\n\t\t\tIDocumentPartitioner partitioner = documentPartitioner.get();\n\t\t\tpartitioner.connect(document);\n\t\t\tdocument.setDocumentPartitioner(partitioner);\n\t\t}\n\t\treturn document;\n\t}","commit_id":"c72dab98c1e655e0cd2da76d4f8562b6ae1a16c6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected ElementInfo createElementInfo(Object element) throws CoreException {\n\t\tElementInfo info = super.createElementInfo(element);\n\t\tXtextDocument doc = (XtextDocument) info.fDocument;\n\t\tif(info.fModel != null) {\n\t\t\tAnnotationIssueProcessor annotationIssueProcessor = new AnnotationIssueProcessor(doc, info.fModel,\n\t\t\t\tissueResolutionProvider);\n\t\t\tValidationJob job = new ValidationJob(resourceValidator, doc, annotationIssueProcessor, CheckMode.FAST_ONLY);\n\t\t\tdoc.setValidationJob(job);\n\t\t}\n\t\treturn info;\n\t}","id":35358,"modified_method":"@Override\n\tprotected ElementInfo createElementInfo(Object element) throws CoreException {\n\t\tElementInfo info;\n\t\tif (element instanceof IURIEditorInput) {\n\t\t\tIDocument document= null;\n\t\t\tIStatus status= null;\n\t\t\ttry {\n\t\t\t\tdocument= createDocument(element);\n\t\t\t} catch (CoreException x) {\n\t\t\t\tstatus= x.getStatus();\n\t\t\t\tdocument= createEmptyDocument();\n\t\t\t}\n\n\t\t\tinfo= new URIInfo(document, createAnnotationModel(element));\n\t\t\tinfo.fStatus= status;\n\t\t} else {\n\t\t\tinfo = super.createElementInfo(element);\n\t\t}\n\t\tXtextDocument doc = (XtextDocument) info.fDocument;\n\t\tif(info.fModel != null) {\n\t\t\tAnnotationIssueProcessor annotationIssueProcessor = new AnnotationIssueProcessor(doc, info.fModel,\n\t\t\t\tissueResolutionProvider);\n\t\t\tValidationJob job = new ValidationJob(resourceValidator, doc, annotationIssueProcessor, CheckMode.FAST_ONLY);\n\t\t\tdoc.setValidationJob(job);\n\t\t}\n\t\treturn info;\n\t}","commit_id":"c72dab98c1e655e0cd2da76d4f8562b6ae1a16c6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic boolean isSynchronized(Object element) {\n\t\tElementInfo info2 = getElementInfo(element);\n\t\tif (info2 instanceof FileInfo) {\n\t\t\tFileInfo info = (FileInfo) getElementInfo(element);\n\t\t\tlong modificationStamp = getModificationStamp(element);\n\t\t\tif (info.fModificationStamp != modificationStamp) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn super.isSynchronized(element);\n\t}","id":35359,"modified_method":"@Override\n\tpublic boolean isSynchronized(Object element) {\n\t\tElementInfo info = getElementInfo(element);\n\t\tif (info instanceof FileInfo) {\n\t\t\tFileInfo fileInfo = (FileInfo) getElementInfo(element);\n\t\t\tlong modificationStamp = getModificationStamp(element);\n\t\t\tif (fileInfo.fModificationStamp != modificationStamp) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn super.isSynchronized(element);\n\t}","commit_id":"c72dab98c1e655e0cd2da76d4f8562b6ae1a16c6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic boolean isDeleted(Object element) {\n\t\tif (element instanceof IFileEditorInput) {\n\t\t\tfinal IFileEditorInput input = (IFileEditorInput) element;\n\n\t\t\tfinal IPath path = input.getFile().getLocation();\n\t\t\tif (path == null) {\n\t\t\t\t// return true;\n\t\t\t\treturn !input.getFile().exists(); // fixed for EFS compatibility\n\t\t\t}\n\t\t\treturn !path.toFile().exists();\n\t\t}\n\t\treturn super.isDeleted(element);\n\t}","id":35360,"modified_method":"@Override\n\tpublic boolean isDeleted(Object element) {\n\t\tif (element instanceof IURIEditorInput) {\n\t\t\tfinal IURIEditorInput input = (IURIEditorInput) element;\n\t\t\tboolean result = !input.exists();\n\t\t\treturn result;\n\t\t}\n\t\tif (element instanceof IFileEditorInput) {\n\t\t\tfinal IFileEditorInput input = (IFileEditorInput) element;\n\n\t\t\tfinal IPath path = input.getFile().getLocation();\n\t\t\tif (path == null) {\n\t\t\t\t// return true;\n\t\t\t\treturn !input.getFile().exists(); // fixed for EFS compatibility\n\t\t\t}\n\t\t\treturn !path.toFile().exists();\n\t\t}\n\t\treturn super.isDeleted(element);\n\t}","commit_id":"c72dab98c1e655e0cd2da76d4f8562b6ae1a16c6","url":"https://github.com/eclipse/xtext"},{"original_method":"public long getFileSize(\n\t\t\tlong companyId, long repositoryId, String fileName)\n\t\tthrows PortalException {\n\n\t\tString versionNumber = getHeadVersionNumber(\n\t\t\tcompanyId, repositoryId, fileName);\n\n\t\tEntry fileEntry = getVersionedFileEntry(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\n\t\tCMISObject cmisObject = fileEntry.getFirstChild(_cmisConstants.OBJECT);\n\n\t\treturn cmisObject.getContentStreamLength();\n\t}","id":35361,"modified_method":"public long getFileSize(\n\t\t\tlong companyId, long repositoryId, String fileName)\n\t\tthrows PortalException {\n\n\t\tString versionNumber = getHeadVersionNumber(\n\t\t\tcompanyId, repositoryId, fileName);\n\n\t\tDocument document = getVersionedDocument(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\n\t\treturn document.getContentStreamLength();\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, String newFileName, boolean reindex)\n\t\tthrows PortalException {\n\n\t\tEntry oldVersioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, repositoryId, fileName, true);\n\t\tEntry newVersioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, repositoryId, newFileName, true);\n\n\t\tList<String> fileNames = CMISUtil.getFolders(oldVersioningFolderEntry);\n\n\t\tfor (String curFileName : fileNames) {\n\t\t\tEntry entry = CMISUtil.getDocument(\n\t\t\t\toldVersioningFolderEntry, curFileName);\n\n\t\t\tInputStream is = CMISUtil.getInputStream(entry);\n\n\t\t\tCMISUtil.createDocument(newVersioningFolderEntry, curFileName, is);\n\t\t}\n\n\t\tCMISUtil.delete(oldVersioningFolderEntry);\n\n\t\tif (reindex) {\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\tfileModel.setCompanyId(companyId);\n\t\t\tfileModel.setFileName(fileName);\n\t\t\tfileModel.setPortletId(portletId);\n\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\tindexer.delete(fileModel);\n\n\t\t\tfileModel.setFileName(newFileName);\n\t\t\tfileModel.setGroupId(groupId);\n\n\t\t\tindexer.reindex(fileModel);\n\t\t}\n\t}","id":35362,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, String newFileName, boolean reindex)\n\t\tthrows PortalException {\n\n\t\tFolder oldVersioningFolderEntry = getVersioningFolder(\n\t\t\tcompanyId, repositoryId, fileName, true);\n\t\tFolder newVersioningFolderEntry = getVersioningFolder(\n\t\t\tcompanyId, repositoryId, newFileName, true);\n\n\t\tList<Folder> folders = getFolders(oldVersioningFolderEntry);\n\n\t\tfor (Folder folder : folders) {\n\t\t\tString curFileName = folder.getName();\n\n\t\t\tDocument document = getDocument(\n\t\t\t\toldVersioningFolderEntry, curFileName);\n\n\t\t\tInputStream is = document.getContentStream().getStream();\n\n\t\t\tcreateDocument(newVersioningFolderEntry, curFileName, is);\n\t\t}\n\n\t\toldVersioningFolderEntry.deleteTree(true, UnfileObject.DELETE, false);\n\n\t\tif (reindex) {\n\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\tfileModel.setCompanyId(companyId);\n\t\t\tfileModel.setFileName(fileName);\n\t\t\tfileModel.setPortletId(portletId);\n\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\tindexer.delete(fileModel);\n\n\t\t\tfileModel.setFileName(newFileName);\n\t\t\tfileModel.setGroupId(groupId);\n\n\t\t\tindexer.reindex(fileModel);\n\t\t}\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber)\n\t\tthrows PortalException {\n\n\t\tif (Validator.isNull(versionNumber)) {\n\t\t\tversionNumber = getHeadVersionNumber(\n\t\t\t\tcompanyId, repositoryId, fileName);\n\t\t}\n\n\t\tEntry fileEntry = getVersionedFileEntry(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\n\t\treturn CMISUtil.getInputStream(fileEntry);\n\t}","id":35363,"modified_method":"public InputStream getFileAsStream(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber)\n\t\tthrows PortalException {\n\n\t\tif (Validator.isNull(versionNumber)) {\n\t\t\tversionNumber = getHeadVersionNumber(\n\t\t\t\tcompanyId, repositoryId, fileName);\n\t\t}\n\n\t\tDocument document = getVersionedDocument(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\n\t\treturn document.getContentStream().getStream();\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException {\n\n\t\tEntry versioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, repositoryId, fileName, false);\n\n\t\tif (versioningFolderEntry == null) {\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\tCMISUtil.delete(versioningFolderEntry);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\tFileModel.class);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setPortletId(portletId);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tindexer.delete(fileModel);\n\t}","id":35364,"modified_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName)\n\t\tthrows PortalException {\n\n\t\tFolder versioningFolder = getVersioningFolder(\n\t\t\tcompanyId, repositoryId, fileName, false);\n\n\t\tif (versioningFolder == null) {\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\tversioningFolder.deleteTree(true, UnfileObject.DELETE, false);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\tFileModel.class);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setPortletId(portletId);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tindexer.delete(fileModel);\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Entry getRepositoryFolderEntry(long companyId, long repositoryId)\n\t\tthrows CMISException {\n\n\t\tEntry companyFolderEntry = getCompanyFolderEntry(companyId);\n\n\t\tLink link = companyFolderEntry.getLink(_cmisConstants.LINK_DESCENDANTS);\n\n\t\tString url = link.getHref().toString();\n\n\t\tString title = String.valueOf(repositoryId);\n\n\t\tEntry repositoryFolderEntry = CMISUtil.getFolder(url, title);\n\n\t\tif (repositoryFolderEntry == null) {\n\t\t\trepositoryFolderEntry = CMISUtil.createFolder(url, title);\n\t\t}\n\n\t\treturn repositoryFolderEntry;\n\t}","id":35365,"modified_method":"protected Folder getRepositoryFolder(long companyId, long repositoryId) {\n\t\tFolder companyFolder = getCompanyFolder(companyId);\n\n\t\tString name = String.valueOf(repositoryId);\n\n\t\tFolder repositoryFolder = getFolder(companyFolder, name);\n\n\t\tif (repositoryFolder == null) {\n\t\t\trepositoryFolder = createFolder(companyFolder, name);\n\t\t}\n\n\t\treturn repositoryFolder;\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tlong newRepositoryId, String fileName, long fileEntryId)\n\t\tthrows PortalException {\n\n\t\tEntry oldVersioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, repositoryId, fileName, true);\n\t\tEntry newVersioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, newRepositoryId, fileName, true);\n\n\t\tList<String> fileNames = CMISUtil.getFolders(oldVersioningFolderEntry);\n\n\t\tfor (String curFileName : fileNames) {\n\t\t\tEntry entry = CMISUtil.getDocument(\n\t\t\t\toldVersioningFolderEntry, curFileName);\n\n\t\t\tInputStream is = CMISUtil.getInputStream(entry);\n\n\t\t\tCMISUtil.createDocument(newVersioningFolderEntry, curFileName, is);\n\t\t}\n\n\t\tCMISUtil.delete(oldVersioningFolderEntry);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setPortletId(portletId);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tindexer.delete(fileModel);\n\n\t\tfileModel.setGroupId(groupId);\n\t\tfileModel.setRepositoryId(newRepositoryId);\n\n\t\tindexer.reindex(fileModel);\n\t}","id":35366,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tlong newRepositoryId, String fileName, long fileEntryId)\n\t\tthrows PortalException {\n\n\t\tFolder oldVersioningFolderEntry = getVersioningFolder(\n\t\t\tcompanyId, repositoryId, fileName, true);\n\t\tFolder newVersioningFolderEntry = getVersioningFolder(\n\t\t\tcompanyId, newRepositoryId, fileName, true);\n\n\t\tList<Folder> folders = getFolders(oldVersioningFolderEntry);\n\n\t\tfor (Folder folder : folders) {\n\t\t\tString curFileName = folder.getName();\n\n\t\t\tDocument document = getDocument(\n\t\t\t\toldVersioningFolderEntry, curFileName);\n\n\t\t\tInputStream is = document.getContentStream().getStream();\n\n\t\t\tcreateDocument(newVersioningFolderEntry, curFileName, is);\n\t\t}\n\n\t\toldVersioningFolderEntry.deleteTree(true, UnfileObject.DELETE, false);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setPortletId(portletId);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tindexer.delete(fileModel);\n\n\t\tfileModel.setGroupId(groupId);\n\t\tfileModel.setRepositoryId(newRepositoryId);\n\n\t\tindexer.reindex(fileModel);\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String[] getFileNames(\n\t\t\tlong companyId, long repositoryId, String dirName)\n\t\tthrows PortalException {\n\n\t\tEntry repositoryFolderEntry = getRepositoryFolderEntry(\n\t\t\tcompanyId, repositoryId);\n\n\t\tString[] dirNames = StringUtil.split(dirName, StringPool.SLASH);\n\n\t\tfor (String curDirName : dirNames) {\n\t\t\tLink link = repositoryFolderEntry.getLink(\n\t\t\t\t_cmisConstants.LINK_DESCENDANTS);\n\n\t\t\tString url = link.getHref().toString();\n\n\t\t\trepositoryFolderEntry = CMISUtil.getFolder(url, curDirName);\n\t\t}\n\n\t\tList<String> fileNames = CMISUtil.getFolders(repositoryFolderEntry);\n\n\t\tfor (int i = 0 ; i < fileNames.size(); i++) {\n\t\t\tString fileName = fileNames.get(i);\n\n\t\t\tfileNames.set(i, dirName.concat(StringPool.SLASH).concat(fileName));\n\t\t}\n\n\t\treturn fileNames.toArray(new String[fileNames.size()]);\n\t}","id":35367,"modified_method":"public String[] getFileNames(\n\t\t\tlong companyId, long repositoryId, String dirName)\n\t\tthrows PortalException {\n\n\t\tFolder folder = getRepositoryFolder(companyId, repositoryId);\n\n\t\tString[] dirNames = StringUtil.split(dirName, StringPool.SLASH);\n\n\t\tfor (String curDirName : dirNames) {\n\t\t\tFolder subFolder = getFolder(folder, curDirName);\n\n\t\t\tif (subFolder == null) {\n\t\t\t\tsubFolder = createFolder(folder, curDirName);\n\t\t\t}\n\n\t\t\tfolder = subFolder;\n\t\t}\n\n\t\tList<Folder> folders = getFolders(folder);\n\n\t\tString [] fileNames = new String[folders.size()];\n\n\t\tfor (int i = 0; i < folders.size(); i++) {\n\t\t\tString fileName = folders.get(i).getName();\n\n\t\t\tfileNames[i] = dirName.concat(StringPool.SLASH).concat(fileName);\n\t\t}\n\n\t\treturn fileNames;\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteDirectory(\n\t\t\tlong companyId, String portletId, long repositoryId, String dirName)\n\t\tthrows PortalException {\n\n\t\tEntry repositoryFolderEntry = getRepositoryFolderEntry(\n\t\t\tcompanyId, repositoryId);\n\n\t\tEntry directory = CMISUtil.getFolder(repositoryFolderEntry, dirName);\n\n\t\tif (directory != null) {\n\t\t\tCMISUtil.delete(directory);\n\t\t}\n\t}","id":35368,"modified_method":"public void deleteDirectory(\n\t\t\tlong companyId, String portletId, long repositoryId, String dirName)\n\t\tthrows PortalException {\n\n\t\tFolder repositoryFolder = getRepositoryFolder(companyId, repositoryId);\n\n\t\tFolder directory = getFolder(repositoryFolder, dirName);\n\n\t\tif (directory != null) {\n\t\t\tdirectory.deleteTree(true, UnfileObject.DELETE, false);\n\t\t}\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Entry getCompanyFolderEntry(long companyId) throws CMISException {\n\t\tString title = String.valueOf(companyId);\n\n\t\tEntry companyFolderEntry = CMISUtil.getFolder(title);\n\n\t\tif (companyFolderEntry == null) {\n\t\t\tcompanyFolderEntry = CMISUtil.createFolder(title);\n\t\t}\n\n\t\treturn companyFolderEntry;\n\t}","id":35369,"modified_method":"protected Folder getCompanyFolder(long companyId) {\n\t\tString name = String.valueOf(companyId);\n\n\t\tFolder companyFolder = getFolder(_systemRootDir, name);\n\n\t\tif (companyFolder == null) {\n\t\t\tcompanyFolder = createFolder(_systemRootDir, name);\n\t\t}\n\n\t\treturn companyFolder;\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, String versionNumber, String sourceFileName,\n\t\t\tlong fileEntryId, String properties, Date modifiedDate,\n\t\t\tServiceContext serviceContext, InputStream is)\n\t\tthrows PortalException {\n\n\t\tEntry versioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, repositoryId, fileName, true);\n\n\t\tLink link = versioningFolderEntry.getLink(\n\t\t\t_cmisConstants.LINK_DESCENDANTS);\n\n\t\tString url = link.getHref().toString();\n\n\t\tString title = String.valueOf(versionNumber);\n\n\t\tEntry fileEntry = CMISUtil.getEntry(\n\t\t\turl, title, _cmisConstants.BASE_TYPE_DOCUMENT);\n\n\t\tif (fileEntry != null) {\n\t\t\tthrow new DuplicateFileException();\n\t\t}\n\n\t\tfileEntry = CMISUtil.createDocument(url, title, is);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setAssetCategoryIds(serviceContext.getAssetCategoryIds());\n\t\tfileModel.setAssetTagNames(serviceContext.getAssetTagNames());\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileEntryId(fileEntryId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setGroupId(groupId);\n\t\tfileModel.setModifiedDate(modifiedDate);\n\t\tfileModel.setPortletId(portletId);\n\t\tfileModel.setProperties(properties);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tindexer.reindex(fileModel);\n\t}","id":35370,"modified_method":"public void updateFile(\n\t\t\tlong companyId, String portletId, long groupId, long repositoryId,\n\t\t\tString fileName, String versionNumber, String sourceFileName,\n\t\t\tlong fileEntryId, String properties, Date modifiedDate,\n\t\t\tServiceContext serviceContext, InputStream is)\n\t\tthrows PortalException {\n\n\t\tFolder versioningFolder = getVersioningFolder(\n\t\t\tcompanyId, repositoryId, fileName, true);\n\n\t\tString title = String.valueOf(versionNumber);\n\n\t\tDocument document = getDocument(versioningFolder, title);\n\n\t\tif (document != null) {\n\t\t\tthrow new DuplicateFileException();\n\t\t}\n\n\t\tcreateDocument(versioningFolder, title, is, serviceContext);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(FileModel.class);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setAssetCategoryIds(serviceContext.getAssetCategoryIds());\n\t\tfileModel.setAssetTagNames(serviceContext.getAssetTagNames());\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileEntryId(fileEntryId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setGroupId(groupId);\n\t\tfileModel.setModifiedDate(modifiedDate);\n\t\tfileModel.setPortletId(portletId);\n\t\tfileModel.setProperties(properties);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tindexer.reindex(fileModel);\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addDirectory(long companyId, long repositoryId, String dirName)\n\t\tthrows PortalException {\n\n\t\tEntry repositoryFolderEntry = getRepositoryFolderEntry(\n\t\t\tcompanyId, repositoryId);\n\n\t\tString[] dirNames = StringUtil.split(dirName, StringPool.SLASH);\n\n\t\tfor (String curDirName : dirNames) {\n\t\t\tLink link = repositoryFolderEntry.getLink(\n\t\t\t\t_cmisConstants.LINK_DESCENDANTS);\n\n\t\t\tString url = link.getHref().toString();\n\n\t\t\trepositoryFolderEntry = CMISUtil.getFolder(url, curDirName);\n\n\t\t\tif (repositoryFolderEntry == null) {\n\t\t\t\trepositoryFolderEntry = CMISUtil.createFolder(url, curDirName);\n\t\t\t}\n\t\t}\n\t}","id":35371,"modified_method":"public void addDirectory(long companyId, long repositoryId, String dirName)\n\t\tthrows PortalException {\n\n\t\tFolder folder = getRepositoryFolder(companyId, repositoryId);\n\n\t\tString[] dirNames = StringUtil.split(dirName, StringPool.SLASH);\n\n\t\tfor (String curDirName : dirNames) {\n\t\t\tFolder subFolder = getFolder(folder, curDirName);\n\n\t\t\tif (subFolder == null) {\n\t\t\t\tsubFolder = createFolder(folder, curDirName);\n\t\t\t}\n\n\t\t\tfolder = subFolder;\n\t\t}\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void reindex(String[] ids) throws SearchException {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\t\tString portletId = ids[1];\n\t\tlong groupId = GetterUtil.getLong(ids[2]);\n\t\tlong repositoryId = GetterUtil.getLong(ids[3]);\n\n\t\tCollection<Document> documents = new ArrayList<Document>();\n\n\t\ttry {\n\t\t\tEntry repositoryFolderEntry = getRepositoryFolderEntry(\n\t\t\t\tcompanyId, repositoryId);\n\n\t\t\tList<String> fileNames = CMISUtil.getFolders(repositoryFolderEntry);\n\n\t\t\tfor (String fileName : fileNames) {\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileModel.class);\n\n\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\tfileModel.setFileName(fileName);\n\t\t\t\tfileModel.setGroupId(groupId);\n\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\tDocument document = indexer.getDocument(fileModel);\n\n\t\t\t\tif (document == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdocuments.add(document);\n\t\t\t}\n\t\t}\n\t\tcatch (CMISException cmise) {\n\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t_log.error(cmise, cmise);\n\t\t\t}\n\t\t}\n\n\t\tSearchEngineUtil.updateDocuments(companyId, documents);\n\t}","id":35372,"modified_method":"public void reindex(String[] ids) throws SearchException {\n\t\tlong companyId = GetterUtil.getLong(ids[0]);\n\t\tString portletId = ids[1];\n\t\tlong groupId = GetterUtil.getLong(ids[2]);\n\t\tlong repositoryId = GetterUtil.getLong(ids[3]);\n\n\t\tCollection<com.liferay.portal.kernel.search.Document> documents =\n\t\t\tnew ArrayList<com.liferay.portal.kernel.search.Document>();\n\n\t\ttry {\n\t\t\tFolder repositoryFolderEntry = getRepositoryFolder(\n\t\t\t\tcompanyId, repositoryId);\n\n\t\t\tList<Folder> folders = getFolders(repositoryFolderEntry);\n\n\t\t\tfor (Folder folder : folders) {\n\t\t\t\tString fileName = folder.getName();\n\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tFileModel.class);\n\n\t\t\t\tFileModel fileModel = new FileModel();\n\n\t\t\t\tfileModel.setCompanyId(companyId);\n\t\t\t\tfileModel.setFileName(fileName);\n\t\t\t\tfileModel.setGroupId(groupId);\n\t\t\t\tfileModel.setPortletId(portletId);\n\t\t\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\t\t\tcom.liferay.portal.kernel.search.Document document =\n\t\t\t\t\tindexer.getDocument(fileModel);\n\n\t\t\t\tif (document == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdocuments.add(document);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\n\t\tSearchEngineUtil.updateDocuments(companyId, documents);\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getHeadVersionNumber(\n\t\t\tlong companyId, long repositoryId, String dirName)\n\t\tthrows CMISException, NoSuchFileException {\n\n\t\tEntry versioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, repositoryId, dirName, false);\n\n\t\tif (versioningFolderEntry == null) {\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\tList<String> versionNumbers = CMISUtil.getFolders(\n\t\t\tversioningFolderEntry);\n\n\t\tString headVersionNumber = DEFAULT_VERSION;\n\n\t\tfor (String versionNumber : versionNumbers) {\n\t\t\tif (DLUtil.compareVersions(versionNumber, headVersionNumber) > 0) {\n\t\t\t\theadVersionNumber = versionNumber;\n\t\t\t}\n\t\t}\n\n\t\treturn headVersionNumber;\n\t}","id":35373,"modified_method":"public String getHeadVersionNumber(\n\t\t\tlong companyId, long repositoryId, String dirName)\n\t\tthrows NoSuchFileException {\n\n\t\tFolder versioningFolder = getVersioningFolder(\n\t\t\tcompanyId, repositoryId, dirName, false);\n\n\t\tif (versioningFolder == null) {\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\tList<Folder> folders = getFolders(versioningFolder);\n\n\t\tString headVersionNumber = DEFAULT_VERSION;\n\n\t\tfor (Folder folder : folders) {\n\t\t\tString versionNumber = folder.getName();\n\n\t\t\tif (DLUtil.compareVersions(versionNumber, headVersionNumber) > 0) {\n\t\t\t\theadVersionNumber = versionNumber;\n\t\t\t}\n\t\t}\n\n\t\treturn headVersionNumber;\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public CMISHook() {\n\t\ttry {\n\t\t\tString version = CMISUtil.verifyRepository();\n\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\"CMIS Service is running version \" + version);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\t}","id":35374,"modified_method":"public CMISHook() {\n\t\t_systemRootDir = getFolder(\n\t\t\t_session.getRootFolder(), PropsValues.DL_HOOK_CMIS_SYSTEM_ROOT_DIR);\n\n\t\tif (_systemRootDir == null) {\n\t\t\t_systemRootDir = createFolder(\n\t\t\t\t_session.getRootFolder(),\n\t\t\t\tPropsValues.DL_HOOK_CMIS_SYSTEM_ROOT_DIR);\n\t\t}\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Entry getVersioningFolderEntry(\n\t\t\tlong companyId, long repositoryId, String fileName, boolean create)\n\t\tthrows CMISException {\n\n\t\tEntry repositoryFolderEntry = getRepositoryFolderEntry(\n\t\t\tcompanyId, repositoryId);\n\n\t\tEntry versioningFolderEntry = repositoryFolderEntry;\n\n\t\tString[] dirNames = StringUtil.split(fileName, StringPool.SLASH);\n\n\t\tfor (String dirName : dirNames) {\n\t\t\tLink link = versioningFolderEntry.getLink(\n\t\t\t\t_cmisConstants.LINK_DESCENDANTS);\n\n\t\t\tString url = link.getHref().toString();\n\n\t\t\tversioningFolderEntry = CMISUtil.getFolder(url, dirName);\n\n\t\t\tif (create && (versioningFolderEntry == null)) {\n\t\t\t\tversioningFolderEntry = CMISUtil.createFolder(url, dirName);\n\t\t\t}\n\t\t}\n\n\t\treturn versioningFolderEntry;\n\t}","id":35375,"modified_method":"protected Folder getVersioningFolder(\n\t\tlong companyId, long repositoryId, String fileName, boolean create) {\n\n\t\tFolder repositoryFolder = getRepositoryFolder(companyId, repositoryId);\n\n\t\tFolder versioningFolder = repositoryFolder;\n\n\t\tString[] dirNames = StringUtil.split(fileName, StringPool.SLASH);\n\n\t\tfor (String dirName : dirNames) {\n\t\t\tFolder subFolder = getFolder(versioningFolder, dirName);\n\n\t\t\tif (create && (subFolder == null)) {\n\t\t\t\tsubFolder = createFolder(versioningFolder, dirName);\n\t\t\t}\n\n\t\t\tversioningFolder = subFolder;\n\t\t}\n\n\t\treturn versioningFolder;\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Entry getVersionedFileEntry(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber)\n\t\tthrows CMISException, NoSuchFileException {\n\n\t\tEntry versioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, repositoryId, fileName, false);\n\n\t\tif (versioningFolderEntry == null) {\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\tLink link = versioningFolderEntry.getLink(\n\t\t\t_cmisConstants.LINK_DESCENDANTS);\n\n\t\tString url = link.getHref().toString();\n\n\t\tEntry fileEntry = CMISUtil.getEntry(\n\t\t\turl, String.valueOf(versionNumber),\n\t\t\t_cmisConstants.BASE_TYPE_DOCUMENT);\n\n\t\tif (fileEntry == null) {\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":35376,"modified_method":"protected Document getVersionedDocument(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber)\n\t\tthrows NoSuchFileException {\n\n\t\tFolder versioningFolder = getVersioningFolder(\n\t\t\tcompanyId, repositoryId, fileName, false);\n\n\t\tif (versioningFolder == null) {\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\tDocument document = getDocument(versioningFolder, versionNumber);\n\n\t\tif (document == null) {\n\t\t\tthrow new NoSuchFileException();\n\t\t}\n\n\t\treturn document;\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName, String versionNumber)\n\t\tthrows PortalException {\n\n\t\tEntry fileEntry = getVersionedFileEntry(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\n\t\tCMISUtil.delete(fileEntry);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\tFileModel.class);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setPortletId(portletId);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tindexer.delete(fileModel);\n\t}","id":35377,"modified_method":"public void deleteFile(\n\t\t\tlong companyId, String portletId, long repositoryId,\n\t\t\tString fileName, String versionNumber)\n\t\tthrows PortalException {\n\n\t\tDocument document = getVersionedDocument(\n\t\t\tcompanyId, repositoryId, fileName, versionNumber);\n\n\t\tdocument.delete(true);\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\tFileModel.class);\n\n\t\tFileModel fileModel = new FileModel();\n\n\t\tfileModel.setCompanyId(companyId);\n\t\tfileModel.setFileName(fileName);\n\t\tfileModel.setPortletId(portletId);\n\t\tfileModel.setRepositoryId(repositoryId);\n\n\t\tindexer.delete(fileModel);\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public boolean hasFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber)\n\t\tthrows PortalException {\n\n\t\tEntry versioningFolderEntry = getVersioningFolderEntry(\n\t\t\tcompanyId, repositoryId, fileName, true);\n\n\t\tLink link = versioningFolderEntry.getLink(\n\t\t\t_cmisConstants.LINK_DESCENDANTS);\n\n\t\tString url = link.getHref().toString();\n\n\t\tEntry fileEntry = CMISUtil.getEntry(\n\t\t\turl, versionNumber, _cmisConstants.BASE_TYPE_DOCUMENT);\n\n\t\tif (fileEntry == null) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}","id":35378,"modified_method":"public boolean hasFile(\n\t\t\tlong companyId, long repositoryId, String fileName,\n\t\t\tString versionNumber)\n\t\tthrows PortalException {\n\n\t\tFolder versioningFolder = getVersioningFolder(\n\t\t\tcompanyId, repositoryId, fileName, true);\n\n\t\tDocument document = getDocument(versioningFolder, versionNumber);\n\n\t\tif (document == null) {\n\t\t\treturn false;\n\t\t}\n\t\telse {\n\t\t\treturn true;\n\t\t}\n\t}","commit_id":"4889a5c53dff57806f11cc32feeb719e742ba10b","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private URL getXmlUrl(String xmlName) throws MalformedURLException {\n        // user.dir will point to the root of this module\n        File f = new File(System.getProperty(\"user.dir\"));\n        f = new File(f, \"../../build/target\");\n        File[] children = f.listFiles(); f = null;\n        if (children != null)\n            for (File child : children)\n                if (child.getName().startsWith(\"jboss-\"))\n                    f = child;\n\n        if (f == null)\n            Assert.fail(\"Server not built\");\n\n        f = new File(f, xmlName);\n        return f.toURI().toURL();\n    }","id":35379,"modified_method":"private File getXmlFile(String xmlName) throws MalformedURLException {\n        if (baseDir() == null)\n            Assert.fail(\"Server not built\");\n\n        return new File(baseDir(), xmlName);\n    }","commit_id":"4cc31912b243385752230f6ae541f0f4403b9e46","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void parseXml(String xmlName) throws ParserConfigurationException, SAXException, IOException {\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        if (!factory.isNamespaceAware())\n            factory.setNamespaceAware(true);\n        if (!factory.isValidating())\n            factory.setValidating(true);\n        if (!factory.isXIncludeAware())\n            factory.setXIncludeAware(true);\n\n        SAXParser parser = factory.newSAXParser();\n        XMLReader reader = parser.getXMLReader();\n        reader.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n        reader.setErrorHandler(new ErrorHandlerImpl());\n        reader.setEntityResolver(new EntityResolver() {\n            @Override\n            public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n                if (systemId == null)\n                    Assert.fail(\"Failed to resolve schema: systemId is null\");\n                int lastSlash = systemId.lastIndexOf('/');\n                if (lastSlash > 0)\n                    systemId = systemId.substring(lastSlash + 1);\n                URL xsdUrl = getXsdUrl(systemId);\n                return new InputSource(xsdUrl.openStream());\n            }\n        });\n        URL xmlUrl = getXmlUrl(xmlName);\n        InputSource is = new InputSource();\n        is.setByteStream(xmlUrl.openStream());\n        reader.parse(is);\n    }","id":35380,"modified_method":"private void parseXml(String xmlName) throws ParserConfigurationException, SAXException, IOException {\n        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        schemaFactory.setErrorHandler(new ErrorHandlerImpl());\n        schemaFactory.setResourceResolver(DEFAULT_RESOURCE_RESOLVER);\n        Schema schema = schemaFactory.newSchema(SCHEMAS);\n        Validator validator = schema.newValidator();\n        validator.setFeature(\"http://apache.org/xml/features/validation/schema\", true);\n        validator.setResourceResolver(DEFAULT_RESOURCE_RESOLVER);\n        validator.validate(new StreamSource(getXmlFile(xmlName)));\n    }","commit_id":"4cc31912b243385752230f6ae541f0f4403b9e46","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void validateXsd(String xsdName) throws Exception {\n        URL jbossDomain = getXsdUrl(xsdName);\n\n        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        schemaFactory.setErrorHandler(new ErrorHandlerImpl());\n        schemaFactory.setResourceResolver(new LSResourceResolver() {\n            public LSInput resolveResource(String type, String namespaceURI, String publicId, String systemId, String baseURI) {\n                LSInput input = new DOMInputImpl();\n\n                final URL url;\n                if (NAMESPACE_MAP.containsKey(systemId)) {\n                    url = XsdUtil.discover(NAMESPACE_MAP.get(systemId));\n                } else {\n                    url = XsdUtil.discover(systemId);\n                }\n                try {\n                    input.setByteStream(url.openStream());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n\n                return input;\n            }\n        });\n        schemaFactory.newSchema(jbossDomain);\n    }","id":35381,"modified_method":"private void validateXsd(final File xsdFile) throws Exception {\n        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        schemaFactory.setErrorHandler(new ErrorHandlerImpl());\n        schemaFactory.setResourceResolver(DEFAULT_RESOURCE_RESOLVER);\n        schemaFactory.newSchema(xsdFile.toURI().toURL());\n    }","commit_id":"4cc31912b243385752230f6ae541f0f4403b9e46","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testJBossThreads() throws Exception {\n        validateXsd(\"jboss-threads.xsd\");\n    }","id":35382,"modified_method":"@Test\n    public void testJBossXsds() throws Exception {\n        for (File xsdFile : jbossSchemaFiles())\n            validateXsd(xsdFile);\n    }","commit_id":"4cc31912b243385752230f6ae541f0f4403b9e46","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Writes the xml contents into an output stream.<p>\n     * \n     * @param out the output stream to write to\n     * @param encoding the encoding to use\n     * @return the output stream with the xml content\n     * @throws CmsXmlPageException if something goes wrong\n     */\n    public OutputStream write(OutputStream out, String encoding) throws CmsXmlPageException {        \n        try {\n            OutputFormat format = OutputFormat.createPrettyPrint();\n            format.setEncoding(encoding);\n            \n            XMLWriter writer = new XMLWriter(out, format);\n            writer.setEscapeText(false);\n            writer.write(m_document);\n            writer.close();\n            \n        } catch (Exception exc) {\n            throw new CmsXmlPageException(\"Writing xml page failed\", exc);\n        }\n        \n        return out;\n    }","id":35383,"modified_method":"/**\n     * Writes the xml contents into an output stream.<p>\n     * \n     * @param out the output stream to write to\n     * @param encoding the encoding to use\n     * @return the output stream with the xml content\n     * @throws CmsXmlPageException if something goes wrong\n     */\n    public OutputStream write(OutputStream out, String encoding) throws CmsXmlPageException {        \n        try {\n            OutputFormat format = OutputFormat.createPrettyPrint();\n            format.setEncoding(encoding);\n            \n            XMLWriter writer = new XMLWriter(out, format);\n            writer.setEscapeText(false);\n            \n            // ensure xml page has proper system doc type set\n            DocumentType type = m_document.getDocType();\n            if (type != null) {\n                String systemId = type.getSystemID();\n                if ((systemId != null) && systemId.endsWith(CmsXmlPageEntityResolver.C_XMLPAGE_DTD_OLD_SYSTEM_ID)) {\n                    m_document.addDocType(C_DOCUMENT_NODE, \"\", C_XMLPAGE_DTD_SYSTEM_ID);\n                }\n            }\n            \n            writer.write(m_document);\n            writer.close();\n            \n        } catch (Exception exc) {\n            throw new CmsXmlPageException(\"Writing xml page failed\", exc);\n        }\n        \n        return out;\n    }","commit_id":"b25645390aea68c1257121e0d7b185eae2c67e4d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Validated if the xml structure of the xmlpage does match the dtd.<p>\n     * \n     * This is nescessary, as someone could have edited the xml controlcode of the page and\n     * modified the xml structure there.\n     * \n     * @throws CmsXmlPageException if the validation fails\n     */\n    public void validateXmlStructure() throws CmsXmlPageException  {\n\n        // Modifiy the path to the dtd. The xmlpage only contains the relative path to the\n        // dtd inside of opencms. To validate the xmlstructure, the complete path is required.\n         \n        CmsSiteMatcher workplace = OpenCms.getSiteManager().getWorkplaceSiteMatcher();                \n        CmsSystemInfo systemInfo = OpenCms.getSystemInfo();\n        String path = workplace.getUrl() + systemInfo.getOpenCmsContext();          \n     \n        m_document.addDocType(C_DOCUMENT_NODE, \"\", path+C_DOCUMENT_TYPE);\n        \n        // create a new validator and validate the xml structure\n        SAXValidator validator = new SAXValidator();\n        validator.setErrorHandler(new CmsXmlPageValidationErrorHandler());\n        try {\n            // validate the document\n            validator.validate(m_document);                        \n        } catch (SAXException e) {\n            // there was an validation error, so throw an exception\n            throw new CmsXmlPageException(\"XML validation error \" +e.getMessage());\n        } finally {\n           // clean up some memory\n           validator = null;\n        }           \n    }","id":35384,"modified_method":"/**\n     * Validates the xml structure of the page with the xmlpage dtd.<p>\n     * \n     * This is required in case someone modifies the xml structure of a  \n     * xmlpage file using the \"edit control code\" option.<p>\n     * \n     * @throws CmsXmlPageException if the validation fails\n     */\n    public void validateXmlStructure() throws CmsXmlPageException  {\n\n        // create a new validator and validate the xml structure\n        SAXValidator validator = new SAXValidator();\n        try {\n            // set the OpenCms xml validation error handler \n            validator.setErrorHandler(new CmsXmlPageValidationErrorHandler());\n            // set the xmlpage entitiy resolver for the validation XML reader\n            validator.getXMLReader().setEntityResolver(m_resolver);\n            // validate the document\n            validator.validate(m_document);                        \n        } catch (SAXException e) {\n            // there was an validation error, so throw an exception\n            throw new CmsXmlPageException(\"XML validation error \" + e.getMessage(), CmsException.C_XML_CORRUPT_INTERNAL_STRUCTURE);\n        } finally {\n           // clean up some memory\n           validator = null;\n        }           \n    }","commit_id":"b25645390aea68c1257121e0d7b185eae2c67e4d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Initializes the internal document object.<p>\n     */\n    protected void initDocument() {        \n        m_document = DocumentHelper.createDocument(DocumentHelper.createElement(C_DOCUMENT_NODE));\n        m_document.addDocType(C_DOCUMENT_NODE, \"\", C_DOCUMENT_TYPE);\n        m_document.getRootElement().addElement(C_NODE_ELEMENTS);\n    }","id":35385,"modified_method":"/**\n     * Initializes the internal document object.<p>\n     */\n    protected void initDocument() {        \n        m_document = DocumentHelper.createDocument(DocumentHelper.createElement(C_DOCUMENT_NODE));\n        m_document.addDocType(C_DOCUMENT_NODE, \"\", C_XMLPAGE_DTD_SYSTEM_ID);\n        m_document.getRootElement().addElement(C_NODE_ELEMENTS);\n    }","commit_id":"b25645390aea68c1257121e0d7b185eae2c67e4d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Reads the xml contents of a file into the page.<p>\n     * \n     * @param cms the current cms object\n     * @param file the file with xml data\n     * @return the concrete PageObject instanciated with the xml data\n     * @throws CmsXmlPageException if something goes wrong\n     */\n    public static CmsXmlPage read(CmsObject cms, CmsFile file) throws CmsXmlPageException {\n\n        CmsXmlPage newPage = null;\n        \n        byte[] content = file.getContents();\n\n        String allowRelative;\n        try {\n            allowRelative = cms.readPropertyObject(cms.readAbsolutePath(file), C_PROPERTY_ALLOW_RELATIVE, false).getValue(\"false\");\n        } catch (CmsException e) {\n            allowRelative = \"false\";\n        }\n        \n        String encoding;\n        try { \n            encoding = cms.readPropertyObject(cms.readAbsolutePath(file), I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, true).getValue(OpenCms.getSystemInfo().getDefaultEncoding());\n        } catch (CmsException e) {\n            encoding = OpenCms.getSystemInfo().getDefaultEncoding();\n        }        \n        \n        if (content.length > 0) {\n            // content is initialized\n            \n            String xmlData;\n            try {\n                xmlData = new String(content, encoding);\n            } catch (UnsupportedEncodingException e) {\n                try {\n                    xmlData = new String(content, OpenCms.getSystemInfo().getDefaultEncoding());\n                }  catch (UnsupportedEncodingException e2) {\n                    xmlData = new String();\n                }\n            }            \n            newPage = read(cms, xmlData);\n            \n        } else {\n            // content is empty\n            newPage = new CmsXmlPage(encoding);\n        }\n        \n        newPage.m_file = file;\n        newPage.m_encoding = encoding;\n        newPage.m_allowRelativeLinks = Boolean.valueOf(allowRelative).booleanValue();\n        \n        return newPage;\n    }","id":35386,"modified_method":"/**\n     * Reads the xml contents of a file into the page.<p>\n     * \n     * @param cms the current cms object\n     * @param file the file with xml data\n     * @return the concrete PageObject instanciated with the xml data\n     * @throws CmsXmlPageException if something goes wrong\n     */\n    public static CmsXmlPage read(CmsObject cms, CmsFile file) throws CmsXmlPageException {\n\n        CmsXmlPage newPage = null;\n        \n        byte[] content = file.getContents();\n\n        String allowRelative;\n        try {\n            allowRelative = cms.readPropertyObject(cms.readAbsolutePath(file), C_PROPERTY_ALLOW_RELATIVE, false).getValue(\"false\");\n        } catch (CmsException e) {\n            allowRelative = \"false\";\n        }\n        \n        String encoding;\n        try { \n            encoding = cms.readPropertyObject(cms.readAbsolutePath(file), I_CmsConstants.C_PROPERTY_CONTENT_ENCODING, true).getValue(OpenCms.getSystemInfo().getDefaultEncoding());\n        } catch (CmsException e) {\n            encoding = OpenCms.getSystemInfo().getDefaultEncoding();\n        }        \n        \n        if (content.length > 0) {\n            // content is initialized\n            \n            String xmlData;\n            try {\n                xmlData = new String(content, encoding);\n            } catch (UnsupportedEncodingException e) {\n                try {\n                    xmlData = new String(content, OpenCms.getSystemInfo().getDefaultEncoding());\n                }  catch (UnsupportedEncodingException e2) {\n                    xmlData = new String();\n                }\n            }            \n            newPage = read(xmlData);\n            \n        } else {\n            // content is empty\n            newPage = new CmsXmlPage(encoding);\n        }\n        \n        newPage.m_file = file;\n        newPage.m_encoding = encoding;\n        newPage.m_allowRelativeLinks = Boolean.valueOf(allowRelative).booleanValue();\n        \n        return newPage;\n    }","commit_id":"b25645390aea68c1257121e0d7b185eae2c67e4d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Reads the xml contents from a string into the page.<p>\n     * \n     * @param cms the current cms object\n     * @param xmlData the xml data\n     * @return the page initialized with the given xml data\n     * @throws CmsXmlPageException if something goes wrong\n     */\n    public static CmsXmlPage read(CmsObject cms, String xmlData) throws CmsXmlPageException {        \n        try {\n            SAXReader reader = new SAXReader();\n            reader.setEntityResolver(new CmsEntityResolver(cms));\n            Document document = reader.read(new StringReader(xmlData));            \n            return new CmsXmlPage(document);\n        } catch (DocumentException e) {\n            throw new CmsXmlPageException(\"Reading xml page from a String failed: \" + e.getMessage(), e);\n        }\n    }","id":35387,"modified_method":"/**\n     * Reads the xml contents from a string into the page.<p>\n     * \n     * @param xmlData the xml data in a String \n     * @return the page initialized with the given xml data\n     * @throws CmsXmlPageException if something goes wrong\n     */\n    public static CmsXmlPage read(String xmlData) throws CmsXmlPageException {        \n        try {\n            SAXReader reader = new SAXReader();\n            reader.setEntityResolver(m_resolver);\n            Document document = reader.read(new StringReader(xmlData));            \n            return new CmsXmlPage(document);\n        } catch (DocumentException e) {\n            throw new CmsXmlPageException(\"Reading xml page from a String failed: \" + e.getMessage(), e);\n        }\n    }","commit_id":"b25645390aea68c1257121e0d7b185eae2c67e4d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.xml.sax.ErrorHandler#fatalError(org.xml.sax.SAXParseException)\n     */\n    public void fatalError(SAXParseException arg0) throws SAXException {  \n         throw new SAXException(\"[FatalError] \"  + arg0.getMessage().replaceAll(\"\\\"\", \"'\"));\n    }","id":35388,"modified_method":"/**\n     * @see org.xml.sax.ErrorHandler#fatalError(org.xml.sax.SAXParseException)\n     */\n    public void fatalError(SAXParseException exception) throws SAXException {\n\n        OpenCms.getLog(this).error(\"Fatel error parsing xmlPage resource\", exception);\n        throw exception;\n    }","commit_id":"b25645390aea68c1257121e0d7b185eae2c67e4d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)\n     */\n    public void error(SAXParseException arg0) throws SAXException {\n        throw new SAXException(\"[Error] \"+ arg0.getMessage().replaceAll(\"\\\"\", \"'\"));\n    }","id":35389,"modified_method":"/**\n     * @see org.xml.sax.ErrorHandler#error(org.xml.sax.SAXParseException)\n     */\n    public void error(SAXParseException exception) throws SAXException {\n\n        OpenCms.getLog(this).error(\"Error parsing xmlPage resource\", exception);\n        throw exception;\n    }","commit_id":"b25645390aea68c1257121e0d7b185eae2c67e4d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.xml.sax.ErrorHandler#warning(org.xml.sax.SAXParseException)\n     */\n    public void warning(SAXParseException arg0) throws SAXException { \n        throw new SAXException(\"[Warning] \" + arg0.getMessage().replaceAll(\"\\\"\", \"'\"));\n    }","id":35390,"modified_method":"/**\n     * @see org.xml.sax.ErrorHandler#warning(org.xml.sax.SAXParseException)\n     */\n    public void warning(SAXParseException exception) {\n        \n        if (OpenCms.getLog(this).isWarnEnabled()) {\n            OpenCms.getLog(this).warn(\"Warning parsing xmlPage resource\", exception);\n        }\n    }","commit_id":"b25645390aea68c1257121e0d7b185eae2c67e4d","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private List<Object> readModels(Exchange exchange, InputStream stream) {\n        List<Object> results = new ArrayList<Object>();\n        BufferedReader streamReader = IOHelper.buffered(new InputStreamReader(stream, getEncoding()));\n\n        BeanReader in = factory.createReader(getStreamName(), streamReader);\n\n        try {\n            in.setErrorHandler(new BeanIOErrorHandler(configuration));\n\n            Object readObject;\n            while ((readObject = in.read()) != null) {\n                if (readObject instanceof BeanIOHeader) {\n                    exchange.getOut().getHeaders().putAll(((BeanIOHeader) readObject).getHeaders());\n                }\n                results.add(readObject);\n            }\n        } finally {\n            in.close();\n        }\n\n        return results;\n    }","id":35391,"modified_method":"private List<Object> readModels(Exchange exchange, InputStream stream) {\n        List<Object> results = new ArrayList<Object>();\n        BufferedReader streamReader = IOHelper.buffered(new InputStreamReader(stream, getEncoding()));\n\n        BeanReader in = factory.createReader(getStreamName(), streamReader);\n\n        try {\n            if (ObjectHelper.isNotEmpty(configuration.getBeanReaderErrorHandler())) {\n            \tin.setErrorHandler(configuration.getBeanReaderErrorHandler());\n            } else {\n                in.setErrorHandler(new BeanIOErrorHandler(configuration));\n            }\n\n            Object readObject;\n            while ((readObject = in.read()) != null) {\n                if (readObject instanceof BeanIOHeader) {\n                    exchange.getOut().getHeaders().putAll(((BeanIOHeader) readObject).getHeaders());\n                }\n                results.add(readObject);\n            }\n        } finally {\n            in.close();\n        }\n\n        return results;\n    }","commit_id":"66594e97a89dddd4d298a7332787ee07444b2f91","url":"https://github.com/apache/camel"},{"original_method":"private void installDocuments() {\n    for (int i = 0; i < myTestLocations.length; i++) {\n      final LabeledComponent testLocation = getTestLocation(i);\n      final JComponent component = testLocation.getComponent();\n      final ComponentWithBrowseButton field;\n      final Object document;\n      if (component instanceof TextFieldWithBrowseButton) {\n        field = (TextFieldWithBrowseButton)component;\n        document = new PlainDocument();\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((Document)document);\n        myModel.setJUnitDocument(i, document);\n      } else if (component instanceof EditorTextFieldWithBrowseButton) {\n        field = (ComponentWithBrowseButton)component;\n        document = ((EditorTextField)field.getChildComponent()).getDocument();\n        myModel.setJUnitDocument(i, document);\n      }\n      else {\n        field = myPatternTextField;\n        document = new PlainDocument();\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((Document)document);\n        myModel.setJUnitDocument(i, document);\n      }\n      myBrowsers[i].setField(field);\n      if (myBrowsers[i] instanceof MethodBrowser) {\n        ((MethodBrowser)myBrowsers[i]).installCompletion((EditorTextField)field.getChildComponent());\n      }\n    }\n  }","id":35392,"modified_method":"private void installDocuments() {\n    for (int i = 0; i < myTestLocations.length; i++) {\n      final LabeledComponent testLocation = getTestLocation(i);\n      final JComponent component = testLocation.getComponent();\n      final ComponentWithBrowseButton field;\n      Object document;\n      if (component instanceof TextFieldWithBrowseButton) {\n        field = (TextFieldWithBrowseButton)component;\n        document = new PlainDocument();\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((Document)document);\n      } else if (component instanceof EditorTextFieldWithBrowseButton) {\n        field = (ComponentWithBrowseButton)component;\n        document = ((EditorTextField)field.getChildComponent()).getDocument();\n      }\n      else {\n        field = myPatternTextField;\n        document = new PlainDocument();\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((Document)document);\n        \n      }\n      myBrowsers[i].setField(field);\n      if (myBrowsers[i] instanceof MethodBrowser) {\n        final EditorTextField childComponent = (EditorTextField)field.getChildComponent();\n        ((MethodBrowser)myBrowsers[i]).installCompletion(childComponent);\n        document = childComponent.getDocument();\n      }\n      myModel.setJUnitDocument(i, document);\n    }\n  }","commit_id":"c00c4900db84a4601265cf92d8cd108afb19cbe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TestNGConfigurationEditor(Project project) {\n    this.project = project;\n    BrowseModuleValueActionListener[] browseListeners = new BrowseModuleValueActionListener[]{new PackageBrowser(project),\n      new TestClassBrowser(project, this), new TestNGMethodBrowser(project), new GroupBrowser(project, this), new SuiteBrowser(project),\n      new TestClassBrowser(project, this) {\n        @Override\n        protected void onClassChoosen(PsiClass psiClass) {\n          final JTextField textField = myPatternTextField.getTextField();\n          final String text = textField.getText();\n          textField.setText(text + (text.length() > 0 ? \"||\" : \"\") + psiClass.getQualifiedName());\n        }\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          showDialog();\n        }\n      }};\n    model = new TestNGConfigurationModel(project);\n    model.setListener(this);\n    createView();\n    moduleSelector = new ConfigurationModuleSelector(project, getModulesComponent());\n    commonJavaParameters.setModuleContext(moduleSelector.getModule());\n    moduleClasspath.getComponent().addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        commonJavaParameters.setModuleContext(moduleSelector.getModule());\n      }\n    });\n    commonJavaParameters.setHasModuleMacro();\n\n    final JPanel panel = myPattern.getComponent();\n    panel.setLayout(new BorderLayout());\n    myPatternTextField = new TextFieldWithBrowseButton();\n    myPatternTextField.setButtonIcon(IconUtil.getAddIcon());\n    panel.add(myPatternTextField, BorderLayout.CENTER);\n    final FixedSizeButton editBtn = new FixedSizeButton();\n    editBtn.setIcon(AllIcons.Actions.ShowViewer);\n    editBtn.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        Messages.showTextAreaDialog(myPatternTextField.getTextField(), \"Configure suite tests\", \"EditParametersPopupWindow\");\n      }\n    });\n    panel.add(editBtn, BorderLayout.EAST);\n\n    registerListener(new JRadioButton[]{packageTest, classTest, methodTest, groupTest, suiteTest, patternTest}, new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        ButtonModel buttonModel = (ButtonModel)e.getSource();\n        if (buttonModel.isSelected()) {\n          if (buttonModel == packageTest.getModel()) {\n            model.setType(TestType.PACKAGE);\n          }\n          else if (buttonModel == classTest.getModel()) {\n            model.setType(TestType.CLASS);\n          }\n          else if (buttonModel == methodTest.getModel()) {\n            model.setType(TestType.METHOD);\n          }\n          else if (buttonModel == groupTest.getModel()) {\n            model.setType(TestType.GROUP);\n          }\n          else if (buttonModel == suiteTest.getModel()) {\n            model.setType(TestType.SUITE);\n          }\n          else if (buttonModel == patternTest.getModel()) {\n            model.setType(TestType.PATTERN);\n          }\n        }\n      }\n    });\n    registerListener(new JRadioButton[]{packagesInProject, packagesInModule, packagesAcrossModules}, null);\n    packagesInProject.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        evaluateModuleClassPath();\n      }\n    });\n\n    LabeledComponent[] components = new LabeledComponent[]{packageField, classField, methodField, groupField, suiteField, myPattern};\n    for (int i = 0; i < components.length; i++) {\n      JComponent field = components[i].getComponent();\n      Object document = model.getDocument(i);\n      if (field instanceof TextFieldWithBrowseButton) {\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((PlainDocument)document);\n      }\n      else if (field instanceof EditorTextFieldWithBrowseButton) {\n        final com.intellij.openapi.editor.Document componentDocument =\n          ((EditorTextFieldWithBrowseButton)field).getChildComponent().getDocument();\n        \n        model.setDocument(i, componentDocument);\n      }\n      else {\n        field = myPatternTextField;\n        document = new PlainDocument();\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((Document)document);\n        model.setDocument(i, document);\n      }\n\n      browseListeners[i].setField((ComponentWithBrowseButton)field);\n      if (browseListeners[i] instanceof MethodBrowser) {\n        ((MethodBrowser)browseListeners[i]).installCompletion((EditorTextField)((ComponentWithBrowseButton)field).getChildComponent());\n      }\n    }\n    model.setType(TestType.CLASS);\n    propertiesFile.getComponent().getTextField().setDocument(model.getPropertiesFileDocument());\n    outputDirectory.getComponent().getTextField().setDocument(model.getOutputDirectoryDocument());\n\n    commonJavaParameters.setProgramParametersLabel(ExecutionBundle.message(\"junit.configuration.test.runner.parameters.label\"));\n\n    setAnchor(outputDirectory.getLabel());\n    alternateJDK.setAnchor(moduleClasspath.getLabel());\n    commonJavaParameters.setAnchor(moduleClasspath.getLabel());\n  }","id":35393,"modified_method":"public TestNGConfigurationEditor(Project project) {\n    this.project = project;\n    BrowseModuleValueActionListener[] browseListeners = new BrowseModuleValueActionListener[]{new PackageBrowser(project),\n      new TestClassBrowser(project, this), new TestNGMethodBrowser(project), new GroupBrowser(project, this), new SuiteBrowser(project),\n      new TestClassBrowser(project, this) {\n        @Override\n        protected void onClassChoosen(PsiClass psiClass) {\n          final JTextField textField = myPatternTextField.getTextField();\n          final String text = textField.getText();\n          textField.setText(text + (text.length() > 0 ? \"||\" : \"\") + psiClass.getQualifiedName());\n        }\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          showDialog();\n        }\n      }};\n    model = new TestNGConfigurationModel(project);\n    model.setListener(this);\n    createView();\n    moduleSelector = new ConfigurationModuleSelector(project, getModulesComponent());\n    commonJavaParameters.setModuleContext(moduleSelector.getModule());\n    moduleClasspath.getComponent().addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        commonJavaParameters.setModuleContext(moduleSelector.getModule());\n      }\n    });\n    commonJavaParameters.setHasModuleMacro();\n\n    final JPanel panel = myPattern.getComponent();\n    panel.setLayout(new BorderLayout());\n    myPatternTextField = new TextFieldWithBrowseButton();\n    myPatternTextField.setButtonIcon(IconUtil.getAddIcon());\n    panel.add(myPatternTextField, BorderLayout.CENTER);\n    final FixedSizeButton editBtn = new FixedSizeButton();\n    editBtn.setIcon(AllIcons.Actions.ShowViewer);\n    editBtn.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        Messages.showTextAreaDialog(myPatternTextField.getTextField(), \"Configure suite tests\", \"EditParametersPopupWindow\");\n      }\n    });\n    panel.add(editBtn, BorderLayout.EAST);\n\n    registerListener(new JRadioButton[]{packageTest, classTest, methodTest, groupTest, suiteTest, patternTest}, new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        ButtonModel buttonModel = (ButtonModel)e.getSource();\n        if (buttonModel.isSelected()) {\n          if (buttonModel == packageTest.getModel()) {\n            model.setType(TestType.PACKAGE);\n          }\n          else if (buttonModel == classTest.getModel()) {\n            model.setType(TestType.CLASS);\n          }\n          else if (buttonModel == methodTest.getModel()) {\n            model.setType(TestType.METHOD);\n          }\n          else if (buttonModel == groupTest.getModel()) {\n            model.setType(TestType.GROUP);\n          }\n          else if (buttonModel == suiteTest.getModel()) {\n            model.setType(TestType.SUITE);\n          }\n          else if (buttonModel == patternTest.getModel()) {\n            model.setType(TestType.PATTERN);\n          }\n        }\n      }\n    });\n    registerListener(new JRadioButton[]{packagesInProject, packagesInModule, packagesAcrossModules}, null);\n    packagesInProject.addChangeListener(new ChangeListener() {\n      public void stateChanged(ChangeEvent e) {\n        evaluateModuleClassPath();\n      }\n    });\n\n    LabeledComponent[] components = new LabeledComponent[]{packageField, classField, methodField, groupField, suiteField, myPattern};\n    for (int i = 0; i < components.length; i++) {\n      JComponent field = components[i].getComponent();\n      Object document = model.getDocument(i);\n      if (field instanceof TextFieldWithBrowseButton) {\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((PlainDocument)document);\n      }\n      else if (field instanceof EditorTextFieldWithBrowseButton) {\n        document = ((EditorTextFieldWithBrowseButton)field).getChildComponent().getDocument();\n      }\n      else {\n        field = myPatternTextField;\n        document = new PlainDocument();\n        ((TextFieldWithBrowseButton)field).getTextField().setDocument((Document)document);\n      }\n\n      browseListeners[i].setField((ComponentWithBrowseButton)field);\n      if (browseListeners[i] instanceof MethodBrowser) {\n        final EditorTextField childComponent = (EditorTextField)((ComponentWithBrowseButton)field).getChildComponent();\n        ((MethodBrowser)browseListeners[i]).installCompletion(childComponent);\n        document = childComponent.getDocument();\n      }\n      model.setDocument(i, document);\n    }\n    model.setType(TestType.CLASS);\n    propertiesFile.getComponent().getTextField().setDocument(model.getPropertiesFileDocument());\n    outputDirectory.getComponent().getTextField().setDocument(model.getOutputDirectoryDocument());\n\n    commonJavaParameters.setProgramParametersLabel(ExecutionBundle.message(\"junit.configuration.test.runner.parameters.label\"));\n\n    setAnchor(outputDirectory.getLabel());\n    alternateJDK.setAnchor(moduleClasspath.getLabel());\n    commonJavaParameters.setAnchor(moduleClasspath.getLabel());\n  }","commit_id":"c00c4900db84a4601265cf92d8cd108afb19cbe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TextFieldWithAutoCompletion<String> create(final Project project,\n                                                           @NotNull final Collection<String> items,\n                                                           @Nullable final Icon icon,\n                                                           final boolean showAutocompletionIsAvailableHint,\n                                                           @Nullable final String text) {\n    return new TextFieldWithAutoCompletion<String>(project, new StringsCompletionProvider(items, icon), showAutocompletionIsAvailableHint,\n                                                   text);\n  }","id":35394,"modified_method":"@NotNull\n  public static TextFieldWithAutoCompletion<String> create(@Nullable Project project,\n                                                           @NotNull Collection<String> items,\n                                                           @Nullable Icon icon,\n                                                           boolean showCompletionHint,\n                                                           @Nullable String text) {\n    return new TextFieldWithAutoCompletion<String>(project, new StringsCompletionProvider(items, icon), showCompletionHint, text);\n  }","commit_id":"791ab530319877a3b08e6ae48427bbb40a4155a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TextFieldWithAutoCompletion<String> create(final Project project,\n                                                           @NotNull final Collection<String> items,\n                                                           final boolean showAutocompletionIsAvailableHint,\n                                                           @Nullable final String text) {\n    return create(project, items, null, showAutocompletionIsAvailableHint, text);\n  }","id":35395,"modified_method":"@NotNull\n  public static TextFieldWithAutoCompletion<String> create(@Nullable Project project,\n                                                           @NotNull Collection<String> items,\n                                                           boolean showCompletionHint,\n                                                           @Nullable String text) {\n    return create(project, items, null, showCompletionHint, text);\n  }","commit_id":"791ab530319877a3b08e6ae48427bbb40a4155a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TextFieldWithAutoCompletion(final Project project,\n                                     @NotNull final TextFieldWithAutoCompletionListProvider<T> provider,\n                                     final boolean showAutocompletionIsAvailableHint, @Nullable final String text) {\n    super(project == null ? null : PlainTextLanguage.INSTANCE, project, text == null ? \"\" : text);\n\n    myShowAutocompletionIsAvailableHint = showAutocompletionIsAvailableHint;\n    myProvider = provider;\n\n    installCompletion(getDocument(), project, provider, true);\n  }","id":35396,"modified_method":"public TextFieldWithAutoCompletion(@Nullable Project project,\n                                     @NotNull TextFieldWithAutoCompletionListProvider<T> provider,\n                                     boolean showCompletionHint,\n                                     @Nullable String text) {\n    super(project == null ? null : PlainTextLanguage.INSTANCE, project, text == null ? \"\" : text);\n\n    myShowCompletionHint = showCompletionHint;\n    myProvider = provider;\n\n    if (project != null) {\n      installCompletion(getDocument(), project, provider, true);\n    }\n  }","commit_id":"791ab530319877a3b08e6ae48427bbb40a4155a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected EditorEx createEditor() {\n    EditorEx editor = super.createEditor();\n\n    if (myShowAutocompletionIsAvailableHint) {\n      TextCompletionUtil.installCompletionHint(editor);\n    }\n\n    return editor;\n  }","id":35397,"modified_method":"@Override\n  protected EditorEx createEditor() {\n    EditorEx editor = super.createEditor();\n\n    if (myShowCompletionHint) {\n      TextCompletionUtil.installCompletionHint(editor);\n    }\n\n    return editor;\n  }","commit_id":"791ab530319877a3b08e6ae48427bbb40a4155a3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public WOComponent nextPage(boolean doConfirm) {\n        if(doConfirm && d2wContext().valueForKey(\"inspectConfirmConfigurationName\") != null) {\n            InspectPageInterface ipi = (InspectPageInterface)D2W.factory().pageForConfigurationNamed((String)d2wContext().valueForKey(\"inspectConfirmConfigurationName\"), session());\n            ipi.setObject((EOEnterpriseObject)d2wContext().valueForKey(\"object\"));\n            ipi.setNextPageDelegate(nextPageDelegate());\n            ipi.setNextPage(super.nextPage());\n            if (ipi instanceof ERDFollowPageInterface) \n                ((ERDFollowPageInterface)ipi).setPreviousPage(context().page());\n             return (WOComponent)ipi;\n        }\n        return (nextPageDelegate() != null) ? nextPageDelegate().nextPage(this) : super.nextPage();\n    }","id":35398,"modified_method":"public WOComponent nextPage(boolean doConfirm) {\n        Object inspectConfirmConfigurationName = d2wContext().valueForKey(\"inspectConfirmConfigurationName\");\n        if(doConfirm && inspectConfirmConfigurationName != null && ! \"\".equals(inspectConfirmConfigurationName)) {\n            WOComponent ipi = D2W.factory().pageForConfigurationNamed((String)d2wContext().valueForKey(\"inspectConfirmConfigurationName\"), session());\n            if (ipi instanceof InspectPageInterface) {\n                ((InspectPageInterface)ipi).setObject((EOEnterpriseObject)d2wContext().valueForKey(\"object\"));\n                ((InspectPageInterface)ipi).setNextPageDelegate(nextPageDelegate());\n                ((InspectPageInterface)ipi).setNextPage(super.nextPage());\n            }\n            if (ipi instanceof ERDFollowPageInterface)\n                ((ERDFollowPageInterface)ipi).setPreviousPage(context().page());\n            return (WOComponent)ipi;\n        }\n        return (nextPageDelegate() != null) ? nextPageDelegate().nextPage(this) : super.nextPage();\n    }","commit_id":"9b7b7898aece9ca1872cb4cfdc679562d6e5ff57","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String urlForCurrentState() {\n        return context().directActionURLForActionNamed(d2wContext().dynamicPage(), null);\n    }","id":35399,"modified_method":"/*** end of reimplementation */\n\n    public String urlForCurrentState() {\n        return context().directActionURLForActionNamed(d2wContext().dynamicPage(), null);\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isEntityReadOnly() {\n        return !ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"isEntityEditable\"), !super.isEntityReadOnly());\n    }","id":35400,"modified_method":"public boolean isEntityReadOnly() {\n        boolean isEntityReadOnly = super.isEntityReadOnly();\n        boolean isEditable = ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"isEntityEditable\"), true);\n        boolean readOnly = ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"readOnly\"), false);\n        return isEntityReadOnly && !isEditable && readOnly;\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent editObjectAction() {\n        WOComponent result = null;\n        String editConfigurationName=(String)d2wContext().valueForKey(\"editConfigurationName\");\n\n        if(editConfigurationName != null) {\n            log.debug(\"editConfigurationName = \"+editConfigurationName);\n            Object page = D2W.factory().pageForConfigurationNamed(editConfigurationName,session());\n            log.debug(\"page = \"+page);\n            EditPageInterface epi = (EditPageInterface)page;\n\n            epi.setObject(localInstanceOfObject());\n            epi.setNextPage(context().page());\n            result = (WOComponent)epi;\n        } else {\n            EditPageInterface editpageinterface = D2W.factory().editPageForEntityNamed(object().entityName(), session());            \n            editpageinterface.setObject(localInstanceOfObject());\n            editpageinterface.setNextPage(context().page());\n            result = (WOComponent)editpageinterface;\n        }\n        return result;\n    }","id":35401,"modified_method":"public WOComponent editObjectAction() {\n        EditPageInterface epi;\n        String editConfigurationName=(String)d2wContext().valueForKey(\"editConfigurationName\");\n        log.debug(\"editConfigurationName: \" + editConfigurationName);\n        if(editConfigurationName != null) {\n            epi = (EditPageInterface)D2W.factory().pageForConfigurationNamed(editConfigurationName,session());\n        } else {\n            epi = D2W.factory().editPageForEntityNamed(object().entityName(), session());            \n        }\n        epi.setObject(localInstanceOfObject());\n        epi.setNextPage(context().page());\n        return (WOComponent)epi;\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Public constructor\n     * @param c current context\n     */\n    public ERD2WListPage(WOContext c) {\n        super(c);\n        if (ERD2WFactory.erFactory().defaultListPageDisplayGroupDelegate() != null) {\n            displayGroup().setDelegate(ERD2WFactory.erFactory().defaultListPageDisplayGroupDelegate());\n        }\n    }","id":35402,"modified_method":"/**\n     * Public constructor\n     * @param c current context\n     */\n    public ERD2WListPage(WOContext c) {\n        super(c);\n        NSNotificationCenter.defaultCenter().addObserver(this, new NSSelector(\"savedChanges\", ERXConstant.NotificationClassArray), EOEditingContext.EditingContextDidSaveChangesNotification, null);\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void takeValuesFromRequest(WORequest r, WOContext c) {\n        setupPhase();\n        NDC.push(\"Page: \" + getClass().getName()+ (d2wContext()!= null ? (\" - Configuration: \"+d2wContext().valueForKey(\"pageConfiguration\")) : \"\"));\n        try {\n            super.takeValuesFromRequest(r, c);\n        } finally {\n            NDC.pop();\n        }\n    }","id":35403,"modified_method":"public void takeValuesFromRequest(WORequest r, WOContext c) {\n        setupPhase();\n        super.takeValuesFromRequest(r, c);\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent inspectObjectAction() {\n        WOComponent result = null;\n        String inspectConfigurationName=(String)d2wContext().valueForKey(\"inspectConfigurationName\");\n\n        if(inspectConfigurationName!=null) {\n            InspectPageInterface ipi=(InspectPageInterface)D2W.factory().pageForConfigurationNamed(inspectConfigurationName,session());\n            ipi.setObject(object());\n            ipi.setNextPage(context().page());\n            return (WOComponent)ipi;\n        } else {\n            InspectPageInterface inspectpageinterface = D2W.factory().inspectPageForEntityNamed(object().entityName(), session());\n            inspectpageinterface.setObject(object());\n            inspectpageinterface.setNextPage(context().page());\n            return (WOComponent)inspectpageinterface;\n        }\n    }","id":35404,"modified_method":"public WOComponent inspectObjectAction() {\n        InspectPageInterface ipi;\n        String inspectConfigurationName=(String)d2wContext().valueForKey(\"inspectConfigurationName\");\n        log.debug(\"inspectConfigurationName: \" + inspectConfigurationName);\n        if(inspectConfigurationName!=null) {\n            ipi=(InspectPageInterface)D2W.factory().pageForConfigurationNamed(inspectConfigurationName,session());\n        } else {\n            ipi = D2W.factory().inspectPageForEntityNamed(object().entityName(), session());\n        }\n        ipi.setObject(object());\n        ipi.setNextPage(context().page());\n        return (WOComponent)ipi;\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setDataSource(EODataSource eodatasource) {\n        try{\n            super.setDataSource(eodatasource);\n        } catch (Exception ex) {\n            log.warn(\"Exception when setting datasource\", ex);\n            NSArray sortOrderings=sortOrderings();\n            displayGroup().setDataSource(eodatasource);\n            displayGroup().setSortOrderings(sortOrderings!=null ? sortOrderings : NSArray.EmptyArray);\n            displayGroup().fetch();\n        }\n    }","id":35405,"modified_method":"public void setDataSource(EODataSource eodatasource) {\n        NSArray sortOrderings=sortOrderings();\n        displayGroup().setDataSource(eodatasource);\n        displayGroup().setSortOrderings(sortOrderings!=null ? sortOrderings : NSArray.EmptyArray);\n        displayGroup().fetch();\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected void setupPhase() {\n        WODisplayGroup dg=displayGroup();\n        if (dg!=null) {\n            if (!_hasBeenInitialized) {\n                log.debug(\"Initializing display group\");\n                String fetchspecName = (String)d2wContext().valueForKey(\"restrictingFetchSpecification\");\n                if(fetchspecName != null) {\n                    EODataSource ds = dataSource();\n                    if(ds instanceof EODatabaseDataSource)\n                        ((EODatabaseDataSource)ds).setFetchSpecificationByName(fetchspecName);\n                }\n                NSArray sortOrderings=sortOrderings();\n                displayGroup().setSortOrderings(sortOrderings!=null ? sortOrderings : NSArray.EmptyArray);\n                displayGroup().setNumberOfObjectsPerBatch(numberOfObjectsPerBatch());\n                displayGroup().fetch();\n                displayGroup().updateDisplayedObjects();\n                _hasBeenInitialized=true;\n            }\n            // this will have the side effect of resetting the batch # to sth correct, in case\n            // the current index if out of range\n            log.debug(\"dg.currentBatchIndex() \"+dg.currentBatchIndex());\n            dg.setCurrentBatchIndex(dg.currentBatchIndex());\n            if (listSize() > 0)\n                d2wContext().takeValueForKey(dg.allObjects().objectAtIndex(0), \"object\");\n        }\n    }","id":35406,"modified_method":"protected void setupPhase() {\n        WODisplayGroup dg=displayGroup();\n        if (dg!=null) {\n            if (!_hasBeenInitialized) {\n                log.debug(\"Initializing display group\");\n                String fetchspecName = (String)d2wContext().valueForKey(\"restrictingFetchSpecification\");\n                if(fetchspecName != null) {\n                    EODataSource ds = dataSource();\n                    if(ds instanceof EODatabaseDataSource)\n                        ((EODatabaseDataSource)ds).setFetchSpecificationByName(fetchspecName);\n                }\n                NSArray sortOrderings=sortOrderings();\n                dg.setSortOrderings(sortOrderings!=null ? sortOrderings : NSArray.EmptyArray);\n                dg.setNumberOfObjectsPerBatch(numberOfObjectsPerBatch());\n                dg.fetch();\n                dg.updateDisplayedObjects();\n                _hasBeenInitialized=true;\n            }\n            // this will have the side effect of resetting the batch # to sth correct, in case\n            // the current index if out of range\n            log.debug(\"dg.currentBatchIndex() \"+dg.currentBatchIndex());\n            dg.setCurrentBatchIndex(dg.currentBatchIndex());\n            if (listSize() > 0)\n                d2wContext().takeValueForKey(dg.allObjects().objectAtIndex(0), \"object\");\n        }\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void appendToResponse(WOResponse r, WOContext c) {\n        setupPhase();\n        NDC.push(\"Page: \" + getClass().getName()+ (d2wContext()!= null ? (\" - Configuration: \"+d2wContext().valueForKey(\"pageConfiguration\")) : \"\"));\n        try {\n            super.appendToResponse(r,c);\n        } catch(Exception ex) {\n            ERDirectToWeb.reportException(ex, d2wContext());\n        } finally {\n            NDC.pop();\n        }\n    }","id":35407,"modified_method":"public void appendToResponse(WOResponse r, WOContext c) {\n        setupPhase();\n        _rowFlip = true;\n        if(_hasToUpdate) {\n            displayGroup().fetch();\n            _hasToUpdate = false;\n        }\n        super.appendToResponse(r,c);\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOActionResults invokeAction(WORequest r, WOContext c) {\n        setupPhase();\n        WOActionResults result=null;\n        NDC.push(\"Page: \" + getClass().getName()+ (d2wContext()!= null ? (\" - Configuration: \"+d2wContext().valueForKey(\"pageConfiguration\")) : \"\"));\n        try {\n            result= super.invokeAction(r, c);\n        } finally {\n            NDC.pop();\n        }\n        return result;\n    }","id":35408,"modified_method":"public WOActionResults invokeAction(WORequest r, WOContext c) {\n        setupPhase();\n        return super.invokeAction(r, c);\n    }","commit_id":"092ba097dbfe3f360138f4b57ab71271b4677d19","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent createObjectAction() {\n        String editRelationshipConfigurationName = (String)valueForBinding(\"editRelationshipConfigurationName\");\n        if(editRelationshipConfigurationName != null && editRelationshipConfigurationName.length() > 0) {\n            EditRelationshipPageInterface epi = (EditRelationshipPageInterface)D2W.factory().pageForConfigurationNamed(editRelationshipConfigurationName, session());\n            epi.setMasterObjectAndRelationshipKey(object(), key());\n            epi.setNextPage(context().page());\n            return (WOComponent)epi;\n        } else {\n            ERXEOControlUtilities.createAndAddObjectToRelationship(object().editingContext(), object(), key(), (String)valueForBinding(\"destinationEntityName\"), null);\n        }\n        return context().page();\n    }","id":35409,"modified_method":"public WOComponent createObjectAction() {\n        WOComponent nextPage = context().page();\n        String editRelationshipConfigurationName = (String)valueForBinding(\"editRelationshipConfigurationName\");\n        if(editRelationshipConfigurationName != null && editRelationshipConfigurationName.length() > 0) {\n            nextPage = D2W.factory().pageForConfigurationNamed(editRelationshipConfigurationName, session());\n            if(nextPage instanceof EditRelationshipPageInterface) {\n                EditRelationshipPageInterface epi = (EditRelationshipPageInterface)nextPage;\n                epi.setMasterObjectAndRelationshipKey(object(), key());\n                epi.setNextPage(context().page());\n            } else if(nextPage instanceof EditPageInterface) {\n                EOEnterpriseObject object = ERD2WUtilities.localInstanceFromObjectWithD2WContext(object(), d2wContext());\n                EOEnterpriseObject eo = ERXEOControlUtilities.createAndAddObjectToRelationship(object.editingContext(), object, key(), (String)valueForBinding(\"destinationEntityName\"), null);\n                EditPageInterface epi = (EditPageInterface)nextPage;\n                epi.setObject(eo);\n                epi.setNextPage(context().page());\n            }\n        } else {\n            ERXEOControlUtilities.createAndAddObjectToRelationship(object().editingContext(), object(), key(), (String)valueForBinding(\"destinationEntityName\"), null);\n        }\n        return nextPage;\n    }","commit_id":"3334957c158995774b3e85905c18b52753aa05f9","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n   * Build the instance of {@link BasicMapReduceContext}.\n   * @param conf runtime configuration\n   * @param runId program run id\n   * @param classLoader classloader to use\n   * @param programLocation program location\n   * @param inputDataSetName name of the input dataset if specified for this mapreduce job, null otherwise\n   * @param inputSplits input splits if specified for this mapreduce job, null otherwise\n   * @param outputDataSetName name of the output dataset if specified for this mapreduce job, null otherwise\n   * @return instance of {@link BasicMapReduceContext}\n   */\n  public BasicMapReduceContext build(CConfiguration conf, String runId,\n                                     ClassLoader classLoader,\n                                     String programLocation,\n                                     @Nullable String inputDataSetName,\n                                     @Nullable List<Split> inputSplits,\n                                     @Nullable String outputDataSetName) {\n    Injector injector = createInjector();\n\n    // Initializing Program\n    LocationFactory locationFactory = injector.getInstance(LocationFactory.class);\n    Program program;\n    try {\n      program = new Program(locationFactory.create(programLocation));\n    } catch (IOException e) {\n      LOG.error(\"Could not init Program based on location: \" + programLocation);\n      throw Throwables.propagate(e);\n    }\n\n    // Initializing dataset context and hooking it up with mapreduce job transaction\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opexContext = new OperationContext(program.getAccountId(), program.getApplicationId());\n    // TODO: Pick up tx started when mapreduce job was submitted (requires missing implementation of long-running txs)\n    TransactionProxy transactionProxy = new TransactionProxy();\n    transactionProxy.setTransactionAgent(new SynchronousTransactionAgent(opex, opexContext));\n    DataFabric dataFabric = new DataFabricImpl(opex, opexContext);\n    DataSetInstantiator dataSetContext =\n      new DataSetInstantiator(dataFabric, transactionProxy, classLoader);\n    dataSetContext.setDataSets(Lists.newArrayList(program.getSpecification().getDataSets().values()));\n\n    // Creating mapreduce job context\n    MapReduceSpecification spec = program.getSpecification().getMapReduces().get(program.getProgramName());\n    BasicMapReduceContext context =\n      new BasicMapReduceContext(program, RunId.from(runId),\n                                // NOTE: we are initializing all datasets of application, so that user is not required\n                                //       to define all datasets used in Mapper and Reducer classes on MapReduceJob\n                                //       class level\n                                DataSets.createDataSets(\n                                  dataSetContext, program.getSpecification().getDataSets().keySet()),\n                                spec);\n\n    // Setting extra context's configuration: mapreduce input and output\n    if (inputDataSetName != null && inputSplits != null) {\n      context.setInput((BatchReadable) dataSetContext.getDataSet(inputDataSetName), inputSplits);\n    }\n    if (outputDataSetName != null) {\n      context.setOutput((BatchWritable) dataSetContext.getDataSet(outputDataSetName));\n    }\n\n    // Hooking up with logging and metrics systems\n    // this is a hack for old logging system\n    CAppender.logWriter = injector.getInstance(LogWriter.class);\n    // this is a hack for old metrics system\n    OverlordMetricsReporter.enable(1, TimeUnit.SECONDS, conf);\n\n    return context;\n  }","id":35410,"modified_method":"/**\n   * Build the instance of {@link BasicMapReduceContext}.\n   * @param conf runtime configuration\n   * @param runId program run id\n   * @param classLoader classloader to use\n   * @param programLocation program location\n   * @param inputDataSetName name of the input dataset if specified for this mapreduce job, null otherwise\n   * @param inputSplits input splits if specified for this mapreduce job, null otherwise\n   * @param outputDataSetName name of the output dataset if specified for this mapreduce job, null otherwise\n   * @return instance of {@link BasicMapReduceContext}\n   */\n  public BasicMapReduceContext build(CConfiguration conf, String runId,\n                                     ClassLoader classLoader,\n                                     String programLocation,\n                                     @Nullable String inputDataSetName,\n                                     @Nullable List<Split> inputSplits,\n                                     @Nullable String outputDataSetName) {\n    Injector injector = createInjector();\n\n    // Initializing Program\n    LocationFactory locationFactory = injector.getInstance(LocationFactory.class);\n    Program program;\n    try {\n      program = new Program(locationFactory.create(programLocation));\n    } catch (IOException e) {\n      LOG.error(\"Could not init Program based on location: \" + programLocation);\n      throw Throwables.propagate(e);\n    }\n\n    // Initializing dataset context and hooking it up with mapreduce job transaction\n    OperationExecutor opex = injector.getInstance(OperationExecutor.class);\n    OperationContext opexContext = new OperationContext(program.getAccountId(), program.getApplicationId());\n    // TODO: Pick up tx started when mapreduce job was submitted (requires missing implementation of long-running txs)\n    TransactionProxy transactionProxy = new TransactionProxy();\n    transactionProxy.setTransactionAgent(new SynchronousTransactionAgent(opex, opexContext));\n    DataFabric dataFabric = new DataFabricImpl(opex, opexContext);\n    DataSetInstantiator dataSetContext =\n      new DataSetInstantiator(dataFabric, transactionProxy, classLoader);\n    dataSetContext.setDataSets(Lists.newArrayList(program.getSpecification().getDataSets().values()));\n\n    // Creating mapreduce job context\n    MapReduceSpecification spec = program.getSpecification().getMapReduces().get(program.getProgramName());\n    BasicMapReduceContext context =\n      new BasicMapReduceContext(program, RunId.from(runId),\n                                // NOTE: we are initializing all datasets of application, so that user is not required\n                                //       to define all datasets used in Mapper and Reducer classes on MapReduceJob\n                                //       class level\n                                DataSets.createDataSets(\n                                  dataSetContext, program.getSpecification().getDataSets().keySet()),\n                                spec);\n\n    // Setting extra context's configuration: mapreduce input and output\n    if (inputDataSetName != null && inputSplits != null) {\n      context.setInput((BatchReadable) dataSetContext.getDataSet(inputDataSetName), inputSplits);\n    }\n    if (outputDataSetName != null) {\n      context.setOutput((BatchWritable) dataSetContext.getDataSet(outputDataSetName));\n    }\n\n    // Hooking up with logging and metrics systems\n    // this is a hack for old logging system\n    CAppender.logWriter = injector.getInstance(LogWriter.class);\n\n    return context;\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void before() throws Exception {\n    configuration = CConfiguration.create();\n    configuration.setInt(Constants.CFG_APP_FABRIC_SERVER_PORT, 45000);\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, System.getProperty(\"java.io.tmpdir\") + \"/app\");\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, System.getProperty(\"java.io.tmpdir\") + \"/temp\");\n\n    Injector injector = Guice.createInjector(new AppFabricTestModule(configuration));\n\n    server = injector.getInstance(AppFabricServer.class);\n  }","id":35411,"modified_method":"@BeforeClass\n  public static void before() throws Exception {\n    TempFolder tempFolder = new TempFolder();\n    configuration = CConfiguration.create();\n    configuration.setInt(Constants.CFG_APP_FABRIC_SERVER_PORT, Networks.getRandomPort());\n    configuration.set(\"app.output.dir\", tempFolder.newFolder(\"app\").getAbsolutePath());\n    configuration.set(\"app.tmp.dir\", tempFolder.newFolder(\"temp\").getAbsolutePath());\n\n    Injector injector = Guice.createInjector(new AppFabricTestModule(configuration));\n\n    server = injector.getInstance(AppFabricServer.class);\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"public AppFabricTestModule(CConfiguration configuration) {\n    this.configuration = configuration;\n  }","id":35412,"modified_method":"public AppFabricTestModule(CConfiguration configuration) {\n    this.cConf = configuration;\n    hConf = new Configuration();\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void configure() {\n    install(new DataFabricModules().getInMemoryModules());\n    install(new ConfigModule(configuration));\n    install(new IOModule());\n    install(new DiscoveryRuntimeModule().getInMemoryModules());\n    install(new LocationRuntimeModule().getInMemoryModules());\n    install(new AppFabricServiceRuntimeModule().getInMemoryModules());\n    install(new ProgramRunnerRuntimeModule().getInMemoryModules());\n  }","id":35413,"modified_method":"@Override\n  protected void configure() {\n    install(new DataFabricModules().getInMemoryModules());\n    install(new ConfigModule(cConf, hConf));\n    install(new IOModule());\n    install(new DiscoveryRuntimeModule().getInMemoryModules());\n    install(new LocationRuntimeModule().getInMemoryModules());\n    install(new AppFabricServiceRuntimeModule().getInMemoryModules());\n    install(new ProgramRunnerRuntimeModule().getInMemoryModules());\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Tests that the admin class has ability to change security manager.\n   */\n  @Test\n  public void testAbilityToSetSecurityManagerMultipleTimes() throws Exception {\n    // Apply security and make sure we block exitJVM. This would throw an\n    // SecurityException.\n    ApplicationSecurity.builder()\n      .adminClass(this.getClass())\n      .add(new RuntimePermission(\"exitJVM\"))\n      .apply();\n\n    try {\n      System.exit(0);\n      Assert.assertFalse(\"Security is not set correctly. System.exit should have thrown security exception\", true);\n    } catch (Exception e) {\n      Assert.assertTrue(\"Security manager was set\", true);\n    }\n\n    // Changes the security setting.\n    ApplicationSecurity.builder()\n      .adminClass(this.getClass())\n      .add(new RuntimePermission(\"exitJVM.2\"))\n      .apply();\n\n    try {\n      System.exit(2);\n      Assert.assertFalse(\"Security is not set correctly. System.exit should have thrown security exception\", true);\n    } catch (Exception e) {\n      Assert.assertTrue(\"Security manager was set again.\", true);\n    }\n  }","id":35414,"modified_method":"/**\n   * Tests that the admin class has ability to change security manager.\n   */\n  @Test\n  public void testAbilityToSetSecurityManagerMultipleTimes() throws Exception {\n    SecurityAdmin admin = new SecurityAdmin();\n    try {\n      // Apply security and make sure we block exitJVM. This would throw an\n      // SecurityException.\n      admin.set(new RuntimePermission(\"exitJVM\"));\n\n      try {\n        System.exit(0);\n        Assert.assertFalse(\"Security is not set correctly. System.exit should have thrown security exception\", true);\n      } catch (Exception e) {\n        Assert.assertTrue(\"Security manager was set\", true);\n      }\n\n      // Changes the security setting.\n      admin.set(new RuntimePermission(\"exitJVM.2\"));\n\n      try {\n        System.exit(2);\n        Assert.assertFalse(\"Security is not set correctly. System.exit should have thrown security exception\", true);\n      } catch (Exception e) {\n        Assert.assertTrue(\"Security manager was set again.\", true);\n      }\n    } finally {\n      admin.reset();\n    }\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"protected Injector createInjector() {\n    ImmutableList<Module> modules = ImmutableList.of(\n      new BigMamaModule(cConf),\n      new MetricsModules().getSingleNodeModules(),\n      new MetadataModules().getSingleNodeModules(),\n      new Module() {\n        @Override\n        public void configure(Binder binder) {\n          binder.bind(Configuration.class).toInstance(hConf);\n\n          // Data-fabric bindings\n          // this makes mapreduce tasks talk to HBase/HDFS directly\n          binder.bind(OperationExecutor.class).\n            to(OmidTransactionalOperationExecutor.class).in(Singleton.class);\n\n          binder.bind(OVCTableHandle.class).to(HBaseOVCTableHandle.class);\n\n          binder.bind(TimestampOracle.class).to(MemoryStrictlyMonotonicTimeOracle.class).in(Singleton.class);\n          binder.bind(TransactionOracle.class).to(MemoryOracle.class).in(Singleton.class);\n\n          binder.bind(Configuration.class).annotatedWith(Names.named(\"HBaseOVCTableHandleHConfig\")).toInstance(hConf);\n          binder.bind(CConfiguration.class).annotatedWith(Names.named(\"HBaseOVCTableHandleCConfig\")).toInstance(cConf);\n          binder.bind(CConfiguration.class).annotatedWith(Names.named(\"DataFabricOperationExecutorConfig\"))\n            .toInstance(cConf);\n        }\n      }\n    );\n\n    // We need the hack to override the binding in massive BigMamaModule\n    // TODO: remove this hack after refactoring Guice modules (separate task that is in progress as of writing this)\n    Module module = Modules.override(modules).with(new Module() {\n      @Override\n      public void configure(Binder binder) {\n        binder.bind(LocationFactory.class).to(HDFSLocationFactory.class);\n      }\n    });\n\n\n    return Guice.createInjector(module);\n  }","id":35415,"modified_method":"protected Injector createInjector() {\n    return Guice.createInjector(\n      new ConfigModule(cConf, hConf),\n      new LocationRuntimeModule().getDistributedModules(),\n      new IOModule(),\n      new AbstractModule() {\n        @Override\n        protected void configure() {\n\n          // Data-fabric bindings\n          // this makes mapreduce tasks talk to HBase/HDFS directly\n          bind(OperationExecutor.class).\n            to(OmidTransactionalOperationExecutor.class).in(Singleton.class);\n\n          bind(OVCTableHandle.class).to(HBaseOVCTableHandle.class);\n\n          bind(TimestampOracle.class).to(MemoryStrictlyMonotonicTimeOracle.class).in(Singleton.class);\n          bind(TransactionOracle.class).to(MemoryOracle.class).in(Singleton.class);\n\n          bind(Configuration.class).annotatedWith(Names.named(\"HBaseOVCTableHandleHConfig\")).to(Configuration.class);\n          bind(CConfiguration.class).annotatedWith(Names.named(\"HBaseOVCTableHandleCConfig\")).to(CConfiguration.class);\n          bind(CConfiguration.class).annotatedWith(Names.named(\"DataFabricOperationExecutorConfig\")).to\n            (CConfiguration.class);\n\n        }\n      }\n    );\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"private Injector createInMemoryModules() {\n    ImmutableList<Module> inMemoryModules = ImmutableList.of(\n      new BigMamaModule(cConf),\n      new MetricsModules().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new MetadataModules().getInMemoryModules()\n    );\n\n    return Guice.createInjector(inMemoryModules);\n  }","id":35416,"modified_method":"private Injector createInMemoryModules() {\n    ImmutableList<Module> inMemoryModules = ImmutableList.of(\n//      new BigMamaModule(cConf),\n      new ConfigModule(cConf),\n      new IOModule(),\n      new LocationRuntimeModule().getInMemoryModules(),\n      new DiscoveryRuntimeModule().getInMemoryModules(),\n      new ProgramRunnerRuntimeModule().getInMemoryModules(),\n      new DataFabricModules().getInMemoryModules(),\n      new MetadataModules().getInMemoryModules()\n    );\n\n    return Guice.createInjector(inMemoryModules);\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"private Injector createPersistentModules(Constants.InMemoryPersistenceType persistenceType) {\n    ImmutableList<Module> singleNodeModules = ImmutableList.of(\n      new BigMamaModule(cConf),\n      new MetricsModules().getSingleNodeModules(),\n      Constants.InMemoryPersistenceType.LEVELDB == persistenceType ?\n        new DataFabricLevelDBModule(cConf) : new DataFabricModules().getSingleNodeModules(),\n      new MetadataModules().getSingleNodeModules()\n    );\n    return Guice.createInjector(singleNodeModules);\n  }","id":35417,"modified_method":"private Injector createPersistentModules(Constants.InMemoryPersistenceType persistenceType) {\n    ImmutableList<Module> singleNodeModules = ImmutableList.of(\n//      new BigMamaModule(cConf),\n      new ConfigModule(cConf),\n      new IOModule(),\n      new LocationRuntimeModule().getSingleNodeModules(),\n      new DiscoveryRuntimeModule().getSingleNodeModules(),\n      new ProgramRunnerRuntimeModule().getSingleNodeModules(),\n      Constants.InMemoryPersistenceType.LEVELDB == persistenceType ?\n        new DataFabricLevelDBModule(cConf) : new DataFabricModules().getSingleNodeModules(),\n      new MetadataModules().getSingleNodeModules()\n    );\n    return Guice.createInjector(singleNodeModules);\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@Singleton\n  @Provides\n  private LogWriter providesLogWriter(CConfiguration configuration) {\n    return new LocalLogWriter(configuration);\n  }","id":35418,"modified_method":"@Singleton\n  @Provides\n  private LocalLogWriter providesLogWriter(CConfiguration configuration) {\n    return new LocalLogWriter(configuration);\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Configures a {@link com.google.inject.Binder} via the exposed methods.\n   */\n  @Override\n  protected void configure() {\n\n    // Bind ServiceAnnouncer for procedure.\n    bind(ServiceAnnouncer.class).to(DiscoveryServiceAnnouncer.class);\n\n    // Bind ProgramRunner\n    MapBinder<ProgramRunnerFactory.Type, ProgramRunner> runnerFactoryBinder =\n      MapBinder.newMapBinder(binder(), ProgramRunnerFactory.Type.class, ProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.FLOW).to(FlowProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.FLOWLET).to(FlowletProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.PROCEDURE).to(ProcedureProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.MAPREDUCE).to(MapReduceProgramRunner.class);\n\n    bind(ProgramRunnerFactory.class).to(InMemoryFlowProgramRunnerFactory.class).in(Scopes.SINGLETON);\n    // Note: Expose for test cases. Need to refactor test cases.\n    expose(ProgramRunnerFactory.class);\n\n    // Bind and expose runtime service\n    bind(ProgramRuntimeService.class).to(InMemoryProgramRuntimeService.class).in(Scopes.SINGLETON);\n    expose(ProgramRuntimeService.class);\n\n    // Bind MapReduce runtime service\n    bind(MapReduceRuntimeService.class).to(InMemoryMapReduceRuntimeService.class).in(Scopes.SINGLETON);\n    expose(MapReduceRuntimeService.class);\n\n    // For binding DataSet transaction stuff\n    install(new PrivateModule() {\n      @Override\n      protected void configure() {\n        install(new FactoryModuleBuilder()\n                .implement(DataFabricFacade.class, SmartDataFabricFacade.class)\n                .build(DataFabricFacadeFactory.class));\n\n        expose(DataFabricFacadeFactory.class);\n      }\n    });\n\n    // For Binding queue stuff\n    install(new FactoryModuleBuilder()\n            .implement(QueueReader.class, SingleQueueReader.class)\n            .build(QueueReaderFactory.class));\n  }","id":35419,"modified_method":"/**\n   * Configures a {@link com.google.inject.Binder} via the exposed methods.\n   */\n  @Override\n  protected void configure() {\n\n    // Bind and expose LogWriter (a bit hacky, but needed by MapReduce for now)\n    bind(LogWriter.class).to(LocalLogWriter.class);\n    expose(LogWriter.class);\n\n    // Bind ServiceAnnouncer for procedure.\n    bind(ServiceAnnouncer.class).to(DiscoveryServiceAnnouncer.class);\n\n    // Bind ProgramRunner\n    MapBinder<ProgramRunnerFactory.Type, ProgramRunner> runnerFactoryBinder =\n      MapBinder.newMapBinder(binder(), ProgramRunnerFactory.Type.class, ProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.FLOW).to(FlowProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.FLOWLET).to(FlowletProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.PROCEDURE).to(ProcedureProgramRunner.class);\n    runnerFactoryBinder.addBinding(ProgramRunnerFactory.Type.MAPREDUCE).to(MapReduceProgramRunner.class);\n\n    bind(ProgramRunnerFactory.class).to(InMemoryFlowProgramRunnerFactory.class).in(Scopes.SINGLETON);\n    // Note: Expose for test cases. Need to refactor test cases.\n    expose(ProgramRunnerFactory.class);\n\n    // Bind and expose runtime service\n    bind(ProgramRuntimeService.class).to(InMemoryProgramRuntimeService.class).in(Scopes.SINGLETON);\n    expose(ProgramRuntimeService.class);\n\n    // For binding DataSet transaction stuff\n    install(new PrivateModule() {\n      @Override\n      protected void configure() {\n        install(new FactoryModuleBuilder()\n                .implement(DataFabricFacade.class, SmartDataFabricFacade.class)\n                .build(DataFabricFacadeFactory.class));\n\n        expose(DataFabricFacadeFactory.class);\n      }\n    });\n\n    // For Binding queue stuff\n    install(new FactoryModuleBuilder()\n            .implement(QueueReader.class, SingleQueueReader.class)\n            .build(QueueReaderFactory.class));\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void beforeClass() {\n    final Configuration hConf = new Configuration();\n    hConf.addResource(\"mapred-site-local.xml\");\n    hConf.reloadConfiguration();\n\n    injector = Guice.createInjector(new AppFabricTestModule(TestHelper.configuration),\n                                    new Module() {\n                                      @Override\n                                      public void configure(Binder binder) {\n                                        binder.bind(Configuration.class).toInstance(hConf);\n                                      }\n                                    });\n\n  }","id":35420,"modified_method":"@BeforeClass\n  public static void beforeClass() {\n    injector = Guice.createInjector(new AppFabricTestModule(TestHelper.configuration));\n  }","commit_id":"c0c81f5d97609fecdf3f066d7a4df7af4a8eabd0","url":"https://github.com/caskdata/cdap"},{"original_method":"public List<Object> toFileEntriesAndFolders(\n\t\tList<Object> dlFileEntriesAndDLFolders) {\n\n\t\treturn RepositoryModelUtil.toFileEntriesAndFolders(\n\t\t\tdlFileEntriesAndDLFolders);\n\t}","id":35421,"modified_method":"public List<Object> toFileEntriesAndFolders(\n\t\tList<Object> dlFileEntriesAndDLFolders) {\n\n\t\treturn (List)RepositoryModelUtil.toFileEntriesFileShortcutsAndFolders(\n\t\t\tdlFileEntriesAndDLFolders);\n\t}","commit_id":"14af2ad252277301ad2d30a69e960279596209ce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<Object> getFoldersAndFileEntriesAndFileShortcuts(\n\t\t\tlong folderId, int status, boolean includeMountFolders, int start,\n\t\t\tint end, OrderByComparator<?> obc)\n\t\tthrows PortalException {\n\n\t\tList<Object> dlFoldersAndFileEntriesAndFileShortcuts =\n\t\t\tdlFolderService.getFoldersAndFileEntriesAndFileShortcuts(\n\t\t\t\tgetGroupId(), toFolderId(folderId), status, includeMountFolders,\n\t\t\t\tstart, end, obc);\n\n\t\treturn RepositoryModelUtil.toFileEntriesAndFolders(\n\t\t\tdlFoldersAndFileEntriesAndFileShortcuts);\n\t}","id":35422,"modified_method":"@Override\n\tpublic List<Object> getFoldersAndFileEntriesAndFileShortcuts(\n\t\t\tlong folderId, int status, boolean includeMountFolders, int start,\n\t\t\tint end, OrderByComparator<?> obc)\n\t\tthrows PortalException {\n\n\t\tList<Object> dlFoldersAndFileEntriesAndFileShortcuts =\n\t\t\tdlFolderService.getFoldersAndFileEntriesAndFileShortcuts(\n\t\t\t\tgetGroupId(), toFolderId(folderId), status, includeMountFolders,\n\t\t\t\tstart, end, obc);\n\n\t\treturn (List)RepositoryModelUtil.toFileEntriesFileShortcutsAndFolders(\n\t\t\tdlFoldersAndFileEntriesAndFileShortcuts);\n\t}","commit_id":"14af2ad252277301ad2d30a69e960279596209ce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<Object> getFileEntriesAndFileShortcuts(\n\t\t\tlong folderId, int status, int start, int end)\n\t\tthrows PortalException {\n\n\t\tList<Object> dlFileEntriesAndFileShortcuts =\n\t\t\tdlFolderService.getFileEntriesAndFileShortcuts(\n\t\t\t\tgetGroupId(), toFolderId(folderId), status, start, end);\n\n\t\treturn RepositoryModelUtil.toFileEntriesAndFolders(\n\t\t\tdlFileEntriesAndFileShortcuts);\n\t}","id":35423,"modified_method":"@Override\n\tpublic List<Object> getFileEntriesAndFileShortcuts(\n\t\t\tlong folderId, int status, int start, int end)\n\t\tthrows PortalException {\n\n\t\tList<Object> dlFileEntriesAndFileShortcuts =\n\t\t\tdlFolderService.getFileEntriesAndFileShortcuts(\n\t\t\t\tgetGroupId(), toFolderId(folderId), status, start, end);\n\n\t\treturn (List)RepositoryModelUtil.toFileEntriesFileShortcutsAndFolders(\n\t\t\tdlFileEntriesAndFileShortcuts);\n\t}","commit_id":"14af2ad252277301ad2d30a69e960279596209ce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic List<Object> getFoldersAndFileEntriesAndFileShortcuts(\n\t\t\tlong folderId, int status, String[] mimeTypes,\n\t\t\tboolean includeMountFolders, int start, int end,\n\t\t\tOrderByComparator<?> obc)\n\t\tthrows PortalException {\n\n\t\tList<Object> dlFoldersAndFileEntriesAndFileShortcuts =\n\t\t\tdlFolderService.getFoldersAndFileEntriesAndFileShortcuts(\n\t\t\t\tgetGroupId(), toFolderId(folderId), status, mimeTypes,\n\t\t\t\tincludeMountFolders, start, end, obc);\n\n\t\treturn RepositoryModelUtil.toFileEntriesAndFolders(\n\t\t\tdlFoldersAndFileEntriesAndFileShortcuts);\n\t}","id":35424,"modified_method":"@Override\n\tpublic List<Object> getFoldersAndFileEntriesAndFileShortcuts(\n\t\t\tlong folderId, int status, String[] mimeTypes,\n\t\t\tboolean includeMountFolders, int start, int end,\n\t\t\tOrderByComparator<?> obc)\n\t\tthrows PortalException {\n\n\t\tList<Object> dlFoldersAndFileEntriesAndFileShortcuts =\n\t\t\tdlFolderService.getFoldersAndFileEntriesAndFileShortcuts(\n\t\t\t\tgetGroupId(), toFolderId(folderId), status, mimeTypes,\n\t\t\t\tincludeMountFolders, start, end, obc);\n\n\t\treturn (List)RepositoryModelUtil.toFileEntriesFileShortcutsAndFolders(\n\t\t\tdlFoldersAndFileEntriesAndFileShortcuts);\n\t}","commit_id":"14af2ad252277301ad2d30a69e960279596209ce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<Object> toFileEntriesAndFolders(\n\t\tList<Object> dlFileEntriesAndDLFolders) {\n\n\t\tList<Object> fileEntriesAndFolders = new ArrayList<>(\n\t\t\tdlFileEntriesAndDLFolders.size());\n\n\t\tfor (Object object : dlFileEntriesAndDLFolders) {\n\t\t\tif (object instanceof DLFileEntry) {\n\t\t\t\tDLFileEntry dlFileEntry = (DLFileEntry)object;\n\n\t\t\t\tFileEntry fileEntry = new LiferayFileEntry(dlFileEntry);\n\n\t\t\t\tfileEntriesAndFolders.add(fileEntry);\n\t\t\t}\n\t\t\telse if (object instanceof DLFolder) {\n\t\t\t\tDLFolder dlFolder = (DLFolder)object;\n\n\t\t\t\tFolder folder = new LiferayFolder(dlFolder);\n\n\t\t\t\tfileEntriesAndFolders.add(folder);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfileEntriesAndFolders.add(object);\n\t\t\t}\n\t\t}\n\n\t\tif (ListUtil.isUnmodifiableList(dlFileEntriesAndDLFolders)) {\n\t\t\treturn Collections.unmodifiableList(fileEntriesAndFolders);\n\t\t}\n\t\telse {\n\t\t\treturn fileEntriesAndFolders;\n\t\t}\n\t}","id":35425,"modified_method":"public static List<RepositoryEntry> toFileEntriesFileShortcutsAndFolders(\n\t\tList<Object> dlFileEntriesDLFileShortcutsAndDLFolders) {\n\n\t\tList<RepositoryEntry> fileEntriesFileShortcutsAndFolders =\n\t\t\tnew ArrayList<>(\n\t\t\t\tdlFileEntriesDLFileShortcutsAndDLFolders.size());\n\n\t\tfor (Object object : dlFileEntriesDLFileShortcutsAndDLFolders) {\n\t\t\tif (object instanceof DLFileEntry) {\n\t\t\t\tDLFileEntry dlFileEntry = (DLFileEntry)object;\n\n\t\t\t\tFileEntry fileEntry = new LiferayFileEntry(dlFileEntry);\n\n\t\t\t\tfileEntriesFileShortcutsAndFolders.add(fileEntry);\n\t\t\t}\n\t\t\telse if (object instanceof DLFolder) {\n\t\t\t\tDLFolder dlFolder = (DLFolder)object;\n\n\t\t\t\tFolder folder = new LiferayFolder(dlFolder);\n\n\t\t\t\tfileEntriesFileShortcutsAndFolders.add(folder);\n\t\t\t}\n\t\t\telse if (object instanceof DLFileShortcut) {\n\t\t\t\tDLFileShortcut dlFileShortcut = (DLFileShortcut)object;\n\n\t\t\t\tFileShortcut fileShortcut = new LiferayFileShortcut(\n\t\t\t\t\tdlFileShortcut);\n\n\t\t\t\tfileEntriesFileShortcutsAndFolders.add(fileShortcut);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\tString.format(\n\t\t\t\t\t\t\"Expected an instance of one of: %s; got %s\",\n\t\t\t\t\t\tArrays.asList(\n\t\t\t\t\t\t\tDLFileEntry.class.getName(),\n\t\t\t\t\t\t\tDLFolder.class.getName(),\n\t\t\t\t\t\t\tDLFileShortcut.class.getName()),\n\t\t\t\t\t\tobject));\n\t\t\t}\n\t\t}\n\n\t\tif (ListUtil.isUnmodifiableList(\n\t\t\t\tdlFileEntriesDLFileShortcutsAndDLFolders)) {\n\n\t\t\treturn Collections.unmodifiableList(\n\t\t\t\tfileEntriesFileShortcutsAndFolders);\n\t\t}\n\t\telse {\n\t\t\treturn fileEntriesFileShortcutsAndFolders;\n\t\t}\n\t}","commit_id":"14af2ad252277301ad2d30a69e960279596209ce","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void createVolume(String volumeId, int size) throws EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\n\t\tLVMVolumeInfo lvmVolumeInfo = null;\n\t\tif(exportManager instanceof AOEManager) {\n\t\t\tlvmVolumeInfo = new AOEVolumeInfo();\n\t\t} else {\n\t\t\tlvmVolumeInfo = new ISCSIVolumeInfo();\n\t\t}\n\t\tvolumeManager.finish();\n\t\tString rawFileName = DirectStorageInfo.getStorageInfo().getVolumesDir() + \"/\" + volumeId;\n\t\t//create file and attach to loopback device\n\t\tlong absoluteSize = size * StorageProperties.GB + LVM_HEADER_LENGTH;\n\t\ttry {\n\t\t\t//set up LVM\n\t\t\tString vgName = \"vg-\" + Hashes.getRandom(4);\n\t\t\tString lvName = \"lv-\" + Hashes.getRandom(4);\n\t\t\t//create file and attach to loopback device\n\t\t\tString loDevName = createLoopback(rawFileName, absoluteSize);\n\t\t\t//create physical volume, volume group and logical volume\n\t\t\tcreateLogicalVolume(loDevName, vgName, lvName);\n\t\t\tlvmVolumeInfo.setVgName(vgName);\n\t\t\tlvmVolumeInfo.setLvName(lvName);\n\t\t\tlvmVolumeInfo.setPvName(loDevName);\n\t\t\tlvmVolumeInfo.setVolumeId(volumeId);\n\t\t\tlvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\tlvmVolumeInfo.setSize(size);\n\t\t\t//tear down\n\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\tdisableLogicalVolume(absoluteLVName);\n\t\t\tremoveLoopback(loDevName);\n\t\t\tvolumeManager = new VolumeEntityWrapperManager();\n\t\t\tvolumeManager.add(lvmVolumeInfo);\n\t\t\tvolumeManager.finish();\n\t\t} catch(EucalyptusCloudException ex) {\n\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\tvolumeManager.abort();\n\t\t\tLOG.error(error);\n\t\t\tthrow new EucalyptusCloudException(error);\n\t\t}\n\t}","id":35426,"modified_method":"public void createVolume(String volumeId, int size) throws EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\n\t\tLVMVolumeInfo lvmVolumeInfo = null;\n\t\tif(exportManager instanceof AOEManager) {\n\t\t\tlvmVolumeInfo = new AOEVolumeInfo();\n\t\t} else {\n\t\t\tlvmVolumeInfo = new ISCSIVolumeInfo();\n\t\t}\n\t\tvolumeManager.finish();\n\t\tString rawFileName = DirectStorageInfo.getStorageInfo().getVolumesDir() + \"/\" + volumeId;\n\t\t//create file and attach to loopback device\n\t\tlong absoluteSize = size * StorageProperties.GB + LVM_HEADER_LENGTH;\n\t\ttry {\n\t\t\t//set up LVM\n\t\t\tString vgName = \"vg-\" + Hashes.getRandom(4);\n\t\t\tString lvName = \"lv-\" + Hashes.getRandom(4);\n\t\t\t//create file and attach to loopback device\n\t\t\tString loDevName = createLoopback(rawFileName, absoluteSize);\n\t\t\t//create physical volume, volume group and logical volume\n\t\t\tcreateLogicalVolume(loDevName, vgName, lvName);\n\t\t\tlvmVolumeInfo.setVgName(vgName);\n\t\t\tlvmVolumeInfo.setLvName(lvName);\n\t\t\tlvmVolumeInfo.setVolumeId(volumeId);\n\t\t\tlvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\tlvmVolumeInfo.setSize(size);\n\t\t\t//tear down\n\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\tdisableLogicalVolume(absoluteLVName);\n\t\t\tremoveLoopback(loDevName);\n\t\t\tvolumeManager = new VolumeEntityWrapperManager();\n\t\t\tvolumeManager.add(lvmVolumeInfo);\n\t\t\tvolumeManager.finish();\n\t\t} catch(EucalyptusCloudException ex) {\n\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\tvolumeManager.abort();\n\t\t\tLOG.error(error);\n\t\t\tthrow new EucalyptusCloudException(error);\n\t\t}\n\t}","commit_id":"aae085c99509eda36ff85c3cb5cb047ca9ec2b9d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public int createVolume(String volumeId, String snapshotId, int size) throws EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\t\tLVMVolumeInfo foundSnapshotInfo = volumeManager.getVolumeInfo(snapshotId);\n\t\tif(foundSnapshotInfo != null) {\n\t\t\tString status = foundSnapshotInfo.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString())) {\n\t\t\t\tString vgName = \"vg-\" + Hashes.getRandom(4);\n\t\t\t\tString lvName = \"lv-\" + Hashes.getRandom(4);\n\t\t\t\tString loFileName = foundSnapshotInfo.getLoFileName();\n\t\t\t\tString snapId = foundSnapshotInfo.getVolumeId();\n\t\t\t\tLVMVolumeInfo lvmVolumeInfo = volumeManager.getVolumeInfo();\n\t\t\t\tvolumeManager.finish();\n\t\t\t\ttry {\n\t\t\t\t\tString rawFileName = DirectStorageInfo.getStorageInfo().getVolumesDir() + \"/\" + volumeId;\n\t\t\t\t\t//create file and attach to loopback device\n\t\t\t\t\tFile snapshotFile = new File(DirectStorageInfo.getStorageInfo().getVolumesDir() + PATH_SEPARATOR + snapId);\n\t\t\t\t\tassert(snapshotFile.exists());\n\t\t\t\t\tlong absoluteSize;\n\t\t\t\t\tif(size > 0) {\n\t\t\t\t\t\tabsoluteSize = size * StorageProperties.GB + LVM_HEADER_LENGTH;\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsize = (int)(snapshotFile.length() / StorageProperties.GB);\n\t\t\t\t\t\tabsoluteSize = snapshotFile.length() + LVM_HEADER_LENGTH;\n\t\t\t\t\t}\n\t\t\t\t\tString loDevName = createLoopback(rawFileName, absoluteSize);\n\t\t\t\t\t//create physical volume, volume group and logical volume\n\t\t\t\t\tcreateLogicalVolume(loDevName, vgName, lvName);\n\t\t\t\t\t//duplicate snapshot volume\n\t\t\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\t\t\tduplicateLogicalVolume(loFileName, absoluteLVName);\n\t\t\t\t\t//export logical volume\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvolumeManager.exportVolume(lvmVolumeInfo, vgName, lvName);\n\t\t\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\t\t\tString returnValue = removeLogicalVolume(absoluteLVName);\n\t\t\t\t\t\treturnValue = removeVolumeGroup(vgName);\n\t\t\t\t\t\treturnValue = removePhysicalVolume(loDevName);\n\t\t\t\t\t\tremoveLoopback(loDevName);\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t\tlvmVolumeInfo.setVolumeId(volumeId);\n\t\t\t\t\tlvmVolumeInfo.setLoDevName(loDevName);\n\t\t\t\t\tlvmVolumeInfo.setPvName(loDevName);\n\t\t\t\t\tlvmVolumeInfo.setVgName(vgName);\n\t\t\t\t\tlvmVolumeInfo.setLvName(lvName);\n\t\t\t\t\tlvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\t\t\tlvmVolumeInfo.setSize(size);\n\t\t\t\t\tvolumeManager = new VolumeEntityWrapperManager();\n\t\t\t\t\tvolumeManager.add(lvmVolumeInfo);\n\t\t\t\t\tvolumeManager.finish();\n\t\t\t\t}  catch(EucalyptusCloudException ex) {\n\t\t\t\t\tvolumeManager.abort();\n\t\t\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\t\t\tLOG.error(error);\n\t\t\t\t\tthrow new EucalyptusCloudException(error);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvolumeManager.abort();\n\t\t\tthrow new EucalyptusCloudException(\"Unable to find snapshot: \" + snapshotId);\n\t\t}\n\t\treturn size;\n\t}","id":35427,"modified_method":"public int createVolume(String volumeId, String snapshotId, int size) throws EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\t\tLVMVolumeInfo foundSnapshotInfo = volumeManager.getVolumeInfo(snapshotId);\n\t\tif(foundSnapshotInfo != null) {\n\t\t\tString status = foundSnapshotInfo.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString())) {\n\t\t\t\tString vgName = \"vg-\" + Hashes.getRandom(4);\n\t\t\t\tString lvName = \"lv-\" + Hashes.getRandom(4);\n\t\t\t\tString loFileName = foundSnapshotInfo.getLoFileName();\n\t\t\t\tString snapId = foundSnapshotInfo.getVolumeId();\n\t\t\t\tLVMVolumeInfo lvmVolumeInfo = volumeManager.getVolumeInfo();\n\t\t\t\tvolumeManager.finish();\n\t\t\t\ttry {\n\t\t\t\t\tString rawFileName = DirectStorageInfo.getStorageInfo().getVolumesDir() + \"/\" + volumeId;\n\t\t\t\t\t//create file and attach to loopback device\n\t\t\t\t\tFile snapshotFile = new File(DirectStorageInfo.getStorageInfo().getVolumesDir() + PATH_SEPARATOR + snapId);\n\t\t\t\t\tassert(snapshotFile.exists());\n\t\t\t\t\tlong absoluteSize;\n\t\t\t\t\tif(size > 0) {\n\t\t\t\t\t\tabsoluteSize = size * StorageProperties.GB + LVM_HEADER_LENGTH;\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsize = (int)(snapshotFile.length() / StorageProperties.GB);\n\t\t\t\t\t\tabsoluteSize = snapshotFile.length() + LVM_HEADER_LENGTH;\n\t\t\t\t\t}\n\t\t\t\t\tString loDevName = createLoopback(rawFileName, absoluteSize);\n\t\t\t\t\t//create physical volume, volume group and logical volume\n\t\t\t\t\tcreateLogicalVolume(loDevName, vgName, lvName);\n\t\t\t\t\t//duplicate snapshot volume\n\t\t\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\t\t\tduplicateLogicalVolume(loFileName, absoluteLVName);\n\t\t\t\t\tlvmVolumeInfo.setVolumeId(volumeId);\n\t\t\t\t\tlvmVolumeInfo.setVgName(vgName);\n\t\t\t\t\tlvmVolumeInfo.setLvName(lvName);\n\t\t\t\t\tlvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\t\t\tlvmVolumeInfo.setSize(size);\n\t\t\t\t\t//tear down\n\t\t\t\t\tdisableLogicalVolume(absoluteLVName);\n\t\t\t\t\tremoveLoopback(loDevName);\n\t\t\t\t\tvolumeManager = new VolumeEntityWrapperManager();\n\t\t\t\t\tvolumeManager.add(lvmVolumeInfo);\n\t\t\t\t\tvolumeManager.finish();\n\t\t\t\t}  catch(EucalyptusCloudException ex) {\n\t\t\t\t\tvolumeManager.abort();\n\t\t\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\t\t\tLOG.error(error);\n\t\t\t\t\tthrow new EucalyptusCloudException(error);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvolumeManager.abort();\n\t\t\tthrow new EucalyptusCloudException(\"Unable to find snapshot: \" + snapshotId);\n\t\t}\n\t\treturn size;\n\t}","commit_id":"aae085c99509eda36ff85c3cb5cb047ca9ec2b9d","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void deleteSnapshot(String snapshotId) throws EucalyptusCloudException {\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo(snapshotId);\n        LVMVolumeInfo foundLVMVolumeInfo = db.getUnique(lvmVolumeInfo);\n\n        if(foundLVMVolumeInfo != null) {\n            String loDevName = foundLVMVolumeInfo.getLoDevName();\n            String vgName = foundLVMVolumeInfo.getVgName();\n            String lvName = foundLVMVolumeInfo.getLvName();\n            String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\n            String returnValue = removeLogicalVolume(absoluteLVName);\n            if(returnValue.length() == 0) {\n                throw new EucalyptusCloudException(\"Unable to remove logical volume \" + absoluteLVName);\n            }\n            returnValue = reduceVolumeGroup(vgName, loDevName);\n            if(returnValue.length() == 0) {\n                throw new EucalyptusCloudException(\"Unable to reduce volume group \" + vgName + \" logical volume: \" + loDevName);\n            }\n            returnValue = removePhysicalVolume(loDevName);\n            if(returnValue.length() == 0) {\n                throw new EucalyptusCloudException(\"Unable to remove physical volume \" + loDevName);\n            }\n            returnValue = removeLoopback(loDevName);\n            db.delete(foundLVMVolumeInfo);\n            db.commit();\n        }  else {\n            db.rollback();\n            throw new EucalyptusCloudException();\n        }\n    }","id":35428,"modified_method":"public void deleteSnapshot(String snapshotId) throws EucalyptusCloudException {\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo(snapshotId);\n        LVMVolumeInfo foundLVMVolumeInfo = db.getUnique(lvmVolumeInfo);\n\n        if(foundLVMVolumeInfo != null) {\n            String loDevName = foundLVMVolumeInfo.getLoDevName();\n            /*     String vgName = foundLVMVolumeInfo.getVgName();\n          String lvName = foundLVMVolumeInfo.getLvName();\n          String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\n          String returnValue = removeLogicalVolume(absoluteLVName);\n          if(returnValue.length() == 0) {\n              throw new EucalyptusCloudException(\"Unable to remove logical volume \" + absoluteLVName);\n          }\n          returnValue = reduceVolumeGroup(vgName, loDevName);\n          if(returnValue.length() == 0) {\n              throw new EucalyptusCloudException(\"Unable to reduce volume group \" + vgName + \" logical volume: \" + loDevName);\n          }\n          returnValue = removePhysicalVolume(loDevName);\n          if(returnValue.length() == 0) {\n              throw new EucalyptusCloudException(\"Unable to remove physical volume \" + loDevName);\n          }  */\n            String returnValue = removeLoopback(loDevName);\n            db.delete(foundLVMVolumeInfo);\n            db.commit();\n        }  else {\n            db.rollback();\n            throw new EucalyptusCloudException();\n        }\n    }","commit_id":"b898d0a7290ae9426d6e4e479e0c83945f380df1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void cleanSnapshot(String snapshotId) {\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo(snapshotId);\n        List<LVMVolumeInfo> lvmVolumeInfos = db.query(lvmVolumeInfo);\n        if(lvmVolumeInfos.size() > 0) {\n            LVMVolumeInfo lvmVolInfo = lvmVolumeInfos.get(0);\n            String vgName = lvmVolInfo.getVgName();\n            String lvName = lvmVolInfo.getLvName();\n            String loDevName = lvmVolInfo.getLoDevName();\n            String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\n            String returnValue = removeLogicalVolume(absoluteLVName);\n            returnValue = reduceVolumeGroup(vgName, loDevName);\n            returnValue = removePhysicalVolume(loDevName);\n            removeLoopback(loDevName);\n            db.delete(lvmVolInfo);\n            db.commit();\n        }\n    }","id":35429,"modified_method":"public void cleanSnapshot(String snapshotId) {\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo(snapshotId);\n        List<LVMVolumeInfo> lvmVolumeInfos = db.query(lvmVolumeInfo);\n        if(lvmVolumeInfos.size() > 0) {\n            LVMVolumeInfo lvmVolInfo = lvmVolumeInfos.get(0);\n            String loDevName = lvmVolInfo.getLoDevName();\n/*            String vgName = lvmVolInfo.getVgName();\n            String lvName = lvmVolInfo.getLvName();\n            String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\n            String returnValue = removeLogicalVolume(absoluteLVName);\n            returnValue = reduceVolumeGroup(vgName, loDevName);\n            returnValue = removePhysicalVolume(loDevName); */\n            String returnValue = removeLoopback(loDevName);\n            db.delete(lvmVolInfo);\n            db.commit();\n        }\n    }","commit_id":"b898d0a7290ae9426d6e4e479e0c83945f380df1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public int createVolume(String volumeId, String snapshotId, int size) throws EucalyptusCloudException {\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo(snapshotId);\n        LVMVolumeInfo foundSnapshotInfo = db.getUnique(lvmVolumeInfo);\n        if(foundSnapshotInfo != null) {\n            String status = foundSnapshotInfo.getStatus();\n            if(status.equals(StorageProperties.Status.available.toString())) {\n                String vgName = \"vg-\" + Hashes.getRandom(4);\n                String lvName = \"lv-\" + Hashes.getRandom(4);\n                lvmVolumeInfo = new LVMVolumeInfo();\n\n                String rawFileName = StorageProperties.storageRootDirectory + \"/\" + volumeId;\n                //create file and attach to loopback device\n                File snapshotFile = new File(StorageProperties.storageRootDirectory + PATH_SEPARATOR + foundSnapshotInfo.getVolumeId());\n                assert(snapshotFile.exists());\n                size = (int)(snapshotFile.length() / StorageProperties.GB);\n                String loDevName = createLoopback(rawFileName, size);\n                //create physical volume, volume group and logical volume\n                createLogicalVolume(loDevName, vgName, lvName);\n                //duplicate snapshot volume\n                String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n                String absoluteSnapshotLVName = lvmRootDirectory + PATH_SEPARATOR + foundSnapshotInfo.getVgName() +\n                        PATH_SEPARATOR + foundSnapshotInfo.getLvName();\n                duplicateLogicalVolume(absoluteSnapshotLVName, absoluteLVName);\n                //export logical volume\n                try {\n                    int vbladePid = exportVolume(lvmVolumeInfo, vgName, lvName);\n                    if(vbladePid < 0) {\n                        throw new EucalyptusCloudException();\n                    }\n                } catch(EucalyptusCloudException ex) {\n                    String returnValue = removeLogicalVolume(absoluteLVName);\n                    returnValue = removeVolumeGroup(vgName);\n                    returnValue = removePhysicalVolume(loDevName);\n                    removeLoopback(loDevName);\n                    throw ex;\n                }\n                lvmVolumeInfo.setVolumeId(volumeId);\n                lvmVolumeInfo.setLoDevName(loDevName);\n                lvmVolumeInfo.setPvName(loDevName);\n                lvmVolumeInfo.setVgName(vgName);\n                lvmVolumeInfo.setLvName(lvName);\n                lvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n                lvmVolumeInfo.setSize(size);\n                db.add(lvmVolumeInfo);\n                db.commit();\n            }\n        } else {\n            db.rollback();\n            throw new EucalyptusCloudException();\n        }\n        return size;\n    }","id":35430,"modified_method":"public int createVolume(String volumeId, String snapshotId, int size) throws EucalyptusCloudException {\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo(snapshotId);\n        LVMVolumeInfo foundSnapshotInfo = db.getUnique(lvmVolumeInfo);\n        if(foundSnapshotInfo != null) {\n            String status = foundSnapshotInfo.getStatus();\n            if(status.equals(StorageProperties.Status.available.toString())) {\n                String vgName = \"vg-\" + Hashes.getRandom(4);\n                String lvName = \"lv-\" + Hashes.getRandom(4);\n                lvmVolumeInfo = new LVMVolumeInfo();\n\n                String rawFileName = StorageProperties.storageRootDirectory + \"/\" + volumeId;\n                //create file and attach to loopback device\n                File snapshotFile = new File(StorageProperties.storageRootDirectory + PATH_SEPARATOR + foundSnapshotInfo.getVolumeId());\n                assert(snapshotFile.exists());\n                long absoluteSize = snapshotFile.length() + LVM_HEADER_LENGTH;\n                size = (int)(snapshotFile.length() / StorageProperties.GB);\n                String loDevName = createLoopback(rawFileName, absoluteSize);\n                //create physical volume, volume group and logical volume\n                createLogicalVolume(loDevName, vgName, lvName);\n                //duplicate snapshot volume\n                String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n                duplicateLogicalVolume(foundSnapshotInfo.getLoDevName(), absoluteLVName);\n                //export logical volume\n                try {\n                    int vbladePid = exportVolume(lvmVolumeInfo, vgName, lvName);\n                    if(vbladePid < 0) {\n                        throw new EucalyptusCloudException();\n                    }\n                } catch(EucalyptusCloudException ex) {\n                    String returnValue = removeLogicalVolume(absoluteLVName);\n                    returnValue = removeVolumeGroup(vgName);\n                    returnValue = removePhysicalVolume(loDevName);\n                    removeLoopback(loDevName);\n                    throw ex;\n                }\n                lvmVolumeInfo.setVolumeId(volumeId);\n                lvmVolumeInfo.setLoDevName(loDevName);\n                lvmVolumeInfo.setPvName(loDevName);\n                lvmVolumeInfo.setVgName(vgName);\n                lvmVolumeInfo.setLvName(lvName);\n                lvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n                lvmVolumeInfo.setSize(size);\n                db.add(lvmVolumeInfo);\n                db.commit();\n            }\n        } else {\n            db.rollback();\n            throw new EucalyptusCloudException();\n        }\n        return size;\n    }","commit_id":"b898d0a7290ae9426d6e4e479e0c83945f380df1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void createVolume(String volumeId, int size) throws EucalyptusCloudException {\n        File volumeDir = new File(StorageProperties.storageRootDirectory);\n        volumeDir.mkdirs();\n\n        String vgName = \"vg-\" + Hashes.getRandom(4);\n        String lvName = \"lv-\" + Hashes.getRandom(4);\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo();\n\n        String rawFileName = StorageProperties.storageRootDirectory + \"/\" + volumeId;\n        //create file and attach to loopback device\n        String loDevName = createLoopback(rawFileName, size);\n        //create physical volume, volume group and logical volume\n        createLogicalVolume(loDevName, vgName, lvName);\n        //export logical volume\n        try {\n            int vbladePid = exportVolume(lvmVolumeInfo, vgName, lvName);\n            if(vbladePid < 0) {\n                throw new EucalyptusCloudException();\n            }\n        } catch(EucalyptusCloudException ex) {\n            LOG.error(ex);\n            String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n            String returnValue = removeLogicalVolume(absoluteLVName);\n            returnValue = removeVolumeGroup(vgName);\n            returnValue = removePhysicalVolume(loDevName);\n            removeLoopback(loDevName);\n            throw ex;\n        }\n\n        lvmVolumeInfo.setVolumeId(volumeId);\n        lvmVolumeInfo.setLoDevName(loDevName);\n        lvmVolumeInfo.setPvName(loDevName);\n        lvmVolumeInfo.setVgName(vgName);\n        lvmVolumeInfo.setLvName(lvName);\n        lvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n        lvmVolumeInfo.setSize(size);\n\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        db.add(lvmVolumeInfo);\n        db.commit();\n    }","id":35431,"modified_method":"public void createVolume(String volumeId, int size) throws EucalyptusCloudException {\n        File volumeDir = new File(StorageProperties.storageRootDirectory);\n        volumeDir.mkdirs();\n\n        String vgName = \"vg-\" + Hashes.getRandom(4);\n        String lvName = \"lv-\" + Hashes.getRandom(4);\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo();\n\n        String rawFileName = StorageProperties.storageRootDirectory + \"/\" + volumeId;\n        //create file and attach to loopback device\n        long absoluteSize = size * StorageProperties.GB + LVM_HEADER_LENGTH;\n        String loDevName = createLoopback(rawFileName, absoluteSize);\n        //create physical volume, volume group and logical volume\n        createLogicalVolume(loDevName, vgName, lvName);\n        //export logical volume\n        try {\n            int vbladePid = exportVolume(lvmVolumeInfo, vgName, lvName);\n            if(vbladePid < 0) {\n                throw new EucalyptusCloudException();\n            }\n        } catch(EucalyptusCloudException ex) {\n            LOG.error(ex);\n            String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n            String returnValue = removeLogicalVolume(absoluteLVName);\n            returnValue = removeVolumeGroup(vgName);\n            returnValue = removePhysicalVolume(loDevName);\n            removeLoopback(loDevName);\n            throw ex;\n        }\n\n        lvmVolumeInfo.setVolumeId(volumeId);\n        lvmVolumeInfo.setLoDevName(loDevName);\n        lvmVolumeInfo.setPvName(loDevName);\n        lvmVolumeInfo.setVgName(vgName);\n        lvmVolumeInfo.setLvName(lvName);\n        lvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n        lvmVolumeInfo.setSize(size);\n\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        db.add(lvmVolumeInfo);\n        db.commit();\n    }","commit_id":"b898d0a7290ae9426d6e4e479e0c83945f380df1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public List<String> createSnapshot(String volumeId, String snapshotId) throws EucalyptusCloudException {\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo(volumeId);\n        LVMVolumeInfo foundLVMVolumeInfo = db.getUnique(lvmVolumeInfo);\n        ArrayList<String> returnValues = new ArrayList<String>();\n        if(foundLVMVolumeInfo != null) {\n            LVMVolumeInfo snapshotInfo = new LVMVolumeInfo(snapshotId);\n            snapshotInfo.setSnapshotOf(volumeId);\n            File snapshotDir = new File(StorageProperties.storageRootDirectory);\n            snapshotDir.mkdirs();\n\n            String vgName = foundLVMVolumeInfo.getVgName();\n            String lvName = \"lv-snap-\" + Hashes.getRandom(4);\n            String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + foundLVMVolumeInfo.getLvName();\n\n            int size = foundLVMVolumeInfo.getSize();\n            String rawFileName = StorageProperties.storageRootDirectory + \"/\" + snapshotId;\n            //create file and attach to loopback device\n            String loDevName = createLoopback(rawFileName, size);\n            //create physical volume, volume group and logical volume\n            createSnapshotLogicalVolume(loDevName, vgName, absoluteLVName, lvName);\n\n            snapshotInfo.setLoDevName(loDevName);\n            snapshotInfo.setPvName(loDevName);\n            snapshotInfo.setVgName(vgName);\n            snapshotInfo.setLvName(lvName);\n            snapshotInfo.setStatus(StorageProperties.Status.available.toString());\n            snapshotInfo.setVbladePid(-1);\n            snapshotInfo.setSize(size);\n            returnValues.add(vgName);\n            returnValues.add(lvName);\n            db.add(snapshotInfo);\n        }\n        db.commit();\n        return returnValues;\n    }","id":35432,"modified_method":"public List<String> createSnapshot(String volumeId, String snapshotId) throws EucalyptusCloudException {\n        EntityWrapper<LVMVolumeInfo> db = new EntityWrapper<LVMVolumeInfo>();\n        LVMVolumeInfo lvmVolumeInfo = new LVMVolumeInfo(volumeId);\n        LVMVolumeInfo foundLVMVolumeInfo = db.getUnique(lvmVolumeInfo);\n        ArrayList<String> returnValues = new ArrayList<String>();\n        if(foundLVMVolumeInfo != null) {\n            LVMVolumeInfo snapshotInfo = new LVMVolumeInfo(snapshotId);\n            snapshotInfo.setSnapshotOf(volumeId);\n            File snapshotDir = new File(StorageProperties.storageRootDirectory);\n            snapshotDir.mkdirs();\n\n            String vgName = foundLVMVolumeInfo.getVgName();\n            String lvName = \"lv-snap-\" + Hashes.getRandom(4);\n            String absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + foundLVMVolumeInfo.getLvName();\n\n            int size = foundLVMVolumeInfo.getSize();\n            long snapshotSize = (size * StorageProperties.GB) / 2;\n            String rawFileName = StorageProperties.storageRootDirectory + \"/\" + volumeId + Hashes.getRandom(6);\n            //create file and attach to loopback device\n            String loDevName = createLoopback(rawFileName, snapshotSize);\n            //create physical volume, volume group and logical volume\n            createSnapshotLogicalVolume(loDevName, vgName, absoluteLVName, lvName);\n\n            String snapRawFileName = StorageProperties.storageRootDirectory + \"/\" + snapshotId;\n            String snapLoDevName = createLoopback(snapRawFileName, size);\n            duplicateLogicalVolume(absoluteLVName, snapLoDevName);\n\n            String absoluteSnapLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\n            String returnValue = removeLogicalVolume(absoluteSnapLVName);\n            if(returnValue.length() == 0) {\n                throw new EucalyptusCloudException(\"Unable to remove logical volume \" + absoluteSnapLVName);\n            }\n            returnValue = reduceVolumeGroup(vgName, loDevName);\n            if(returnValue.length() == 0) {\n                throw new EucalyptusCloudException(\"Unable to reduce volume group \" + vgName + \" logical volume: \" + loDevName);\n            }\n            returnValue = removePhysicalVolume(loDevName);\n            if(returnValue.length() == 0) {\n                throw new EucalyptusCloudException(\"Unable to remove physical volume \" + loDevName);\n            }\n            returnValue = removeLoopback(loDevName);            \n\n            snapshotInfo.setLoDevName(snapLoDevName);\n            snapshotInfo.setStatus(StorageProperties.Status.available.toString());\n            snapshotInfo.setVbladePid(-1);\n            snapshotInfo.setSize(size);\n            returnValues.add(vgName);\n            returnValues.add(lvName);\n            db.add(snapshotInfo);\n        }\n        db.commit();\n        return returnValues;\n    }","commit_id":"b898d0a7290ae9426d6e4e479e0c83945f380df1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void run() {\n            try {\n                EntityWrapper<SnapshotInfo>dbS = new EntityWrapper<SnapshotInfo>();\n                EntityWrapper<VolumeInfo> dbVol = dbS.recast(VolumeInfo.class);\n                VolumeInfo vInfo = new VolumeInfo(volumeId);\n                VolumeInfo originalVolInfo = dbVol.getUnique(vInfo);\n\n                SnapshotInfo snapInfo = new SnapshotInfo(snapshotId);\n                SnapshotInfo foundSnapInfo = dbS.getUnique(snapInfo);\n                String dupedVolumeId;\n                if(originalVolInfo.getDupedVolumeId() == null) {\n                    //dup it so parent vol can be treated independently\n                    dupedVolumeId = volumeId + \"-\" + Hashes.getRandom(6);\n                    originalVolInfo.setDupedVolumeId(dupedVolumeId);\n                    foundSnapInfo.setDupedVolumeId(dupedVolumeId);\n                    blockManager.dupVolume(volumeId, dupedVolumeId);\n                    volumeId = dupedVolumeId;\n                } else {\n                    volumeId = originalVolInfo.getDupedVolumeId();\n                }\n                dbS.commit();\n                blockManager.createSnapshot(volumeId, snapshotId);\n                if(sharedMode) {\n                    EntityWrapper<SnapshotInfo> dbSnap = new EntityWrapper<SnapshotInfo>();\n                    SnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n                    SnapshotInfo foundSnapshotInfo = dbSnap.getUnique(snapshotInfo);\n                    foundSnapshotInfo.setProgress(\"100\");\n                    foundSnapshotInfo.setTransferred(true);\n                    foundSnapshotInfo.setStatus(StorageProperties.Status.available.toString());\n                    dbSnap.commit();\n                    return;\n                } else {\n                    List<String> returnValues = blockManager.prepareForTransfer(volumeId, snapshotId);\n                    volumeFileName = returnValues.get(0);\n                    snapshotFileName = returnValues.get(1);\n                    EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n                    VolumeInfo volumeInfo = new VolumeInfo(volumeId);\n                    List <VolumeInfo> volumeInfos = db.query(volumeInfo);\n\n                    boolean shouldTransferVolume = false;\n                    if(volumeInfos.size() > 0) {\n                        VolumeInfo foundVolumeInfo = volumeInfos.get(0);\n                        if(!foundVolumeInfo.getTransferred()) {\n                            //transfer volume to Walrus\n                            foundVolumeInfo.setVolumeBucket(volumeBucket);\n                            shouldTransferVolume = true;\n                        }\n                        volumeBucket = foundVolumeInfo.getVolumeBucket();\n                        db.commit();\n                        EntityWrapper<SnapshotInfo> db2 = new EntityWrapper<SnapshotInfo>();\n                        SnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n                        SnapshotInfo foundSnapshotInfo = db2.getUnique(snapshotInfo);\n                        if(foundSnapshotInfo != null) {\n                            transferSnapshot(shouldTransferVolume);\n                        }\n                        db2.commit();\n                    } else {\n                        db.rollback();\n                        throw new EucalyptusCloudException(\"Volume not found \" + volumeId);\n                    }\n                }\n            } catch(EucalyptusCloudException ex) {\n                LOG.error(ex);\n            }\n        }","id":35433,"modified_method":"public void run() {\n            try {\n                blockManager.createSnapshot(volumeId, snapshotId);\n                if(sharedMode) {\n                    EntityWrapper<SnapshotInfo> dbSnap = new EntityWrapper<SnapshotInfo>();\n                    SnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n                    SnapshotInfo foundSnapshotInfo = dbSnap.getUnique(snapshotInfo);\n                    foundSnapshotInfo.setProgress(\"100\");\n                    foundSnapshotInfo.setTransferred(true);\n                    foundSnapshotInfo.setStatus(StorageProperties.Status.available.toString());\n                    dbSnap.commit();\n                    return;\n                } else {\n                    List<String> returnValues = blockManager.prepareForTransfer(volumeId, snapshotId);\n                    volumeFileName = returnValues.get(0);\n                    snapshotFileName = returnValues.get(1);\n                    EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n                    VolumeInfo volumeInfo = new VolumeInfo(volumeId);\n                    List <VolumeInfo> volumeInfos = db.query(volumeInfo);\n\n                    boolean shouldTransferVolume = false;\n                    if(volumeInfos.size() > 0) {\n                        VolumeInfo foundVolumeInfo = volumeInfos.get(0);\n                        if(!foundVolumeInfo.getTransferred()) {\n                            //transfer volume to Walrus\n                            foundVolumeInfo.setVolumeBucket(volumeBucket);\n                            shouldTransferVolume = true;\n                        }\n                        volumeBucket = foundVolumeInfo.getVolumeBucket();\n                        db.commit();\n                        EntityWrapper<SnapshotInfo> db2 = new EntityWrapper<SnapshotInfo>();\n                        SnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n                        SnapshotInfo foundSnapshotInfo = db2.getUnique(snapshotInfo);\n                        if(foundSnapshotInfo != null) {\n                            transferSnapshot(shouldTransferVolume);\n                        }\n                        db2.commit();\n                    } else {\n                        db.rollback();\n                        throw new EucalyptusCloudException(\"Volume not found \" + volumeId);\n                    }\n                }\n            } catch(EucalyptusCloudException ex) {\n                LOG.error(ex);\n            }\n        }","commit_id":"b898d0a7290ae9426d6e4e479e0c83945f380df1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteStorageVolumeResponseType DeleteStorageVolume(DeleteStorageVolumeType request) throws EucalyptusCloudException {\n        DeleteStorageVolumeResponseType reply = (DeleteStorageVolumeResponseType) request.getReply();\n        if(!enableStorage) {\n            LOG.error(\"Storage has been disabled. Please check your setup\");\n            return reply;\n        }\n\n        String volumeId = request.getVolumeId();\n\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n        VolumeInfo volumeInfo = new VolumeInfo();\n        volumeInfo.setVolumeId(volumeId);\n        List<VolumeInfo> volumeList = db.query(volumeInfo);\n\n        reply.set_return(Boolean.FALSE);\n        if(volumeList.size() > 0) {\n            VolumeInfo foundVolume = volumeList.get(0);\n            //check its status\n            String status = foundVolume.getStatus();\n            if(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n                try {\n                    blockManager.deleteVolume(volumeId);\n                    volumeStorageManager.deleteObject(\"\", volumeId);\n                    db.delete(foundVolume);\n                    db.commit();\n                } catch (IOException ex) {\n                    LOG.error(ex);\n                }\n            } else {\n                db.rollback();\n                throw new VolumeInUseException(volumeId);\n            }\n        } else {\n            db.rollback();\n            throw new NoSuchVolumeException(volumeId);\n        }\n        SnapshotInfo snapInfo = new SnapshotInfo();\n        snapInfo.setVolumeId(volumeId);\n        EntityWrapper<SnapshotInfo> dbSnap = new EntityWrapper<SnapshotInfo>();\n        List<SnapshotInfo> snapInfos = dbSnap.query(snapInfo);\n        for(SnapshotInfo snapshotInfo : snapInfos) {\n            String snapshotId = snapInfo.getSnapshotId();\n            String status = snapshotInfo.getStatus();\n            if(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n                try {\n                    blockManager.deleteSnapshot(snapshotId);\n                    snapshotStorageManager.deleteObject(\"\", snapshotId);\n                    dbSnap.delete(snapshotInfo);\n                } catch (IOException ex) {\n                    LOG.error(\"Could not delete snapshot \" + snapshotId + ex);\n                }\n            }\n        }\n        dbSnap.commit();\n        return reply;\n    }","id":35434,"modified_method":"public DeleteStorageVolumeResponseType DeleteStorageVolume(DeleteStorageVolumeType request) throws EucalyptusCloudException {\n        DeleteStorageVolumeResponseType reply = (DeleteStorageVolumeResponseType) request.getReply();\n        if(!enableStorage) {\n            LOG.error(\"Storage has been disabled. Please check your setup\");\n            return reply;\n        }\n\n        String volumeId = request.getVolumeId();\n\n        EntityWrapper<VolumeInfo> db = new EntityWrapper<VolumeInfo>();\n        VolumeInfo volumeInfo = new VolumeInfo();\n        volumeInfo.setVolumeId(volumeId);\n        List<VolumeInfo> volumeList = db.query(volumeInfo);\n\n        reply.set_return(Boolean.FALSE);\n        if(volumeList.size() > 0) {\n            VolumeInfo foundVolume = volumeList.get(0);\n            //check its status\n            String status = foundVolume.getStatus();\n            if(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n                try {\n                    blockManager.deleteVolume(volumeId);\n                    volumeStorageManager.deleteObject(\"\", volumeId);\n                    db.delete(foundVolume);\n                    db.commit();\n                } catch (IOException ex) {\n                    LOG.error(ex);\n                }\n            } else {\n                db.rollback();\n                throw new VolumeInUseException(volumeId);\n            }\n        } else {\n            db.rollback();\n            throw new NoSuchVolumeException(volumeId);\n        }\n        return reply;\n    }","commit_id":"b898d0a7290ae9426d6e4e479e0c83945f380df1","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void createVolume(String volumeId, int size) throws EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\n\t\tLVMVolumeInfo lvmVolumeInfo = null;\n\t\tif(exportManager instanceof AOEManager) {\n\t\t\tlvmVolumeInfo = new AOEVolumeInfo();\n\t\t} else {\n\t\t\tlvmVolumeInfo = new ISCSIVolumeInfo();\n\t\t}\n\t\tvolumeManager.finish();\n\t\tString rawFileName = DirectStorageInfo.getStorageInfo().getVolumesDir() + \"/\" + volumeId;\n\t\t//create file and attach to loopback device\n\t\tlong absoluteSize = size * StorageProperties.GB + LVM_HEADER_LENGTH;\n\t\ttry {\n\t\t\t//set up LVM\n\t\t\tString vgName = \"vg-\" + Hashes.getRandom(4);\n\t\t\tString lvName = \"lv-\" + Hashes.getRandom(4);\n\t\t\t//create file and attach to loopback device\n\t\t\tString loDevName = createLoopback(rawFileName, absoluteSize);\n\t\t\t//create physical volume, volume group and logical volume\n\t\t\tcreateLogicalVolume(loDevName, vgName, lvName);\n\t\t\tlvmVolumeInfo.setVgName(vgName);\n\t\t\tlvmVolumeInfo.setLvName(lvName);\n\t\t\tlvmVolumeInfo.setVolumeId(volumeId);\n\t\t\tlvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\tlvmVolumeInfo.setSize(size);\n\t\t\t//tear down\n\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\tdisableLogicalVolume(absoluteLVName);\n\t\t\tremoveLoopback(loDevName);\n\t\t\tvolumeManager = new VolumeEntityWrapperManager();\n\t\t\tvolumeManager.add(lvmVolumeInfo);\n\t\t\tvolumeManager.finish();\n\t\t} catch(EucalyptusCloudException ex) {\n\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\tvolumeManager.abort();\n\t\t\tLOG.error(error);\n\t\t\tthrow new EucalyptusCloudException(error);\n\t\t}\n\t}","id":35435,"modified_method":"public void createVolume(String volumeId, int size) throws EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\n\t\tLVMVolumeInfo lvmVolumeInfo = null;\n\t\tif(exportManager instanceof AOEManager) {\n\t\t\tlvmVolumeInfo = new AOEVolumeInfo();\n\t\t} else {\n\t\t\tlvmVolumeInfo = new ISCSIVolumeInfo();\n\t\t}\n\t\tvolumeManager.finish();\n\t\tString rawFileName = DirectStorageInfo.getStorageInfo().getVolumesDir() + \"/\" + volumeId;\n\t\t//create file and attach to loopback device\n\t\tlong absoluteSize = size * StorageProperties.GB + LVM_HEADER_LENGTH;\n\t\ttry {\n\t\t\t//set up LVM\n\t\t\tString vgName = \"vg-\" + Hashes.getRandom(4);\n\t\t\tString lvName = \"lv-\" + Hashes.getRandom(4);\n\t\t\t//create file and attach to loopback device\n\t\t\tString loDevName = createLoopback(rawFileName, absoluteSize);\n\t\t\t//create physical volume, volume group and logical volume\n\t\t\tcreateLogicalVolume(loDevName, vgName, lvName);\n\t\t\tlvmVolumeInfo.setVgName(vgName);\n\t\t\tlvmVolumeInfo.setLvName(lvName);\n\t\t\tlvmVolumeInfo.setPvName(loDevName);\n\t\t\tlvmVolumeInfo.setVolumeId(volumeId);\n\t\t\tlvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\tlvmVolumeInfo.setSize(size);\n\t\t\t//tear down\n\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\tdisableLogicalVolume(absoluteLVName);\n\t\t\tremoveLoopback(loDevName);\n\t\t\tvolumeManager = new VolumeEntityWrapperManager();\n\t\t\tvolumeManager.add(lvmVolumeInfo);\n\t\t\tvolumeManager.finish();\n\t\t} catch(EucalyptusCloudException ex) {\n\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\tvolumeManager.abort();\n\t\t\tLOG.error(error);\n\t\t\tthrow new EucalyptusCloudException(error);\n\t\t}\n\t}","commit_id":"e21e49117a32f4d3dec9443713001a860b7763c7","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void detachVolume(String volumeId, String nodeIqn)\n\tthrows EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\t\tLVMVolumeInfo foundLVMVolumeInfo = volumeManager.getVolumeInfo(volumeId);\n\t\tif(foundLVMVolumeInfo != null) {\n\t\t\tString loDevName = foundLVMVolumeInfo.getLoDevName();\n\t\t\tString vgName = foundLVMVolumeInfo.getVgName();\n\t\t\tString lvName = foundLVMVolumeInfo.getLvName();\n\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\tvolumeManager.unexportVolume(foundLVMVolumeInfo);\n\t\t\ttry {\n\t\t\t\tdeleteLogicalVolume(loDevName, vgName, absoluteLVName);\n\t\t\t\tremoveLoopback(loDevName);\n\t\t\t\tif(getLoopback(loDevName).length() != 0) {\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to remove loopback device: \" + loDevName);\n\t\t\t\t} else {\n\t\t\t\t\tLOG.info(loDevName + \"was removed.\");\n\t\t\t\t}\n\t\t\t\tvolumeManager.finish();\n\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\tvolumeManager.abort();\n\t\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\t\tLOG.error(error);\n\t\t\t\tthrow new EucalyptusCloudException(error);\n\t\t\t}\n\t\t}  else {\n\t\t\tvolumeManager.abort();\n\t\t\tthrow new EucalyptusCloudException(\"Unable to find volume: \" + volumeId);\n\t\t}\n\t}","id":35436,"modified_method":"@Override\n\tpublic void detachVolume(String volumeId, String nodeIqn)\n\tthrows EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\t\tLVMVolumeInfo foundLVMVolumeInfo = volumeManager.getVolumeInfo(volumeId);\n\t\tif(foundLVMVolumeInfo != null) {\n\t\t\tString loDevName = foundLVMVolumeInfo.getLoDevName();\n\t\t\tString vgName = foundLVMVolumeInfo.getVgName();\n\t\t\tString lvName = foundLVMVolumeInfo.getLvName();\n\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\tvolumeManager.unexportVolume(foundLVMVolumeInfo);\n                        disableLogicalVolume(absoluteLVName);\n\t\t\tdeleteLogicalVolume(loDevName, vgName, absoluteLVName);\n                        removeLoopback(loDevName);\n\t\t\tvolumeManager.finish();\n\t\t}  else {\n\t\t\tvolumeManager.abort();\n\t\t\tthrow new EucalyptusCloudException(\"Unable to find volume: \" + volumeId);\n\t\t}\n\t}","commit_id":"e21e49117a32f4d3dec9443713001a860b7763c7","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic String attachVolume(String volumeId, List<String> nodeIqns)\n\tthrows EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n\n\t\tString vgName = \"vg-\" + Hashes.getRandom(4);\n\t\tString lvName = \"lv-\" + Hashes.getRandom(4);\n\t\tLVMVolumeInfo lvmVolumeInfo = null;\n\t\tif(exportManager instanceof AOEManager) {\n\t\t\tlvmVolumeInfo = new AOEVolumeInfo();\n\t\t} else {\n\t\t\tlvmVolumeInfo = new ISCSIVolumeInfo();\n\t\t}\n\t\tvolumeManager.finish();\n\t\tString rawFileName = DirectStorageInfo.getStorageInfo().getVolumesDir() + \"/\" + volumeId;\n\t\t//create file and attach to loopback device\n\t\tlong absoluteSize = lvmVolumeInfo.getSize() * StorageProperties.GB + LVM_HEADER_LENGTH;\n\t\ttry {\n\t\t\tString loDevName = createLoopback(rawFileName);\n\t\t\t//create physical volume, volume group and logical volume\n\t\t\tcreateLogicalVolume(loDevName, vgName, lvName);\n\t\t\t//export logical volume\n\t\t\ttry {\n\t\t\t\tvolumeManager.exportVolume(lvmVolumeInfo, vgName, lvName);\n\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\tLOG.error(ex);\n\t\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\t\tString returnValue = removeLogicalVolume(absoluteLVName);\n\t\t\t\treturnValue = removeVolumeGroup(vgName);\n\t\t\t\treturnValue = removePhysicalVolume(loDevName);\n\t\t\t\tremoveLoopback(loDevName);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tlvmVolumeInfo.setLoDevName(loDevName);\n\t\t\tlvmVolumeInfo.setPvName(loDevName);\n\t\t\tlvmVolumeInfo.setVgName(vgName);\n\t\t\tlvmVolumeInfo.setLvName(lvName);\n\t\t\tlvmVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\tvolumeManager = new VolumeEntityWrapperManager();\n\t\t\tvolumeManager.add(lvmVolumeInfo);\n\t\t\tvolumeManager.finish();\n\t\t} catch(EucalyptusCloudException ex) {\n\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\tvolumeManager.abort();\n\t\t\tLOG.error(error);\n\t\t\tthrow new EucalyptusCloudException(error);\n\t\t}\n\t\treturn getVolumeProperty(volumeId);\n\t}","id":35437,"modified_method":"@Override\n\tpublic String attachVolume(String volumeId, List<String> nodeIqns)\n\tthrows EucalyptusCloudException {\n\t\tVolumeEntityWrapperManager volumeManager = new VolumeEntityWrapperManager();\n                LVMVolumeInfo lvmVolumeInfo = volumeManager.getVolumeInfo(volumeId);\n                if(lvmVolumeInfo != null) {\n\t\t//create file and attach to loopback device\n\t\tlong absoluteSize = lvmVolumeInfo.getSize() * StorageProperties.GB + LVM_HEADER_LENGTH;\n\t\tString rawFileName = DirectStorageInfo.getStorageInfo().getVolumesDir() + \"/\" + volumeId;\n\t\ttry {\n\t\t\tString loDevName = createLoopback(rawFileName);\n\t\t\tString vgName = lvmVolumeInfo.getVgName();\n\t\t\tString lvName = lvmVolumeInfo.getLvName();\n\t\t\tString absoluteLVName = lvmRootDirectory + PATH_SEPARATOR + vgName + PATH_SEPARATOR + lvName;\n\t\t\tlvmVolumeInfo.setLoDevName(loDevName);\n\t\t\tenableLogicalVolume(absoluteLVName);\n\t\t\t//export logical volume\n\t\t\ttry {\n\t\t\t\tvolumeManager.exportVolume(lvmVolumeInfo, vgName, lvName);\n\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\tLOG.error(ex);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tvolumeManager.finish();\n\t\t} catch(EucalyptusCloudException ex) {\n\t\t\tString error = \"Unable to run command: \" + ex.getMessage();\n\t\t\tvolumeManager.abort();\n\t\t\tLOG.error(error);\n\t\t\tthrow new EucalyptusCloudException(error);\n\t\t}\n\t\t}\n\t\treturn getVolumeProperty(volumeId);\n\t}","commit_id":"e21e49117a32f4d3dec9443713001a860b7763c7","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DetachVolumeResponseType detach( DetachVolumeType request ) throws EucalyptusCloudException {\n    DetachVolumeResponseType reply = ( DetachVolumeResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    \n    Volume vol;\n    try {\n      vol = Volumes.lookup( ctx.getUserFullName( ).asAccountFullName( ), request.getVolumeId( ) );\n    } catch ( Exception ex1 ) {\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId( ) );\n    }\n    if ( !RestrictedTypes.filterPrivileged( ).apply( vol ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to detach volume \" + request.getVolumeId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    \n    VmInstance vm = null;\n    AttachedVolume volume = null;\n    try {\n      VmVolumeAttachment vmVolAttach = VmInstances.lookupVolumeAttachment( request.getVolumeId( ) );\n      volume = VmVolumeAttachment.asAttachedVolume( vmVolAttach.getVmInstance( ) ).apply( vmVolAttach );\n      vm = vmVolAttach.getVmInstance( );\n    } catch ( NoSuchElementException ex ) {\n      /** no such attachment **/\n    }\n    if ( volume == null ) {\n      throw new EucalyptusCloudException( \"Volume is not attached: \" + request.getVolumeId( ) );\n    }\n    if ( !RestrictedTypes.filterPrivileged( ).apply( vm ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to detach volume from instance \" + request.getInstanceId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    if ( !vm.getInstanceId( ).equals( request.getInstanceId( ) ) && request.getInstanceId( ) != null && !request.getInstanceId( ).equals( \"\" ) ) {\n      throw new EucalyptusCloudException( \"Volume is not attached to instance: \" + request.getInstanceId( ) );\n    }\n    if ( request.getDevice( ) != null && !request.getDevice( ).equals( \"\" ) && !volume.getDevice( ).equals( request.getDevice( ) ) ) {\n      throw new EucalyptusCloudException( \"Volume is not attached to device: \" + request.getDevice( ) );\n    }\n    ServiceConfiguration scVm;\n    try {\n      scVm = Topology.lookup( Storage.class, vm.lookupPartition( ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex, ex );\n      throw new EucalyptusCloudException( \"Failed to lookup SC for partition: \" + vm.getPartition( ), ex );\n    }\n    if ( VmState.STOPPED.equals( vm.getState( ) ) ) {\n    \ttry {\n    \t\tAsyncRequests.sendSync( scVm, new DetachStorageVolumeType( volume.getVolumeId( ) ) );\n    \t} catch ( Exception e ) {\n    \t\tLOG.debug( e );\n    \t\tLogs.extreme( ).debug( e, e );\n    \t\t//GRZE: attach is idempotent, failure here is ok, throw new EucalyptusCloudException( e.getMessage( ) );\n    \t}\n    \tvm.removeVolumeAttachment( volume.getVolumeId( ) );\n    } else {\n    \tCluster cluster = null;\n    \tServiceConfiguration ccConfig = null;\n    \ttry {\n    \t\tccConfig = Topology.lookup( ClusterController.class, vm.lookupPartition( ) );\n    \t\tcluster = Clusters.lookup( ccConfig );\n    \t} catch ( NoSuchElementException e ) {\n    \t\tLOG.debug( e, e );\n    \t\tthrow new EucalyptusCloudException( \"Cluster does not exist in partition: \" + vm.getPartition( ) );\n    \t}\n    \trequest.setVolumeId( volume.getVolumeId( ) );\n    \trequest.setRemoteDevice( volume.getRemoteDevice( ) );\n    \trequest.setDevice( volume.getDevice( ).replaceAll( \"unknown,requested:\", \"\" ) );\n    \trequest.setInstanceId( vm.getInstanceId( ) );\n    \tVolumeDetachCallback ncDetach = new VolumeDetachCallback( request );\n    \ttry {\n    \t\tAsyncRequests.sendSync( scVm, new DetachStorageVolumeType( volume.getVolumeId( ) ) );\n    \t} catch ( Exception e ) {\n    \t\tLOG.debug( e );\n    \t\tLogs.extreme( ).debug( e, e );\n    \t\t//GRZE: attach is idempotent, failure here is ok, throw new EucalyptusCloudException( e.getMessage( ) );\n    \t}\n    \tAsyncRequests.newRequest( ncDetach ).dispatch( cluster.getConfiguration( ) );\n    }\n    volume.setStatus( \"detaching\" );\n    reply.setDetachedVolume( volume );\n    Volumes.fireUsageEvent(vol, VolumeEvent.forVolumeDetach(vm.getInstanceUuid(), vm.getInstanceId()));\n    return reply;\n  }","id":35438,"modified_method":"public DetachVolumeResponseType detach( DetachVolumeType request ) throws EucalyptusCloudException {\n    DetachVolumeResponseType reply = ( DetachVolumeResponseType ) request.getReply( );\n    Context ctx = Contexts.lookup( );\n    \n    Volume vol;\n    try {\n      vol = Volumes.lookup( ctx.getUserFullName( ).asAccountFullName( ), request.getVolumeId( ) );\n    } catch ( Exception ex1 ) {\n      throw new EucalyptusCloudException( \"Volume does not exist: \" + request.getVolumeId( ) );\n    }\n    if ( !RestrictedTypes.filterPrivileged( ).apply( vol ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to detach volume \" + request.getVolumeId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    \n    VmInstance vm = null;\n    AttachedVolume volume = null;\n    try {\n      VmVolumeAttachment vmVolAttach = VmInstances.lookupVolumeAttachment( request.getVolumeId( ) );\n      volume = VmVolumeAttachment.asAttachedVolume( vmVolAttach.getVmInstance( ) ).apply( vmVolAttach );\n      vm = vmVolAttach.getVmInstance( );\n    } catch ( NoSuchElementException ex ) {\n      /** no such attachment **/\n    }\n    if ( volume == null ) {\n      throw new EucalyptusCloudException( \"Volume is not attached: \" + request.getVolumeId( ) );\n    }\n    if ( !RestrictedTypes.filterPrivileged( ).apply( vm ) ) {\n      throw new EucalyptusCloudException( \"Not authorized to detach volume from instance \" + request.getInstanceId( ) + \" by \" + ctx.getUser( ).getName( ) );\n    }\n    if ( !vm.getInstanceId( ).equals( request.getInstanceId( ) ) && request.getInstanceId( ) != null && !request.getInstanceId( ).equals( \"\" ) ) {\n      throw new EucalyptusCloudException( \"Volume is not attached to instance: \" + request.getInstanceId( ) );\n    }\n    if ( request.getDevice( ) != null && !request.getDevice( ).equals( \"\" ) && !volume.getDevice( ).equals( request.getDevice( ) ) ) {\n      throw new EucalyptusCloudException( \"Volume is not attached to device: \" + request.getDevice( ) );\n    }\n    ServiceConfiguration scVm;\n    try {\n      scVm = Topology.lookup( Storage.class, vm.lookupPartition( ) );\n    } catch ( Exception ex ) {\n      LOG.error( ex, ex );\n      throw new EucalyptusCloudException( \"Failed to lookup SC for partition: \" + vm.getPartition( ), ex );\n    }\n    if ( VmState.STOPPED.equals( vm.getState( ) ) ) {\n    \ttry {\n    \t\tAsyncRequests.sendSync( scVm, new DetachStorageVolumeType( volume.getVolumeId( ) ) );\n    \t} catch ( Exception e ) {\n    \t\tLOG.debug( e );\n    \t\tLogs.extreme( ).debug( e, e );\n    \t\t//GRZE: attach is idempotent, failure here is ok, throw new EucalyptusCloudException( e.getMessage( ) );\n    \t}\n    \tvm.removeVolumeAttachment( volume.getVolumeId( ) );\n    } else {\n    \tCluster cluster = null;\n    \tServiceConfiguration ccConfig = null;\n    \ttry {\n    \t\tccConfig = Topology.lookup( ClusterController.class, vm.lookupPartition( ) );\n    \t\tcluster = Clusters.lookup( ccConfig );\n    \t} catch ( NoSuchElementException e ) {\n    \t\tLOG.debug( e, e );\n    \t\tthrow new EucalyptusCloudException( \"Cluster does not exist in partition: \" + vm.getPartition( ) );\n    \t}\n    \trequest.setVolumeId( volume.getVolumeId( ) );\n    \trequest.setRemoteDevice( volume.getRemoteDevice( ) );\n    \trequest.setDevice( volume.getDevice( ).replaceAll( \"unknown,requested:\", \"\" ) );\n    \trequest.setInstanceId( vm.getInstanceId( ) );\n    \tVolumeDetachCallback ncDetach = new VolumeDetachCallback( request );\n    \tAsyncRequests.newRequest( ncDetach ).dispatch( cluster.getConfiguration( ) );\n    \ttry {\n    \t\tAsyncRequests.sendSync( scVm, new DetachStorageVolumeType( volume.getVolumeId( ) ) );\n    \t} catch ( Exception e ) {\n    \t\tLOG.debug( e );\n    \t\tLogs.extreme( ).debug( e, e );\n    \t\t//GRZE: attach is idempotent, failure here is ok, throw new EucalyptusCloudException( e.getMessage( ) );\n    \t}\n    }\n    volume.setStatus( \"detaching\" );\n    reply.setDetachedVolume( volume );\n    Volumes.fireUsageEvent(vol, VolumeEvent.forVolumeDetach(vm.getInstanceUuid(), vm.getInstanceId()));\n    return reply;\n  }","commit_id":"e21e49117a32f4d3dec9443713001a860b7763c7","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void addComment(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString body,\n\t\t\tFunction<String, ServiceContext> serviceContextFunction)\n\t\tthrows PortalException {\n\n\t\tCommentManager commentManager = getCommentManager();\n\n\t\tcommentManager.addComment(\n\t\t\tuserId, groupId, className, classPK, body, serviceContextFunction);\n\t}","id":35439,"modified_method":"@Override\n\tpublic long addComment(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString body,\n\t\t\tFunction<String, ServiceContext> serviceContextFunction)\n\t\tthrows PortalException {\n\n\t\tCommentManager commentManager = getCommentManager();\n\n\t\treturn commentManager.addComment(\n\t\t\tuserId, groupId, className, classPK, body, serviceContextFunction);\n\t}","commit_id":"ea40293201cff164ae62857181a8ec9c662254ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addComment(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString body,\n\t\t\tFunction<String, ServiceContext> serviceContextFunction)\n\t\tthrows PortalException {\n\n\t\tgetCommentManager().addComment(\n\t\t\tuserId, groupId, className, classPK, body, serviceContextFunction);\n\t}","id":35440,"modified_method":"public static long addComment(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString body,\n\t\t\tFunction<String, ServiceContext> serviceContextFunction)\n\t\tthrows PortalException {\n\n\t\treturn getCommentManager().addComment(\n\t\t\tuserId, groupId, className, classPK, body, serviceContextFunction);\n\t}","commit_id":"ea40293201cff164ae62857181a8ec9c662254ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addComment(\n\t\tlong userId, long groupId, String className, long classPK, String body,\n\t\tFunction<String, ServiceContext> serviceContextFunction) {\n\t}","id":35441,"modified_method":"@Override\n\tpublic long addComment(\n\t\tlong userId, long groupId, String className, long classPK, String body,\n\t\tFunction<String, ServiceContext> serviceContextFunction) {\n\n\t\treturn 0;\n\t}","commit_id":"ea40293201cff164ae62857181a8ec9c662254ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addComment(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString body,\n\t\t\tFunction<String, ServiceContext> serviceContextFunction)\n\t\tthrows PortalException {\n\n\t\tMBMessageDisplay messageDisplay =\n\t\t\t_mbMessageLocalService.getDiscussionMessageDisplay(\n\t\t\t\tuserId, groupId, className, classPK,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\tMBThread thread = messageDisplay.getThread();\n\n\t\tList<MBMessage> messages = _mbMessageLocalService.getThreadMessages(\n\t\t\tthread.getThreadId(), WorkflowConstants.STATUS_APPROVED);\n\n\t\tfor (MBMessage message : messages) {\n\t\t\tString messageBody = message.getBody();\n\n\t\t\tif (messageBody.equals(body)) {\n\t\t\t\tthrow new DuplicateCommentException();\n\t\t\t}\n\t\t}\n\n\t\tServiceContext serviceContext = serviceContextFunction.apply(\n\t\t\tMBMessage.class.getName());\n\n\t\t_mbMessageLocalService.addDiscussionMessage(\n\t\t\tuserId, StringPool.BLANK, groupId, className, classPK,\n\t\t\tthread.getThreadId(), thread.getRootMessageId(), StringPool.BLANK,\n\t\t\tbody, serviceContext);\n\t}","id":35442,"modified_method":"@Override\n\tpublic long addComment(\n\t\t\tlong userId, long groupId, String className, long classPK,\n\t\t\tString body,\n\t\t\tFunction<String, ServiceContext> serviceContextFunction)\n\t\tthrows PortalException {\n\n\t\tMBMessageDisplay messageDisplay =\n\t\t\t_mbMessageLocalService.getDiscussionMessageDisplay(\n\t\t\t\tuserId, groupId, className, classPK,\n\t\t\t\tWorkflowConstants.STATUS_APPROVED);\n\n\t\tMBThread thread = messageDisplay.getThread();\n\n\t\tList<MBMessage> messages = _mbMessageLocalService.getThreadMessages(\n\t\t\tthread.getThreadId(), WorkflowConstants.STATUS_APPROVED);\n\n\t\tfor (MBMessage message : messages) {\n\t\t\tString messageBody = message.getBody();\n\n\t\t\tif (messageBody.equals(body)) {\n\t\t\t\tthrow new DuplicateCommentException();\n\t\t\t}\n\t\t}\n\n\t\tServiceContext serviceContext = serviceContextFunction.apply(\n\t\t\tMBMessage.class.getName());\n\n\t\tMBMessage mbMessage = _mbMessageLocalService.addDiscussionMessage(\n\t\t\tuserId, StringPool.BLANK, groupId, className, classPK,\n\t\t\tthread.getThreadId(), thread.getRootMessageId(), StringPool.BLANK,\n\t\t\tbody, serviceContext);\n\n\t\treturn mbMessage.getMessageId();\n\t}","commit_id":"ea40293201cff164ae62857181a8ec9c662254ea","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addPingback(long companyId) throws Exception {\n\t\tif (!PropsValues.BLOGS_PINGBACK_ENABLED) {\n\t\t\tthrow new DisabledPingbackException(\"Pingbacks are disabled\");\n\t\t}\n\n\t\tvalidateSource();\n\n\t\tBlogsEntry entry = getBlogsEntry(companyId);\n\n\t\tif (!entry.isAllowPingbacks()) {\n\t\t\tthrow new DisabledPingbackException(\"Pingbacks are disabled\");\n\t\t}\n\n\t\tlong userId = UserLocalServiceUtil.getDefaultUserId(companyId);\n\t\tlong groupId = entry.getGroupId();\n\t\tString className = BlogsEntry.class.getName();\n\t\tlong classPK = entry.getEntryId();\n\n\t\tString body =\n\t\t\t\"[...] \" + getExcerpt() + \" [...] [url=\" + _sourceURI + \"]\" +\n\t\t\t\tLanguageUtil.get(LocaleUtil.getSiteDefault(), \"read-more\") +\n\t\t\t\t\t\"[/url]\";\n\n\t\tServiceContext serviceContext = buildServiceContext(\n\t\t\tcompanyId, groupId, entry.getUrlTitle());\n\n\t\t_commentManager.addComment(\n\t\t\tuserId, groupId, className, classPK, body,\n\t\t\tnew IdentityServiceContextFunction(serviceContext));\n\t}","id":35443,"modified_method":"protected long addPingback(long companyId) throws Exception {\n\t\tif (!PropsValues.BLOGS_PINGBACK_ENABLED) {\n\t\t\tthrow new DisabledPingbackException(\"Pingbacks are disabled\");\n\t\t}\n\n\t\tvalidateSource();\n\n\t\tBlogsEntry entry = getBlogsEntry(companyId);\n\n\t\tif (!entry.isAllowPingbacks()) {\n\t\t\tthrow new DisabledPingbackException(\"Pingbacks are disabled\");\n\t\t}\n\n\t\tlong userId = UserLocalServiceUtil.getDefaultUserId(companyId);\n\t\tlong groupId = entry.getGroupId();\n\t\tString className = BlogsEntry.class.getName();\n\t\tlong classPK = entry.getEntryId();\n\n\t\tString body =\n\t\t\t\"[...] \" + getExcerpt() + \" [...] [url=\" + _sourceURI + \"]\" +\n\t\t\t\tLanguageUtil.get(LocaleUtil.getSiteDefault(), \"read-more\") +\n\t\t\t\t\t\"[/url]\";\n\n\t\tServiceContext serviceContext = buildServiceContext(\n\t\t\tcompanyId, groupId, entry.getUrlTitle());\n\n\t\treturn _commentManager.addComment(\n\t\t\tuserId, groupId, className, classPK, body,\n\t\t\tnew IdentityServiceContextFunction(serviceContext));\n\t}","commit_id":"a8c85a8f0cfc8af974caef781196b1cf98741455","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setConfig(String config) {\n\t\t_config = config;\n\t}","id":35444,"modified_method":"public void setConfig(String config) {\n\t\t_configNames = StringUtil.split(\n\t\t\tconfig.replace(CharPool.PERIOD, CharPool.SLASH));\n\t}","commit_id":"b032f3727824ca1846719b4608205f1453bf5313","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Locale getSuperLocale(Locale locale) {\n\t\tif (Validator.isNotNull(locale.getVariant())) {\n\t\t\treturn new Locale(locale.getLanguage(), locale.getCountry());\n\t\t}\n\n\t\tif (Validator.isNotNull(locale.getCountry())) {\n\t\t\tif (LanguageUtil.isDuplicateLanguageCode(locale.getLanguage())) {\n\t\t\t\tLocale priorityLocale = LanguageUtil.getLocale(\n\t\t\t\t\tlocale.getLanguage());\n\n\t\t\t\tif (!locale.equals(priorityLocale)) {\n\t\t\t\t\treturn new Locale(\n\t\t\t\t\t\tpriorityLocale.getLanguage(),\n\t\t\t\t\t\tpriorityLocale.getCountry());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn LocaleUtil.fromLanguageId(locale.getLanguage());\n\t\t}\n\n\t\tif (Validator.isNotNull(locale.getLanguage())) {\n\t\t\treturn _blankLocale;\n\t\t}\n\n\t\treturn null;\n\t}","id":35445,"modified_method":"public static Locale getSuperLocale(Locale locale) {\n\t\tif (locale.getVariant().length() > 0) {\n\t\t\treturn new Locale(locale.getLanguage(), locale.getCountry());\n\t\t}\n\n\t\tif (locale.getCountry().length() > 0) {\n\t\t\tLocale priorityLocale = LanguageUtil.getLocale(\n\t\t\t\tlocale.getLanguage());\n\n\t\t\tif ((priorityLocale != null) && (!locale.equals(priorityLocale))) {\n\t\t\t\treturn new Locale(\n\t\t\t\t\tpriorityLocale.getLanguage(),\n\t\t\t\t\tpriorityLocale.getCountry());\n\t\t\t}\n\n\t\t\treturn LocaleUtil.fromLanguageId(locale.getLanguage());\n\t\t}\n\n\t\tif (locale.getLanguage().length() > 0) {\n\t\t\treturn _blankLocale;\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"b032f3727824ca1846719b4608205f1453bf5313","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static Map<String, String> _loadLocale(Locale locale) {\n\t\tString[] names = StringUtil.split(\n\t\t\t_config.replace(StringPool.PERIOD, StringPool.SLASH));\n\n\t\tMap<String, String> languageMap = null;\n\n\t\tif (names.length > 0) {\n\t\t\tString localeName = locale.toString();\n\n\t\t\tlanguageMap = new HashMap<String, String>();\n\n\t\t\tfor (String name : names) {\n\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\tsb.append(name);\n\n\t\t\t\tif (localeName.length() > 0) {\n\t\t\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\t\t\tsb.append(localeName);\n\t\t\t\t}\n\n\t\t\t\tsb.append(\".properties\");\n\n\t\t\t\tProperties properties = _loadProperties(sb.toString());\n\n\t\t\t\tfixValues(languageMap, properties);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlanguageMap = Collections.emptyMap();\n\t\t}\n\n\t\t_languageMaps.put(locale, languageMap);\n\n\t\treturn languageMap;\n\t}","id":35446,"modified_method":"private static Map<String, String> _loadLocale(Locale locale) {\n\t\tMap<String, String> languageMap = null;\n\n\t\tif (_configNames.length > 0) {\n\t\t\tString localeName = locale.toString();\n\n\t\t\tlanguageMap = new HashMap<String, String>();\n\n\t\t\tfor (String name : _configNames) {\n\t\t\t\tStringBundler sb = new StringBundler(4);\n\n\t\t\t\tsb.append(name);\n\n\t\t\t\tif (localeName.length() > 0) {\n\t\t\t\t\tsb.append(StringPool.UNDERLINE);\n\t\t\t\t\tsb.append(localeName);\n\t\t\t\t}\n\n\t\t\t\tsb.append(\".properties\");\n\n\t\t\t\tProperties properties = _loadProperties(sb.toString());\n\n\t\t\t\tfixValues(languageMap, properties);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlanguageMap = Collections.emptyMap();\n\t\t}\n\n\t\t_languageMaps.put(locale, languageMap);\n\n\t\treturn languageMap;\n\t}","commit_id":"b032f3727824ca1846719b4608205f1453bf5313","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static LinkDeclaration findMetalink(ConceptDeclaration sourceMetatype, ConceptDeclaration targetMetatype, String role) {\n    Iterator<LinkDeclaration> metalinks = sourceMetatype.linkDeclarations();\n    while (metalinks.hasNext()) {\n      LinkDeclaration metalink = metalinks.next();\n      if (SModelUtil_new.isAssignableConcept(targetMetatype, metalink.getTarget()) && \n              (role == null || metalink.getRole().equals(role))) {\n        return metalink;\n      }\n    }\n    ConceptDeclaration anExtends = sourceMetatype.getExtends();\n    if (anExtends != null) {\n      return findMetalink(anExtends, targetMetatype, role);\n    }\n    return null;\n  }","id":35447,"modified_method":"private static LinkDeclaration findMetalink(AbstractConceptDeclaration sourceMetatype, AbstractConceptDeclaration targetMetatype, String role) {\n    for (LinkDeclaration metalink: new ConceptHierarchyScope(sourceMetatype).getAdapters(LinkDeclaration.class)) {\n      if (SModelUtil_new.isAssignableConcept(targetMetatype, metalink.getTarget()) &&\n              (role == null || metalink.getRole().equals(role))) {\n        return metalink;\n      }\n    }\n    return null;\n  }","commit_id":"718972f7403f61b07610151fd2a03111214d7588","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean pasteToTarget_internal(final SNode pasteTarget, final SNode pasteNode, final SNode anchorNode, String role, final boolean pasteBefore, boolean reallyPaste, final IOperationContext operationContext) {\n    ConceptDeclaration pasteTargetType = (ConceptDeclaration) pasteTarget.getConceptDeclarationAdapter();\n    ConceptDeclaration pasteNodeType = (ConceptDeclaration) pasteNode.getConceptDeclarationAdapter();\n    final LinkDeclaration linkDeclaration = findMetalink(pasteTargetType, pasteNodeType, role);\n    if (linkDeclaration == null) {\n      return false;\n    }\n    if (reallyPaste) {\n      CommandProcessor.instance().executeCommand(new Runnable() {\n        public void run() {\n          Cardinality cardinality = linkDeclaration.getSourceCardinality();\n          boolean uniqueChild = (cardinality == Cardinality._0_1 || cardinality == Cardinality._1);\n          if (linkDeclaration.getMetaClass() == LinkMetaclass.aggregation) {\n            if (uniqueChild) pasteTarget.setChild(linkDeclaration.getRole(), pasteNode);\n            else pasteTarget.insertChild(anchorNode, linkDeclaration.getRole(), pasteNode, pasteBefore);\n          } else {\n            if (uniqueChild) pasteTarget.insertReferent(anchorNode, linkDeclaration.getRole(), pasteNode, pasteBefore);\n            else pasteTarget.setReferent(linkDeclaration.getRole(), pasteNode);\n          }\n        //Add resolving here!\n\n\n      //  Resolver.resolveAllReferences(pasteNode, operationContext);\n\n        }\n      });\n    }\n    return true;\n  }","id":35448,"modified_method":"private static boolean pasteToTarget_internal(final SNode pasteTarget, final SNode pasteNode, final SNode anchorNode, String role, final boolean pasteBefore, boolean reallyPaste, final IOperationContext operationContext) {\n    AbstractConceptDeclaration pasteTargetType = pasteTarget.getConceptDeclarationAdapter();\n    AbstractConceptDeclaration pasteNodeType = pasteNode.getConceptDeclarationAdapter();\n    final LinkDeclaration linkDeclaration = findMetalink(pasteTargetType, pasteNodeType, role);\n    if (linkDeclaration == null) {\n      return false;\n    }\n    if (reallyPaste) {\n      CommandProcessor.instance().executeCommand(new Runnable() {\n        public void run() {\n          Cardinality cardinality = linkDeclaration.getSourceCardinality();\n          boolean uniqueChild = (cardinality == Cardinality._0_1 || cardinality == Cardinality._1);\n          if (linkDeclaration.getMetaClass() == LinkMetaclass.aggregation) {\n            if (uniqueChild) pasteTarget.setChild(linkDeclaration.getRole(), pasteNode);\n            else pasteTarget.insertChild(anchorNode, linkDeclaration.getRole(), pasteNode, pasteBefore);\n          } else {\n            if (uniqueChild) pasteTarget.insertReferent(anchorNode, linkDeclaration.getRole(), pasteNode, pasteBefore);\n            else pasteTarget.setReferent(linkDeclaration.getRole(), pasteNode);\n          }\n        //Add resolving here!\n\n\n      //  Resolver.resolveAllReferences(pasteNode, operationContext);\n\n        }\n      });\n    }\n    return true;\n  }","commit_id":"718972f7403f61b07610151fd2a03111214d7588","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConceptDeclaration getConceptDeclaration(IScope scope) {\n    return (ConceptDeclaration) getNode().getConceptDeclarationAdapter(scope);\n  }","id":35449,"modified_method":"public ConceptDeclaration getConceptDeclaration(IScope scope) {\n    return getNode().getConceptDeclarationAdapter(scope);\n  }","commit_id":"54f13592152e4e471377ce29d28e38b7d88eea6c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean checkPremiseForBaseMappingRule(SNode inputNode, ConceptDeclaration sourceNodeConcept, BaseMappingRule rule, ITemplateGenerator generator) throws GenerationFailureException {\n    AbstractConceptDeclaration applicableConcept = rule.getApplicableConcept();\n    if (applicableConcept != null) {\n      if (rule.getApplyToConceptInheritors()) {\n        if (!SModelUtil_new.isAssignableConcept(sourceNodeConcept, applicableConcept)) return false;\n      } else {\n        if (sourceNodeConcept != applicableConcept) return false;\n      }\n    }\n    return checkCondition(rule.getConditionFunction(), false, inputNode, rule.getNode(), generator);\n  }","id":35450,"modified_method":"public static boolean checkPremiseForBaseMappingRule(SNode inputNode, AbstractConceptDeclaration inputNodeConcept, BaseMappingRule rule, ITemplateGenerator generator) throws GenerationFailureException {\n    AbstractConceptDeclaration applicableConcept = rule.getApplicableConcept();\n    if (applicableConcept != null) {\n      if (rule.getApplyToConceptInheritors()) {\n        if (!SModelUtil_new.isAssignableConcept(inputNodeConcept, applicableConcept)) return false;\n      } else {\n        if (inputNodeConcept != applicableConcept) return false;\n      }\n    }\n    return checkCondition(rule.getConditionFunction(), false, inputNode, rule.getNode(), generator);\n  }","commit_id":"baaabdac7d553d1b5e5c117f8d13a5517a5d333c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RuleConsequence getConsequenceForSwitchCase(SNode inputNode, TemplateSwitch templateSwitch) throws GenerationFailureException {\n    ConceptDeclaration nodeConcept = (ConceptDeclaration) inputNode.getConceptDeclarationAdapter();\n\n    if (myTemplateSwitchGraph == null) {\n      myTemplateSwitchGraph = new TemplateSwitchGraph(getGeneratorSessionContext().getTemplateModels());\n      myTemplateSwitchToListCache = new HashMap<TemplateSwitch, List<TemplateSwitch>>();\n    }\n\n    List<TemplateSwitch> switches = myTemplateSwitchToListCache.get(templateSwitch);\n    if (switches == null) {\n      switches = myTemplateSwitchGraph.getSubgraphAsList(templateSwitch);\n      myTemplateSwitchToListCache.put(templateSwitch, switches);\n    }\n\n    // for each template switch test conditions and choose template node\n    for (TemplateSwitch aSwitch : switches) {\n      List<Reduction_MappingRule> rules = aSwitch.getReductionMappingRules();\n      for (Reduction_MappingRule rule : rules) {\n        if (GeneratorUtil.checkPremiseForBaseMappingRule(inputNode, nodeConcept, rule, this)) {\n          RuleConsequence ruleConsequence = rule.getRuleConsequence();\n          if (ruleConsequence == null) {\n            showErrorMessage(inputNode, null, rule.getNode(), \"couldn't apply reduction: no rule consequence\");\n          }\n          return ruleConsequence;\n        }\n      }\n\n      // default\n      RuleConsequence ruleConsequence = aSwitch.getDefaultConsequence();\n      if (ruleConsequence != null) {\n        return ruleConsequence;\n      }\n    }\n\n    return null;\n  }","id":35451,"modified_method":"public RuleConsequence getConsequenceForSwitchCase(SNode inputNode, TemplateSwitch templateSwitch) throws GenerationFailureException {\n    AbstractConceptDeclaration inputNodeConcept = inputNode.getConceptDeclarationAdapter();\n\n    if (myTemplateSwitchGraph == null) {\n      myTemplateSwitchGraph = new TemplateSwitchGraph(getGeneratorSessionContext().getTemplateModels());\n      myTemplateSwitchToListCache = new HashMap<TemplateSwitch, List<TemplateSwitch>>();\n    }\n\n    List<TemplateSwitch> switches = myTemplateSwitchToListCache.get(templateSwitch);\n    if (switches == null) {\n      switches = myTemplateSwitchGraph.getSubgraphAsList(templateSwitch);\n      myTemplateSwitchToListCache.put(templateSwitch, switches);\n    }\n\n    // for each template switch test conditions and choose template node\n    for (TemplateSwitch aSwitch : switches) {\n      List<Reduction_MappingRule> rules = aSwitch.getReductionMappingRules();\n      for (Reduction_MappingRule rule : rules) {\n        if (GeneratorUtil.checkPremiseForBaseMappingRule(inputNode, inputNodeConcept, rule, this)) {\n          RuleConsequence ruleConsequence = rule.getRuleConsequence();\n          if (ruleConsequence == null) {\n            showErrorMessage(inputNode, null, rule.getNode(), \"couldn't apply reduction: no rule consequence\");\n          }\n          return ruleConsequence;\n        }\n      }\n\n      // default\n      RuleConsequence ruleConsequence = aSwitch.getDefaultConsequence();\n      if (ruleConsequence != null) {\n        return ruleConsequence;\n      }\n    }\n\n    return null;\n  }","commit_id":"baaabdac7d553d1b5e5c117f8d13a5517a5d333c","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void processElementUsages(@NotNull final PsiElement element,\n                                   @NotNull final Processor<UsageInfo> processor,\n                                   @NotNull final FindUsagesOptions options) {\n    final ReadActionProcessor<PsiReference> refProcessor = new ReadActionProcessor<PsiReference>() {\n      @Override\n      public boolean processInReadAction(final PsiReference ref) {\n        TextRange rangeInElement = ref.getRangeInElement();\n        return processor.process(new UsageInfo(ref.getElement(), rangeInElement.getStartOffset(), rangeInElement.getEndOffset(), false));\n      }\n    };\n\n    final SearchScope scope = options.searchScope;\n\n    final boolean searchText = options.isSearchForTextOccurrences && scope instanceof GlobalSearchScope;\n\n    if (options.isUsages) {\n      ReferencesSearch.search(new ReferencesSearch.SearchParameters(element, scope, false, options.fastTrack)).forEach(refProcessor);\n    }\n\n    if (searchText) {\n      if (options.fastTrack != null) {\n        options.fastTrack.searchCustom(new Processor<Processor<PsiReference>>() {\n          @Override\n          public boolean process(Processor<PsiReference> consumer) {\n            processUsagesInText(element, processor, (GlobalSearchScope)scope);\n            return true;\n          }\n        });\n      } else {\n        processUsagesInText(element, processor, (GlobalSearchScope)scope);\n      }\n    }\n  }","id":35452,"modified_method":"public boolean processElementUsages(@NotNull final PsiElement element,\n                                      @NotNull final Processor<UsageInfo> processor,\n                                      @NotNull final FindUsagesOptions options) {\n    final ReadActionProcessor<PsiReference> refProcessor = new ReadActionProcessor<PsiReference>() {\n      @Override\n      public boolean processInReadAction(final PsiReference ref) {\n        TextRange rangeInElement = ref.getRangeInElement();\n        return processor.process(new UsageInfo(ref.getElement(), rangeInElement.getStartOffset(), rangeInElement.getEndOffset(), false));\n      }\n    };\n\n    final SearchScope scope = options.searchScope;\n\n    final boolean searchText = options.isSearchForTextOccurrences && scope instanceof GlobalSearchScope;\n\n    if (options.isUsages) {\n      boolean success =\n        ReferencesSearch.search(new ReferencesSearch.SearchParameters(element, scope, false, options.fastTrack)).forEach(refProcessor);\n      if (!success) return false;\n    }\n\n    if (searchText) {\n      if (options.fastTrack != null) {\n        options.fastTrack.searchCustom(new Processor<Processor<PsiReference>>() {\n          @Override\n          public boolean process(Processor<PsiReference> consumer) {\n            return processUsagesInText(element, processor, (GlobalSearchScope)scope);\n          }\n        });\n      }\n      else {\n        return processUsagesInText(element, processor, (GlobalSearchScope)scope);\n      }\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processUsagesInText(@NotNull final PsiElement element,\n                                  @NotNull Processor<UsageInfo> processor,\n                                  @NotNull GlobalSearchScope searchScope) {\n    Collection<String> stringToSearch = ApplicationManager.getApplication().runReadAction(new NullableComputable<Collection<String>>() {\n      @Override\n      public Collection<String> compute() {\n        return getStringsToSearch(element);\n      }\n    });\n    if (stringToSearch == null) return;\n    final TextRange elementTextRange = ApplicationManager.getApplication().runReadAction(new NullableComputable<TextRange>() {\n      @Override\n      public TextRange compute() {\n        if (!element.isValid()) return null;\n        return element.getTextRange();\n      }\n    });\n    TextOccurrencesUtil.UsageInfoFactory factory = new TextOccurrencesUtil.UsageInfoFactory() {\n      @Override\n      public UsageInfo createUsageInfo(@NotNull PsiElement usage, int startOffset, int endOffset) {\n        if (elementTextRange != null\n            && usage.getContainingFile() == element.getContainingFile()\n            && elementTextRange.contains(startOffset)\n            && elementTextRange.contains(endOffset)) {\n          return null;\n        }\n\n        PsiReference someReference = usage.findReferenceAt(startOffset);\n        if (someReference != null) {\n          PsiElement refElement = someReference.getElement();\n          for (PsiReference ref : PsiReferenceService.getService().getReferences(refElement, new PsiReferenceService.Hints(element, null))) {\n            if (element.getManager().areElementsEquivalent(ref.resolve(), element)) {\n              TextRange range = ref.getRangeInElement().shiftRight(refElement.getTextRange().getStartOffset() - usage.getTextRange().getStartOffset());\n              return new UsageInfo(usage, range.getStartOffset(), range.getEndOffset(), true);\n            }\n          }\n\n        }\n\n        return new UsageInfo(usage, startOffset, endOffset, true);\n      }\n    };\n    for (String s : stringToSearch) {\n      TextOccurrencesUtil.processTextOccurences(element, s, searchScope, processor, factory);\n    }\n  }","id":35453,"modified_method":"public boolean processUsagesInText(@NotNull final PsiElement element,\n                                     @NotNull Processor<UsageInfo> processor,\n                                     @NotNull GlobalSearchScope searchScope) {\n    Collection<String> stringToSearch = ApplicationManager.getApplication().runReadAction(new NullableComputable<Collection<String>>() {\n      @Override\n      public Collection<String> compute() {\n        return getStringsToSearch(element);\n      }\n    });\n    if (stringToSearch == null) return true;\n    final TextRange elementTextRange = ApplicationManager.getApplication().runReadAction(new NullableComputable<TextRange>() {\n      @Override\n      public TextRange compute() {\n        if (!element.isValid()) return null;\n        return element.getTextRange();\n      }\n    });\n    TextOccurrencesUtil.UsageInfoFactory factory = new TextOccurrencesUtil.UsageInfoFactory() {\n      @Override\n      public UsageInfo createUsageInfo(@NotNull PsiElement usage, int startOffset, int endOffset) {\n        if (elementTextRange != null\n            && usage.getContainingFile() == element.getContainingFile()\n            && elementTextRange.contains(startOffset)\n            && elementTextRange.contains(endOffset)) {\n          return null;\n        }\n\n        PsiReference someReference = usage.findReferenceAt(startOffset);\n        if (someReference != null) {\n          PsiElement refElement = someReference.getElement();\n          for (PsiReference ref : PsiReferenceService.getService().getReferences(refElement, new PsiReferenceService.Hints(element, null))) {\n            if (element.getManager().areElementsEquivalent(ref.resolve(), element)) {\n              TextRange range = ref.getRangeInElement().shiftRight(refElement.getTextRange().getStartOffset() - usage.getTextRange().getStartOffset());\n              return new UsageInfo(usage, range.getStartOffset(), range.getEndOffset(), true);\n            }\n          }\n\n        }\n\n        return new UsageInfo(usage, startOffset, endOffset, true);\n      }\n    };\n    for (String s : stringToSearch) {\n      if (!TextOccurrencesUtil.processTextOccurences(element, s, searchScope, processor, factory)) return false;\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processOverridingMethods(PsiMethod psiMethod, final Processor<UsageInfo> processor, final JavaMethodFindUsagesOptions options) {\n    OverridingMethodsSearch.search(psiMethod, options.searchScope, options.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiMethod>(\n      new PsiElementProcessor<PsiMethod>() {\n      @Override\n      public boolean execute(@NotNull PsiMethod element) {\n        addResult(processor, element.getNavigationElement(), options);\n        return true;\n      }\n    }));\n  }","id":35454,"modified_method":"private static boolean processOverridingMethods(@NotNull PsiMethod psiMethod,\n                                                  @NotNull final Processor<UsageInfo> processor,\n                                                  @NotNull final JavaMethodFindUsagesOptions options) {\n    return OverridingMethodsSearch.search(psiMethod, options.searchScope, options.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiMethod>(\n      new PsiElementProcessor<PsiMethod>() {\n      @Override\n      public boolean execute(@NotNull PsiMethod element) {\n        return addResult(processor, element.getNavigationElement(), options);\n      }\n    }));\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addClassesUsages(PsiPackage aPackage, final Processor<UsageInfo> results, final JavaPackageFindUsagesOptions options) {\n    ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n    if (progress != null){\n      progress.pushState();\n    }\n\n    ArrayList<PsiClass> classes = new ArrayList<PsiClass>();\n    addClassesInPackage(aPackage, options.isIncludeSubpackages, classes);\n    for (final PsiClass aClass : classes) {\n      if (progress != null) {\n        progress.setText(FindBundle.message(\"find.searching.for.references.to.class.progress\", ApplicationManager.getApplication().runReadAction(new Computable<String>(){\n          @Override\n          public String compute() {\n            return aClass.getName();\n          }\n        })));\n        progress.checkCanceled();\n      }\n      ReferencesSearch.search(new ReferencesSearch.SearchParameters(aClass, options.searchScope, false, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n        @Override\n        public boolean processInReadAction(final PsiReference psiReference) {\n          return addResult(results, psiReference, options);\n        }\n      });\n    }\n\n    if (progress != null){\n      progress.popState();\n    }\n  }","id":35455,"modified_method":"private static boolean addClassesUsages(@NotNull PsiPackage aPackage,\n                                          @NotNull final Processor<UsageInfo> processor,\n                                          @NotNull final JavaPackageFindUsagesOptions options) {\n    ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n    if (progress != null){\n      progress.pushState();\n    }\n\n    List<PsiClass> classes = new ArrayList<PsiClass>();\n    addClassesInPackage(aPackage, options.isIncludeSubpackages, classes);\n    for (final PsiClass aClass : classes) {\n      if (progress != null) {\n        progress.setText(FindBundle.message(\"find.searching.for.references.to.class.progress\", ApplicationManager.getApplication().runReadAction(new Computable<String>(){\n          @Override\n          public String compute() {\n            return aClass.getName();\n          }\n        })));\n        progress.checkCanceled();\n      }\n      boolean success = ReferencesSearch.search(new ReferencesSearch.SearchParameters(aClass, options.searchScope, false, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n        @Override\n        public boolean processInReadAction(final PsiReference psiReference) {\n          return addResult(processor, psiReference, options);\n        }\n      });\n      if (!success) return false;\n    }\n\n    if (progress != null){\n      progress.popState();\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addFieldsUsages(final PsiClass aClass, final Processor<UsageInfo> results, final JavaClassFindUsagesOptions options) {\n    if (options.isIncludeInherited) {\n      final PsiManager manager = aClass.getManager();\n      PsiField[] fields = aClass.getAllFields();\n      FieldsLoop:\n      for (int i = 0; i < fields.length; i++) {\n        final PsiField field = fields[i];\n        // filter hidden fields\n        for (int j = 0; j < i; j++) {\n          if (Comparing.strEqual(field.getName(), fields[j].getName())) continue FieldsLoop;\n        }\n        final PsiClass fieldClass = field.getContainingClass();\n        if (manager.areElementsEquivalent(fieldClass, aClass)) {\n          addElementUsages(fields[i], results, options);\n        }\n        else {\n          ReferencesSearch.search(new ReferencesSearch.SearchParameters(field, options.searchScope, false, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n            @Override\n            public boolean processInReadAction(final PsiReference reference) {\n              addResultFromReference(reference, fieldClass, manager, aClass, results, options);\n              return true;\n            }\n          });\n        }\n      }\n    }\n    else {\n      PsiField[] fields = ApplicationManager.getApplication().runReadAction(new Computable<PsiField[]>() {\n        @Override\n        public PsiField[] compute() {\n          return aClass.getFields();\n        }\n      });\n      for (PsiField field : fields) {\n        addElementUsages(field, results, options);\n      }\n    }\n  }","id":35456,"modified_method":"private static boolean addFieldsUsages(@NotNull final PsiClass aClass,\n                                         @NotNull final Processor<UsageInfo> processor,\n                                         @NotNull final JavaClassFindUsagesOptions options) {\n    if (options.isIncludeInherited) {\n      final PsiManager manager = aClass.getManager();\n      PsiField[] fields = aClass.getAllFields();\n      FieldsLoop:\n      for (int i = 0; i < fields.length; i++) {\n        final PsiField field = fields[i];\n        // filter hidden fields\n        for (int j = 0; j < i; j++) {\n          if (Comparing.strEqual(field.getName(), fields[j].getName())) continue FieldsLoop;\n        }\n        final PsiClass fieldClass = field.getContainingClass();\n        if (manager.areElementsEquivalent(fieldClass, aClass)) {\n          if (!addElementUsages(fields[i], processor, options)) return false;\n        }\n        else {\n          boolean success = ReferencesSearch.search(new ReferencesSearch.SearchParameters(field, options.searchScope, false, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n            @Override\n            public boolean processInReadAction(final PsiReference reference) {\n              return addResultFromReference(reference, fieldClass, manager, aClass, processor, options);\n            }\n          });\n          if (!success) return false;\n        }\n      }\n    }\n    else {\n      PsiField[] fields = ApplicationManager.getApplication().runReadAction(new Computable<PsiField[]>() {\n        @Override\n        public PsiField[] compute() {\n          return aClass.getFields();\n        }\n      });\n      for (PsiField field : fields) {\n        if (!addElementUsages(field, processor, options)) return false;\n      }\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addDerivedInterfaces(PsiClass anInterface, final Processor<UsageInfo> results, final JavaClassFindUsagesOptions options) {\n    ClassInheritorsSearch.search(anInterface, options.searchScope, options.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiClass>(\n      new PsiElementProcessor<PsiClass>() {\n      @Override\n      public boolean execute(@NotNull PsiClass inheritor) {\n        if (inheritor.isInterface()) {\n          addResult(results, inheritor, options);\n        }\n        return true;\n      }\n\n    }));\n  }","id":35457,"modified_method":"private static boolean addDerivedInterfaces(@NotNull PsiClass anInterface,\n                                              @NotNull final Processor<UsageInfo> processor,\n                                              @NotNull final JavaClassFindUsagesOptions options) {\n    return ClassInheritorsSearch.search(anInterface, options.searchScope, options.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiClass>(\n      new PsiElementProcessor<PsiClass>() {\n      @Override\n      public boolean execute(@NotNull PsiClass inheritor) {\n        return !inheritor.isInterface() || addResult(processor, inheritor, options);\n      }\n\n    }));\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processElementUsages(@NotNull final PsiElement element, @NotNull final Processor<UsageInfo> processor, @NotNull final FindUsagesOptions options) {\n    if (options instanceof JavaVariableFindUsagesOptions) {\n      final JavaVariableFindUsagesOptions varOptions = (JavaVariableFindUsagesOptions) options;\n      if (varOptions.isReadAccess || varOptions.isWriteAccess){\n        if (varOptions.isReadAccess && varOptions.isWriteAccess){\n          addElementUsages(element, processor, options);\n        }\n        else{\n          addElementUsages(element, new Processor<UsageInfo>() {\n            @Override\n            public boolean process(UsageInfo info) {\n              final PsiElement element = info.getElement();\n              boolean isWrite = element instanceof PsiExpression && PsiUtil.isAccessedForWriting((PsiExpression)element);\n              if (isWrite == varOptions.isWriteAccess) {\n                if (!processor.process(info)) return false;\n              }\n              return true;\n            }\n          }, varOptions);\n        }\n      }\n    }\n    else if (options.isUsages) {\n      addElementUsages(element, processor, options);\n    }\n\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        if (ThrowSearchUtil.isSearchable (element) && options instanceof JavaThrowFindUsagesOptions && options.isUsages) {\n          ThrowSearchUtil.Root root = options.getUserData(ThrowSearchUtil.THROW_SEARCH_ROOT_KEY);\n          if (root == null) {\n            final ThrowSearchUtil.Root[] roots = ThrowSearchUtil.getSearchRoots(element);\n            if (roots != null && roots.length > 0) {\n              root = roots [0];\n            }\n          }\n          if (root != null) {\n            ThrowSearchUtil.addThrowUsages(processor, root, options);\n          }\n        }\n      }\n    });\n\n    if (options instanceof JavaPackageFindUsagesOptions && ((JavaPackageFindUsagesOptions)options).isClassesUsages){\n      addClassesUsages((PsiPackage)element, processor, (JavaPackageFindUsagesOptions)options);\n    }\n\n    if (options instanceof JavaClassFindUsagesOptions) {\n      final JavaClassFindUsagesOptions classOptions = (JavaClassFindUsagesOptions)options;\n      final PsiClass psiClass = (PsiClass)element;\n      if (classOptions.isMethodsUsages){\n        addMethodsUsages(psiClass, processor, classOptions);\n      }\n      if (classOptions.isFieldsUsages){\n        addFieldsUsages(psiClass, processor, classOptions);\n      }\n      if (psiClass.isInterface()) {\n        if (classOptions.isDerivedInterfaces){\n          if (classOptions.isImplementingClasses){\n            addInheritors(psiClass, processor, classOptions);\n          }\n          else{\n            addDerivedInterfaces(psiClass, processor, classOptions);\n          }\n        }\n        else if (classOptions.isImplementingClasses){\n          addImplementingClasses(psiClass, processor, classOptions);\n        }\n      }\n      else if (classOptions.isDerivedClasses) {\n        addInheritors(psiClass, processor, classOptions);\n      }\n    }\n\n\n\n    if (options instanceof JavaMethodFindUsagesOptions){\n      final PsiMethod psiMethod = (PsiMethod)element;\n      boolean isAbstract = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          return psiMethod.hasModifierProperty(PsiModifier.ABSTRACT);\n        }\n      });\n      final JavaMethodFindUsagesOptions methodOptions = (JavaMethodFindUsagesOptions)options;\n      if (isAbstract && methodOptions.isImplementingMethods || methodOptions.isOverridingMethods) {\n        processOverridingMethods(psiMethod, processor, methodOptions);\n      }\n    }\n\n    if (element instanceof PomTarget) {\n       addAliasingUsages((PomTarget)element, processor, options);\n    }\n    final Boolean isSearchable = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return ThrowSearchUtil.isSearchable(element);\n      }\n    });\n    if (!isSearchable && options.isSearchForTextOccurrences && options.searchScope instanceof GlobalSearchScope) {\n      // todo add to fastTrack\n      processUsagesInText(element, processor, (GlobalSearchScope)options.searchScope);\n    }\n  }","id":35458,"modified_method":"@Override\n  public boolean processElementUsages(@NotNull final PsiElement element,\n                                      @NotNull final Processor<UsageInfo> processor,\n                                      @NotNull final FindUsagesOptions options) {\n    if (options instanceof JavaVariableFindUsagesOptions) {\n      final JavaVariableFindUsagesOptions varOptions = (JavaVariableFindUsagesOptions) options;\n      if (varOptions.isReadAccess || varOptions.isWriteAccess){\n        if (varOptions.isReadAccess && varOptions.isWriteAccess){\n          if (!addElementUsages(element, processor, options)) return false;\n        }\n        else{\n          if (!addElementUsages(element, new Processor<UsageInfo>() {\n            @Override\n            public boolean process(UsageInfo info) {\n              final PsiElement element = info.getElement();\n              boolean isWrite = element instanceof PsiExpression && PsiUtil.isAccessedForWriting((PsiExpression)element);\n              if (isWrite == varOptions.isWriteAccess) {\n                if (!processor.process(info)) return false;\n              }\n              return true;\n            }\n          }, varOptions)) return false;\n        }\n      }\n    }\n    else if (options.isUsages) {\n      if (!addElementUsages(element, processor, options)) return false;\n    }\n\n    boolean success = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        if (ThrowSearchUtil.isSearchable (element) && options instanceof JavaThrowFindUsagesOptions && options.isUsages) {\n          ThrowSearchUtil.Root root = options.getUserData(ThrowSearchUtil.THROW_SEARCH_ROOT_KEY);\n          if (root == null) {\n            final ThrowSearchUtil.Root[] roots = ThrowSearchUtil.getSearchRoots(element);\n            if (roots != null && roots.length > 0) {\n              root = roots [0];\n            }\n          }\n          if (root != null) {\n            return ThrowSearchUtil.addThrowUsages(processor, root, options);\n          }\n        }\n        return true;\n      }\n    });\n    if (!success) return false;\n\n    if (options instanceof JavaPackageFindUsagesOptions && ((JavaPackageFindUsagesOptions)options).isClassesUsages){\n      if (!addClassesUsages((PsiPackage)element, processor, (JavaPackageFindUsagesOptions)options)) return false;\n    }\n\n    if (options instanceof JavaClassFindUsagesOptions) {\n      final JavaClassFindUsagesOptions classOptions = (JavaClassFindUsagesOptions)options;\n      final PsiClass psiClass = (PsiClass)element;\n      if (classOptions.isMethodsUsages){\n        if (!addMethodsUsages(psiClass, processor, classOptions)) return false;\n      }\n      if (classOptions.isFieldsUsages){\n        if (!addFieldsUsages(psiClass, processor, classOptions)) return false;\n      }\n      if (psiClass.isInterface()) {\n        if (classOptions.isDerivedInterfaces){\n          if (classOptions.isImplementingClasses){\n            if (!addInheritors(psiClass, processor, classOptions)) return false;\n          }\n          else{\n            if (!addDerivedInterfaces(psiClass, processor, classOptions)) return false;\n          }\n        }\n        else if (classOptions.isImplementingClasses){\n          if (!addImplementingClasses(psiClass, processor, classOptions)) return false;\n        }\n      }\n      else if (classOptions.isDerivedClasses) {\n        if (!addInheritors(psiClass, processor, classOptions)) return false;\n      }\n    }\n\n    if (options instanceof JavaMethodFindUsagesOptions){\n      final PsiMethod psiMethod = (PsiMethod)element;\n      boolean isAbstract = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          return psiMethod.hasModifierProperty(PsiModifier.ABSTRACT);\n        }\n      });\n      final JavaMethodFindUsagesOptions methodOptions = (JavaMethodFindUsagesOptions)options;\n      if (isAbstract && methodOptions.isImplementingMethods || methodOptions.isOverridingMethods) {\n        if (!processOverridingMethods(psiMethod, processor, methodOptions)) return false;\n      }\n    }\n\n    if (element instanceof PomTarget) {\n       if (!addAliasingUsages((PomTarget)element, processor, options)) return false;\n    }\n    final Boolean isSearchable = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return ThrowSearchUtil.isSearchable(element);\n      }\n    });\n    if (!isSearchable && options.isSearchForTextOccurrences && options.searchScope instanceof GlobalSearchScope) {\n      // todo add to fastTrack\n      if (!processUsagesInText(element, processor, (GlobalSearchScope)options.searchScope)) return false;\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addElementUsages(final PsiElement element, final Processor<UsageInfo> result, final FindUsagesOptions options) {\n    final SearchScope searchScope = options.searchScope;\n    if (element instanceof PsiMethod && ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return ((PsiMethod)element).isConstructor();\n      }\n    })){\n      PsiMethod method = (PsiMethod)element;\n      final PsiClass parentClass = method.getContainingClass();\n\n      if (parentClass != null) {\n        MethodReferencesSearch.search(new MethodReferencesSearch.SearchParameters(method, searchScope, options instanceof JavaMethodFindUsagesOptions ? !((JavaMethodFindUsagesOptions)options).isIncludeOverloadUsages : true, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n          @Override\n          public boolean processInReadAction(final PsiReference ref) {\n            return addResult(result, ref, options);\n          }\n        });\n      }\n      return;\n    }\n\n    final ReadActionProcessor<PsiReference> consumer = new ReadActionProcessor<PsiReference>() {\n      @Override\n      public boolean processInReadAction(final PsiReference ref) {\n        return addResult(result, ref, options);\n      }\n    };\n\n    if (element instanceof PsiMethod) {\n      final boolean strictSignatureSearch = !(options instanceof JavaMethodFindUsagesOptions) || // field with getter\n                                            !((JavaMethodFindUsagesOptions)options).isIncludeOverloadUsages;\n      MethodReferencesSearch.search(new MethodReferencesSearch.SearchParameters((PsiMethod)element, searchScope, strictSignatureSearch, options.fastTrack)).forEach(consumer);\n    } else {\n      ReferencesSearch.search(new ReferencesSearch.SearchParameters(element, searchScope, false, options.fastTrack)).forEach(consumer);\n    }\n  }","id":35459,"modified_method":"private static boolean addElementUsages(@NotNull final PsiElement element,\n                                          @NotNull final Processor<UsageInfo> processor,\n                                          @NotNull final FindUsagesOptions options) {\n    final SearchScope searchScope = options.searchScope;\n    if (element instanceof PsiMethod && ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return ((PsiMethod)element).isConstructor();\n      }\n    })) {\n      PsiMethod method = (PsiMethod)element;\n      final PsiClass parentClass = method.getContainingClass();\n\n      if (parentClass != null) {\n        boolean strictSignatureSearch =\n          !(options instanceof JavaMethodFindUsagesOptions) || !((JavaMethodFindUsagesOptions)options).isIncludeOverloadUsages;\n        return MethodReferencesSearch\n          .search(new MethodReferencesSearch.SearchParameters(method, searchScope, strictSignatureSearch, options.fastTrack))\n          .forEach(new ReadActionProcessor<PsiReference>() {\n            @Override\n            public boolean processInReadAction(final PsiReference ref) {\n              return addResult(processor, ref, options);\n            }\n          });\n      }\n      return true;\n    }\n\n    final ReadActionProcessor<PsiReference> consumer = new ReadActionProcessor<PsiReference>() {\n      @Override\n      public boolean processInReadAction(final PsiReference ref) {\n        return addResult(processor, ref, options);\n      }\n    };\n\n    if (element instanceof PsiMethod) {\n      final boolean strictSignatureSearch = !(options instanceof JavaMethodFindUsagesOptions) || // field with getter\n                                            !((JavaMethodFindUsagesOptions)options).isIncludeOverloadUsages;\n      return MethodReferencesSearch\n        .search(new MethodReferencesSearch.SearchParameters((PsiMethod)element, searchScope, strictSignatureSearch, options.fastTrack))\n        .forEach(consumer);\n    }\n    return ReferencesSearch.search(new ReferencesSearch.SearchParameters(element, searchScope, false, options.fastTrack)).forEach(consumer);\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addClassesInPackage(PsiPackage aPackage, boolean includeSubpackages, ArrayList<PsiClass> array) {\n    PsiDirectory[] dirs = aPackage.getDirectories();\n    for (PsiDirectory dir : dirs) {\n      addClassesInDirectory(dir, includeSubpackages, array);\n    }\n  }","id":35460,"modified_method":"private static void addClassesInPackage(@NotNull PsiPackage aPackage, boolean includeSubpackages, @NotNull List<PsiClass> array) {\n    PsiDirectory[] dirs = aPackage.getDirectories();\n    for (PsiDirectory dir : dirs) {\n      addClassesInDirectory(dir, includeSubpackages, array);\n    }\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addImplementingClasses(PsiClass anInterface, final Processor<UsageInfo> results, final JavaClassFindUsagesOptions options) {\n    ClassInheritorsSearch.search(anInterface, options.searchScope, options.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiClass>(\n      new PsiElementProcessor<PsiClass>() {\n      @Override\n      public boolean execute(@NotNull PsiClass inheritor) {\n        if (!inheritor.isInterface()) {\n          addResult(results, inheritor, options);\n        }\n        return true;\n      }\n\n    }));\n  }","id":35461,"modified_method":"private static boolean addImplementingClasses(@NotNull PsiClass anInterface,\n                                                @NotNull final Processor<UsageInfo> processor,\n                                                @NotNull final JavaClassFindUsagesOptions options) {\n    return ClassInheritorsSearch.search(anInterface, options.searchScope, options.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiClass>(\n      new PsiElementProcessor<PsiClass>() {\n      @Override\n      public boolean execute(@NotNull PsiClass inheritor) {\n        return inheritor.isInterface() || addResult(processor, inheritor, options);\n      }\n    }));\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean addResult(Processor<UsageInfo> results, PsiReference ref, FindUsagesOptions options) {\n    if (filterUsage(ref.getElement(), options)){\n      TextRange rangeInElement = ref.getRangeInElement();\n      return results.process(new UsageInfo(ref.getElement(), rangeInElement.getStartOffset(), rangeInElement.getEndOffset(), false));\n    }\n    return true;\n  }","id":35462,"modified_method":"private static boolean addResult(Processor<UsageInfo> processor, PsiReference ref, FindUsagesOptions options) {\n    if (filterUsage(ref.getElement(), options)){\n      TextRange rangeInElement = ref.getRangeInElement();\n      return processor.process(new UsageInfo(ref.getElement(), rangeInElement.getStartOffset(), rangeInElement.getEndOffset(), false));\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addMethodsUsages(final PsiClass aClass, final Processor<UsageInfo> results, final JavaClassFindUsagesOptions options) {\n    if (options.isIncludeInherited) {\n      final PsiManager manager = aClass.getManager();\n      PsiMethod[] methods = aClass.getAllMethods();\n      MethodsLoop:\n        for(int i = 0; i < methods.length; i++){\n          final PsiMethod method = methods[i];\n          // filter overriden methods\n          MethodSignature methodSignature = method.getSignature(PsiSubstitutor.EMPTY);\n          for(int j = 0; j < i; j++){\n            if (methodSignature.equals(methods[j].getSignature(PsiSubstitutor.EMPTY))) continue MethodsLoop;\n          }\n          final PsiClass methodClass = method.getContainingClass();\n          if (methodClass != null && manager.areElementsEquivalent(methodClass, aClass)){\n            addElementUsages(methods[i], results, options);\n          }\n          else{\n            MethodReferencesSearch.search(new MethodReferencesSearch.SearchParameters(method, options.searchScope, true, options.fastTrack)).forEach(new PsiReferenceProcessorAdapter(new PsiReferenceProcessor() {\n                      @Override\n                      public boolean execute(PsiReference reference) {\n                        addResultFromReference(reference, methodClass, manager, aClass, results, options);\n                        return true;\n                      }\n                    }));\n          }\n        }\n    }\n    else {\n      for (PsiMethod method : aClass.getMethods()) {\n        addElementUsages(method, results, options);\n      }\n    }\n  }","id":35463,"modified_method":"private static boolean addMethodsUsages(@NotNull final PsiClass aClass,\n                                          @NotNull final Processor<UsageInfo> processor,\n                                          @NotNull final JavaClassFindUsagesOptions options) {\n    if (options.isIncludeInherited) {\n      final PsiManager manager = aClass.getManager();\n      PsiMethod[] methods = aClass.getAllMethods();\n      MethodsLoop:\n      for(int i = 0; i < methods.length; i++){\n        final PsiMethod method = methods[i];\n        // filter overriden methods\n        MethodSignature methodSignature = method.getSignature(PsiSubstitutor.EMPTY);\n        for(int j = 0; j < i; j++){\n          if (methodSignature.equals(methods[j].getSignature(PsiSubstitutor.EMPTY))) continue MethodsLoop;\n        }\n        final PsiClass methodClass = method.getContainingClass();\n        if (methodClass != null && manager.areElementsEquivalent(methodClass, aClass)){\n          if (!addElementUsages(methods[i], processor, options)) return false;\n        }\n        else {\n          boolean success = MethodReferencesSearch.search(new MethodReferencesSearch.SearchParameters(method, options.searchScope, true, options.fastTrack))\n            .forEach(new PsiReferenceProcessorAdapter(new PsiReferenceProcessor() {\n              @Override\n              public boolean execute(PsiReference reference) {\n                addResultFromReference(reference, methodClass, manager, aClass, processor, options);\n                return true;\n              }\n            }));\n          if (!success) return false;\n        }\n      }\n    }\n    else {\n      for (PsiMethod method : aClass.getMethods()) {\n        if (!addElementUsages(method, processor, options)) return false;\n      }\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addInheritors(final PsiClass aClass, final Processor<UsageInfo> results, final JavaClassFindUsagesOptions options) {\n    ClassInheritorsSearch.search(aClass, options.searchScope, options.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiClass>(\n      new PsiElementProcessor<PsiClass>() {\n      @Override\n      public boolean execute(@NotNull PsiClass element) {\n        addResult(results, element, options);\n        return true;\n      }\n\n    }));\n  }","id":35464,"modified_method":"private static boolean addInheritors(@NotNull PsiClass aClass,\n                                       @NotNull final Processor<UsageInfo> processor,\n                                       @NotNull final JavaClassFindUsagesOptions options) {\n    return ClassInheritorsSearch.search(aClass, options.searchScope, options.isCheckDeepInheritance).forEach(new PsiElementProcessorAdapter<PsiClass>(\n      new PsiElementProcessor<PsiClass>() {\n      @Override\n      public boolean execute(@NotNull PsiClass element) {\n        return addResult(processor, element, options);\n      }\n\n    }));\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addAliasingUsages(PomTarget pomTarget, final Processor<UsageInfo> processor, final FindUsagesOptions options) {\n    for (AliasingPsiTargetMapper aliasingPsiTargetMapper : Extensions.getExtensions(AliasingPsiTargetMapper.EP_NAME)) {\n      for (AliasingPsiTarget psiTarget : aliasingPsiTargetMapper.getTargets(pomTarget)) {\n          ReferencesSearch.search(new ReferencesSearch.SearchParameters(PomService.convertToPsi(psiTarget), options.searchScope, false, options.fastTrack)).forEach(new ReadActionProcessor<PsiReference>() {\n            @Override\n            public boolean processInReadAction(final PsiReference reference) {\n              addResult(processor, reference, options);\n              return true;\n            }\n          });\n      }\n    }\n  }","id":35465,"modified_method":"private static boolean addAliasingUsages(@NotNull PomTarget pomTarget,\n                                           @NotNull final Processor<UsageInfo> processor,\n                                           @NotNull final FindUsagesOptions options) {\n    for (AliasingPsiTargetMapper aliasingPsiTargetMapper : Extensions.getExtensions(AliasingPsiTargetMapper.EP_NAME)) {\n      for (AliasingPsiTarget psiTarget : aliasingPsiTargetMapper.getTargets(pomTarget)) {\n        boolean success = ReferencesSearch\n          .search(new ReferencesSearch.SearchParameters(PomService.convertToPsi(psiTarget), options.searchScope, false, options.fastTrack))\n          .forEach(new ReadActionProcessor<PsiReference>() {\n            @Override\n            public boolean processInReadAction(final PsiReference reference) {\n              return addResult(processor, reference, options);\n            }\n          });\n        if (!success) return false;\n      }\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addResultFromReference(final PsiReference reference,\n                                             final PsiClass methodClass,\n                                             final PsiManager manager,\n                                             final PsiClass aClass,\n                                             final Processor<UsageInfo> results,\n                                             final FindUsagesOptions options) {\n    PsiElement refElement = reference.getElement();\n    if (refElement instanceof PsiReferenceExpression) {\n      PsiClass usedClass = getFieldOrMethodAccessedClass((PsiReferenceExpression)refElement, methodClass);\n      if (usedClass != null) {\n        if (manager.areElementsEquivalent(usedClass, aClass) || usedClass.isInheritor(aClass, true)) {\n          addResult(results, refElement, options);\n        }\n      }\n    }\n  }","id":35466,"modified_method":"private static boolean addResultFromReference(@NotNull PsiReference reference,\n                                                @NotNull PsiClass methodClass,\n                                                @NotNull PsiManager manager,\n                                                @NotNull PsiClass aClass,\n                                                @NotNull Processor<UsageInfo> processor,\n                                                @NotNull FindUsagesOptions options) {\n    PsiElement refElement = reference.getElement();\n    if (refElement instanceof PsiReferenceExpression) {\n      PsiClass usedClass = getFieldOrMethodAccessedClass((PsiReferenceExpression)refElement, methodClass);\n      if (usedClass != null) {\n        if (manager.areElementsEquivalent(usedClass, aClass) || usedClass.isInheritor(aClass, true)) {\n          if (!addResult(processor, refElement, options)) return false;\n        }\n      }\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addResult(Processor<UsageInfo> total, PsiElement element, FindUsagesOptions options) {\n    if (filterUsage(element, options)){\n      total.process(new UsageInfo(element));\n    }\n  }","id":35467,"modified_method":"private static boolean addResult(@NotNull Processor<UsageInfo> processor, @NotNull PsiElement element, @NotNull FindUsagesOptions options) {\n    return !filterUsage(element, options) || processor.process(new UsageInfo(element));\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addClassesInDirectory(final PsiDirectory dir, final boolean includeSubdirs, final ArrayList<PsiClass> array) {\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        PsiClass[] classes = JavaDirectoryService.getInstance().getClasses(dir);\n        ContainerUtil.addAll(array, classes);\n        if (includeSubdirs) {\n          PsiDirectory[] dirs = dir.getSubdirectories();\n          for (PsiDirectory directory : dirs) {\n            addClassesInDirectory(directory, includeSubdirs, array);\n          }\n        }\n      }\n    });\n  }","id":35468,"modified_method":"private static void addClassesInDirectory(@NotNull final PsiDirectory dir,\n                                            final boolean includeSubdirs,\n                                            @NotNull final List<PsiClass> array) {\n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        PsiClass[] classes = JavaDirectoryService.getInstance().getClasses(dir);\n        ContainerUtil.addAll(array, classes);\n        if (includeSubdirs) {\n          PsiDirectory[] dirs = dir.getSubdirectories();\n          for (PsiDirectory directory : dirs) {\n            addClassesInDirectory(directory, includeSubdirs, array);\n          }\n        }\n      }\n    });\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processAllFilesWithWord(@NotNull String word, @NotNull GlobalSearchScope scope, @NotNull Processor<PsiFile> processor, final boolean caseSensitively) {\n    CacheManager.SERVICE.getInstance(myManager.getProject()).processFilesWithWord(processor, word, UsageSearchContext.IN_CODE, scope, caseSensitively);\n  }","id":35469,"modified_method":"@Override\n  public boolean processAllFilesWithWord(@NotNull String word,\n                                         @NotNull GlobalSearchScope scope,\n                                         @NotNull Processor<PsiFile> processor,\n                                         final boolean caseSensitively) {\n    return CacheManager.SERVICE.getInstance(myManager.getProject()).processFilesWithWord(processor, word, UsageSearchContext.IN_CODE, scope, caseSensitively);\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processAllFilesWithWordInText(@NotNull final String word, @NotNull final GlobalSearchScope scope, @NotNull final Processor<PsiFile> processor,\n                                            final boolean caseSensitively) {\n    CacheManager.SERVICE.getInstance(myManager.getProject()).processFilesWithWord(processor, word, UsageSearchContext.IN_PLAIN_TEXT, scope, caseSensitively);\n  }","id":35470,"modified_method":"@Override\n  public boolean processAllFilesWithWordInText(@NotNull final String word,\n                                               @NotNull final GlobalSearchScope scope,\n                                               @NotNull final Processor<PsiFile> processor,\n                                               final boolean caseSensitively) {\n    return CacheManager.SERVICE.getInstance(myManager.getProject()).processFilesWithWord(processor, word, UsageSearchContext.IN_PLAIN_TEXT, scope, caseSensitively);\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processAllFilesWithWordInLiterals(@NotNull String word, @NotNull GlobalSearchScope scope, @NotNull Processor<PsiFile> processor) {\n    CacheManager.SERVICE.getInstance(myManager.getProject()).processFilesWithWord(processor, word, UsageSearchContext.IN_STRINGS, scope, true);\n  }","id":35471,"modified_method":"@Override\n  public boolean processAllFilesWithWordInLiterals(@NotNull String word,\n                                                   @NotNull GlobalSearchScope scope,\n                                                   @NotNull Processor<PsiFile> processor) {\n    return CacheManager.SERVICE.getInstance(myManager.getProject()).processFilesWithWord(processor, word, UsageSearchContext.IN_STRINGS, scope, true);\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processUsagesInNonJavaFiles(@NotNull String qName,\n                                          @NotNull PsiNonJavaFileReferenceProcessor processor,\n                                          @NotNull GlobalSearchScope searchScope) {\n    processUsagesInNonJavaFiles(null, qName, processor, searchScope);\n  }","id":35472,"modified_method":"@Override\n  public boolean processUsagesInNonJavaFiles(@NotNull String qName,\n                                             @NotNull PsiNonJavaFileReferenceProcessor processor,\n                                             @NotNull GlobalSearchScope searchScope) {\n    return processUsagesInNonJavaFiles(null, qName, processor, searchScope);\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processUsagesInNonJavaFiles(@Nullable final PsiElement originalElement,\n                                          @NotNull String qName,\n                                          @NotNull final PsiNonJavaFileReferenceProcessor processor,\n                                          @NotNull final GlobalSearchScope initialScope) {\n    if (qName.length() == 0) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    final ProgressIndicator progress = ProgressIndicatorProvider.getInstance().getProgressIndicator();\n\n    int dotIndex = qName.lastIndexOf('.');\n    int dollarIndex = qName.lastIndexOf('$');\n    int maxIndex = Math.max(dotIndex, dollarIndex);\n    final String wordToSearch = maxIndex >= 0 ? qName.substring(maxIndex + 1) : qName;\n    final GlobalSearchScope theSearchScope = ApplicationManager.getApplication().runReadAction(new Computable<GlobalSearchScope>() {\n      @Override\n      public GlobalSearchScope compute() {\n        if (originalElement != null && myManager.isInProject(originalElement) && initialScope.isSearchInLibraries()) {\n          return initialScope.intersectWith(GlobalSearchScope.projectScope(myManager.getProject()));\n        }\n        return initialScope;\n      }\n    });\n    PsiFile[] files = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile[]>() {\n      @Override\n      public PsiFile[] compute() {\n        return CacheManager.SERVICE.getInstance(myManager.getProject()).getFilesWithWord(wordToSearch, UsageSearchContext.IN_PLAIN_TEXT, theSearchScope, true);\n      }\n    });\n\n    final StringSearcher searcher = new StringSearcher(qName, true, true);\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.search.in.non.java.files.progress\"));\n    }\n\n    final SearchScope useScope = new ReadAction<SearchScope>() {\n      @Override\n      protected void run(final Result<SearchScope> result) {\n        if (originalElement != null) {\n          result.setResult(getUseScope(originalElement));\n        }\n      }\n    }.execute().getResultObject();\n\n    final Ref<Boolean> cancelled = new Ref<Boolean>(Boolean.FALSE);\n    final GlobalSearchScope finalScope = initialScope;\n    for (int i = 0; i < files.length; i++) {\n      if (progress != null) progress.checkCanceled();\n\n      final PsiFile psiFile = files[i];\n\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          CharSequence text = psiFile.getViewProvider().getContents();\n          final char[] textArray = CharArrayUtil.fromSequenceWithoutCopying(text);\n          for (int index = LowLevelSearchUtil.searchWord(text, textArray, 0, text.length(), searcher, progress); index >= 0;) {\n            PsiReference referenceAt = psiFile.findReferenceAt(index);\n            if (referenceAt == null || useScope == null ||\n                !PsiSearchScopeUtil.isInScope(useScope.intersectWith(finalScope), psiFile)) {\n              if (!processor.process(psiFile, index, index + searcher.getPattern().length())) {\n                cancelled.set(Boolean.TRUE);\n                return;\n              }\n            }\n\n            index = LowLevelSearchUtil.searchWord(text, textArray, index + searcher.getPattern().length(), text.length(), searcher, progress);\n          }\n        }\n      });\n      if (cancelled.get()) break;\n      if (progress != null) {\n        progress.setFraction((double)(i + 1) / files.length);\n      }\n    }\n\n    if (progress != null) {\n      progress.popState();\n    }\n  }","id":35473,"modified_method":"@Override\n  public boolean processUsagesInNonJavaFiles(@Nullable final PsiElement originalElement,\n                                             @NotNull String qName,\n                                             @NotNull final PsiNonJavaFileReferenceProcessor processor,\n                                             @NotNull final GlobalSearchScope initialScope) {\n    if (qName.length() == 0) {\n      throw new IllegalArgumentException(\"Cannot search for elements with empty text\");\n    }\n    final ProgressIndicator progress = ProgressIndicatorProvider.getInstance().getProgressIndicator();\n\n    int dotIndex = qName.lastIndexOf('.');\n    int dollarIndex = qName.lastIndexOf('$');\n    int maxIndex = Math.max(dotIndex, dollarIndex);\n    final String wordToSearch = maxIndex >= 0 ? qName.substring(maxIndex + 1) : qName;\n    final GlobalSearchScope theSearchScope = ApplicationManager.getApplication().runReadAction(new Computable<GlobalSearchScope>() {\n      @Override\n      public GlobalSearchScope compute() {\n        if (originalElement != null && myManager.isInProject(originalElement) && initialScope.isSearchInLibraries()) {\n          return initialScope.intersectWith(GlobalSearchScope.projectScope(myManager.getProject()));\n        }\n        return initialScope;\n      }\n    });\n    PsiFile[] files = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile[]>() {\n      @Override\n      public PsiFile[] compute() {\n        return CacheManager.SERVICE.getInstance(myManager.getProject()).getFilesWithWord(wordToSearch, UsageSearchContext.IN_PLAIN_TEXT, theSearchScope, true);\n      }\n    });\n\n    final StringSearcher searcher = new StringSearcher(qName, true, true);\n\n    if (progress != null) {\n      progress.pushState();\n      progress.setText(PsiBundle.message(\"psi.search.in.non.java.files.progress\"));\n    }\n\n    final SearchScope useScope = new ReadAction<SearchScope>() {\n      @Override\n      protected void run(final Result<SearchScope> result) {\n        if (originalElement != null) {\n          result.setResult(getUseScope(originalElement));\n        }\n      }\n    }.execute().getResultObject();\n\n    final Ref<Boolean> cancelled = new Ref<Boolean>(Boolean.FALSE);\n    for (int i = 0; i < files.length; i++) {\n      if (progress != null) progress.checkCanceled();\n      final PsiFile psiFile = files[i];\n\n      ApplicationManager.getApplication().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          CharSequence text = psiFile.getViewProvider().getContents();\n          final char[] textArray = CharArrayUtil.fromSequenceWithoutCopying(text);\n          for (int index = LowLevelSearchUtil.searchWord(text, textArray, 0, text.length(), searcher, progress); index >= 0;) {\n            PsiReference referenceAt = psiFile.findReferenceAt(index);\n            if (referenceAt == null || useScope == null ||\n                !PsiSearchScopeUtil.isInScope(useScope.intersectWith(initialScope), psiFile)) {\n              if (!processor.process(psiFile, index, index + searcher.getPattern().length())) {\n                cancelled.set(Boolean.TRUE);\n                return;\n              }\n            }\n\n            index = LowLevelSearchUtil.searchWord(text, textArray, index + searcher.getPattern().length(), text.length(), searcher, progress);\n          }\n        }\n      });\n      if (cancelled.get()) break;\n      if (progress != null) {\n        progress.setFraction((double)(i + 1) / files.length);\n      }\n    }\n\n    if (progress != null) {\n      progress.popState();\n    }\n    return !cancelled.get();\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processPsiFileRoots(@NotNull List<VirtualFile> files,\n                                      @NotNull final Processor<PsiElement> psiRootProcessor,\n                                      final ProgressIndicator progress) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      final AtomicInteger counter = new AtomicInteger(0);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n      final AtomicBoolean pceThrown = new AtomicBoolean(false);\n\n      final int size = files.size();\n      boolean completed = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files, progress, false, new Processor<VirtualFile>() {\n        @Override\n        public boolean process(final VirtualFile vfile) {\n          final PsiFile file = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n            @Override\n            public PsiFile compute() {\n              return myManager.findFile(vfile);\n            }\n          });\n          if (file != null && !(file instanceof PsiBinaryFile)) {\n            file.getViewProvider().getContents(); // load contents outside readaction\n            ApplicationManager.getApplication().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                try {\n                  if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n                  List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n                  Set<PsiElement> processed = new HashSet<PsiElement>(psiRoots.size() * 2, (float)0.5);\n                  for (PsiElement psiRoot : psiRoots) {\n                    if (progress != null) progress.checkCanceled();\n                    if (!processed.add(psiRoot)) continue;\n                    if (!psiRoot.isValid()) continue;\n                    assert psiRoot != null : \"One of the roots of file \" +\n                                             file +\n                                             \" is null. All roots: \" +\n                                             Arrays.asList(psiRoots) +\n                                             \"; Viewprovider: \" +\n                                             file.getViewProvider() +\n                                             \"; Virtual file: \" +\n                                             file.getViewProvider().getVirtualFile();\n                    if (!psiRootProcessor.process(psiRoot)) {\n                      canceled.set(true);\n                      return;\n                    }\n                  }\n                  myManager.dropResolveCaches();\n                }\n                catch (ProcessCanceledException e) {\n                  canceled.set(true);\n                  pceThrown.set(true);\n                }\n              }\n            });\n          }\n          if (progress != null && progress.isRunning()) {\n            double fraction = (double)counter.incrementAndGet() / size;\n            progress.setFraction(fraction);\n          }\n          return !canceled.get();\n        }\n      });\n\n      if (pceThrown.get()) {\n        throw new ProcessCanceledException();\n      }\n\n      return completed;\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n  }","id":35474,"modified_method":"private boolean processPsiFileRoots(@NotNull List<VirtualFile> files,\n                                      @NotNull final Processor<PsiElement> psiRootProcessor,\n                                      final ProgressIndicator progress) {\n    myManager.startBatchFilesProcessingMode();\n    try {\n      final AtomicInteger counter = new AtomicInteger(0);\n      final AtomicBoolean canceled = new AtomicBoolean(false);\n      final AtomicBoolean pceThrown = new AtomicBoolean(false);\n\n      final int size = files.size();\n      boolean completed = JobLauncher.getInstance().invokeConcurrentlyUnderProgress(files, progress, false, new Processor<VirtualFile>() {\n        @Override\n        public boolean process(final VirtualFile vfile) {\n          final PsiFile file = ApplicationManager.getApplication().runReadAction(new Computable<PsiFile>() {\n            @Override\n            public PsiFile compute() {\n              return vfile.isValid() ? myManager.findFile(vfile) : null;\n            }\n          });\n          if (file != null && !(file instanceof PsiBinaryFile)) {\n            file.getViewProvider().getContents(); // load contents outside readaction\n            ApplicationManager.getApplication().runReadAction(new Runnable() {\n              @Override\n              public void run() {\n                try {\n                  if (myManager.getProject().isDisposed()) throw new ProcessCanceledException();\n                  List<PsiFile> psiRoots = file.getViewProvider().getAllFiles();\n                  Set<PsiElement> processed = new HashSet<PsiElement>(psiRoots.size() * 2, (float)0.5);\n                  for (PsiElement psiRoot : psiRoots) {\n                    if (progress != null) progress.checkCanceled();\n                    if (!processed.add(psiRoot)) continue;\n                    if (!psiRoot.isValid()) continue;\n                    assert psiRoot != null : \"One of the roots of file \" +\n                                             file +\n                                             \" is null. All roots: \" +\n                                             Arrays.asList(psiRoots) +\n                                             \"; Viewprovider: \" +\n                                             file.getViewProvider() +\n                                             \"; Virtual file: \" +\n                                             file.getViewProvider().getVirtualFile();\n                    if (!psiRootProcessor.process(psiRoot)) {\n                      canceled.set(true);\n                      return;\n                    }\n                  }\n                  myManager.dropResolveCaches();\n                }\n                catch (ProcessCanceledException e) {\n                  canceled.set(true);\n                  pceThrown.set(true);\n                }\n              }\n            });\n          }\n          if (progress != null && progress.isRunning()) {\n            double fraction = (double)counter.incrementAndGet() / size;\n            progress.setFraction(fraction);\n          }\n          return !canceled.get();\n        }\n      });\n\n      if (pceThrown.get()) {\n        throw new ProcessCanceledException();\n      }\n\n      return completed;\n    }\n    finally {\n      myManager.finishBatchFilesProcessingMode();\n    }\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processAllFilesWithWordInComments(@NotNull String word, @NotNull GlobalSearchScope scope, @NotNull Processor<PsiFile> processor) {\n    CacheManager.SERVICE.getInstance(myManager.getProject()).processFilesWithWord(processor, word, UsageSearchContext.IN_COMMENTS, scope, true);\n  }","id":35475,"modified_method":"@Override\n  public boolean processAllFilesWithWordInComments(@NotNull String word,\n                                                   @NotNull GlobalSearchScope scope,\n                                                   @NotNull Processor<PsiFile> processor) {\n    return CacheManager.SERVICE.getInstance(myManager.getProject()).processFilesWithWord(processor, word, UsageSearchContext.IN_COMMENTS, scope, true);\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void processTextOccurences(@NotNull final PsiElement element,\n                                           @NotNull String stringToSearch,\n                                           @NotNull GlobalSearchScope searchScope,\n                                           @NotNull final Processor<UsageInfo> processor,\n                                           @NotNull final UsageInfoFactory factory) {\n    PsiSearchHelper helper = ApplicationManager.getApplication().runReadAction(new Computable<PsiSearchHelper>() {\n      @Override\n      public PsiSearchHelper compute() {\n        return PsiSearchHelper.SERVICE.getInstance(element.getProject());\n      }\n    });\n\n    helper.processUsagesInNonJavaFiles(element, stringToSearch, new PsiNonJavaFileReferenceProcessor() {\n      public boolean process(PsiFile psiFile, int startOffset, int endOffset) {\n        UsageInfo usageInfo = factory.createUsageInfo(psiFile, startOffset, endOffset);\n        return usageInfo == null || processor.process(usageInfo);\n      }\n    }, searchScope);\n  }","id":35476,"modified_method":"public static boolean processTextOccurences(@NotNull final PsiElement element,\n                                           @NotNull String stringToSearch,\n                                           @NotNull GlobalSearchScope searchScope,\n                                           @NotNull final Processor<UsageInfo> processor,\n                                           @NotNull final UsageInfoFactory factory) {\n    PsiSearchHelper helper = ApplicationManager.getApplication().runReadAction(new Computable<PsiSearchHelper>() {\n      @Override\n      public PsiSearchHelper compute() {\n        return PsiSearchHelper.SERVICE.getInstance(element.getProject());\n      }\n    });\n\n    return helper.processUsagesInNonJavaFiles(element, stringToSearch, new PsiNonJavaFileReferenceProcessor() {\n      public boolean process(PsiFile psiFile, int startOffset, int endOffset) {\n        UsageInfo usageInfo = factory.createUsageInfo(psiFile, startOffset, endOffset);\n        return usageInfo == null || processor.process(usageInfo);\n      }\n    }, searchScope);\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return true, if we should continue processing\n   * @param aCatch\n   * @param processor\n   * @param root\n   */\n\n  private static boolean processExn(final PsiParameter aCatch, Processor<UsageInfo> processor, Root root) {\n    final PsiType type = aCatch.getType();\n    if (type.isAssignableFrom(root.myType)) {\n      processor.process (new UsageInfo (aCatch));\n      return false;\n    }\n    else if (!root.isExact && root.myType.isAssignableFrom (type)) {\n        processor.process (new UsageInfo (aCatch));\n        return true;\n    }\n    return true;\n  }","id":35477,"modified_method":"/**\n   * @param aCatch\n   * @param processor\n   * @param root\n   * @return true, if we should continue processing\n   */\n  private static boolean processExn(@NotNull PsiParameter aCatch, @NotNull Processor<UsageInfo> processor, @NotNull Root root) {\n    final PsiType type = aCatch.getType();\n    if (type.isAssignableFrom(root.myType)) {\n      processor.process(new UsageInfo(aCatch));\n      return false;\n    }\n    if (!root.isExact && root.myType.isAssignableFrom(type)) {\n      processor.process(new UsageInfo(aCatch));\n      return true;\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void addThrowUsages(Processor<UsageInfo> processor, Root root, FindUsagesOptions options) {\n    Set<PsiMethod> processed = new HashSet<PsiMethod>();\n    scanCatches (root.myElement, processor, root, options, processed);\n  }","id":35478,"modified_method":"public static boolean addThrowUsages(@NotNull Processor<UsageInfo> processor, @NotNull Root root, @NotNull FindUsagesOptions options) {\n    Set<PsiMethod> processed = new HashSet<PsiMethod>();\n    return scanCatches(root.myElement, processor, root, options, processed);\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String toString() {\n      return PsiFormatUtil.formatType (myType, PsiFormatUtil.SHOW_FQ_CLASS_NAMES, PsiSubstitutor.EMPTY);\n    }","id":35479,"modified_method":"public String toString() {\n      return PsiFormatUtil.formatType(myType, PsiFormatUtilBase.SHOW_FQ_CLASS_NAMES, PsiSubstitutor.EMPTY);\n    }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void scanCatches(PsiElement elem,\n                                  Processor<UsageInfo> processor,\n                                  Root root,\n                                  FindUsagesOptions options,\n                                  Set<PsiMethod> processed)\n  {\n    while (elem != null) {\n      final PsiElement parent = elem.getParent();\n      if (elem instanceof PsiMethod) {\n        final PsiMethod deepestSuperMethod = ((PsiMethod) elem).findDeepestSuperMethod();\n        final PsiMethod method = deepestSuperMethod != null ? deepestSuperMethod : (PsiMethod)elem;\n        if (!processed.contains(method)) {\n          processed.add(method);\n          final PsiReference[] refs = MethodReferencesSearch.search(method, options.searchScope, true).toArray(PsiReference.EMPTY_ARRAY);\n          for (int i = 0; i != refs.length; ++i) {\n            scanCatches(refs[i].getElement(), processor, root, options, processed);\n          }\n        }\n        return;\n      }\n      else if (elem instanceof PsiTryStatement) {\n        final PsiTryStatement aTry = (PsiTryStatement) elem;\n        final PsiParameter[] catches = aTry.getCatchBlockParameters();\n        for (int i = 0; i != catches.length; ++ i) {\n          if (!processExn(catches[i], processor, root)) {\n            return;\n          }\n        }\n      }\n      else if (parent instanceof PsiTryStatement) {\n        final PsiTryStatement tryStmt = (PsiTryStatement) parent;\n        if (elem != tryStmt.getTryBlock()) {\n          elem = parent.getParent();\n          continue;\n        }\n      }\n      elem = parent;\n    }\n  }","id":35480,"modified_method":"private static boolean scanCatches(@NotNull PsiElement elem,\n                                     @NotNull Processor<UsageInfo> processor,\n                                     @NotNull Root root,\n                                     @NotNull FindUsagesOptions options,\n                                     @NotNull Set<PsiMethod> processed) {\n    while (elem != null) {\n      final PsiElement parent = elem.getParent();\n      if (elem instanceof PsiMethod) {\n        final PsiMethod deepestSuperMethod = ((PsiMethod)elem).findDeepestSuperMethod();\n        final PsiMethod method = deepestSuperMethod != null ? deepestSuperMethod : (PsiMethod)elem;\n        if (!processed.contains(method)) {\n          processed.add(method);\n          final PsiReference[] refs = MethodReferencesSearch.search(method, options.searchScope, true).toArray(PsiReference.EMPTY_ARRAY);\n          for (int i = 0; i != refs.length; ++i) {\n            if (!scanCatches(refs[i].getElement(), processor, root, options, processed)) return false;\n          }\n        }\n        return true;\n      }\n      if (elem instanceof PsiTryStatement) {\n        final PsiTryStatement aTry = (PsiTryStatement)elem;\n        final PsiParameter[] catches = aTry.getCatchBlockParameters();\n        for (int i = 0; i != catches.length; ++i) {\n          if (!processExn(catches[i], processor, root)) {\n            return false;\n          }\n        }\n      }\n      else if (parent instanceof PsiTryStatement) {\n        final PsiTryStatement tryStmt = (PsiTryStatement)parent;\n        if (elem != tryStmt.getTryBlock()) {\n          elem = parent.getParent();\n          continue;\n        }\n      }\n      elem = parent;\n    }\n    return true;\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getSearchableTypeName(final PsiElement e) {\n    if (e instanceof PsiThrowStatement) {\n      final PsiThrowStatement aThrow = (PsiThrowStatement) e;\n      final PsiType type = aThrow.getException ().getType ();\n      return PsiFormatUtil.formatType (type, PsiFormatUtil.SHOW_FQ_CLASS_NAMES, PsiSubstitutor.EMPTY);\n    }\n    if (e instanceof PsiKeyword && PsiKeyword.THROWS.equals (e.getText())) {\n      return e.getParent().getText ();\n    }\n    LOG.error (\"invalid searchable element\");\n    return e.getText();\n  }","id":35481,"modified_method":"public static String getSearchableTypeName(final PsiElement e) {\n    if (e instanceof PsiThrowStatement) {\n      final PsiThrowStatement aThrow = (PsiThrowStatement)e;\n      final PsiType type = aThrow.getException().getType();\n      return PsiFormatUtil.formatType(type, PsiFormatUtilBase.SHOW_FQ_CLASS_NAMES, PsiSubstitutor.EMPTY);\n    }\n    if (e instanceof PsiKeyword && PsiKeyword.THROWS.equals(e.getText())) {\n      return e.getParent().getText();\n    }\n    LOG.error(\"invalid searchable element\");\n    return e.getText();\n  }","commit_id":"c436a7d815c7eddd22800788295b9a2756da00f9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        boolean disableCoord = false;\n        float boost = 1.0f;\n        int minimumNumberShouldMatch = -1;\n\n        List<BooleanClause> clauses = newArrayList();\n\n        String currentFieldName = null;\n        JsonToken token;\n        while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n            if (token == JsonToken.FIELD_NAME) {\n                currentFieldName = jp.getCurrentName();\n            } else if (token == JsonToken.START_OBJECT) {\n                if (\"must\".equals(currentFieldName)) {\n                    clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.MUST));\n                } else if (\"mustNot\".equals(currentFieldName)) {\n                    clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.MUST_NOT));\n                } else if (\"should\".equals(currentFieldName)) {\n                    clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.SHOULD));\n                }\n            } else if (token == JsonToken.START_ARRAY) {\n                if (\"must\".equals(currentFieldName)) {\n                    while ((token = jp.nextToken()) != JsonToken.END_ARRAY) {\n                        clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.MUST));\n                    }\n                } else if (\"mustNot\".equals(currentFieldName)) {\n                    while ((token = jp.nextToken()) != JsonToken.END_ARRAY) {\n                        clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.MUST_NOT));\n                    }\n                } else if (\"should\".equals(currentFieldName)) {\n                    while ((token = jp.nextToken()) != JsonToken.END_ARRAY) {\n                        clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.SHOULD));\n                    }\n                }\n            } else if (token == JsonToken.VALUE_TRUE || token == JsonToken.VALUE_FALSE) {\n                if (\"disableCoord\".equals(currentFieldName)) {\n                    disableCoord = token == JsonToken.VALUE_TRUE;\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_INT) {\n                if (\"disableCoord\".equals(currentFieldName)) {\n                    disableCoord = jp.getIntValue() != 0;\n                }\n            } else {\n                if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"minimumNumberShouldMatch\".equals(currentFieldName)) {\n                    minimumNumberShouldMatch = jp.getIntValue();\n                }\n            }\n        }\n\n        BooleanQuery query = new BooleanQuery(disableCoord);\n        for (BooleanClause clause : clauses) {\n            query.add(clause);\n        }\n        query.setBoost(boost);\n        if (minimumNumberShouldMatch != -1) {\n            query.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        }\n        return fixNegativeQueryIfNeeded(query);\n    }","id":35482,"modified_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        boolean disableCoord = false;\n        float boost = 1.0f;\n        int minimumNumberShouldMatch = -1;\n\n        List<BooleanClause> clauses = newArrayList();\n\n        String currentFieldName = null;\n        JsonToken token;\n        while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n            if (token == JsonToken.FIELD_NAME) {\n                currentFieldName = jp.getCurrentName();\n            } else if (token == JsonToken.START_OBJECT) {\n                if (\"must\".equals(currentFieldName)) {\n                    clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.MUST));\n                } else if (\"mustNot\".equals(currentFieldName)) {\n                    clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.MUST_NOT));\n                } else if (\"should\".equals(currentFieldName)) {\n                    clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.SHOULD));\n                }\n            } else if (token == JsonToken.START_ARRAY) {\n                if (\"must\".equals(currentFieldName)) {\n                    while ((token = jp.nextToken()) != JsonToken.END_ARRAY) {\n                        clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.MUST));\n                    }\n                } else if (\"mustNot\".equals(currentFieldName)) {\n                    while ((token = jp.nextToken()) != JsonToken.END_ARRAY) {\n                        clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.MUST_NOT));\n                    }\n                } else if (\"should\".equals(currentFieldName)) {\n                    while ((token = jp.nextToken()) != JsonToken.END_ARRAY) {\n                        clauses.add(new BooleanClause(parseContext.parseInnerQuery(), BooleanClause.Occur.SHOULD));\n                    }\n                }\n            } else if (token == JsonToken.VALUE_TRUE || token == JsonToken.VALUE_FALSE) {\n                if (\"disableCoord\".equals(currentFieldName)) {\n                    disableCoord = token == JsonToken.VALUE_TRUE;\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_INT) {\n                if (\"disableCoord\".equals(currentFieldName)) {\n                    disableCoord = jp.getIntValue() != 0;\n                }\n            } else {\n                if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"minimumNumberShouldMatch\".equals(currentFieldName)) {\n                    minimumNumberShouldMatch = jp.getIntValue();\n                }\n            }\n        }\n\n        BooleanQuery query = new BooleanQuery(disableCoord);\n        for (BooleanClause clause : clauses) {\n            query.add(clause);\n        }\n        query.setBoost(boost);\n        if (minimumNumberShouldMatch != -1) {\n            query.setMinimumNumberShouldMatch(minimumNumberShouldMatch);\n        }\n        return optimizeQuery(fixNegativeQueryIfNeeded(query));\n    }","commit_id":"7709c68f6312703b60b40f9ded1bd6121daa1d58","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        JsonToken token = jp.nextToken();\n        assert token == JsonToken.FIELD_NAME;\n        String fieldName = jp.getCurrentName();\n\n        String queryString = null;\n        float boost = 1.0f;\n        MapperQueryParser.Operator defaultOperator = QueryParser.Operator.OR;\n        boolean lowercaseExpandedTerms = true;\n        boolean enablePositionIncrements = true;\n        int phraseSlop = 0;\n        float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;\n        int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;\n        boolean escape = false;\n        Analyzer analyzer = null;\n        token = jp.nextToken();\n        if (token == JsonToken.START_OBJECT) {\n            String currentFieldName = null;\n            while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n                if (token == JsonToken.FIELD_NAME) {\n                    currentFieldName = jp.getCurrentName();\n                } else {\n                    if (\"query\".equals(currentFieldName)) {\n                        queryString = jp.getText();\n                    } else if (\"boost\".equals(currentFieldName)) {\n                        boost = jp.getFloatValue();\n                    } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                        if (token == JsonToken.VALUE_TRUE) {\n                            enablePositionIncrements = true;\n                        } else if (token == JsonToken.VALUE_FALSE) {\n                            enablePositionIncrements = false;\n                        } else {\n                            enablePositionIncrements = jp.getIntValue() != 0;\n                        }\n                    } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                        if (token == JsonToken.VALUE_TRUE) {\n                            lowercaseExpandedTerms = true;\n                        } else if (token == JsonToken.VALUE_FALSE) {\n                            lowercaseExpandedTerms = false;\n                        } else {\n                            lowercaseExpandedTerms = jp.getIntValue() != 0;\n                        }\n                    } else if (\"phraseSlop\".equals(currentFieldName)) {\n                        phraseSlop = jp.getIntValue();\n                    } else if (\"analyzer\".equals(currentFieldName)) {\n                        analyzer = analysisService.analyzer(jp.getText());\n                    } else if (\"defaultOperator\".equals(currentFieldName)) {\n                        String op = jp.getText();\n                        if (\"or\".equalsIgnoreCase(op)) {\n                            defaultOperator = QueryParser.Operator.OR;\n                        } else if (\"and\".equalsIgnoreCase(op)) {\n                            defaultOperator = QueryParser.Operator.AND;\n                        } else {\n                            throw new QueryParsingException(index, \"Query default operator [\" + op + \"] is not allowed\");\n                        }\n                    } else if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                        fuzzyMinSim = jp.getFloatValue();\n                    } else if (\"fuzzyPrefixLength\".equals(currentFieldName)) {\n                        fuzzyPrefixLength = jp.getIntValue();\n                    } else if (\"escape\".equals(currentFieldName)) {\n                        if (token == JsonToken.VALUE_TRUE) {\n                            escape = true;\n                        } else if (token == JsonToken.VALUE_FALSE) {\n                            escape = false;\n                        } else {\n                            escape = jp.getIntValue() != 0;\n                        }\n                    }\n                }\n            }\n            jp.nextToken();\n        } else {\n            queryString = jp.getText();\n            // move to the next token\n            jp.nextToken();\n        }\n\n        if (analyzer == null) {\n            analyzer = parseContext.mapperService().searchAnalyzer();\n        }\n\n        if (queryString == null) {\n            throw new QueryParsingException(index, \"No value specified for term query\");\n        }\n\n        MapperQueryParser queryParser = new MapperQueryParser(fieldName, analyzer, parseContext.mapperService(), parseContext.filterCache());\n        queryParser.setEnablePositionIncrements(enablePositionIncrements);\n        queryParser.setLowercaseExpandedTerms(lowercaseExpandedTerms);\n        queryParser.setPhraseSlop(phraseSlop);\n        queryParser.setDefaultOperator(defaultOperator);\n        queryParser.setFuzzyMinSim(fuzzyMinSim);\n        queryParser.setFuzzyPrefixLength(fuzzyPrefixLength);\n\n        if (escape) {\n            queryString = QueryParser.escape(queryString);\n        }\n\n        try {\n            Query query = queryParser.parse(queryString);\n            query.setBoost(boost);\n            return fixNegativeQueryIfNeeded(query);\n        } catch (ParseException e) {\n            throw new QueryParsingException(index, \"Failed to parse query [\" + queryString + \"]\", e);\n        }\n    }","id":35483,"modified_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        JsonToken token = jp.nextToken();\n        assert token == JsonToken.FIELD_NAME;\n        String fieldName = jp.getCurrentName();\n\n        String queryString = null;\n        float boost = 1.0f;\n        MapperQueryParser.Operator defaultOperator = QueryParser.Operator.OR;\n        boolean lowercaseExpandedTerms = true;\n        boolean enablePositionIncrements = true;\n        int phraseSlop = 0;\n        float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;\n        int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;\n        boolean escape = false;\n        Analyzer analyzer = null;\n        token = jp.nextToken();\n        if (token == JsonToken.START_OBJECT) {\n            String currentFieldName = null;\n            while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n                if (token == JsonToken.FIELD_NAME) {\n                    currentFieldName = jp.getCurrentName();\n                } else {\n                    if (\"query\".equals(currentFieldName)) {\n                        queryString = jp.getText();\n                    } else if (\"boost\".equals(currentFieldName)) {\n                        boost = jp.getFloatValue();\n                    } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                        if (token == JsonToken.VALUE_TRUE) {\n                            enablePositionIncrements = true;\n                        } else if (token == JsonToken.VALUE_FALSE) {\n                            enablePositionIncrements = false;\n                        } else {\n                            enablePositionIncrements = jp.getIntValue() != 0;\n                        }\n                    } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                        if (token == JsonToken.VALUE_TRUE) {\n                            lowercaseExpandedTerms = true;\n                        } else if (token == JsonToken.VALUE_FALSE) {\n                            lowercaseExpandedTerms = false;\n                        } else {\n                            lowercaseExpandedTerms = jp.getIntValue() != 0;\n                        }\n                    } else if (\"phraseSlop\".equals(currentFieldName)) {\n                        phraseSlop = jp.getIntValue();\n                    } else if (\"analyzer\".equals(currentFieldName)) {\n                        analyzer = analysisService.analyzer(jp.getText());\n                    } else if (\"defaultOperator\".equals(currentFieldName)) {\n                        String op = jp.getText();\n                        if (\"or\".equalsIgnoreCase(op)) {\n                            defaultOperator = QueryParser.Operator.OR;\n                        } else if (\"and\".equalsIgnoreCase(op)) {\n                            defaultOperator = QueryParser.Operator.AND;\n                        } else {\n                            throw new QueryParsingException(index, \"Query default operator [\" + op + \"] is not allowed\");\n                        }\n                    } else if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                        fuzzyMinSim = jp.getFloatValue();\n                    } else if (\"fuzzyPrefixLength\".equals(currentFieldName)) {\n                        fuzzyPrefixLength = jp.getIntValue();\n                    } else if (\"escape\".equals(currentFieldName)) {\n                        if (token == JsonToken.VALUE_TRUE) {\n                            escape = true;\n                        } else if (token == JsonToken.VALUE_FALSE) {\n                            escape = false;\n                        } else {\n                            escape = jp.getIntValue() != 0;\n                        }\n                    }\n                }\n            }\n            jp.nextToken();\n        } else {\n            queryString = jp.getText();\n            // move to the next token\n            jp.nextToken();\n        }\n\n        if (analyzer == null) {\n            analyzer = parseContext.mapperService().searchAnalyzer();\n        }\n\n        if (queryString == null) {\n            throw new QueryParsingException(index, \"No value specified for term query\");\n        }\n\n        MapperQueryParser queryParser = new MapperQueryParser(fieldName, analyzer, parseContext.mapperService(), parseContext.filterCache());\n        queryParser.setEnablePositionIncrements(enablePositionIncrements);\n        queryParser.setLowercaseExpandedTerms(lowercaseExpandedTerms);\n        queryParser.setPhraseSlop(phraseSlop);\n        queryParser.setDefaultOperator(defaultOperator);\n        queryParser.setFuzzyMinSim(fuzzyMinSim);\n        queryParser.setFuzzyPrefixLength(fuzzyPrefixLength);\n\n        if (escape) {\n            queryString = QueryParser.escape(queryString);\n        }\n\n        try {\n            Query query = queryParser.parse(queryString);\n            query.setBoost(boost);\n            return optimizeQuery(fixNegativeQueryIfNeeded(query));\n        } catch (ParseException e) {\n            throw new QueryParsingException(index, \"Failed to parse query [\" + queryString + \"]\", e);\n        }\n    }","commit_id":"7709c68f6312703b60b40f9ded1bd6121daa1d58","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        // move to the field value\n\n        String queryString = null;\n        String defaultField = null;\n        MapperQueryParser.Operator defaultOperator = QueryParser.Operator.OR;\n        boolean allowLeadingWildcard = true;\n        boolean lowercaseExpandedTerms = true;\n        boolean enablePositionIncrements = true;\n        float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;\n        int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;\n        int phraseSlop = 0;\n        float boost = 1.0f;\n        boolean escape = false;\n        Analyzer analyzer = null;\n\n        String currentFieldName = null;\n        JsonToken token;\n        while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n            if (token == JsonToken.FIELD_NAME) {\n                currentFieldName = jp.getCurrentName();\n            } else if (token == JsonToken.VALUE_STRING) {\n                if (\"query\".equals(currentFieldName)) {\n                    queryString = jp.getText();\n                } else if (\"defaultField\".equals(currentFieldName)) {\n                    defaultField = parseContext.indexName(jp.getText());\n                } else if (\"defaultOperator\".equals(currentFieldName)) {\n                    String op = jp.getText();\n                    if (\"or\".equalsIgnoreCase(op)) {\n                        defaultOperator = QueryParser.Operator.OR;\n                    } else if (\"and\".equalsIgnoreCase(op)) {\n                        defaultOperator = QueryParser.Operator.AND;\n                    } else {\n                        throw new QueryParsingException(index, \"Query default operator [\" + op + \"] is not allowed\");\n                    }\n                } else if (\"analyzer\".equals(currentFieldName)) {\n                    analyzer = analysisService.analyzer(jp.getText());\n                }\n            } else if (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE) {\n                if (\"allowLeadingWildcard\".equals(currentFieldName)) {\n                    allowLeadingWildcard = token == JsonToken.VALUE_TRUE;\n                } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                    lowercaseExpandedTerms = token == JsonToken.VALUE_TRUE;\n                } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                    enablePositionIncrements = token == JsonToken.VALUE_TRUE;\n                } else if (\"escape\".equals(currentFieldName)) {\n                    escape = token == JsonToken.VALUE_TRUE;\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_FLOAT) {\n                if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                    fuzzyMinSim = jp.getFloatValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_INT) {\n                if (\"fuzzyPrefixLength\".equals(currentFieldName)) {\n                    fuzzyPrefixLength = jp.getIntValue();\n                } else if (\"phraseSlop\".equals(currentFieldName)) {\n                    phraseSlop = jp.getIntValue();\n                } else if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                    fuzzyMinSim = jp.getFloatValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"allowLeadingWildcard\".equals(currentFieldName)) {\n                    allowLeadingWildcard = jp.getIntValue() != 0;\n                } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                    lowercaseExpandedTerms = jp.getIntValue() != 0;\n                } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                    enablePositionIncrements = jp.getIntValue() != 0;\n                } else if (\"escape\".equals(currentFieldName)) {\n                    escape = jp.getIntValue() != 0;\n                }\n            }\n        }\n        if (queryString == null) {\n            throw new QueryParsingException(index, \"QueryString must be provided with a [query]\");\n        }\n        if (analyzer == null) {\n            analyzer = parseContext.mapperService().searchAnalyzer();\n        }\n\n        MapperQueryParser queryParser = new MapperQueryParser(defaultField, analyzer, parseContext.mapperService(), parseContext.filterCache());\n        queryParser.setEnablePositionIncrements(enablePositionIncrements);\n        queryParser.setLowercaseExpandedTerms(lowercaseExpandedTerms);\n        queryParser.setAllowLeadingWildcard(allowLeadingWildcard);\n        queryParser.setDefaultOperator(defaultOperator);\n        queryParser.setFuzzyMinSim(fuzzyMinSim);\n        queryParser.setFuzzyPrefixLength(fuzzyPrefixLength);\n        queryParser.setPhraseSlop(phraseSlop);\n\n        if (escape) {\n            queryString = QueryParser.escape(queryString);\n        }\n\n        try {\n            Query query = queryParser.parse(queryString);\n            query.setBoost(boost);\n            return fixNegativeQueryIfNeeded(query);\n        } catch (ParseException e) {\n            throw new QueryParsingException(index, \"Failed to parse query [\" + queryString + \"]\", e);\n        }\n    }","id":35484,"modified_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        // move to the field value\n\n        String queryString = null;\n        String defaultField = null;\n        MapperQueryParser.Operator defaultOperator = QueryParser.Operator.OR;\n        boolean allowLeadingWildcard = true;\n        boolean lowercaseExpandedTerms = true;\n        boolean enablePositionIncrements = true;\n        float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;\n        int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;\n        int phraseSlop = 0;\n        float boost = 1.0f;\n        boolean escape = false;\n        Analyzer analyzer = null;\n\n        String currentFieldName = null;\n        JsonToken token;\n        while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n            if (token == JsonToken.FIELD_NAME) {\n                currentFieldName = jp.getCurrentName();\n            } else if (token == JsonToken.VALUE_STRING) {\n                if (\"query\".equals(currentFieldName)) {\n                    queryString = jp.getText();\n                } else if (\"defaultField\".equals(currentFieldName)) {\n                    defaultField = parseContext.indexName(jp.getText());\n                } else if (\"defaultOperator\".equals(currentFieldName)) {\n                    String op = jp.getText();\n                    if (\"or\".equalsIgnoreCase(op)) {\n                        defaultOperator = QueryParser.Operator.OR;\n                    } else if (\"and\".equalsIgnoreCase(op)) {\n                        defaultOperator = QueryParser.Operator.AND;\n                    } else {\n                        throw new QueryParsingException(index, \"Query default operator [\" + op + \"] is not allowed\");\n                    }\n                } else if (\"analyzer\".equals(currentFieldName)) {\n                    analyzer = analysisService.analyzer(jp.getText());\n                }\n            } else if (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE) {\n                if (\"allowLeadingWildcard\".equals(currentFieldName)) {\n                    allowLeadingWildcard = token == JsonToken.VALUE_TRUE;\n                } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                    lowercaseExpandedTerms = token == JsonToken.VALUE_TRUE;\n                } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                    enablePositionIncrements = token == JsonToken.VALUE_TRUE;\n                } else if (\"escape\".equals(currentFieldName)) {\n                    escape = token == JsonToken.VALUE_TRUE;\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_FLOAT) {\n                if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                    fuzzyMinSim = jp.getFloatValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_INT) {\n                if (\"fuzzyPrefixLength\".equals(currentFieldName)) {\n                    fuzzyPrefixLength = jp.getIntValue();\n                } else if (\"phraseSlop\".equals(currentFieldName)) {\n                    phraseSlop = jp.getIntValue();\n                } else if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                    fuzzyMinSim = jp.getFloatValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"allowLeadingWildcard\".equals(currentFieldName)) {\n                    allowLeadingWildcard = jp.getIntValue() != 0;\n                } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                    lowercaseExpandedTerms = jp.getIntValue() != 0;\n                } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                    enablePositionIncrements = jp.getIntValue() != 0;\n                } else if (\"escape\".equals(currentFieldName)) {\n                    escape = jp.getIntValue() != 0;\n                }\n            }\n        }\n        if (queryString == null) {\n            throw new QueryParsingException(index, \"QueryString must be provided with a [query]\");\n        }\n        if (analyzer == null) {\n            analyzer = parseContext.mapperService().searchAnalyzer();\n        }\n\n        MapperQueryParser queryParser = new MapperQueryParser(defaultField, analyzer, parseContext.mapperService(), parseContext.filterCache());\n        queryParser.setEnablePositionIncrements(enablePositionIncrements);\n        queryParser.setLowercaseExpandedTerms(lowercaseExpandedTerms);\n        queryParser.setAllowLeadingWildcard(allowLeadingWildcard);\n        queryParser.setDefaultOperator(defaultOperator);\n        queryParser.setFuzzyMinSim(fuzzyMinSim);\n        queryParser.setFuzzyPrefixLength(fuzzyPrefixLength);\n        queryParser.setPhraseSlop(phraseSlop);\n\n        if (escape) {\n            queryString = QueryParser.escape(queryString);\n        }\n\n        try {\n            Query query = queryParser.parse(queryString);\n            query.setBoost(boost);\n            return optimizeQuery(fixNegativeQueryIfNeeded(query));\n        } catch (ParseException e) {\n            throw new QueryParsingException(index, \"Failed to parse query [\" + queryString + \"]\", e);\n        }\n    }","commit_id":"7709c68f6312703b60b40f9ded1bd6121daa1d58","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        float boost = 1.0f;\n        float tieBreakerMultiplier = 0.0f;\n\n        List<Query> queries = newArrayList();\n\n        String currentFieldName = null;\n        JsonToken token;\n        while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n            if (token == JsonToken.FIELD_NAME) {\n                currentFieldName = jp.getCurrentName();\n            } else if (token == JsonToken.START_OBJECT) {\n                if (\"queries\".equals(currentFieldName)) {\n                    queries.add(parseContext.parseInnerQuery());\n                }\n            } else if (token == JsonToken.START_ARRAY) {\n                if (\"queries\".equals(currentFieldName)) {\n                    while (token != JsonToken.END_ARRAY) {\n                        queries.add(parseContext.parseInnerQuery());\n                        token = jp.nextToken();\n                    }\n                }\n            } else {\n                if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"tieBreakerMultiplier\".equals(currentFieldName)) {\n                    tieBreakerMultiplier = jp.getFloatValue();\n                }\n            }\n        }\n\n        DisjunctionMaxQuery query = new DisjunctionMaxQuery(queries, tieBreakerMultiplier);\n        query.setBoost(boost);\n        return query;\n    }","id":35485,"modified_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        float boost = 1.0f;\n        float tieBreakerMultiplier = 0.0f;\n\n        List<Query> queries = newArrayList();\n\n        String currentFieldName = null;\n        JsonToken token;\n        while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n            if (token == JsonToken.FIELD_NAME) {\n                currentFieldName = jp.getCurrentName();\n            } else if (token == JsonToken.START_OBJECT) {\n                if (\"queries\".equals(currentFieldName)) {\n                    queries.add(parseContext.parseInnerQuery());\n                }\n            } else if (token == JsonToken.START_ARRAY) {\n                if (\"queries\".equals(currentFieldName)) {\n                    while (token != JsonToken.END_ARRAY) {\n                        queries.add(parseContext.parseInnerQuery());\n                        token = jp.nextToken();\n                    }\n                }\n            } else {\n                if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"tieBreakerMultiplier\".equals(currentFieldName)) {\n                    tieBreakerMultiplier = jp.getFloatValue();\n                } else if (\"tieBreaker\".equals(currentFieldName)) {\n                    tieBreakerMultiplier = jp.getFloatValue();\n                }\n            }\n        }\n\n        DisjunctionMaxQuery query = new DisjunctionMaxQuery(queries, tieBreakerMultiplier);\n        query.setBoost(boost);\n        return query;\n    }","commit_id":"fdd221e8ea303d569b0d6ac77bcb283dd4c1f294","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override protected Query getBooleanQuery(List<BooleanClause> clauses, boolean disableCoord) throws ParseException {\n        Query q = super.getBooleanQuery(clauses, disableCoord);\n        if (q == null) {\n            return null;\n        }\n        return fixNegativeQueryIfNeeded(q);\n    }","id":35486,"modified_method":"@Override protected Query getBooleanQuery(List<BooleanClause> clauses, boolean disableCoord) throws ParseException {\n        Query q = super.getBooleanQuery(clauses, disableCoord);\n        if (q == null) {\n            return null;\n        }\n        return optimizeQuery(fixNegativeQueryIfNeeded(q));\n    }","commit_id":"fdd221e8ea303d569b0d6ac77bcb283dd4c1f294","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override protected void doJson(JsonBuilder builder, Params params) throws IOException {\n        builder.startObject(QueryStringJsonQueryParser.NAME);\n        builder.field(\"query\", queryString);\n        if (defaultField != null) {\n            builder.field(\"defaultField\", defaultField);\n        }\n        if (defaultOperator != null) {\n            builder.field(\"defaultOperator\", defaultOperator.name().toLowerCase());\n        }\n        if (analyzer != null) {\n            builder.field(\"analyzer\", analyzer);\n        }\n        if (allowLeadingWildcard != null) {\n            builder.field(\"allowLeadingWildcard\", allowLeadingWildcard);\n        }\n        if (lowercaseExpandedTerms != null) {\n            builder.field(\"lowercaseExpandedTerms\", lowercaseExpandedTerms);\n        }\n        if (enablePositionIncrements != null) {\n            builder.field(\"enablePositionIncrements\", enablePositionIncrements);\n        }\n        if (fuzzyMinSim != -1) {\n            builder.field(\"fuzzyMinSim\", fuzzyMinSim);\n        }\n        if (boost != -1) {\n            builder.field(\"boost\", boost);\n        }\n        if (fuzzyPrefixLength != -1) {\n            builder.field(\"fuzzyPrefixLength\", fuzzyPrefixLength);\n        }\n        if (phraseSlop != -1) {\n            builder.field(\"phraseSlop\", phraseSlop);\n        }\n        builder.endObject();\n    }","id":35487,"modified_method":"@Override protected void doJson(JsonBuilder builder, Params params) throws IOException {\n        builder.startObject(QueryStringJsonQueryParser.NAME);\n        builder.field(\"query\", queryString);\n        if (defaultField != null) {\n            builder.field(\"defaultField\", defaultField);\n        }\n        if (fields != null) {\n            builder.startArray(\"fields\");\n            for (String field : fields) {\n                float boost = -1;\n                if (fieldsBoosts != null) {\n                    boost = fieldsBoosts.get(field);\n                }\n                if (boost != -1) {\n                    field += \"^\" + boost;\n                }\n                builder.string(field);\n            }\n            builder.endArray();\n        }\n        if (useDisMax != null) {\n            builder.field(\"useDisMax\", useDisMax);\n        }\n        if (tieBreaker != -1) {\n            builder.field(\"tieBreaker\", tieBreaker);\n        }\n        if (defaultOperator != null) {\n            builder.field(\"defaultOperator\", defaultOperator.name().toLowerCase());\n        }\n        if (analyzer != null) {\n            builder.field(\"analyzer\", analyzer);\n        }\n        if (allowLeadingWildcard != null) {\n            builder.field(\"allowLeadingWildcard\", allowLeadingWildcard);\n        }\n        if (lowercaseExpandedTerms != null) {\n            builder.field(\"lowercaseExpandedTerms\", lowercaseExpandedTerms);\n        }\n        if (enablePositionIncrements != null) {\n            builder.field(\"enablePositionIncrements\", enablePositionIncrements);\n        }\n        if (fuzzyMinSim != -1) {\n            builder.field(\"fuzzyMinSim\", fuzzyMinSim);\n        }\n        if (boost != -1) {\n            builder.field(\"boost\", boost);\n        }\n        if (fuzzyPrefixLength != -1) {\n            builder.field(\"fuzzyPrefixLength\", fuzzyPrefixLength);\n        }\n        if (phraseSlop != -1) {\n            builder.field(\"phraseSlop\", phraseSlop);\n        }\n        builder.endObject();\n    }","commit_id":"fdd221e8ea303d569b0d6ac77bcb283dd4c1f294","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        // move to the field value\n\n        String queryString = null;\n        String defaultField = null;\n        MapperQueryParser.Operator defaultOperator = QueryParser.Operator.OR;\n        boolean allowLeadingWildcard = true;\n        boolean lowercaseExpandedTerms = true;\n        boolean enablePositionIncrements = true;\n        float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;\n        int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;\n        int phraseSlop = 0;\n        float boost = 1.0f;\n        boolean escape = false;\n        Analyzer analyzer = null;\n\n        String currentFieldName = null;\n        JsonToken token;\n        while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n            if (token == JsonToken.FIELD_NAME) {\n                currentFieldName = jp.getCurrentName();\n            } else if (token == JsonToken.VALUE_STRING) {\n                if (\"query\".equals(currentFieldName)) {\n                    queryString = jp.getText();\n                } else if (\"defaultField\".equals(currentFieldName)) {\n                    defaultField = parseContext.indexName(jp.getText());\n                } else if (\"defaultOperator\".equals(currentFieldName)) {\n                    String op = jp.getText();\n                    if (\"or\".equalsIgnoreCase(op)) {\n                        defaultOperator = QueryParser.Operator.OR;\n                    } else if (\"and\".equalsIgnoreCase(op)) {\n                        defaultOperator = QueryParser.Operator.AND;\n                    } else {\n                        throw new QueryParsingException(index, \"Query default operator [\" + op + \"] is not allowed\");\n                    }\n                } else if (\"analyzer\".equals(currentFieldName)) {\n                    analyzer = analysisService.analyzer(jp.getText());\n                }\n            } else if (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE) {\n                if (\"allowLeadingWildcard\".equals(currentFieldName)) {\n                    allowLeadingWildcard = token == JsonToken.VALUE_TRUE;\n                } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                    lowercaseExpandedTerms = token == JsonToken.VALUE_TRUE;\n                } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                    enablePositionIncrements = token == JsonToken.VALUE_TRUE;\n                } else if (\"escape\".equals(currentFieldName)) {\n                    escape = token == JsonToken.VALUE_TRUE;\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_FLOAT) {\n                if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                    fuzzyMinSim = jp.getFloatValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_INT) {\n                if (\"fuzzyPrefixLength\".equals(currentFieldName)) {\n                    fuzzyPrefixLength = jp.getIntValue();\n                } else if (\"phraseSlop\".equals(currentFieldName)) {\n                    phraseSlop = jp.getIntValue();\n                } else if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                    fuzzyMinSim = jp.getFloatValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"allowLeadingWildcard\".equals(currentFieldName)) {\n                    allowLeadingWildcard = jp.getIntValue() != 0;\n                } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                    lowercaseExpandedTerms = jp.getIntValue() != 0;\n                } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                    enablePositionIncrements = jp.getIntValue() != 0;\n                } else if (\"escape\".equals(currentFieldName)) {\n                    escape = jp.getIntValue() != 0;\n                }\n            }\n        }\n        if (queryString == null) {\n            throw new QueryParsingException(index, \"QueryString must be provided with a [query]\");\n        }\n        if (analyzer == null) {\n            analyzer = parseContext.mapperService().searchAnalyzer();\n        }\n\n        MapperQueryParser queryParser = new MapperQueryParser(defaultField, analyzer, parseContext.mapperService(), parseContext.filterCache());\n        queryParser.setEnablePositionIncrements(enablePositionIncrements);\n        queryParser.setLowercaseExpandedTerms(lowercaseExpandedTerms);\n        queryParser.setAllowLeadingWildcard(allowLeadingWildcard);\n        queryParser.setDefaultOperator(defaultOperator);\n        queryParser.setFuzzyMinSim(fuzzyMinSim);\n        queryParser.setFuzzyPrefixLength(fuzzyPrefixLength);\n        queryParser.setPhraseSlop(phraseSlop);\n\n        if (escape) {\n            queryString = QueryParser.escape(queryString);\n        }\n\n        try {\n            Query query = queryParser.parse(queryString);\n            query.setBoost(boost);\n            return optimizeQuery(fixNegativeQueryIfNeeded(query));\n        } catch (ParseException e) {\n            throw new QueryParsingException(index, \"Failed to parse query [\" + queryString + \"]\", e);\n        }\n    }","id":35488,"modified_method":"@Override public Query parse(JsonQueryParseContext parseContext) throws IOException, QueryParsingException {\n        JsonParser jp = parseContext.jp();\n\n        // move to the field value\n\n        String queryString = null;\n        String defaultField = null;\n        MapperQueryParser.Operator defaultOperator = QueryParser.Operator.OR;\n        boolean allowLeadingWildcard = true;\n        boolean lowercaseExpandedTerms = true;\n        boolean enablePositionIncrements = true;\n        float fuzzyMinSim = FuzzyQuery.defaultMinSimilarity;\n        int fuzzyPrefixLength = FuzzyQuery.defaultPrefixLength;\n        int phraseSlop = 0;\n        float boost = 1.0f;\n        boolean escape = false;\n        Analyzer analyzer = null;\n        List<String> fields = null;\n        ExtTObjectFloatHashMap<String> boosts = null;\n        float tieBreaker = 0.0f;\n        boolean useDisMax = true;\n\n        String currentFieldName = null;\n        JsonToken token;\n        while ((token = jp.nextToken()) != JsonToken.END_OBJECT) {\n            if (token == JsonToken.FIELD_NAME) {\n                currentFieldName = jp.getCurrentName();\n            } else if (token == JsonToken.START_ARRAY) {\n                if (\"fields\".equals(currentFieldName)) {\n                    while ((token = jp.nextToken()) != JsonToken.END_ARRAY) {\n                        String fField = null;\n                        float fBoost = -1;\n                        char[] text = jp.getTextCharacters();\n                        int end = jp.getTextOffset() + jp.getTextLength();\n                        for (int i = jp.getTextOffset(); i < end; i++) {\n                            if (text[i] == '^') {\n                                int relativeLocation = i - jp.getTextOffset();\n                                fField = new String(text, jp.getTextOffset(), relativeLocation);\n                                fBoost = Float.parseFloat(new String(text, i + 1, jp.getTextLength() - relativeLocation - 1));\n                                break;\n                            }\n                        }\n                        if (fField == null) {\n                            fField = jp.getText();\n                        }\n                        if (fields == null) {\n                            fields = Lists.newArrayList();\n                        }\n                        fields.add(fField);\n                        if (fBoost != -1) {\n                            if (boosts == null) {\n                                boosts = new ExtTObjectFloatHashMap<String>();\n                            }\n                            boosts.put(fField, fBoost);\n                        }\n                    }\n                }\n            } else if (token == JsonToken.VALUE_STRING) {\n                if (\"query\".equals(currentFieldName)) {\n                    queryString = jp.getText();\n                } else if (\"defaultField\".equals(currentFieldName)) {\n                    defaultField = parseContext.indexName(jp.getText());\n                } else if (\"defaultOperator\".equals(currentFieldName)) {\n                    String op = jp.getText();\n                    if (\"or\".equalsIgnoreCase(op)) {\n                        defaultOperator = QueryParser.Operator.OR;\n                    } else if (\"and\".equalsIgnoreCase(op)) {\n                        defaultOperator = QueryParser.Operator.AND;\n                    } else {\n                        throw new QueryParsingException(index, \"Query default operator [\" + op + \"] is not allowed\");\n                    }\n                } else if (\"analyzer\".equals(currentFieldName)) {\n                    analyzer = analysisService.analyzer(jp.getText());\n                }\n            } else if (token == JsonToken.VALUE_FALSE || token == JsonToken.VALUE_TRUE) {\n                if (\"allowLeadingWildcard\".equals(currentFieldName)) {\n                    allowLeadingWildcard = token == JsonToken.VALUE_TRUE;\n                } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                    lowercaseExpandedTerms = token == JsonToken.VALUE_TRUE;\n                } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                    enablePositionIncrements = token == JsonToken.VALUE_TRUE;\n                } else if (\"escape\".equals(currentFieldName)) {\n                    escape = token == JsonToken.VALUE_TRUE;\n                } else if (\"useDisMax\".equals(currentFieldName)) {\n                    useDisMax = token == JsonToken.VALUE_TRUE;\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_FLOAT) {\n                if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                    fuzzyMinSim = jp.getFloatValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"tieBreaker\".equals(currentFieldName)) {\n                    tieBreaker = jp.getFloatValue();\n                }\n            } else if (token == JsonToken.VALUE_NUMBER_INT) {\n                if (\"fuzzyPrefixLength\".equals(currentFieldName)) {\n                    fuzzyPrefixLength = jp.getIntValue();\n                } else if (\"phraseSlop\".equals(currentFieldName)) {\n                    phraseSlop = jp.getIntValue();\n                } else if (\"fuzzyMinSim\".equals(currentFieldName)) {\n                    fuzzyMinSim = jp.getFloatValue();\n                } else if (\"boost\".equals(currentFieldName)) {\n                    boost = jp.getFloatValue();\n                } else if (\"allowLeadingWildcard\".equals(currentFieldName)) {\n                    allowLeadingWildcard = jp.getIntValue() != 0;\n                } else if (\"lowercaseExpandedTerms\".equals(currentFieldName)) {\n                    lowercaseExpandedTerms = jp.getIntValue() != 0;\n                } else if (\"enablePositionIncrements\".equals(currentFieldName)) {\n                    enablePositionIncrements = jp.getIntValue() != 0;\n                } else if (\"escape\".equals(currentFieldName)) {\n                    escape = jp.getIntValue() != 0;\n                } else if (\"useDisMax\".equals(currentFieldName)) {\n                    escape = jp.getIntValue() != 0;\n                } else if (\"tieBreaker\".equals(currentFieldName)) {\n                    tieBreaker = jp.getFloatValue();\n                }\n            }\n        }\n        if (queryString == null) {\n            throw new QueryParsingException(index, \"QueryString must be provided with a [query]\");\n        }\n        if (analyzer == null) {\n            analyzer = parseContext.mapperService().searchAnalyzer();\n        }\n\n        MapperQueryParser queryParser;\n        if (fields != null) {\n            if (fields.size() == 1) {\n                queryParser = new MapperQueryParser(fields.get(0), analyzer, parseContext.mapperService(), parseContext.filterCache());\n            } else {\n                MultiFieldMapperQueryParser mQueryParser = new MultiFieldMapperQueryParser(fields, boosts, analyzer, parseContext.mapperService(), parseContext.filterCache());\n                mQueryParser.setTieBreaker(tieBreaker);\n                mQueryParser.setUseDisMax(useDisMax);\n                queryParser = mQueryParser;\n            }\n        } else {\n            queryParser = new MapperQueryParser(defaultField, analyzer, parseContext.mapperService(), parseContext.filterCache());\n        }\n        queryParser.setEnablePositionIncrements(enablePositionIncrements);\n        queryParser.setLowercaseExpandedTerms(lowercaseExpandedTerms);\n        queryParser.setAllowLeadingWildcard(allowLeadingWildcard);\n        queryParser.setDefaultOperator(defaultOperator);\n        queryParser.setFuzzyMinSim(fuzzyMinSim);\n        queryParser.setFuzzyPrefixLength(fuzzyPrefixLength);\n        queryParser.setPhraseSlop(phraseSlop);\n\n        if (escape) {\n            queryString = QueryParser.escape(queryString);\n        }\n\n        try {\n            Query query = queryParser.parse(queryString);\n            query.setBoost(boost);\n            return optimizeQuery(fixNegativeQueryIfNeeded(query));\n        } catch (ParseException e) {\n            throw new QueryParsingException(index, \"Failed to parse query [\" + queryString + \"]\", e);\n        }\n    }","commit_id":"fdd221e8ea303d569b0d6ac77bcb283dd4c1f294","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test public void testDisMax() throws Exception {\n        IndexQueryParser queryParser = newQueryParser();\n        String query = copyToStringFromClasspath(\"/org/elasticsearch/index/query/json/disMax.json\");\n        Query parsedQuery = queryParser.parse(query);\n        assertThat(parsedQuery, instanceOf(DisjunctionMaxQuery.class));\n        DisjunctionMaxQuery disjunctionMaxQuery = (DisjunctionMaxQuery) parsedQuery;\n        assertThat((double) disjunctionMaxQuery.getBoost(), closeTo(1.2, 0.01));\n\n        Field field = disjunctionMaxQuery.getClass().getDeclaredField(\"disjuncts\");\n        field.setAccessible(true);\n        List<Query> disjuncts = (List<Query>) field.get(disjunctionMaxQuery);\n        assertThat(disjuncts.size(), equalTo(2));\n\n        Query firstQ = disjuncts.get(0);\n        assertThat(firstQ, instanceOf(TermQuery.class));\n        assertThat(((TermQuery) firstQ).getTerm(), equalTo(new Term(\"age\", NumericUtils.longToPrefixCoded(34))));\n\n        Query secondsQ = disjuncts.get(1);\n        assertThat(secondsQ, instanceOf(TermQuery.class));\n        assertThat(((TermQuery) secondsQ).getTerm(), equalTo(new Term(\"age\", NumericUtils.longToPrefixCoded(35))));\n    }","id":35489,"modified_method":"@Test public void testDisMax() throws Exception {\n        IndexQueryParser queryParser = newQueryParser();\n        String query = copyToStringFromClasspath(\"/org/elasticsearch/index/query/json/disMax.json\");\n        Query parsedQuery = queryParser.parse(query);\n        assertThat(parsedQuery, instanceOf(DisjunctionMaxQuery.class));\n        DisjunctionMaxQuery disjunctionMaxQuery = (DisjunctionMaxQuery) parsedQuery;\n        assertThat((double) disjunctionMaxQuery.getBoost(), closeTo(1.2, 0.01));\n\n        List<Query> disjuncts = Queries.disMaxClauses(disjunctionMaxQuery);\n        assertThat(disjuncts.size(), equalTo(2));\n\n        Query firstQ = disjuncts.get(0);\n        assertThat(firstQ, instanceOf(TermQuery.class));\n        assertThat(((TermQuery) firstQ).getTerm(), equalTo(new Term(\"age\", NumericUtils.longToPrefixCoded(34))));\n\n        Query secondsQ = disjuncts.get(1);\n        assertThat(secondsQ, instanceOf(TermQuery.class));\n        assertThat(((TermQuery) secondsQ).getTerm(), equalTo(new Term(\"age\", NumericUtils.longToPrefixCoded(35))));\n    }","commit_id":"fdd221e8ea303d569b0d6ac77bcb283dd4c1f294","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test public void testDisMaxBuilder() throws Exception {\n        IndexQueryParser queryParser = newQueryParser();\n        Query parsedQuery = queryParser.parse(disMaxQuery().boost(1.2f).tieBreakerMultiplier(0.7f).add(termQuery(\"age\", 34)).add(termQuery(\"age\", 35)));\n        assertThat(parsedQuery, instanceOf(DisjunctionMaxQuery.class));\n        DisjunctionMaxQuery disjunctionMaxQuery = (DisjunctionMaxQuery) parsedQuery;\n        assertThat((double) disjunctionMaxQuery.getBoost(), closeTo(1.2, 0.01));\n\n        Field field = disjunctionMaxQuery.getClass().getDeclaredField(\"disjuncts\");\n        field.setAccessible(true);\n        List<Query> disjuncts = (List<Query>) field.get(disjunctionMaxQuery);\n        assertThat(disjuncts.size(), equalTo(2));\n\n        Query firstQ = disjuncts.get(0);\n        assertThat(firstQ, instanceOf(TermQuery.class));\n        assertThat(((TermQuery) firstQ).getTerm(), equalTo(new Term(\"age\", NumericUtils.longToPrefixCoded(34))));\n\n        Query secondsQ = disjuncts.get(1);\n        assertThat(secondsQ, instanceOf(TermQuery.class));\n        assertThat(((TermQuery) secondsQ).getTerm(), equalTo(new Term(\"age\", NumericUtils.longToPrefixCoded(35))));\n    }","id":35490,"modified_method":"@Test public void testDisMaxBuilder() throws Exception {\n        IndexQueryParser queryParser = newQueryParser();\n        Query parsedQuery = queryParser.parse(disMaxQuery().boost(1.2f).tieBreakerMultiplier(0.7f).add(termQuery(\"age\", 34)).add(termQuery(\"age\", 35)));\n        assertThat(parsedQuery, instanceOf(DisjunctionMaxQuery.class));\n        DisjunctionMaxQuery disjunctionMaxQuery = (DisjunctionMaxQuery) parsedQuery;\n        assertThat((double) disjunctionMaxQuery.getBoost(), closeTo(1.2, 0.01));\n\n        List<Query> disjuncts = Queries.disMaxClauses(disjunctionMaxQuery);\n        assertThat(disjuncts.size(), equalTo(2));\n\n        Query firstQ = disjuncts.get(0);\n        assertThat(firstQ, instanceOf(TermQuery.class));\n        assertThat(((TermQuery) firstQ).getTerm(), equalTo(new Term(\"age\", NumericUtils.longToPrefixCoded(34))));\n\n        Query secondsQ = disjuncts.get(1);\n        assertThat(secondsQ, instanceOf(TermQuery.class));\n        assertThat(((TermQuery) secondsQ).getTerm(), equalTo(new Term(\"age\", NumericUtils.longToPrefixCoded(35))));\n    }","commit_id":"fdd221e8ea303d569b0d6ac77bcb283dd4c1f294","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public TypeConversionDescriptorBase findConversion(final PsiType from, final PsiType to, final PsiMember member, final PsiExpression context,\n                                                 final TypeMigrationLabeler labeler) {\n    if (to instanceof PsiClassType && from instanceof PsiPrimitiveType) {\n      if (!PsiUtil.getLanguageLevel(context).hasEnumKeywordAndAutoboxing()) {\n        final String boxedTypeName = ((PsiPrimitiveType)from).getBoxedTypeName();\n        if (Comparing.strEqual(boxedTypeName, to.getCanonicalText())) {\n          return new TypeConversionDescriptor(\"$qualifier$\", boxedTypeName + \".valueOf($qualifier$)\");\n        }\n      }\n    }\n    else if (from instanceof PsiClassType && to instanceof PsiPrimitiveType) {\n      if (!PsiUtil.getLanguageLevel(context).hasEnumKeywordAndAutoboxing()) {\n        final String boxedTypeName = ((PsiPrimitiveType)to).getBoxedTypeName();\n        if (Comparing.strEqual(boxedTypeName, from.getCanonicalText())) {\n          return new TypeConversionDescriptor(\"$qualifier$\", \"($qualifier$).\" + to.getCanonicalText() + \"Value()\");\n        }\n      }\n    }\n    return null;\n  }","id":35491,"modified_method":"public TypeConversionDescriptorBase findConversion(final PsiType from, final PsiType to, final PsiMember member, final PsiExpression context,\n                                                 final TypeMigrationLabeler labeler) {\n    if (to instanceof PsiClassType && from instanceof PsiPrimitiveType) {\n      if (!PsiUtil.isLanguageLevel5OrHigher(context)) {\n        final String boxedTypeName = ((PsiPrimitiveType)from).getBoxedTypeName();\n        if (Comparing.strEqual(boxedTypeName, to.getCanonicalText())) {\n          return new TypeConversionDescriptor(\"$qualifier$\", boxedTypeName + \".valueOf($qualifier$)\");\n        }\n      }\n    }\n    else if (from instanceof PsiClassType && to instanceof PsiPrimitiveType) {\n      if (!PsiUtil.isLanguageLevel5OrHigher(context)) {\n        final String boxedTypeName = ((PsiPrimitiveType)to).getBoxedTypeName();\n        if (Comparing.strEqual(boxedTypeName, from.getCanonicalText())) {\n          return new TypeConversionDescriptor(\"$qualifier$\", \"($qualifier$).\" + to.getCanonicalText() + \"Value()\");\n        }\n      }\n    }\n    return null;\n  }","commit_id":"58d6002bb8bb68ce173f2d25fa09f4033e16e40c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TypeConversionDescriptorBase findConversion(final PsiType from, final PsiType to, final PsiMember member, final PsiExpression context,\n                                                 final TypeMigrationLabeler labeler) {\n    if (member == null && to instanceof PsiArrayType && TypeConversionUtil.isAssignable(((PsiArrayType)to).getComponentType(), from)) {\n      TypeConversionDescriptor wrapDescription =\n        new TypeConversionDescriptor(\"$qualifier$\", \"new \" + from.getCanonicalText() + \"[]{$qualifier$}\", context);\n      if (((PsiArrayType)to).getComponentType() instanceof PsiClassType && from instanceof PsiPrimitiveType) {\n        final String boxedTypeName = ((PsiPrimitiveType)from).getBoxedTypeName();\n        final String normalizedArrayInitializer =\n          PsiUtil.getLanguageLevel(context).hasEnumKeywordAndAutoboxing() ? \"$qualifier$\" : boxedTypeName + \".valueOf($qualifier$)\";\n        wrapDescription = new TypeConversionDescriptor(\"$qualifier$\", \"new \" + boxedTypeName + \"[]{\" + normalizedArrayInitializer + \"}\", context);\n      }\n      final PsiElement parent = context.getParent();\n      if ((context instanceof PsiLiteralExpression || context instanceof PsiReferenceExpression) && parent instanceof PsiStatement) {\n        return wrapDescription;\n      }\n      if (parent instanceof PsiAssignmentExpression && ((PsiAssignmentExpression)parent).getRExpression() == context) {\n        return wrapDescription;\n      }\n    }\n    return null;\n  }","id":35492,"modified_method":"public TypeConversionDescriptorBase findConversion(final PsiType from, final PsiType to, final PsiMember member, final PsiExpression context,\n                                                 final TypeMigrationLabeler labeler) {\n    if (member == null && to instanceof PsiArrayType && TypeConversionUtil.isAssignable(((PsiArrayType)to).getComponentType(), from)) {\n      TypeConversionDescriptor wrapDescription =\n        new TypeConversionDescriptor(\"$qualifier$\", \"new \" + from.getCanonicalText() + \"[]{$qualifier$}\", context);\n      if (((PsiArrayType)to).getComponentType() instanceof PsiClassType && from instanceof PsiPrimitiveType) {\n        final String boxedTypeName = ((PsiPrimitiveType)from).getBoxedTypeName();\n        final String normalizedArrayInitializer =\n          PsiUtil.isLanguageLevel5OrHigher(context) ? \"$qualifier$\" : boxedTypeName + \".valueOf($qualifier$)\";\n        wrapDescription = new TypeConversionDescriptor(\"$qualifier$\", \"new \" + boxedTypeName + \"[]{\" + normalizedArrayInitializer + \"}\", context);\n      }\n      final PsiElement parent = context.getParent();\n      if ((context instanceof PsiLiteralExpression || context instanceof PsiReferenceExpression) && parent instanceof PsiStatement) {\n        return wrapDescription;\n      }\n      if (parent instanceof PsiAssignmentExpression && ((PsiAssignmentExpression)parent).getRExpression() == context) {\n        return wrapDescription;\n      }\n    }\n    return null;\n  }","commit_id":"58d6002bb8bb68ce173f2d25fa09f4033e16e40c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main( String[] args )\n    {\n        new EmbeddedGraphDatabase( args[0] ).shutdown();\n    }","id":35493,"modified_method":"public static void main( String[] args )\n    {\n        at( args[0] );\n    }","commit_id":"a86c36c1b8c916ef4882a127eb42d936913803a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InstanceInfo[] getInstancesInCluster()\n        {\n            ConnectionInformation[] connections = db.getBroker().getConnectionInformation();\n            InstanceInfo[] result = new InstanceInfo[connections.length];\n            for ( int i = 0; i < result.length; i++ )\n            {\n                ConnectionInformation connection = connections[i];\n                result[i] = new InstanceInfo( connection.getJMXServiceURL(),\n                        connection.getInstanceId(), connection.getMachineId(),\n                        connection.isMaster(), connection.getLastCommitedTransactionId() );\n            }\n            return result;\n        }","id":35494,"modified_method":"public InstanceInfo[] getInstancesInCluster()\n        {\n            ConnectionInformation[] connections = db.getBroker().getConnectionInformation();\n            InstanceInfo[] result = new InstanceInfo[connections.length];\n            for ( int i = 0; i < result.length; i++ )\n            {\n                ConnectionInformation connection = connections[i];\n                result[i] = new InstanceInfo( connection.getJMXServiceURL().toString(),\n                        connection.getInstanceId(), connection.getMachineId(),\n                        connection.isMaster(), connection.getLastCommitedTransactionId() );\n            }\n            return result;\n        }","commit_id":"a86c36c1b8c916ef4882a127eb42d936913803a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"private SlaveInfo slaveInfo( int machineId, Collection<SlaveContext> contexts )\n        {\n            List<SlaveTransaction> txInfo = new ArrayList<SlaveTransaction>();\n            for ( SlaveContext context : contexts )\n            {\n                Map<String, Long> lastTransactions = new HashMap<String, Long>();\n                for ( Pair<String, Long> tx : context.lastAppliedTransactions() )\n                {\n                    lastTransactions.put( tx.first(), tx.other() );\n                }\n                txInfo.add( new SlaveTransaction( context.getEventIdentifier(), lastTransactions ) );\n            }\n            ConnectionInformation connection = db.getBroker().getConnectionInformation( machineId );\n            return new SlaveInfo( connection.getJMXServiceURL(), connection.getInstanceId(),\n                    machineId, false, connection.getLastCommitedTransactionId(),\n                    txInfo.toArray( new SlaveTransaction[txInfo.size()] ) );\n        }","id":35495,"modified_method":"private SlaveInfo slaveInfo( int machineId, Collection<SlaveContext> contexts )\n        {\n            List<SlaveTransaction> txInfo = new ArrayList<SlaveTransaction>();\n            for ( SlaveContext context : contexts )\n            {\n                Map<String, Long> lastTransactions = new HashMap<String, Long>();\n                for ( Pair<String, Long> tx : context.lastAppliedTransactions() )\n                {\n                    lastTransactions.put( tx.first(), tx.other() );\n                }\n                txInfo.add( new SlaveTransaction( context.getEventIdentifier(), lastTransactions ) );\n            }\n            ConnectionInformation connection = db.getBroker().getConnectionInformation( machineId );\n            return new SlaveInfo( connection.getJMXServiceURL().toString(),\n                    connection.getInstanceId(), machineId, false,\n                    connection.getLastCommitedTransactionId(),\n                    txInfo.toArray( new SlaveTransaction[txInfo.size()] ) );\n        }","commit_id":"a86c36c1b8c916ef4882a127eb42d936913803a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void setJmxConnectionData( JMXServiceURL jmxUrl, String instanceId )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"/jmx\";\n        String url = jmxUrl.toString();\n        byte[] data = new byte[( url.length() + instanceId.length() ) * 2 + 4];\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        // write URL\n        buffer.putShort( (short) url.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        // write instanceId\n        buffer.putShort( (short) instanceId.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        // truncate array\n        if ( buffer.limit() != data.length )\n        {\n            byte[] array = new byte[buffer.limit()];\n            System.arraycopy( data, 0, array, 0, array.length );\n            data = array;\n        }\n        try\n        {\n            zooKeeper.setData( path, data, -1 );\n        }\n        catch ( KeeperException e )\n        {\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n    }","id":35496,"modified_method":"public synchronized void setJmxConnectionData( JMXServiceURL jmxUrl, String instanceId )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"-jmx\";\n        String url = jmxUrl.toString();\n        byte[] data = new byte[( url.length() + instanceId.length() ) * 2 + 4];\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        // write URL\n        buffer.putShort( (short) url.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        buffer.position( buffer.position() + url.length() * 2 );\n        // write instanceId\n        buffer.putShort( (short) instanceId.length() );\n        buffer.asCharBuffer().put( instanceId.toCharArray() );\n        // truncate array\n        if ( buffer.limit() != data.length )\n        {\n            byte[] array = new byte[buffer.limit()];\n            System.arraycopy( data, 0, array, 0, array.length );\n            data = array;\n        }\n        try\n        {\n            try\n            {\n                zooKeeper.setData( path, data, -1 );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() == KeeperException.Code.NONODE )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL );\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unable to set jxm connection info\", e );\n                }\n            }\n        }\n        catch ( KeeperException e )\n        {\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n    }","commit_id":"a86c36c1b8c916ef4882a127eb42d936913803a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void getJmxConnectionData( ConnectionInformation connection )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"/jmx\";\n        byte[] data;\n        try\n        {\n            data = zooKeeper.getData( path, false, null );\n        }\n        catch ( KeeperException e )\n        {\n            return;\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            return;\n        }\n        if ( data == null || data.length == 0 ) return;\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        char[] url, instanceId;\n        try\n        {\n            // read URL\n            url = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( url );\n            // read instanceId\n            instanceId = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( instanceId );\n        }\n        catch ( BufferUnderflowException e )\n        {\n            return;\n        }\n        connection.setJMXConnectionData( new String( url ), new String( instanceId ) );\n    }","id":35497,"modified_method":"public void getJmxConnectionData( ConnectionInformation connection )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"-jmx\";\n        byte[] data;\n        try\n        {\n            data = zooKeeper.getData( path, false, null );\n        }\n        catch ( KeeperException e )\n        {\n            return;\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            return;\n        }\n        if ( data == null || data.length == 0 ) return;\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        char[] url, instanceId;\n        try\n        {\n            // read URL\n            url = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( url );\n            buffer.position( buffer.position() + url.length * 2 );\n            // read instanceId\n            instanceId = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( instanceId );\n        }\n        catch ( BufferUnderflowException e )\n        {\n            return;\n        }\n        connection.setJMXConnectionData( new String( url ), new String( instanceId ) );\n    }","commit_id":"a86c36c1b8c916ef4882a127eb42d936913803a0","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] args )\n    {\n        new EmbeddedGraphDatabase( args[0] ).shutdown();\n    }","id":35498,"modified_method":"public static void main( String[] args )\n    {\n        at( args[0] );\n    }","commit_id":"41e1b13e28b03020e47ed71b3a865b07e9479e8b","url":"https://github.com/neo4j/neo4j"},{"original_method":"private SlaveInfo slaveInfo( int machineId, Collection<SlaveContext> contexts )\n        {\n            List<SlaveTransaction> txInfo = new ArrayList<SlaveTransaction>();\n            for ( SlaveContext context : contexts )\n            {\n                Map<String, Long> lastTransactions = new HashMap<String, Long>();\n                for ( Pair<String, Long> tx : context.lastAppliedTransactions() )\n                {\n                    lastTransactions.put( tx.first(), tx.other() );\n                }\n                txInfo.add( new SlaveTransaction( context.getEventIdentifier(), lastTransactions ) );\n            }\n            ConnectionInformation connection = db.getBroker().getConnectionInformation( machineId );\n            return new SlaveInfo( connection.getJMXServiceURL(), connection.getInstanceId(),\n                    machineId, false, connection.getLastCommitedTransactionId(),\n                    txInfo.toArray( new SlaveTransaction[txInfo.size()] ) );\n        }","id":35499,"modified_method":"private SlaveInfo slaveInfo( int machineId, Collection<SlaveContext> contexts )\n        {\n            List<SlaveTransaction> txInfo = new ArrayList<SlaveTransaction>();\n            for ( SlaveContext context : contexts )\n            {\n                Map<String, Long> lastTransactions = new HashMap<String, Long>();\n                for ( Pair<String, Long> tx : context.lastAppliedTransactions() )\n                {\n                    lastTransactions.put( tx.first(), tx.other() );\n                }\n                txInfo.add( new SlaveTransaction( context.getEventIdentifier(), lastTransactions ) );\n            }\n            ConnectionInformation connection = db.getBroker().getConnectionInformation( machineId );\n            return new SlaveInfo( connection.getJMXServiceURL().toString(),\n                    connection.getInstanceId(), machineId, false,\n                    connection.getLastCommitedTransactionId(),\n                    txInfo.toArray( new SlaveTransaction[txInfo.size()] ) );\n        }","commit_id":"41e1b13e28b03020e47ed71b3a865b07e9479e8b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InstanceInfo[] getInstancesInCluster()\n        {\n            ConnectionInformation[] connections = db.getBroker().getConnectionInformation();\n            InstanceInfo[] result = new InstanceInfo[connections.length];\n            for ( int i = 0; i < result.length; i++ )\n            {\n                ConnectionInformation connection = connections[i];\n                result[i] = new InstanceInfo( connection.getJMXServiceURL(),\n                        connection.getInstanceId(), connection.getMachineId(),\n                        connection.isMaster(), connection.getLastCommitedTransactionId() );\n            }\n            return result;\n        }","id":35500,"modified_method":"public InstanceInfo[] getInstancesInCluster()\n        {\n            ConnectionInformation[] connections = db.getBroker().getConnectionInformation();\n            InstanceInfo[] result = new InstanceInfo[connections.length];\n            for ( int i = 0; i < result.length; i++ )\n            {\n                ConnectionInformation connection = connections[i];\n                result[i] = new InstanceInfo( connection.getJMXServiceURL().toString(),\n                        connection.getInstanceId(), connection.getMachineId(),\n                        connection.isMaster(), connection.getLastCommitedTransactionId() );\n            }\n            return result;\n        }","commit_id":"41e1b13e28b03020e47ed71b3a865b07e9479e8b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void setJmxConnectionData( JMXServiceURL jmxUrl, String instanceId )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"/jmx\";\n        String url = jmxUrl.toString();\n        byte[] data = new byte[( url.length() + instanceId.length() ) * 2 + 4];\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        // write URL\n        buffer.putShort( (short) url.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        // write instanceId\n        buffer.putShort( (short) instanceId.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        // truncate array\n        if ( buffer.limit() != data.length )\n        {\n            byte[] array = new byte[buffer.limit()];\n            System.arraycopy( data, 0, array, 0, array.length );\n            data = array;\n        }\n        try\n        {\n            zooKeeper.setData( path, data, -1 );\n        }\n        catch ( KeeperException e )\n        {\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n    }","id":35501,"modified_method":"public synchronized void setJmxConnectionData( JMXServiceURL jmxUrl, String instanceId )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"-jmx\";\n        String url = jmxUrl.toString();\n        byte[] data = new byte[( url.length() + instanceId.length() ) * 2 + 4];\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        // write URL\n        buffer.putShort( (short) url.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        buffer.position( buffer.position() + url.length() * 2 );\n        // write instanceId\n        buffer.putShort( (short) instanceId.length() );\n        buffer.asCharBuffer().put( instanceId.toCharArray() );\n        // truncate array\n        if ( buffer.limit() != data.length )\n        {\n            byte[] array = new byte[buffer.limit()];\n            System.arraycopy( data, 0, array, 0, array.length );\n            data = array;\n        }\n        try\n        {\n            try\n            {\n                zooKeeper.setData( path, data, -1 );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() == KeeperException.Code.NONODE )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL );\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unable to set jxm connection info\", e );\n                }\n            }\n        }\n        catch ( KeeperException e )\n        {\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n    }","commit_id":"41e1b13e28b03020e47ed71b3a865b07e9479e8b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void getJmxConnectionData( ConnectionInformation connection )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"/jmx\";\n        byte[] data;\n        try\n        {\n            data = zooKeeper.getData( path, false, null );\n        }\n        catch ( KeeperException e )\n        {\n            return;\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            return;\n        }\n        if ( data == null || data.length == 0 ) return;\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        char[] url, instanceId;\n        try\n        {\n            // read URL\n            url = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( url );\n            // read instanceId\n            instanceId = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( instanceId );\n        }\n        catch ( BufferUnderflowException e )\n        {\n            return;\n        }\n        connection.setJMXConnectionData( new String( url ), new String( instanceId ) );\n    }","id":35502,"modified_method":"public void getJmxConnectionData( ConnectionInformation connection )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"-jmx\";\n        byte[] data;\n        try\n        {\n            data = zooKeeper.getData( path, false, null );\n        }\n        catch ( KeeperException e )\n        {\n            return;\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            return;\n        }\n        if ( data == null || data.length == 0 ) return;\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        char[] url, instanceId;\n        try\n        {\n            // read URL\n            url = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( url );\n            buffer.position( buffer.position() + url.length * 2 );\n            // read instanceId\n            instanceId = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( instanceId );\n        }\n        catch ( BufferUnderflowException e )\n        {\n            return;\n        }\n        connection.setJMXConnectionData( new String( url ), new String( instanceId ) );\n    }","commit_id":"41e1b13e28b03020e47ed71b3a865b07e9479e8b","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void main( String[] args )\n    {\n        new EmbeddedGraphDatabase( args[0] ).shutdown();\n    }","id":35503,"modified_method":"public static void main( String[] args )\n    {\n        at( args[0] );\n    }","commit_id":"c784907540bcde41aa641e6a06174a6be6dfd830","url":"https://github.com/neo4j/neo4j"},{"original_method":"private SlaveInfo slaveInfo( int machineId, Collection<SlaveContext> contexts )\n        {\n            List<SlaveTransaction> txInfo = new ArrayList<SlaveTransaction>();\n            for ( SlaveContext context : contexts )\n            {\n                Map<String, Long> lastTransactions = new HashMap<String, Long>();\n                for ( Pair<String, Long> tx : context.lastAppliedTransactions() )\n                {\n                    lastTransactions.put( tx.first(), tx.other() );\n                }\n                txInfo.add( new SlaveTransaction( context.getEventIdentifier(), lastTransactions ) );\n            }\n            ConnectionInformation connection = db.getBroker().getConnectionInformation( machineId );\n            return new SlaveInfo( connection.getJMXServiceURL(), connection.getInstanceId(),\n                    machineId, false, connection.getLastCommitedTransactionId(),\n                    txInfo.toArray( new SlaveTransaction[txInfo.size()] ) );\n        }","id":35504,"modified_method":"private SlaveInfo slaveInfo( int machineId, Collection<SlaveContext> contexts )\n        {\n            List<SlaveTransaction> txInfo = new ArrayList<SlaveTransaction>();\n            for ( SlaveContext context : contexts )\n            {\n                Map<String, Long> lastTransactions = new HashMap<String, Long>();\n                for ( Pair<String, Long> tx : context.lastAppliedTransactions() )\n                {\n                    lastTransactions.put( tx.first(), tx.other() );\n                }\n                txInfo.add( new SlaveTransaction( context.getEventIdentifier(), lastTransactions ) );\n            }\n            ConnectionInformation connection = db.getBroker().getConnectionInformation( machineId );\n            return new SlaveInfo( connection.getJMXServiceURL().toString(),\n                    connection.getInstanceId(), machineId, false,\n                    connection.getLastCommitedTransactionId(),\n                    txInfo.toArray( new SlaveTransaction[txInfo.size()] ) );\n        }","commit_id":"c784907540bcde41aa641e6a06174a6be6dfd830","url":"https://github.com/neo4j/neo4j"},{"original_method":"public InstanceInfo[] getInstancesInCluster()\n        {\n            ConnectionInformation[] connections = db.getBroker().getConnectionInformation();\n            InstanceInfo[] result = new InstanceInfo[connections.length];\n            for ( int i = 0; i < result.length; i++ )\n            {\n                ConnectionInformation connection = connections[i];\n                result[i] = new InstanceInfo( connection.getJMXServiceURL(),\n                        connection.getInstanceId(), connection.getMachineId(),\n                        connection.isMaster(), connection.getLastCommitedTransactionId() );\n            }\n            return result;\n        }","id":35505,"modified_method":"public InstanceInfo[] getInstancesInCluster()\n        {\n            ConnectionInformation[] connections = db.getBroker().getConnectionInformation();\n            InstanceInfo[] result = new InstanceInfo[connections.length];\n            for ( int i = 0; i < result.length; i++ )\n            {\n                ConnectionInformation connection = connections[i];\n                result[i] = new InstanceInfo( connection.getJMXServiceURL().toString(),\n                        connection.getInstanceId(), connection.getMachineId(),\n                        connection.isMaster(), connection.getLastCommitedTransactionId() );\n            }\n            return result;\n        }","commit_id":"c784907540bcde41aa641e6a06174a6be6dfd830","url":"https://github.com/neo4j/neo4j"},{"original_method":"public synchronized void setJmxConnectionData( JMXServiceURL jmxUrl, String instanceId )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"/jmx\";\n        String url = jmxUrl.toString();\n        byte[] data = new byte[( url.length() + instanceId.length() ) * 2 + 4];\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        // write URL\n        buffer.putShort( (short) url.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        // write instanceId\n        buffer.putShort( (short) instanceId.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        // truncate array\n        if ( buffer.limit() != data.length )\n        {\n            byte[] array = new byte[buffer.limit()];\n            System.arraycopy( data, 0, array, 0, array.length );\n            data = array;\n        }\n        try\n        {\n            zooKeeper.setData( path, data, -1 );\n        }\n        catch ( KeeperException e )\n        {\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n    }","id":35506,"modified_method":"public synchronized void setJmxConnectionData( JMXServiceURL jmxUrl, String instanceId )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"-jmx\";\n        String url = jmxUrl.toString();\n        byte[] data = new byte[( url.length() + instanceId.length() ) * 2 + 4];\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        // write URL\n        buffer.putShort( (short) url.length() );\n        buffer.asCharBuffer().put( url.toCharArray() );\n        buffer.position( buffer.position() + url.length() * 2 );\n        // write instanceId\n        buffer.putShort( (short) instanceId.length() );\n        buffer.asCharBuffer().put( instanceId.toCharArray() );\n        // truncate array\n        if ( buffer.limit() != data.length )\n        {\n            byte[] array = new byte[buffer.limit()];\n            System.arraycopy( data, 0, array, 0, array.length );\n            data = array;\n        }\n        try\n        {\n            try\n            {\n                zooKeeper.setData( path, data, -1 );\n            }\n            catch ( KeeperException e )\n            {\n                if ( e.code() == KeeperException.Code.NONODE )\n                {\n                    zooKeeper.create( path, data, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL );\n                }\n                else\n                {\n                    msgLog.logMessage( \"Unable to set jxm connection info\", e );\n                }\n            }\n        }\n        catch ( KeeperException e )\n        {\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            msgLog.logMessage( \"Unable to set jxm connection info\", e );\n        }\n    }","commit_id":"c784907540bcde41aa641e6a06174a6be6dfd830","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void getJmxConnectionData( ConnectionInformation connection )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"/jmx\";\n        byte[] data;\n        try\n        {\n            data = zooKeeper.getData( path, false, null );\n        }\n        catch ( KeeperException e )\n        {\n            return;\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            return;\n        }\n        if ( data == null || data.length == 0 ) return;\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        char[] url, instanceId;\n        try\n        {\n            // read URL\n            url = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( url );\n            // read instanceId\n            instanceId = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( instanceId );\n        }\n        catch ( BufferUnderflowException e )\n        {\n            return;\n        }\n        connection.setJMXConnectionData( new String( url ), new String( instanceId ) );\n    }","id":35507,"modified_method":"public void getJmxConnectionData( ConnectionInformation connection )\n    {\n        String path = rootPath + \"/\" + HA_SERVERS_CHILD + \"/\" + machineId + \"-jmx\";\n        byte[] data;\n        try\n        {\n            data = zooKeeper.getData( path, false, null );\n        }\n        catch ( KeeperException e )\n        {\n            return;\n        }\n        catch ( InterruptedException e )\n        {\n            Thread.interrupted();\n            return;\n        }\n        if ( data == null || data.length == 0 ) return;\n        ByteBuffer buffer = ByteBuffer.wrap( data );\n        char[] url, instanceId;\n        try\n        {\n            // read URL\n            url = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( url );\n            buffer.position( buffer.position() + url.length * 2 );\n            // read instanceId\n            instanceId = new char[buffer.getShort()];\n            buffer.asCharBuffer().get( instanceId );\n        }\n        catch ( BufferUnderflowException e )\n        {\n            return;\n        }\n        connection.setJMXConnectionData( new String( url ), new String( instanceId ) );\n    }","commit_id":"c784907540bcde41aa641e6a06174a6be6dfd830","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n   * @param counters counts of tasks that are in various states.\n   * @param totalTasks total number of tasks in request\n   * @return summary request status based on statuses of tasks in different\n   * states.\n   */\n  private HostRoleStatus calculateSummaryStatus(Map<HostRoleStatus, Integer> counters, int totalTasks) {\n    return counters.get(HostRoleStatus.FAILED) > 0 ? HostRoleStatus.FAILED :\n            // TODO (dlysnichenko): maybe change order of FAILED and ABORTED?\n            counters.get(HostRoleStatus.ABORTED) > 0 ? HostRoleStatus.ABORTED :\n                    counters.get(HostRoleStatus.TIMEDOUT) > 0 ? HostRoleStatus.TIMEDOUT :\n                            counters.get(HostRoleStatus.IN_PROGRESS) > 0 ? HostRoleStatus.IN_PROGRESS :\n                                    counters.get(HostRoleStatus.COMPLETED) == totalTasks ? HostRoleStatus.COMPLETED :\n                                            HostRoleStatus.PENDING;\n  }","id":35508,"modified_method":"/**\n   * @param counters counts of tasks that are in various states.\n   * @param totalTasks total number of tasks in request\n   * @return summary request status based on statuses of tasks in different\n   * states.\n   */\n  static HostRoleStatus calculateSummaryStatus(Map<HostRoleStatus, Integer> counters, int totalTasks) {\n    return counters.get(HostRoleStatus.FAILED) > 0 ? HostRoleStatus.FAILED :\n            // TODO (dlysnichenko): maybe change order of FAILED and ABORTED?\n            counters.get(HostRoleStatus.ABORTED) > 0 ? HostRoleStatus.ABORTED :\n                    counters.get(HostRoleStatus.TIMEDOUT) > 0 ? HostRoleStatus.TIMEDOUT :\n                            counters.get(HostRoleStatus.IN_PROGRESS) > 0 ? HostRoleStatus.IN_PROGRESS :\n                                    counters.get(HostRoleStatus.COMPLETED) == totalTasks ? HostRoleStatus.COMPLETED :\n                                            HostRoleStatus.PENDING;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"private Resource getRequestResource(final org.apache.ambari.server.actionmanager.Request request,\n                                      Set<String> requestedPropertyIds) {\n    Resource resource = new ResourceImpl(Resource.Type.Request);\n\n    if (null != request.getClusterName())\n      setResourceProperty(resource, REQUEST_CLUSTER_NAME_PROPERTY_ID, request.getClusterName(), requestedPropertyIds);\n\n    setResourceProperty(resource, REQUEST_ID_PROPERTY_ID, request.getRequestId(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_CONTEXT_ID, request.getRequestContext(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TYPE_ID, request.getRequestType(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_INPUTS_ID, request.getInputs(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_RESOURCE_FILTER_ID, request.getResourceFilters(), requestedPropertyIds);\n\n    RequestOperationLevel operationLevel = request.getOperationLevel();\n    String opLevelStr = null;\n    if (operationLevel != null) {\n      opLevelStr = RequestOperationLevel.getExternalLevelName(\n              operationLevel.getLevel().toString());\n    }\n    setResourceProperty(resource, REQUEST_OPERATION_LEVEL_ID, opLevelStr, requestedPropertyIds);\n\n    setResourceProperty(resource, REQUEST_CREATE_TIME_ID, request.getCreateTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_START_TIME_ID, request.getStartTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_END_TIME_ID, request.getEndTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_EXCLUSIVE_ID, request.isExclusive(), requestedPropertyIds);\n\n    if (request.getRequestScheduleId() != null) {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE_ID, request.getRequestScheduleId(), requestedPropertyIds);\n    } else {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE, null, requestedPropertyIds);\n    }\n    int taskCount = request.getCommands().size();\n\n    Map<HostRoleStatus, Integer> hostRoleStatusCounters = calculateRequestStatusCounters(request);\n    HostRoleStatus requestStatus = calculateSummaryStatus(hostRoleStatusCounters, taskCount);\n\n    double progressPercent =\n            ((hostRoleStatusCounters.get(HostRoleStatus.QUEUED) * 0.09 +\n                    hostRoleStatusCounters.get(HostRoleStatus.IN_PROGRESS) * 0.35 +\n                    hostRoleStatusCounters.get(HostRoleStatus.COMPLETED)) / (double) taskCount) * 100.0;\n\n    setResourceProperty(resource, REQUEST_STATUS_PROPERTY_ID, requestStatus.toString(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TASK_CNT_ID, taskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_FAILED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.FAILED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_ABORTED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.ABORTED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TIMED_OUT_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.TIMEDOUT), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_QUEUED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.QUEUED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_COMPLETED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.COMPLETED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_PROGRESS_PERCENT_ID, progressPercent, requestedPropertyIds);\n\n    return resource;\n  }","id":35509,"modified_method":"private Resource getRequestResource(final org.apache.ambari.server.actionmanager.Request request,\n                                      Set<String> requestedPropertyIds) {\n    Resource resource = new ResourceImpl(Resource.Type.Request);\n\n    if (null != request.getClusterName())\n      setResourceProperty(resource, REQUEST_CLUSTER_NAME_PROPERTY_ID, request.getClusterName(), requestedPropertyIds);\n\n    setResourceProperty(resource, REQUEST_ID_PROPERTY_ID, request.getRequestId(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_CONTEXT_ID, request.getRequestContext(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TYPE_ID, request.getRequestType(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_INPUTS_ID, request.getInputs(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_RESOURCE_FILTER_ID, request.getResourceFilters(), requestedPropertyIds);\n\n    RequestOperationLevel operationLevel = request.getOperationLevel();\n    String opLevelStr = null;\n    if (operationLevel != null) {\n      opLevelStr = RequestOperationLevel.getExternalLevelName(\n              operationLevel.getLevel().toString());\n    }\n    setResourceProperty(resource, REQUEST_OPERATION_LEVEL_ID, opLevelStr, requestedPropertyIds);\n\n    setResourceProperty(resource, REQUEST_CREATE_TIME_ID, request.getCreateTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_START_TIME_ID, request.getStartTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_END_TIME_ID, request.getEndTime(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_EXCLUSIVE_ID, request.isExclusive(), requestedPropertyIds);\n\n    if (request.getRequestScheduleId() != null) {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE_ID, request.getRequestScheduleId(), requestedPropertyIds);\n    } else {\n      setResourceProperty(resource, REQUEST_SOURCE_SCHEDULE, null, requestedPropertyIds);\n    }\n    int taskCount = request.getCommands().size();\n\n    Map<HostRoleStatus, Integer> hostRoleStatusCounters = calculateRequestStatusCounters(request);\n    HostRoleStatus requestStatus = calculateSummaryStatus(hostRoleStatusCounters, taskCount);\n\n    double progressPercent =\n            ((hostRoleStatusCounters.get(HostRoleStatus.QUEUED) * 0.09 +\n                    hostRoleStatusCounters.get(HostRoleStatus.IN_PROGRESS) * 0.35 +\n                    hostRoleStatusCounters.get(HostRoleStatus.COMPLETED)) / taskCount) * 100.0;\n\n    setResourceProperty(resource, REQUEST_STATUS_PROPERTY_ID, requestStatus.toString(), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TASK_CNT_ID, taskCount, requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_FAILED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.FAILED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_ABORTED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.ABORTED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_TIMED_OUT_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.TIMEDOUT), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_QUEUED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.QUEUED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_COMPLETED_TASK_CNT_ID,\n            hostRoleStatusCounters.get(HostRoleStatus.COMPLETED), requestedPropertyIds);\n    setResourceProperty(resource, REQUEST_PROGRESS_PERCENT_ID, progressPercent, requestedPropertyIds);\n\n    return resource;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Get a resource definition for the given type.\n   *\n   * @param type    the resource type\n   * @param mapIds  the map of ids\n   *\n   * @return the resource definition\n   */\n  public static ResourceDefinition getResourceDefinition(Resource.Type type, Map<Resource.Type, String> mapIds) {\n    ResourceDefinition resourceDefinition;\n\n    // Check to see if there is an external resource definition registered for the given type.\n    if (resourceDefinitions.containsKey(type)) {\n      return resourceDefinitions.get(type);\n    }\n\n    //todo: consider ResourceDependencyManager : Map<Resource.Type, ResourceDefinition>\n    switch (type.getInternalType()) {\n      case Cluster:\n        resourceDefinition = new ClusterResourceDefinition();\n        break;\n\n      case Service:\n        resourceDefinition = new ServiceResourceDefinition();\n        break;\n\n      case Host:\n        resourceDefinition = mapIds.containsKey(Resource.Type.Cluster) ?\n            new HostResourceDefinition() : new DetachedHostResourceDefinition();\n        break;\n\n      case Component:\n        resourceDefinition = new ComponentResourceDefinition();\n        break;\n\n      case HostComponent:\n        resourceDefinition = new HostComponentResourceDefinition();\n        break;\n\n      case Action:\n        resourceDefinition = new ActionResourceDefinition();\n        break;\n\n      case Configuration:\n        resourceDefinition = new ConfigurationResourceDefinition();\n        break;\n\n      case ServiceConfigVersion:\n        resourceDefinition = new ServiceConfigVersionResourceDefinition();\n        break;\n\n      case Task:\n        resourceDefinition = new TaskResourceDefinition();\n        break;\n\n      case User:\n        resourceDefinition = new UserResourceDefinition();\n        break;\n\n      case Group:\n        resourceDefinition = new GroupResourceDefinition();\n        break;\n\n      case Member:\n        resourceDefinition = new MemberResourceDefinition();\n        break;\n\n      case Request:\n        resourceDefinition = new RequestResourceDefinition();\n        break;\n\n      case Stack:\n        resourceDefinition = new StackResourceDefinition();\n        break;\n\n      case StackVersion:\n        resourceDefinition = new StackVersionResourceDefinition();\n        break;\n\n      case StackLevelConfiguration:\n        resourceDefinition = new StackLevelConfigurationResourceDefinition();\n        break;\n\n      case StackService:\n        resourceDefinition = new StackServiceResourceDefinition();\n        break;\n\n      case StackServiceComponent:\n        resourceDefinition = new StackServiceComponentResourceDefinition();\n        break;\n\n      case StackServiceComponentDependency:\n        resourceDefinition = new StackDependencyResourceDefinition();\n        break;\n\n      case StackConfiguration:\n        resourceDefinition = new StackConfigurationResourceDefinition();\n        break;\n\n      case OperatingSystem:\n        resourceDefinition = new OperatingSystemResourceDefinition();\n        break;\n\n      case Repository:\n        resourceDefinition = new RepositoryResourceDefinition();\n        break;\n\n      case DRFeed:\n        resourceDefinition = new FeedResourceDefinition();\n        break;\n\n      case DRTargetCluster:\n        resourceDefinition = new TargetClusterResourceDefinition();\n        break;\n\n      case DRInstance:\n        resourceDefinition = new InstanceResourceDefinition();\n        break;\n\n      case Workflow:\n        resourceDefinition = new WorkflowResourceDefinition();\n        break;\n\n      case Job:\n        resourceDefinition = new JobResourceDefinition();\n        break;\n\n      case TaskAttempt:\n        resourceDefinition = new TaskAttemptResourceDefinition();\n        break;\n\n      case RootService:\n        resourceDefinition = new RootServiceResourceDefinition();\n        break;\n\n      case RootServiceComponent:\n        resourceDefinition = new RootServiceComponentResourceDefinition();\n        break;\n\n      case RootServiceHostComponent:\n        resourceDefinition = new RootServiceHostComponentResourceDefinition();\n        break;\n\n      case ConfigGroup:\n        resourceDefinition = new ConfigGroupResourceDefinition();\n        break;\n\n      case RequestSchedule:\n        resourceDefinition = new RequestScheduleResourceDefinition();\n        break;\n\n      case View:\n        resourceDefinition = new ViewResourceDefinition();\n        break;\n\n      case ViewVersion:\n        resourceDefinition = new ViewVersionResourceDefinition();\n        break;\n\n      case ViewInstance:\n        String viewName = mapIds.get(Resource.Type.View);\n        String version  = mapIds.get(Resource.Type.ViewVersion);\n\n        Set<SubResourceDefinition> subResourceDefinitions = (viewName == null || version == null)  ?\n            Collections.<SubResourceDefinition>emptySet() :\n            ViewRegistry.getInstance().getSubResourceDefinitions(viewName, version);\n\n        resourceDefinition = new ViewInstanceResourceDefinition(subResourceDefinitions);\n        break;\n\n      case Blueprint:\n        resourceDefinition = new BlueprintResourceDefinition();\n        break;\n\n      case Recommendation:\n        resourceDefinition = new RecommendationResourceDefinition();\n        break;\n\n      case Validation:\n        resourceDefinition = new ValidationResourceDefinition();\n        break;\n\n      case HostComponentProcess:\n        resourceDefinition = new HostComponentProcessResourceDefinition();\n        break;\n\n      case Permission:\n        resourceDefinition = new PermissionResourceDefinition();\n        break;\n\n      case Alert:\n        resourceDefinition = new AlertResourceDefinition();\n        break;\n\n      case AlertDefinition:\n        resourceDefinition = new AlertDefResourceDefinition();\n        break;\n\n      case AlertHistory:\n        resourceDefinition = new AlertHistoryResourceDefinition();\n        break;\n\n      case AlertGroup:\n        resourceDefinition = new AlertGroupResourceDefinition();\n        break;\n\n      case AlertTarget:\n        resourceDefinition = new AlertTargetResourceDefinition();\n        break;\n\n      case AlertNotice:\n        resourceDefinition = new AlertNoticeResourceDefinition();\n        break;\n\n      case AmbariPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.AmbariPrivilege);\n        break;\n\n      case ClusterPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.ClusterPrivilege);\n        break;\n\n      case ViewPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.ViewPrivilege);\n        break;\n\n      case UserPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.UserPrivilege);\n        break;\n\n      case ViewPermission:\n        resourceDefinition = new ViewPermissionResourceDefinition();\n        break;\n\n      case ClientConfig:\n        resourceDefinition = new ClientConfigResourceDefinition();\n        break;\n\n      case LdapSyncEvent:\n        resourceDefinition = new LdapSyncEventResourceDefinition();\n        break;\n\n      case RepositoryVersion:\n        resourceDefinition = new RepositoryVersionResourceDefinition();\n        break;\n\n      case HostStackVersion:\n        resourceDefinition = new ComponentStackVersionResourceDefinition(Resource.Type.HostStackVersion);\n        break;\n\n      case ClusterStackVersion:\n        resourceDefinition = new ComponentStackVersionResourceDefinition(Resource.Type.ClusterStackVersion);\n        break;\n\n      case Upgrade:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.Upgrade, \"upgrade\", \"upgrades\",\n            Resource.Type.UpgradeGroup);\n        break;\n\n      case UpgradeGroup:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.UpgradeGroup, \"upgrade_group\", \"upgrade_groups\",\n            Resource.Type.UpgradeItem);\n        break;\n\n      case UpgradeItem:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.UpgradeItem, \"upgrade_item\", \"upgrade_items\");\n        break;\n\n      case Stage:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.Stage, \"stage\", \"stages\", Resource.Type.Task);\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Unsupported resource type: \" + type);\n    }\n    return resourceDefinition;\n  }","id":35510,"modified_method":"/**\n   * Get a resource definition for the given type.\n   *\n   * @param type    the resource type\n   * @param mapIds  the map of ids\n   *\n   * @return the resource definition\n   */\n  public static ResourceDefinition getResourceDefinition(Resource.Type type, Map<Resource.Type, String> mapIds) {\n    ResourceDefinition resourceDefinition;\n\n    // Check to see if there is an external resource definition registered for the given type.\n    if (resourceDefinitions.containsKey(type)) {\n      return resourceDefinitions.get(type);\n    }\n\n    //todo: consider ResourceDependencyManager : Map<Resource.Type, ResourceDefinition>\n    switch (type.getInternalType()) {\n      case Cluster:\n        resourceDefinition = new ClusterResourceDefinition();\n        break;\n\n      case Service:\n        resourceDefinition = new ServiceResourceDefinition();\n        break;\n\n      case Host:\n        resourceDefinition = mapIds.containsKey(Resource.Type.Cluster) ?\n            new HostResourceDefinition() : new DetachedHostResourceDefinition();\n        break;\n\n      case Component:\n        resourceDefinition = new ComponentResourceDefinition();\n        break;\n\n      case HostComponent:\n        resourceDefinition = new HostComponentResourceDefinition();\n        break;\n\n      case Action:\n        resourceDefinition = new ActionResourceDefinition();\n        break;\n\n      case Configuration:\n        resourceDefinition = new ConfigurationResourceDefinition();\n        break;\n\n      case ServiceConfigVersion:\n        resourceDefinition = new ServiceConfigVersionResourceDefinition();\n        break;\n\n      case Task:\n        resourceDefinition = new TaskResourceDefinition();\n        break;\n\n      case User:\n        resourceDefinition = new UserResourceDefinition();\n        break;\n\n      case Group:\n        resourceDefinition = new GroupResourceDefinition();\n        break;\n\n      case Member:\n        resourceDefinition = new MemberResourceDefinition();\n        break;\n\n      case Request:\n        resourceDefinition = new RequestResourceDefinition();\n        break;\n\n      case Stack:\n        resourceDefinition = new StackResourceDefinition();\n        break;\n\n      case StackVersion:\n        resourceDefinition = new StackVersionResourceDefinition();\n        break;\n\n      case StackLevelConfiguration:\n        resourceDefinition = new StackLevelConfigurationResourceDefinition();\n        break;\n\n      case StackService:\n        resourceDefinition = new StackServiceResourceDefinition();\n        break;\n\n      case StackServiceComponent:\n        resourceDefinition = new StackServiceComponentResourceDefinition();\n        break;\n\n      case StackServiceComponentDependency:\n        resourceDefinition = new StackDependencyResourceDefinition();\n        break;\n\n      case StackConfiguration:\n        resourceDefinition = new StackConfigurationResourceDefinition();\n        break;\n\n      case OperatingSystem:\n        resourceDefinition = new OperatingSystemResourceDefinition();\n        break;\n\n      case Repository:\n        resourceDefinition = new RepositoryResourceDefinition();\n        break;\n\n      case DRFeed:\n        resourceDefinition = new FeedResourceDefinition();\n        break;\n\n      case DRTargetCluster:\n        resourceDefinition = new TargetClusterResourceDefinition();\n        break;\n\n      case DRInstance:\n        resourceDefinition = new InstanceResourceDefinition();\n        break;\n\n      case Workflow:\n        resourceDefinition = new WorkflowResourceDefinition();\n        break;\n\n      case Job:\n        resourceDefinition = new JobResourceDefinition();\n        break;\n\n      case TaskAttempt:\n        resourceDefinition = new TaskAttemptResourceDefinition();\n        break;\n\n      case RootService:\n        resourceDefinition = new RootServiceResourceDefinition();\n        break;\n\n      case RootServiceComponent:\n        resourceDefinition = new RootServiceComponentResourceDefinition();\n        break;\n\n      case RootServiceHostComponent:\n        resourceDefinition = new RootServiceHostComponentResourceDefinition();\n        break;\n\n      case ConfigGroup:\n        resourceDefinition = new ConfigGroupResourceDefinition();\n        break;\n\n      case RequestSchedule:\n        resourceDefinition = new RequestScheduleResourceDefinition();\n        break;\n\n      case View:\n        resourceDefinition = new ViewResourceDefinition();\n        break;\n\n      case ViewVersion:\n        resourceDefinition = new ViewVersionResourceDefinition();\n        break;\n\n      case ViewInstance:\n        String viewName = mapIds.get(Resource.Type.View);\n        String version  = mapIds.get(Resource.Type.ViewVersion);\n\n        Set<SubResourceDefinition> subResourceDefinitions = (viewName == null || version == null)  ?\n            Collections.<SubResourceDefinition>emptySet() :\n            ViewRegistry.getInstance().getSubResourceDefinitions(viewName, version);\n\n        resourceDefinition = new ViewInstanceResourceDefinition(subResourceDefinitions);\n        break;\n\n      case Blueprint:\n        resourceDefinition = new BlueprintResourceDefinition();\n        break;\n\n      case Recommendation:\n        resourceDefinition = new RecommendationResourceDefinition();\n        break;\n\n      case Validation:\n        resourceDefinition = new ValidationResourceDefinition();\n        break;\n\n      case HostComponentProcess:\n        resourceDefinition = new HostComponentProcessResourceDefinition();\n        break;\n\n      case Permission:\n        resourceDefinition = new PermissionResourceDefinition();\n        break;\n\n      case Alert:\n        resourceDefinition = new AlertResourceDefinition();\n        break;\n\n      case AlertDefinition:\n        resourceDefinition = new AlertDefResourceDefinition();\n        break;\n\n      case AlertHistory:\n        resourceDefinition = new AlertHistoryResourceDefinition();\n        break;\n\n      case AlertGroup:\n        resourceDefinition = new AlertGroupResourceDefinition();\n        break;\n\n      case AlertTarget:\n        resourceDefinition = new AlertTargetResourceDefinition();\n        break;\n\n      case AlertNotice:\n        resourceDefinition = new AlertNoticeResourceDefinition();\n        break;\n\n      case AmbariPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.AmbariPrivilege);\n        break;\n\n      case ClusterPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.ClusterPrivilege);\n        break;\n\n      case ViewPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.ViewPrivilege);\n        break;\n\n      case UserPrivilege:\n        resourceDefinition = new PrivilegeResourceDefinition(Resource.Type.UserPrivilege);\n        break;\n\n      case ViewPermission:\n        resourceDefinition = new ViewPermissionResourceDefinition();\n        break;\n\n      case ClientConfig:\n        resourceDefinition = new ClientConfigResourceDefinition();\n        break;\n\n      case LdapSyncEvent:\n        resourceDefinition = new LdapSyncEventResourceDefinition();\n        break;\n\n      case RepositoryVersion:\n        resourceDefinition = new RepositoryVersionResourceDefinition();\n        break;\n\n      case HostStackVersion:\n        resourceDefinition = new ComponentStackVersionResourceDefinition(Resource.Type.HostStackVersion);\n        break;\n\n      case ClusterStackVersion:\n        resourceDefinition = new ComponentStackVersionResourceDefinition(Resource.Type.ClusterStackVersion);\n        break;\n\n      case Upgrade:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.Upgrade, \"upgrade\", \"upgrades\",\n            Resource.Type.UpgradeGroup);\n        break;\n\n      case UpgradeGroup:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.UpgradeGroup, \"upgrade_group\", \"upgrade_groups\",\n            Resource.Type.UpgradeItem);\n        break;\n\n      case UpgradeItem:\n        resourceDefinition = new SimpleResourceDefinition(\n            Resource.Type.UpgradeItem, \"upgrade_item\", \"upgrade_items\", Resource.Type.Task);\n        break;\n\n      case Stage:\n        resourceDefinition = new SimpleResourceDefinition(Resource.Type.Stage, \"stage\", \"stages\", Resource.Type.Task);\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Unsupported resource type: \" + type);\n    }\n    return resourceDefinition;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * @param groupId the group id\n   * @return the group, or {@code null} if not found\n   */\n  public UpgradeGroupEntity findUpgradeGroup(long groupId) {\n\n    TypedQuery<UpgradeGroupEntity> query = entityManagerProvider.get().createQuery(\n        \"SELECT p FROM UpgradeGroupEntity p WHERE p.upgradeGroupId = :groupId\", UpgradeGroupEntity.class);\n    query.setParameter(\"groupId\", Long.valueOf(groupId));\n    query.setHint(QueryHints.REFRESH, HintValues.TRUE);\n\n    return daoUtils.selectSingle(query);\n  }","id":35511,"modified_method":"/**\n   * @param groupId the group id\n   * @return the group, or {@code null} if not found\n   */\n  @RequiresSession\n  public UpgradeGroupEntity findUpgradeGroup(Long groupId) {\n\n    TypedQuery<UpgradeGroupEntity> query = entityManagerProvider.get().createQuery(\n        \"SELECT p FROM UpgradeGroupEntity p WHERE p.upgradeGroupId = :groupId\", UpgradeGroupEntity.class);\n    query.setParameter(\"groupId\", groupId);\n    query.setHint(QueryHints.REFRESH, HintValues.TRUE);\n\n    return daoUtils.selectSingle(query);\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate)\n      throws SystemException, UnsupportedPropertyException,\n      NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> results = new HashSet<Resource>();\n    Set<String> requestPropertyIds = getRequestPropertyIds(request, predicate);\n\n    for (Map<String, Object> propertyMap : getPropertyMaps(predicate)) {\n      String upgradeIdStr = (String) propertyMap.get(UPGRADE_ID);\n\n      if (null == upgradeIdStr || upgradeIdStr.isEmpty()) {\n        throw new IllegalArgumentException(\"The upgrade id is required when querying for upgrades\");\n      }\n\n      long upgradeId = Long.parseLong(upgradeIdStr);\n      UpgradeEntity upgrade = m_dao.findUpgrade(upgradeId);\n\n      List<UpgradeGroupEntity> groups = upgrade.getUpgradeGroups();\n      if (null != groups) {\n        for (UpgradeGroupEntity group : upgrade.getUpgradeGroups()) {\n          results.add(toResource(upgrade, group, requestPropertyIds));\n        }\n      }\n\n    }\n\n    return results;\n  }","id":35512,"modified_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate)\n      throws SystemException, UnsupportedPropertyException,\n      NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> results = new HashSet<Resource>();\n    Set<String> requestPropertyIds = getRequestPropertyIds(request, predicate);\n\n    for (Map<String, Object> propertyMap : getPropertyMaps(predicate)) {\n      String upgradeIdStr = (String) propertyMap.get(UPGRADE_REQUEST_ID);\n      String clusterName = (String) propertyMap.get(UPGRADE_CLUSTER_NAME);\n\n      if (null == upgradeIdStr || upgradeIdStr.isEmpty()) {\n        throw new IllegalArgumentException(\"The upgrade id is required when querying for upgrades\");\n      }\n\n      Long upgradeId = Long.valueOf(upgradeIdStr);\n      UpgradeEntity upgrade = m_dao.findUpgradeByRequestId(upgradeId);\n\n      List<UpgradeGroupEntity> groups = upgrade.getUpgradeGroups();\n      if (null != groups) {\n        UpgradeHelper helper = new UpgradeHelper();\n\n        for (UpgradeGroupEntity group : upgrade.getUpgradeGroups()) {\n          Resource r = toResource(upgrade, group, requestPropertyIds);\n\n          List<Long> stageIds = new ArrayList<Long>();\n          for (UpgradeItemEntity itemEntity : group.getItems()) {\n            stageIds.add(itemEntity.getStageId());\n          }\n\n          Set<Resource> stages = helper.getStageResources(clusterName, upgrade.getRequestId(), stageIds);\n\n          aggregate(r, stages, requestPropertyIds);\n\n          results.add(r);\n        }\n      }\n\n    }\n\n    return results;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"private Resource toResource(UpgradeEntity upgrade, UpgradeGroupEntity group, Set<String> requestedIds) {\n    ResourceImpl resource = new ResourceImpl(Resource.Type.UpgradeGroup);\n\n    setResourceProperty(resource, UPGRADE_ID, upgrade.getId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_ID, group.getId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_NAME, group.getName(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_TITLE, group.getTitle(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_STATE, \"NONE\", requestedIds);\n\n    return resource;\n  }","id":35513,"modified_method":"private Resource toResource(UpgradeEntity upgrade, UpgradeGroupEntity group, Set<String> requestedIds) {\n    ResourceImpl resource = new ResourceImpl(Resource.Type.UpgradeGroup);\n\n    setResourceProperty(resource, UPGRADE_REQUEST_ID, upgrade.getRequestId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_ID, group.getId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_NAME, group.getName(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_TITLE, group.getTitle(), requestedIds);\n\n    return resource;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * @param groupId the specific group id\n   * @return the resource instance\n   */\n  private ResourceInstance createResourceInstance(Long groupId) {\n    Map<Resource.Type, String> mapIds = new HashMap<Resource.Type, String>();\n    mapIds.put(Resource.Type.Cluster, m_clusterName);\n    mapIds.put(Resource.Type.Upgrade, m_upgradeId);\n\n    if (null != groupId) {\n      mapIds.put(Resource.Type.UpgradeGroup, groupId.toString());\n    }\n\n    return createResource(Resource.Type.UpgradeGroup, mapIds);\n  }","id":35514,"modified_method":"/**\n   * @param groupId the specific group id\n   * @return the resource instance\n   */\n  private ResourceInstance createResourceInstance(Long groupId) {\n    Map<Resource.Type, String> mapIds = new HashMap<Resource.Type, String>();\n    mapIds.put(Resource.Type.Cluster, m_clusterName);\n    mapIds.put(Resource.Type.Upgrade, m_upgradeId);\n    mapIds.put(Resource.Type.Request, m_upgradeId);\n\n    if (null != groupId) {\n      mapIds.put(Resource.Type.UpgradeGroup, groupId.toString());\n    }\n\n    return createResource(Resource.Type.UpgradeGroup, mapIds);\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"private Resource toResource(UpgradeEntity upgrade, UpgradeItemEntity item, Set<String> requestedIds) {\n    ResourceImpl resource = new ResourceImpl(Resource.Type.UpgradeItem);\n\n    setResourceProperty(resource, UPGRADE_ID, upgrade.getId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_ID, item.getGroupEntity().getId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_ITEM_ID, item.getId(), requestedIds);\n    if (isPropertyRequested(UPGRADE_ITEM_STATE, requestedIds)) {\n      UpgradeState state = calculateState(upgrade, item);\n      setResourceProperty(resource, UPGRADE_ITEM_STATE, state, requestedIds);\n    }\n    setResourceProperty(resource, UPGRADE_ITEM_TEXT, item.getText(), requestedIds);\n\n    return resource;\n  }","id":35515,"modified_method":"private Resource toResource(UpgradeItemEntity item, Set<String> requestedIds) {\n    ResourceImpl resource = new ResourceImpl(Resource.Type.UpgradeItem);\n\n    UpgradeGroupEntity group = item.getGroupEntity();\n    UpgradeEntity upgrade = group.getUpgradeEntity();\n\n    setResourceProperty(resource, UPGRADE_REQUEST_ID, upgrade.getRequestId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_GROUP_ID, group.getId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_ITEM_STAGE_ID, item.getStageId(), requestedIds);\n\n    return resource;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate)\n      throws SystemException, UnsupportedPropertyException,\n      NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> results = new HashSet<Resource>();\n    Set<String> requestPropertyIds = getRequestPropertyIds(request, predicate);\n\n    for (Map<String, Object> propertyMap : getPropertyMaps(predicate)) {\n      String upgradeIdStr = (String) propertyMap.get(UPGRADE_ID);\n      String groupIdStr = (String) propertyMap.get(UPGRADE_GROUP_ID);\n\n      if (null == upgradeIdStr || upgradeIdStr.isEmpty()) {\n        throw new IllegalArgumentException(\"The upgrade id is required when querying for upgrades\");\n      }\n\n      if (null == groupIdStr || groupIdStr.isEmpty()) {\n        throw new IllegalArgumentException(\"The upgrade id is required when querying for upgrades\");\n      }\n\n\n      long upgradeId = Long.parseLong(upgradeIdStr);\n      long groupId = Long.parseLong(groupIdStr);\n      UpgradeGroupEntity group = m_dao.findUpgradeGroup(groupId);\n\n      if (null == group || null == group.getItems()) {\n        throw new NoSuchResourceException(String.format(\"Cannot load upgrade for %s\", upgradeIdStr));\n      }\n\n      for (UpgradeItemEntity entity : group.getItems()) {\n        results.add(toResource(group.getUpgradeEntity(), entity, requestPropertyIds));\n      }\n    }\n\n    return results;\n  }","id":35516,"modified_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate)\n      throws SystemException, UnsupportedPropertyException,\n      NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> results = new HashSet<Resource>();\n    Set<String> requestPropertyIds = getRequestPropertyIds(request, predicate);\n\n    for (Map<String, Object> propertyMap : getPropertyMaps(predicate)) {\n      String clusterName = (String) propertyMap.get(UPGRADE_CLUSTER_NAME);\n      String requestIdStr = (String) propertyMap.get(UPGRADE_REQUEST_ID);\n      String groupIdStr = (String) propertyMap.get(UPGRADE_GROUP_ID);\n      String stageIdStr = (String) propertyMap.get(UPGRADE_ITEM_STAGE_ID);\n\n      if (null == requestIdStr || requestIdStr.isEmpty()) {\n        throw new IllegalArgumentException(\"The upgrade id is required when querying for upgrades\");\n      }\n\n      if (null == groupIdStr || groupIdStr.isEmpty()) {\n        throw new IllegalArgumentException(\"The upgrade group id is required when querying for upgrades\");\n      }\n\n      Long requestId = Long.valueOf(requestIdStr);\n      Long groupId = Long.valueOf(groupIdStr);\n      Long stageId = null;\n      if (null != stageIdStr) {\n        stageId = Long.valueOf(stageIdStr);\n      }\n\n      List<UpgradeItemEntity> entities = new ArrayList<UpgradeItemEntity>();\n      if (null == stageId) {\n        UpgradeGroupEntity group = m_dao.findUpgradeGroup(groupId);\n\n        if (null == group || null == group.getItems()) {\n          throw new NoSuchResourceException(String.format(\"Cannot load upgrade for %s\", requestIdStr));\n        }\n\n        entities = group.getItems();\n\n      } else {\n        UpgradeItemEntity entity = m_dao.findUpgradeItemByRequestAndStage(requestId, stageId);\n        if (null != entity) {\n          entities.add(entity);\n        }\n      }\n\n      // !!! need to do some lookup for stages, so use a stageid -> resource for\n      // when that happens\n      Map<Long, Resource> resultMap = new HashMap<Long, Resource>();\n\n      for (UpgradeItemEntity entity : entities) {\n        Resource r = toResource(entity, requestPropertyIds);\n        resultMap.put(entity.getStageId(), r);\n      }\n\n      if (null != clusterName) {\n        UpgradeHelper helper = new UpgradeHelper();\n\n        Set<Resource> stages = helper.getStageResources(clusterName, requestId,\n            new ArrayList<Long>(resultMap.keySet()));\n\n        for (Resource stage : stages) {\n          Long l = (Long) stage.getPropertyValue(StageResourceProvider.STAGE_STAGE_ID);\n\n          Resource r = resultMap.get(l);\n          if (null != r) {\n            for (String propertyId : StageResourceProvider.PROPERTY_IDS) {\n              setResourceProperty(r, STAGE_MAPPED_IDS.get(propertyId),\n                stage.getPropertyValue(propertyId), requestPropertyIds);\n            }\n          }\n        }\n      }\n\n      results.addAll(resultMap.values());\n\n    }\n    return results;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * @param upgradeItemId the specific item id\n   * @return the resource instance\n   */\n  private ResourceInstance createResourceInstance(Long upgradeItemId) {\n    Map<Resource.Type, String> mapIds = new HashMap<Resource.Type, String>();\n    mapIds.put(Resource.Type.Cluster, m_clusterName);\n    mapIds.put(Resource.Type.Upgrade, m_upgradeId);\n    mapIds.put(Resource.Type.UpgradeGroup, m_upgradeGroupId);\n\n    if (null != upgradeItemId) {\n      mapIds.put(Resource.Type.UpgradeItem, upgradeItemId.toString());\n    }\n\n    return createResource(Resource.Type.UpgradeItem, mapIds);\n  }","id":35517,"modified_method":"/**\n   * @param upgradeItemId the specific item id\n   * @return the resource instance\n   */\n  private ResourceInstance createResourceInstance(Long upgradeItemId) {\n    Map<Resource.Type, String> mapIds = new HashMap<Resource.Type, String>();\n    mapIds.put(Resource.Type.Cluster, m_clusterName);\n    mapIds.put(Resource.Type.Upgrade, m_upgradeId);\n    mapIds.put(Resource.Type.UpgradeGroup, m_upgradeGroupId);\n    mapIds.put(Resource.Type.Request, m_upgradeId);\n\n    if (null != upgradeItemId) {\n      mapIds.put(Resource.Type.UpgradeItem, upgradeItemId.toString());\n    }\n\n    return createResource(Resource.Type.UpgradeItem, mapIds);\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"private Resource toResource(UpgradeEntity entity, String clusterName,\n      Set<String> requestedIds) {\n    ResourceImpl resource = new ResourceImpl(Resource.Type.Upgrade);\n\n    setResourceProperty(resource, UPGRADE_ID, entity.getId(), requestedIds);\n    setResourceProperty(resource, UPGRADE_CLUSTER_NAME, clusterName, requestedIds);\n    setResourceProperty(resource, UPGRADE_REQUEST_ID, entity.getRequestId(), requestedIds);\n\n    return resource;\n  }","id":35518,"modified_method":"private Resource toResource(UpgradeEntity entity, String clusterName,\n      Set<String> requestedIds) {\n    ResourceImpl resource = new ResourceImpl(Resource.Type.Upgrade);\n\n    setResourceProperty(resource, UPGRADE_CLUSTER_NAME, clusterName, requestedIds);\n    setResourceProperty(resource, UPGRADE_REQUEST_ID, entity.getRequestId(), requestedIds);\n\n    return resource;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate)\n      throws SystemException, UnsupportedPropertyException,\n      NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> results = new HashSet<Resource>();\n    Set<String> requestPropertyIds = getRequestPropertyIds(request, predicate);\n\n    for (Map<String, Object> propertyMap : getPropertyMaps(predicate)) {\n      String clusterName = (String) propertyMap.get(UPGRADE_CLUSTER_NAME);\n\n      if (null == clusterName || clusterName.isEmpty()) {\n        throw new IllegalArgumentException(\"The cluster name is required when querying for upgrades\");\n      }\n\n      Cluster cluster = null;\n      try {\n        cluster = getManagementController().getClusters().getCluster(clusterName);\n      } catch (AmbariException e) {\n        throw new NoSuchResourceException(String.format(\"Cluster %s could not be loaded\", clusterName));\n      }\n\n      List<UpgradeEntity> upgrades = new ArrayList<UpgradeEntity>();\n\n      String upgradeIdStr = (String) propertyMap.get(UPGRADE_ID);\n      if (null != upgradeIdStr) {\n        UpgradeEntity upgrade = m_upgradeDAO.findUpgrade(Long.parseLong(upgradeIdStr));\n        if (null != upgrade) {\n          upgrades.add(upgrade);\n        }\n      } else {\n        upgrades = m_upgradeDAO.findUpgrades(cluster.getClusterId());\n      }\n\n      for (UpgradeEntity entity : upgrades) {\n        results.add(toResource(entity, clusterName, requestPropertyIds));\n      }\n    }\n\n    return results;\n  }","id":35519,"modified_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate)\n      throws SystemException, UnsupportedPropertyException,\n      NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> results = new HashSet<Resource>();\n    Set<String> requestPropertyIds = getRequestPropertyIds(request, predicate);\n\n    for (Map<String, Object> propertyMap : getPropertyMaps(predicate)) {\n      String clusterName = (String) propertyMap.get(UPGRADE_CLUSTER_NAME);\n\n      if (null == clusterName || clusterName.isEmpty()) {\n        throw new IllegalArgumentException(\"The cluster name is required when querying for upgrades\");\n      }\n\n      Cluster cluster = null;\n      try {\n        cluster = getManagementController().getClusters().getCluster(clusterName);\n      } catch (AmbariException e) {\n        throw new NoSuchResourceException(String.format(\"Cluster %s could not be loaded\", clusterName));\n      }\n\n      List<UpgradeEntity> upgrades = new ArrayList<UpgradeEntity>();\n\n      String upgradeIdStr = (String) propertyMap.get(UPGRADE_REQUEST_ID);\n      if (null != upgradeIdStr) {\n        UpgradeEntity upgrade = m_upgradeDAO.findUpgradeByRequestId(Long.valueOf(upgradeIdStr));\n\n        if (null != upgrade) {\n          upgrades.add(upgrade);\n        }\n      } else {\n        upgrades = m_upgradeDAO.findUpgrades(cluster.getClusterId());\n      }\n\n      UpgradeHelper helper = new UpgradeHelper();\n      for (UpgradeEntity entity : upgrades) {\n        Resource r = toResource(entity, clusterName, requestPropertyIds);\n        results.add(r);\n\n        // !!! not terribly efficient, but that's ok in this case.  The handful-per-year\n        // an upgrade is done won't kill performance.\n        Resource r1 = helper.getRequestResource(clusterName, entity.getRequestId());\n        for (Entry<String, String> entry : REQUEST_PROPERTY_MAP.entrySet()) {\n          Object o = r1.getPropertyValue(entry.getKey());\n\n          setResourceProperty(r, entry.getValue(), o, requestPropertyIds);\n        }\n      }\n    }\n\n    return results;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public RequestStatus createResources(final Request request)\n      throws SystemException,\n      UnsupportedPropertyException, ResourceAlreadyExistsException,\n      NoSuchParentResourceException {\n\n    Set<Map<String, Object>> requestMaps = request.getProperties();\n\n    if (requestMaps.size() > 1) {\n      throw new SystemException(\"Can only initiate one upgrade per request.\");\n    }\n\n    // !!! above check ensures only one\n    final Map<String, Object> requestMap = requestMaps.iterator().next();\n\n    UpgradeEntity entity = createResources(new Command<UpgradeEntity>() {\n        @Override\n        public UpgradeEntity invoke() throws AmbariException {\n          UpgradePack up = validateRequest(requestMap);\n\n          return createUpgrade(up, requestMap);\n        };\n      });\n\n    notifyCreate(Resource.Type.Upgrade, request);\n\n    Resource res = new ResourceImpl(Resource.Type.Upgrade);\n    res.setProperty(UPGRADE_ID, entity.getId());\n    return new RequestStatusImpl(null, Collections.singleton(res));\n  }","id":35520,"modified_method":"@Override\n  public RequestStatus createResources(final Request request)\n      throws SystemException,\n      UnsupportedPropertyException, ResourceAlreadyExistsException,\n      NoSuchParentResourceException {\n\n    Set<Map<String, Object>> requestMaps = request.getProperties();\n\n    if (requestMaps.size() > 1) {\n      throw new SystemException(\"Can only initiate one upgrade per request.\");\n    }\n\n    // !!! above check ensures only one\n    final Map<String, Object> requestMap = requestMaps.iterator().next();\n\n    UpgradeEntity entity = createResources(new Command<UpgradeEntity>() {\n        @Override\n        public UpgradeEntity invoke() throws AmbariException {\n          UpgradePack up = validateRequest(requestMap);\n\n          return createUpgrade(up, requestMap);\n        };\n      });\n\n    notifyCreate(Resource.Type.Upgrade, request);\n\n    Resource res = new ResourceImpl(Resource.Type.Upgrade);\n    res.setProperty(UPGRADE_REQUEST_ID, entity.getRequestId());\n    return new RequestStatusImpl(null, Collections.singleton(res));\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * @throws Exception\n   */\n  @Test\n  public void testCreateResources() throws Exception {\n\n    Cluster cluster = clusters.getCluster(\"c1\");\n\n    List<UpgradeEntity> upgrades = upgradeDao.findUpgrades(cluster.getClusterId());\n    assertEquals(0, upgrades.size());\n\n    AmbariManagementController amc = injector.getInstance(AmbariManagementController.class);\n\n    UpgradeResourceProvider provider = createProvider(amc);\n\n    Map<String, Object> requestProps = new HashMap<String, Object>();\n    requestProps.put(UpgradeResourceProvider.UPGRADE_CLUSTER_NAME, \"c1\");\n    requestProps.put(UpgradeResourceProvider.UPGRADE_VERSION, \"2.2.2.2\");\n\n    Request request = PropertyHelper.getCreateRequest(Collections.singleton(requestProps), null);\n    org.apache.ambari.server.controller.spi.RequestStatus status = provider.createResources(request);\n\n\n    upgrades = upgradeDao.findUpgrades(cluster.getClusterId());\n    assertEquals(1, upgrades.size());\n\n    UpgradeEntity entity = upgrades.get(0);\n    assertEquals(cluster.getClusterId(), entity.getClusterId().longValue());\n\n    assertEquals(3, entity.getUpgradeGroups().size());\n\n    UpgradeGroupEntity group = entity.getUpgradeGroups().get(0);\n\n    assertEquals(3, group.getItems().size());\n\n    assertTrue(group.getItems().get(0).getText().contains(\"Preparing\"));\n    assertTrue(group.getItems().get(1).getText().contains(\"Restarting\"));\n    assertTrue(group.getItems().get(2).getText().contains(\"Completing\"));\n\n    ActionManager am = injector.getInstance(ActionManager.class);\n    List<Long> requests = am.getRequestsByStatus(RequestStatus.IN_PROGRESS, 100, true);\n\n    assertEquals(1, requests.size());\n    assertEquals(requests.get(0), entity.getRequestId());\n\n\n    List<Stage> stages = am.getRequestStatus(requests.get(0).longValue());\n    assertEquals(3, stages.size());\n    for (int i = 0; i < stages.size(); i++) {\n      Stage stage = stages.get(i);\n      UpgradeItemEntity upgradeItem = group.getItems().get(i);\n      assertEquals(stage.getStageId(), upgradeItem.getStageId().longValue());\n      assertEquals(UpgradeState.NONE, upgradeItem.getState());\n    }\n\n\n    List<HostRoleCommand> tasks = am.getRequestTasks(requests.get(0).longValue());\n    assertEquals(3, tasks.size());\n  }","id":35521,"modified_method":"public org.apache.ambari.server.controller.spi.RequestStatus testCreateResources() throws Exception {\n\n    Cluster cluster = clusters.getCluster(\"c1\");\n\n    List<UpgradeEntity> upgrades = upgradeDao.findUpgrades(cluster.getClusterId());\n    assertEquals(0, upgrades.size());\n\n    Map<String, Object> requestProps = new HashMap<String, Object>();\n    requestProps.put(UpgradeResourceProvider.UPGRADE_CLUSTER_NAME, \"c1\");\n    requestProps.put(UpgradeResourceProvider.UPGRADE_VERSION, \"2.2.2.2\");\n\n    ResourceProvider upgradeResourceProvider = createProvider(amc);\n\n    Request request = PropertyHelper.getCreateRequest(Collections.singleton(requestProps), null);\n    org.apache.ambari.server.controller.spi.RequestStatus status = upgradeResourceProvider.createResources(request);\n\n    upgrades = upgradeDao.findUpgrades(cluster.getClusterId());\n    assertEquals(1, upgrades.size());\n\n    UpgradeEntity entity = upgrades.get(0);\n    assertEquals(cluster.getClusterId(), entity.getClusterId().longValue());\n\n    assertEquals(3, entity.getUpgradeGroups().size());\n\n    UpgradeGroupEntity group = entity.getUpgradeGroups().get(0);\n\n    assertEquals(3, group.getItems().size());\n\n    assertTrue(group.getItems().get(0).getText().contains(\"Preparing\"));\n    assertTrue(group.getItems().get(1).getText().contains(\"Restarting\"));\n    assertTrue(group.getItems().get(2).getText().contains(\"Completing\"));\n\n    ActionManager am = injector.getInstance(ActionManager.class);\n    List<Long> requests = am.getRequestsByStatus(RequestStatus.IN_PROGRESS, 100, true);\n\n    assertEquals(1, requests.size());\n    assertEquals(requests.get(0), entity.getRequestId());\n\n\n    List<Stage> stages = am.getRequestStatus(requests.get(0).longValue());\n    assertEquals(3, stages.size());\n    for (int i = 0; i < stages.size(); i++) {\n      Stage stage = stages.get(i);\n      UpgradeItemEntity upgradeItem = group.getItems().get(i);\n      assertEquals(stage.getStageId(), upgradeItem.getStageId().longValue());\n      assertEquals(UpgradeState.NONE, upgradeItem.getState());\n    }\n\n\n    List<HostRoleCommand> tasks = am.getRequestTasks(requests.get(0).longValue());\n    assertEquals(3, tasks.size());\n\n    return status;\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"@Before\n  public void before() throws Exception {\n\n    injector = Guice.createInjector(new InMemoryDefaultTestModule());\n    injector.getInstance(GuiceJpaInitializer.class);\n\n    upgradeDao = injector.getInstance(UpgradeDAO.class);\n    repoVersionDao = injector.getInstance(RepositoryVersionDAO.class);\n\n    RepositoryVersionEntity repoVersionEntity = new RepositoryVersionEntity();\n    repoVersionEntity.setDisplayName(\"My New Version\");\n    repoVersionEntity.setOperatingSystems(\"\");\n    repoVersionEntity.setStack(\"HDP-2.1.1\");\n    repoVersionEntity.setUpgradePackage(\"upgrade_test\");\n    repoVersionEntity.setVersion(\"2.2.2.2\");\n\n    repoVersionDao.create(repoVersionEntity);\n\n    clusters = injector.getInstance(Clusters.class);\n    clusters.addCluster(\"c1\");\n    Cluster cluster = clusters.getCluster(\"c1\");\n    StackId stackId = new StackId(\"HDP-2.1.1\");\n    cluster.setDesiredStackVersion(stackId);\n    cluster.createClusterVersion(stackId.getStackName(), stackId.getStackVersion(), \"admin\", RepositoryVersionState.CURRENT);\n\n    clusters.addHost(\"h1\");\n    Host host = clusters.getHost(\"h1\");\n    Map<String, String> hostAttributes = new HashMap<String, String>();\n    hostAttributes.put(\"os_family\", \"redhat\");\n    hostAttributes.put(\"os_release_version\", \"6.3\");\n    host.setHostAttributes(hostAttributes);\n    host.persist();\n\n    clusters.mapHostToCluster(\"h1\", \"c1\");\n\n    // add a single ZK server\n    Service service = cluster.addService(\"ZOOKEEPER\");\n    service.setDesiredStackVersion(cluster.getDesiredStackVersion());\n    service.persist();\n\n    ServiceComponent component = service.addServiceComponent(\"ZOOKEEPER_SERVER\");\n    component.addServiceComponentHost(\"h1\");\n\n\n  }","id":35522,"modified_method":"@Before\n  public void before() throws Exception {\n\n    injector = Guice.createInjector(new InMemoryDefaultTestModule());\n    injector.getInstance(GuiceJpaInitializer.class);\n\n\n    amc = injector.getInstance(AmbariManagementController.class);\n//    upgradeResourceProvider = createProvider(amc);\n\n    Field field = AmbariServer.class.getDeclaredField(\"clusterController\");\n    field.setAccessible(true);\n    field.set(null, amc);\n\n    upgradeDao = injector.getInstance(UpgradeDAO.class);\n    repoVersionDao = injector.getInstance(RepositoryVersionDAO.class);\n\n    ViewRegistry.initInstance(new ViewRegistry());\n    System.out.println(AmbariServer.getController());\n\n    RepositoryVersionEntity repoVersionEntity = new RepositoryVersionEntity();\n    repoVersionEntity.setDisplayName(\"My New Version\");\n    repoVersionEntity.setOperatingSystems(\"\");\n    repoVersionEntity.setStack(\"HDP-2.1.1\");\n    repoVersionEntity.setUpgradePackage(\"upgrade_test\");\n    repoVersionEntity.setVersion(\"2.2.2.2\");\n\n    repoVersionDao.create(repoVersionEntity);\n\n    clusters = injector.getInstance(Clusters.class);\n    clusters.addCluster(\"c1\");\n    Cluster cluster = clusters.getCluster(\"c1\");\n    StackId stackId = new StackId(\"HDP-2.1.1\");\n    cluster.setDesiredStackVersion(stackId);\n    cluster.createClusterVersion(stackId.getStackName(), stackId.getStackVersion(), \"admin\", RepositoryVersionState.CURRENT);\n\n    clusters.addHost(\"h1\");\n    Host host = clusters.getHost(\"h1\");\n    Map<String, String> hostAttributes = new HashMap<String, String>();\n    hostAttributes.put(\"os_family\", \"redhat\");\n    hostAttributes.put(\"os_release_version\", \"6.3\");\n    host.setHostAttributes(hostAttributes);\n    host.persist();\n\n    clusters.mapHostToCluster(\"h1\", \"c1\");\n\n    // add a single ZK server\n    Service service = cluster.addService(\"ZOOKEEPER\");\n    service.setDesiredStackVersion(cluster.getDesiredStackVersion());\n    service.persist();\n\n    ServiceComponent component = service.addServiceComponent(\"ZOOKEEPER_SERVER\");\n    component.addServiceComponentHost(\"h1\");\n\n\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * @param upgradeId the upgrade id\n   * @return the resource instance\n   */\n  private ResourceInstance createResourceInstance(Long upgradeId) {\n    Map<Resource.Type, String> mapIds = new HashMap<Resource.Type, String>();\n    mapIds.put(Resource.Type.Cluster, m_clusterName);\n\n    if (null != upgradeId) {\n      mapIds.put(Resource.Type.Upgrade, upgradeId.toString());\n    }\n\n    return createResource(Resource.Type.Upgrade, mapIds);\n  }","id":35523,"modified_method":"/**\n   * @param upgradeId the upgrade id\n   * @return the resource instance\n   */\n  private ResourceInstance createResourceInstance(Long upgradeId) {\n    Map<Resource.Type, String> mapIds = new HashMap<Resource.Type, String>();\n    mapIds.put(Resource.Type.Cluster, m_clusterName);\n\n    if (null != upgradeId) {\n      mapIds.put(Resource.Type.Upgrade, upgradeId.toString());\n      mapIds.put(Resource.Type.Request, upgradeId.toString());\n    }\n\n    return createResource(Resource.Type.Upgrade, mapIds);\n  }","commit_id":"e7c512c2c45256ef7cb5a26bc1b7282be0574c20","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  protected RequestStatus createResourcesAuthorized(final Request request)\n      throws SystemException,\n      UnsupportedPropertyException, ResourceAlreadyExistsException,\n      NoSuchParentResourceException {\n\n    Set<Map<String, Object>> requestProperties = request.getProperties();\n\n    if (requestProperties.size() > 1) {\n      throw new IllegalArgumentException(\"Cannot process more than one file per request\");\n    }\n\n    final Map<String, Object> properties = requestProperties.iterator().next();\n\n    if (!properties.containsKey(VERSION_DEF_DEFINITION_URL) &&\n        !properties.containsKey(VERSION_DEF_DEFINITION_BASE64) &&\n        !properties.containsKey(VERSION_DEF_AVAILABLE_DEFINITION)) {\n      throw new IllegalArgumentException(String.format(\"Creation method is not known.  %s or %s is required or upload the file directly\",\n          VERSION_DEF_DEFINITION_URL, VERSION_DEF_AVAILABLE_DEFINITION));\n    }\n\n    if (properties.containsKey(VERSION_DEF_DEFINITION_URL) && properties.containsKey(VERSION_DEF_DEFINITION_BASE64)) {\n      throw new IllegalArgumentException(String.format(\"Specify ONLY the url with %s or upload the file directly\",\n          VERSION_DEF_DEFINITION_URL));\n    }\n\n    RepositoryVersionEntity entity = createResources(new Command<RepositoryVersionEntity>() {\n      @Override\n      public RepositoryVersionEntity invoke() throws AmbariException {\n\n        String definitionUrl = (String) properties.get(VERSION_DEF_DEFINITION_URL);\n        String definitionBase64 = (String) properties.get(VERSION_DEF_DEFINITION_BASE64);\n        String definitionName = (String) properties.get(VERSION_DEF_AVAILABLE_DEFINITION);\n\n        XmlHolder holder = null;\n        if (null != definitionUrl) {\n          holder = loadXml(definitionUrl);\n        } else if (null != definitionBase64) {\n          holder = loadXml(Base64.decodeBase64(definitionBase64));\n        } else if (null != definitionName) {\n          VersionDefinitionXml xml = s_metaInfo.get().getVersionDefinition(definitionName);\n          if (null == xml) {\n            throw new AmbariException(String.format(\"Version %s not found\", definitionName));\n          }\n\n          holder = new XmlHolder();\n          holder.xml = xml;\n          try {\n            holder.xmlString = xml.toXml();\n          } catch (Exception e) {\n            throw new AmbariException(String.format(\"The available repository %s does not serialize\", definitionName));\n          }\n\n        } else {\n          throw new AmbariException(\"Cannot determine creation method\");\n        }\n\n\n        RepositoryVersionEntity entity = toRepositoryVersionEntity(holder);\n\n        RepositoryVersionResourceProvider.validateRepositoryVersion(s_repoVersionDAO,\n            s_metaInfo.get(), entity);\n\n        checkForParent(holder, entity);\n\n        s_repoVersionDAO.create(entity);\n\n        return entity;\n      }\n    });\n\n    notifyCreate(Resource.Type.VersionDefinition, request);\n\n    RequestStatusImpl status = new RequestStatusImpl(null,\n        Collections.singleton(toResource(entity, Collections.<String>emptySet())));\n\n    return status;\n  }","id":35524,"modified_method":"@Override\n  protected RequestStatus createResourcesAuthorized(final Request request)\n      throws SystemException,\n      UnsupportedPropertyException, ResourceAlreadyExistsException,\n      NoSuchParentResourceException {\n\n    Set<Map<String, Object>> requestProperties = request.getProperties();\n\n    if (requestProperties.size() > 1) {\n      throw new IllegalArgumentException(\"Cannot process more than one file per request\");\n    }\n\n    final Map<String, Object> properties = requestProperties.iterator().next();\n\n    if (!properties.containsKey(VERSION_DEF_DEFINITION_URL) &&\n        !properties.containsKey(VERSION_DEF_DEFINITION_BASE64) &&\n        !properties.containsKey(VERSION_DEF_AVAILABLE_DEFINITION)) {\n      throw new IllegalArgumentException(String.format(\"Creation method is not known.  %s or %s is required or upload the file directly\",\n          VERSION_DEF_DEFINITION_URL, VERSION_DEF_AVAILABLE_DEFINITION));\n    }\n\n    if (properties.containsKey(VERSION_DEF_DEFINITION_URL) && properties.containsKey(VERSION_DEF_DEFINITION_BASE64)) {\n      throw new IllegalArgumentException(String.format(\"Specify ONLY the url with %s or upload the file directly\",\n          VERSION_DEF_DEFINITION_URL));\n    }\n\n    Map<String, String> requestInfo = request.getRequestInfoProperties();\n\n    final boolean dryRun;\n    if (requestInfo.containsKey(DIRECTIVE_DRY_RUN)) {\n      dryRun = Boolean.parseBoolean(requestInfo.get(DIRECTIVE_DRY_RUN));\n    } else {\n      dryRun = false;\n    }\n\n    XmlHolder xmlHolder = createResources(new Command<XmlHolder>() {\n      @Override\n      public XmlHolder invoke() throws AmbariException {\n\n        String definitionUrl = (String) properties.get(VERSION_DEF_DEFINITION_URL);\n        String definitionBase64 = (String) properties.get(VERSION_DEF_DEFINITION_BASE64);\n        String definitionName = (String) properties.get(VERSION_DEF_AVAILABLE_DEFINITION);\n\n        XmlHolder holder = null;\n        if (null != definitionUrl) {\n          holder = loadXml(definitionUrl);\n        } else if (null != definitionBase64) {\n          holder = loadXml(Base64.decodeBase64(definitionBase64));\n        } else if (null != definitionName) {\n          VersionDefinitionXml xml = s_metaInfo.get().getVersionDefinition(definitionName);\n          if (null == xml) {\n            throw new AmbariException(String.format(\"Version %s not found\", definitionName));\n          }\n\n          holder = new XmlHolder();\n          holder.xml = xml;\n          try {\n            holder.xmlString = xml.toXml();\n          } catch (Exception e) {\n            throw new AmbariException(String.format(\"The available repository %s does not serialize\", definitionName));\n          }\n\n        } else {\n          throw new AmbariException(\"Cannot determine creation method\");\n        }\n\n        toRepositoryVersionEntity(holder);\n\n        if (!dryRun) {\n          RepositoryVersionResourceProvider.validateRepositoryVersion(s_repoVersionDAO,\n              s_metaInfo.get(), holder.entity);\n        }\n\n        checkForParent(holder);\n\n        if (!dryRun) {\n          s_repoVersionDAO.create(holder.entity);\n        }\n\n        return holder;\n      }\n    });\n\n    final Resource res;\n\n    if (dryRun) {\n      // !!! dry runs imply that the whole entity should be provided.  this is usually\n      // done via sub-resources, but that model breaks down since we don't have a saved\n      // entity yet\n      Set<String> ids = Sets.newHashSet(\n        VERSION_DEF_TYPE_PROPERTY_ID,\n        VERSION_DEF_FULL_VERSION,\n        VERSION_DEF_RELEASE_BUILD,\n        VERSION_DEF_RELEASE_COMPATIBLE_WITH,\n        VERSION_DEF_RELEASE_NOTES,\n        VERSION_DEF_RELEASE_VERSION,\n        VERSION_DEF_AVAILABLE_SERVICES,\n        VERSION_DEF_STACK_SERVICES);\n\n      res = toResource(null, xmlHolder.xml, ids, false);\n\n      addSubresources(res, xmlHolder.entity);\n    } else {\n      res = toResource(xmlHolder.entity, Collections.<String>emptySet());\n      notifyCreate(Resource.Type.VersionDefinition, request);\n    }\n\n    RequestStatusImpl status = new RequestStatusImpl(null,\n        Collections.singleton(res));\n\n    return status;\n  }","commit_id":"81279faedf80ffc6841408f5a2ae2c5f83e6c8f6","url":"https://github.com/apache/ambari"},{"original_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate)\n      throws SystemException, UnsupportedPropertyException,\n      NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> results = new HashSet<Resource>();\n    Set<String> requestPropertyIds = getRequestPropertyIds(request, predicate);\n\n    Set<Map<String, Object>> propertyMaps = getPropertyMaps(predicate);\n\n    if (propertyMaps.isEmpty()) {\n      List<RepositoryVersionEntity> versions = s_repoVersionDAO.findAllDefinitions();\n\n      for (RepositoryVersionEntity entity : versions) {\n        results.add(toResource(entity, requestPropertyIds));\n      }\n    } else {\n      for (Map<String, Object> propertyMap : propertyMaps) {\n\n        if (propertyMap.containsKey(SHOW_AVAILABLE) &&\n            Boolean.parseBoolean(propertyMap.get(SHOW_AVAILABLE).toString())) {\n\n          for (Entry<String, VersionDefinitionXml> entry : s_metaInfo.get().getVersionDefinitions().entrySet()) {\n            results.add(toResource(entry.getKey(), entry.getValue(), requestPropertyIds));\n          }\n\n        } else {\n          String id = (String) propertyMap.get(VERSION_DEF_ID);\n\n          if (null != id) {\n            if (NumberUtils.isDigits(id)) {\n\n              RepositoryVersionEntity entity = s_repoVersionDAO.findByPK(Long.parseLong(id));\n              if (null != entity) {\n                results.add(toResource(entity, requestPropertyIds));\n              }\n            } else {\n              VersionDefinitionXml xml = s_metaInfo.get().getVersionDefinition(id);\n\n              if (null == xml) {\n                throw new NoSuchResourceException(String.format(\"Could not find version %s\",\n                    id));\n              }\n              results.add(toResource(id, xml, requestPropertyIds));\n\n            }\n          } else {\n            List<RepositoryVersionEntity> versions = s_repoVersionDAO.findAllDefinitions();\n\n            for (RepositoryVersionEntity entity : versions) {\n              results.add(toResource(entity, requestPropertyIds));\n            }\n          }\n\n        }\n      }\n    }\n    return results;\n  }","id":35525,"modified_method":"@Override\n  public Set<Resource> getResources(Request request, Predicate predicate)\n      throws SystemException, UnsupportedPropertyException,\n      NoSuchResourceException, NoSuchParentResourceException {\n\n    Set<Resource> results = new HashSet<Resource>();\n    Set<String> requestPropertyIds = getRequestPropertyIds(request, predicate);\n\n    Set<Map<String, Object>> propertyMaps = getPropertyMaps(predicate);\n\n    if (propertyMaps.isEmpty()) {\n      List<RepositoryVersionEntity> versions = s_repoVersionDAO.findAllDefinitions();\n\n      for (RepositoryVersionEntity entity : versions) {\n        results.add(toResource(entity, requestPropertyIds));\n      }\n    } else {\n      for (Map<String, Object> propertyMap : propertyMaps) {\n\n        if (propertyMap.containsKey(SHOW_AVAILABLE) &&\n            Boolean.parseBoolean(propertyMap.get(SHOW_AVAILABLE).toString())) {\n\n          for (Entry<String, VersionDefinitionXml> entry : s_metaInfo.get().getVersionDefinitions().entrySet()) {\n            results.add(toResource(entry.getKey(), entry.getValue(), requestPropertyIds, true));\n          }\n\n        } else {\n          String id = (String) propertyMap.get(VERSION_DEF_ID);\n\n          if (null != id) {\n            if (NumberUtils.isDigits(id)) {\n\n              RepositoryVersionEntity entity = s_repoVersionDAO.findByPK(Long.parseLong(id));\n              if (null != entity) {\n                results.add(toResource(entity, requestPropertyIds));\n              }\n            } else {\n              VersionDefinitionXml xml = s_metaInfo.get().getVersionDefinition(id);\n\n              if (null == xml) {\n                throw new NoSuchResourceException(String.format(\"Could not find version %s\",\n                    id));\n              }\n              results.add(toResource(id, xml, requestPropertyIds, true));\n\n            }\n          } else {\n            List<RepositoryVersionEntity> versions = s_repoVersionDAO.findAllDefinitions();\n\n            for (RepositoryVersionEntity entity : versions) {\n              results.add(toResource(entity, requestPropertyIds));\n            }\n          }\n\n        }\n      }\n    }\n    return results;\n  }","commit_id":"81279faedf80ffc6841408f5a2ae2c5f83e6c8f6","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * In the case of a patch, check if there is a parent repo.\n   * @param entity the entity to check\n   */\n  private void checkForParent(XmlHolder holder, RepositoryVersionEntity entity) throws AmbariException {\n    if (entity.getType() != RepositoryType.PATCH) {\n      return;\n    }\n\n    List<RepositoryVersionEntity> entities = s_repoVersionDAO.findByStack(entity.getStackId());\n    if (entities.isEmpty()) {\n      throw new IllegalArgumentException(String.format(\"Patch %s was uploaded, but there are no repositories for %s\",\n          entity.getVersion(), entity.getStackId().toString()));\n    }\n\n    List<RepositoryVersionEntity> matching = new ArrayList<>();\n\n    boolean emptyCompatible = StringUtils.isBlank(holder.xml.release.compatibleWith);\n\n    for (RepositoryVersionEntity candidate : entities) {\n      String baseVersion = candidate.getVersion();\n      if (baseVersion.lastIndexOf('-') > -1) {\n        baseVersion = baseVersion.substring(0,  baseVersion.lastIndexOf('-'));\n      }\n\n      if (emptyCompatible) {\n        if (baseVersion.equals(holder.xml.release.version)) {\n          matching.add(candidate);\n        }\n      } else {\n        if (baseVersion.matches(holder.xml.release.compatibleWith)) {\n          matching.add(candidate);\n        }\n      }\n    }\n\n    if (matching.isEmpty()) {\n      String format = \"No versions matched pattern %s\";\n\n      throw new IllegalArgumentException(String.format(format,\n          emptyCompatible ? holder.xml.release.version : holder.xml.release.compatibleWith));\n    } else if (matching.size() > 1) {\n      Set<String> versions= new HashSet<>();\n      for (RepositoryVersionEntity match : matching) {\n        versions.add(match.getVersion());\n      }\n\n      throw new IllegalArgumentException(String.format(\"More than one repository matches patch %s: %s\",\n          entity.getVersion(), StringUtils.join(versions, \", \")));\n    }\n\n    RepositoryVersionEntity parent = matching.get(0);\n\n    entity.setParent(parent);\n  }","id":35526,"modified_method":"/**\n   * In the case of a patch, check if there is a parent repo.\n   * @param entity the entity to check\n   */\n  private void checkForParent(XmlHolder holder) throws AmbariException {\n    RepositoryVersionEntity entity = holder.entity;\n    if (entity.getType() != RepositoryType.PATCH) {\n      return;\n    }\n\n    List<RepositoryVersionEntity> entities = s_repoVersionDAO.findByStack(entity.getStackId());\n    if (entities.isEmpty()) {\n      throw new IllegalArgumentException(String.format(\"Patch %s was uploaded, but there are no repositories for %s\",\n          entity.getVersion(), entity.getStackId().toString()));\n    }\n\n    List<RepositoryVersionEntity> matching = new ArrayList<>();\n\n    boolean emptyCompatible = StringUtils.isBlank(holder.xml.release.compatibleWith);\n\n    for (RepositoryVersionEntity candidate : entities) {\n      String baseVersion = candidate.getVersion();\n      if (baseVersion.lastIndexOf('-') > -1) {\n        baseVersion = baseVersion.substring(0,  baseVersion.lastIndexOf('-'));\n      }\n\n      if (emptyCompatible) {\n        if (baseVersion.equals(holder.xml.release.version)) {\n          matching.add(candidate);\n        }\n      } else {\n        if (baseVersion.matches(holder.xml.release.compatibleWith)) {\n          matching.add(candidate);\n        }\n      }\n    }\n\n    if (matching.isEmpty()) {\n      String format = \"No versions matched pattern %s\";\n\n      throw new IllegalArgumentException(String.format(format,\n          emptyCompatible ? holder.xml.release.version : holder.xml.release.compatibleWith));\n    } else if (matching.size() > 1) {\n      Set<String> versions= new HashSet<>();\n      for (RepositoryVersionEntity match : matching) {\n        versions.add(match.getVersion());\n      }\n\n      throw new IllegalArgumentException(String.format(\"More than one repository matches patch %s: %s\",\n          entity.getVersion(), StringUtils.join(versions, \", \")));\n    }\n\n    RepositoryVersionEntity parent = matching.get(0);\n\n    entity.setParent(parent);\n  }","commit_id":"81279faedf80ffc6841408f5a2ae2c5f83e6c8f6","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Transforms a XML version defintion to an entity\n   *\n   * @param definitionUrl the String URL for loading\n   * @return constructed entity\n   * @throws AmbariException if some properties are missing or json has incorrect structure\n   */\n  protected RepositoryVersionEntity toRepositoryVersionEntity(XmlHolder holder) throws AmbariException {\n\n    // !!! TODO validate parsed object graph\n\n    RepositoryVersionEntity entity = new RepositoryVersionEntity();\n\n    StackId stackId = new StackId(holder.xml.release.stackId);\n\n    StackEntity stackEntity = s_stackDAO.find(stackId.getStackName(), stackId.getStackVersion());\n\n    entity.setStack(stackEntity);\n    entity.setOperatingSystems(s_repoVersionHelper.get().serializeOperatingSystems(\n        holder.xml.repositoryInfo.getRepositories()));\n    entity.setVersion(holder.xml.release.getFullVersion());\n    entity.setDisplayName(stackId, holder.xml.release);\n    entity.setType(holder.xml.release.repositoryType);\n    entity.setVersionUrl(holder.url);\n    entity.setVersionXml(holder.xmlString);\n    entity.setVersionXsd(holder.xml.xsdLocation);\n\n    return entity;\n  }","id":35527,"modified_method":"/**\n   * Transforms a XML version defintion to an entity\n   *\n   * @param definitionUrl the String URL for loading\n   * @return constructed entity\n   * @throws AmbariException if some properties are missing or json has incorrect structure\n   */\n  protected void toRepositoryVersionEntity(XmlHolder holder) throws AmbariException {\n\n    // !!! TODO validate parsed object graph\n\n    RepositoryVersionEntity entity = new RepositoryVersionEntity();\n\n    StackId stackId = new StackId(holder.xml.release.stackId);\n\n    StackEntity stackEntity = s_stackDAO.find(stackId.getStackName(), stackId.getStackVersion());\n\n    entity.setStack(stackEntity);\n    entity.setOperatingSystems(s_repoVersionHelper.get().serializeOperatingSystems(\n        holder.xml.repositoryInfo.getRepositories()));\n    entity.setVersion(holder.xml.release.getFullVersion());\n    entity.setDisplayName(stackId, holder.xml.release);\n    entity.setType(holder.xml.release.repositoryType);\n    entity.setVersionUrl(holder.url);\n    entity.setVersionXml(holder.xmlString);\n    entity.setVersionXsd(holder.xml.xsdLocation);\n\n    holder.entity = entity;\n  }","commit_id":"81279faedf80ffc6841408f5a2ae2c5f83e6c8f6","url":"https://github.com/apache/ambari"},{"original_method":"private Resource toResource(String id, VersionDefinitionXml xml, Set<String> requestedIds) throws SystemException {\n\n    Resource resource = new ResourceImpl(Resource.Type.VersionDefinition);\n    resource.setProperty(VERSION_DEF_ID, id);\n    resource.setProperty(SHOW_AVAILABLE, Boolean.TRUE);\n    StackId stackId = new StackId(xml.release.stackId);\n\n    // !!! these are needed for href\n    resource.setProperty(VERSION_DEF_STACK_NAME, stackId.getStackName());\n    resource.setProperty(VERSION_DEF_STACK_VERSION, stackId.getStackVersion());\n\n    StackInfo stack = null;\n    try {\n      stack = s_metaInfo.get().getStack(stackId.getStackName(), stackId.getStackVersion());\n    } catch (AmbariException e) {\n      throw new SystemException(String.format(\"Could not load stack %s\", stackId));\n    }\n\n    setResourceProperty(resource, VERSION_DEF_TYPE_PROPERTY_ID, xml.release.repositoryType, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_FULL_VERSION, xml.release.version, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_RELEASE_BUILD, xml.release.build, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_RELEASE_COMPATIBLE_WITH, xml.release.compatibleWith, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_RELEASE_NOTES, xml.release.releaseNotes, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_RELEASE_VERSION, xml.release.version, requestedIds);\n\n    setResourceProperty(resource, VERSION_DEF_AVAILABLE_SERVICES, xml.getAvailableServices(stack), requestedIds);\n    setResourceProperty(resource, VERSION_DEF_STACK_SERVICES, xml.getStackServices(stack), requestedIds);\n\n    return resource;\n\n  }","id":35528,"modified_method":"private Resource toResource(String id, VersionDefinitionXml xml, Set<String> requestedIds, boolean fromAvailable) throws SystemException {\n\n    Resource resource = new ResourceImpl(Resource.Type.VersionDefinition);\n    resource.setProperty(VERSION_DEF_ID, id);\n    if (fromAvailable) {\n      resource.setProperty(SHOW_AVAILABLE, Boolean.TRUE);\n    }\n\n    StackId stackId = new StackId(xml.release.stackId);\n\n    // !!! these are needed for href\n    resource.setProperty(VERSION_DEF_STACK_NAME, stackId.getStackName());\n    resource.setProperty(VERSION_DEF_STACK_VERSION, stackId.getStackVersion());\n\n    StackInfo stack = null;\n    try {\n      stack = s_metaInfo.get().getStack(stackId.getStackName(), stackId.getStackVersion());\n    } catch (AmbariException e) {\n      throw new SystemException(String.format(\"Could not load stack %s\", stackId));\n    }\n\n    setResourceProperty(resource, VERSION_DEF_TYPE_PROPERTY_ID, xml.release.repositoryType, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_FULL_VERSION, xml.release.version, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_RELEASE_BUILD, xml.release.build, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_RELEASE_COMPATIBLE_WITH, xml.release.compatibleWith, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_RELEASE_NOTES, xml.release.releaseNotes, requestedIds);\n    setResourceProperty(resource, VERSION_DEF_RELEASE_VERSION, xml.release.version, requestedIds);\n\n    setResourceProperty(resource, VERSION_DEF_AVAILABLE_SERVICES, xml.getAvailableServices(stack), requestedIds);\n    setResourceProperty(resource, VERSION_DEF_STACK_SERVICES, xml.getStackServices(stack), requestedIds);\n\n    return resource;\n  }","commit_id":"81279faedf80ffc6841408f5a2ae2c5f83e6c8f6","url":"https://github.com/apache/ambari"},{"original_method":"/**\n   * Tries to find visual column that points to the first non-white space symbol at the visual line at the given editor.\n   *\n   * @param editor              target editor\n   * @param visualLineNumber    target visual line\n   * @return                    visual column that points to the first non-white space symbol at the target visual line if the one exists;\n   *                            <code>'-1'<\/code> otherwise\n   */\n  public static int findFirstNonSpaceColumnOnTheLine(@NotNull Editor editor, int visualLineNumber) {\n    Document document = editor.getDocument();\n    VisualPosition visLine = new VisualPosition(visualLineNumber, 0);\n    int logLine = editor.visualToLogicalPosition(visLine).line;\n    int logLineStartOffset = document.getLineStartOffset(logLine);\n    int logLineEndOffset = document.getLineEndOffset(logLine);\n    LogicalPosition logLineStart = editor.offsetToLogicalPosition(logLineStartOffset);\n    VisualPosition visLineStart = editor.logicalToVisualPosition(logLineStart);\n\n    boolean softWrapIntroducedLine = visLineStart.line != visualLineNumber;\n    if (!softWrapIntroducedLine) {\n      int offset = findFirstNonSpaceOffsetInRange(document.getCharsSequence(), logLineStartOffset, logLineEndOffset);\n      if (offset >= 0) {\n        return EditorUtil.calcColumnNumber(editor, document.getCharsSequence(), logLineStartOffset, offset);\n      }\n      else {\n        return -1;\n      }\n    }\n\n    int lineFeedsToSkip = visualLineNumber - visLineStart.line;\n    List<? extends SoftWrap> softWraps = editor.getSoftWrapModel().getSoftWrapsForLine(logLine);\n    for (SoftWrap softWrap : softWraps) {\n      CharSequence softWrapText = softWrap.getText();\n      int softWrapLineFeedsNumber = StringUtil.countNewLines(softWrapText);\n\n      if (softWrapLineFeedsNumber < lineFeedsToSkip) {\n        lineFeedsToSkip -= softWrapLineFeedsNumber;\n        continue;\n      }\n\n      // Point to the first non-white space symbol at the target soft wrap visual line or to the first non-white space symbol\n      // of document line that follows it if possible.\n      int softWrapTextLength = softWrapText.length();\n      boolean skip = true;\n      for (int j = 0; j < softWrapTextLength; j++) {\n        if (softWrapText.charAt(j) == '\\n') {\n          skip = --lineFeedsToSkip > 0;\n          continue;\n        }\n        if (skip) {\n          continue;\n        }\n\n        int nextSoftWrapLineFeedOffset = StringUtil.indexOf(softWrapText, '\\n', j, softWrapTextLength);\n\n        int end = findFirstNonSpaceOffsetInRange(softWrapText, j, softWrapTextLength);\n        if (end >= 0) {\n          // Non space symbol is contained at soft wrap text after offset that corresponds to the target visual line start.\n          if (nextSoftWrapLineFeedOffset < 0 || end < nextSoftWrapLineFeedOffset) {\n            return EditorUtil.calcColumnNumber(editor, softWrapText, j, end);\n          }\n          else {\n            return -1;\n          }\n        }\n\n        if (nextSoftWrapLineFeedOffset >= 0) {\n          // There are soft wrap-introduced visual lines after the target one\n          return -1;\n        }\n      }\n      int end = findFirstNonSpaceOffsetInRange(document.getCharsSequence(), softWrap.getStart(), logLineEndOffset);\n      if (end >= 0) {\n        return EditorUtil.calcColumnNumber(editor, document.getCharsSequence(), softWrap.getStart(), end);\n      }\n      else {\n        return -1;\n      }\n    }\n    return -1;\n  }","id":35529,"modified_method":"/**\n   * Tries to find visual column that points to the first non-white space symbol at the visual line at the given editor.\n   *\n   * @param editor              target editor\n   * @param visualLineNumber    target visual line\n   * @return                    visual column that points to the first non-white space symbol at the target visual line if the one exists;\n   *                            <code>'-1'<\/code> otherwise\n   */\n  public static int findFirstNonSpaceColumnOnTheLine(@NotNull Editor editor, int visualLineNumber) {\n    Document document = editor.getDocument();\n    VisualPosition visLine = new VisualPosition(visualLineNumber, 0);\n    int logLine = editor.visualToLogicalPosition(visLine).line;\n    int logLineStartOffset = document.getLineStartOffset(logLine);\n    int logLineEndOffset = document.getLineEndOffset(logLine);\n    LogicalPosition logLineStart = editor.offsetToLogicalPosition(logLineStartOffset);\n    VisualPosition visLineStart = editor.logicalToVisualPosition(logLineStart);\n    boolean newRendering = editor instanceof EditorImpl && ((EditorImpl)editor).myUseNewRendering;\n\n    boolean softWrapIntroducedLine = visLineStart.line != visualLineNumber;\n    if (!softWrapIntroducedLine) {\n      int offset = findFirstNonSpaceOffsetInRange(document.getCharsSequence(), logLineStartOffset, logLineEndOffset);\n      if (offset >= 0) {\n        return newRendering ? editor.offsetToVisualPosition(offset).column : \n               EditorUtil.calcColumnNumber(editor, document.getCharsSequence(), logLineStartOffset, offset);\n      }\n      else {\n        return -1;\n      }\n    }\n\n    int lineFeedsToSkip = visualLineNumber - visLineStart.line;\n    List<? extends SoftWrap> softWraps = editor.getSoftWrapModel().getSoftWrapsForLine(logLine);\n    for (SoftWrap softWrap : softWraps) {\n      CharSequence softWrapText = softWrap.getText();\n      int softWrapLineFeedsNumber = StringUtil.countNewLines(softWrapText);\n\n      if (softWrapLineFeedsNumber < lineFeedsToSkip) {\n        lineFeedsToSkip -= softWrapLineFeedsNumber;\n        continue;\n      }\n\n      // Point to the first non-white space symbol at the target soft wrap visual line or to the first non-white space symbol\n      // of document line that follows it if possible.\n      int softWrapTextLength = softWrapText.length();\n      boolean skip = true;\n      for (int j = 0; j < softWrapTextLength; j++) {\n        if (softWrapText.charAt(j) == '\\n') {\n          skip = --lineFeedsToSkip > 0;\n          continue;\n        }\n        if (skip) {\n          continue;\n        }\n\n        int nextSoftWrapLineFeedOffset = StringUtil.indexOf(softWrapText, '\\n', j, softWrapTextLength);\n\n        int end = findFirstNonSpaceOffsetInRange(softWrapText, j, softWrapTextLength);\n        if (end >= 0) {\n          assert !newRendering : \"Unexpected soft wrap text\";\n          // Non space symbol is contained at soft wrap text after offset that corresponds to the target visual line start.\n          if (nextSoftWrapLineFeedOffset < 0 || end < nextSoftWrapLineFeedOffset) {\n            return EditorUtil.calcColumnNumber(editor, softWrapText, j, end);\n          }\n          else {\n            return -1;\n          }\n        }\n\n        if (nextSoftWrapLineFeedOffset >= 0) {\n          // There are soft wrap-introduced visual lines after the target one\n          return -1;\n        }\n      }\n      int end = findFirstNonSpaceOffsetInRange(document.getCharsSequence(), softWrap.getStart(), logLineEndOffset);\n      if (end >= 0) {\n        return newRendering ? editor.offsetToVisualPosition(end).column : \n               EditorUtil.calcColumnNumber(editor, document.getCharsSequence(), softWrap.getStart(), end);\n      }\n      else {\n        return -1;\n      }\n    }\n    return -1;\n  }","commit_id":"a6bf2c11ed2d4be70d6b3033a884fb30b945099e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int shiftForward(@NotNull CharSequence buffer, int offset, @NotNull String chars) {\n    while (true) {\n      if (offset >= buffer.length()) break;\n      char c = buffer.charAt(offset);\n      int i;      \n      for (i = 0; i < chars.length(); i++) {\n        if (c == chars.charAt(i)) break;\n      }\n      if (i == chars.length()) break;\n      offset++;\n    }\n    return offset;\n  }","id":35530,"modified_method":"public static int shiftForward(@NotNull CharSequence buffer, int offset, @NotNull String chars) {\n    return shiftForward(buffer, offset, buffer.length(), chars);\n  }","commit_id":"de7131e6a81ca66067ef3ab211fbbd521b13977a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isBlankLine(int line, CharSequence chars) {\n    Document document = myDocument;\n    if (document == null) {\n      return true;\n    }\n    int startOffset = document.getLineStartOffset(line);\n    return CharArrayUtil.shiftForward(chars, startOffset, \" \\t\") >= myDocument.getLineEndOffset(line);\n  }","id":35531,"modified_method":"private boolean isBlankLine(int line, CharSequence chars) {\n    Document document = myDocument;\n    if (document == null) {\n      return true;\n    }\n    int startOffset = document.getLineStartOffset(line);\n    int endOffset = document.getLineEndOffset(line);\n    return CharArrayUtil.shiftForward(chars, startOffset, endOffset, \" \\t\") >= myDocument.getLineEndOffset(line);\n  }","commit_id":"de7131e6a81ca66067ef3ab211fbbd521b13977a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * We want to treat comments specially in a way to skip comment prefix on line indent calculation.\n   * <p/>\n   * Example:\n   * <pre>\n   *   it (true) {\n   *     int i1;\n   * //    int i2;\n   *     int i3;\n   *   }\n   * <\/pre>\n   * We want to use 'int i2;' start offset as the third line indent (though it has non-white space comment prefix (//)\n   * at the first column.\n   * <p/>\n   * This method tries to parse comment prefix for the language implied by the given comment type. It uses\n   * {@link #NO_COMMENT_INFO_MARKER} as an indicator that that information is unavailable\n   * \n   * @param commentType  target comment type\n   * @return             prefix of the comment denoted by the given type if any;\n   *                     {@link #NO_COMMENT_INFO_MARKER} otherwise\n   */\n  @NotNull\n  private static String parseComments(@NotNull IElementType commentType) {\n    Commenter c = LanguageCommenters.INSTANCE.forLanguage(commentType.getLanguage());\n    if (!(c instanceof CodeDocumentationAwareCommenter)) {\n      COMMENT_PREFIXES.put(commentType, NO_COMMENT_INFO_MARKER);\n      return NO_COMMENT_INFO_MARKER;\n    }\n    CodeDocumentationAwareCommenter commenter = (CodeDocumentationAwareCommenter)c;\n    \n    IElementType lineCommentType = commenter.getLineCommentTokenType();\n    String lineCommentPrefix = commenter.getLineCommentPrefix();\n    if (lineCommentType != null) {\n      COMMENT_PREFIXES.put(lineCommentType, lineCommentPrefix == null ? NO_COMMENT_INFO_MARKER : lineCommentPrefix);\n    }\n\n    IElementType blockCommentType = commenter.getBlockCommentTokenType();\n    String blockCommentPrefix = commenter.getBlockCommentPrefix();\n    if (blockCommentType != null) {\n      COMMENT_PREFIXES.put(blockCommentType, blockCommentPrefix == null ? NO_COMMENT_INFO_MARKER : blockCommentPrefix);\n    }\n\n    IElementType docCommentType = commenter.getDocumentationCommentTokenType();\n    String docCommentPrefix = commenter.getDocumentationCommentPrefix();\n    if (docCommentType != null) {\n      COMMENT_PREFIXES.put(docCommentType, docCommentPrefix == null ? NO_COMMENT_INFO_MARKER : docCommentPrefix);\n    }\n\n    COMMENT_PREFIXES.putIfAbsent(commentType, NO_COMMENT_INFO_MARKER);\n    return COMMENT_PREFIXES.get(commentType);\n  }","id":35532,"modified_method":"/**\n   * We want to treat comments specially in a way to skip comment prefix on line indent calculation.\n   * <p/>\n   * Example:\n   * <pre>\n   *   if (true) {\n   *     int i1;\n   * //    int i2;\n   *     int i3;\n   *   }\n   * <\/pre>\n   * We want to use 'int i2;' start offset as the third line indent (though it has non-white space comment prefix (//)\n   * at the first column.\n   * <p/>\n   * This method tries to parse comment prefix for the language implied by the given comment type. It uses\n   * {@link #NO_COMMENT_INFO_MARKER} as an indicator that that information is unavailable\n   * \n   * @param commentType  target comment type\n   * @return             prefix of the comment denoted by the given type if any;\n   *                     {@link #NO_COMMENT_INFO_MARKER} otherwise\n   */\n  @NotNull\n  private static String getCommentPrefix(@NotNull IElementType commentType) {\n    Commenter c = LanguageCommenters.INSTANCE.forLanguage(commentType.getLanguage());\n    if (!(c instanceof CodeDocumentationAwareCommenter)) {\n      COMMENT_PREFIXES.put(commentType, NO_COMMENT_INFO_MARKER);\n      return NO_COMMENT_INFO_MARKER;\n    }\n    CodeDocumentationAwareCommenter commenter = (CodeDocumentationAwareCommenter)c;\n    \n    IElementType lineCommentType = commenter.getLineCommentTokenType();\n    String lineCommentPrefix = commenter.getLineCommentPrefix();\n    if (lineCommentType != null) {\n      COMMENT_PREFIXES.put(lineCommentType, lineCommentPrefix == null ? NO_COMMENT_INFO_MARKER : lineCommentPrefix);\n    }\n\n    IElementType blockCommentType = commenter.getBlockCommentTokenType();\n    String blockCommentPrefix = commenter.getBlockCommentPrefix();\n    if (blockCommentType != null) {\n      COMMENT_PREFIXES.put(blockCommentType, blockCommentPrefix == null ? NO_COMMENT_INFO_MARKER : blockCommentPrefix);\n    }\n\n    IElementType docCommentType = commenter.getDocumentationCommentTokenType();\n    String docCommentPrefix = commenter.getDocumentationCommentPrefix();\n    if (docCommentType != null) {\n      COMMENT_PREFIXES.put(docCommentType, docCommentPrefix == null ? NO_COMMENT_INFO_MARKER : docCommentPrefix);\n    }\n\n    COMMENT_PREFIXES.putIfAbsent(commentType, NO_COMMENT_INFO_MARKER);\n    return COMMENT_PREFIXES.get(commentType);\n  }","commit_id":"de7131e6a81ca66067ef3ab211fbbd521b13977a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<IndentGuideDescriptor> buildDescriptors() {\n    if (!myEditor.getSettings().isIndentGuidesShown()) return Collections.emptyList();\n\n    int[] lineIndents = calcIndents();\n\n    List<IndentGuideDescriptor> descriptors = new ArrayList<IndentGuideDescriptor>();\n\n    IntStack lines = new IntStack();\n    IntStack indents = new IntStack();\n\n    lines.push(0);\n    indents.push(0);\n    assert myDocument != null;\n    final CharSequence chars = myDocument.getCharsSequence();\n    for (int line = 1; line < lineIndents.length; line++) {\n      ProgressManager.checkCanceled();\n      int curIndent = lineIndents[line];\n\n      while (!indents.empty() && curIndent <= indents.peek()) {\n        ProgressManager.checkCanceled();\n        final int level = indents.pop();\n        int startLine = lines.pop();\n        if (level > 0) {\n          descriptors.add(createDescriptor(level, startLine, line, chars));\n        }\n      }\n\n      int prevLine = line - 1;\n      int prevIndent = lineIndents[prevLine];\n\n      if (curIndent - prevIndent > 1) {\n        lines.push(prevLine);\n        indents.push(prevIndent);\n      }\n    }\n\n    while (!indents.empty()) {\n      ProgressManager.checkCanceled();\n      final int level = indents.pop();\n      if (level > 0) {\n        int startLine = lines.pop();\n        descriptors.add(createDescriptor(level, startLine, myDocument.getLineCount(), chars));\n      }\n    }\n    return descriptors;\n  }","id":35533,"modified_method":"private List<IndentGuideDescriptor> buildDescriptors() {\n    if (!myEditor.getSettings().isIndentGuidesShown()) return Collections.emptyList();\n\n    IndentsCalculator calculator = new IndentsCalculator();\n    calculator.calculate();\n    int[] lineIndents = calculator.lineIndents;\n    TIntIntHashMap effectiveCommentColumns = calculator.indentAfterUncomment;\n\n    List<IndentGuideDescriptor> descriptors = new ArrayList<IndentGuideDescriptor>();\n\n    IntStack lines = new IntStack();\n    IntStack indents = new IntStack();\n\n    lines.push(0);\n    indents.push(0);\n    assert myDocument != null;\n    final CharSequence chars = myDocument.getCharsSequence();\n    for (int line = 1; line < lineIndents.length; line++) {\n      ProgressManager.checkCanceled();\n      int curIndent = lineIndents[line];\n\n      while (!indents.empty() && curIndent <= indents.peek()) {\n        ProgressManager.checkCanceled();\n        final int level = indents.pop();\n        int startLine = lines.pop();\n        if (level > 0) {\n          boolean addDescriptor = effectiveCommentColumns.contains(startLine); // Indent started at comment\n          if (!addDescriptor) {\n            for (int i = startLine; i < line; i++) {\n              if (level != lineIndents[i] && level != effectiveCommentColumns.get(i)) {\n                addDescriptor = true;\n                break;\n              }\n            }\n          }\n          if (addDescriptor) {\n            descriptors.add(createDescriptor(level, startLine, line, chars));\n          }\n        }\n      }\n\n      int prevLine = line - 1;\n      int prevIndent = lineIndents[prevLine];\n\n      if (curIndent - prevIndent > 1) {\n        lines.push(prevLine);\n        indents.push(prevIndent);\n      }\n    }\n\n    while (!indents.empty()) {\n      ProgressManager.checkCanceled();\n      final int level = indents.pop();\n      int startLine = lines.pop();\n      if (level > 0) {\n        descriptors.add(createDescriptor(level, startLine, myDocument.getLineCount(), chars));\n      }\n    }\n    return descriptors;\n  }","commit_id":"de7131e6a81ca66067ef3ab211fbbd521b13977a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void paint(Graphics2D g, MapView mv, Bounds box) {\n        Graphics2D g2 = g;\n        if (mode == Mode.select) {\n            // Nothing to do\n        } else {\n            if (newN1en != null) {\n\n                Point p1 = mv.getPoint(initialN1en);\n                Point p2 = mv.getPoint(initialN2en);\n                Point p3 = mv.getPoint(newN1en);\n                Point p4 = mv.getPoint(newN2en);\n\n                Point2D normalUnitVector = getNormalUniVector();\n\n                if (mode == Mode.extrude || mode == Mode.create_new) {\n                    g2.setColor(mainColor);\n                    g2.setStroke(mainStroke);\n                    // Draw rectangle around new area.\n                    GeneralPath b = new GeneralPath();\n                    b.moveTo(p1.x, p1.y); b.lineTo(p3.x, p3.y);\n                    b.lineTo(p4.x, p4.y); b.lineTo(p2.x, p2.y);\n                    b.lineTo(p1.x, p1.y);\n                    g2.draw(b);\n\n                    if (dualAlignActive) {\n                        // Draw reference ways\n                        drawReferenceSegment(g2, mv, dualAlignSegment1);\n                        drawReferenceSegment(g2, mv, dualAlignSegment2);\n                    } else if (activeMoveDirection != null) {\n                        // Draw reference way\n                        drawReferenceSegment(g2, mv, activeMoveDirection);\n\n                        // Draw right angle marker on first node position, only when moving at right angle\n                        if (activeMoveDirection.perpendicular) {\n                            // mirror RightAngle marker, so it is inside the extrude\n                            double headingRefWS = activeMoveDirection.p1.heading(activeMoveDirection.p2);\n                            double headingMoveDir = Math.atan2(normalUnitVector.getY(), normalUnitVector.getX());\n                            double headingDiff = headingRefWS - headingMoveDir;\n                            if (headingDiff < 0) headingDiff += 2 * Math.PI;\n                            boolean mirrorRA = Math.abs(headingDiff - Math.PI) > 1e-5;\n                            Point pr1 = mv.getPoint(activeMoveDirection.p1);\n                            drawAngleSymbol(g2, pr1, normalUnitVector, mirrorRA);\n                        }\n                    }\n                } else if (mode == Mode.translate || mode == Mode.translate_node) {\n                    g2.setColor(mainColor);\n                    if (p1.distance(p2) < 3) {\n                        g2.setStroke(mainStroke);\n                        g2.drawOval((int) (p1.x-symbolSize/2), (int) (p1.y-symbolSize/2),\n                                (int) (symbolSize), (int) (symbolSize));\n                    } else {\n                        Line2D oldline = new Line2D.Double(p1, p2);\n                        g2.setStroke(oldLineStroke);\n                        g2.draw(oldline);\n                    }\n\n                    if (dualAlignActive) {\n                        // Draw reference ways\n                        drawReferenceSegment(g2, mv, dualAlignSegment1);\n                        drawReferenceSegment(g2, mv, dualAlignSegment2);\n                    } else if (activeMoveDirection != null) {\n\n                        g2.setColor(helperColor);\n                        g2.setStroke(helperStrokeDash);\n                        // Draw a guideline along the normal.\n                        Line2D normline;\n                        Point2D centerpoint = new Point2D.Double((p1.getX()+p2.getX())*0.5, (p1.getY()+p2.getY())*0.5);\n                        normline = createSemiInfiniteLine(centerpoint, normalUnitVector, g2);\n                        g2.draw(normline);\n                        // Draw right angle marker on initial position, only when moving at right angle\n                        if (activeMoveDirection.perpendicular) {\n                            // EastNorth units per pixel\n                            g2.setStroke(helperStrokeRA);\n                            g2.setColor(mainColor);\n                            drawAngleSymbol(g2, centerpoint, normalUnitVector, false);\n                        }\n                    }\n                }\n            }\n            g2.setStroke(helperStrokeRA); // restore default stroke to prevent starnge occasional drawings\n        }\n    }","id":35534,"modified_method":"@Override\n    public void paint(Graphics2D g, MapView mv, Bounds box) {\n        Graphics2D g2 = g;\n        if (mode == Mode.select) {\n            // Nothing to do\n        } else {\n            if (newN1en != null) {\n\n                Point p1 = mv.getPoint(initialN1en);\n                Point p2 = mv.getPoint(initialN2en);\n                Point p3 = mv.getPoint(newN1en);\n                Point p4 = mv.getPoint(newN2en);\n\n                Point2D normalUnitVector = activeMoveDirection != null ? getNormalUniVector() : null;\n\n                if (mode == Mode.extrude || mode == Mode.create_new) {\n                    g2.setColor(mainColor);\n                    g2.setStroke(mainStroke);\n                    // Draw rectangle around new area.\n                    GeneralPath b = new GeneralPath();\n                    b.moveTo(p1.x, p1.y);\n                    b.lineTo(p3.x, p3.y);\n                    b.lineTo(p4.x, p4.y);\n                    b.lineTo(p2.x, p2.y);\n                    b.lineTo(p1.x, p1.y);\n                    g2.draw(b);\n\n                    if (dualAlignActive) {\n                        // Draw reference ways\n                        drawReferenceSegment(g2, mv, dualAlignSegment1);\n                        drawReferenceSegment(g2, mv, dualAlignSegment2);\n                    } else if (activeMoveDirection != null && normalUnitVector != null) {\n                        // Draw reference way\n                        drawReferenceSegment(g2, mv, activeMoveDirection);\n\n                        // Draw right angle marker on first node position, only when moving at right angle\n                        if (activeMoveDirection.perpendicular) {\n                            // mirror RightAngle marker, so it is inside the extrude\n                            double headingRefWS = activeMoveDirection.p1.heading(activeMoveDirection.p2);\n                            double headingMoveDir = Math.atan2(normalUnitVector.getY(), normalUnitVector.getX());\n                            double headingDiff = headingRefWS - headingMoveDir;\n                            if (headingDiff < 0)\n                                headingDiff += 2 * Math.PI;\n                            boolean mirrorRA = Math.abs(headingDiff - Math.PI) > 1e-5;\n                            Point pr1 = mv.getPoint(activeMoveDirection.p1);\n                            drawAngleSymbol(g2, pr1, normalUnitVector, mirrorRA);\n                        }\n                    }\n                } else if (mode == Mode.translate || mode == Mode.translate_node) {\n                    g2.setColor(mainColor);\n                    if (p1.distance(p2) < 3) {\n                        g2.setStroke(mainStroke);\n                        g2.drawOval((int) (p1.x-symbolSize/2), (int) (p1.y-symbolSize/2),\n                                (int) (symbolSize), (int) (symbolSize));\n                    } else {\n                        Line2D oldline = new Line2D.Double(p1, p2);\n                        g2.setStroke(oldLineStroke);\n                        g2.draw(oldline);\n                    }\n\n                    if (dualAlignActive) {\n                        // Draw reference ways\n                        drawReferenceSegment(g2, mv, dualAlignSegment1);\n                        drawReferenceSegment(g2, mv, dualAlignSegment2);\n                    } else if (activeMoveDirection != null) {\n\n                        g2.setColor(helperColor);\n                        g2.setStroke(helperStrokeDash);\n                        // Draw a guideline along the normal.\n                        Line2D normline;\n                        Point2D centerpoint = new Point2D.Double((p1.getX()+p2.getX())*0.5, (p1.getY()+p2.getY())*0.5);\n                        normline = createSemiInfiniteLine(centerpoint, normalUnitVector, g2);\n                        g2.draw(normline);\n                        // Draw right angle marker on initial position, only when moving at right angle\n                        if (activeMoveDirection.perpendicular) {\n                            // EastNorth units per pixel\n                            g2.setStroke(helperStrokeRA);\n                            g2.setColor(mainColor);\n                            drawAngleSymbol(g2, centerpoint, normalUnitVector, false);\n                        }\n                    }\n                }\n            }\n            g2.setStroke(helperStrokeRA); // restore default stroke to prevent starnge occasional drawings\n        }\n    }","commit_id":"acd8bd0bfd38cd35b8db23d568f3d2826f8979dd","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates a window geometry from a rectangle\n     *\n     * @param rect the position\n     */\n    public WindowGeometry(Rectangle rect) {\n        this.topLeft = rect.getLocation();\n        this.extent = rect.getSize();\n    }","id":35535,"modified_method":"/**\n     * Creates a window geometry from a rectangle\n     *\n     * @param rect the position\n     */\n    public WindowGeometry(Rectangle rect) {\n        this(rect.getLocation(), rect.getSize());\n    }","commit_id":"acd8bd0bfd38cd35b8db23d568f3d2826f8979dd","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Find the size and position of the screen for given coordinates. Use first screen,\n     * when no coordinates are stored or null is passed.\n     *\n     * @param g coordinates to check\n     * @return bounds of the screen\n     */\n    private static Rectangle getScreenInfo(Rectangle g) {\n        GraphicsEnvironment ge = GraphicsEnvironment\n                .getLocalGraphicsEnvironment();\n        GraphicsDevice[] gs = ge.getScreenDevices();\n        int intersect = 0;\n        Rectangle bounds = null;\n        for (GraphicsDevice gd : gs) {\n            if (gd.getType() == GraphicsDevice.TYPE_RASTER_SCREEN) {\n                Rectangle b = gd.getDefaultConfiguration().getBounds();\n                if (b.height > 0 && b.width / b.height >= 3) /* multiscreen with wrong definition */ {\n                    b.width /= 2;\n                    Rectangle is = b.intersection(g);\n                    int s = is.width * is.height;\n                    if (bounds == null || intersect < s) {\n                        intersect = s;\n                        bounds = b;\n                    }\n                    b = new Rectangle(b);\n                    b.x += b.width;\n                    is = b.intersection(g);\n                    s = is.width * is.height;\n                    if (bounds == null || intersect < s) {\n                        intersect = s;\n                        bounds = b;\n                    }\n                } else {\n                    Rectangle is = b.intersection(g);\n                    int s = is.width * is.height;\n                    if (bounds == null || intersect < s) {\n                        intersect = s;\n                        bounds = b;\n                    }\n                }\n            }\n        }\n        return bounds;\n    }","id":35536,"modified_method":"/**\n     * Find the size and position of the screen for given coordinates. Use first screen,\n     * when no coordinates are stored or null is passed.\n     *\n     * @param g coordinates to check\n     * @return bounds of the screen\n     */\n    private static Rectangle getScreenInfo(Rectangle g) {\n        GraphicsDevice[] gs = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();\n        int intersect = 0;\n        Rectangle bounds = null;\n        for (GraphicsDevice gd : gs) {\n            if (gd.getType() == GraphicsDevice.TYPE_RASTER_SCREEN) {\n                Rectangle b = gd.getDefaultConfiguration().getBounds();\n                if (b.height > 0 && b.width / b.height >= 3) /* multiscreen with wrong definition */ {\n                    b.width /= 2;\n                    Rectangle is = b.intersection(g);\n                    int s = is.width * is.height;\n                    if (bounds == null || intersect < s) {\n                        intersect = s;\n                        bounds = b;\n                    }\n                    b = new Rectangle(b);\n                    b.x += b.width;\n                    is = b.intersection(g);\n                    s = is.width * is.height;\n                    if (intersect < s) {\n                        intersect = s;\n                        bounds = b;\n                    }\n                } else {\n                    Rectangle is = b.intersection(g);\n                    int s = is.width * is.height;\n                    if (bounds == null || intersect < s) {\n                        intersect = s;\n                        bounds = b;\n                    }\n                }\n            }\n        }\n        return bounds != null ? bounds : g;\n    }","commit_id":"acd8bd0bfd38cd35b8db23d568f3d2826f8979dd","url":"https://github.com/openstreetmap/josm"},{"original_method":"@NotNull\n  private static String realKey(String key, @Nullable Project project) {\n    JFrame frame = project == null ? WindowManager.getInstance().findVisibleFrame() : WindowManager.getInstance().getFrame(project);\n\n    Rectangle screen = new Rectangle(0,0,0,0);\n    if (frame != null) {\n      final Point topLeft = frame.getLocation();\n      Point center = new Point(topLeft.x + frame.getWidth() / 2, topLeft.y + frame.getHeight() / 2);\n      for (GraphicsDevice device : GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()) {\n        Rectangle bounds = device.getDefaultConfiguration().getBounds();\n        if (bounds.contains(center)) {\n          screen = bounds;\n          break;\n        }\n      }\n    } else {\n      GraphicsConfiguration gc =\n        GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices()[0].getDefaultConfiguration();\n      screen = gc.getBounds();\n    }\n    return key + '.' + screen.x + '.' + screen.y + '.' + screen.width + '.' + screen.height;\n  }","id":35537,"modified_method":"@NotNull\n  private static String realKey(String key, @Nullable Project project) {\n    GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n    if (env.isHeadlessInstance()) {\n      return key + \".headless\";\n    }\n\n    JFrame frame = project == null ? WindowManager.getInstance().findVisibleFrame() : WindowManager.getInstance().getFrame(project);\n    Rectangle screen = new Rectangle(0, 0, 0, 0);\n    if (frame != null) {\n      final Point topLeft = frame.getLocation();\n      Point center = new Point(topLeft.x + frame.getWidth() / 2, topLeft.y + frame.getHeight() / 2);\n      for (GraphicsDevice device : env.getScreenDevices()) {\n        Rectangle bounds = device.getDefaultConfiguration().getBounds();\n        if (bounds.contains(center)) {\n          screen = bounds;\n          break;\n        }\n      }\n    }\n    else {\n      GraphicsConfiguration gc = env.getScreenDevices()[0].getDefaultConfiguration();\n      screen = gc.getBounds();\n    }\n    return key + '.' + screen.x + '.' + screen.y + '.' + screen.width + '.' + screen.height;\n  }","commit_id":"cab46ebc7ff9010aafe91ed87909d8f84921e806","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Rectangle getScreenRectangle(int x, int y) {\n    return getScreenRectangle(new Point(x, y));\n  }","id":35538,"modified_method":"/**\n   * Finds a device that is the closest to the specified point and\n   * returns its visible area.\n   *\n   * @param x the X coordinate of the specified point\n   * @param y the Y coordinate of the specified point\n   * @return a visible area rectangle\n   */\n  public static Rectangle getScreenRectangle(int x, int y) {\n    GraphicsDevice[] devices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();\n    if (devices.length == 0) {\n      return new Rectangle(x, y, 0, 0);\n    }\n    if (devices.length == 1) {\n      return getScreenRectangle(devices[0]);\n    }\n    Rectangle[] rectangles = new Rectangle[devices.length];\n    for (int i = 0; i < devices.length; i++) {\n      GraphicsConfiguration configuration = devices[i].getDefaultConfiguration();\n      Rectangle bounds = configuration.getBounds();\n      rectangles[i] = applyInsets(bounds, getScreenInsets(configuration));\n      if (bounds.contains(x, y)) {\n        return rectangles[i];\n      }\n    }\n    Rectangle bounds = rectangles[0];\n    int minimum = distance(bounds, x, y);\n    for (int i = 1; i < rectangles.length; i++) {\n      int distance = distance(rectangles[i], x, y);\n      if (minimum > distance) {\n        minimum = distance;\n        bounds = rectangles[i];\n      }\n    }\n    return bounds;\n  }","commit_id":"25939970da39ca3f3f7e06affa7729ea0f50d606","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Rectangle applyInsets(Rectangle rect, Insets i) {\n    if (i == null) {\n      return rect;\n    }\n\n    return new Rectangle(rect.x + i.left, rect.y + i.top, rect.width - (i.left + i.right), rect.height - (i.top + i.bottom));\n  }","id":35539,"modified_method":"private static Rectangle applyInsets(Rectangle rect, Insets i) {\n    return (i == null)\n           ? new Rectangle(rect)\n           : new Rectangle(rect.x + i.left,\n                           rect.y + i.top,\n                           rect.width - (i.left + i.right),\n                           rect.height - (i.top + i.bottom));\n  }","commit_id":"25939970da39ca3f3f7e06affa7729ea0f50d606","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Rectangle[] getAllScreenBounds() {\n    final GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n    final GraphicsDevice[] devices = env.getScreenDevices();\n    Rectangle[] result = new Rectangle[devices.length];\n    for (int i = 0; i < devices.length; i++) {\n      GraphicsDevice device = devices[i];\n      GraphicsConfiguration configuration = device.getDefaultConfiguration();\n      result[i] = new Rectangle(configuration.getBounds());\n      applyInsets(result[i], getScreenInsets(configuration));\n    }\n    return result;\n  }","id":35540,"modified_method":"private static Rectangle[] getAllScreenBounds() {\n    GraphicsDevice[] devices = GraphicsEnvironment.getLocalGraphicsEnvironment().getScreenDevices();\n    Rectangle[] result = new Rectangle[devices.length];\n    for (int i = 0; i < devices.length; i++) {\n      result[i] = getScreenRectangle(devices[i]);\n    }\n    return result;\n  }","commit_id":"25939970da39ca3f3f7e06affa7729ea0f50d606","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Rectangle getMainScreenBounds() {\n    GraphicsConfiguration graphicsConfiguration =\n      GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();\n    Rectangle bounds = graphicsConfiguration.getBounds();\n    applyInsets(bounds, getScreenInsets(graphicsConfiguration));\n    return bounds;\n  }","id":35541,"modified_method":"public static Rectangle getMainScreenBounds() {\n    return getScreenRectangle(GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice());\n  }","commit_id":"25939970da39ca3f3f7e06affa7729ea0f50d606","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Rectangle getScreenRectangle(@NotNull Point p) {\n    double distance = -1;\n    Rectangle answer = null;\n\n    Rectangle[] allScreenBounds = getAllScreenBounds();\n    for (Rectangle rect : allScreenBounds) {\n      if (rect.contains(p)) {\n        return rect;\n      }\n\n      final double d = findNearestPointOnBorder(rect, p).distance(p.x, p.y);\n      if (answer == null || distance > d) {\n        distance = d;\n        answer = rect;\n      }\n    }\n\n    if (answer == null) {\n      throw new IllegalStateException(\"It's impossible to determine target graphics environment for point (\" + p.x + \",\" + p.y + \")\");\n    }\n\n    return answer;\n  }","id":35542,"modified_method":"public static Rectangle getScreenRectangle(@NotNull Point p) {\n    return getScreenRectangle(p.x, p.y);\n  }","commit_id":"25939970da39ca3f3f7e06affa7729ea0f50d606","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void show(final Component owner, final int aScreenX, final int aScreenY, final boolean considerForcedXY) {\n    LOG.assertTrue (!isDisposed());\n\n    Rectangle targetBounds = new Rectangle(new Point(aScreenX, aScreenY), getContent().getPreferredSize());\n    ScreenUtil.moveRectangleToFitTheScreen(targetBounds);\n\n    if (getParent() != null) {\n      final Rectangle parentBounds = getParent().getBounds();\n      parentBounds.x += STEP_X_PADDING;\n      parentBounds.width -= STEP_X_PADDING * 2;\n      if (parentBounds.intersects(targetBounds)) {\n        targetBounds.x = getParent().getBounds().x - targetBounds.width - STEP_X_PADDING;\n      }\n    }\n\n    if (getParent() == null) {\n      PopupDispatcher.setActiveRoot(this);\n    }\n    else {\n      PopupDispatcher.setShowing(this);\n    }\n\n    LOG.assertTrue (!isDisposed(), \"Disposed popup, parent=\"+getParent());\n    super.show(owner, targetBounds.x, targetBounds.y, true);\n  }","id":35543,"modified_method":"@Override\n  public void show(final Component owner, final int aScreenX, final int aScreenY, final boolean considerForcedXY) {\n    LOG.assertTrue (!isDisposed());\n\n    Rectangle targetBounds = new Rectangle(new Point(aScreenX, aScreenY), getContent().getPreferredSize());\n\n    if (getParent() != null) {\n      final Rectangle parentBounds = getParent().getBounds();\n      parentBounds.x += STEP_X_PADDING;\n      parentBounds.width -= STEP_X_PADDING * 2;\n      ScreenUtil.moveToFit(targetBounds, ScreenUtil.getScreenRectangle(\n        parentBounds.x + parentBounds.width / 2,\n        parentBounds.y + parentBounds.height / 2), null);\n      if (parentBounds.intersects(targetBounds)) {\n        targetBounds.x = getParent().getBounds().x - targetBounds.width - STEP_X_PADDING;\n      }\n    } else {\n      ScreenUtil.moveToFit(targetBounds, ScreenUtil.getScreenRectangle(aScreenX, aScreenY), null);\n    }\n\n    if (getParent() == null) {\n      PopupDispatcher.setActiveRoot(this);\n    }\n    else {\n      PopupDispatcher.setShowing(this);\n    }\n\n    LOG.assertTrue (!isDisposed(), \"Disposed popup, parent=\"+getParent());\n    super.show(owner, targetBounds.x, targetBounds.y, true);\n  }","commit_id":"25939970da39ca3f3f7e06affa7729ea0f50d606","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Applies this geometry to a window. Makes sure that the window is not\n     * placed outside of the coordinate range of all available screens.\n     *\n     * @param window the window\n     */\n    public void applySafe(Window window) {\n        Point p = new Point(topLeft);\n\n        Rectangle virtualBounds = new Rectangle();\n        GraphicsEnvironment ge = GraphicsEnvironment\n                .getLocalGraphicsEnvironment();\n        GraphicsDevice[] gs = ge.getScreenDevices();\n        for (GraphicsDevice gd : gs) {\n            if (gd.getType() == GraphicsDevice.TYPE_RASTER_SCREEN) {\n                virtualBounds = virtualBounds.union(gd.getDefaultConfiguration().getBounds());\n            }\n        }\n\n        if (p.x < virtualBounds.x) {\n            p.x = virtualBounds.x;\n        } else if (p.x > virtualBounds.x + virtualBounds.width - extent.width) {\n            p.x = virtualBounds.x + virtualBounds.width - extent.width;\n        }\n\n        if (p.y < virtualBounds.y) {\n            p.y = virtualBounds.y;\n        } else if (p.y > virtualBounds.y + virtualBounds.height - extent.height) {\n            p.y = virtualBounds.y + virtualBounds.height - extent.height;\n        }\n\n        window.setLocation(p);\n        window.setSize(extent);\n    }","id":35544,"modified_method":"/**\n     * Applies this geometry to a window. Makes sure that the window is not\n     * placed outside of the coordinate range of all available screens.\n     *\n     * @param window the window\n     */\n    public void applySafe(Window window) {\n        Point p = new Point(topLeft);\n        Dimension size = new Dimension(extent);\n\n        Rectangle virtualBounds = getVirtualScreenBounds();\n\n        // Ensure window fit on screen\n\n        if (p.x < virtualBounds.x) {\n            p.x = virtualBounds.x;\n        } else if (p.x > virtualBounds.x + virtualBounds.width - size.width) {\n            p.x = virtualBounds.x + virtualBounds.width - size.width;\n        }\n\n        if (p.y < virtualBounds.y) {\n            p.y = virtualBounds.y;\n        } else if (p.y > virtualBounds.y + virtualBounds.height - size.height) {\n            p.y = virtualBounds.y + virtualBounds.height - size.height;\n        }\n\n        int deltax = (p.x + size.width) - (virtualBounds.x + virtualBounds.width);\n        if (deltax > 0) {\n            size.width -= deltax;\n        }\n\n        int deltay = (p.x + size.height) - (virtualBounds.y + virtualBounds.height);\n        if (deltay > 0) {\n            size.height -= deltay;\n        }\n\n        // Ensure window does not hide taskbar\n\n        Rectangle maxbounds = GraphicsEnvironment.getLocalGraphicsEnvironment().getMaximumWindowBounds();\n\n        deltax = size.width - maxbounds.width;\n        if (deltax > 0) {\n            size.width -= deltax;\n        }\n\n        deltay = size.height - maxbounds.height;\n        if (deltay > 0) {\n            size.height -= deltay;\n        }\n\n        window.setLocation(p);\n        window.setSize(size);\n    }","commit_id":"cc5600c5e7aae74e6032e3dd0a833574d8d713ea","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void resolve(DependencyMetaData dependency, BuildableComponentResolveResult result) {\n        DefaultBuildableComponentIdResolveResult idResult = new DefaultBuildableComponentIdResolveResult();\n        idResolver.resolve(dependency, idResult);\n        if (idResult.getFailure() != null) {\n            idResult.applyTo(result);\n            result.failed(idResult.getFailure());\n            return;\n        }\n        if (idResult.getMetaData() != null) {\n            result.resolved(idResult.getMetaData());\n            return;\n        }\n        metaDataResolver.resolve(dependency, idResult.getId(), result);\n    }","id":35545,"modified_method":"public ModuleVersionIdResolveResult resolve(final DependencyMetaData dependency) {\n        final DefaultBuildableComponentIdResolveResult idResult = new DefaultBuildableComponentIdResolveResult();\n        idResolver.resolve(dependency, idResult);\n        if (idResult.getFailure() != null) {\n            return new BrokenResult(idResult);\n        }\n        if (idResult.getMetaData() != null) {\n            return new WithMetaDataResult(idResult);\n        }\n        return new LazyResult(idResult, dependency);\n    }","commit_id":"c016031ff720ae15def80ba67429ac5278b224b5","url":"https://github.com/gradle/gradle"},{"original_method":"private void reset() {\n        failure = null;\n        metaData = null;\n        id = null;\n        moduleVersionId = null;\n    }","id":35546,"modified_method":"private void reset() {\n        failure = null;\n        metaData = null;\n        id = null;\n        moduleVersionId = null;\n        selectionReason = VersionSelectionReasons.REQUESTED;\n    }","commit_id":"c016031ff720ae15def80ba67429ac5278b224b5","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolved(ComponentResolveMetaData metaData) {\n        reset();\n        this.metaData = metaData;\n        id = metaData.getComponentId();\n        moduleVersionId = metaData.getId();\n    }","id":35547,"modified_method":"public void resolved(ComponentResolveMetaData metaData) {\n        resolved(metaData.getComponentId(), metaData.getId());\n        this.metaData = metaData;\n    }","commit_id":"c016031ff720ae15def80ba67429ac5278b224b5","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolve(final ConfigurationInternal configuration,\n                        final List<? extends ResolutionAwareRepository> repositories,\n                        final ModuleMetadataHandler metadataHandler,\n                        final ResolverResults results) throws ResolveException {\n        LOGGER.debug(\"Resolving {}\", configuration);\n        ivyContextManager.withIvy(new Action<Ivy>() {\n            public void execute(Ivy ivy) {\n                RepositoryChain repositoryChain = ivyFactory.create(configuration, repositories, metadataHandler);\n\n                DependencyToComponentResolver dependencyResolver = repositoryChain.getDependencyResolver();\n                RepositoryChainAdapter adapter = new RepositoryChainAdapter(dependencyResolver, versionMatcher);\n                ClientModuleResolver clientModuleResolver = new ClientModuleResolver(adapter, dependencyDescriptorFactory);\n                ProjectDependencyResolver projectDependencyResolver = new ProjectDependencyResolver(projectComponentRegistry, localComponentFactory, adapter);\n                dependencyResolver = new ComponentResolverAdapter(projectDependencyResolver, clientModuleResolver);\n                ResolutionStrategyInternal resolutionStrategy = (ResolutionStrategyInternal)configuration.getResolutionStrategy();\n                DependencyToModuleVersionIdResolver idResolver = new LazyDependencyToModuleResolver(dependencyResolver, versionMatcher);\n                idResolver = new VersionForcingDependencyToModuleResolver(idResolver, resolutionStrategy.getDependencyResolveRule());\n\n                ArtifactResolver artifactResolver = createArtifactResolver(repositoryChain);\n\n                ModuleConflictResolver conflictResolver;\n                if (resolutionStrategy.getConflictResolution() instanceof StrictConflictResolution) {\n                    conflictResolver = new StrictConflictResolver();\n                } else {\n                    conflictResolver = new LatestModuleConflictResolver(latestStrategy);\n                }\n                conflictResolver = new VersionSelectionReasonResolver(conflictResolver);\n                ConflictHandler conflictHandler = new DefaultConflictHandler(conflictResolver, metadataHandler.getModuleReplacements());\n\n                DependencyGraphBuilder builder = new DependencyGraphBuilder(idResolver, projectDependencyResolver, artifactResolver, conflictHandler, new DefaultDependencyToConfigurationResolver());\n\n                StoreSet stores = storeFactory.createStoreSet();\n\n                BinaryStore newModelStore = stores.nextBinaryStore();\n                Store<ResolvedComponentResult> newModelCache = stores.oldModelStore();\n                ResolutionResultBuilder newModelBuilder = new StreamingResolutionResultBuilder(newModelStore, newModelCache);\n\n                BinaryStore oldModelStore = stores.nextBinaryStore();\n                Store<TransientConfigurationResults> oldModelCache = stores.newModelStore();\n                TransientConfigurationResultsBuilder oldTransientModelBuilder = new TransientConfigurationResultsBuilder(oldModelStore, oldModelCache);\n                DefaultResolvedConfigurationBuilder oldModelBuilder = new DefaultResolvedConfigurationBuilder(oldTransientModelBuilder);\n\n                builder.resolve(configuration, newModelBuilder, oldModelBuilder);\n                DefaultLenientConfiguration result = new DefaultLenientConfiguration(configuration, oldModelBuilder, cacheLockingManager);\n                results.resolved(new DefaultResolvedConfiguration(result), newModelBuilder.complete());\n            }\n        });\n    }","id":35548,"modified_method":"public void resolve(final ConfigurationInternal configuration,\n                        final List<? extends ResolutionAwareRepository> repositories,\n                        final ModuleMetadataHandler metadataHandler,\n                        final ResolverResults results) throws ResolveException {\n        LOGGER.debug(\"Resolving {}\", configuration);\n        ivyContextManager.withIvy(new Action<Ivy>() {\n            public void execute(Ivy ivy) {\n                RepositoryChain repositoryChain = ivyFactory.create(configuration, repositories, metadataHandler);\n\n                DependencyToComponentResolver dependencyResolver = repositoryChain.getDependencyResolver();\n                RepositoryChainAdapter adapter = new RepositoryChainAdapter(dependencyResolver, versionMatcher);\n                ClientModuleResolver clientModuleResolver = new ClientModuleResolver(adapter, dependencyDescriptorFactory);\n                ProjectDependencyResolver projectDependencyResolver = new ProjectDependencyResolver(projectComponentRegistry, localComponentFactory, adapter);\n                ResolutionStrategyInternal resolutionStrategy = (ResolutionStrategyInternal) configuration.getResolutionStrategy();\n                VersionForcingDependencyToModuleResolver substitutionResolver = new VersionForcingDependencyToModuleResolver(projectDependencyResolver, resolutionStrategy.getDependencyResolveRule());\n                DependencyToModuleVersionIdResolver idResolver = new ComponentResolverAdapter(substitutionResolver, clientModuleResolver);\n\n                ArtifactResolver artifactResolver = createArtifactResolver(repositoryChain);\n\n                ModuleConflictResolver conflictResolver;\n                if (resolutionStrategy.getConflictResolution() instanceof StrictConflictResolution) {\n                    conflictResolver = new StrictConflictResolver();\n                } else {\n                    conflictResolver = new LatestModuleConflictResolver(latestStrategy);\n                }\n                conflictResolver = new VersionSelectionReasonResolver(conflictResolver);\n                ConflictHandler conflictHandler = new DefaultConflictHandler(conflictResolver, metadataHandler.getModuleReplacements());\n\n                DependencyGraphBuilder builder = new DependencyGraphBuilder(idResolver, projectDependencyResolver, artifactResolver, conflictHandler, new DefaultDependencyToConfigurationResolver());\n\n                StoreSet stores = storeFactory.createStoreSet();\n\n                BinaryStore newModelStore = stores.nextBinaryStore();\n                Store<ResolvedComponentResult> newModelCache = stores.oldModelStore();\n                ResolutionResultBuilder newModelBuilder = new StreamingResolutionResultBuilder(newModelStore, newModelCache);\n\n                BinaryStore oldModelStore = stores.nextBinaryStore();\n                Store<TransientConfigurationResults> oldModelCache = stores.newModelStore();\n                TransientConfigurationResultsBuilder oldTransientModelBuilder = new TransientConfigurationResultsBuilder(oldModelStore, oldModelCache);\n                DefaultResolvedConfigurationBuilder oldModelBuilder = new DefaultResolvedConfigurationBuilder(oldTransientModelBuilder);\n\n                builder.resolve(configuration, newModelBuilder, oldModelBuilder);\n                DefaultLenientConfiguration result = new DefaultLenientConfiguration(configuration, oldModelBuilder, cacheLockingManager);\n                results.resolved(new DefaultResolvedConfiguration(result), newModelBuilder.complete());\n            }\n        });\n    }","commit_id":"c016031ff720ae15def80ba67429ac5278b224b5","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolve(DependencyMetaData dependency, ComponentIdentifier identifier, BuildableComponentResolveResult result) {\n        ModuleVersionSelector requested = dependency.getRequested();\n        DefaultModuleComponentIdentifier id = new DefaultModuleComponentIdentifier(requested.getGroup(), requested.getName(), requested.getVersion());\n        if (!id.equals(identifier)) {\n            throw new UnsupportedOperationException(\"Dependency and component id have mismatching identifiers.\");\n        }\n\n        resolver.resolve(dependency, result);\n    }","id":35549,"modified_method":"public void resolve(DependencyMetaData dependency, ComponentIdentifier identifier, BuildableComponentResolveResult result) {\n        if (!(identifier instanceof ModuleComponentIdentifier)) {\n            throw new UnsupportedOperationException(\"Can only resolve module components\");\n        }\n\n        // Force the requested version\n        ModuleComponentIdentifier moduleId = (ModuleComponentIdentifier) identifier;\n        dependency = dependency.withRequestedVersion(new DefaultModuleVersionSelector(moduleId.getGroup(), moduleId.getModule(), moduleId.getVersion()));\n\n        resolver.resolve(dependency, result);\n    }","commit_id":"c016031ff720ae15def80ba67429ac5278b224b5","url":"https://github.com/gradle/gradle"},{"original_method":"public VersionForcingDependencyToModuleResolver(DependencyToModuleVersionIdResolver resolver, Action<DependencyResolveDetailsInternal> rule) {\n        this.resolver = resolver;\n        this.rule = rule;\n    }","id":35550,"modified_method":"public VersionForcingDependencyToModuleResolver(DependencyToComponentIdResolver resolver, Action<DependencyResolveDetailsInternal> rule) {\n        this.resolver = resolver;\n        this.rule = rule;\n    }","commit_id":"c016031ff720ae15def80ba67429ac5278b224b5","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionIdResolveResult resolve(DependencyMetaData dependency) {\n        ModuleVersionSelector module = dependency.getRequested();\n        DefaultDependencyResolveDetails details = new DefaultDependencyResolveDetails(module);\n        try {\n            rule.execute(details);\n        } catch (Throwable e) {\n            return new FailedDependencyResolveRuleResult(module, e);\n        }\n        if (details.isUpdated()) {\n            DependencyMetaData substitutedDependency = dependency.withRequestedVersion(details.getTarget());\n            ModuleVersionIdResolveResult result = resolver.resolve(substitutedDependency);\n            return new SubstitutedModuleVersionIdResolveResult(result, details.getSelectionReason());\n        }\n        return resolver.resolve(dependency);\n    }","id":35551,"modified_method":"public void resolve(DependencyMetaData dependency, BuildableComponentIdResolveResult result) {\n        ModuleVersionSelector module = dependency.getRequested();\n        DefaultDependencyResolveDetails details = new DefaultDependencyResolveDetails(module);\n        try {\n            rule.execute(details);\n        } catch (Throwable e) {\n            result.failed(new ModuleVersionResolveException(module, e));\n            return;\n        }\n        if (details.isUpdated()) {\n            DependencyMetaData substitutedDependency = dependency.withRequestedVersion(details.getTarget());\n            resolver.resolve(substitutedDependency, result);\n            result.setSelectionReason(details.getSelectionReason());\n            return;\n        }\n        resolver.resolve(dependency, result);\n    }","commit_id":"c016031ff720ae15def80ba67429ac5278b224b5","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultResolvedDependency getResult() {\n            if (result == null) {\n                result = new DefaultResolvedDependency(\n                        moduleRevision.id.getOrganisation(),\n                        moduleRevision.id.getName(),\n                        moduleRevision.id.getRevision(),\n                        configurationName);\n            }\n\n            return result;\n        }","id":35552,"modified_method":"public DefaultResolvedDependency getResult() {\n            if (result == null) {\n                result = new DefaultResolvedDependency(\n                        moduleRevision.id.getGroup(),\n                        moduleRevision.id.getName(),\n                        moduleRevision.id.getVersion(),\n                        configurationName);\n            }\n\n            return result;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleVersionSelectorResolveState(DependencyMetaData dependencyMetaData, DependencyToModuleVersionIdResolver resolver, ResolveState resolveState) {\n            this.dependencyMetaData = dependencyMetaData;\n            this.resolver = resolver;\n            this.resolveState = resolveState;\n            targetModule = resolveState.getModule(new ModuleId(dependencyMetaData.getRequested().getGroup(), dependencyMetaData.getRequested().getName()));\n        }","id":35553,"modified_method":"private ModuleVersionSelectorResolveState(DependencyMetaData dependencyMetaData, DependencyToModuleVersionIdResolver resolver, ResolveState resolveState) {\n            this.dependencyMetaData = dependencyMetaData;\n            this.resolver = resolver;\n            this.resolveState = resolveState;\n            targetModule = resolveState.getModule(new DefaultModuleIdentifier(dependencyMetaData.getRequested().getGroup(), dependencyMetaData.getRequested().getName()));\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionSelectorResolveState restart(DefaultModuleRevisionResolveState moduleRevision) {\n            return resolveState.getSelector(dependencyMetaData.withRequestedVersion(moduleRevision.id.getRevision()), moduleRevision.id);\n        }","id":35554,"modified_method":"public void restart(DefaultModuleRevisionResolveState moduleRevision) {\n            this.targetModuleRevision = moduleRevision;\n            this.targetModule = moduleRevision.module;\n            this.failure = targetModuleRevision.resolver.failure;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public void attachFailures(ResolvedConfigurationBuilder result) {\n            for (Map.Entry<ModuleVersionSelector, BrokenDependency> entry : failuresByRevisionId.entrySet()) {\n                Collection<List<ModuleRevisionId>> paths = calculatePaths(entry.getValue());\n                result.addUnresolvedDependency(new DefaultUnresolvedDependency(entry.getKey(), entry.getValue().failure.withIncomingPaths(paths)));\n            }\n        }","id":35555,"modified_method":"public void attachFailures(ResolvedConfigurationBuilder result) {\n            for (Map.Entry<ModuleVersionSelector, BrokenDependency> entry : failuresByRevisionId.entrySet()) {\n                Collection<List<ModuleVersionIdentifier>> paths = calculatePaths(entry.getValue());\n                result.addUnresolvedDependency(new DefaultUnresolvedDependency(entry.getKey(), entry.getValue().failure.withIncomingPaths(paths)));\n            }\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public String getRevision() {\n            return id.getRevision();\n        }","id":35556,"modified_method":"public String getRevision() {\n            return id.getVersion();\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"private void calculateTargetConfigurations() {\n            targetConfigurations.clear();\n            ModuleVersionMetaData targetModuleVersion = targetModuleRevision.getMetaData();\n            if (targetModuleVersion == null) {\n                // Broken version\n                return;\n            }\n\n            ModuleDescriptor targetDescriptor = targetModuleVersion.getDescriptor();\n            IvyNode node = new IvyNode(resolveState.resolveData, targetDescriptor);\n            Set<String> targets = new LinkedHashSet<String>();\n            for (String targetConfiguration : targetConfigurationRules) {\n                Collections.addAll(targets, node.getRealConfs(targetConfiguration));\n            }\n\n            for (String targetConfigurationName : targets) {\n                // TODO - this is the wrong spot for this check\n                if (targetDescriptor.getConfiguration(targetConfigurationName) == null) {\n                    throw new RuntimeException(String.format(\"Module version group:%s, module:%s, version:%s, configuration:%s declares a dependency on configuration '%s' which is not declared in the module descriptor for group:%s, module:%s, version:%s\",\n                            from.moduleRevision.id.getOrganisation(), from.moduleRevision.id.getName(), from.moduleRevision.id.getRevision(), from.configurationName,\n                            targetConfigurationName, targetModuleRevision.id.getOrganisation(), targetModuleRevision.id.getName(), targetModuleRevision.id.getRevision()));\n                }\n                ConfigurationNode targetConfiguration = resolveState.getConfigurationNode(targetModuleRevision, targetConfigurationName);\n                targetConfigurations.add(targetConfiguration);\n            }\n        }","id":35557,"modified_method":"private void calculateTargetConfigurations() {\n            targetConfigurations.clear();\n            ModuleVersionMetaData targetModuleVersion = targetModuleRevision.getMetaData();\n            if (targetModuleVersion == null) {\n                // Broken version\n                return;\n            }\n\n            ModuleDescriptor targetDescriptor = targetModuleVersion.getDescriptor();\n            IvyNode node = new IvyNode(resolveState.resolveData, targetDescriptor);\n            Set<String> targets = new LinkedHashSet<String>();\n            for (String targetConfiguration : targetConfigurationRules) {\n                Collections.addAll(targets, node.getRealConfs(targetConfiguration));\n            }\n\n            for (String targetConfigurationName : targets) {\n                // TODO - this is the wrong spot for this check\n                if (targetDescriptor.getConfiguration(targetConfigurationName) == null) {\n                    throw new RuntimeException(String.format(\"Module version %s, configuration:%s declares a dependency on configuration '%s' which is not declared in the module descriptor for %s\",\n                            from.moduleRevision.id, from.configurationName,\n                            targetConfigurationName, targetModuleRevision.id));\n                }\n                ConfigurationNode targetConfiguration = resolveState.getConfigurationNode(targetModuleRevision, targetConfigurationName);\n                targetConfigurations.add(targetConfiguration);\n            }\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"private Collection<List<ModuleRevisionId>> calculatePaths(BrokenDependency brokenDependency) {\n            // Include the shortest path from each version that has a direct dependency on the broken dependency, back to the root\n            \n            Map<DefaultModuleRevisionResolveState, List<ModuleRevisionId>> shortestPaths = new LinkedHashMap<DefaultModuleRevisionResolveState, List<ModuleRevisionId>>();\n            List<ModuleRevisionId> rootPath = new ArrayList<ModuleRevisionId>();\n            rootPath.add(root.moduleRevision.id);\n            shortestPaths.put(root.moduleRevision, rootPath);\n\n            Set<DefaultModuleRevisionResolveState> directDependees = new LinkedHashSet<DefaultModuleRevisionResolveState>();\n            for (ConfigurationNode node : brokenDependency.requiredBy) {\n                directDependees.add(node.moduleRevision);\n            }\n\n            Set<DefaultModuleRevisionResolveState> seen = new HashSet<DefaultModuleRevisionResolveState>();\n            LinkedList<DefaultModuleRevisionResolveState> queue = new LinkedList<DefaultModuleRevisionResolveState>();\n            queue.addAll(directDependees);\n            while (!queue.isEmpty()) {\n                DefaultModuleRevisionResolveState version = queue.getFirst();\n                if (version == root.moduleRevision) {\n                    queue.removeFirst();\n                } else if (seen.add(version)) {\n                    for (ConfigurationNode configuration : version.configurations) {\n                        for (DependencyEdge dependencyEdge : configuration.incomingEdges) {\n                            queue.add(0, dependencyEdge.from.moduleRevision);\n                        }\n                    }\n                } else {\n                    queue.remove();\n                    List<ModuleRevisionId> shortest = null;\n                    for (ConfigurationNode configuration : version.configurations) {\n                        for (DependencyEdge dependencyEdge : configuration.incomingEdges) {\n                            List<ModuleRevisionId> candidate = shortestPaths.get(dependencyEdge.from.moduleRevision);\n                            if (candidate == null) {\n                                continue;\n                            }\n                            if (shortest == null) {\n                                shortest = candidate;\n                            } else if (shortest.size() > candidate.size()) {\n                                shortest = candidate;\n                            }\n                        }\n                    }\n                    if (shortest == null) {\n                        continue;\n                    }\n                    List<ModuleRevisionId> path = new ArrayList<ModuleRevisionId>();\n                    path.addAll(shortest);\n                    path.add(version.id);\n                    shortestPaths.put(version, path);\n                }\n            }\n\n            List<List<ModuleRevisionId>> paths = new ArrayList<List<ModuleRevisionId>>();\n            for (DefaultModuleRevisionResolveState version : directDependees) {\n                List<ModuleRevisionId> path = shortestPaths.get(version);\n                paths.add(path);\n            }\n            return paths;\n        }","id":35558,"modified_method":"private Collection<List<ModuleVersionIdentifier>> calculatePaths(BrokenDependency brokenDependency) {\n            // Include the shortest path from each version that has a direct dependency on the broken dependency, back to the root\n            \n            Map<DefaultModuleRevisionResolveState, List<ModuleVersionIdentifier>> shortestPaths = new LinkedHashMap<DefaultModuleRevisionResolveState, List<ModuleVersionIdentifier>>();\n            List<ModuleVersionIdentifier> rootPath = new ArrayList<ModuleVersionIdentifier>();\n            rootPath.add(root.moduleRevision.id);\n            shortestPaths.put(root.moduleRevision, rootPath);\n\n            Set<DefaultModuleRevisionResolveState> directDependees = new LinkedHashSet<DefaultModuleRevisionResolveState>();\n            for (ConfigurationNode node : brokenDependency.requiredBy) {\n                directDependees.add(node.moduleRevision);\n            }\n\n            Set<DefaultModuleRevisionResolveState> seen = new HashSet<DefaultModuleRevisionResolveState>();\n            LinkedList<DefaultModuleRevisionResolveState> queue = new LinkedList<DefaultModuleRevisionResolveState>();\n            queue.addAll(directDependees);\n            while (!queue.isEmpty()) {\n                DefaultModuleRevisionResolveState version = queue.getFirst();\n                if (version == root.moduleRevision) {\n                    queue.removeFirst();\n                } else if (seen.add(version)) {\n                    for (ConfigurationNode configuration : version.configurations) {\n                        for (DependencyEdge dependencyEdge : configuration.incomingEdges) {\n                            queue.add(0, dependencyEdge.from.moduleRevision);\n                        }\n                    }\n                } else {\n                    queue.remove();\n                    List<ModuleVersionIdentifier> shortest = null;\n                    for (ConfigurationNode configuration : version.configurations) {\n                        for (DependencyEdge dependencyEdge : configuration.incomingEdges) {\n                            List<ModuleVersionIdentifier> candidate = shortestPaths.get(dependencyEdge.from.moduleRevision);\n                            if (candidate == null) {\n                                continue;\n                            }\n                            if (shortest == null) {\n                                shortest = candidate;\n                            } else if (shortest.size() > candidate.size()) {\n                                shortest = candidate;\n                            }\n                        }\n                    }\n                    if (shortest == null) {\n                        continue;\n                    }\n                    List<ModuleVersionIdentifier> path = new ArrayList<ModuleVersionIdentifier>();\n                    path.addAll(shortest);\n                    path.add(version.id);\n                    shortestPaths.put(version, path);\n                }\n            }\n\n            List<List<ModuleVersionIdentifier>> paths = new ArrayList<List<ModuleVersionIdentifier>>();\n            for (DefaultModuleRevisionResolveState version : directDependees) {\n                List<ModuleVersionIdentifier> path = shortestPaths.get(version);\n                paths.add(path);\n            }\n            return paths;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n     * Traverses the dependency graph, resolving conflicts and building the paths from the root configuration.\n     */\n    private void traverseGraph(ResolveState resolveState) {\n        Set<ModuleId> conflicts = new LinkedHashSet<ModuleId>();\n\n        resolveState.onMoreSelected(resolveState.root);\n\n        List<DependencyEdge> dependencies = new ArrayList<DependencyEdge>();\n        while (resolveState.peek() != null || !conflicts.isEmpty()) {\n            if (resolveState.peek() != null) {\n                ConfigurationNode node = resolveState.pop();\n                LOGGER.debug(\"Visiting configuration {}.\", node);\n\n                // Calculate the outgoing edges of this configuration\n                dependencies.clear();\n                node.visitOutgoingDependencies(dependencies);\n\n                for (DependencyEdge dependency : dependencies) {\n                    LOGGER.debug(\"Visiting dependency {}\", dependency);\n\n                    // Resolve dependency to a particular revision\n                    DefaultModuleRevisionResolveState moduleRevision = dependency.resolveModuleRevisionId();\n                    if (moduleRevision == null) {\n                        // Failed to resolve.\n                        continue;\n                    }\n                    ModuleId moduleId = moduleRevision.id.getModuleId();\n\n                    // Check for a new conflict\n                    if (moduleRevision.state == ModuleState.New) {\n                        ModuleResolveState module = resolveState.getModule(moduleId);\n\n                        // A new module revision. Check for conflict\n                        Collection<DefaultModuleRevisionResolveState> versions = module.getVersions();\n                        if (versions.size() == 1) {\n                            // First version of this module. Select it for now\n                            LOGGER.debug(\"Selecting new module version {}\", moduleRevision);\n                            module.select(moduleRevision);\n                        } else {\n                            // Not the first version of this module. We have a new conflict\n                            LOGGER.debug(\"Found new conflicting module version {}\", moduleRevision);\n                            conflicts.add(moduleId);\n\n                            // Deselect the currently selected version, and remove all outgoing edges from the version\n                            // This will propagate through the graph and prune configurations that are no longer required\n                            DefaultModuleRevisionResolveState previouslySelected = module.clearSelection();\n                            if (previouslySelected != null) {\n                                for (ConfigurationNode configuration : previouslySelected.configurations) {\n                                    configuration.removeOutgoingEdges();\n                                }\n                            }\n                        }\n                    }\n\n                    dependency.attachToTargetConfigurations();\n                }\n            } else {\n                // We have some batched up conflicts. Resolve the first, and continue traversing the graph\n                ModuleId moduleId = conflicts.iterator().next();\n                conflicts.remove(moduleId);\n                ModuleResolveState module = resolveState.getModule(moduleId);\n                DefaultModuleRevisionResolveState selected = conflictResolver.select(module.getVersions(), resolveState.root.moduleRevision);\n                LOGGER.debug(\"Selected {} from conflicting modules {}.\", selected, module.getVersions());\n\n                // Restart each configuration. For the evicted configuration, this means moving incoming dependencies across to the\n                // matching selected configuration. For the select configuration, this mean traversing its dependencies.\n                module.restart(selected);\n            }\n        }\n    }","id":35559,"modified_method":"/**\n     * Traverses the dependency graph, resolving conflicts and building the paths from the root configuration.\n     */\n    private void traverseGraph(ResolveState resolveState) {\n        Set<ModuleIdentifier> conflicts = new LinkedHashSet<ModuleIdentifier>();\n\n        resolveState.onMoreSelected(resolveState.root);\n\n        List<DependencyEdge> dependencies = new ArrayList<DependencyEdge>();\n        while (resolveState.peek() != null || !conflicts.isEmpty()) {\n            if (resolveState.peek() != null) {\n                ConfigurationNode node = resolveState.pop();\n                LOGGER.debug(\"Visiting configuration {}.\", node);\n\n                // Calculate the outgoing edges of this configuration\n                dependencies.clear();\n                node.visitOutgoingDependencies(dependencies);\n\n                for (DependencyEdge dependency : dependencies) {\n                    LOGGER.debug(\"Visiting dependency {}\", dependency);\n\n                    // Resolve dependency to a particular revision\n                    DefaultModuleRevisionResolveState moduleRevision = dependency.resolveModuleRevisionId();\n                    if (moduleRevision == null) {\n                        // Failed to resolve.\n                        continue;\n                    }\n                    ModuleIdentifier moduleId = moduleRevision.id.getModule();\n\n                    // Check for a new conflict\n                    if (moduleRevision.state == ModuleState.New) {\n                        ModuleResolveState module = resolveState.getModule(moduleId);\n\n                        // A new module revision. Check for conflict\n                        Collection<DefaultModuleRevisionResolveState> versions = module.getVersions();\n                        if (versions.size() == 1) {\n                            // First version of this module. Select it for now\n                            LOGGER.debug(\"Selecting new module version {}\", moduleRevision);\n                            module.select(moduleRevision);\n                        } else {\n                            // Not the first version of this module. We have a new conflict\n                            LOGGER.debug(\"Found new conflicting module version {}\", moduleRevision);\n                            conflicts.add(moduleId);\n\n                            // Deselect the currently selected version, and remove all outgoing edges from the version\n                            // This will propagate through the graph and prune configurations that are no longer required\n                            DefaultModuleRevisionResolveState previouslySelected = module.clearSelection();\n                            if (previouslySelected != null) {\n                                for (ConfigurationNode configuration : previouslySelected.configurations) {\n                                    configuration.removeOutgoingEdges();\n                                }\n                            }\n                        }\n                    }\n\n                    dependency.attachToTargetConfigurations();\n                }\n            } else {\n                // We have some batched up conflicts. Resolve the first, and continue traversing the graph\n                ModuleIdentifier moduleId = conflicts.iterator().next();\n                conflicts.remove(moduleId);\n                ModuleResolveState module = resolveState.getModule(moduleId);\n                DefaultModuleRevisionResolveState selected = conflictResolver.select(module.getVersions(), resolveState.root.moduleRevision);\n                LOGGER.debug(\"Selected {} from conflicting modules {}.\", selected, module.getVersions());\n\n                // Restart each configuration. For the evicted configuration, this means moving incoming dependencies across to the\n                // matching selected configuration. For the select configuration, this mean traversing its dependencies.\n                module.restart(selected);\n            }\n        }\n    }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionIdentifier getSelectedId() {\n            return new DefaultModuleVersionIdentifier(\n                    id.getOrganisation(),\n                    id.getName(),\n                    id.getRevision());\n        }","id":35560,"modified_method":"public ModuleVersionIdentifier getSelectedId() {\n            return id;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"private DefaultModuleRevisionResolveState(ModuleResolveState module, ModuleRevisionId id, ResolveState resolveState) {\n            this.module = module;\n            this.id = id;\n            this.resolveState = resolveState;\n        }","id":35561,"modified_method":"private DefaultModuleRevisionResolveState(ModuleResolveState module, ModuleVersionIdentifier id, ResolveState resolveState) {\n            this.module = module;\n            this.id = id;\n            this.resolveState = resolveState;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleResolveState getModule(ModuleId moduleId) {\n            ModuleId id = new ModuleId(moduleId.getOrganisation(), moduleId.getName());\n            ModuleResolveState module = modules.get(id);\n            if (module == null) {\n                module = new ModuleResolveState(id, this);\n                modules.put(id, module);\n            }\n            return module;\n        }","id":35562,"modified_method":"public ModuleResolveState getModule(ModuleIdentifier id) {\n            ModuleResolveState module = modules.get(id);\n            if (module == null) {\n                module = new ModuleResolveState(id, this);\n                modules.put(id, module);\n            }\n            return module;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public ConfigurationNode getConfigurationNode(DefaultModuleRevisionResolveState module, String configurationName) {\n            ModuleRevisionId original = module.id;\n            ResolvedConfigurationIdentifier id = new ResolvedConfigurationIdentifier(original.getOrganisation(), original.getName(), original.getRevision(), configurationName);\n            ConfigurationNode configuration = nodes.get(id);\n            if (configuration == null) {\n                configuration = new ConfigurationNode(module, module.metaData, configurationName, this);\n                nodes.put(id, configuration);\n            }\n            return configuration;\n        }","id":35563,"modified_method":"public ConfigurationNode getConfigurationNode(DefaultModuleRevisionResolveState module, String configurationName) {\n            ModuleVersionIdentifier original = module.id;\n            ResolvedConfigurationIdentifier id = new ResolvedConfigurationIdentifier(original.getGroup(), original.getName(), original.getVersion(), configurationName);\n            ConfigurationNode configuration = nodes.get(id);\n            if (configuration == null) {\n                configuration = new ConfigurationNode(module, module.metaData, configurationName, this);\n                nodes.put(id, configuration);\n            }\n            return configuration;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionSelectionReason getSelectionReason() {\n            return idResolveResult.getSelectionReason();\n        }","id":35564,"modified_method":"public ModuleVersionSelectionReason getSelectionReason() {\n            return targetModuleRevision == null ? idResolveResult.getSelectionReason() : targetModuleRevision.getSelectionReason();\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultModuleRevisionResolveState getVersion(ModuleRevisionId id) {\n            DefaultModuleRevisionResolveState moduleRevision = versions.get(id);\n            if (moduleRevision == null) {\n                moduleRevision = new DefaultModuleRevisionResolveState(this, id, resolveState);\n                versions.put(id, moduleRevision);\n            }\n\n            return moduleRevision;\n        }","id":35565,"modified_method":"public DefaultModuleRevisionResolveState getVersion(ModuleVersionIdentifier id) {\n            DefaultModuleRevisionResolveState moduleRevision = versions.get(id);\n            if (moduleRevision == null) {\n                moduleRevision = new DefaultModuleRevisionResolveState(this, id, resolveState);\n                versions.put(id, moduleRevision);\n            }\n\n            return moduleRevision;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultModuleRevisionResolveState getRevision(ModuleVersionIdentifier moduleVersionIdentifier) {\n            ModuleRevisionId id = new ModuleRevisionId(new ModuleId(moduleVersionIdentifier.getGroup(), moduleVersionIdentifier.getName()), moduleVersionIdentifier.getVersion());\n            return getModule(id.getModuleId()).getVersion(id);\n        }","id":35566,"modified_method":"public DefaultModuleRevisionResolveState getRevision(ModuleVersionIdentifier id) {\n            return getModule(id.getModule()).getVersion(id);\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionResolveException getFailure() {\n            //see also getSelected(). For evicted targetModuleRevisions, we need to reach out to the failure of selected module\n            //covered in VersionConflictResolutionIntegrationTest\n            return selector.failure != null ? selector.failure : getSelected().resolver.failure;\n        }","id":35567,"modified_method":"public ModuleVersionResolveException getFailure() {\n            return selector.getFailure();\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public void restart(DefaultModuleRevisionResolveState selected) {\n            selector = selector.restart(selected);\n            targetModuleRevision = selected;\n            attachToTargetConfigurations();\n        }","id":35568,"modified_method":"public void restart(DefaultModuleRevisionResolveState selected) {\n            selector.restart(selected);\n            targetModuleRevision = selected;\n            attachToTargetConfigurations();\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleVersionIdentifier toId() {\n            return newId(moduleRevision.id.getOrganisation(),\n                    moduleRevision.id.getName(),\n                    moduleRevision.id.getRevision());\n        }","id":35569,"modified_method":"private ModuleVersionIdentifier toId() {\n            return moduleRevision.id;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleVersionSelectionReason getReason() {\n            return getSelected() == null ? selector.getSelectionReason() : getSelected().selectionReason;\n        }","id":35570,"modified_method":"public ModuleVersionSelectionReason getReason() {\n            return selector.getSelectionReason();\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public void collectFailures(FailureState failureState) {\n            if (isFailed()) {\n                failureState.addUnresolvedDependency(this, selector.dependencyMetaData.getRequested(), getFailure());\n            }\n        }","id":35571,"modified_method":"public void collectFailures(FailureState failureState) {\n            ModuleVersionResolveException failure = getFailure();\n            if (failure != null) {\n                failureState.addUnresolvedDependency(this, selector.dependencyMetaData.getRequested(), failure);\n            }\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"public String getId() {\n            return String.format(\"%s:%s:%s\", id.getOrganisation(), id.getName(), id.getRevision());\n        }","id":35572,"modified_method":"public String getId() {\n            return String.format(\"%s:%s:%s\", id.getGroup(), id.getName(), id.getVersion());\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleResolveState(ModuleId id, ResolveState resolveState) {\n            this.id = id;\n            this.resolveState = resolveState;\n        }","id":35573,"modified_method":"private ModuleResolveState(ModuleIdentifier id, ResolveState resolveState) {\n            this.id = id;\n            this.resolveState = resolveState;\n        }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public String getMessage() {\n        if (paths.isEmpty()) {\n            return super.getMessage();\n        }\n        Formatter formatter = new Formatter();\n        formatter.format(\"%s%nRequired by:\", super.getMessage());\n        for (List<ModuleRevisionId> path : paths) {\n            formatter.format(\"%n    %s\", toString(path.get(0)));\n            for (int i = 1; i < path.size(); i++) {\n                formatter.format(\" > %s\", toString(path.get(i)));\n            }\n        }\n        return formatter.toString();\n    }","id":35574,"modified_method":"@Override\n    public String getMessage() {\n        if (paths.isEmpty()) {\n            return super.getMessage();\n        }\n        Formatter formatter = new Formatter();\n        formatter.format(\"%s%nRequired by:\", super.getMessage());\n        for (List<ModuleVersionIdentifier> path : paths) {\n            formatter.format(\"%n    %s\", toString(path.get(0)));\n            for (int i = 1; i < path.size(); i++) {\n                formatter.format(\" > %s\", toString(path.get(i)));\n            }\n        }\n        return formatter.toString();\n    }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"private String toString(ModuleRevisionId moduleRevisionId) {\n        return String.format(\"%s:%s:%s\", moduleRevisionId.getOrganisation(), moduleRevisionId.getName(), moduleRevisionId.getRevision());\n    }","id":35575,"modified_method":"private String toString(ModuleVersionIdentifier identifier) {\n        return identifier.toString();\n    }","commit_id":"9934fce5ef6a853248c897e7b47fd997b1522ee3","url":"https://github.com/gradle/gradle"},{"original_method":"@Test\n    public void testWaitingInfinitelyForTryLock() throws InterruptedException {\n       final Config config = new Config();\n        config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS, \"2000\");\n        final HazelcastInstance hz = createHazelcastInstance(config);\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        hz.getLock(\"testWaitingInfinitelyForTryLock\").lock();\n\n        new Thread() {\n            public void run() {\n                try {\n                    hz.getLock(\"testWaitingInfinitelyForTryLock\").tryLock(5, TimeUnit.SECONDS);\n                    latch.countDown();\n                } catch (Exception ignored) {\n                }\n            }\n        }.start();\n\n        assertTrue(latch.await(15, TimeUnit.SECONDS));\n\n    }","id":35576,"modified_method":"@Test\n    public void testWaitingInfinitelyForTryLock() throws InterruptedException {\n       final Config config = new Config();\n        config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS, \"3000\");\n        final HazelcastInstance hz = createHazelcastInstance(config);\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        final String name = \"testWaitingInfinitelyForTryLock\";\n        hz.getLock(name).lock();\n\n        new Thread() {\n            public void run() {\n                try {\n                    hz.getLock(name).tryLock(10, TimeUnit.SECONDS);\n                    latch.countDown();\n                } catch (Exception ignored) {\n                }\n            }\n        }.start();\n\n        assertTrue(latch.await(20, TimeUnit.SECONDS));\n\n    }","commit_id":"393633d0a175d0da12bb0d9d6c6bfd9cfb4e2ccf","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testWaitingIndefinitely() throws InterruptedException {\n        final Config config = new Config();\n        config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS, \"2000\");\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance[] instances = factory.newInstances(config);\n\n        // need to warm-up partitions,\n        // since waiting for lock backup can take up to 5 seconds\n        // and that may cause OperationTimeoutException with \"No response for 4000 ms\" error.\n        warmUpPartitions(instances);\n\n        instances[0].getLock(\"testWaitingIndefinitely\").lock();\n\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        new Thread() {\n            public void run() {\n                try {\n                    // because max timeout=2000 we get timeout exception which we should not\n                    instances[1].getLock(\"testWaitingIndefinitely\").lock();\n                    latch.countDown();\n                } catch (Exception ignored) {\n                }\n            }\n        }.start();\n\n\n        // wait for enough time which is greater than max-timeout (2000)\n        Thread.sleep(10000);\n\n        instances[0].getLock(\"testWaitingIndefinitely\").unlock();\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":35577,"modified_method":"@Test\n    public void testWaitingIndefinitely() throws InterruptedException {\n        final Config config = new Config();\n        config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS, \"3000\");\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance[] instances = factory.newInstances(config);\n\n        // need to warm-up partitions,\n        // since waiting for lock backup can take up to 5 seconds\n        // and that may cause OperationTimeoutException with \"No response for 4000 ms\" error.\n        warmUpPartitions(instances);\n\n        final String name = \"testWaitingIndefinitely\";\n        ILock lock = instances[0].getLock(name);\n        lock.lock();\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        new Thread() {\n            public void run() {\n                try {\n                    // because max timeout=3000 we get timeout exception which we should not\n                    instances[1].getLock(name).lock();\n                    latch.countDown();\n                } catch (Exception ignored) {\n                }\n            }\n        }.start();\n\n        // wait for enough time which is greater than max-timeout (3000)\n        sleepSeconds(10);\n        lock.unlock();\n\n        assertTrue(latch.await(20, TimeUnit.SECONDS));\n    }","commit_id":"393633d0a175d0da12bb0d9d6c6bfd9cfb4e2ccf","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testWaitingIndefinitely() throws InterruptedException {\n        final Config config = new Config();\n        config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS, \"2000\");\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance[] instances = factory.newInstances(config);\n\n        // need to warm-up partitions,\n        // since waiting for lock backup can take up to 5 seconds\n        // and that may cause OperationTimeoutException with \"No response for 4000 ms\" error.\n        warmUpPartitions(instances);\n\n        instances[0].getLock(\"testWaitingIndefinitely\").lock();\n\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        new Thread() {\n            public void run() {\n                try {\n                    // because max timeout=2000 we get timeout exception which we should not\n                    instances[1].getLock(\"testWaitingIndefinitely\").lock();\n                    latch.countDown();\n                } catch (Exception ignored) {\n                }\n            }\n        }.start();\n\n\n        // wait for enough time which is greater than max-timeout (2000)\n        Thread.sleep(10000);\n\n        instances[0].getLock(\"testWaitingIndefinitely\").unlock();\n\n        assertTrue(latch.await(5, TimeUnit.SECONDS));\n    }","id":35578,"modified_method":"@Test\n    public void testWaitingIndefinitely() throws InterruptedException {\n        final Config config = new Config();\n        config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS, \"3000\");\n\n        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n        final HazelcastInstance[] instances = factory.newInstances(config);\n\n        // need to warm-up partitions,\n        // since waiting for lock backup can take up to 5 seconds\n        // and that may cause OperationTimeoutException with \"No response for 4000 ms\" error.\n        warmUpPartitions(instances);\n\n        final String name = \"testWaitingIndefinitely\";\n        ILock lock = instances[0].getLock(name);\n        lock.lock();\n\n        final CountDownLatch latch = new CountDownLatch(1);\n        new Thread() {\n            public void run() {\n                try {\n                    // because max timeout=3000 we get timeout exception which we should not\n                    instances[1].getLock(name).lock();\n                    latch.countDown();\n                } catch (Exception ignored) {\n                }\n            }\n        }.start();\n\n        // wait for enough time which is greater than max-timeout (3000)\n        sleepSeconds(10);\n        lock.unlock();\n\n        assertTrue(latch.await(20, TimeUnit.SECONDS));\n    }","commit_id":"9773b0b977b83edb0bf0358ce677385615838e3c","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testWaitingInfinitelyForTryLock() throws InterruptedException {\n       final Config config = new Config();\n        config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS, \"2000\");\n        final HazelcastInstance hz = createHazelcastInstance(config);\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        hz.getLock(\"testWaitingInfinitelyForTryLock\").lock();\n\n        new Thread() {\n            public void run() {\n                try {\n                    hz.getLock(\"testWaitingInfinitelyForTryLock\").tryLock(5, TimeUnit.SECONDS);\n                    latch.countDown();\n                } catch (Exception ignored) {\n                }\n            }\n        }.start();\n\n        assertTrue(latch.await(15, TimeUnit.SECONDS));\n\n    }","id":35579,"modified_method":"@Test\n    public void testWaitingInfinitelyForTryLock() throws InterruptedException {\n       final Config config = new Config();\n        config.setProperty(GroupProperties.PROP_OPERATION_CALL_TIMEOUT_MILLIS, \"3000\");\n        final HazelcastInstance hz = createHazelcastInstance(config);\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        final String name = \"testWaitingInfinitelyForTryLock\";\n        hz.getLock(name).lock();\n\n        new Thread() {\n            public void run() {\n                try {\n                    hz.getLock(name).tryLock(10, TimeUnit.SECONDS);\n                    latch.countDown();\n                } catch (Exception ignored) {\n                }\n            }\n        }.start();\n\n        assertTrue(latch.await(20, TimeUnit.SECONDS));\n\n    }","commit_id":"9773b0b977b83edb0bf0358ce677385615838e3c","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Creates the HTML String for the buttons \"edit\" and \"define properties\" depending on the lock state of the resource.<p>\n     *  \n     * @return the HTML output String for the buttons\n     */\n    public String buildActionButtons() {\n        CmsLock lock = getCms().getLock(getParamFile());\n\n        if (!lock.isNullLock()) {\n            // resource is locked, show \"define\" & \"modify\" button\n            StringBuffer retValue = new StringBuffer(256);\n            \n            retValue.append(\"<table border=\\\"0\\\">\\n\");\n            retValue.append(\"<tr>\\n\\t<td>\\n\");\n            \n            //  create button to switch to the edit properties window\n            setParamAction(DIALOG_SHOW_EDIT);\n            retValue.append(\"<form action=\\\"\"+getDialogUri()+\"\\\" method=\\\"post\\\" class=\\\"nomargin\\\" name=\\\"define\\\">\\n\");\n            retValue.append(paramsAsHidden());\n            retValue.append(\"<input type=\\\"submit\\\" class=\\\"dialogbutton\\\" style=\\\"margin-left: 0;\\\" name=\\\"ok\\\" value=\\\"\"+key(\"button.edit\")+\"\\\">\\n\");\n            retValue.append(\"<\/form>\\n\");\n            \n            retValue.append(\"\\t<\/td>\\n\");\n            retValue.append(\"\\t<td>\\n\");\n            \n            \n            // create button to switch to the define property window\n            setParamAction(DIALOG_SHOW_DEFINE);\n            retValue.append(\"<form action=\\\"\"+getDialogUri()+\"\\\" method=\\\"post\\\" class=\\\"nomargin\\\" name=\\\"define\\\">\\n\");\n            retValue.append(paramsAsHidden());\n            retValue.append(\"<input type=\\\"submit\\\" class=\\\"dialogbutton\\\" name=\\\"ok\\\" value=\\\"\"+key(\"button.newpropertydef\")+\"\\\">\\n\");\n            retValue.append(\"<\/form>\\n\");\n            \n            retValue.append(\"\\t<\/td>\\n<\/tr>\\n\");\n            retValue.append(\"<\/table>\");\n            \n            return retValue.toString();\n        } else {\n            // resource is not locked, don't display edit buttons\n            return \"\";\n        }\n    }","id":35580,"modified_method":"/**\n     * Creates the HTML String for the buttons \"edit\" and \"define properties\" depending on the lock state of the resource.<p>\n     *  \n     * @return the HTML output String for the buttons\n     */\n    public String buildActionButtons() {\n        String resourceName = getParamFile();\n        CmsResource file;\n        \n        try {\n            file = (CmsResource)getCms().readFileHeader(resourceName);\n            // check if resource is a folder\n            if (file.isFolder()) {\n                resourceName += \"/\";            \n            }\n        } catch (CmsException e) { }\n        \n        CmsLock lock = getCms().getLock(resourceName);\n        \n        if (!lock.isNullLock()) {\n            // resource is locked, show \"define\" & \"modify\" button\n            StringBuffer retValue = new StringBuffer(256);\n            \n            retValue.append(\"<table border=\\\"0\\\">\\n\");\n            retValue.append(\"<tr>\\n\\t<td>\\n\");\n            \n            //  create button to switch to the edit properties window\n            setParamAction(DIALOG_SHOW_EDIT);\n            retValue.append(\"<form action=\\\"\"+getDialogUri()+\"\\\" method=\\\"post\\\" class=\\\"nomargin\\\" name=\\\"define\\\">\\n\");\n            retValue.append(paramsAsHidden());\n            retValue.append(\"<input type=\\\"submit\\\" class=\\\"dialogbutton\\\" style=\\\"margin-left: 0;\\\" name=\\\"ok\\\" value=\\\"\"+key(\"button.edit\")+\"\\\">\\n\");\n            retValue.append(\"<\/form>\\n\");\n            \n            retValue.append(\"\\t<\/td>\\n\");\n            retValue.append(\"\\t<td>\\n\");\n            \n            \n            // create button to switch to the define property window\n            setParamAction(DIALOG_SHOW_DEFINE);\n            retValue.append(\"<form action=\\\"\"+getDialogUri()+\"\\\" method=\\\"post\\\" class=\\\"nomargin\\\" name=\\\"define\\\">\\n\");\n            retValue.append(paramsAsHidden());\n            retValue.append(\"<input type=\\\"submit\\\" class=\\\"dialogbutton\\\" name=\\\"ok\\\" value=\\\"\"+key(\"button.newpropertydef\")+\"\\\">\\n\");\n            retValue.append(\"<\/form>\\n\");\n            \n            retValue.append(\"\\t<\/td>\\n<\/tr>\\n\");\n            retValue.append(\"<\/table>\");\n            \n            return retValue.toString();\n        } else {\n            // resource is not locked, don't display edit buttons\n            return \"\";\n        }\n    }","commit_id":"a5bdb8d0d7dce5c0622671fba25865a524d9cea1","url":"https://github.com/alkacon/opencms-core"},{"original_method":"static final CheckedListenableFuture<ServiceConfiguration> startTransitionChain( final ServiceConfiguration config ) {\n    if ( !State.NOTREADY.equals( config.lookupState( ) ) && !State.DISABLED.equals( config.lookupState( ) ) && !State.ENABLED.equals( config.lookupState( ) ) ) {\n      Callable<CheckedListenableFuture<ServiceConfiguration>> transition = null;\n      if ( State.STOPPED.isIn( config ) || State.INITIALIZED.isIn( config ) || State.BROKEN.isIn( config ) ) {\n        transition = Automata.sequenceTransitions( config,\n                                                   Component.State.BROKEN,\n                                                   Component.State.INITIALIZED,\n                                                   Component.State.LOADED,\n                                                   Component.State.NOTREADY,\n                                                   Component.State.DISABLED );\n      } else {\n        transition = Automata.sequenceTransitions( config, config.lookupState( ), Component.State.NOTREADY, Component.State.DISABLED );\n      }\n      try {\n        return transition.call( );\n      } catch ( Throwable ex ) {\n        LOG.error( ex, ex );\n        return Futures.predestinedFailedFuture( ex );\n      }\n    } else {\n      return Futures.predestinedFuture( config );\n    }\n  }","id":35581,"modified_method":"static final CheckedListenableFuture<ServiceConfiguration> startTransitionChain( final ServiceConfiguration config ) {\n    if ( !State.NOTREADY.equals( config.lookupState( ) ) && !State.DISABLED.equals( config.lookupState( ) ) && !State.ENABLED.equals( config.lookupState( ) ) ) {\n      Callable<CheckedListenableFuture<ServiceConfiguration>> transition = null;\n      if ( State.STOPPED.isIn( config ) ) {\n        transition = Automata.sequenceTransitions( config,\n                                                   Component.State.INITIALIZED,\n                                                   Component.State.LOADED,\n                                                   Component.State.NOTREADY,\n                                                   Component.State.DISABLED );\n      } else if ( State.INITIALIZED.isIn( config ) ) {\n        transition = Automata.sequenceTransitions( config,\n                                                   Component.State.LOADED,\n                                                   Component.State.NOTREADY,\n                                                   Component.State.DISABLED );\n      } else if ( State.BROKEN.isIn( config ) ) {\n        transition = Automata.sequenceTransitions( config,\n                                                     Component.State.BROKEN,\n                                                     Component.State.INITIALIZED,\n                                                     Component.State.LOADED,\n                                                     Component.State.NOTREADY,\n                                                     Component.State.DISABLED );\n      } else {\n        transition = Automata.sequenceTransitions( config, config.lookupState( ), Component.State.NOTREADY, Component.State.DISABLED );\n      }\n      try {\n        return transition.call( );\n      } catch ( Throwable ex ) {\n        LOG.error( ex, ex );\n        return Futures.predestinedFailedFuture( ex );\n      }\n    } else {\n      return Futures.predestinedFuture( config );\n    }\n  }","commit_id":"1510827e05080d393a1cbe5d617bcb5144195118","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected void onServerPoolMemberChanged(final Entity member) {\n        synchronized (mutex) {\n            log.trace(\"For {}, considering membership of {} which is in locations {}\", new Object[]{ this, member, member.getLocations() });\n\n            Map<Entity, String> nodes = getAttribute(RIAK_CLUSTER_NODES);\n            if (belongsInServerPool(member)) {\n                // TODO can we discover the nodes by asking the riak cluster, rather than assuming what we add will be in there?\n                // TODO and can we do join as part of node starting?\n\n                if (nodes == null) {\n                    nodes = Maps.newLinkedHashMap();\n                }\n                String riakName = getRiakName(member);\n                Preconditions.checkNotNull(riakName);\n\n                // flag a first node to be the first node in the riak cluster.\n                Boolean firstNode = getAttribute(IS_FIRST_NODE_SET);\n                if (!Boolean.TRUE.equals(firstNode)) {\n                    setAttribute(IS_FIRST_NODE_SET, Boolean.TRUE);\n\n                    nodes.put(member, riakName);\n                    setAttribute(RIAK_CLUSTER_NODES, nodes);\n\n                    ((EntityInternal) member).setAttribute(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Boolean.TRUE);\n\n                    log.info(\"Added initial Riak node {}: {}; {} to new cluster\", new Object[] { this, member, getRiakName(member) });\n                } else {\n                    // TODO: be wary of erroneous nodes but are still flagged 'in cluster'\n                    // add the new node to be part of the riak cluster.\n                    Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), Predicates.and(\n                            Predicates.instanceOf(RiakNode.class),\n                            EntityPredicates.attributeEqualTo(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, true)));\n                    if (anyNodeInCluster.isPresent()) {\n                        if (!nodes.containsKey(member) && member.getAttribute(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER) == null) {\n                            String anyNodeName = anyNodeInCluster.get().getAttribute(RiakNode.RIAK_NODE_NAME);\n                            Task<Void> joinCluster = Entities.invokeEffectorWithArgs(this, member, RiakNode.JOIN_RIAK_CLUSTER, anyNodeName);\n                            if (getAttribute(IS_CLUSTER_INIT)) {\n                                joinCluster.blockUntilEnded();\n                                Entities.invokeEffector(RiakClusterImpl.this, member, RiakNode.COMMIT_RIAK_CLUSTER);\n                            }\n                            nodes.put(member, riakName);\n                            setAttribute(RIAK_CLUSTER_NODES, nodes);\n                            log.info(\"Added Riak node {}: {}; {} to cluster\", new Object[] { this, member, getRiakName(member) });\n                        }\n                    } else {\n                        log.error(\"isFirstNodeSet, but no cluster members found to add {}\", member.getId());\n                    }\n                }\n            } else {\n                if (nodes != null && nodes.containsKey(member)) {\n                    Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), Predicates.and(\n                            Predicates.instanceOf(RiakNode.class),\n                            EntityPredicates.attributeEqualTo(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, true),\n                            Predicates.not(Predicates.equalTo(member))));\n                    if (anyNodeInCluster.isPresent()) {\n                        Entities.invokeEffectorWithArgs(this, anyNodeInCluster.get(), RiakNode.LEAVE_RIAK_CLUSTER, getRiakName(member));\n                    }\n                    nodes.remove(member);\n                    setAttribute(RIAK_CLUSTER_NODES, nodes);\n                    log.info(\"Removed Riak node {}: {}; {} from cluster\", new Object[]{ this, member, getRiakName(member) });\n                }\n            }\n\n            ServiceNotUpLogic.updateNotUpIndicatorRequiringNonEmptyMap(this, RIAK_CLUSTER_NODES);\n\n            calculateClusterAddresses();\n        }\n    }","id":35582,"modified_method":"protected void onServerPoolMemberChanged(final Entity member) {\n        synchronized (mutex) {\n            log.trace(\"For {}, considering membership of {} which is in locations {}\", new Object[]{ this, member, member.getLocations() });\n\n            Map<Entity, String> nodes = getAttribute(RIAK_CLUSTER_NODES);\n            if (belongsInServerPool(member)) {\n                // TODO can we discover the nodes by asking the riak cluster, rather than assuming what we add will be in there?\n                // TODO and can we do join as part of node starting?\n\n                if (nodes == null) {\n                    nodes = Maps.newLinkedHashMap();\n                }\n                String riakName = getRiakName(member);\n                Preconditions.checkNotNull(riakName);\n\n                // flag a first node to be the first node in the riak cluster.\n                Boolean firstNode = getAttribute(IS_FIRST_NODE_SET);\n                if (!Boolean.TRUE.equals(firstNode)) {\n                    setAttribute(IS_FIRST_NODE_SET, Boolean.TRUE);\n\n                    nodes.put(member, riakName);\n                    setAttribute(RIAK_CLUSTER_NODES, nodes);\n\n                    ((EntityInternal) member).setAttribute(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, Boolean.TRUE);\n\n                    log.info(\"Added initial Riak node {}: {}; {} to new cluster\", new Object[] { this, member, getRiakName(member) });\n                } else {\n                    // TODO: be wary of erroneous nodes but are still flagged 'in cluster'\n                    // add the new node to be part of the riak cluster.\n                    Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), Predicates.and(\n                            Predicates.instanceOf(RiakNode.class),\n                            EntityPredicates.attributeEqualTo(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, true)));\n                    if (anyNodeInCluster.isPresent()) {\n                        if (!nodes.containsKey(member) && member.getAttribute(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER) == null) {\n                            String anyNodeName = anyNodeInCluster.get().getAttribute(RiakNode.RIAK_NODE_NAME);\n                            Entities.invokeEffectorWithArgs(this, member, RiakNode.JOIN_RIAK_CLUSTER, anyNodeName).blockUntilEnded();\n                            if (getAttribute(IS_CLUSTER_INIT)) {\n                                Entities.invokeEffector(this, member, RiakNode.COMMIT_RIAK_CLUSTER).blockUntilEnded();\n                            }\n                            nodes.put(member, riakName);\n                            setAttribute(RIAK_CLUSTER_NODES, nodes);\n                            log.info(\"Added Riak node {}: {}; {} to cluster\", new Object[] { this, member, getRiakName(member) });\n                        }\n                    } else {\n                        log.error(\"isFirstNodeSet, but no cluster members found to add {}\", member.getId());\n                    }\n                }\n            } else {\n                if (nodes != null && nodes.containsKey(member)) {\n                    Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), Predicates.and(\n                            Predicates.instanceOf(RiakNode.class),\n                            EntityPredicates.attributeEqualTo(RiakNode.RIAK_NODE_HAS_JOINED_CLUSTER, true),\n                            Predicates.not(Predicates.equalTo(member))));\n                    if (anyNodeInCluster.isPresent()) {\n                        Entities.invokeEffectorWithArgs(this, anyNodeInCluster.get(), RiakNode.LEAVE_RIAK_CLUSTER, getRiakName(member)).blockUntilEnded();\n                    }\n                    nodes.remove(member);\n                    setAttribute(RIAK_CLUSTER_NODES, nodes);\n                    log.info(\"Removed Riak node {}: {}; {} from cluster\", new Object[]{ this, member, getRiakName(member) });\n                }\n            }\n\n            ServiceNotUpLogic.updateNotUpIndicatorRequiringNonEmptyMap(this, RIAK_CLUSTER_NODES);\n\n            calculateClusterAddresses();\n        }\n    }","commit_id":"b8d60635392142b4fb33e5ced47f8f8a86058edd","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected synchronized void onServerPoolMemberChanged(Entity member) {\n        if (log.isTraceEnabled()) log.trace(\"For {}, considering membership of {} which is in locations {}\",\n                new Object[]{this, member, member.getLocations()});\n\n        if (belongsInServerPool(member)) {\n            Map<Entity, String> nodes = getAttribute(RIAK_CLUSTER_NODES);\n            if (nodes == null) nodes = Maps.newLinkedHashMap();\n            String riakName = getRiakName(member);\n            if (riakName == null) {\n                log.error(\"Unable to get riak name for node: {}\", member.getId());\n            } else {\n\n                //flag a first node to be the first node in the riak cluster.\n                if (!isFirstNodeSet.getAndSet(true)) {\n                    ((EntityInternal) member).setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, Boolean.TRUE);\n                } else {\n                    //TODO: be wary of erreneous nodes but are still flagged 'in cluster'\n                    //add the new node to be part of the riak cluster.\n                    Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), new Predicate<Entity>() {\n\n                        @Override\n                        public boolean apply(@Nullable Entity node) {\n                            return (node instanceof RiakNode &&\n                                    node.getAttribute(RiakNode.RIAK_NODE_IN_CLUSTER))? true : false;\n                        }\n                    });\n\n                    //invoke join cluster operation on newly added member.\n                    if (anyNodeInCluster.isPresent() && !member.getAttribute(RiakNode.RIAK_NODE_IN_CLUSTER))\n                        Entities.invokeEffectorWithArgs(this, member, RiakNode.JOIN_RIAK_CLUSTER, (RiakNode)anyNodeInCluster.get());\n                    else\n                        log.error(\"entity {}: is not present\",member.getId());\n                }\n\n                nodes.put(member, riakName);\n                setAttribute(RIAK_CLUSTER_NODES, nodes);\n\n\n            }\n        } else {\n            Map<Entity, String> nodes = getAttribute(RIAK_CLUSTER_NODES);\n            if (nodes != null) {\n\n                String riakNodeName = member.getAttribute(RiakNode.RIAK_NODE_NAME);\n                ((EntityInternal) member).setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, false);\n\n                if (member.getAttribute(RiakNode.RIAK_NODE_IN_CLUSTER))\n                    Entities.invokeEffector(this, member, RiakNode.LEAVE_RIAK_CLUSTER);\n\n                nodes.remove(member);\n\n                setAttribute(RIAK_CLUSTER_NODES, nodes);\n                log.info(\"Removing riak node from {}: {}; {}\", new Object[]{this, member, riakNodeName});\n\n            }\n        }\n        if (log.isTraceEnabled()) log.trace(\"Done {} checkEntity {}\", this, member);\n    }","id":35583,"modified_method":"protected synchronized void onServerPoolMemberChanged(Entity member) {\n        if (log.isTraceEnabled()) log.trace(\"For {}, considering membership of {} which is in locations {}\",\n                new Object[]{this, member, member.getLocations()});\n\n        if (belongsInServerPool(member)) {\n            Map<Entity, String> nodes = getAttribute(RIAK_CLUSTER_NODES);\n            if (nodes == null) nodes = Maps.newLinkedHashMap();\n            String riakName = getRiakName(member);\n\n            if (riakName == null) {\n                log.error(\"Unable to get riak name for node: {}\", member.getId());\n            } else {\n\n                //flag a first node to be the first node in the riak cluster.\n                if (!isFirstNodeSet.get()) {\n                    nodes.put(member, riakName);\n                    setAttribute(RIAK_CLUSTER_NODES, nodes);\n\n                    ((EntityInternal) member).setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, Boolean.TRUE);\n                    isFirstNodeSet.set(true);\n\n                } else {\n                    //TODO: be wary of erreneous nodes but are still flagged 'in cluster'\n                    //add the new node to be part of the riak cluster.\n                    Optional<Entity> anyNodeInCluster = Iterables.tryFind(nodes.keySet(), new Predicate<Entity>() {\n                        @Override\n                        public boolean apply(@Nullable Entity node) {\n                            return (node instanceof RiakNode && node.getAttribute(RiakNode.RIAK_NODE_IN_CLUSTER)) ? true : false;\n                        }\n                    });\n\n                    //invoke join cluster operation on newly added member.\n                    if (anyNodeInCluster.isPresent()) {\n                        if (!isMemberInCluster(member)) {\n                            Entities.invokeEffectorWithArgs(this, member, RiakNode.JOIN_RIAK_CLUSTER, (RiakNode) anyNodeInCluster.get());\n                            nodes.put(member, riakName);\n                            setAttribute(RIAK_CLUSTER_NODES, nodes);\n                            log.info(\"Adding riak node {}: {}; {} to cluster\", new Object[]{this, member, getRiakName(member)});\n                        }\n                    } else {\n                        log.error(\"entity {}: is not present\", member.getId());\n                    }\n                }\n            }\n        } else {\n            Map<Entity, String> nodes = getAttribute(RIAK_CLUSTER_NODES);\n            if (nodes != null) {\n                if (isMemberInCluster(member))\n                    Entities.invokeEffector(this, member, RiakNode.LEAVE_RIAK_CLUSTER);\n\n                nodes.remove(member);\n\n                setAttribute(RIAK_CLUSTER_NODES, nodes);\n                log.info(\"Removing riak node {}: {}; {} from cluster\", new Object[]{this, member, getRiakName(member)});\n\n            }\n        }\n        if (log.isTraceEnabled()) log.trace(\"Done {} checkEntity {}\", this, member);\n    }","commit_id":"7ac08918aa4c615fa9d29b158e512f72f9be513b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void stop() {\n\n        if (entity.getAttribute(RiakNode.RIAK_NODE_IN_CLUSTER))\n            leaveCluster();\n\n        String command = format(\"%s stop\", getRiakCmd());\n        command = isPackageInstall ? \"sudo \" + command : command;\n\n        ScriptHelper stopScript = newScript(STOPPING)\n                .failOnNonZeroResultCode()\n                .body.append(command);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            stopScript.environmentVariablesReset(newPathVariable);\n        }\n\n        stopScript.execute();\n\n    }","id":35584,"modified_method":"@Override\n    public void stop() {\n\n        leaveCluster();\n\n        String command = format(\"%s stop\", getRiakCmd());\n        command = isPackageInstall ? \"sudo \" + command : command;\n\n        ScriptHelper stopScript = newScript(STOPPING)\n                .failOnNonZeroResultCode()\n                .body.append(command);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            stopScript.environmentVariablesReset(newPathVariable);\n        }\n\n        stopScript.execute();\n    }","commit_id":"7ac08918aa4c615fa9d29b158e512f72f9be513b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void launch() {\n\n        String command = format(\"%s start >/dev/null 2>&1 < /dev/null &\", getRiakCmd());\n        command = isPackageInstall ? \"sudo \" + command : command;\n\n        ScriptHelper launchScript = newScript(LAUNCHING)\n                .failOnNonZeroResultCode()\n                .body.append(command);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            launchScript.environmentVariablesReset(newPathVariable);\n        }\n\n        launchScript.execute();\n    }","id":35585,"modified_method":"@Override\n    public void launch() {\n\n        String command = format(\"%s start >/dev/null 2>&1 < /dev/null &\", getRiakCmd());\n        command = isPackageInstall ? \"sudo \" + command : command;\n\n        ScriptHelper launchScript = newScript(LAUNCHING)\n                .body.append(command);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            launchScript.environmentVariablesReset(newPathVariable);\n        }\n\n        launchScript.execute();\n    }","commit_id":"7ac08918aa4c615fa9d29b158e512f72f9be513b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void customize() {\n\n        isRiakOnPath = isPackageInstall ? isRiakOnPath() : true;\n\n        OsDetails osDetails = getMachine().getMachineDetails().getOsDetails();\n        List<String> commands = Lists.newLinkedList();\n\n        String vmArgsTemplate = processTemplate(entity.getConfig(RiakNode.RIAK_VM_ARGS_TEMPLATE_URL));\n\n        //create entity's runDir\n        DynamicTasks.queueIfPossible(newScript(CUSTOMIZING).body.append(\"true\").newTask());\n\n        DynamicTasks.queueIfPossible(SshEffectorTasks.put(getRunDir() + \"/vm.args\")\n                .contents(Streams.newInputStreamWithContents(vmArgsTemplate))\n                .machine(getMachine())\n                .summary(\"sending the vm.args file to the riak node\"));\n\n        //increase open file limit (default min for riak is: 4096)\n        //TODO: detect the actual limit then do the modificaiton.\n        //TODO: modify ulimit for linux distros\n        //    commands.add(sudo(\"launchctl limit maxfiles 4096 32768\"));\n        if (osDetails.isMac())\n            commands.add(\"ulimit -n 4096\");\n        else if (osDetails.isLinux()) {\n            commands.add(sudo(\"chown riak:riak \" + getRunDir() + \"/vm.args\"));\n        }\n\n        commands.add(sudo(\"mv \" + getRunDir() + \"/vm.args \" + getEtcDir()));\n\n        //FIXME EC2 requires to configure the private IP in order for the riak node to work.\n        //replace instances of 127.0.0.1 with the actual hostname in the app.config and vm.args files\n        commands.add(sudo(format(\"sed -i -e \\\"s/127.0.0.1/%s/g\\\" %s\", getPrivateIp(), getAppConfigLocation())));\n\n        ScriptHelper customizeScript = newScript(CUSTOMIZING)\n                .failOnNonZeroResultCode()\n                .body.append(commands);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            customizeScript.environmentVariablesReset(newPathVariable);\n        }\n\n        customizeScript.execute();\n\n        //set the riak node name\n        entity.setAttribute(RiakNode.RIAK_NODE_NAME, format(\"riak@%s\", getHostname()));\n\n    }","id":35586,"modified_method":"@Override\n    public void customize() {\n\n        isRiakOnPath = isPackageInstall ? isRiakOnPath() : true;\n\n        OsDetails osDetails = getMachine().getMachineDetails().getOsDetails();\n        List<String> commands = Lists.newLinkedList();\n\n        String vmArgsTemplate = processTemplate(entity.getConfig(RiakNode.RIAK_VM_ARGS_TEMPLATE_URL));\n        String saveAsVmArgs = Urls.mergePaths(getRunDir(), \"vm.args\");\n        //create entity's runDir\n        newScript(CUSTOMIZING).execute();\n\n\n        DynamicTasks.queueIfPossible(SshEffectorTasks.put(saveAsVmArgs)\n                .contents(Streams.newInputStreamWithContents(vmArgsTemplate))\n                .machine(getMachine())\n                .summary(\"sending the vm.args file to the riak node\"));\n\n        commands.add(sudo(\"mv \" + saveAsVmArgs + \" \" + getEtcDir()));\n\n        //increase open file limit (default min for riak is: 4096)\n        //TODO: detect the actual limit then do the modificaiton.\n        //TODO: modify ulimit for linux distros\n        //    commands.add(sudo(\"launchctl limit maxfiles 4096 32768\"));\n        if (osDetails.isMac()) {\n            commands.add(\"ulimit -n 4096\");\n        } else if (osDetails.isLinux()) {\n            commands.add(sudo(\"chown riak:riak \" + getVmArgsLocation()));\n        }\n\n        //FIXME EC2 requires to configure the private IP in order for the riak node to work.\n        //replace instances of 127.0.0.1 with the actual hostname in the app.config and vm.args files\n        commands.add(sudo(format(\"sed -i -e \\\"s/127.0.0.1/%s/g\\\" %s\", getPrivateIp(), getAppConfigLocation())));\n\n        ScriptHelper customizeScript = newScript(CUSTOMIZING)\n                .failOnNonZeroResultCode()\n                .body.append(commands);\n\n        if (!isRiakOnPath) {\n            Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n            log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n            customizeScript.environmentVariablesReset(newPathVariable);\n        }\n\n        customizeScript.execute();\n\n        //set the riak node name\n        entity.setAttribute(RiakNode.RIAK_NODE_NAME, format(\"riak@%s\", getHostname()));\n    }","commit_id":"7ac08918aa4c615fa9d29b158e512f72f9be513b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void install() {\n        DownloadResolver resolver = Entities.newDownloader(this);\n        String saveAs = resolver.getFilename();\n        String expandedInstallDir = getInstallDir() + \"/\" + resolver.getUnpackedDirectoryName(format(\"riak-%s\", getVersion()));\n        setExpandedInstallDir(expandedInstallDir);\n\n        OsDetails osDetails = getMachine().getMachineDetails().getOsDetails();\n        List<String> commands = Lists.newLinkedList();\n        if (osDetails.isLinux()) {\n            commands.addAll(installLinux(expandedInstallDir));\n        } else if (osDetails.isMac()) {\n            commands.addAll(installMac(saveAs));\n        } else if (osDetails.isWindows()) {\n            throw new UnsupportedOperationException(\"RiakNode not supported on Windows instances\");\n        } else {\n            throw new IllegalStateException(\"Machine was not detected as linux, mac or windows! Installation does not know how to proceed with \" +\n                    getMachine() + \". Details: \" + getMachine().getMachineDetails().getOsDetails());\n        }\n        newScript(INSTALLING)\n                .failOnNonZeroResultCode()\n                .body.append(commands)\n                .execute();\n\n    }","id":35587,"modified_method":"@Override\n    public void install() {\n        DownloadResolver resolver = Entities.newDownloader(this);\n        String saveAs = resolver.getFilename();\n        String expandedInstallDir = getInstallDir() + \"/\" + resolver.getUnpackedDirectoryName(format(\"riak-%s\", getVersion()));\n        setExpandedInstallDir(expandedInstallDir);\n\n        OsDetails osDetails = getMachine().getMachineDetails().getOsDetails();\n        List<String> commands = Lists.newLinkedList();\n        if (osDetails.isLinux()) {\n            commands.addAll(installLinux(expandedInstallDir));\n        } else if (osDetails.isMac()) {\n            commands.addAll(installMac(saveAs));\n        } else if (osDetails.isWindows()) {\n            throw new UnsupportedOperationException(\"RiakNode not supported on Windows instances\");\n        } else {\n            throw new IllegalStateException(\"Machine was not detected as linux, mac or windows! Installation does not know how to proceed with \" +\n                    getMachine() + \". Details: \" + getMachine().getMachineDetails().getOsDetails());\n        }\n        newScript(INSTALLING)\n                .body.append(commands)\n                .execute();\n    }","commit_id":"7ac08918aa4c615fa9d29b158e512f72f9be513b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void leaveCluster() {\n        //TODO: add 'riak-admin cluster force-remove' for erreneous and unrecoverable nodes.\n        //FIXME: find a way to batch commit the changes, instead of committing for every operation.\n\n        if (isInCluster()) {\n            ScriptHelper leaveClusterScript = newScript(\"leaveCluster\")\n                    .body.append(format(\"%s cluster leave\"))\n                    .body.append(format(\"%s cluster plan\", getRiakAdminCmd()))\n                    .body.append(format(\"%s cluster commit\", getRiakAdminCmd()))\n                    .failOnNonZeroResultCode();\n\n            if (!isRiakOnPath) {\n                Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n                log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n                leaveClusterScript.environmentVariablesReset(newPathVariable);\n            }\n\n            leaveClusterScript.execute();\n\n\n            entity.setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, Boolean.FALSE);\n\n\n        } else {\n            log.warn(\"entity {}: is not in the riak Cluster\", entity.getId());\n        }\n    }","id":35588,"modified_method":"@Override\n    public void leaveCluster() {\n        //TODO: add 'riak-admin cluster force-remove' for erreneous and unrecoverable nodes.\n        //FIXME: find a way to batch commit the changes, instead of committing for every operation.\n        //FIXME: check if only node in cluster then don't execute the leave script.\n        if (isInCluster()) {\n            ScriptHelper leaveClusterScript = newScript(\"leaveCluster\")\n                    .body.append(format(\"%s cluster leave\", getRiakAdminCmd()))\n                    .body.append(format(\"%s cluster plan\", getRiakAdminCmd()))\n                    .body.append(format(\"%s cluster commit\", getRiakAdminCmd()))\n                    .failOnNonZeroResultCode();\n\n            if (!isRiakOnPath) {\n                Map<String, String> newPathVariable = ImmutableMap.of(\"PATH\", sbinPath);\n                log.warn(\"riak command not found on PATH. Altering future commands' environment variables from {} to {}\", getShellEnvironment(), newPathVariable);\n                leaveClusterScript.environmentVariablesReset(newPathVariable);\n            }\n\n            leaveClusterScript.execute();\n\n            entity.setAttribute(RiakNode.RIAK_NODE_IN_CLUSTER, Boolean.FALSE);\n        } else {\n            log.warn(\"entity {}: is not in the riak Cluster\", entity.getId());\n        }\n    }","commit_id":"7ac08918aa4c615fa9d29b158e512f72f9be513b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void addServers(Set<Entity> serversToAdd) {\n        //FIXME: disambiguate between method names to differentiate between the stage phase and commit phase.\n        log.info(\"adding the SERVICE_UP couchbase nodes to the cluster..\");\n\n        if (!serversToAdd.isEmpty()) {\n            for (Entity e : serversToAdd) {\n                if (!isMemberInCluster(e)) {\n                    String hostname = e.getAttribute(Attributes.HOSTNAME) + \":\" + e.getConfig(CouchbaseNode.COUCHBASE_WEB_ADMIN_PORT).iterator().next();\n                    String username = e.getConfig(CouchbaseNode.COUCHBASE_ADMIN_USERNAME);\n                    String password = e.getConfig(CouchbaseNode.COUCHBASE_ADMIN_PASSWORD);\n\n                    Entities.invokeEffectorWithArgs(this, getPrimaryNode(), CouchbaseNode.SERVER_ADD, hostname, username, password);\n                    //FIXME check feedback of whether the server was added.\n                    ((EntityInternal) e).setAttribute(CouchbaseNode.IS_IN_CLUSTER, true);\n                }\n            }\n        } else {\n            log.warn(\"no servers to be added on the cluster: {}\", this);\n        }\n    }","id":35589,"modified_method":"protected void addServers(Set<Entity> serversToAdd) {\n        Preconditions.checkNotNull(serversToAdd);\n        for (Entity e : serversToAdd) {\n            if (!isMemberInCluster(e)) {\n                addServer(e);\n            }\n        }\n    }","commit_id":"02af3ebd6968617428c666ec040e9c392e4026c7","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected synchronized void onServerPoolMemberChanged(Entity member) {\n        if (log.isTraceEnabled()) log.trace(\"For {}, considering membership of {} which is in locations {}\",\n                new Object[]{this, member, member.getLocations()});\n\n        //FIXME: make use of servers to be added after cluster initialization.\n        synchronized (mutex) {\n            if (belongsInServerPool(member)) {\n\n                Optional<Set<Entity>> upNodes = Optional.fromNullable(getUpNodes());\n                if (upNodes.isPresent()) {\n\n                    if (!upNodes.get().contains(member)) {\n                        Set<Entity> newNodes = Sets.newHashSet(getUpNodes());\n                        newNodes.add(member);\n                        setAttribute(COUCHBASE_CLUSTER_UP_NODES, newNodes);\n\n                        //add to set of servers to be added.\n                        if (isClusterInitialized()) {\n                            addServer(member);\n                        }\n                    } else {\n                        log.warn(\"Node already in cluster up nodes {}: {};\", this, member);\n                    }\n                } else {\n                    Set<Entity> newNodes = Sets.newHashSet();\n                    newNodes.add(member);\n                    setAttribute(COUCHBASE_CLUSTER_UP_NODES, newNodes);\n\n                    if (isClusterInitialized()) {\n                        addServer(member);\n                    }\n                }\n            } else {\n                Set<Entity> upNodes = getUpNodes();\n                if (upNodes != null && upNodes.contains(member)) {\n                    upNodes.remove(member);\n                    setAttribute(COUCHBASE_CLUSTER_UP_NODES, upNodes);\n                    log.info(\"Removing couchbase node {}: {}; from cluster\", new Object[]{this, member});\n                }\n            }\n            if (log.isTraceEnabled()) log.trace(\"Done {} checkEntity {}\", this, member);\n        }\n    }","id":35590,"modified_method":"protected synchronized void onServerPoolMemberChanged(Entity member) {\n        if (log.isTraceEnabled()) log.trace(\"For {}, considering membership of {} which is in locations {}\",\n                new Object[]{this, member, member.getLocations()});\n\n        //FIXME: make use of servers to be added after cluster initialization.\n        synchronized (mutex) {\n            if (belongsInServerPool(member)) {\n\n                Optional<Set<Entity>> upNodes = Optional.fromNullable(getUpNodes());\n                if (upNodes.isPresent()) {\n\n                    if (!upNodes.get().contains(member)) {\n                        Set<Entity> newNodes = Sets.newHashSet(getUpNodes());\n                        newNodes.add(member);\n                        setAttribute(COUCHBASE_CLUSTER_UP_NODES, newNodes);\n\n                        //add to set of servers to be added.\n                        if (isClusterInitialized()) {\n                            addServer(member);\n                        }\n                    }\n                } else {\n                    Set<Entity> newNodes = Sets.newHashSet();\n                    newNodes.add(member);\n                    setAttribute(COUCHBASE_CLUSTER_UP_NODES, newNodes);\n\n                    if (isClusterInitialized()) {\n                        addServer(member);\n                    }\n                }\n            } else {\n                Set<Entity> upNodes = getUpNodes();\n                if (upNodes != null && upNodes.contains(member)) {\n                    upNodes.remove(member);\n                    setAttribute(COUCHBASE_CLUSTER_UP_NODES, upNodes);\n                    log.info(\"Removing couchbase node {}: {}; from cluster\", new Object[]{this, member});\n                }\n            }\n            if (log.isTraceEnabled()) log.trace(\"Done {} checkEntity {}\", this, member);\n        }\n    }","commit_id":"02af3ebd6968617428c666ec040e9c392e4026c7","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected void addServer(Entity serverToAdd) {\n\n        if (!isMemberInCluster(serverToAdd)) {\n            String hostname = serverToAdd.getAttribute(Attributes.HOSTNAME) + \":\" + serverToAdd.getConfig(CouchbaseNode.COUCHBASE_WEB_ADMIN_PORT).iterator().next();\n            String username = serverToAdd.getConfig(CouchbaseNode.COUCHBASE_ADMIN_USERNAME);\n            String password = serverToAdd.getConfig(CouchbaseNode.COUCHBASE_ADMIN_PASSWORD);\n\n            Entities.invokeEffectorWithArgs(this, getPrimaryNode(), CouchbaseNode.SERVER_ADD, hostname, username, password);\n            //FIXME check feedback of whether the server was added.\n            ((EntityInternal) serverToAdd).setAttribute(CouchbaseNode.IS_IN_CLUSTER, true);\n        }\n    }","id":35591,"modified_method":"protected void addServer(Entity serverToAdd) {\n        Preconditions.checkNotNull(serverToAdd);\n        if (!isMemberInCluster(serverToAdd)) {\n            String hostname = serverToAdd.getAttribute(Attributes.HOSTNAME) + \":\" + serverToAdd.getConfig(CouchbaseNode.COUCHBASE_WEB_ADMIN_PORT).iterator().next();\n            String username = serverToAdd.getConfig(CouchbaseNode.COUCHBASE_ADMIN_USERNAME);\n            String password = serverToAdd.getConfig(CouchbaseNode.COUCHBASE_ADMIN_PASSWORD);\n\n            if (isClusterInitialized()) {\n                Entities.invokeEffectorWithArgs(this, getPrimaryNode(), CouchbaseNode.SERVER_ADD_AND_REBALANCE, hostname, username, password);\n            } else {\n                Entities.invokeEffectorWithArgs(this, getPrimaryNode(), CouchbaseNode.SERVER_ADD, hostname, username, password);\n            }\n            //FIXME check feedback of whether the server was added.\n            ((EntityInternal) serverToAdd).setAttribute(CouchbaseNode.IS_IN_CLUSTER, true);\n        }\n    }","commit_id":"02af3ebd6968617428c666ec040e9c392e4026c7","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void connectSensors() {\n        super.connectSensors();\n        connectServiceUpIsRunning();\n                \n        Integer rawPort = getAttribute(CouchbaseNode.COUCHBASE_WEB_ADMIN_PORT);\n        Preconditions.checkNotNull(rawPort, \"HTTP_PORT sensors not set for %s; is an acceptable port available?\", this);\n        HostAndPort hp = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, rawPort);\n        \n        String adminUrl = String.format(\"http://%s:%s\", hp.getHostText(), hp.getPort());\n        \n        httpFeed = HttpFeed.builder()\n            .entity(this)\n            .period(1000)\n            .baseUri(adminUrl + \"/pools/nodes/\")\n            .credentialsIfNotNull(getConfig(CouchbaseNode.COUCHBASE_ADMIN_USERNAME), getConfig(CouchbaseNode.COUCHBASE_ADMIN_PASSWORD))\n            .poll(getSensorFromNodeStat(CouchbaseNode.OPS, \"ops\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_DOCS_DATA_SIZE, \"couch_docs_data_size\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_DOCS_ACTUAL_DISK_SIZE, \"couch_docs_actual_disk_size\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.EP_BG_FETCHED, \"ep_bg_fetched\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.MEM_USED, \"mem_used\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_VIEWS_ACTUAL_DISK_SIZE, \"couch_views_actual_disk_size\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.CURR_ITEMS, \"curr_items\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.VB_REPLICA_CURR_ITEMS, \"vb_replica_curr_items\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_VIEWS_DATA_SIZE, \"couch_views_data_size\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.GET_HITS, \"get_hits\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.CMD_GET, \"cmd_get\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.CURR_ITEMS_TOT, \"curr_items_tot\"))\n            .build();\n    }","id":35592,"modified_method":"public void connectSensors() {\n        super.connectSensors();\n        connectServiceUpIsRunning();\n                \n        Integer rawPort = getAttribute(CouchbaseNode.COUCHBASE_WEB_ADMIN_PORT);\n        Preconditions.checkNotNull(rawPort, \"HTTP_PORT sensors not set for %s; is an acceptable port available?\", this);\n        HostAndPort hp = BrooklynAccessUtils.getBrooklynAccessibleAddress(this, rawPort);\n        \n        String adminUrl = String.format(\"http://%s:%s\", hp.getHostText(), hp.getPort());\n        \n        httpFeed = HttpFeed.builder()\n            .entity(this)\n            .period(1000)\n            .baseUri(adminUrl + \"/pools/nodes/\")\n            .credentialsIfNotNull(getConfig(CouchbaseNode.COUCHBASE_ADMIN_USERNAME), getConfig(CouchbaseNode.COUCHBASE_ADMIN_PASSWORD))\n            .poll(getSensorFromNodeStat(CouchbaseNode.OPS, \"ops\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_DOCS_DATA_SIZE, \"couch_docs_data_size\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_DOCS_ACTUAL_DISK_SIZE, \"couch_docs_actual_disk_size\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.EP_BG_FETCHED, \"ep_bg_fetched\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.MEM_USED, \"mem_used\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_VIEWS_ACTUAL_DISK_SIZE, \"couch_views_actual_disk_size\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.CURR_ITEMS, \"curr_items\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.VB_REPLICA_CURR_ITEMS, \"vb_replica_curr_items\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.COUCH_VIEWS_DATA_SIZE, \"couch_views_data_size\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.GET_HITS, \"get_hits\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.CMD_GET, \"cmd_get\"))\n            .poll(getSensorFromNodeStat(CouchbaseNode.CURR_ITEMS_TOT, \"curr_items_tot\"))\n            .poll(new HttpPollConfig<String>(CouchbaseNode.REBALANCE_STATUS)\n                        .onSuccess(HttpValueFunctions.jsonContents(\"rebalanceStatus\", String.class))\n                        .onFailureOrException(Functions.constant(\"Could not retrieve\")))\n            .build();\n    }","commit_id":"02af3ebd6968617428c666ec040e9c392e4026c7","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void serverAddAndRebalance(String serverToAdd, String username, String password) {\n        newScript(\"serverAddAndRebalance\").body.append(couchbaseCli(\"rebalance\")\n                + getCouchbaseHostnameAndCredentials() +\n                \" --server-add=\" + serverToAdd +\n                \" --server-add-username=\" + username +\n                \" --server-add-password=\" + password)\n                .failOnNonZeroResultCode()\n                .execute();\n    }","id":35593,"modified_method":"@Override\n    public void serverAddAndRebalance(String serverToAdd, String username, String password) {\n        newScript(\"serverAddAndRebalance\").body.append(couchbaseCli(\"rebalance\")\n                + getCouchbaseHostnameAndCredentials() +\n                \" --server-add=\" + serverToAdd +\n                \" --server-add-username=\" + username +\n                \" --server-add-password=\" + password)\n                .failOnNonZeroResultCode()\n                .execute();\n        entity.setAttribute(CouchbaseNode.REBALANCE_STATUS, \"Rebalance Started\");\n    }","commit_id":"02af3ebd6968617428c666ec040e9c392e4026c7","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n    public void rebalance() {\n        newScript(\"rebalance\")\n                .body.append(\n                couchbaseCli(\"rebalance\") +\n                        getCouchbaseHostnameAndCredentials())\n                .failOnNonZeroResultCode()\n                .execute();\n    }","id":35594,"modified_method":"@Override\n    public void rebalance() {\n        newScript(\"rebalance\")\n                .body.append(\n                couchbaseCli(\"rebalance\") +\n                        getCouchbaseHostnameAndCredentials())\n                .failOnNonZeroResultCode()\n                .execute();\n        entity.setAttribute(CouchbaseNode.REBALANCE_STATUS, \"Rebalance Started\");\n    }","commit_id":"02af3ebd6968617428c666ec040e9c392e4026c7","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Generic method to parse and translate a rule into SQL.\n     *\n     * Only columns listed in database-schema.xml may be used in a filter\n     * (explicit \"table.column\" specification is not supported in filters)\n     *\n     * To differentiate column names from SQL key words (operators, functions, typecasts, etc)\n     * sqlKeyWordRegex must match any SQL key words that may be used in filters,\n     * and must not match any column names or prefixed values\n     *\n     * To make filter syntax more simple and intuitive than SQL\n     * - Filters support some aliases for common SQL key words / operators\n     *    \"&amp;\" or \"&amp;&amp;\" = \"AND\"\n     *    \"|\" or \"||\" = \"OR\"\n     *    \"!\" = \"NOT\"\n     *    \"==\" = \"=\"\n     * - \"IPLIKE\" may be used as an operator instead of a function in filters (\"ipAddr IPLIKE '*.*.*.*'\")\n     *   When using \"IPLIKE\" as an operator, the value does not have to be quoted (\"ipAddr IPLIKE *.*.*.*\" is ok)\n     * - Some common SQL expressions may be generated by adding a (lower-case) prefix to an unquoted value in the filter\n     *    \"isVALUE\" = \"serviceName = VALUE\"\n     *    \"notisVALUE\" = interface does not support the specified service\n     *    \"catincVALUE\" = node is in the specified category\n     * - Double-quoted (\") strings in filters are converted to single-quoted (') strings in SQL\n     *   SQL treats single-quoted strings as constants (values) and double-quoted strings as identifiers (columns, tables, etc)\n     *   So, all quoted strings in filters are treated as constants, and filters don't support quoted identifiers\n     *\n     * This function does not do complete syntax/grammar checking - that is left to the database itself - do not assume the output is valid SQL\n     *\n     * @param tables\n     *            a list to be populated with any tables referenced by the returned SQL\n     * @param rule\n     *            the rule to parse\n     *\n     * @return an SQL WHERE clause\n     *\n     * @throws FilterParseException\n     *             if any errors occur during parsing\n     */\n    private String parseRule(List<Table> tables, String rule) throws FilterParseException {\n        if (rule != null && rule.length() > 0) {\n            String sqlRule = new String(rule);\n            Matcher regex;\n            List<String> extractedStrings = new ArrayList<String>();\n            StringBuffer tempStringBuff;\n\n            // Extract quoted strings from rule and convert double-quoted strings to single-quoted strings\n            // Quoted strings need to be extracted first to avoid accidentally matching/modifying anything within them\n            // As in SQL, pairs of quotes within a quoted string are treated as an escaped quote character:\n            //  'a''b' = a'b ; \"a\"\"b\" = a\"b ; 'a\"b' = a\"b ; \"a'b\" = a'b\n            regex = Pattern.compile(\"'(?:[^']|'')*'|\\\"(?:[^\\\"]|\\\"\\\")*\\\"\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                String tempString = regex.group();\n                if (tempString.charAt(0) == '\"') {\n                    extractedStrings.add(\"'\" + tempString.substring(1, tempString.length() - 1).replaceAll(\"\\\"\\\"\", \"\\\"\").replaceAll(\"'\", \"''\") + \"'\");\n                } else {\n                    extractedStrings.add(regex.group());\n                }\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            int tempIndex = tempStringBuff.length();\n            regex.appendTail(tempStringBuff);\n            if (tempStringBuff.substring(tempIndex).indexOf('\\'') > -1) {\n                log().error(\"Unmatched ' in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched ' in filter rule '\" + rule + \"'\");\n            }\n            if (tempStringBuff.substring(tempIndex).indexOf('\"') > -1) {\n                log().error(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n            }\n            sqlRule = tempStringBuff.toString();\n\n            // Translate filter-specific operators to SQL operators\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:&|&&)\\\\s*\", \" AND \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:\\\\||\\\\|\\\\|)\\\\s*\", \" OR \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*!(?!=)\\\\s*\", \" NOT \");\n            sqlRule = sqlRule.replaceAll(\"==\", \"=\");\n\n            // Translate IPLIKE operators to IPLIKE() functions\n            // If IPLIKE is already used as a function in the filter, this regex should not match it\n            regex = Pattern.compile(\"(\\\\w+)\\\\s+IPLIKE\\\\s+([0-9.*,-]+|###@\\\\d+@###)\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Is the second argument already a quoted string?\n                if (regex.group().charAt(0) == '#') {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, $2)\");\n                } else {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, '$2')\");\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Extract SQL key words to avoid identifying them as columns or prefixed values\n            regex = Pattern.compile(sqlKeyWordRegex, Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                extractedStrings.add(regex.group().toUpperCase());\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Identify prefixed values and columns\n            regex = Pattern.compile(\"[a-zA-Z0-9_\\\\-]*[a-zA-Z][a-zA-Z0-9_\\\\-]*\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Convert prefixed values to SQL expressions\n                if (regex.group().startsWith(\"is\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"serviceName\") + \" = '\" + regex.group().substring(2) + \"'\");\n                } else if (regex.group().startsWith(\"notis\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"ipAddr\") + \" NOT IN (SELECT ifServices.ipAddr FROM ifServices, service WHERE service.serviceName ='\" + regex.group().substring(5) + \"' AND service.serviceID = ifServices.serviceID)\");\n                } else if (regex.group().startsWith(\"catinc\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"nodeID\") + \" IN (SELECT category_node.nodeID FROM category_node, categories WHERE categories.categoryID = category_node.categoryID AND categories.categoryName = '\" + regex.group().substring(6) + \"')\");\n                } else {\n                    // Call addColumn() on each column\n                    regex.appendReplacement(tempStringBuff, addColumn(tables, regex.group()));\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Merge extracted strings back into expression\n            regex = Pattern.compile(\"###@(\\\\d+)@###\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find())\n                regex.appendReplacement(tempStringBuff, regex.quoteReplacement(extractedStrings.get(Integer.parseInt(regex.group(1)))));\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            return \"WHERE \" + sqlRule;\n        }\n        return \"\";\n    }","id":35595,"modified_method":"/**\n     * Generic method to parse and translate a rule into SQL.\n     *\n     * Only columns listed in database-schema.xml may be used in a filter\n     * (explicit \"table.column\" specification is not supported in filters)\n     *\n     * To differentiate column names from SQL key words (operators, functions, typecasts, etc)\n     * sqlKeyWordRegex must match any SQL key words that may be used in filters,\n     * and must not match any column names or prefixed values\n     *\n     * To make filter syntax more simple and intuitive than SQL\n     * - Filters support some aliases for common SQL key words / operators\n     *    \"&amp;\" or \"&amp;&amp;\" = \"AND\"\n     *    \"|\" or \"||\" = \"OR\"\n     *    \"!\" = \"NOT\"\n     *    \"==\" = \"=\"\n     * - \"IPLIKE\" may be used as an operator instead of a function in filters (\"ipAddr IPLIKE '*.*.*.*'\")\n     *   When using \"IPLIKE\" as an operator, the value does not have to be quoted (\"ipAddr IPLIKE *.*.*.*\" is ok)\n     * - Some common SQL expressions may be generated by adding a (lower-case) prefix to an unquoted value in the filter\n     *    \"isVALUE\" = \"serviceName = VALUE\"\n     *    \"notisVALUE\" = interface does not support the specified service\n     *    \"catincVALUE\" = node is in the specified category\n     * - Double-quoted (\") strings in filters are converted to single-quoted (') strings in SQL\n     *   SQL treats single-quoted strings as constants (values) and double-quoted strings as identifiers (columns, tables, etc)\n     *   So, all quoted strings in filters are treated as constants, and filters don't support quoted identifiers\n     *\n     * This function does not do complete syntax/grammar checking - that is left to the database itself - do not assume the output is valid SQL\n     *\n     * @param tables\n     *            a list to be populated with any tables referenced by the returned SQL\n     * @param rule\n     *            the rule to parse\n     *\n     * @return an SQL WHERE clause\n     *\n     * @throws FilterParseException\n     *             if any errors occur during parsing\n     */\n    private String parseRule(List<Table> tables, String rule) throws FilterParseException {\n        if (rule != null && rule.length() > 0) {\n            String sqlRule = new String(rule);\n            Matcher regex;\n            List<String> extractedStrings = new ArrayList<String>();\n            StringBuffer tempStringBuff;\n\n            // Extract quoted strings from rule and convert double-quoted strings to single-quoted strings\n            // Quoted strings need to be extracted first to avoid accidentally matching/modifying anything within them\n            // As in SQL, pairs of quotes within a quoted string are treated as an escaped quote character:\n            //  'a''b' = a'b ; \"a\"\"b\" = a\"b ; 'a\"b' = a\"b ; \"a'b\" = a'b\n            regex = Pattern.compile(\"'(?:[^']|'')*'|\\\"(?:[^\\\"]|\\\"\\\")*\\\"\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                String tempString = regex.group();\n                if (tempString.charAt(0) == '\"') {\n                    extractedStrings.add(\"'\" + tempString.substring(1, tempString.length() - 1).replaceAll(\"\\\"\\\"\", \"\\\"\").replaceAll(\"'\", \"''\") + \"'\");\n                } else {\n                    extractedStrings.add(regex.group());\n                }\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            int tempIndex = tempStringBuff.length();\n            regex.appendTail(tempStringBuff);\n            if (tempStringBuff.substring(tempIndex).indexOf('\\'') > -1) {\n                log().error(\"Unmatched ' in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched ' in filter rule '\" + rule + \"'\");\n            }\n            if (tempStringBuff.substring(tempIndex).indexOf('\"') > -1) {\n                log().error(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n            }\n            sqlRule = tempStringBuff.toString();\n\n            // Translate filter-specific operators to SQL operators\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:&|&&)\\\\s*\", \" AND \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:\\\\||\\\\|\\\\|)\\\\s*\", \" OR \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*!(?!=)\\\\s*\", \" NOT \");\n            sqlRule = sqlRule.replaceAll(\"==\", \"=\");\n\n            // Translate IPLIKE operators to IPLIKE() functions\n            // If IPLIKE is already used as a function in the filter, this regex should not match it\n            regex = Pattern.compile(\"(\\\\w+)\\\\s+IPLIKE\\\\s+([0-9.*,-]+|###@\\\\d+@###)\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Is the second argument already a quoted string?\n                if (regex.group().charAt(0) == '#') {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, $2)\");\n                } else {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, '$2')\");\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Extract SQL key words to avoid identifying them as columns or prefixed values\n            regex = Pattern.compile(sqlKeyWordRegex, Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                extractedStrings.add(regex.group().toUpperCase());\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Identify prefixed values and columns\n            regex = Pattern.compile(\"[a-zA-Z0-9_\\\\-]*[a-zA-Z][a-zA-Z0-9_\\\\-]*\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Convert prefixed values to SQL expressions\n                if (regex.group().startsWith(\"is\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"serviceName\") + \" = '\" + regex.group().substring(2) + \"'\");\n                } else if (regex.group().startsWith(\"notis\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"ipAddr\") + \" NOT IN (SELECT ifServices.ipAddr FROM ifServices, service WHERE service.serviceName ='\" + regex.group().substring(5) + \"' AND service.serviceID = ifServices.serviceID)\");\n                } else if (regex.group().startsWith(\"catinc\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"nodeID\") + \" IN (SELECT category_node.nodeID FROM category_node, categories WHERE categories.categoryID = category_node.categoryID AND categories.categoryName = '\" + regex.group().substring(6) + \"')\");\n                } else {\n                    // Call addColumn() on each column\n                    regex.appendReplacement(tempStringBuff, addColumn(tables, regex.group()));\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Merge extracted strings back into expression\n            regex = Pattern.compile(\"###@(\\\\d+)@###\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                regex.appendReplacement(tempStringBuff, Matcher.quoteReplacement(extractedStrings.get(Integer.parseInt(regex.group(1)))));\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            return \"WHERE \" + sqlRule;\n        }\n        return \"\";\n    }","commit_id":"90c2def6d3d3e8f5facbbd7992633995eccb6f42","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Generic method to parse and translate a rule into SQL.\n     *\n     * Only columns listed in database-schema.xml may be used in a filter\n     * (explicit \"table.column\" specification is not supported in filters)\n     *\n     * To differentiate column names from SQL key words (operators, functions, typecasts, etc)\n     * sqlKeyWordRegex must match any SQL key words that may be used in filters,\n     * and must not match any column names or prefixed values\n     *\n     * To make filter syntax more simple and intuitive than SQL\n     * - Filters support some aliases for common SQL key words / operators\n     *    \"&amp;\" or \"&amp;&amp;\" = \"AND\"\n     *    \"|\" or \"||\" = \"OR\"\n     *    \"!\" = \"NOT\"\n     *    \"==\" = \"=\"\n     * - \"IPLIKE\" may be used as an operator instead of a function in filters (\"ipAddr IPLIKE '*.*.*.*'\")\n     *   When using \"IPLIKE\" as an operator, the value does not have to be quoted (\"ipAddr IPLIKE *.*.*.*\" is ok)\n     * - Some common SQL expressions may be generated by adding a (lower-case) prefix to an unquoted value in the filter\n     *    \"isVALUE\" = \"serviceName = VALUE\"\n     *    \"notisVALUE\" = interface does not support the specified service\n     *    \"catincVALUE\" = node is in the specified category\n     * - Double-quoted (\") strings in filters are converted to single-quoted (') strings in SQL\n     *   SQL treats single-quoted strings as constants (values) and double-quoted strings as identifiers (columns, tables, etc)\n     *   So, all quoted strings in filters are treated as constants, and filters don't support quoted identifiers\n     *\n     * This function does not do complete syntax/grammar checking - that is left to the database itself - do not assume the output is valid SQL\n     *\n     * @param tables\n     *            a list to be populated with any tables referenced by the returned SQL\n     * @param rule\n     *            the rule to parse\n     *\n     * @return an SQL WHERE clause\n     *\n     * @throws FilterParseException\n     *             if any errors occur during parsing\n     */\n    private String parseRule(List<Table> tables, String rule) throws FilterParseException {\n        if (rule != null && rule.length() > 0) {\n            String sqlRule = new String(rule);\n            Matcher regex;\n            List<String> extractedStrings = new ArrayList<String>();\n            StringBuffer tempStringBuff;\n\n            // Extract quoted strings from rule and convert double-quoted strings to single-quoted strings\n            // Quoted strings need to be extracted first to avoid accidentally matching/modifying anything within them\n            // As in SQL, pairs of quotes within a quoted string are treated as an escaped quote character:\n            //  'a''b' = a'b ; \"a\"\"b\" = a\"b ; 'a\"b' = a\"b ; \"a'b\" = a'b\n            regex = Pattern.compile(\"'(?:[^']|'')*'|\\\"(?:[^\\\"]|\\\"\\\")*\\\"\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                String tempString = regex.group();\n                if (tempString.charAt(0) == '\"') {\n                    extractedStrings.add(\"'\" + tempString.substring(1, tempString.length() - 1).replaceAll(\"\\\"\\\"\", \"\\\"\").replaceAll(\"'\", \"''\") + \"'\");\n                } else {\n                    extractedStrings.add(regex.group());\n                }\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            int tempIndex = tempStringBuff.length();\n            regex.appendTail(tempStringBuff);\n            if (tempStringBuff.substring(tempIndex).indexOf('\\'') > -1) {\n                log().error(\"Unmatched ' in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched ' in filter rule '\" + rule + \"'\");\n            }\n            if (tempStringBuff.substring(tempIndex).indexOf('\"') > -1) {\n                log().error(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n            }\n            sqlRule = tempStringBuff.toString();\n\n            // Translate filter-specific operators to SQL operators\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:&|&&)\\\\s*\", \" AND \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:\\\\||\\\\|\\\\|)\\\\s*\", \" OR \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*!(?!=)\\\\s*\", \" NOT \");\n            sqlRule = sqlRule.replaceAll(\"==\", \"=\");\n\n            // Translate IPLIKE operators to IPLIKE() functions\n            // If IPLIKE is already used as a function in the filter, this regex should not match it\n            regex = Pattern.compile(\"(\\\\w+)\\\\s+IPLIKE\\\\s+([0-9.*,-]+|###@\\\\d+@###)\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Is the second argument already a quoted string?\n                if (regex.group().charAt(0) == '#') {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, $2)\");\n                } else {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, '$2')\");\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Extract SQL key words to avoid identifying them as columns or prefixed values\n            regex = Pattern.compile(sqlKeyWordRegex, Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                extractedStrings.add(regex.group().toUpperCase());\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Identify prefixed values and columns\n            regex = Pattern.compile(\"[a-zA-Z0-9_\\\\-]*[a-zA-Z][a-zA-Z0-9_\\\\-]*\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Convert prefixed values to SQL expressions\n                if (regex.group().startsWith(\"is\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"serviceName\") + \" = '\" + regex.group().substring(2) + \"'\");\n                } else if (regex.group().startsWith(\"notis\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"ipAddr\") + \" NOT IN (SELECT ifServices.ipAddr FROM ifServices, service WHERE service.serviceName ='\" + regex.group().substring(5) + \"' AND service.serviceID = ifServices.serviceID)\");\n                } else if (regex.group().startsWith(\"catinc\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"nodeID\") + \" IN (SELECT category_node.nodeID FROM category_node, categories WHERE categories.categoryID = category_node.categoryID AND categories.categoryName = '\" + regex.group().substring(6) + \"')\");\n                } else {\n                    // Call addColumn() on each column\n                    regex.appendReplacement(tempStringBuff, addColumn(tables, regex.group()));\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Merge extracted strings back into expression\n            regex = Pattern.compile(\"###@(\\\\d+)@###\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find())\n                regex.appendReplacement(tempStringBuff, regex.quoteReplacement(extractedStrings.get(Integer.parseInt(regex.group(1)))));\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            return \"WHERE \" + sqlRule;\n        }\n        return \"\";\n    }","id":35596,"modified_method":"/**\n     * Generic method to parse and translate a rule into SQL.\n     *\n     * Only columns listed in database-schema.xml may be used in a filter\n     * (explicit \"table.column\" specification is not supported in filters)\n     *\n     * To differentiate column names from SQL key words (operators, functions, typecasts, etc)\n     * sqlKeyWordRegex must match any SQL key words that may be used in filters,\n     * and must not match any column names or prefixed values\n     *\n     * To make filter syntax more simple and intuitive than SQL\n     * - Filters support some aliases for common SQL key words / operators\n     *    \"&amp;\" or \"&amp;&amp;\" = \"AND\"\n     *    \"|\" or \"||\" = \"OR\"\n     *    \"!\" = \"NOT\"\n     *    \"==\" = \"=\"\n     * - \"IPLIKE\" may be used as an operator instead of a function in filters (\"ipAddr IPLIKE '*.*.*.*'\")\n     *   When using \"IPLIKE\" as an operator, the value does not have to be quoted (\"ipAddr IPLIKE *.*.*.*\" is ok)\n     * - Some common SQL expressions may be generated by adding a (lower-case) prefix to an unquoted value in the filter\n     *    \"isVALUE\" = \"serviceName = VALUE\"\n     *    \"notisVALUE\" = interface does not support the specified service\n     *    \"catincVALUE\" = node is in the specified category\n     * - Double-quoted (\") strings in filters are converted to single-quoted (') strings in SQL\n     *   SQL treats single-quoted strings as constants (values) and double-quoted strings as identifiers (columns, tables, etc)\n     *   So, all quoted strings in filters are treated as constants, and filters don't support quoted identifiers\n     *\n     * This function does not do complete syntax/grammar checking - that is left to the database itself - do not assume the output is valid SQL\n     *\n     * @param tables\n     *            a list to be populated with any tables referenced by the returned SQL\n     * @param rule\n     *            the rule to parse\n     *\n     * @return an SQL WHERE clause\n     *\n     * @throws FilterParseException\n     *             if any errors occur during parsing\n     */\n    private String parseRule(List<Table> tables, String rule) throws FilterParseException {\n        if (rule != null && rule.length() > 0) {\n            String sqlRule = new String(rule);\n            Matcher regex;\n            List<String> extractedStrings = new ArrayList<String>();\n            StringBuffer tempStringBuff;\n\n            // Extract quoted strings from rule and convert double-quoted strings to single-quoted strings\n            // Quoted strings need to be extracted first to avoid accidentally matching/modifying anything within them\n            // As in SQL, pairs of quotes within a quoted string are treated as an escaped quote character:\n            //  'a''b' = a'b ; \"a\"\"b\" = a\"b ; 'a\"b' = a\"b ; \"a'b\" = a'b\n            regex = Pattern.compile(\"'(?:[^']|'')*'|\\\"(?:[^\\\"]|\\\"\\\")*\\\"\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                String tempString = regex.group();\n                if (tempString.charAt(0) == '\"') {\n                    extractedStrings.add(\"'\" + tempString.substring(1, tempString.length() - 1).replaceAll(\"\\\"\\\"\", \"\\\"\").replaceAll(\"'\", \"''\") + \"'\");\n                } else {\n                    extractedStrings.add(regex.group());\n                }\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            int tempIndex = tempStringBuff.length();\n            regex.appendTail(tempStringBuff);\n            if (tempStringBuff.substring(tempIndex).indexOf('\\'') > -1) {\n                log().error(\"Unmatched ' in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched ' in filter rule '\" + rule + \"'\");\n            }\n            if (tempStringBuff.substring(tempIndex).indexOf('\"') > -1) {\n                log().error(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n            }\n            sqlRule = tempStringBuff.toString();\n\n            // Translate filter-specific operators to SQL operators\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:&|&&)\\\\s*\", \" AND \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:\\\\||\\\\|\\\\|)\\\\s*\", \" OR \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*!(?!=)\\\\s*\", \" NOT \");\n            sqlRule = sqlRule.replaceAll(\"==\", \"=\");\n\n            // Translate IPLIKE operators to IPLIKE() functions\n            // If IPLIKE is already used as a function in the filter, this regex should not match it\n            regex = Pattern.compile(\"(\\\\w+)\\\\s+IPLIKE\\\\s+([0-9.*,-]+|###@\\\\d+@###)\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Is the second argument already a quoted string?\n                if (regex.group().charAt(0) == '#') {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, $2)\");\n                } else {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, '$2')\");\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Extract SQL key words to avoid identifying them as columns or prefixed values\n            regex = Pattern.compile(sqlKeyWordRegex, Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                extractedStrings.add(regex.group().toUpperCase());\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Identify prefixed values and columns\n            regex = Pattern.compile(\"[a-zA-Z0-9_\\\\-]*[a-zA-Z][a-zA-Z0-9_\\\\-]*\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Convert prefixed values to SQL expressions\n                if (regex.group().startsWith(\"is\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"serviceName\") + \" = '\" + regex.group().substring(2) + \"'\");\n                } else if (regex.group().startsWith(\"notis\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"ipAddr\") + \" NOT IN (SELECT ifServices.ipAddr FROM ifServices, service WHERE service.serviceName ='\" + regex.group().substring(5) + \"' AND service.serviceID = ifServices.serviceID)\");\n                } else if (regex.group().startsWith(\"catinc\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"nodeID\") + \" IN (SELECT category_node.nodeID FROM category_node, categories WHERE categories.categoryID = category_node.categoryID AND categories.categoryName = '\" + regex.group().substring(6) + \"')\");\n                } else {\n                    // Call addColumn() on each column\n                    regex.appendReplacement(tempStringBuff, addColumn(tables, regex.group()));\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Merge extracted strings back into expression\n            regex = Pattern.compile(\"###@(\\\\d+)@###\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                regex.appendReplacement(tempStringBuff, Matcher.quoteReplacement(extractedStrings.get(Integer.parseInt(regex.group(1)))));\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            return \"WHERE \" + sqlRule;\n        }\n        return \"\";\n    }","commit_id":"f0ac617e5927010bb126654d59a4c8e9101de5cc","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Generic method to parse and translate a rule into SQL.\n     *\n     * Only columns listed in database-schema.xml may be used in a filter\n     * (explicit \"table.column\" specification is not supported in filters)\n     *\n     * To differentiate column names from SQL key words (operators, functions, typecasts, etc)\n     * sqlKeyWordRegex must match any SQL key words that may be used in filters,\n     * and must not match any column names or prefixed values\n     *\n     * To make filter syntax more simple and intuitive than SQL\n     * - Filters support some aliases for common SQL key words / operators\n     *    \"&amp;\" or \"&amp;&amp;\" = \"AND\"\n     *    \"|\" or \"||\" = \"OR\"\n     *    \"!\" = \"NOT\"\n     *    \"==\" = \"=\"\n     * - \"IPLIKE\" may be used as an operator instead of a function in filters (\"ipAddr IPLIKE '*.*.*.*'\")\n     *   When using \"IPLIKE\" as an operator, the value does not have to be quoted (\"ipAddr IPLIKE *.*.*.*\" is ok)\n     * - Some common SQL expressions may be generated by adding a (lower-case) prefix to an unquoted value in the filter\n     *    \"isVALUE\" = \"serviceName = VALUE\"\n     *    \"notisVALUE\" = interface does not support the specified service\n     *    \"catincVALUE\" = node is in the specified category\n     * - Double-quoted (\") strings in filters are converted to single-quoted (') strings in SQL\n     *   SQL treats single-quoted strings as constants (values) and double-quoted strings as identifiers (columns, tables, etc)\n     *   So, all quoted strings in filters are treated as constants, and filters don't support quoted identifiers\n     *\n     * This function does not do complete syntax/grammar checking - that is left to the database itself - do not assume the output is valid SQL\n     *\n     * @param tables\n     *            a list to be populated with any tables referenced by the returned SQL\n     * @param rule\n     *            the rule to parse\n     *\n     * @return an SQL WHERE clause\n     *\n     * @throws FilterParseException\n     *             if any errors occur during parsing\n     */\n    private String parseRule(List<Table> tables, String rule) throws FilterParseException {\n        if (rule != null && rule.length() > 0) {\n            String sqlRule = new String(rule);\n            Matcher regex;\n            List<String> extractedStrings = new ArrayList<String>();\n            StringBuffer tempStringBuff;\n\n            // Extract quoted strings from rule and convert double-quoted strings to single-quoted strings\n            // Quoted strings need to be extracted first to avoid accidentally matching/modifying anything within them\n            // As in SQL, pairs of quotes within a quoted string are treated as an escaped quote character:\n            //  'a''b' = a'b ; \"a\"\"b\" = a\"b ; 'a\"b' = a\"b ; \"a'b\" = a'b\n            regex = Pattern.compile(\"'(?:[^']|'')*'|\\\"(?:[^\\\"]|\\\"\\\")*\\\"\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                String tempString = regex.group();\n                if (tempString.charAt(0) == '\"') {\n                    extractedStrings.add(\"'\" + tempString.substring(1, tempString.length() - 1).replaceAll(\"\\\"\\\"\", \"\\\"\").replaceAll(\"'\", \"''\") + \"'\");\n                } else {\n                    extractedStrings.add(regex.group());\n                }\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            int tempIndex = tempStringBuff.length();\n            regex.appendTail(tempStringBuff);\n            if (tempStringBuff.substring(tempIndex).indexOf('\\'') > -1) {\n                log().error(\"Unmatched ' in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched ' in filter rule '\" + rule + \"'\");\n            }\n            if (tempStringBuff.substring(tempIndex).indexOf('\"') > -1) {\n                log().error(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n            }\n            sqlRule = tempStringBuff.toString();\n\n            // Translate filter-specific operators to SQL operators\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:&|&&)\\\\s*\", \" AND \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:\\\\||\\\\|\\\\|)\\\\s*\", \" OR \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*!(?!=)\\\\s*\", \" NOT \");\n            sqlRule = sqlRule.replaceAll(\"==\", \"=\");\n\n            // Translate IPLIKE operators to IPLIKE() functions\n            // If IPLIKE is already used as a function in the filter, this regex should not match it\n            regex = Pattern.compile(\"(\\\\w+)\\\\s+IPLIKE\\\\s+([0-9.*,-]+|###@\\\\d+@###)\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Is the second argument already a quoted string?\n                if (regex.group().charAt(0) == '#') {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, $2)\");\n                } else {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, '$2')\");\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Extract SQL key words to avoid identifying them as columns or prefixed values\n            regex = Pattern.compile(sqlKeyWordRegex, Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                extractedStrings.add(regex.group().toUpperCase());\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Identify prefixed values and columns\n            regex = Pattern.compile(\"[a-zA-Z0-9_\\\\-]*[a-zA-Z][a-zA-Z0-9_\\\\-]*\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Convert prefixed values to SQL expressions\n                if (regex.group().startsWith(\"is\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"serviceName\") + \" = '\" + regex.group().substring(2) + \"'\");\n                } else if (regex.group().startsWith(\"notis\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"ipAddr\") + \" NOT IN (SELECT ifServices.ipAddr FROM ifServices, service WHERE service.serviceName ='\" + regex.group().substring(5) + \"' AND service.serviceID = ifServices.serviceID)\");\n                } else if (regex.group().startsWith(\"catinc\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"nodeID\") + \" IN (SELECT category_node.nodeID FROM category_node, categories WHERE categories.categoryID = category_node.categoryID AND categories.categoryName = '\" + regex.group().substring(6) + \"')\");\n                } else {\n                    // Call addColumn() on each column\n                    regex.appendReplacement(tempStringBuff, addColumn(tables, regex.group()));\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Merge extracted strings back into expression\n            regex = Pattern.compile(\"###@(\\\\d+)@###\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find())\n                regex.appendReplacement(tempStringBuff, regex.quoteReplacement(extractedStrings.get(Integer.parseInt(regex.group(1)))));\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            return \"WHERE \" + sqlRule;\n        }\n        return \"\";\n    }","id":35597,"modified_method":"/**\n     * Generic method to parse and translate a rule into SQL.\n     *\n     * Only columns listed in database-schema.xml may be used in a filter\n     * (explicit \"table.column\" specification is not supported in filters)\n     *\n     * To differentiate column names from SQL key words (operators, functions, typecasts, etc)\n     * sqlKeyWordRegex must match any SQL key words that may be used in filters,\n     * and must not match any column names or prefixed values\n     *\n     * To make filter syntax more simple and intuitive than SQL\n     * - Filters support some aliases for common SQL key words / operators\n     *    \"&amp;\" or \"&amp;&amp;\" = \"AND\"\n     *    \"|\" or \"||\" = \"OR\"\n     *    \"!\" = \"NOT\"\n     *    \"==\" = \"=\"\n     * - \"IPLIKE\" may be used as an operator instead of a function in filters (\"ipAddr IPLIKE '*.*.*.*'\")\n     *   When using \"IPLIKE\" as an operator, the value does not have to be quoted (\"ipAddr IPLIKE *.*.*.*\" is ok)\n     * - Some common SQL expressions may be generated by adding a (lower-case) prefix to an unquoted value in the filter\n     *    \"isVALUE\" = \"serviceName = VALUE\"\n     *    \"notisVALUE\" = interface does not support the specified service\n     *    \"catincVALUE\" = node is in the specified category\n     * - Double-quoted (\") strings in filters are converted to single-quoted (') strings in SQL\n     *   SQL treats single-quoted strings as constants (values) and double-quoted strings as identifiers (columns, tables, etc)\n     *   So, all quoted strings in filters are treated as constants, and filters don't support quoted identifiers\n     *\n     * This function does not do complete syntax/grammar checking - that is left to the database itself - do not assume the output is valid SQL\n     *\n     * @param tables\n     *            a list to be populated with any tables referenced by the returned SQL\n     * @param rule\n     *            the rule to parse\n     *\n     * @return an SQL WHERE clause\n     *\n     * @throws FilterParseException\n     *             if any errors occur during parsing\n     */\n    private String parseRule(List<Table> tables, String rule) throws FilterParseException {\n        if (rule != null && rule.length() > 0) {\n            String sqlRule = new String(rule);\n            Matcher regex;\n            List<String> extractedStrings = new ArrayList<String>();\n            StringBuffer tempStringBuff;\n\n            // Extract quoted strings from rule and convert double-quoted strings to single-quoted strings\n            // Quoted strings need to be extracted first to avoid accidentally matching/modifying anything within them\n            // As in SQL, pairs of quotes within a quoted string are treated as an escaped quote character:\n            //  'a''b' = a'b ; \"a\"\"b\" = a\"b ; 'a\"b' = a\"b ; \"a'b\" = a'b\n            regex = Pattern.compile(\"'(?:[^']|'')*'|\\\"(?:[^\\\"]|\\\"\\\")*\\\"\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                String tempString = regex.group();\n                if (tempString.charAt(0) == '\"') {\n                    extractedStrings.add(\"'\" + tempString.substring(1, tempString.length() - 1).replaceAll(\"\\\"\\\"\", \"\\\"\").replaceAll(\"'\", \"''\") + \"'\");\n                } else {\n                    extractedStrings.add(regex.group());\n                }\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            int tempIndex = tempStringBuff.length();\n            regex.appendTail(tempStringBuff);\n            if (tempStringBuff.substring(tempIndex).indexOf('\\'') > -1) {\n                log().error(\"Unmatched ' in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched ' in filter rule '\" + rule + \"'\");\n            }\n            if (tempStringBuff.substring(tempIndex).indexOf('\"') > -1) {\n                log().error(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n                throw new FilterParseException(\"Unmatched \\\" in filter rule '\" + rule + \"'\");\n            }\n            sqlRule = tempStringBuff.toString();\n\n            // Translate filter-specific operators to SQL operators\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:&|&&)\\\\s*\", \" AND \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*(?:\\\\||\\\\|\\\\|)\\\\s*\", \" OR \");\n            sqlRule = sqlRule.replaceAll(\"\\\\s*!(?!=)\\\\s*\", \" NOT \");\n            sqlRule = sqlRule.replaceAll(\"==\", \"=\");\n\n            // Translate IPLIKE operators to IPLIKE() functions\n            // If IPLIKE is already used as a function in the filter, this regex should not match it\n            regex = Pattern.compile(\"(\\\\w+)\\\\s+IPLIKE\\\\s+([0-9.*,-]+|###@\\\\d+@###)\", Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Is the second argument already a quoted string?\n                if (regex.group().charAt(0) == '#') {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, $2)\");\n                } else {\n                    regex.appendReplacement(tempStringBuff, \"IPLIKE($1, '$2')\");\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Extract SQL key words to avoid identifying them as columns or prefixed values\n            regex = Pattern.compile(sqlKeyWordRegex, Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE).matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                extractedStrings.add(regex.group().toUpperCase());\n                regex.appendReplacement(tempStringBuff, \"###@\" + (extractedStrings.size() - 1) + \"@###\");\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Identify prefixed values and columns\n            regex = Pattern.compile(\"[a-zA-Z0-9_\\\\-]*[a-zA-Z][a-zA-Z0-9_\\\\-]*\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                // Convert prefixed values to SQL expressions\n                if (regex.group().startsWith(\"is\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"serviceName\") + \" = '\" + regex.group().substring(2) + \"'\");\n                } else if (regex.group().startsWith(\"notis\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"ipAddr\") + \" NOT IN (SELECT ifServices.ipAddr FROM ifServices, service WHERE service.serviceName ='\" + regex.group().substring(5) + \"' AND service.serviceID = ifServices.serviceID)\");\n                } else if (regex.group().startsWith(\"catinc\")) {\n                    regex.appendReplacement(tempStringBuff,\n                        addColumn(tables, \"nodeID\") + \" IN (SELECT category_node.nodeID FROM category_node, categories WHERE categories.categoryID = category_node.categoryID AND categories.categoryName = '\" + regex.group().substring(6) + \"')\");\n                } else {\n                    // Call addColumn() on each column\n                    regex.appendReplacement(tempStringBuff, addColumn(tables, regex.group()));\n                }\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            // Merge extracted strings back into expression\n            regex = Pattern.compile(\"###@(\\\\d+)@###\").matcher(sqlRule);\n            tempStringBuff = new StringBuffer();\n            while (regex.find()) {\n                regex.appendReplacement(tempStringBuff, Matcher.quoteReplacement(extractedStrings.get(Integer.parseInt(regex.group(1)))));\n            }\n            regex.appendTail(tempStringBuff);\n            sqlRule = tempStringBuff.toString();\n\n            return \"WHERE \" + sqlRule;\n        }\n        return \"\";\n    }","commit_id":"2bcf47891965c1f498e652a37f01c5d39ed1f64f","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void addRecent(TextWithImports text) {\n    if (text.getText().length() != 0) {\n      final Component editorComponent = myComboBox.getEditor().getEditorComponent();\n      final boolean focusOwner = editorComponent.isFocusOwner();\n      super.addRecent(text);\n      myComboBox.insertItemAt(text, 0);\n      myComboBox.setSelectedIndex(0);\n\n      if (focusOwner) {\n        editorComponent.requestFocus();\n      }\n    }\n  }","id":35598,"modified_method":"public void addRecent(TextWithImports text) {\n    if (text.getText().length() != 0) {\n      Component editorComponent = myComboBox.getEditor().getEditorComponent();\n      final boolean focusOwner = editorComponent.isFocusOwner();\n      int offset = -1;\n      if (editorComponent instanceof EditorTextField) {\n        offset = ((EditorTextField)editorComponent).getCaretModel().getOffset();\n      }\n      super.addRecent(text);\n      myComboBox.insertItemAt(text, 0);\n      myComboBox.setSelectedIndex(0);\n      editorComponent = myComboBox.getEditor().getEditorComponent();\n      if (offset != -1 && editorComponent instanceof EditorTextField) {\n        final EditorTextField textField = (EditorTextField)editorComponent;\n        textField.getCaretModel().moveToOffset(offset);\n        final Editor editor = textField.getEditor();\n        if (editor != null) {\n          editor.getSelectionModel().setSelection(offset, offset);\n        }\n      }\n\n      if (focusOwner) {\n        editorComponent.requestFocus();\n      }\n    }\n  }","commit_id":"53a8ef1073cb0cdf50943b172a859e471414e6db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent getEditorComponent() {\n    return (JComponent)myEditor.getEditorComponent();\n  }","id":35599,"modified_method":"public JComponent getEditorComponent() {\n    return myEditor.getEditorComponent();\n  }","commit_id":"53a8ef1073cb0cdf50943b172a859e471414e6db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void doSetText(TextWithImports item) {\n    final String itemText = item.getText().replace('\\n', ' ');\n    restoreFactory(item);\n    item.setText(itemText);\n    if (!\"\".equals(itemText)) {\n      if (myComboBox.getItemCount() == 0 || !item.equals(myComboBox.getItemAt(0))) {\n        myComboBox.insertItemAt(item, 0);\n      }\n    }\n    if (myComboBox.getItemCount() > 0) {\n      myComboBox.setSelectedIndex(0);\n    }\n\n    myComboBox.getEditor().setItem(item);\n  }","id":35600,"modified_method":"@Override\n  protected void doSetText(TextWithImports item) {\n    final String itemText = item.getText().replace('\\n', ' ');\n    restoreFactory(item);\n    item.setText(itemText);\n    if (!StringUtil.isEmpty(itemText)) {\n      if (myComboBox.getItemCount() == 0 || !item.equals(myComboBox.getItemAt(0))) {\n        myComboBox.insertItemAt(item, 0);\n      }\n    }\n    if (myComboBox.getItemCount() > 0) {\n      myComboBox.setSelectedIndex(0);\n    }\n\n    myComboBox.getEditor().setItem(item);\n  }","commit_id":"53a8ef1073cb0cdf50943b172a859e471414e6db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void selectPopupValue() {\n    selectAll();\n    final Object currentPopupValue = getCurrentPopupValue();\n    if (currentPopupValue != null) {\n      myComboBox.getModel().setSelectedItem(currentPopupValue);\n      myComboBox.getEditor().setItem(currentPopupValue);\n    }\n\n    myComboBox.setPopupVisible(false);\n  }","id":35601,"modified_method":"public void selectPopupValue() {\n    //selectAll();\n    final Object currentPopupValue = getCurrentPopupValue();\n    if (currentPopupValue != null) {\n      myComboBox.getModel().setSelectedItem(currentPopupValue);\n      myComboBox.getEditor().setItem(currentPopupValue);\n    }\n\n    myComboBox.setPopupVisible(false);\n  }","commit_id":"53a8ef1073cb0cdf50943b172a859e471414e6db","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initEditor() {\n    myEditor = new EditorComboBoxEditor(getProject(), myDebuggerEditorsProvider.getFileType()) {\n      public void setItem(Object anObject) {\n        if (anObject == null) {\n          anObject = \"\";\n        }\n        super.setItem(createDocument((String)anObject));\n      }\n\n      public Object getItem() {\n        return ((Document)super.getItem()).getText();\n      }\n    };\n    myComboBox.setEditor(myEditor);\n    myEditor.setItem(myExpression);\n    myComboBox.setRenderer(new EditorComboBoxRenderer(myEditor));\n    myComboBox.setMaximumRowCount(XDebuggerHistoryManager.MAX_RECENT_EXPRESSIONS);\n  }","id":35602,"modified_method":"private void initEditor() {\n    myEditor = new EditorComboBoxEditor(getProject(), myDebuggerEditorsProvider.getFileType()) {\n      @Override\n      public void setItem(Object anObject) {\n        super.setItem(createDocument(StringUtil.notNullize((String)anObject)));\n      }\n\n      @Override\n      public Object getItem() {\n        return ((Document)super.getItem()).getText();\n      }\n    };\n    myComboBox.setEditor(myEditor);\n    myEditor.setItem(myExpression);\n    myComboBox.setRenderer(new EditorComboBoxRenderer(myEditor));\n    myComboBox.setMaximumRowCount(XDebuggerHistoryManager.MAX_RECENT_EXPRESSIONS);\n  }","commit_id":"20a4f26ca85a2988b4257f2530f5c69e2198ef80","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent getEditorComponent() {\n    return (JComponent)myEditor.getEditorComponent();\n  }","id":35603,"modified_method":"public JComponent getEditorComponent() {\n    return myEditor.getEditorComponent();\n  }","commit_id":"20a4f26ca85a2988b4257f2530f5c69e2198ef80","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public PsiElement findContextElement(@NotNull VirtualFile virtualFile, int offset, @NotNull Project project, boolean checkXml) {\n    Document document = FileDocumentManager.getInstance().getDocument(virtualFile);\n    PsiFile file = PsiManager.getInstance(project).findFile(virtualFile);\n    if (file == null || document == null) {\n      return null;\n    }\n\n    if (offset < 0) {\n      offset = 0;\n    }\n    if (offset > document.getTextLength()) {\n      offset = document.getTextLength();\n    }\n    int startOffset = offset;\n\n    int lineEndOffset = document.getLineEndOffset(document.getLineNumber(offset));\n    PsiElement result = null;\n    do {\n      PsiElement element = file.findElementAt(offset);\n      if (!(element instanceof PsiWhiteSpace) && !(element instanceof PsiComment)) {\n        result = element;\n        break;\n      }\n\n      offset = element.getTextRange().getEndOffset() + 1;\n    }\n    while (offset < lineEndOffset);\n\n    if (result == null) {\n      result = file.findElementAt(startOffset);\n    }\n\n    if (checkXml && result != null && StdFileTypes.XML.getLanguage().equals(result.getLanguage())) {\n      PsiLanguageInjectionHost parent = PsiTreeUtil.getParentOfType(result, PsiLanguageInjectionHost.class);\n      if (parent != null) {\n        result = InjectedLanguageUtil.findElementInInjected(parent, offset);\n      }\n    }\n    return result;\n  }","id":35604,"modified_method":"@Override\n  @Nullable\n  public PsiElement findContextElement(@NotNull VirtualFile virtualFile, int offset, @NotNull Project project, boolean checkXml) {\n    if (!virtualFile.isValid()) {\n      return null;\n    }\n\n    Document document = FileDocumentManager.getInstance().getDocument(virtualFile);\n    PsiFile file = document == null ? null : PsiManager.getInstance(project).findFile(virtualFile);\n    if (file == null) {\n      return null;\n    }\n\n    if (offset < 0) {\n      offset = 0;\n    }\n    if (offset > document.getTextLength()) {\n      offset = document.getTextLength();\n    }\n    int startOffset = offset;\n\n    int lineEndOffset = document.getLineEndOffset(document.getLineNumber(offset));\n    PsiElement result = null;\n    do {\n      PsiElement element = file.findElementAt(offset);\n      if (!(element instanceof PsiWhiteSpace) && !(element instanceof PsiComment)) {\n        result = element;\n        break;\n      }\n\n      offset = element.getTextRange().getEndOffset() + 1;\n    }\n    while (offset < lineEndOffset);\n\n    if (result == null) {\n      result = file.findElementAt(startOffset);\n    }\n\n    if (checkXml && result != null && StdFileTypes.XML.getLanguage().equals(result.getLanguage())) {\n      PsiLanguageInjectionHost parent = PsiTreeUtil.getParentOfType(result, PsiLanguageInjectionHost.class);\n      if (parent != null) {\n        result = InjectedLanguageUtil.findElementInInjected(parent, offset);\n      }\n    }\n    return result;\n  }","commit_id":"20a4f26ca85a2988b4257f2530f5c69e2198ef80","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createUIComponents() {\n    myTargetField = new ComboBox(MvcRunTargetHistoryService.getInstance().getHistory(), -1);\n    myTargetField.setLightWeightPopupEnabled(false);\n\n    EditorComboBoxEditor editor = new StringComboboxEditor(myModule.getProject(), PlainTextFileType.INSTANCE, myTargetField);\n    myTargetField.setRenderer(new EditorComboBoxRenderer(editor));\n\n    myTargetField.setEditable(true);\n    myTargetField.setEditor(editor);\n\n    EditorTextField editorTextField = (EditorTextField)editor.getEditorComponent();\n\n    myFakePanel = new JPanel(new BorderLayout());\n    myFakePanel.add(myTargetField, BorderLayout.CENTER);\n\n    TextFieldCompletionProvider vmOptionCompletionProvider = new TextFieldCompletionProviderDumbAware() {\n      @NotNull\n      @Override\n      protected String getPrefix(@NotNull String currentTextPrefix) {\n        return MvcRunTargetDialog.getPrefix(currentTextPrefix);\n      }\n\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        if (prefix.endsWith(\"-D\")) {\n          result.addAllElements(MvcTargetDialogCompletionUtils.getSystemPropertiesVariants());\n        }\n      }\n    };\n    myVmOptionsField = vmOptionCompletionProvider.createEditor(myModule.getProject());\n\n    new TextFieldCompletionProviderDumbAware() {\n\n      @NotNull\n      @Override\n      protected String getPrefix(@NotNull String currentTextPrefix) {\n        return MvcRunTargetDialog.getPrefix(currentTextPrefix);\n      }\n\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        for (LookupElement variant : MvcTargetDialogCompletionUtils.collectVariants(myModule, text, offset, prefix)) {\n          result.addElement(variant);\n        }\n      }\n    }.apply(editorTextField);\n\n    editorTextField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void documentChanged(DocumentEvent e) {\n        setOKActionEnabled(!StringUtil.isEmptyOrSpaces(e.getDocument().getText()));\n      }\n    });\n    setOKActionEnabled(false);\n  }","id":35605,"modified_method":"private void createUIComponents() {\n    myTargetField = new ComboBox(MvcRunTargetHistoryService.getInstance().getHistory(), -1);\n    myTargetField.setLightWeightPopupEnabled(false);\n\n    EditorComboBoxEditor editor = new StringComboboxEditor(myModule.getProject(), PlainTextFileType.INSTANCE, myTargetField);\n    myTargetField.setRenderer(new EditorComboBoxRenderer(editor));\n\n    myTargetField.setEditable(true);\n    myTargetField.setEditor(editor);\n\n    EditorTextField editorTextField = editor.getEditorComponent();\n\n    myFakePanel = new JPanel(new BorderLayout());\n    myFakePanel.add(myTargetField, BorderLayout.CENTER);\n\n    TextFieldCompletionProvider vmOptionCompletionProvider = new TextFieldCompletionProviderDumbAware() {\n      @NotNull\n      @Override\n      protected String getPrefix(@NotNull String currentTextPrefix) {\n        return MvcRunTargetDialog.getPrefix(currentTextPrefix);\n      }\n\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        if (prefix.endsWith(\"-D\")) {\n          result.addAllElements(MvcTargetDialogCompletionUtils.getSystemPropertiesVariants());\n        }\n      }\n    };\n    myVmOptionsField = vmOptionCompletionProvider.createEditor(myModule.getProject());\n\n    new TextFieldCompletionProviderDumbAware() {\n\n      @NotNull\n      @Override\n      protected String getPrefix(@NotNull String currentTextPrefix) {\n        return MvcRunTargetDialog.getPrefix(currentTextPrefix);\n      }\n\n      @Override\n      protected void addCompletionVariants(@NotNull String text, int offset, @NotNull String prefix, @NotNull CompletionResultSet result) {\n        for (LookupElement variant : MvcTargetDialogCompletionUtils.collectVariants(myModule, text, offset, prefix)) {\n          result.addElement(variant);\n        }\n      }\n    }.apply(editorTextField);\n\n    editorTextField.getDocument().addDocumentListener(new DocumentAdapter() {\n      @Override\n      public void documentChanged(DocumentEvent e) {\n        setOKActionEnabled(!StringUtil.isEmptyOrSpaces(e.getDocument().getText()));\n      }\n    });\n    setOKActionEnabled(false);\n  }","commit_id":"18c466a5617c0deeb474006cdcef34c81eb565ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean equals(IEObjectDescription next, IEObjectDescription next2) {\n\t\tif (next == next2)\n\t\t\treturn true;\n\t\tif (next.getEClass() != next2.getEClass())\n\t\t\treturn false;\n\t\tif (next.getName() != null && !next.getName().equals(next2.getName()))\n\t\t\treturn false;\n\t\tif (!next.getEObjectURI().equals(next2.getEObjectURI()))\n\t\t\treturn false;\n\t\tif (!Arrays.equals(next.getUserDataKeys(), next2.getUserDataKeys()))\n\t\t\treturn false;\n\t\tfor (String key : next.getUserDataKeys()) {\n\t\t\tString userData = next.getUserData(key);\n\t\t\tString userData2 = next2.getUserData(key);\n\t\t\tif (userData == null) {\n\t\t\t\tif (userData2 != null)\n\t\t\t\t\treturn false;\n\t\t\t} else if (!userData.equals(userData2)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","id":35606,"modified_method":"protected boolean equals(IEObjectDescription oldObj, IEObjectDescription newObj) {\n\t\tif (oldObj == newObj)\n\t\t\treturn true;\n\t\tif (oldObj.getEClass() != newObj.getEClass())\n\t\t\treturn false;\n\t\tif (oldObj.getName() != null && !oldObj.getName().equals(newObj.getName()))\n\t\t\treturn false;\n\t\tif (!oldObj.getEObjectURI().equals(newObj.getEObjectURI()))\n\t\t\treturn false;\n\t\tString[] oldKeys = oldObj.getUserDataKeys();\n\t\tString[] newKeys = newObj.getUserDataKeys();\n\t\tif (oldKeys.length != newKeys.length)\n\t\t\treturn false;\n\t\tSet<String> newKeySet = ImmutableSet.of(newKeys);\n\t\tfor (String key : oldKeys) {\n\t\t\tif (!newKeySet.contains(key))\n\t\t\t\treturn false;\n\t\t\tString oldValue = oldObj.getUserData(key);\n\t\t\tString newValue = newObj.getUserData(key);\n\t\t\tif (oldValue == null) {\n\t\t\t\tif (newValue != null)\n\t\t\t\t\treturn false;\n\t\t\t} else if (!oldValue.equals(newValue)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}","commit_id":"446beac13f3e54f4423d640365b7946d0ed900ab","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean internalHasChanges() {\n\t\tif (_new == null || old == null)\n\t\t\treturn true;\n\n\t\tCollection<IEObjectDescription> oldEObjects = Lists.newArrayList(old.getExportedObjects());\n\t\tCollection<IEObjectDescription> newEObjects = Lists.newArrayList(_new.getExportedObjects());\n\t\tif (oldEObjects.size() != newEObjects.size())\n\t\t\treturn true;\n\n\t\tIterator<IEObjectDescription> iterator1 = oldEObjects.iterator();\n\t\tIterator<IEObjectDescription> iterator2 = newEObjects.iterator();\n\t\twhile (iterator1.hasNext()) {\n\t\t\tif (!equals(iterator1.next(), iterator2.next()))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","id":35607,"modified_method":"protected boolean internalHasChanges() {\n\t\tif (_new == null || old == null)\n\t\t\treturn true;\n\n\t\tIterable<IEObjectDescription> oldEObjects = old.getExportedObjects();\n\t\tIterable<IEObjectDescription> newEObjects = _new.getExportedObjects();\n\t\tif (Iterables.size(oldEObjects) != Iterables.size(newEObjects))\n\t\t\treturn true;\n\n\t\tIterator<IEObjectDescription> iterator1 = oldEObjects.iterator();\n\t\tIterator<IEObjectDescription> iterator2 = newEObjects.iterator();\n\t\twhile (iterator1.hasNext()) {\n\t\t\tif (!equals(iterator1.next(), iterator2.next()))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"446beac13f3e54f4423d640365b7946d0ed900ab","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected IResourceDescription internalGetResourceDescription(final Resource resource,\n\t\t\tIDefaultResourceDescriptionStrategy strategy) {\n\t\tDerivedStateAwareResource res = (DerivedStateAwareResource) resource;\n\t\tboolean isInitialized = res.fullyInitialized || res.isInitializing;\n\t\ttry {\n\t\t\tif (!isInitialized) {\n\t\t\t\tres.eSetDeliver(false);\n\t\t\t\tres.installDerivedState(true);\n\t\t\t}\n\t\t\tIResourceDescription description = createResourceDescription(resource, strategy);\n\t\t\tif (!isInitialized) {\n\t\t\t\t// make sure the eobject descriptions are being built.\n\t\t\t\tnewArrayList(description.getExportedObjects());\n\t\t\t}\n\t\t\treturn description;\n\t\t} finally {\n\t\t\tif (!isInitialized) {\n\t\t\t\tres.discardDerivedState();\n\t\t\t\tres.eSetDeliver(true);\n\t\t\t}\n\t\t}\n\t}","id":35608,"modified_method":"@Override\n\tprotected IResourceDescription internalGetResourceDescription(final Resource resource,\n\t\t\tIDefaultResourceDescriptionStrategy strategy) {\n\t\tDerivedStateAwareResource res = (DerivedStateAwareResource) resource;\n\t\tboolean isInitialized = res.fullyInitialized || res.isInitializing;\n\t\ttry {\n\t\t\tif (!isInitialized) {\n\t\t\t\tres.eSetDeliver(false);\n\t\t\t\tres.installDerivedState(true);\n\t\t\t}\n\t\t\tIResourceDescription description = createResourceDescription(resource, strategy);\n\t\t\tif (!isInitialized) {\n\t\t\t\t// eager initialize\n\t\t\t\tfor (IEObjectDescription desc : description.getExportedObjects()) {\n\t\t\t\t\tdesc.getEObjectURI();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn description;\n\t\t} finally {\n\t\t\tif (!isInitialized) {\n\t\t\t\tif (log.isInfoEnabled())\n\t\t\t\t\tlog.info(\"Discarding inferred state for \"+resource.getURI());\n\t\t\t\tres.discardDerivedState();\n\t\t\t\tres.eSetDeliver(true);\n\t\t\t}\n\t\t}\n\t}","commit_id":"81ad67279a6bdd3ad2c37156b0e4c8874e91fa83","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + normalizers + getAllLocalElements() + \" -> \" + getParent();\n\t}","id":35609,"modified_method":"@Override\n\tpublic String toString() {\n\t\treturn getClass().getSimpleName() + normalizers + \" imports from \" + importFrom + \" for type \"+type.getName();\n\t}","commit_id":"81ad67279a6bdd3ad2c37156b0e4c8874e91fa83","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Locate a locale type with the given fragment. Does not consider types that\n\t * are defined in operations or constructors as inner classes.\n\t */\n\tpublic EObject resolveJavaObject(JvmType rootType, String fragment) {\n\t\tif (fragment.endsWith(\"[]\")) {\n\t\t\treturn resolveJavaArrayObject(rootType, fragment);\n\t\t}\n\t\tint slash = fragment.indexOf('/'); \n\t\tif (slash != -1) {\n\t\t\tif (slash == 0)\n\t\t\t\treturn null;\n\t\t\tString containerFragment = fragment.substring(0, slash);\n\t\t\tEObject container = resolveJavaObject(rootType, containerFragment);\n\t\t\tif (container != null) {\n\t\t\t\tString parameterName = fragment.substring(slash + 1);\n\t\t\t\tif (container instanceof JvmTypeParameterDeclarator) {\n\t\t\t\t\tJvmTypeParameterDeclarator executable = (JvmTypeParameterDeclarator) container;\n\t\t\t\t\tfor(JvmTypeParameter parameter: executable.getTypeParameters()) {\n\t\t\t\t\t\tif (parameter.getName().equals(parameterName))\n\t\t\t\t\t\t\treturn parameter;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t} else {\n\t\t\tif (rootType.getIdentifier().equals(fragment)) {\n\t\t\t\treturn rootType;\n\t\t\t}\n\t\t\tint paren = fragment.indexOf('(');\n\t\t\tif (paren == -1)\n\t\t\t\tparen = fragment.length();\n\t\t\tint dollar = fragment.lastIndexOf('$', paren);\n\t\t\tint dot = fragment.lastIndexOf('.', paren);\n\t\t\tfinal int max = Math.max(dollar, dot);\n\t\t\tif (max == -1) {\n\t\t\t\tlogger.warn(\"Couldn't resolve java object for root type \"+rootType.getQualifiedName()+\" and fragment '\"+fragment, new Exception());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tString subFragment = fragment.substring(0, max);\n\t\t\tEObject container = resolveJavaObject(rootType, subFragment);\n\t\t\tif (container instanceof JvmDeclaredType) {\n\t\t\t\tEList<JvmMember> members = ((JvmDeclaredType) container).getMembers();\n\t\t\t\tfor(JvmMember member: members) {\n\t\t\t\t\tif (member instanceof JvmType) {\n\t\t\t\t\t\tString name = member.getIdentifier();\n\t\t\t\t\t\tif (name.equals(fragment))\n\t\t\t\t\t\t\treturn member;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\t\n\t}","id":35610,"modified_method":"/**\n\t * Locate a locale type with the given fragment. Does not consider types that\n\t * are defined in operations or constructors as inner classes.\n\t */\n\tpublic EObject resolveJavaObject(JvmType rootType, String fragment) {\n\t\tif (fragment.endsWith(\"[]\")) {\n\t\t\treturn resolveJavaArrayObject(rootType, fragment);\n\t\t}\n\t\tint slash = fragment.indexOf('/'); \n\t\tif (slash != -1) {\n\t\t\tif (slash == 0)\n\t\t\t\treturn null;\n\t\t\tString containerFragment = fragment.substring(0, slash);\n\t\t\tEObject container = resolveJavaObject(rootType, containerFragment);\n\t\t\tif (container != null) {\n\t\t\t\tString parameterName = fragment.substring(slash + 1);\n\t\t\t\tif (container instanceof JvmTypeParameterDeclarator) {\n\t\t\t\t\tJvmTypeParameterDeclarator executable = (JvmTypeParameterDeclarator) container;\n\t\t\t\t\tfor(JvmTypeParameter parameter: executable.getTypeParameters()) {\n\t\t\t\t\t\tif (parameter.getName().equals(parameterName))\n\t\t\t\t\t\t\treturn parameter;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t}\n\t\t} else {\n\t\t\tif (rootType.getIdentifier().equals(fragment)) {\n\t\t\t\treturn rootType;\n\t\t\t}\n\t\t\tint paren = fragment.indexOf('(');\n\t\t\tif (paren == -1)\n\t\t\t\tparen = fragment.length();\n\t\t\tint dollar = fragment.lastIndexOf('$', paren);\n\t\t\tint dot = fragment.lastIndexOf('.', paren);\n\t\t\tfinal int max = Math.max(dollar, dot);\n\t\t\tif (max == -1) {\n\t\t\t\tlogger.warn(\"Couldn't resolve java object for root type \"+rootType.getQualifiedName()+\" and fragment '\"+fragment);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tString subFragment = fragment.substring(0, max);\n\t\t\tEObject container = resolveJavaObject(rootType, subFragment);\n\t\t\tif (container instanceof JvmDeclaredType) {\n\t\t\t\tEList<JvmMember> members = ((JvmDeclaredType) container).getMembers();\n\t\t\t\tfor(JvmMember member: members) {\n\t\t\t\t\tif (member instanceof JvmType) {\n\t\t\t\t\t\tString name = member.getIdentifier();\n\t\t\t\t\t\tif (name.equals(fragment))\n\t\t\t\t\t\t\treturn member;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\t\n\t}","commit_id":"81ad67279a6bdd3ad2c37156b0e4c8874e91fa83","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected Iterable<IEObjectDescription> filterByURI(Iterable<IEObjectDescription> unfiltered) {\n\t\treturn Iterables.filter(unfiltered, new Predicate<IEObjectDescription>() {\n\t\t\tprivate Collection<URI> contents = null;\n\n\t\t\tpublic boolean apply(IEObjectDescription input) {\n\t\t\t\tif(contents == null) {\n\t\t\t\t\tcontents = state.getContents();\n\t\t\t\t}\n\t\t\t\tURI resourceURI = input.getEObjectURI().trimFragment();\n\t\t\t\treturn contents.contains(resourceURI);\n\t\t\t}\n\t\t});\n\t}","id":35611,"modified_method":"@Override\n\tprotected Iterable<IEObjectDescription> filterByURI(Iterable<IEObjectDescription> unfiltered) {\n\t\treturn Iterables.filter(unfiltered, new Predicate<IEObjectDescription>() {\n\t\t\tprivate Collection<URI> contents = null;\n\n\t\t\tpublic boolean apply(IEObjectDescription input) {\n\t\t\t\tif(contents == null) {\n\t\t\t\t\tcontents = state.getContents();\n\t\t\t\t}\n\t\t\t\tURI resourceURI = input.getEObjectURI().trimFragment();\n\t\t\t\tfinal boolean contains = contents.contains(resourceURI);\n\t\t\t\treturn contains;\n\t\t\t}\n\t\t});\n\t}","commit_id":"81ad67279a6bdd3ad2c37156b0e4c8874e91fa83","url":"https://github.com/eclipse/xtext"},{"original_method":"protected ImportScope createImportScope(IScope parent, List<ImportNormalizer> namespaceResolvers, ISelectable importFrom, EClass type, boolean ignoreCase) {\n\t\tif (importFrom == null)\n\t\t\tthrow new NullPointerException(\"importFrom\");\n\t\t\n\t\treturn new ImportScope(namespaceResolvers, parent, importFrom, type, ignoreCase) {\n\t\t\t@Override\n\t\t\tprotected IEObjectDescription getSingleLocalElementByName(QualifiedName name) {\n\t\t\t\tif (name.getSegmentCount() > 1)\n\t\t\t\t\treturn null;\n\t\t\t\treturn super.getSingleLocalElementByName(name);\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected Iterable<IEObjectDescription> getLocalElementsByName(QualifiedName name) {\n\t\t\t\tif (name.getSegmentCount() > 1)\n\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\treturn super.getLocalElementsByName(name);\n\t\t\t}\n\t\t};\n\t}","id":35612,"modified_method":"protected ImportScope createImportScope(IScope parent, List<ImportNormalizer> namespaceResolvers, ISelectable importFrom, EClass type, boolean ignoreCase) {\n\t\tif (importFrom == null)\n\t\t\tthrow new NullPointerException(\"importFrom\");\n\t\t\n\t\treturn new ImportScope(namespaceResolvers, parent, importFrom, type, ignoreCase) {\n\t\t\t@Override\n\t\t\tprotected IEObjectDescription getSingleLocalElementByName(QualifiedName name) {\n\t\t\t\tif (name.getSegmentCount() > 1)\n\t\t\t\t\treturn null;\n\t\t\t\tfinal IEObjectDescription result = super.getSingleLocalElementByName(name);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tprotected Iterable<IEObjectDescription> getLocalElementsByName(QualifiedName name) {\n\t\t\t\tif (name.getSegmentCount() > 1)\n\t\t\t\t\treturn Collections.emptyList();\n\t\t\t\treturn super.getLocalElementsByName(name);\n\t\t\t}\n\t\t};\n\t}","commit_id":"81ad67279a6bdd3ad2c37156b0e4c8874e91fa83","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n\n        // So jung kommen wir nicht mehr zusammen.\n\n        final CommandLineArguments commandLineArguments = new CommandLineArguments();\n        final JCommander jCommander = new JCommander(commandLineArguments, args);\n        jCommander.setProgramName(\"graylog2\");\n\n        if (commandLineArguments.isShowHelp()) {\n            jCommander.usage();\n            System.exit(0);\n        }\n\n        if (commandLineArguments.isShowVersion()) {\n            System.out.println(\"Graylog2 Server \" + Core.GRAYLOG2_VERSION);\n            System.out.println(\"JRE: \" + Tools.getSystemInformation());\n            System.exit(0);\n        }\n\n        // Are we in debug mode?\n        if (commandLineArguments.isDebug()) {\n            LOG.info(\"Running in Debug mode\");\n            Logger.getRootLogger().setLevel(Level.ALL);\n            Logger.getLogger(Main.class.getPackage().getName()).setLevel(Level.ALL);\n        }\n\n        LOG.info(\"Graylog2 \" + Core.GRAYLOG2_VERSION + \" starting up. (JRE: \" + Tools.getSystemInformation() + \")\");\n\n        String configFile = commandLineArguments.getConfigFile();\n        LOG.info(\"Using config file: \" + configFile);\n\n        final Configuration configuration = new Configuration();\n        JadConfig jadConfig = new JadConfig(new PropertiesRepository(configFile), configuration);\n\n        LOG.info(\"Loading configuration\");\n        try {\n            jadConfig.process();\n        } catch (RepositoryException e) {\n            LOG.fatal(\"Couldn't load configuration file \" + configFile, e);\n            System.exit(1);\n        } catch (ValidationException e) {\n            LOG.fatal(\"Invalid configuration\", e);\n            System.exit(1);\n        }\n\n        // If we only want to check our configuration, we just initialize the rules engine to check if the rules compile\n        if (commandLineArguments.isConfigTest()) {\n            Core server = new Core();\n            DroolsInitializer drools = new DroolsInitializer(server, configuration);\n            drools.initialize();\n            // rules have been checked, exit gracefully\n            System.exit(0);\n        }\n\n        // Do not use a PID file if the user requested not to\n        if (!commandLineArguments.isNoPidFile()) {\n            savePidFile(commandLineArguments.getPidFile());\n        }\n\n        // Le server object. This is where all the magic happens.\n        Core server = new Core();\n        server.initialize(configuration);\n        \n        // Could it be that there is another master instance already?\n        if (configuration.isMaster() && server.cluster().masterCountExcept(server.getServerId()) != 0) {\n            // All devils here.\n            String what = \"Detected other master node in the cluster! Starting as non-master! \"\n                    + \"This is a mis-configuration you should fix.\";\n            LOG.warn(what);\n            server.getActivityWriter().write(new Activity(what, Main.class));\n            \n            configuration.setIsMaster(false);\n        }\n        \n        if (commandLineArguments.isLocal()) {\n            // In local mode, systemstats are sent to localhost for example.\n            LOG.info(\"Running in local mode\");\n            server.setLocalMode(true);\n        }\n        \n        // Register communicator methods.\n        if (configuration.isEnableCommunicationMethodTwilio()) {\n            server.registerCommunicatorMethod(TwilioCommunicator.class);\n        }\n        \n        // Register initializers.\n        server.registerInitializer(new ServerValueWriterInitializer(server, configuration));\n        server.registerInitializer(new DroolsInitializer(server, configuration));\n        server.registerInitializer(new HostCounterCacheWriterInitializer(server));\n        server.registerInitializer(new MessageCounterInitializer(server));\n        if (configuration.isEnableGraphiteOutput())       { server.registerInitializer(new GraphiteInitializer(server)); }\n        if (configuration.isEnableLibratoMetricsOutput()) { server.registerInitializer(new LibratoMetricsInitializer(server)); }\n        server.registerInitializer(new DeflectorThreadsInitializer(server));\n        server.registerInitializer(new AnonymousInformationCollectorInitializer(server));\n        if (configuration.performRetention() && commandLineArguments.performRetention()) {\n            server.registerInitializer(new IndexRetentionInitializer(server));\n        }\n        \n        // Register inputs.\n        if (configuration.isUseGELF()) {\n            server.registerInput(new GELFUDPInput());\n            server.registerInput(new GELFTCPInput());\n        }\n        \n        if (configuration.isSyslogUdpEnabled()) { server.registerInput(new SyslogUDPInput()); }\n        if (configuration.isSyslogTcpEnabled()) { server.registerInput(new SyslogTCPInput()); }\n\n        // Register message filters.\n        server.registerFilter(new RewriteFilter());\n        server.registerFilter(new BlacklistFilter());\n        if (configuration.isEnableTokenizerFilter()) { server.registerFilter(new TokenizerFilter()); }\n        server.registerFilter(new StreamMatcherFilter());\n        server.registerFilter(new CounterUpdateFilter());\n\n        // Register outputs.\n        server.registerOutput(ElasticSearchOutput.class);\n        \n        // Blocks until we shut down.\n        server.run();\n\n        LOG.info(\"Graylog2 \" + Core.GRAYLOG2_VERSION + \" exiting.\");\n    }","id":35613,"modified_method":"/**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n\n        // So jung kommen wir nicht mehr zusammen.\n\n        final CommandLineArguments commandLineArguments = new CommandLineArguments();\n        final JCommander jCommander = new JCommander(commandLineArguments, args);\n        jCommander.setProgramName(\"graylog2\");\n\n        if (commandLineArguments.isShowHelp()) {\n            jCommander.usage();\n            System.exit(0);\n        }\n\n        if (commandLineArguments.isShowVersion()) {\n            System.out.println(\"Graylog2 Server \" + Core.GRAYLOG2_VERSION);\n            System.out.println(\"JRE: \" + Tools.getSystemInformation());\n            System.exit(0);\n        }\n\n        // Are we in debug mode?\n        if (commandLineArguments.isDebug()) {\n            LOG.info(\"Running in Debug mode\");\n            Logger.getRootLogger().setLevel(Level.ALL);\n            Logger.getLogger(Main.class.getPackage().getName()).setLevel(Level.ALL);\n        }\n\n        LOG.info(\"Graylog2 \" + Core.GRAYLOG2_VERSION + \" starting up. (JRE: \" + Tools.getSystemInformation() + \")\");\n\n        String configFile = commandLineArguments.getConfigFile();\n        LOG.info(\"Using config file: \" + configFile);\n\n        final Configuration configuration = new Configuration();\n        JadConfig jadConfig = new JadConfig(new PropertiesRepository(configFile), configuration);\n\n        LOG.info(\"Loading configuration\");\n        try {\n            jadConfig.process();\n        } catch (RepositoryException e) {\n            LOG.fatal(\"Couldn't load configuration file \" + configFile, e);\n            System.exit(1);\n        } catch (ValidationException e) {\n            LOG.fatal(\"Invalid configuration\", e);\n            System.exit(1);\n        }\n\n        // If we only want to check our configuration, we just initialize the rules engine to check if the rules compile\n        if (commandLineArguments.isConfigTest()) {\n            Core server = new Core();\n            DroolsInitializer drools = new DroolsInitializer(server, configuration);\n            drools.initialize();\n            // rules have been checked, exit gracefully\n            System.exit(0);\n        }\n\n        // Do not use a PID file if the user requested not to\n        if (!commandLineArguments.isNoPidFile()) {\n            savePidFile(commandLineArguments.getPidFile());\n        }\n\n        // Le server object. This is where all the magic happens.\n        Core server = new Core();\n        server.initialize(configuration);\n        \n        // Could it be that there is another master instance already?\n        if (configuration.isMaster() && server.cluster().masterCountExcept(server.getServerId()) != 0) {\n            // All devils here.\n            String what = \"Detected other master node in the cluster! Starting as non-master! \"\n                    + \"This is a mis-configuration you should fix.\";\n            LOG.warn(what);\n            server.getActivityWriter().write(new Activity(what, Main.class));\n            \n            configuration.setIsMaster(false);\n        }\n        \n        if (commandLineArguments.isLocal() || commandLineArguments.isDebug()) {\n            // In local mode, systemstats are sent to localhost for example.\n            LOG.info(\"Running in local mode\");\n            server.setLocalMode(true);\n        }\n        \n        // Register communicator methods.\n        if (configuration.isEnableCommunicationMethodTwilio()) {\n            server.registerCommunicatorMethod(TwilioCommunicator.class);\n        }\n        \n        // Register initializers.\n        server.registerInitializer(new ServerValueWriterInitializer(server, configuration));\n        server.registerInitializer(new DroolsInitializer(server, configuration));\n        server.registerInitializer(new HostCounterCacheWriterInitializer(server));\n        server.registerInitializer(new MessageCounterInitializer(server));\n        if (configuration.isEnableGraphiteOutput())       { server.registerInitializer(new GraphiteInitializer(server)); }\n        if (configuration.isEnableLibratoMetricsOutput()) { server.registerInitializer(new LibratoMetricsInitializer(server)); }\n        server.registerInitializer(new DeflectorThreadsInitializer(server));\n        server.registerInitializer(new AnonymousInformationCollectorInitializer(server));\n        if (configuration.performRetention() && commandLineArguments.performRetention()) {\n            server.registerInitializer(new IndexRetentionInitializer(server));\n        }\n        \n        // Register inputs.\n        if (configuration.isUseGELF()) {\n            server.registerInput(new GELFUDPInput());\n            server.registerInput(new GELFTCPInput());\n        }\n        \n        if (configuration.isSyslogUdpEnabled()) { server.registerInput(new SyslogUDPInput()); }\n        if (configuration.isSyslogTcpEnabled()) { server.registerInput(new SyslogTCPInput()); }\n\n        // Register message filters.\n        server.registerFilter(new RewriteFilter());\n        server.registerFilter(new BlacklistFilter());\n        if (configuration.isEnableTokenizerFilter()) { server.registerFilter(new TokenizerFilter()); }\n        server.registerFilter(new StreamMatcherFilter());\n        server.registerFilter(new CounterUpdateFilter());\n\n        // Register outputs.\n        server.registerOutput(ElasticSearchOutput.class);\n        \n        // Blocks until we shut down.\n        server.run();\n\n        LOG.info(\"Graylog2 \" + Core.GRAYLOG2_VERSION + \" exiting.\");\n    }","commit_id":"06a93403d737f57014d6357ac4792187e490f20b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Register the given {@link Service} with the registry. Only used internally.\n     * \n     * @param service\n     */\n    Service register( ServiceConfiguration config ) {\n      Service service = Services.newServiceInstance( config );\n      if ( config.isLocal( ) ) {\n        this.localService.set( service );\n      }\n      this.services.put( config.getFullName( ), service );\n      EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_REGISTERED,\n                          Component.this.getName( ),\n                          service.getServiceConfiguration( ).isLocal( )\n                            ? \"local\"\n                            : \"remote\",\n                          config.getName( ), config.getUri( ) ).info( );\n      return service;\n    }","id":35614,"modified_method":"/**\n     * Register the given {@link Service} with the registry. Only used internally.\n     * \n     * @param service\n     */\n    Service register( ServiceConfiguration config ) {\n      Service service = Services.newServiceInstance( config );\n      if ( config.isLocal( ) || Internets.testLocal( config.getHostName( ) ) ) {\n        this.localService.set( service );\n      }\n      this.services.put( config.getFullName( ), service );\n      EventRecord.caller( Component.class, EventType.COMPONENT_SERVICE_REGISTERED,\n                          Component.this.getName( ),\n                          service.getServiceConfiguration( ).isLocal( )\n                            ? \"local\"\n                            : \"remote\",\n                          config.getName( ), config.getUri( ) ).info( );\n      return service;\n    }","commit_id":"c04106a73f7db00f54b7b2d47a0b1971e84a9d7f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"Service lookupRegisteredService( final ServiceConfiguration config ) throws ServiceRegistrationException, NoSuchElementException {\n    Service service = null;\n    if ( config.isLocal( ) && !this.serviceRegistry.hasLocalService( ) ) {\n      service = this.serviceRegistry.register( config );\n      try {\n        service.transition( State.INITIALIZED );\n      } catch ( IllegalStateException ex ) {\n        LOG.error( ex, ex );\n        throw new ServiceRegistrationException( \"Loading service \" + config + \" failed because of: \" + ex.getMessage( ), ex );\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        throw new ServiceRegistrationException( \"Loading service \" + config + \" failed because of: \" + ex.getMessage( ), ex );\n      } catch ( ExistingTransitionException ex ) {\n        LOG.error( ex, ex );\n        throw new ServiceRegistrationException( \"Loading service \" + config + \" failed because of: \" + ex.getMessage( ), ex );\n      }\n    } else if ( this.serviceRegistry.hasService( config ) ) {\n      service = this.serviceRegistry.lookup( config );\n    } else {\n      service = this.serviceRegistry.register( config );\n    }\n    return service;\n  }","id":35615,"modified_method":"Service lookupRegisteredService( final ServiceConfiguration config ) throws ServiceRegistrationException, NoSuchElementException {\n    Service service = null;\n    if ( ( config.isLocal( ) || Internets.testLocal( config.getHostName( ) ) ) && !this.serviceRegistry.hasLocalService( ) ) {\n      service = this.serviceRegistry.register( config );\n      try {\n        service.transition( State.INITIALIZED );\n      } catch ( IllegalStateException ex ) {\n        LOG.error( ex, ex );\n        throw new ServiceRegistrationException( \"Loading service \" + config + \" failed because of: \" + ex.getMessage( ), ex );\n      } catch ( NoSuchElementException ex ) {\n        LOG.error( ex, ex );\n        throw new ServiceRegistrationException( \"Loading service \" + config + \" failed because of: \" + ex.getMessage( ), ex );\n      } catch ( ExistingTransitionException ex ) {\n        LOG.error( ex, ex );\n        throw new ServiceRegistrationException( \"Loading service \" + config + \" failed because of: \" + ex.getMessage( ), ex );\n      }\n    } else if ( this.serviceRegistry.hasService( config ) ) {\n      service = this.serviceRegistry.lookup( config );\n    } else {\n      service = this.serviceRegistry.register( config );\n    }\n    return service;\n  }","commit_id":"05bb97e2ecaed3853c39d03edcc26446ab16fbfd","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n     * @param cacheNames Cache names.\n     * @param topVer Topology version.\n     * @param explicitParts Explicit partitions list.\n     * @param reserved Reserved list.\n     * @return {@code true} If all the needed partitions successfully reserved.\n     * @throws IgniteCheckedException If failed.\n     */\n    private boolean reservePartitions(\n        Collection<String> cacheNames,\n        AffinityTopologyVersion topVer,\n        final int[] explicitParts,\n        List<GridReservable> reserved\n    ) throws IgniteCheckedException {\n        assert topVer != null;\n\n        Collection<Integer> partIds = wrap(explicitParts);\n\n        for (String cacheName : cacheNames) {\n            GridCacheContext<?, ?> cctx = cacheContext(cacheName);\n\n            if (cctx == null) // Cache was not found, probably was not deployed yet.\n                return false;\n\n            if (cctx.isLocal())\n                continue;\n\n            // For replicated cache topology version does not make sense.\n            final T2<String,AffinityTopologyVersion> grpKey =\n                new T2<>(cctx.name(), cctx.isReplicated() ? null : topVer);\n\n            GridReservable r = reservations.get(grpKey);\n\n            if (explicitParts == null && r != null) { // Try to reserve group partition if any and no explicits.\n                if (r != ReplicatedReservation.INSTANCE) {\n                    if (!r.reserve())\n                        return false; // We need explicit partitions here -> retry.\n\n                    reserved.add(r);\n                }\n            }\n            else { // Try to reserve partitions one by one.\n                int partsCnt = cctx.affinity().partitions();\n\n                if (cctx.isReplicated()) { // Check all the partitions are in owning state for replicated cache.\n                    if (r == null) { // Check only once.\n                        for (int p = 0; p < partsCnt; p++) {\n                            GridDhtLocalPartition part = partition(cctx, p);\n\n                            // We don't need to reserve partitions because they will not be evicted in replicated caches.\n                            if (part == null || part.state() != OWNING)\n                                return false;\n                        }\n\n                        // Mark that we checked this replicated cache.\n                        reservations.putIfAbsent(grpKey, ReplicatedReservation.INSTANCE);\n                    }\n                }\n                else { // Reserve primary partitions for partitioned cache (if no explicit given).\n                    if (explicitParts == null)\n                        partIds = cctx.affinity().primaryPartitions(ctx.localNodeId(), topVer);\n\n                    for (int partId : partIds) {\n                        GridDhtLocalPartition part = partition(cctx, partId);\n\n                        if (part == null || part.state() != OWNING || !part.reserve())\n                            return false;\n\n                        reserved.add(part);\n\n                        // Double check that we are still in owning state and partition contents are not cleared.\n                        if (part.state() != OWNING)\n                            return false;\n                    }\n\n                    if (explicitParts == null) {\n                        // We reserved all the primary partitions for cache, attempt to add group reservation.\n                        GridDhtPartitionsReservation grp = new GridDhtPartitionsReservation(topVer, cctx, \"SQL\");\n\n                        if (grp.register(reserved.subList(reserved.size() - partIds.size(), reserved.size()))) {\n                            if (reservations.putIfAbsent(grpKey, grp) != null)\n                                throw new IllegalStateException(\"Reservation already exists.\");\n\n                            grp.onPublish(new CI1<GridDhtPartitionsReservation>() {\n                                @Override public void apply(GridDhtPartitionsReservation r) {\n                                    reservations.remove(grpKey, r);\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","id":35616,"modified_method":"/**\n     * @param cacheNames Cache names.\n     * @param topVer Topology version.\n     * @param explicitParts Explicit partitions list.\n     * @param reserved Reserved list.\n     * @return {@code true} If all the needed partitions successfully reserved.\n     * @throws IgniteCheckedException If failed.\n     */\n    private boolean reservePartitions(\n        Collection<String> cacheNames,\n        AffinityTopologyVersion topVer,\n        final int[] explicitParts,\n        List<GridReservable> reserved\n    ) throws IgniteCheckedException {\n        assert topVer != null;\n\n        Collection<Integer> partIds = wrap(explicitParts);\n\n        for (String cacheName : cacheNames) {\n            GridCacheContext<?, ?> cctx = cacheContext(cacheName);\n\n            if (cctx == null) // Cache was not found, probably was not deployed yet.\n                return false;\n\n            if (cctx.isLocal() || !cctx.rebalanceEnabled())\n                continue;\n\n            // For replicated cache topology version does not make sense.\n            final T2<String,AffinityTopologyVersion> grpKey =\n                new T2<>(cctx.name(), cctx.isReplicated() ? null : topVer);\n\n            GridReservable r = reservations.get(grpKey);\n\n            if (explicitParts == null && r != null) { // Try to reserve group partition if any and no explicits.\n                if (r != ReplicatedReservation.INSTANCE) {\n                    if (!r.reserve())\n                        return false; // We need explicit partitions here -> retry.\n\n                    reserved.add(r);\n                }\n            }\n            else { // Try to reserve partitions one by one.\n                int partsCnt = cctx.affinity().partitions();\n\n                if (cctx.isReplicated()) { // Check all the partitions are in owning state for replicated cache.\n                    if (r == null) { // Check only once.\n                        for (int p = 0; p < partsCnt; p++) {\n                            GridDhtLocalPartition part = partition(cctx, p);\n\n                            // We don't need to reserve partitions because they will not be evicted in replicated caches.\n                            if (part == null || part.state() != OWNING)\n                                return false;\n                        }\n\n                        // Mark that we checked this replicated cache.\n                        reservations.putIfAbsent(grpKey, ReplicatedReservation.INSTANCE);\n                    }\n                }\n                else { // Reserve primary partitions for partitioned cache (if no explicit given).\n                    if (explicitParts == null)\n                        partIds = cctx.affinity().primaryPartitions(ctx.localNodeId(), topVer);\n\n                    for (int partId : partIds) {\n                        GridDhtLocalPartition part = partition(cctx, partId);\n\n                        if (part == null || part.state() != OWNING || !part.reserve())\n                            return false;\n\n                        reserved.add(part);\n\n                        // Double check that we are still in owning state and partition contents are not cleared.\n                        if (part.state() != OWNING)\n                            return false;\n                    }\n\n                    if (explicitParts == null) {\n                        // We reserved all the primary partitions for cache, attempt to add group reservation.\n                        GridDhtPartitionsReservation grp = new GridDhtPartitionsReservation(topVer, cctx, \"SQL\");\n\n                        if (grp.register(reserved.subList(reserved.size() - partIds.size(), reserved.size()))) {\n                            if (reservations.putIfAbsent(grpKey, grp) != null)\n                                throw new IllegalStateException(\"Reservation already exists.\");\n\n                            grp.onPublish(new CI1<GridDhtPartitionsReservation>() {\n                                @Override public void apply(GridDhtPartitionsReservation r) {\n                                    reservations.remove(grpKey, r);\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","commit_id":"f238b760b683a0fe75132e84d37f2a4f3cf32086","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return Test suite.\n     * @throws Exception If failed.\n     */\n    public static TestSuite suite() throws Exception {\n        TestSuite suite = new TestSuite(\"Ignite Cache Queries Test Suite\");\n\n        // Parsing\n        suite.addTestSuite(GridQueryParsingTest.class);\n\n        // Config.\n        suite.addTestSuite(IgniteCacheDuplicateEntityConfigurationSelfTest.class);\n\n        // Queries tests.\n        suite.addTestSuite(IgniteSqlSplitterSelfTest.class);\n        suite.addTestSuite(IgniteSqlSchemaIndexingTest.class);\n        suite.addTestSuite(GridCacheQueryIndexDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryLoadSelfTest.class);\n        suite.addTestSuite(IgniteCacheLocalQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheLocalAtomicQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheReplicatedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheReplicatedQueryP2PDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedSnapshotEnabledQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheAtomicQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheAtomicNearEnabledQuerySelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQueryP2PDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryIndexSelfTest.class);\n        suite.addTestSuite(IgniteCacheCollocatedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheLargeResultSelfTest.class);\n        suite.addTestSuite(GridCacheQueryInternalKeysSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryMultiThreadedOffHeapTieredSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryEvictsMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryOffheapMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryOffheapEvictsMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapEvictQueryTest.class);\n        suite.addTestSuite(IgniteCacheSqlQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapTieredMultithreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapIndexScanTest.class);\n        suite.addTestSuite(IgniteCacheQueryNodeRestartSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryNodeRestartSelfTest2.class);\n        suite.addTestSuite(IgniteCacheQueryNodeFailTest.class);\n        suite.addTestSuite(IgniteCacheClientQueryReplicatedNodeRestartSelfTest.class);\n        suite.addTestSuite(GridCacheReduceQueryMultithreadedSelfTest.class);\n        suite.addTestSuite(GridCacheCrossCacheQuerySelfTest.class);\n        suite.addTestSuite(GridCacheQuerySerializationSelfTest.class);\n        suite.addTestSuite(IgniteBinaryObjectFieldsQuerySelfTest.class);\n        suite.addTestSuite(IgniteBinaryWrappedObjectFieldsQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryH2IndexingLeakTest.class);\n\n        return suite;\n    }","id":35617,"modified_method":"/**\n     * @return Test suite.\n     * @throws Exception If failed.\n     */\n    public static TestSuite suite() throws Exception {\n        TestSuite suite = new TestSuite(\"Ignite Cache Queries Test Suite\");\n\n        // Parsing\n        suite.addTestSuite(GridQueryParsingTest.class);\n\n        // Config.\n        suite.addTestSuite(IgniteCacheDuplicateEntityConfigurationSelfTest.class);\n\n        // Queries tests.\n        suite.addTestSuite(IgniteSqlSplitterSelfTest.class);\n        suite.addTestSuite(IgniteSqlSchemaIndexingTest.class);\n        suite.addTestSuite(GridCacheQueryIndexDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryLoadSelfTest.class);\n        suite.addTestSuite(IgniteCacheLocalQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheLocalAtomicQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheReplicatedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheReplicatedQueryP2PDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedSnapshotEnabledQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheAtomicQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheAtomicNearEnabledQuerySelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQueryP2PDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryIndexSelfTest.class);\n        suite.addTestSuite(IgniteCacheCollocatedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheLargeResultSelfTest.class);\n        suite.addTestSuite(GridCacheQueryInternalKeysSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryMultiThreadedOffHeapTieredSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryEvictsMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryOffheapMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryOffheapEvictsMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapEvictQueryTest.class);\n        suite.addTestSuite(IgniteCacheSqlQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapTieredMultithreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapIndexScanTest.class);\n        suite.addTestSuite(IgniteCacheQueryNodeRestartSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryNodeRestartSelfTest2.class);\n        suite.addTestSuite(IgniteCacheQueryNodeFailTest.class);\n        suite.addTestSuite(IgniteCacheClientQueryReplicatedNodeRestartSelfTest.class);\n        suite.addTestSuite(GridCacheReduceQueryMultithreadedSelfTest.class);\n        suite.addTestSuite(GridCacheCrossCacheQuerySelfTest.class);\n        suite.addTestSuite(GridCacheQuerySerializationSelfTest.class);\n        suite.addTestSuite(IgniteBinaryObjectFieldsQuerySelfTest.class);\n        suite.addTestSuite(IgniteBinaryWrappedObjectFieldsQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryH2IndexingLeakTest.class);\n        suite.addTestSuite(IgniteCacheQueryNoRebalanceSelfTest.class);\n\n        return suite;\n    }","commit_id":"f238b760b683a0fe75132e84d37f2a4f3cf32086","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param cacheNames Cache names.\n     * @param topVer Topology version.\n     * @param explicitParts Explicit partitions list.\n     * @param reserved Reserved list.\n     * @return {@code true} If all the needed partitions successfully reserved.\n     * @throws IgniteCheckedException If failed.\n     */\n    private boolean reservePartitions(\n        Collection<String> cacheNames,\n        AffinityTopologyVersion topVer,\n        final int[] explicitParts,\n        List<GridReservable> reserved\n    ) throws IgniteCheckedException {\n        assert topVer != null;\n\n        Collection<Integer> partIds = wrap(explicitParts);\n\n        for (String cacheName : cacheNames) {\n            GridCacheContext<?, ?> cctx = cacheContext(cacheName);\n\n            if (cctx == null) // Cache was not found, probably was not deployed yet.\n                return false;\n\n            if (cctx.isLocal())\n                continue;\n\n            // For replicated cache topology version does not make sense.\n            final T2<String,AffinityTopologyVersion> grpKey =\n                new T2<>(cctx.name(), cctx.isReplicated() ? null : topVer);\n\n            GridReservable r = reservations.get(grpKey);\n\n            if (explicitParts == null && r != null) { // Try to reserve group partition if any and no explicits.\n                if (r != ReplicatedReservation.INSTANCE) {\n                    if (!r.reserve())\n                        return false; // We need explicit partitions here -> retry.\n\n                    reserved.add(r);\n                }\n            }\n            else { // Try to reserve partitions one by one.\n                int partsCnt = cctx.affinity().partitions();\n\n                if (cctx.isReplicated()) { // Check all the partitions are in owning state for replicated cache.\n                    if (r == null) { // Check only once.\n                        for (int p = 0; p < partsCnt; p++) {\n                            GridDhtLocalPartition part = partition(cctx, p);\n\n                            // We don't need to reserve partitions because they will not be evicted in replicated caches.\n                            if (part == null || part.state() != OWNING)\n                                return false;\n                        }\n\n                        // Mark that we checked this replicated cache.\n                        reservations.putIfAbsent(grpKey, ReplicatedReservation.INSTANCE);\n                    }\n                }\n                else { // Reserve primary partitions for partitioned cache (if no explicit given).\n                    if (explicitParts == null)\n                        partIds = cctx.affinity().primaryPartitions(ctx.localNodeId(), topVer);\n\n                    for (int partId : partIds) {\n                        GridDhtLocalPartition part = partition(cctx, partId);\n\n                        if (part == null || part.state() != OWNING || !part.reserve())\n                            return false;\n\n                        reserved.add(part);\n\n                        // Double check that we are still in owning state and partition contents are not cleared.\n                        if (part.state() != OWNING)\n                            return false;\n                    }\n\n                    if (explicitParts == null) {\n                        // We reserved all the primary partitions for cache, attempt to add group reservation.\n                        GridDhtPartitionsReservation grp = new GridDhtPartitionsReservation(topVer, cctx, \"SQL\");\n\n                        if (grp.register(reserved.subList(reserved.size() - partIds.size(), reserved.size()))) {\n                            if (reservations.putIfAbsent(grpKey, grp) != null)\n                                throw new IllegalStateException(\"Reservation already exists.\");\n\n                            grp.onPublish(new CI1<GridDhtPartitionsReservation>() {\n                                @Override public void apply(GridDhtPartitionsReservation r) {\n                                    reservations.remove(grpKey, r);\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","id":35618,"modified_method":"/**\n     * @param cacheNames Cache names.\n     * @param topVer Topology version.\n     * @param explicitParts Explicit partitions list.\n     * @param reserved Reserved list.\n     * @return {@code true} If all the needed partitions successfully reserved.\n     * @throws IgniteCheckedException If failed.\n     */\n    private boolean reservePartitions(\n        Collection<String> cacheNames,\n        AffinityTopologyVersion topVer,\n        final int[] explicitParts,\n        List<GridReservable> reserved\n    ) throws IgniteCheckedException {\n        assert topVer != null;\n\n        Collection<Integer> partIds = wrap(explicitParts);\n\n        for (String cacheName : cacheNames) {\n            GridCacheContext<?, ?> cctx = cacheContext(cacheName);\n\n            if (cctx == null) // Cache was not found, probably was not deployed yet.\n                return false;\n\n            if (cctx.isLocal() || !cctx.rebalanceEnabled())\n                continue;\n\n            // For replicated cache topology version does not make sense.\n            final T2<String,AffinityTopologyVersion> grpKey =\n                new T2<>(cctx.name(), cctx.isReplicated() ? null : topVer);\n\n            GridReservable r = reservations.get(grpKey);\n\n            if (explicitParts == null && r != null) { // Try to reserve group partition if any and no explicits.\n                if (r != ReplicatedReservation.INSTANCE) {\n                    if (!r.reserve())\n                        return false; // We need explicit partitions here -> retry.\n\n                    reserved.add(r);\n                }\n            }\n            else { // Try to reserve partitions one by one.\n                int partsCnt = cctx.affinity().partitions();\n\n                if (cctx.isReplicated()) { // Check all the partitions are in owning state for replicated cache.\n                    if (r == null) { // Check only once.\n                        for (int p = 0; p < partsCnt; p++) {\n                            GridDhtLocalPartition part = partition(cctx, p);\n\n                            // We don't need to reserve partitions because they will not be evicted in replicated caches.\n                            if (part == null || part.state() != OWNING)\n                                return false;\n                        }\n\n                        // Mark that we checked this replicated cache.\n                        reservations.putIfAbsent(grpKey, ReplicatedReservation.INSTANCE);\n                    }\n                }\n                else { // Reserve primary partitions for partitioned cache (if no explicit given).\n                    if (explicitParts == null)\n                        partIds = cctx.affinity().primaryPartitions(ctx.localNodeId(), topVer);\n\n                    for (int partId : partIds) {\n                        GridDhtLocalPartition part = partition(cctx, partId);\n\n                        if (part == null || part.state() != OWNING || !part.reserve())\n                            return false;\n\n                        reserved.add(part);\n\n                        // Double check that we are still in owning state and partition contents are not cleared.\n                        if (part.state() != OWNING)\n                            return false;\n                    }\n\n                    if (explicitParts == null) {\n                        // We reserved all the primary partitions for cache, attempt to add group reservation.\n                        GridDhtPartitionsReservation grp = new GridDhtPartitionsReservation(topVer, cctx, \"SQL\");\n\n                        if (grp.register(reserved.subList(reserved.size() - partIds.size(), reserved.size()))) {\n                            if (reservations.putIfAbsent(grpKey, grp) != null)\n                                throw new IllegalStateException(\"Reservation already exists.\");\n\n                            grp.onPublish(new CI1<GridDhtPartitionsReservation>() {\n                                @Override public void apply(GridDhtPartitionsReservation r) {\n                                    reservations.remove(grpKey, r);\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","commit_id":"d33f4db130d4379fa3ab7320ccf118a94c17b889","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return Test suite.\n     * @throws Exception If failed.\n     */\n    public static TestSuite suite() throws Exception {\n        TestSuite suite = new TestSuite(\"Ignite Cache Queries Test Suite\");\n\n        // Parsing\n        suite.addTestSuite(GridQueryParsingTest.class);\n\n        // Config.\n        suite.addTestSuite(IgniteCacheDuplicateEntityConfigurationSelfTest.class);\n\n        // Queries tests.\n        suite.addTestSuite(IgniteSqlSplitterSelfTest.class);\n        suite.addTestSuite(IgniteSqlSchemaIndexingTest.class);\n        suite.addTestSuite(GridCacheQueryIndexDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryLoadSelfTest.class);\n        suite.addTestSuite(IgniteCacheLocalQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheLocalAtomicQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheReplicatedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheReplicatedQueryP2PDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedSnapshotEnabledQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheAtomicQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheAtomicNearEnabledQuerySelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQueryP2PDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryIndexSelfTest.class);\n        suite.addTestSuite(IgniteCacheCollocatedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheLargeResultSelfTest.class);\n        suite.addTestSuite(GridCacheQueryInternalKeysSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryMultiThreadedOffHeapTieredSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryEvictsMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryOffheapMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryOffheapEvictsMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapEvictQueryTest.class);\n        suite.addTestSuite(IgniteCacheSqlQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapTieredMultithreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapIndexScanTest.class);\n        suite.addTestSuite(IgniteCacheQueryNodeRestartSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryNodeRestartSelfTest2.class);\n        suite.addTestSuite(IgniteCacheQueryNodeFailTest.class);\n        suite.addTestSuite(IgniteCacheClientQueryReplicatedNodeRestartSelfTest.class);\n        suite.addTestSuite(GridCacheReduceQueryMultithreadedSelfTest.class);\n        suite.addTestSuite(GridCacheCrossCacheQuerySelfTest.class);\n        suite.addTestSuite(GridCacheQuerySerializationSelfTest.class);\n        suite.addTestSuite(IgniteBinaryObjectFieldsQuerySelfTest.class);\n        suite.addTestSuite(IgniteBinaryWrappedObjectFieldsQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryH2IndexingLeakTest.class);\n\n        return suite;\n    }","id":35619,"modified_method":"/**\n     * @return Test suite.\n     * @throws Exception If failed.\n     */\n    public static TestSuite suite() throws Exception {\n        TestSuite suite = new TestSuite(\"Ignite Cache Queries Test Suite\");\n\n        // Parsing\n        suite.addTestSuite(GridQueryParsingTest.class);\n\n        // Config.\n        suite.addTestSuite(IgniteCacheDuplicateEntityConfigurationSelfTest.class);\n\n        // Queries tests.\n        suite.addTestSuite(IgniteSqlSplitterSelfTest.class);\n        suite.addTestSuite(IgniteSqlSchemaIndexingTest.class);\n        suite.addTestSuite(GridCacheQueryIndexDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryLoadSelfTest.class);\n        suite.addTestSuite(IgniteCacheLocalQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheLocalAtomicQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheReplicatedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheReplicatedQueryP2PDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedSnapshotEnabledQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheAtomicQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheAtomicNearEnabledQuerySelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQueryP2PDisabledSelfTest.class);\n        suite.addTestSuite(IgniteCachePartitionedQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryIndexSelfTest.class);\n        suite.addTestSuite(IgniteCacheCollocatedQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheLargeResultSelfTest.class);\n        suite.addTestSuite(GridCacheQueryInternalKeysSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryMultiThreadedOffHeapTieredSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryEvictsMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryOffheapMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryOffheapEvictsMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapEvictQueryTest.class);\n        suite.addTestSuite(IgniteCacheSqlQueryMultiThreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapTieredMultithreadedSelfTest.class);\n        suite.addTestSuite(IgniteCacheOffheapIndexScanTest.class);\n        suite.addTestSuite(IgniteCacheQueryNodeRestartSelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryNodeRestartSelfTest2.class);\n        suite.addTestSuite(IgniteCacheQueryNodeFailTest.class);\n        suite.addTestSuite(IgniteCacheClientQueryReplicatedNodeRestartSelfTest.class);\n        suite.addTestSuite(GridCacheReduceQueryMultithreadedSelfTest.class);\n        suite.addTestSuite(GridCacheCrossCacheQuerySelfTest.class);\n        suite.addTestSuite(GridCacheQuerySerializationSelfTest.class);\n        suite.addTestSuite(IgniteBinaryObjectFieldsQuerySelfTest.class);\n        suite.addTestSuite(IgniteBinaryWrappedObjectFieldsQuerySelfTest.class);\n        suite.addTestSuite(IgniteCacheQueryH2IndexingLeakTest.class);\n        suite.addTestSuite(IgniteCacheQueryNoRebalanceSelfTest.class);\n\n        return suite;\n    }","commit_id":"d33f4db130d4379fa3ab7320ccf118a94c17b889","url":"https://github.com/apache/ignite"},{"original_method":"protected void perform(final Project project, final SvnVcs activeVcs, VirtualFile file, DataContext context, AbstractVcsHelper helper)\n    throws VcsException {\n    final File srcFile = new File(file.getPath());\n    CopyDialog dialog = new CopyDialog(project, true, srcFile);\n    dialog.show();\n    if (dialog.isOK()) {\n      final String dstURL = dialog.getToURL();\n      final SVNRevision revision = dialog.getRevision();\n      final String comment = dialog.getComment();\n      final SVNException[] exception = new SVNException[1];\n\n      Runnable copyCommand = new Runnable() {\n        public void run() {\n          try {\n            ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n            SVNCopyClient client = activeVcs.createCopyClient();\n            if (progress != null) {\n              progress.setText(SvnBundle.message(\"progress.text.copy.to\", dstURL));\n              client.setEventHandler(new CopyEventHandler(progress));\n            }\n            SVNCommitInfo result = client.doCopy(srcFile, revision, SVNURL.parseURIEncoded(dstURL), comment);\n            if (result != null && result != SVNCommitInfo.NULL) {\n              WindowManager.getInstance().getStatusBar(project).setInfo(\n                SvnBundle.message(\"status.text.comitted.revision\", result.getNewRevision()));\n            }\n          }\n          catch (SVNException e) {\n            exception[0] = e;\n          }\n        }\n      };\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(copyCommand, SvnBundle.message(\"progress.title.copy\"), false, project);\n      if (exception[0] != null) {\n        throw new VcsException(exception[0]);\n      }\n    }\n  }","id":35620,"modified_method":"protected void perform(final Project project, final SvnVcs activeVcs, VirtualFile file, DataContext context, AbstractVcsHelper helper)\n    throws VcsException {\n    CopyDialog dialog = new CopyDialog(project, true, new File(file.getPath()));\n    dialog.show();\n    if (dialog.isOK()) {\n      final String dstURL = dialog.getToURL();\n      final SVNRevision revision = dialog.getRevision();\n      final String comment = dialog.getComment();\n      final Ref<Exception> exception = new Ref<Exception>();\n      final boolean isSrcFile = dialog.isCopyFromWorkingCopy();\n      final File srcFile = new File(dialog.getCopyFromPath());\n      final SVNURL srcUrl;\n      final SVNURL dstSvnUrl;\n      final SVNURL parentUrl;\n      try {\n        final SVNWCClient wcClient = activeVcs.createWCClient();\n        srcUrl = SVNURL.parseURIEncoded(dialog.getCopyFromUrl());\n        dstSvnUrl = SVNURL.parseURIEncoded(dstURL);\n        parentUrl = dstSvnUrl.removePathTail();\n\n        if (!dirExists(parentUrl, wcClient)) {\n          int rc = Messages.showYesNoDialog(project, \"The repository path '\" + parentUrl + \"' does not exist. Would you like to create it?\",\n                                            \"Branch or Tag\", Messages.getQuestionIcon());\n          if (rc == 1) {\n            return;\n          }\n        }\n\n      }\n      catch (SVNException e) {\n        throw new VcsException(e);\n      }\n\n      Runnable copyCommand = new Runnable() {\n        public void run() {\n          try {\n            ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n            SVNCopyClient client = activeVcs.createCopyClient();\n            if (progress != null) {\n              progress.setText(SvnBundle.message(\"progress.text.copy.to\", dstURL));\n              client.setEventHandler(new CopyEventHandler(progress));\n            }\n            checkCreateDir(parentUrl, activeVcs, comment);\n            SVNCommitInfo result;\n            if (isSrcFile) {\n              result = client.doCopy(srcFile, revision, dstSvnUrl, comment);\n            }\n            else {\n              result = client.doCopy(srcUrl, revision, dstSvnUrl, false, comment);\n            }\n            if (result != null && result != SVNCommitInfo.NULL) {\n              WindowManager.getInstance().getStatusBar(project)\n                .setInfo(SvnBundle.message(\"status.text.comitted.revision\", result.getNewRevision()));\n            }\n          }\n          catch (Exception e) {\n            exception.set(e);\n          }\n        }\n      };\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(copyCommand, SvnBundle.message(\"progress.title.copy\"), false, project);\n      if (!exception.isNull()) {\n        throw new VcsException(exception.get());\n      }\n    }\n  }","commit_id":"940249cb757f9df066dd121a61227af6f09c5551","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isOKActionEnabled() {\n    if (myURL == null) {\n      return false;\n    }\n    String url = myToURLText.getText();\n    if (url != null && url.trim().length() > 0) {\n      if (mySpecificRevisionButton.isSelected()) {\n        String revStr = myRevisionText.getText();\n        SVNRevision revision = SVNRevision.parse(revStr);\n        if (revision != null && revision.isValid() && !revision.isLocal()) {\n          return true;\n        }\n      }\n      return true;\n    }\n    return false;\n  }","id":35621,"modified_method":"public boolean isOKActionEnabled() {\n    myErrorLabel.setText(\" \");\n    if (myURL == null) {\n      return false;\n    }\n    String url = myToURLText.getText();\n    if (url != null && url.trim().length() > 0) {\n      if (myRepositoryRadioButton.isSelected()) {\n        SVNRevision revision;\n        try {\n          revision = myRevisionPanel.getRevision();\n        }\n        catch (ConfigurationException e) {\n          revision = SVNRevision.UNDEFINED;\n        }\n        if (!revision.isValid() || revision.isLocal()) {\n          myErrorLabel.setText(\"Invalid revision '\" + myRevisionPanel.getRevisionText() + \"'\");\n          return false;\n        }\n        return true;\n      }\n      else if (myWorkingCopyRadioButton.isSelected()) {\n        File wcFile = new File(myWorkingCopyField.getText());\n        if (wcFile.isFile()) {\n          wcFile = wcFile.getParentFile();\n        }\n        try {\n          SVNWCClient client = SvnVcs.getInstance(myProject).createWCClient();\n          SVNInfo info = client.doInfo(mySrcFile, SVNRevision.WORKING);\n          mySrcURL = info != null && info.getURL() != null ? info.getURL().toString() : null;\n        }\n        catch (SVNException e) {\n          mySrcURL = null;\n        }\n        if (mySrcURL == null) {\n          myErrorLabel.setText(\"No working copy found at \" + myWorkingCopyField.getText());\n          return false;\n        }\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"940249cb757f9df066dd121a61227af6f09c5551","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SVNRevision getRevision() {\n    if (myWorkingRevisionButton.isSelected()) {\n      return SVNRevision.WORKING;\n    }\n    else if (myHEADRevisionButton.isSelected()) {\n      return SVNRevision.HEAD;\n    }\n    else {\n      String revStr = myRevisionText.getText();\n      return SVNRevision.parse(revStr);\n    }\n  }","id":35622,"modified_method":"public SVNRevision getRevision() {\n    if (myWorkingCopyRadioButton.isSelected()) {\n      return SVNRevision.WORKING;\n    }\n    else {\n      try {\n        return myRevisionPanel.getRevision();\n      }\n      catch (ConfigurationException e) {\n        return SVNRevision.UNDEFINED;\n      }\n    }\n  }","commit_id":"940249cb757f9df066dd121a61227af6f09c5551","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void init() {\n    super.init();\n    SvnVcs vcs = SvnVcs.getInstance(myProject);\n    String revStr = \"\";\n    try {\n      SVNWCClient client = vcs.createWCClient();\n      SVNInfo info = client.doInfo(mySrcFile, SVNRevision.WORKING);\n      if (info != null) {\n        mySrcURL = info.getURL() == null ? null : info.getURL().toString();\n        revStr = String.valueOf(info.getRevision());\n        myURL = mySrcURL;\n        if (myURL != null) {\n          @NonNls String dstName = \"CopyOf\" + SVNPathUtil.tail(myURL);\n          if (mySrcFile.isDirectory()) {\n            myURL = SVNPathUtil.append(myURL, dstName);\n          }\n          else {\n            myURL = SVNPathUtil.append(SVNPathUtil.removeTail(myURL), dstName);\n          }\n        }\n      }\n    }\n    catch (SVNException e) {\n      //\n    }\n    if (myURL == null) {\n      return;\n    }\n    myFromURLText.setText(mySrcURL);\n    myToURLText.setText(myURL);\n    myRevisionText.setText(revStr);\n    myRevisionText.selectAll();\n    myRevisionText.setEnabled(mySpecificRevisionButton.isSelected());\n\n    myWorkingRevisionButton.setSelected(true);\n\n    getOKAction().setEnabled(isOKActionEnabled());\n  }","id":35623,"modified_method":"protected void init() {\n    super.init();\n    SvnVcs vcs = SvnVcs.getInstance(myProject);\n    String revStr = \"\";\n    try {\n      SVNWCClient client = vcs.createWCClient();\n      SVNInfo info = client.doInfo(mySrcFile, SVNRevision.WORKING);\n      if (info != null) {\n        mySrcURL = info.getURL() == null ? null : info.getURL().toString();\n        revStr = String.valueOf(info.getRevision());\n        myURL = mySrcURL;\n      }\n    }\n    catch (SVNException e) {\n      //\n    }\n    if (myURL == null) {\n      return;\n    }\n    myWorkingCopyField.setText(mySrcFile.toString());\n    myRepositoryField.setText(mySrcURL);\n    myToURLText.setText(myURL);\n    myRevisionPanel.setRevisionText(revStr);\n    updateControls();\n\n    myWorkingCopyRadioButton.setSelected(true);\n  }","commit_id":"940249cb757f9df066dd121a61227af6f09c5551","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CopyDialog(Project project, boolean canBeParent, File file) {\n    super(project, canBeParent);\n    mySrcFile = file;\n    myProject = project;\n    setResizable(true);\n    setTitle(SvnBundle.message(\"dialog.title.branch\"));\n    getHelpAction().setEnabled(true);\n\n    myToURLText.addActionListener(this);\n    myWorkingRevisionButton.addActionListener(this);\n    myHEADRevisionButton.addActionListener(this);\n    mySpecificRevisionButton.addActionListener(this);\n\n    myRevisionText.setMinimumSize(myRevisionText.getPreferredSize());\n    myRevisionText.getDocument().addDocumentListener(new DocumentListener() {\n      public void insertUpdate(DocumentEvent e) {\n        getOKAction().setEnabled(isOKActionEnabled());\n      }\n\n      public void removeUpdate(DocumentEvent e) {\n        getOKAction().setEnabled(isOKActionEnabled());\n      }\n\n      public void changedUpdate(DocumentEvent e) {\n        getOKAction().setEnabled(isOKActionEnabled());\n      }\n    });\n\n    init();\n  }","id":35624,"modified_method":"public CopyDialog(final Project project, boolean canBeParent, File file) {\n    super(project, canBeParent);\n    mySrcFile = file;\n    myProject = project;\n    setResizable(true);\n    setTitle(SvnBundle.message(\"dialog.title.branch\"));\n    getHelpAction().setEnabled(true);\n    myProjectButton.setIcon(IconLoader.getIcon(\"/nodes/ideaProject.png\"));\n    myBranchTagBaseComboBox.setPreferredSize(new Dimension(myBranchTagBaseComboBox.getPreferredSize().width,\n                                                           myWorkingCopyField.getPreferredSize().height));\n\n    myWorkingCopyField.addBrowseFolderListener(\"Select Working Copy Location\", \"Select Location to Copy From:\",\n                                               project, new FileChooserDescriptor(false, true, false, false, false, false));\n    myWorkingCopyField.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        updateControls();\n      }\n    });\n    myRepositoryField.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        SelectLocationDialog dlg = new SelectLocationDialog(project, myRepositoryField.getText());\n        dlg.show();\n        if (dlg.isOK()) {\n          myRepositoryField.setText(dlg.getSelectedURL());\n        }\n      }\n    });\n    myRepositoryField.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        updateToURL();\n      }\n    });\n    myToURLText.addActionListener(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        String url = myToURLText.getText();\n        String dstName = SVNPathUtil.tail(mySrcURL);\n        dstName = SVNEncodingUtil.uriDecode(dstName);\n        SelectLocationDialog dialog = new SelectLocationDialog(myProject, SVNPathUtil.removeTail(url), SvnBundle.message(\"label.copy.select.location.dialog.copy.as\"), dstName, false);\n        dialog.show();\n        if (dialog.isOK()) {\n          url = dialog.getSelectedURL();\n          String name = dialog.getDestinationName();\n          url = SVNPathUtil.append(url, name);\n          myToURLText.setText(url);\n        }\n      }\n    });\n    myRevisionPanel.setProject(myProject);\n    myRevisionPanel.setUrlProvider(new SvnRevisionPanel.UrlProvider() {\n      public String getUrl() {\n        return mySrcURL;\n      }\n    });\n\n    mySrcVirtualFile = LocalFileSystem.getInstance().findFileByIoFile(file);\n    mySrcVirtualFile = ProjectLevelVcsManager.getInstance(project).getVcsRootFor(mySrcVirtualFile);\n    updateBranchTagBases();\n\n    myRevisionPanel.addChangeListener(new ChangeListener() {\n      public void stateChanged(final ChangeEvent e) {\n        getOKAction().setEnabled(isOKActionEnabled());\n      }\n    });\n\n    init();\n    ActionListener listener = new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateControls();\n      }\n    };\n    myWorkingCopyRadioButton.addActionListener(listener);\n    myRepositoryRadioButton.addActionListener(listener);\n    myBranchOrTagRadioButton.addActionListener(listener);\n    myAnyLocationRadioButton.addActionListener(listener);\n    updateControls();\n    myBranchTextField.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        updateToURL();\n      }\n    });\n    updateToURL();\n    myProjectButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myRepositoryField.setText(myBranchConfiguration.getBaseUrl(mySrcURL));\n      }\n    });\n    myBranchTagBaseComboBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        BranchConfigurationDialog.configureBranches(project, mySrcVirtualFile);\n        updateBranchTagBases();\n      }\n    });\n    myBranchTagBaseComboBox.getComboBox().addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateToURL();\n      }\n    });\n  }","commit_id":"940249cb757f9df066dd121a61227af6f09c5551","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SvnRevisionPanel() {\n    super(new BorderLayout());\n    add(myPanel);\n    myHead.setSelected(true);\n    myRevisionField.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        chooseRevision();\n      }\n    });\n\n//    myRevisionField.setEditable(false);\n    myRevisionField.setEnabled(false);\n\n    mySpecified.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (mySpecified.isSelected()) {\n          if (myRevisionField.getText().trim().length() == 0) {\n            myRevisionField.setText(\"HEAD\");\n          }\n          myRevisionField.setEnabled(true);\n        } else {\n          myRevisionField.setEnabled(false);\n        }\n      }\n    });\n\n    myHead.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myRevisionField.setEnabled(false);\n      }\n    });\n\n    myRevisionField.getTextField().setColumns(10);\n  }","id":35625,"modified_method":"public SvnRevisionPanel() {\n    super(new BorderLayout());\n    add(myPanel);\n    myHead.setSelected(true);\n    myRevisionField.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        chooseRevision();\n      }\n    });\n\n//    myRevisionField.setEditable(false);\n    myRevisionField.setEnabled(false);\n\n    mySpecified.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        if (mySpecified.isSelected()) {\n          if (myRevisionField.getText().trim().length() == 0) {\n            myRevisionField.setText(\"HEAD\");\n          }\n          myRevisionField.setEnabled(true);\n        } else {\n          myRevisionField.setEnabled(false);\n        }\n        notifyChangeListeners();\n      }\n    });\n\n    myHead.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        myRevisionField.setEnabled(false);\n        notifyChangeListeners();\n      }\n    });\n\n    myRevisionField.getTextField().setColumns(10);\n    myRevisionField.getTextField().getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(final DocumentEvent e) {\n        notifyChangeListeners();\n      }\n    });\n  }","commit_id":"940249cb757f9df066dd121a61227af6f09c5551","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visit(Tree.AttributeDeclaration decl){\n        if(hasErrors(decl))\n            return;\n        boolean annots = gen.checkCompilerAnnotations(decl);\n        if (Decl.withinClassOrInterface(decl)) {\n            // Class attributes\n            gen.classGen().transform(decl, classBuilder);\n        } else if (Decl.isToplevel(decl)) {\n            topattrBuilder.add(decl);\n        } else if (Decl.isLocal(decl) \n                && Decl.isCaptured(decl) \n                && decl.getDeclarationModel().isVariable()) {\n            // Captured local attributes get turned into an inner getter/setter class\n            appendList(gen.transform(decl));\n        } else {\n            // All other local attributes\n            appendList(gen.statementGen().transform(decl));\n        }\n        gen.resetCompilerAnnotations(annots);\n    }","id":35626,"modified_method":"public void visit(Tree.AttributeDeclaration decl){\n        if(hasErrors(decl))\n            return;\n        boolean annots = gen.checkCompilerAnnotations(decl);\n        if (Decl.withinClassOrInterface(decl)) {\n            // Class attributes\n            gen.classGen().transform(decl, classBuilder);\n        } else if (Decl.isToplevel(decl)) {\n            topattrBuilder.add(decl);\n        } else if (Decl.isLocal(decl) \n                && ((Decl.isCaptured(decl) && Decl.isVariable(decl))\n                        || Decl.isTransient(decl)\n                        || Decl.hasSetter(decl))) {\n            // Captured local attributes get turned into an inner getter/setter class\n            appendList(gen.transform(decl));\n        } else {\n            // All other local attributes\n            appendList(gen.statementGen().transform(decl));\n        }\n        gen.resetCompilerAnnotations(annots);\n    }","commit_id":"066b7d1c876af596b6ff1b7853d9b78e1da63f08","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n   * Join each element in paths in order, separated by {@code TachyonURI.SEPARATOR}.\n   * <p>\n   * For example, {@code concatPath(\"/myroot/\", \"dir\", 1L, \"filename\")} returns\n   * {@code \"/myroot/dir/1/filename\"}\n   *\n   * @param paths to concatenate\n   * @return joined path\n   */\n  public static String concatPath(Object... paths) {\n    List<String> trimmedPathList = new ArrayList<String>();\n    boolean isAbsPath = false;\n    for (int k = 0; k < paths.length; k ++) {\n      String path = paths[k].toString().trim();\n      String trimmedPath;\n      if (k == 0) {\n        trimmedPath = CharMatcher.is(TachyonURI.SEPARATOR.charAt(0)).trimTrailingFrom(path);\n        if (path.startsWith(TachyonURI.SEPARATOR)) {\n          isAbsPath = true;\n        }\n      } else {\n        trimmedPath = CharMatcher.is(TachyonURI.SEPARATOR.charAt(0)).trimFrom(path);\n        if (trimmedPath == null || trimmedPath.isEmpty()) {\n          continue;\n        }\n      }\n      trimmedPathList.add(trimmedPath);\n    }\n    if (trimmedPathList.size() == 1 && trimmedPathList.get(0).isEmpty() && isAbsPath) {\n      return TachyonURI.SEPARATOR;\n    }\n    return Joiner.on(TachyonURI.SEPARATOR).join(trimmedPathList);\n  }","id":35627,"modified_method":"/**\n   * Join each element in paths in order, separated by {@code TachyonURI.SEPARATOR}.\n   * <p>\n   * For example, {@code concatPath(\"/myroot/\", \"dir\", 1L, \"filename\")} returns\n   * {@code \"/myroot/dir/1/filename\"}, or\n   * {@code concatPath(\"tachyon://myroot\", \"dir\", \"filename\")} returns\n   * {@code \"tachyon://myroot/dir/filename\"}.\n   *\n   * @param paths to concatenate\n   * @return joined path\n   */\n  public static String concatPath(Object... paths) {\n    List<String> trimmedPathList = new ArrayList<String>();\n    String joinedPath;\n    String prefix = null;\n    if (paths.length == 0) {\n      return \"\";\n    }\n    if (paths[0] != null && !paths[0].toString().isEmpty()) {\n      prefix = paths[0].toString().trim();\n      prefix = CharMatcher.is(TachyonURI.SEPARATOR.charAt(0)).trimTrailingFrom(prefix);\n    }\n    for (int k = 1; k < paths.length; ++ k) {\n      String path = paths[k].toString().trim();\n      trimmedPathList.add(CharMatcher.is(TachyonURI.SEPARATOR.charAt(0)).trimFrom(path));\n    }\n    joinedPath = CharMatcher.is(TachyonURI.SEPARATOR.charAt(0)).collapseFrom(\n      Joiner.on(TachyonURI.SEPARATOR).join(trimmedPathList), TachyonURI.SEPARATOR.charAt(0));\n    if (prefix == null) {\n      return joinedPath;\n    }\n    if (joinedPath.isEmpty()) {\n      if (prefix.isEmpty()) {\n        return TachyonURI.SEPARATOR;\n      } else {\n        return prefix;\n      }\n    }\n    return prefix + TachyonURI.SEPARATOR + joinedPath;\n  }","commit_id":"9807ce843f97db4f8f762280d5b212c667f86482","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void concatPath() {\n    Assert.assertEquals(\"\", CommonUtils.concatPath());\n    Assert.assertEquals(\"/\", CommonUtils.concatPath(\"/\", \"\"));\n    Assert.assertEquals(\"/bar\", CommonUtils.concatPath(\"/\", \"bar\"));\n\n    Assert.assertEquals(\"foo\", CommonUtils.concatPath(\"foo\"));\n    Assert.assertEquals(\"/foo\", CommonUtils.concatPath(\"/foo\"));\n    Assert.assertEquals(\"/foo\", CommonUtils.concatPath(\"/foo\", \"\"));\n\n    // Join base without trailing \"/\"\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo\", \"bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo\", \"bar/\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo\", \"/bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo\", \"/bar/\"));\n\n    // Join base with trailing \"/\"\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"bar/\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"/bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"/bar/\"));\n\n    // Whitespace must be trimmed.\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo \", \"bar  \"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo \", \"  bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo \", \"  bar  \"));\n\n    // Redundant separator must be trimmed.\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"bar//\"));\n\n    // Multiple components to join.\n    Assert.assertEquals(\"/foo/bar/a/b/c\", CommonUtils.concatPath(\"/foo\", \"bar\", \"a\", \"b\", \"c\"));\n    Assert.assertEquals(\"/foo/bar/b/c\", CommonUtils.concatPath(\"/foo\", \"bar\", \"\", \"b\", \"c\"));\n\n    // Non-string\n    Assert.assertEquals(\"/foo/bar/1\", CommonUtils.concatPath(\"/foo\", \"bar\", 1));\n    Assert.assertEquals(\"/foo/bar/2\", CommonUtils.concatPath(\"/foo\", \"bar\", 2L));\n  }","id":35628,"modified_method":"@Test\n  public void concatPath() {\n    Assert.assertEquals(\"\", CommonUtils.concatPath());\n    Assert.assertEquals(\"/\", CommonUtils.concatPath(\"/\", \"\"));\n    Assert.assertEquals(\"/bar\", CommonUtils.concatPath(\"/\", \"bar\"));\n\n    Assert.assertEquals(\"foo\", CommonUtils.concatPath(\"foo\"));\n    Assert.assertEquals(\"/foo\", CommonUtils.concatPath(\"/foo\"));\n    Assert.assertEquals(\"/foo\", CommonUtils.concatPath(\"/foo\", \"\"));\n\n    // Join base without trailing \"/\"\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo\", \"bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo\", \"bar/\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo\", \"/bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo\", \"/bar/\"));\n\n    // Join base with trailing \"/\"\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"bar/\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"/bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"/bar/\"));\n\n    // Whitespace must be trimmed.\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo \", \"bar  \"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo \", \"  bar\"));\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo \", \"  bar  \"));\n\n    // Redundant separator must be trimmed.\n    Assert.assertEquals(\"/foo/bar\", CommonUtils.concatPath(\"/foo/\", \"bar//\"));\n\n    // Multiple components to join.\n    Assert.assertEquals(\"/foo/bar/a/b/c\", CommonUtils.concatPath(\"/foo\", \"bar\", \"a\", \"b\", \"c\"));\n    Assert.assertEquals(\"/foo/bar/b/c\", CommonUtils.concatPath(\"/foo\", \"bar\", \"\", \"b\", \"c\"));\n\n    // Non-string\n    Assert.assertEquals(\"/foo/bar/1\", CommonUtils.concatPath(\"/foo\", \"bar\", 1));\n    Assert.assertEquals(\"/foo/bar/2\", CommonUtils.concatPath(\"/foo\", \"bar\", 2L));\n\n    // Header\n    Assert.assertEquals(Constants.HEADER + \"host:port/foo/bar\",\n        CommonUtils.concatPath(Constants.HEADER + \"host:port\", \"/foo\", \"bar\"));\n  }","commit_id":"9807ce843f97db4f8f762280d5b212c667f86482","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n     * Returns the processed link of a given link.<p>\n     * \n     * @param link the link\n     * @return processed link\n     */\n    private String processLink(CmsLink link) {\n\n        if (link.isInternal()) {\n\n            CmsSite site = null;\n            \n            // if we have a local link, leave it unchanged\n            if (link.getUri().startsWith(\"#\")) {\n                return link.getUri();\n            }\n            // we are in the opencms root site but not in edit mode - use link as stored\n            if (!m_processEditorLinks && \"\".equals(m_cms.getRequestContext().getSiteRoot())) {\n                return OpenCms.getLinkManager().substituteLink(m_cms, link.getUri());    \n            }\n\n            // otherwise get the desired site root from the stored link\n            // - if there is no site root, we have a system link (or the site was deleted),\n            // return the link prefixed with the opencms context\n            String siteRoot = link.getSiteRoot();\n            if (siteRoot == null) {\n                return OpenCms.getLinkManager().substituteLink(m_cms, link.getUri());\n            } else {\n                site = CmsSiteManager.getSite(siteRoot);\n            }\n\n            \n            // check if the link has to be returned as relative or absolute link\n            if (m_cms.getRequestContext().getSiteRoot().equals(siteRoot) /* || m_processEditorLinks */) {\n                // if we are in the desired site, relative links are generated\n                return OpenCms.getLinkManager().substituteLink(m_cms, link.getVfsUri());\n            } else {\n                // otherwise, links are generated as absolute links\n                return site.getUrl() + OpenCms.getLinkManager().substituteLink(m_cms, link.getVfsUri());\n            }\n        } else {\n            \n            // don't touch external links\n            return link.getUri();\n        }\n    }","id":35629,"modified_method":"/**\n     * Returns the processed link of a given link.<p>\n     * \n     * @param link the link\n     * @return processed link\n     */\n    private String processLink(CmsLink link) {\n\n        if (link.isInternal()) {\n\n            // if we have a local link, leave it unchanged\n            if (link.getUri().charAt(0) == '#') {\n                return link.getUri();\n            }\n            \n            // we are in the opencms root site but not in edit mode - use link as stored\n            if (!m_processEditorLinks && (m_cms.getRequestContext().getSiteRoot().length() == 0)) {\n                return OpenCms.getLinkManager().substituteLink(m_cms, link.getUri());    \n            }\n\n            // otherwise get the desired site root from the stored link\n            // - if there is no site root, we have a system link (or the site was deleted),\n            // return the link prefixed with the opencms context\n            String siteRoot = link.getSiteRoot();\n            if (siteRoot == null) {\n                return OpenCms.getLinkManager().substituteLink(m_cms, link.getUri());\n            }\n            \n            // check if the link has to be returned as relative or absolute link\n            if (m_cms.getRequestContext().getSiteRoot().equals(siteRoot)) {\n                // if we are in the desired site, relative links are generated\n                return OpenCms.getLinkManager().substituteLink(m_cms, link.getVfsUri());\n            } else {\n                // otherwise, links are generated as absolute links\n                return CmsSiteManager.getSite(siteRoot).getUrl() \n                    + OpenCms.getLinkManager().substituteLink(m_cms, link.getVfsUri());\n            }\n        } else {            \n            // don't touch external links\n            return link.getUri();\n        }\n    }","commit_id":"af275fa5299b57fe9d6407d7ff44179db287766f","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/** Replaces wiki tags with HTML tags in one line of text.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    public String processLineOfWikiCode(String line) {\r\n        //If HTML has not bee replaced yet (can happen if method gets called in recursion), replace now!\r\n        if (!replacedHtmlAlready || preformattedSpanning) {\r\n            line = CharacterCoding.unicode2html(line, true);\r\n            replacedHtmlAlready = true;\r\n        }\r\n\r\n        //check if line contains preformatted symbols or if we are in a preformatted sequence already.\r\n        if ((line.indexOf(\"&lt;pre&gt;\") >= 0) || (line.indexOf(\"&lt;/pre&gt;\") >= 0) || (preformattedSpanning)) {\r\n            line = processPreformattedText(line);\r\n        } else {\r\n\r\n            //tables first -> wiki-tags in cells can be treated after that\r\n            line = processTable(line);\r\n\r\n            // format lines\r\n            if (line.length() > 0 && line.charAt(0) == ' ') {\r\n                line = \"<tt>\" + line.substring(1) + \"<\/tt>\";\r\n            }\r\n            if (line.startsWith(\"----\")) {\r\n                line = \"<hr />\";\r\n            }\r\n\r\n            // citings contributed by [MN]\r\n            if (line.length() > 0 && line.charAt(0) == ':') {\r\n                final StringBuilder head = new StringBuilder();\r\n                final StringBuilder tail = new StringBuilder();\r\n                while (line.length() > 0 && line.charAt(0) == ':') {\r\n                    head.append(OPEN_BLOCKQUOTE);\r\n                    tail.append(CLOSE_BLOCKQUOTE);\r\n                    line = line.substring(1);\r\n                }\r\n                line = head + line + tail;\r\n            }\r\n            // end contrib [MN]\t\r\n\r\n            // format headers\r\n            line = pairReplace(line, \"====\", \"<h4>\", \"<\/h4>\");\r\n            line = pairReplace(line, \"===\", \"<h3>\", \"<\/h3>\");\r\n            line = pairReplace(line, \"==\", \"<h2>\", \"<\/h2>\");\r\n\r\n            line = pairReplace(line, \"'''''\", \"<b><i>\", \"<\/i><\/b>\");\r\n            line = pairReplace(line, \"'''\", \"<b>\", \"<\/b>\");\r\n            line = pairReplace(line, \"''\", \"<i>\", \"<\/i>\");\r\n\r\n            line = processUnorderedList(line);\r\n            line = processOrderedList(line);\r\n            line = processDefinitionList(line);\r\n\r\n            line = processLinksAndImages(line);\r\n\r\n        }\r\n\r\n        if (!processingPreformattedText) {\r\n            replacedHtmlAlready = false;\r\n        }\r\n        if (!(line.endsWith(CLOSE_LIST_ELEMENT) || processingDefList || escape || processingPreformattedText || processingTable || processingCell)) {\r\n            line += \"<br />\";\r\n        }\r\n        return line;\r\n    }","id":35630,"modified_method":"/** Replaces wiki tags with HTML tags in one line of text.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    public String processLineOfWikiCode(String line) {\r\n        //If HTML has not bee replaced yet (can happen if method gets called in recursion), replace now!\r\n        if (!replacedHtmlAlready || preformattedSpanning) {\r\n            line = CharacterCoding.unicode2html(line, true);\r\n            replacedHtmlAlready = true;\r\n        }\r\n\r\n        //check if line contains preformatted symbols or if we are in a preformatted sequence already.\r\n        if ((line.indexOf(WIKI_OPEN_PRE_ESCAPED) >= 0) || (line.indexOf(WIKI_CLOSE_PRE_ESCAPED) >= 0) || (preformattedSpanning)) {\r\n            line = processPreformattedText(line);\r\n        } else {\r\n\r\n            //tables first -> wiki-tags in cells can be treated after that\r\n            line = processTable(line);\r\n\r\n            // format lines\r\n            if (line.length() > 0 && line.charAt(0) == WIKI_FORMATTED) {\r\n                line = \"<tt>\" + line.substring(1) + \"<\/tt>\";\r\n            }\r\n            if (line.startsWith(WIKI_HR_LINE)) {\r\n                line = \"<hr />\" + line.substring(LEN_WIKI_HR_LINE);\r\n            }\r\n\r\n            // citings contributed by [MN]\r\n            if (line.length() > 0 && line.charAt(0) == WIKI_INDENTION) {\r\n                final StringBuilder head = new StringBuilder();\r\n                final StringBuilder tail = new StringBuilder();\r\n                while (line.length() > 0 && line.charAt(0) == WIKI_INDENTION) {\r\n                    head.append(OPEN_BLOCKQUOTE);\r\n                    tail.append(CLOSE_BLOCKQUOTE);\r\n                    line = line.substring(1);\r\n                }\r\n                line = head + line + tail;\r\n            }\r\n            // end contrib [MN]\t\r\n\r\n            // format headers\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_3, \"<h4>\", \"<\/h4>\");\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_2, \"<h3>\", \"<\/h3>\");\r\n            line = pairReplace(line, WIKI_HEADLINE_TAG_1, \"<h2>\", \"<\/h2>\");\r\n\r\n            line = pairReplace(line, WIKI_EMPHASIZE_3, \"<b><i>\", \"<\/i><\/b>\");\r\n            line = pairReplace(line, WIKI_EMPHASIZE_2, \"<b>\", \"<\/b>\");\r\n            line = pairReplace(line, WIKI_EMPHASIZE_1, \"<i>\", \"<\/i>\");\r\n\r\n            line = processUnorderedList(line);\r\n            line = processOrderedList(line);\r\n            line = processDefinitionList(line);\r\n\r\n            line = processLinksAndImages(line);\r\n\r\n        }\r\n\r\n        if (!processingPreformattedText) {\r\n            replacedHtmlAlready = false;\r\n        }\r\n        if (!(line.endsWith(CLOSE_LIST_ELEMENT) || processingDefList || escape || processingPreformattedText || processingTable || processingCell)) {\r\n            line += \"<br />\";\r\n        }\r\n        return line;\r\n    }","commit_id":"5a9ea0308f79debccbaa90bf92641da4386167a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Processes tags which are connected to links and images.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processLinksAndImages(String line) {\r\n\r\n        // create links\r\n        String kl, kv, alt, align;\r\n        int p;\r\n        int positionOfOpeningTag;\r\n        int positionOfClosingTag;\r\n        // internal links and images\r\n        while ((positionOfOpeningTag = line.indexOf(WIKI_OPEN_LINK)) >= 0) {\r\n            positionOfClosingTag = line.indexOf(WIKI_CLOSE_LINK, positionOfOpeningTag + WIKI_OPEN_LINK.length());\r\n            if (positionOfClosingTag <= positionOfOpeningTag) {\r\n                break;\r\n            }\r\n            kl = line.substring(positionOfOpeningTag + WIKI_OPEN_LINK.length(), positionOfClosingTag);\r\n\r\n            // this is the part of the code that's responsible for images\r\n            // contributed by [MN]\r\n            if (kl.startsWith(\"Image:\")) {\r\n                alt = EMPTY;\r\n                align = EMPTY;\r\n                kv = EMPTY;\r\n                kl = kl.substring(6);\r\n\r\n                // are there any arguments for the image?\r\n                if ((p = kl.indexOf(PIPE_ESCAPED)) > 0) {\r\n                    kv = kl.substring(p + 6);\r\n                    kl = kl.substring(0, p);\r\n                    // if there are 2 arguments, write them into ALIGN and ALT\r\n                    if ((p = kv.indexOf(PIPE_ESCAPED)) > 0) {\r\n                        align = kv.substring(0, p);\r\n                        //checking validity of value for align. Only non browser specific\r\n                        //values get supported. Not supported: absmiddle, baseline, texttop\r\n                        if ((align.equals(\"bottom\"))\r\n                                || (align.equals(\"center\"))\r\n                                || (align.equals(\"left\"))\r\n                                || (align.equals(\"middle\"))\r\n                                || (align.equals(\"right\"))\r\n                                || (align.equals(\"top\"))) {\r\n                            align = \" align=\\\"\" + align + \"\\\"\";\r\n                        } else {\r\n                            align = EMPTY;\r\n                        }\r\n                        alt = \" alt=\\\"\" + kv.substring(p + 6) + \"\\\"\";\r\n                    } // if there is just one, put it into ALT\r\n                    else {\r\n                        alt = \" alt=\\\"\" + kv + \"\\\"\";\r\n                    }\r\n                }\r\n\r\n                // replace incomplete URLs and make them point to http://peerip:port/...\r\n                // with this feature you can access an image in DATA/HTDOCS/share/yacy.gif\r\n                // using the wikicode [[Image:share/yacy.gif]]\r\n                // or an image DATA/HTDOCS/grafics/kaskelix.jpg with [[Image:grafics/kaskelix.jpg]]\r\n                // you are free to use other sub-paths of DATA/HTDOCS\r\n                if (kl.indexOf(\"://\") < 1) {\r\n                    kl = \"http://\" + super.address + \"/\" + kl;\r\n                }\r\n\r\n                line = line.substring(0, positionOfOpeningTag) + \"<img src=\\\"\" + kl + \"\\\"\" + align + alt + \">\" + line.substring(positionOfClosingTag + 2);\r\n            } // end contrib [MN]\r\n            // if it's no image, it might be an internal link\r\n            else {\r\n                if ((p = kl.indexOf(PIPE_ESCAPED)) > 0) {\r\n                    kv = kl.substring(p + 6);\r\n                    kl = kl.substring(0, p);\r\n                } else {\r\n                    kv = kl;\r\n                }\r\n                line = line.substring(0, positionOfOpeningTag) + \"<a class=\\\"known\\\" href=\\\"Wiki.html?page=\" + kl + \"\\\">\" + kv + \"<\/a>\" + line.substring(positionOfClosingTag + 2); // oob exception in append() !\r\n            }\r\n        }\r\n\r\n        // external links\r\n        while ((positionOfOpeningTag = line.indexOf(\"[\")) >= 0) {\r\n            positionOfClosingTag = line.indexOf(\"]\", positionOfOpeningTag + 1);\r\n            if (positionOfClosingTag <= positionOfOpeningTag) {\r\n                break;\r\n            }\r\n            kl = line.substring(positionOfOpeningTag + 1, positionOfClosingTag);\r\n            if ((p = kl.indexOf(\" \")) > 0) {\r\n                kv = kl.substring(p + 1);\r\n                kl = kl.substring(0, p);\r\n            } // No text for the link? -> <a href=\"http://www.url.com/\">http://www.url.com/<\/a>\r\n            else {\r\n                kv = kl;\r\n            }\r\n            // replace incomplete URLs and make them point to http://peerip:port/...\r\n            // with this feature you can access a file at DATA/HTDOCS/share/page.html\r\n            // using the wikicode [share/page.html]\r\n            // or a file DATA/HTDOCS/www/page.html with [www/page.html]\r\n            // you are free to use other sub-paths of DATA/HTDOCS\r\n            if (kl.indexOf(\"://\") < 1) {\r\n                kl = \"http://\" + super.address + \"/\" + kl;\r\n            }\r\n            line = line.substring(0, positionOfOpeningTag) + \"<a class=\\\"extern\\\" href=\\\"\" + kl + \"\\\">\" + kv + \"<\/a>\" + line.substring(positionOfClosingTag + 1);\r\n        }\r\n        return line;\r\n    }","id":35631,"modified_method":"/**\r\n     * Processes tags which are connected to links and images.\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processLinksAndImages(String line) {\r\n\r\n        // create links\r\n        String kl, kv, alt, align;\r\n        int p;\r\n        int positionOfOpeningTag;\r\n        int positionOfClosingTag;\r\n        // internal links and images\r\n        while ((positionOfOpeningTag = line.indexOf(WIKI_OPEN_LINK)) >= 0) {\r\n            positionOfClosingTag = line.indexOf(WIKI_CLOSE_LINK, positionOfOpeningTag + LEN_WIKI_OPEN_LINK);\r\n            if (positionOfClosingTag <= positionOfOpeningTag) {\r\n                break;\r\n            }\r\n            kl = line.substring(positionOfOpeningTag + LEN_WIKI_OPEN_LINK, positionOfClosingTag);\r\n\r\n            // this is the part of the code that's responsible for images\r\n            // contributed by [MN]\r\n            if (kl.startsWith(WIKI_IMAGE)) {\r\n                alt = EMPTY;\r\n                align = EMPTY;\r\n                kv = EMPTY;\r\n                kl = kl.substring(LEN_WIKI_IMAGE);\r\n\r\n                // are there any arguments for the image?\r\n                if ((p = kl.indexOf(PIPE_ESCAPED)) > 0) {\r\n                    kv = kl.substring(p + LEN_WIKI_IMAGE);\r\n                    kl = kl.substring(0, p);\r\n                    // if there are 2 arguments, write them into ALIGN and ALT\r\n                    if ((p = kv.indexOf(PIPE_ESCAPED)) > 0) {\r\n                        align = kv.substring(0, p);\r\n                        //checking validity of value for align. Only non browser specific\r\n                        //values get supported. Not supported: absmiddle, baseline, texttop\r\n                        if ((align.equals(\"bottom\"))\r\n                                || (align.equals(\"center\"))\r\n                                || (align.equals(\"left\"))\r\n                                || (align.equals(\"middle\"))\r\n                                || (align.equals(\"right\"))\r\n                                || (align.equals(\"top\"))) {\r\n                            align = \" align=\\\"\" + align + \"\\\"\";\r\n                        } else {\r\n                            align = EMPTY;\r\n                        }\r\n                        alt = \" alt=\\\"\" + kv.substring(p + LEN_WIKI_IMAGE) + \"\\\"\";\r\n                    } // if there is just one, put it into ALT\r\n                    else {\r\n                        alt = \" alt=\\\"\" + kv + \"\\\"\";\r\n                    }\r\n                }\r\n\r\n                // replace incomplete URLs and make them point to http://peerip:port/...\r\n                // with this feature you can access an image in DATA/HTDOCS/share/yacy.gif\r\n                // using the wikicode [[Image:share/yacy.gif]]\r\n                // or an image DATA/HTDOCS/grafics/kaskelix.jpg with [[Image:grafics/kaskelix.jpg]]\r\n                // you are free to use other sub-paths of DATA/HTDOCS\r\n                if (kl.indexOf(\"://\") < 1) {\r\n                    kl = \"http://\" + super.address + \"/\" + kl;\r\n                }\r\n\r\n                line = line.substring(0, positionOfOpeningTag) + \"<img src=\\\"\" + kl + \"\\\"\" + align + alt + \">\" + line.substring(positionOfClosingTag + 2);\r\n            } // end contrib [MN]\r\n            // if it's no image, it might be an internal link\r\n            else {\r\n                if ((p = kl.indexOf(PIPE_ESCAPED)) > 0) {\r\n                    kv = kl.substring(p + 6);\r\n                    kl = kl.substring(0, p);\r\n                } else {\r\n                    kv = kl;\r\n                }\r\n                line = line.substring(0, positionOfOpeningTag) + \"<a class=\\\"known\\\" href=\\\"Wiki.html?page=\" + kl + \"\\\">\" + kv + \"<\/a>\" + line.substring(positionOfClosingTag + 2); // oob exception in append() !\r\n            }\r\n        }\r\n\r\n        // external links\r\n        while ((positionOfOpeningTag = line.indexOf(WIKI_OPEN_EXTERNAL_LINK)) >= 0) {\r\n            positionOfClosingTag = line.indexOf(WIKI_CLOSE_EXTERNAL_LINK, positionOfOpeningTag + LEN_WIKI_OPEN_EXTERNAL_LINK);\r\n            if (positionOfClosingTag <= positionOfOpeningTag) {\r\n                break;\r\n            }\r\n            kl = line.substring(positionOfOpeningTag + LEN_WIKI_OPEN_EXTERNAL_LINK, positionOfClosingTag);\r\n            if ((p = kl.indexOf(\" \")) > 0) {\r\n                kv = kl.substring(p + 1);\r\n                kl = kl.substring(0, p);\r\n            } // No text for the link? -> <a href=\"http://www.url.com/\">http://www.url.com/<\/a>\r\n            else {\r\n                kv = kl;\r\n            }\r\n            // replace incomplete URLs and make them point to http://peerip:port/...\r\n            // with this feature you can access a file at DATA/HTDOCS/share/page.html\r\n            // using the wikicode [share/page.html]\r\n            // or a file DATA/HTDOCS/www/page.html with [www/page.html]\r\n            // you are free to use other sub-paths of DATA/HTDOCS\r\n            if (kl.indexOf(\"://\") < 1) {\r\n                kl = \"http://\" + super.address + \"/\" + kl;\r\n            }\r\n            line = line.substring(0, positionOfOpeningTag) + \"<a class=\\\"extern\\\" href=\\\"\" + kl + \"\\\">\" + kv + \"<\/a>\" + line.substring(positionOfClosingTag + LEN_WIKI_CLOSE_EXTERNAL_LINK);\r\n        }\r\n        return line;\r\n    }","commit_id":"5a9ea0308f79debccbaa90bf92641da4386167a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** Creates table of contents for a wiki page.\r\n     * @return HTML fragment\r\n     */\r\n    private StringBuilder createTableOfContents() {\r\n        final StringBuilder directory = new StringBuilder();\r\n        String element;\r\n        int s = 0;\r\n        int level = 1;\r\n        int level1 = 0;\r\n        int level2 = 0;\r\n        int level3 = 0;\r\n        int doubles = 0;\r\n        String anchorext = EMPTY;\r\n        if ((s = tableOfContentElements.size()) > 2) {\r\n            directory.append(\"<table><tr><td><div class=\\\"WikiTOCBox\\\">\\n\");\r\n            for (int i = 0; i < s; i++) {\r\n                if (i >= tableOfContentElements.size()) {\r\n                    break;\r\n                }\r\n                element = tableOfContentElements.get(i);\r\n                if (element == null) {\r\n                    continue;\r\n                }\r\n                //counting double headlines\r\n                doubles = 0;\r\n                for (int j = 0; j < i; j++) {\r\n                    if (j >= tableOfContentElements.size()) {\r\n                        break;\r\n                    }\r\n                    String d = tableOfContentElements.get(j);\r\n                    if (d == null || d.length() < 1) {\r\n                        continue;\r\n                    }\r\n                    String a = d.substring(1).replaceAll(\" \", \"_\").replaceAll(NOT_CHARACTER_NUMBER_OR_UNDERSCORE, EMPTY);\r\n                    String b = element.substring(1).replaceAll(\" \", \"_\").replaceAll(NOT_CHARACTER_NUMBER_OR_UNDERSCORE, EMPTY);\r\n                    if (a.equals(b)) {\r\n                        doubles++;\r\n                    }\r\n                }\r\n                //if there are doubles, create anchorextension\r\n                if (doubles > 0) {\r\n                    anchorext = \"_\" + (doubles + 1);\r\n                }\r\n\r\n                if (element.length() > 0 && element.charAt(0) == '3') {\r\n                    if (level < 3) {\r\n                        level = 3;\r\n                        level3 = 0;\r\n                    }\r\n                    level3++;\r\n                    final String temp = element.substring(1);\r\n                    element = level1 + \".\" + level2 + \".\" + level3 + \" \" + temp;\r\n                    directory.append(\"&nbsp;&nbsp;&nbsp;&nbsp;<a href=\\\"#\");\r\n                    directory.append(temp.replaceAll(\" \", \"_\").replaceAll(NOT_CHARACTER_NUMBER_OR_UNDERSCORE, EMPTY));\r\n                    directory.append(anchorext);\r\n                    directory.append(\"\\\" class=\\\"WikiTOC\\\">\");\r\n                    directory.append(element);\r\n                    directory.append(\"<\/a><br />\\n\");\r\n                } else if (element.length() > 0 && element.charAt(0) == '2') {\r\n                    if (level == 1) {\r\n                        level2 = 0;\r\n                        level = 2;\r\n                    }\r\n                    if (level == 3) {\r\n                        level = 2;\r\n                    }\r\n                    level2++;\r\n                    final String temp = element.substring(1);\r\n                    element = level1 + \".\" + level2 + \" \" + temp;\r\n                    directory.append(\"&nbsp;&nbsp;<a href=\\\"#\");\r\n                    directory.append(temp.replaceAll(\" \", \"_\").replaceAll(NOT_CHARACTER_NUMBER_OR_UNDERSCORE, EMPTY));\r\n                    directory.append(anchorext);\r\n                    directory.append(\"\\\" class=\\\"WikiTOC\\\">\");\r\n                    directory.append(element);\r\n                    directory.append(\"<\/a><br />\\n\");\r\n                } else if (element.length() > 0 && element.charAt(0) == '1') {\r\n                    if (level > 1) {\r\n                        level = 1;\r\n                        level2 = 0;\r\n                        level3 = 0;\r\n                    }\r\n                    level1++;\r\n                    final String temp = element.substring(1);\r\n                    element = level1 + \". \" + temp;\r\n                    directory.append(\"<a href=\\\"#\");\r\n                    directory.append(temp.replaceAll(\" \", \"_\").replaceAll(NOT_CHARACTER_NUMBER_OR_UNDERSCORE, EMPTY));\r\n                    directory.append(anchorext);\r\n                    directory.append(\"\\\" class=\\\"WikiTOC\\\">\");\r\n                    directory.append(element);\r\n                    directory.append(\"<\/a><br />\\n\");\r\n                }\r\n                anchorext = EMPTY;\r\n            }\r\n            directory.append(\"<\/div><\/td><\/tr><\/table>\\n\");\r\n        }\r\n        if (!tableOfContentElements.isEmpty()) {\r\n            tableOfContentElements.clear();\r\n        }\r\n        return directory;\r\n    }","id":35632,"modified_method":"/** Creates table of contents for a wiki page.\r\n     * @return HTML fragment\r\n     */\r\n    private StringBuilder createTableOfContents() {\r\n        final StringBuilder directory = new StringBuilder();\r\n        String element;\r\n        int s = 0;\r\n        int level = 1;\r\n        int level1 = 0;\r\n        int level2 = 0;\r\n        int level3 = 0;\r\n        int doubles = 0;\r\n        String anchorext = EMPTY;\r\n        if ((s = tableOfContentElements.size()) > 2) {\r\n            directory.append(\"<table><tr><td><div class=\\\"WikiTOCBox\\\">\\n\");\r\n            for (int i = 0; i < s; i++) {\r\n                if (i >= tableOfContentElements.size()) {\r\n                    break;\r\n                }\r\n                element = tableOfContentElements.get(i);\r\n                if (element == null) {\r\n                    continue;\r\n                }\r\n                //counting double headlines\r\n                doubles = 0;\r\n                for (int j = 0; j < i; j++) {\r\n                    if (j >= tableOfContentElements.size()) {\r\n                        break;\r\n                    }\r\n                    String d = tableOfContentElements.get(j);\r\n                    if (d == null || d.length() < 1) {\r\n                        continue;\r\n                    }\r\n                    String a = d.substring(1).replaceAll(\" \", \"_\").replaceAll(REGEX_NOT_CHAR_NUM_OR_UNDERSCORE, EMPTY);\r\n                    String b = element.substring(1).replaceAll(\" \", \"_\").replaceAll(REGEX_NOT_CHAR_NUM_OR_UNDERSCORE, EMPTY);\r\n                    if (a.equals(b)) {\r\n                        doubles++;\r\n                    }\r\n                }\r\n                //if there are doubles, create anchorextension\r\n                if (doubles > 0) {\r\n                    anchorext = \"_\" + (doubles + 1);\r\n                }\r\n\r\n                final char l = element.charAt(0);\r\n                String temp = \"\";\r\n                if (Arrays.binarySearch(HEADLINE_LEVEL, l) >= 0 && element.length() > 0) {\r\n                    if (l == THREE) {\r\n                        if (level < 3) {\r\n                            level = 3;\r\n                            level3 = 0;\r\n                        }\r\n                        level3++;\r\n                        temp = element.substring(1);\r\n                        element = level1 + \".\" + level2 + \".\" + level3 + \" \" + temp;\r\n                        directory.append(\"&nbsp;&nbsp;&nbsp;&nbsp;<a href=\\\"#\");\r\n                    } else if (l == TWO) {\r\n                        if (level == 1) {\r\n                            level2 = 0;\r\n                            level = 2;\r\n                        }\r\n                        if (level == 3) {\r\n                            level = 2;\r\n                        }\r\n                        level2++;\r\n                        temp = element.substring(1);\r\n                        element = level1 + \".\" + level2 + \" \" + temp;\r\n                        directory.append(\"&nbsp;&nbsp;<a href=\\\"#\");\r\n                    } else if (l == ONE) {\r\n                        if (level > 1) {\r\n                            level = 1;\r\n                            level2 = 0;\r\n                            level3 = 0;\r\n                        }\r\n                        level1++;\r\n                        temp = element.substring(1);\r\n                        element = level1 + \". \" + temp;\r\n                        directory.append(\"<a href=\\\"#\");\r\n                    }\r\n\r\n                    directory.append(temp.replaceAll(\" \", \"_\").replaceAll(REGEX_NOT_CHAR_NUM_OR_UNDERSCORE, EMPTY));\r\n                    directory.append(anchorext);\r\n                    directory.append(\"\\\" class=\\\"WikiTOC\\\">\");\r\n                    directory.append(element);\r\n                    directory.append(\"<\/a><br />\\n\");\r\n}\r\n                anchorext = EMPTY;\r\n            }\r\n            directory.append(\"<\/div><\/td><\/tr><\/table>\\n\");\r\n        }\r\n        if (!tableOfContentElements.isEmpty()) {\r\n            tableOfContentElements.clear();\r\n        }\r\n        return directory;\r\n    }","commit_id":"5a9ea0308f79debccbaa90bf92641da4386167a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * Processes tags which are connected preformatted text (&lt;pre&gt; &lt;/pre&gt;).\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processPreformattedText(String line) {\r\n        int positionOfOpeningTag;\r\n        int positionOfClosingTag;\r\n        //both <pre> and <\/pre> in the same line\r\n        if (((positionOfOpeningTag = line.indexOf(\"&lt;pre&gt;\")) >= 0) && ((positionOfClosingTag = line.indexOf(\"&lt;/pre&gt;\")) > 0) && (!(escaped))) {\r\n            if (positionOfOpeningTag < positionOfClosingTag) {\r\n                String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + 11, positionOfClosingTag) + \"<\/pre>\";\r\n                preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n                line = processLineOfWikiCode(line.substring(0, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\" + line.substring(positionOfClosingTag + 12).replaceAll(\"!pre!\", \"!pre!!\"));\r\n                line = line.replaceAll(\"!pre!txt!\", preformattedText);\r\n                line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            } //handles cases like <pre><pre> <\/pre><\/pre> <pre> <\/pre> that would cause an exception otherwise\r\n            else {\r\n                processingPreformattedText = true;\r\n                final String temp1 = processLineOfWikiCode(line.substring(0, positionOfOpeningTag - 1).replaceAll(\"!tmp!\", \"!tmp!!\") + \"!tmp!txt!\");\r\n                noList = true;\r\n                final String temp2 = processLineOfWikiCode(line.substring(positionOfOpeningTag));\r\n                noList = false;\r\n                line = temp1.replaceAll(\"!tmp!txt!\", temp2);\r\n                line = line.replaceAll(\"!tmp!!\", \"!tmp!\");\r\n                processingPreformattedText = false;\r\n            }\r\n        } //start <pre>\r\n        else if (((positionOfOpeningTag = line.indexOf(\"&lt;pre&gt;\")) >= 0) && (!preformattedSpanning) && (!escaped)) {\r\n            processingPreformattedText = true;    //prevent surplus line breaks\r\n            final StringBuilder openBlockQuoteTags = new StringBuilder();  //gets filled with <blockquote>s as needed\r\n            String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + 11);\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (line.substring(preindented, positionOfOpeningTag).startsWith(\":\")) {\r\n                preindented++;\r\n                openBlockQuoteTags.append(OPEN_BLOCKQUOTE);\r\n            }\r\n            line = processLineOfWikiCode(line.substring(preindented, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\");\r\n            line = openBlockQuoteTags + line.replaceAll(\"!pre!txt!\", preformattedText);\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            preformattedSpanning = true;\r\n        } //end <\/pre>\r\n        else if (((positionOfOpeningTag = line.indexOf(\"&lt;/pre&gt;\")) >= 0) && (preformattedSpanning) && (!escaped)) {\r\n            preformattedSpanning = false;\r\n            final StringBuilder endBlockQuoteTags = new StringBuilder(); //gets filled with <\/blockquote>s as needed\r\n            String preformattedText = line.substring(0, positionOfOpeningTag) + \"<\/pre>\";\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (preindented > 0) {\r\n                endBlockQuoteTags.append(CLOSE_BLOCKQUOTE);\r\n                preindented--;\r\n            }\r\n            line = processLineOfWikiCode(\"!pre!txt!\" + line.substring(positionOfOpeningTag + 12).replaceAll(\"!pre!\", \"!pre!!\"));\r\n            line = line.replaceAll(\"!pre!txt!\", preformattedText) + endBlockQuoteTags;\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            processingPreformattedText = false;\r\n        } //Getting rid of surplus <\/pre>\r\n        else if (((positionOfOpeningTag = line.indexOf(\"&lt;/pre&gt;\")) >= 0) && (!preformattedSpanning) && (!escaped)) {\r\n            while ((positionOfOpeningTag = line.indexOf(\"&lt;/pre&gt;\")) >= 0) {\r\n                line = line.substring(0, positionOfOpeningTag) + line.substring(positionOfOpeningTag + 12);\r\n            }\r\n            line = processLineOfWikiCode(line);\r\n        }\r\n        return line;\r\n    }","id":35633,"modified_method":"/**\r\n     * Processes tags which are connected preformatted text (&lt;pre&gt; &lt;/pre&gt;).\r\n     * @param line line of text to be transformed from wiki code to HTML\r\n     * @return HTML fragment\r\n     */\r\n    private String processPreformattedText(String line) {\r\n        final int positionOfOpeningTag = line.indexOf(WIKI_OPEN_PRE_ESCAPED);\r\n        final int positionOfClosingTag = line.indexOf(WIKI_CLOSE_PRE_ESCAPED);\r\n        //both <pre> and <\/pre> in the same line\r\n        if ((positionOfOpeningTag >= 0) && (positionOfClosingTag > 0) && !escaped) {\r\n            if (positionOfOpeningTag < positionOfClosingTag) {\r\n                String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + LEN_WIKI_OPEN_PRE_ESCAPED, positionOfClosingTag) + \"<\/pre>\";\r\n                preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n                line = processLineOfWikiCode(line.substring(0, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\" + line.substring(positionOfClosingTag + LEN_WIKI_CLOSE_PRE_ESCAPED).replaceAll(\"!pre!\", \"!pre!!\"));\r\n                line = line.replaceAll(\"!pre!txt!\", preformattedText);\r\n                line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            } //handles cases like <pre><pre> <\/pre><\/pre> <pre> <\/pre> that would cause an exception otherwise\r\n            else {\r\n                processingPreformattedText = true;\r\n                final String temp1 = processLineOfWikiCode(line.substring(0, positionOfOpeningTag - 1).replaceAll(\"!tmp!\", \"!tmp!!\") + \"!tmp!txt!\");\r\n                noList = true;\r\n                final String temp2 = processLineOfWikiCode(line.substring(positionOfOpeningTag));\r\n                noList = false;\r\n                line = temp1.replaceAll(\"!tmp!txt!\", temp2);\r\n                line = line.replaceAll(\"!tmp!!\", \"!tmp!\");\r\n                processingPreformattedText = false;\r\n            }\r\n        } //start <pre>\r\n        else if ((positionOfOpeningTag >= 0) && !preformattedSpanning && !escaped) {\r\n            processingPreformattedText = true;    //prevent surplus line breaks\r\n            final StringBuilder openBlockQuoteTags = new StringBuilder();  //gets filled with <blockquote>s as needed\r\n            String preformattedText = \"<pre style=\\\"border:dotted;border-width:thin\\\">\" + line.substring(positionOfOpeningTag + LEN_WIKI_OPEN_PRE_ESCAPED);\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (line.substring(preindented, positionOfOpeningTag).charAt(0) == WIKI_INDENTION) {\r\n                preindented++;\r\n                openBlockQuoteTags.append(OPEN_BLOCKQUOTE);\r\n            }\r\n            line = processLineOfWikiCode(line.substring(preindented, positionOfOpeningTag).replaceAll(\"!pre!\", \"!pre!!\") + \"!pre!txt!\");\r\n            line = openBlockQuoteTags + line.replaceAll(\"!pre!txt!\", preformattedText);\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            preformattedSpanning = true;\r\n        } //end <\/pre>\r\n        else if ((positionOfOpeningTag >= 0) && preformattedSpanning && !escaped) {\r\n            preformattedSpanning = false;\r\n            final StringBuilder endBlockQuoteTags = new StringBuilder(); //gets filled with <\/blockquote>s as needed\r\n            String preformattedText = line.substring(0, positionOfOpeningTag) + \"<\/pre>\";\r\n            preformattedText = preformattedText.replaceAll(\"!pre!\", \"!pre!!\");\r\n            //taking care of indented lines\r\n            while (preindented > 0) {\r\n                endBlockQuoteTags.append(CLOSE_BLOCKQUOTE);\r\n                preindented--;\r\n            }\r\n            line = processLineOfWikiCode(\"!pre!txt!\" + line.substring(positionOfOpeningTag + LEN_WIKI_CLOSE_PRE_ESCAPED).replaceAll(\"!pre!\", \"!pre!!\"));\r\n            line = line.replaceAll(\"!pre!txt!\", preformattedText) + endBlockQuoteTags;\r\n            line = line.replaceAll(\"!pre!!\", \"!pre!\");\r\n            processingPreformattedText = false;\r\n        } //Getting rid of surplus <\/pre>\r\n        else if ((positionOfOpeningTag >= 0) && !preformattedSpanning && !escaped) {\r\n            int posTag;\r\n            while ((posTag = line.indexOf(WIKI_CLOSE_PRE_ESCAPED)) >= 0) {\r\n                line = line.substring(0, posTag) + line.substring(posTag + LEN_WIKI_CLOSE_PRE_ESCAPED);\r\n            }\r\n            line = processLineOfWikiCode(line);\r\n        }\r\n        return line;\r\n    }","commit_id":"5a9ea0308f79debccbaa90bf92641da4386167a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/** Replaces two occurences of a substring in a string by a pair of strings if \r\n     * that substring occurs twice in the string. This method is not greedy! You'll\r\n     * have to run it in a loop if you want to replace all occurences of the substring.\r\n     * This method provides special treatment for headlines.\r\n     * @param input the string that something is to be replaced in\r\n     * @param pat substring to be replaced\r\n     * @param repl1 string substring gets replaced by on uneven occurences\r\n     * @param repl2 string substring gets replaced by on even occurences\r\n     */\r\n    //[MN]\r\n    private String pairReplace(String input, final String pat, final String repl1, final String repl2) {\r\n        String direlem = null;    //string to keep headlines until they get added to List dirElements\r\n        int firstPosition;\r\n        final int secondPosition;\r\n        final int strLen = pat.length();\r\n        //replace pattern if a pair of the pattern can be found in the line\r\n        if (((firstPosition = input.indexOf(pat)) >= 0) && ((secondPosition = input.indexOf(pat, firstPosition + strLen)) >= 0)) {\r\n            //extra treatment for headlines\r\n            if (Arrays.binarySearch(HEADLINE_TAGS, pat) >= 0) {\r\n                //add anchor and create headline\r\n                direlem = input.substring(firstPosition + strLen, secondPosition);\r\n                if (direlem != null) {\r\n                    //counting double headlines\r\n                    int doubles = 0;\r\n                    for (int i = 0; i < tableOfContentElements.size(); i++) {\r\n                        // no element with null value should ever be in directory\r\n                        assert (tableOfContentElements.get(i) != null);\r\n\r\n                        if (tableOfContentElements.size() > i && tableOfContentElements.get(i).substring(1).equals(direlem)) {\r\n                            doubles++;\r\n                        }\r\n                    }\r\n                    String anchor = direlem.replaceAll(\" \", \"_\").replaceAll(NOT_CHARACTER_NUMBER_OR_UNDERSCORE, EMPTY); //replace blanks with underscores and delete everything thats not a regular character, a number or _\r\n                    //if there are doubles, add underscore and number of doubles plus one\r\n                    if (doubles > 0) {\r\n                        anchor = anchor + \"_\" + (doubles + 1);\r\n                    }\r\n                    input = input.substring(0, firstPosition) + \"<a name=\\\"\" + anchor + \"\\\"><\/a>\" + repl1\r\n                            + direlem + repl2 + input.substring(secondPosition + strLen);\r\n                    //add headlines to list of headlines (so TOC can be created)\r\n                    if (Arrays.binarySearch(HEADLINE_TAGS, pat) >= 0) {\r\n                        tableOfContentElements.add((pat.length() - 1) + direlem);\r\n                    }\r\n                }\r\n            } else {\r\n                input = input.substring(0, firstPosition) + repl1\r\n                        + (input.substring(firstPosition + strLen, secondPosition)) + repl2\r\n                        + input.substring(secondPosition + strLen);\r\n            }\r\n        }\r\n        //recursion if another pair of the pattern can still be found in the line\r\n        if (((firstPosition = input.indexOf(pat)) >= 0) && (input.indexOf(pat, firstPosition + strLen) >= 0)) {\r\n            input = pairReplace(input, pat, repl1, repl2);\r\n        }\r\n        return input;\r\n    }","id":35634,"modified_method":"/** Replaces two occurences of a substring in a string by a pair of strings if \r\n     * that substring occurs twice in the string. This method is not greedy! You'll\r\n     * have to run it in a loop if you want to replace all occurences of the substring.\r\n     * This method provides special treatment for headlines.\r\n     * @param input the string that something is to be replaced in\r\n     * @param pat substring to be replaced\r\n     * @param repl1 string substring gets replaced by on uneven occurences\r\n     * @param repl2 string substring gets replaced by on even occurences\r\n     */\r\n    //[MN]\r\n    private String pairReplace(String input, final String pat, final String repl1, final String repl2) {\r\n        String direlem = null;    //string to keep headlines until they get added to List dirElements\r\n        int firstPosition;\r\n        final int secondPosition;\r\n        final int strLen = pat.length();\r\n        //replace pattern if a pair of the pattern can be found in the line\r\n        if (((firstPosition = input.indexOf(pat)) >= 0) && ((secondPosition = input.indexOf(pat, firstPosition + strLen)) >= 0)) {\r\n            //extra treatment for headlines\r\n            if (Arrays.binarySearch(HEADLINE_TAGS, pat) >= 0) {\r\n                //add anchor and create headline\r\n                direlem = input.substring(firstPosition + strLen, secondPosition);\r\n                if (direlem != null) {\r\n                    //counting double headlines\r\n                    int doubles = 0;\r\n                    for (int i = 0; i < tableOfContentElements.size(); i++) {\r\n                        // no element with null value should ever be in directory\r\n                        assert (tableOfContentElements.get(i) != null);\r\n\r\n                        if (tableOfContentElements.size() > i && tableOfContentElements.get(i).substring(1).equals(direlem)) {\r\n                            doubles++;\r\n                        }\r\n                    }\r\n                    String anchor = direlem.replaceAll(\" \", \"_\").replaceAll(REGEX_NOT_CHAR_NUM_OR_UNDERSCORE, EMPTY); //replace blanks with underscores and delete everything thats not a regular character, a number or _\r\n                    //if there are doubles, add underscore and number of doubles plus one\r\n                    if (doubles > 0) {\r\n                        anchor = anchor + \"_\" + (doubles + 1);\r\n                    }\r\n                    input = input.substring(0, firstPosition) + \"<a name=\\\"\" + anchor + \"\\\"><\/a>\" + repl1\r\n                            + direlem + repl2 + input.substring(secondPosition + strLen);\r\n                    //add headlines to list of headlines (so TOC can be created)\r\n                    if (Arrays.binarySearch(HEADLINE_TAGS, pat) >= 0) {\r\n                        tableOfContentElements.add((pat.length() - 1) + direlem);\r\n                    }\r\n                }\r\n            } else {\r\n                input = input.substring(0, firstPosition) + repl1\r\n                        + (input.substring(firstPosition + strLen, secondPosition)) + repl2\r\n                        + input.substring(secondPosition + strLen);\r\n            }\r\n        }\r\n        //recursion if another pair of the pattern can still be found in the line\r\n        if (((firstPosition = input.indexOf(pat)) >= 0) && (input.indexOf(pat, firstPosition + strLen) >= 0)) {\r\n            input = pairReplace(input, pat, repl1, repl2);\r\n        }\r\n        return input;\r\n    }","commit_id":"5a9ea0308f79debccbaa90bf92641da4386167a7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n  public void processIntention(@NotNull PsiElement element) {\n    final PsiField field = (PsiField)element.getParent();\n    field.normalizeDeclaration();\n    final PsiExpression initializer = RefactoringUtil.convertInitializerToNormalExpression(field.getInitializer(), field.getType());\n    if (initializer == null) {\n      return;\n    }\n    final String initializerText = initializer.getText();\n    final PsiClass containingClass = field.getContainingClass();\n    if (containingClass == null) {\n      return;\n    }\n    final boolean fieldIsStatic =\n      field.hasModifierProperty(PsiModifier.STATIC);\n    final PsiClassInitializer[] classInitializers =\n      containingClass.getInitializers();\n    PsiClassInitializer classInitializer = null;\n    final int fieldOffset = field.getTextOffset();\n    for (PsiClassInitializer existingClassInitializer : classInitializers) {\n      final int initializerOffset =\n        existingClassInitializer.getTextOffset();\n      if (initializerOffset <= fieldOffset) {\n        continue;\n      }\n      final boolean initializerIsStatic =\n        existingClassInitializer.hasModifierProperty(\n          PsiModifier.STATIC);\n      if (initializerIsStatic == fieldIsStatic) {\n        classInitializer = existingClassInitializer;\n        break;\n      }\n    }\n    final PsiManager manager = field.getManager();\n    final Project project = manager.getProject();\n    final PsiElementFactory elementFactory =\n      JavaPsiFacade.getInstance(project).getElementFactory();\n    if (classInitializer == null) {\n      classInitializer = elementFactory.createClassInitializer();\n      classInitializer = (PsiClassInitializer)\n        containingClass.addAfter(classInitializer, field);\n\n      // add some whitespace between the field and the class initializer\n      final PsiElement whitespace =\n        PsiParserFacade.SERVICE.getInstance(project).createWhiteSpaceFromText(\"\\n\");\n      containingClass.addAfter(whitespace, field);\n    }\n    final PsiCodeBlock body = classInitializer.getBody();\n    @NonNls final String initializationStatementText =\n      field.getName() + \" = \" + initializerText + ';';\n    final PsiExpressionStatement statement =\n      (PsiExpressionStatement)elementFactory.createStatementFromText(\n        initializationStatementText, body);\n    final PsiElement addedElement = body.add(statement);\n    if (fieldIsStatic) {\n      final PsiModifierList modifierList =\n        classInitializer.getModifierList();\n      if (modifierList != null) {\n        modifierList.setModifierProperty(PsiModifier.STATIC, true);\n      }\n    }\n    initializer.delete();\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(manager.getProject());\n    codeStyleManager.reformat(field);\n    codeStyleManager.reformat(classInitializer);\n    HighlightUtil.highlightElement(addedElement,\n                                   IntentionPowerPackBundle.message(\n                                     \"press.escape.to.remove.highlighting.message\"));\n  }","id":35635,"modified_method":"@Override\n  public void processIntention(@NotNull PsiElement element) {\n    final PsiField field = (PsiField)element.getParent();\n    field.normalizeDeclaration();\n    final PsiExpression initializer = field.getInitializer();\n    if (initializer == null) {\n      return;\n    }\n    final String initializerText = RefactoringUtil.convertInitializerToNormalExpression(initializer, field.getType()).getText();\n    final PsiClass containingClass = field.getContainingClass();\n    if (containingClass == null) {\n      return;\n    }\n    final boolean fieldIsStatic =\n      field.hasModifierProperty(PsiModifier.STATIC);\n    final PsiClassInitializer[] classInitializers =\n      containingClass.getInitializers();\n    PsiClassInitializer classInitializer = null;\n    final int fieldOffset = field.getTextOffset();\n    for (PsiClassInitializer existingClassInitializer : classInitializers) {\n      final int initializerOffset =\n        existingClassInitializer.getTextOffset();\n      if (initializerOffset <= fieldOffset) {\n        continue;\n      }\n      final boolean initializerIsStatic =\n        existingClassInitializer.hasModifierProperty(\n          PsiModifier.STATIC);\n      if (initializerIsStatic == fieldIsStatic) {\n        classInitializer = existingClassInitializer;\n        break;\n      }\n    }\n    final PsiManager manager = field.getManager();\n    final Project project = manager.getProject();\n    final PsiElementFactory elementFactory =\n      JavaPsiFacade.getInstance(project).getElementFactory();\n    if (classInitializer == null) {\n      classInitializer = elementFactory.createClassInitializer();\n      classInitializer = (PsiClassInitializer)\n        containingClass.addAfter(classInitializer, field);\n\n      // add some whitespace between the field and the class initializer\n      final PsiElement whitespace =\n        PsiParserFacade.SERVICE.getInstance(project).createWhiteSpaceFromText(\"\\n\");\n      containingClass.addAfter(whitespace, field);\n    }\n    final PsiCodeBlock body = classInitializer.getBody();\n    @NonNls final String initializationStatementText =\n      field.getName() + \" = \" + initializerText + ';';\n    final PsiExpressionStatement statement =\n      (PsiExpressionStatement)elementFactory.createStatementFromText(\n        initializationStatementText, body);\n    final PsiElement addedElement = body.add(statement);\n    if (fieldIsStatic) {\n      final PsiModifierList modifierList =\n        classInitializer.getModifierList();\n      if (modifierList != null) {\n        modifierList.setModifierProperty(PsiModifier.STATIC, true);\n      }\n    }\n    initializer.delete();\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(manager.getProject());\n    codeStyleManager.reformat(field);\n    codeStyleManager.reformat(field);\n    codeStyleManager.reformat(classInitializer);\n    HighlightUtil.highlightElement(addedElement,\n                                   IntentionPowerPackBundle.message(\n                                     \"press.escape.to.remove.highlighting.message\"));\n  }","commit_id":"1bdb54200893229fc295f6bff05260c246d7fead","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processIntention(@NotNull PsiElement element)\n    throws IncorrectOperationException {\n    final PsiField field = (PsiField)element.getParent();\n    field.normalizeDeclaration();\n    final PsiExpression initializer = field.getInitializer();\n    if (initializer == null) {\n      return;\n    }\n    final String initializerText;\n    if (initializer instanceof PsiArrayInitializerExpression) {\n      final PsiType type = initializer.getType();\n      if (type == null) {\n        initializerText = initializer.getText();\n      }\n      else {\n        initializerText = \"new \" + type.getCanonicalText() +\n                          initializer.getText();\n      }\n    }\n    else {\n      initializerText = initializer.getText();\n    }\n    final PsiClass containingClass = field.getContainingClass();\n    if (containingClass == null) {\n      return;\n    }\n    final boolean fieldIsStatic =\n      field.hasModifierProperty(PsiModifier.STATIC);\n    final PsiClassInitializer[] classInitializers =\n      containingClass.getInitializers();\n    PsiClassInitializer classInitializer = null;\n    final int fieldOffset = field.getTextOffset();\n    for (PsiClassInitializer existingClassInitializer : classInitializers) {\n      final int initializerOffset =\n        existingClassInitializer.getTextOffset();\n      if (initializerOffset <= fieldOffset) {\n        continue;\n      }\n      final boolean initializerIsStatic =\n        existingClassInitializer.hasModifierProperty(\n          PsiModifier.STATIC);\n      if (initializerIsStatic == fieldIsStatic) {\n        classInitializer = existingClassInitializer;\n        break;\n      }\n    }\n    final PsiManager manager = field.getManager();\n    final Project project = manager.getProject();\n    final PsiElementFactory elementFactory =\n      JavaPsiFacade.getInstance(project).getElementFactory();\n    if (classInitializer == null) {\n      classInitializer = elementFactory.createClassInitializer();\n      classInitializer = (PsiClassInitializer)\n        containingClass.addAfter(classInitializer, field);\n\n      // add some whitespace between the field and the class initializer\n      final PsiElement whitespace =\n        PsiParserFacade.SERVICE.getInstance(project).createWhiteSpaceFromText(\"\\n\");\n      containingClass.addAfter(whitespace, field);\n    }\n    final PsiCodeBlock body = classInitializer.getBody();\n    @NonNls final String initializationStatementText =\n      field.getName() + \" = \" + initializerText + ';';\n    final PsiExpressionStatement statement =\n      (PsiExpressionStatement)elementFactory.createStatementFromText(\n        initializationStatementText, body);\n    final PsiElement addedElement = body.add(statement);\n    if (fieldIsStatic) {\n      final PsiModifierList modifierList =\n        classInitializer.getModifierList();\n      if (modifierList != null) {\n        modifierList.setModifierProperty(PsiModifier.STATIC, true);\n      }\n    }\n    initializer.delete();\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(manager.getProject());\n    codeStyleManager.reformat(field);\n    codeStyleManager.reformat(classInitializer);\n    HighlightUtil.highlightElement(addedElement,\n                                   IntentionPowerPackBundle.message(\n                                     \"press.escape.to.remove.highlighting.message\"));\n  }","id":35636,"modified_method":"@Override\n  public void processIntention(@NotNull PsiElement element) {\n    final PsiField field = (PsiField)element.getParent();\n    field.normalizeDeclaration();\n    final PsiExpression initializer = RefactoringUtil.convertInitializerToNormalExpression(field.getInitializer(), field.getType());\n    if (initializer == null) {\n      return;\n    }\n    final String initializerText = initializer.getText();\n    final PsiClass containingClass = field.getContainingClass();\n    if (containingClass == null) {\n      return;\n    }\n    final boolean fieldIsStatic =\n      field.hasModifierProperty(PsiModifier.STATIC);\n    final PsiClassInitializer[] classInitializers =\n      containingClass.getInitializers();\n    PsiClassInitializer classInitializer = null;\n    final int fieldOffset = field.getTextOffset();\n    for (PsiClassInitializer existingClassInitializer : classInitializers) {\n      final int initializerOffset =\n        existingClassInitializer.getTextOffset();\n      if (initializerOffset <= fieldOffset) {\n        continue;\n      }\n      final boolean initializerIsStatic =\n        existingClassInitializer.hasModifierProperty(\n          PsiModifier.STATIC);\n      if (initializerIsStatic == fieldIsStatic) {\n        classInitializer = existingClassInitializer;\n        break;\n      }\n    }\n    final PsiManager manager = field.getManager();\n    final Project project = manager.getProject();\n    final PsiElementFactory elementFactory =\n      JavaPsiFacade.getInstance(project).getElementFactory();\n    if (classInitializer == null) {\n      classInitializer = elementFactory.createClassInitializer();\n      classInitializer = (PsiClassInitializer)\n        containingClass.addAfter(classInitializer, field);\n\n      // add some whitespace between the field and the class initializer\n      final PsiElement whitespace =\n        PsiParserFacade.SERVICE.getInstance(project).createWhiteSpaceFromText(\"\\n\");\n      containingClass.addAfter(whitespace, field);\n    }\n    final PsiCodeBlock body = classInitializer.getBody();\n    @NonNls final String initializationStatementText =\n      field.getName() + \" = \" + initializerText + ';';\n    final PsiExpressionStatement statement =\n      (PsiExpressionStatement)elementFactory.createStatementFromText(\n        initializationStatementText, body);\n    final PsiElement addedElement = body.add(statement);\n    if (fieldIsStatic) {\n      final PsiModifierList modifierList =\n        classInitializer.getModifierList();\n      if (modifierList != null) {\n        modifierList.setModifierProperty(PsiModifier.STATIC, true);\n      }\n    }\n    initializer.delete();\n    final CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(manager.getProject());\n    codeStyleManager.reformat(field);\n    codeStyleManager.reformat(classInitializer);\n    HighlightUtil.highlightElement(addedElement,\n                                   IntentionPowerPackBundle.message(\n                                     \"press.escape.to.remove.highlighting.message\"));\n  }","commit_id":"7ccfd14574ea5994de664d14b7ae2580bacc58b9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private JavaArrangementMethodDependencyInfo buildMethodDependencyInfo(@NotNull final PsiMethod method,\n                                                                        @NotNull Map<PsiMethod, JavaArrangementMethodDependencyInfo> cache)\n  {\n    JavaElementArrangementEntry entry = myMethodEntriesMap.get(method);\n    if (entry == null) {\n      return null;\n    }\n    JavaArrangementMethodDependencyInfo result = new JavaArrangementMethodDependencyInfo(entry);\n    Stack<Pair<PsiMethod, JavaArrangementMethodDependencyInfo>> toProcess\n      = new Stack<Pair<PsiMethod, JavaArrangementMethodDependencyInfo>>();\n    toProcess.push(Pair.create(method, result));\n    Set<PsiMethod> usedMethods = ContainerUtilRt.newHashSet();\n    while (!toProcess.isEmpty()) {\n      Pair<PsiMethod, JavaArrangementMethodDependencyInfo> pair = toProcess.pop();\n      Set<PsiMethod> dependentMethods = myMethodDependencies.get(pair.first);\n      if (dependentMethods == null) {\n        continue;\n      }\n      usedMethods.add(pair.first);\n      for (PsiMethod dependentMethod : dependentMethods) {\n        if (usedMethods.contains(dependentMethod)) {\n          // Prevent cyclic dependencies.\n          return null;\n        }\n        JavaElementArrangementEntry dependentEntry = myMethodEntriesMap.get(dependentMethod);\n        if (dependentEntry == null) {\n          continue;\n        }\n        JavaArrangementMethodDependencyInfo dependentMethodInfo = cache.get(dependentMethod);\n        if (dependentMethodInfo == null) {\n          cache.put(dependentMethod, dependentMethodInfo = new JavaArrangementMethodDependencyInfo(dependentEntry));\n        }\n        Pair<PsiMethod, JavaArrangementMethodDependencyInfo> dependentPair = Pair.create(dependentMethod, dependentMethodInfo);\n        pair.second.addDependentMethodInfo(dependentPair.second);\n        toProcess.push(dependentPair);\n      }\n    }\n    return result;\n  }","id":35637,"modified_method":"@Nullable\n  private ArrangementEntryDependencyInfo buildMethodDependencyInfo(@NotNull final PsiMethod method,\n                                                                        @NotNull Map<PsiMethod, ArrangementEntryDependencyInfo> cache)\n  {\n    JavaElementArrangementEntry entry = myMethodEntriesMap.get(method);\n    if (entry == null) {\n      return null;\n    }\n    ArrangementEntryDependencyInfo result = new ArrangementEntryDependencyInfo(entry);\n    Stack<Pair<PsiMethod, ArrangementEntryDependencyInfo>> toProcess\n      = new Stack<Pair<PsiMethod, ArrangementEntryDependencyInfo>>();\n    toProcess.push(Pair.create(method, result));\n    Set<PsiMethod> usedMethods = ContainerUtilRt.newHashSet();\n    while (!toProcess.isEmpty()) {\n      Pair<PsiMethod, ArrangementEntryDependencyInfo> pair = toProcess.pop();\n      Set<PsiMethod> dependentMethods = myMethodDependencies.get(pair.first);\n      if (dependentMethods == null) {\n        continue;\n      }\n      usedMethods.add(pair.first);\n      for (PsiMethod dependentMethod : dependentMethods) {\n        if (usedMethods.contains(dependentMethod)) {\n          // Prevent cyclic dependencies.\n          return null;\n        }\n        JavaElementArrangementEntry dependentEntry = myMethodEntriesMap.get(dependentMethod);\n        if (dependentEntry == null) {\n          continue;\n        }\n        ArrangementEntryDependencyInfo dependentMethodInfo = cache.get(dependentMethod);\n        if (dependentMethodInfo == null) {\n          cache.put(dependentMethod, dependentMethodInfo = new ArrangementEntryDependencyInfo(dependentEntry));\n        }\n        Pair<PsiMethod, ArrangementEntryDependencyInfo> dependentPair = Pair.create(dependentMethod, dependentMethodInfo);\n        pair.second.addDependentEntryInfo(dependentPair.second);\n        toProcess.push(dependentPair);\n      }\n    }\n    return result;\n  }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @return    list of method dependency roots, i.e. there is a possible case that particular method\n   *            {@link JavaArrangementMethodDependencyInfo#getDependentMethodInfos() calls another method}, it calls other methods\n   *            and so forth\n   */\n  @NotNull\n  public List<JavaArrangementMethodDependencyInfo> getMethodDependencyRoots() {\n    if (myRebuildMethodDependencies) {\n      myMethodDependencyRoots.clear();\n      Map<PsiMethod, JavaArrangementMethodDependencyInfo> cache = new HashMap<PsiMethod, JavaArrangementMethodDependencyInfo>();\n      for (PsiMethod method : myTmpMethodDependencyRoots) {\n        JavaArrangementMethodDependencyInfo info = buildMethodDependencyInfo(method, cache);\n        if (info != null) {\n          myMethodDependencyRoots.add(info);\n        }\n      }\n      myRebuildMethodDependencies = false;\n    }\n    return myMethodDependencyRoots;\n  }","id":35638,"modified_method":"/**\n   * @return    list of method dependency roots, i.e. there is a possible case that particular method\n   *            {@link ArrangementEntryDependencyInfo#getDependentEntriesInfos() calls another method}, it calls other methods\n   *            and so forth\n   */\n  @NotNull\n  public List<ArrangementEntryDependencyInfo> getMethodDependencyRoots() {\n    if (myRebuildMethodDependencies) {\n      myMethodDependencyRoots.clear();\n      Map<PsiMethod, ArrangementEntryDependencyInfo> cache = new HashMap<PsiMethod, ArrangementEntryDependencyInfo>();\n      for (PsiMethod method : myTmpMethodDependencyRoots) {\n        ArrangementEntryDependencyInfo info = buildMethodDependencyInfo(method, cache);\n        if (info != null) {\n          myMethodDependencyRoots.add(info);\n        }\n      }\n      myRebuildMethodDependencies = false;\n    }\n    return myMethodDependencyRoots;\n  }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Is expected to be called when new method dependency is detected. Here given <code>'base method'<\/code> calls\n   * <code>'dependent method'<\/code>.\n   * \n   * @param baseMethod       method which calls another method\n   * @param dependentMethod  method being called\n   */\n  public void registerDependency(@NotNull PsiMethod baseMethod, @NotNull PsiMethod dependentMethod) {\n    myTmpMethodDependencyRoots.remove(dependentMethod);\n    if (!myDependentMethods.contains(baseMethod)) {\n      myTmpMethodDependencyRoots.add(baseMethod);\n    }\n    myDependentMethods.add(dependentMethod);\n    Set<PsiMethod> methods = myMethodDependencies.get(baseMethod);\n    if (methods == null) {\n      myMethodDependencies.put(baseMethod, methods = new LinkedHashSet<PsiMethod>());\n    }\n    if (!methods.contains(dependentMethod)) {\n      methods.add(dependentMethod);\n    }\n    myRebuildMethodDependencies = true;\n  }","id":35639,"modified_method":"/**\n   * Is expected to be called when new method dependency is detected. Here given <code>'base method'<\/code> calls\n   * <code>'dependent method'<\/code>.\n   */\n  public void registerMethodCallDependency(@NotNull PsiMethod caller, @NotNull PsiMethod callee) {\n    myTmpMethodDependencyRoots.remove(callee);\n    if (!myDependentMethods.contains(caller)) {\n      myTmpMethodDependencyRoots.add(caller);\n    }\n    myDependentMethods.add(callee);\n    Set<PsiMethod> methods = myMethodDependencies.get(caller);\n    if (methods == null) {\n      myMethodDependencies.put(caller, methods = new LinkedHashSet<PsiMethod>());\n    }\n    if (!methods.contains(callee)) {\n      methods.add(callee);\n    }\n    myRebuildMethodDependencies = true;\n  }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitField(PsiField field) {\n    // There is a possible case that more than one field is declared for the same type like 'int i, j;'. We want to process only\n    // the first one then.\n    PsiElement fieldPrev = getPreviousNonWsComment(field.getPrevSibling(), 0);\n    if (fieldPrev instanceof PsiJavaToken && ((PsiJavaToken)fieldPrev).getTokenType() == JavaTokenType.COMMA) {\n      return;\n    }\n\n    // There is a possible case that fields which share the same type declaration are located on different document lines, e.g.:\n    //    int i1,\n    //        i2;\n    // We want to consider only the first declaration then but need to expand its range to all affected lines (up to semicolon).\n    TextRange range = field.getTextRange();\n    PsiElement child = field.getLastChild();\n    boolean needSpecialProcessing = true;\n    if (isSemicolon(child)) {\n      needSpecialProcessing = false;\n    }\n    else if (child instanceof PsiComment) {\n      // There is a possible field definition like below:\n      //   int f; // my comment.\n      // The comment goes into field PSI here, that's why we need to handle it properly.\n      PsiElement prev = getPreviousNonWsComment(child, range.getStartOffset());\n      needSpecialProcessing = prev != null && !isSemicolon(prev);\n    }\n    \n    if (needSpecialProcessing) {\n      for (PsiElement e = field.getNextSibling(); e != null; e = e.getNextSibling()) {\n        if (e instanceof PsiWhiteSpace || e instanceof PsiComment) { // Skip white space and comment\n          continue;\n        }\n        else if (e instanceof PsiJavaToken) {\n          if (((PsiJavaToken)e).getTokenType() == JavaTokenType.COMMA) { // Skip comma\n            continue;\n          }\n          else {\n            break;\n          }\n        }\n        else if (e instanceof PsiField) {\n          PsiElement c = e.getLastChild();\n          if (c != null) {\n            c = getPreviousNonWsComment(c, range.getStartOffset());\n          }\n          // Stop if current field ends by a semicolon.\n          if (c instanceof PsiErrorElement // Incomplete field without trailing semicolon\n              || (c instanceof PsiJavaToken && ((PsiJavaToken)c).getTokenType() == JavaTokenType.SEMICOLON))\n          {\n            range = TextRange.create(range.getStartOffset(), expandToCommentIfPossible(c));\n          }\n          else {\n            continue;\n          }\n        }\n        break;\n      }\n    }\n    JavaElementArrangementEntry entry = createNewEntry(field, range, FIELD, field.getName(), true);\n    processEntry(entry, field, field.getInitializer());\n  }","id":35640,"modified_method":"@Override\n  public void visitField(PsiField field) {\n    // There is a possible case that more than one field is declared for the same type like 'int i, j;'. We want to process only\n    // the first one then.\n    PsiElement fieldPrev = getPreviousNonWsComment(field.getPrevSibling(), 0);\n    if (fieldPrev instanceof PsiJavaToken && ((PsiJavaToken)fieldPrev).getTokenType() == JavaTokenType.COMMA) {\n      return;\n    }\n\n    // There is a possible case that fields which share the same type declaration are located on different document lines, e.g.:\n    //    int i1,\n    //        i2;\n    // We want to consider only the first declaration then but need to expand its range to all affected lines (up to semicolon).\n    TextRange range = field.getTextRange();\n    PsiElement child = field.getLastChild();\n    boolean needSpecialProcessing = true;\n    if (isSemicolon(child)) {\n      needSpecialProcessing = false;\n    }\n    else if (child instanceof PsiComment) {\n      // There is a possible field definition like below:\n      //   int f; // my comment.\n      // The comment goes into field PSI here, that's why we need to handle it properly.\n      PsiElement prev = getPreviousNonWsComment(child, range.getStartOffset());\n      needSpecialProcessing = prev != null && !isSemicolon(prev);\n    }\n    \n    if (needSpecialProcessing) {\n      for (PsiElement e = field.getNextSibling(); e != null; e = e.getNextSibling()) {\n        if (e instanceof PsiWhiteSpace || e instanceof PsiComment) { // Skip white space and comment\n          continue;\n        }\n        else if (e instanceof PsiJavaToken) {\n          if (((PsiJavaToken)e).getTokenType() == JavaTokenType.COMMA) { // Skip comma\n            continue;\n          }\n          else {\n            break;\n          }\n        }\n        else if (e instanceof PsiField) {\n          PsiElement c = e.getLastChild();\n          if (c != null) {\n            c = getPreviousNonWsComment(c, range.getStartOffset());\n          }\n          // Stop if current field ends by a semicolon.\n          if (c instanceof PsiErrorElement // Incomplete field without trailing semicolon\n              || (c instanceof PsiJavaToken && ((PsiJavaToken)c).getTokenType() == JavaTokenType.SEMICOLON))\n          {\n            range = TextRange.create(range.getStartOffset(), expandToCommentIfPossible(c));\n          }\n          else {\n            continue;\n          }\n        }\n        break;\n      }\n    }\n\n    JavaElementArrangementEntry entry = createNewEntry(field, range, FIELD, field.getName(), true);\n    if (entry == null)\n      return;\n\n    PsiExpression fieldInitializer = field.getInitializer();\n    processEntry(entry, field, fieldInitializer);\n    myInfo.onFieldEntryCreated(field, entry);\n\n    if (fieldInitializer != null) {\n      List<PsiField> referencedFields = getReferencedFields(fieldInitializer);\n      for (PsiField referencedField : referencedFields) {\n        myInfo.registerFieldInitializationDependency(field, referencedField);\n      }\n    }\n  }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitMethodCallExpression(PsiMethodCallExpression psiMethodCallExpression) {\n      PsiReference reference = psiMethodCallExpression.getMethodExpression().getReference();\n      if (reference == null) {\n        return;\n      }\n      PsiElement e = reference.resolve();\n      if (e instanceof PsiMethod) {\n        assert myBaseMethod != null;\n        PsiMethod m = (PsiMethod)e;\n        if (m.getContainingClass() == myBaseMethod.getContainingClass()) {\n          myInfo.registerDependency(myBaseMethod, m);\n        }\n      }\n      \n      // We process all method call expression children because there is a possible case like below:\n      //   new Runnable() {\n      //     void test();\n      //   }.run();\n      // Here we want to process that 'Runnable.run()' implementation.\n      super.visitMethodCallExpression(psiMethodCallExpression);\n    }","id":35641,"modified_method":"public void visitMethodCallExpression(PsiMethodCallExpression psiMethodCallExpression) {\n      PsiReference reference = psiMethodCallExpression.getMethodExpression().getReference();\n      if (reference == null) {\n        return;\n      }\n      PsiElement e = reference.resolve();\n      if (e instanceof PsiMethod) {\n        assert myBaseMethod != null;\n        PsiMethod m = (PsiMethod)e;\n        if (m.getContainingClass() == myBaseMethod.getContainingClass()) {\n          myInfo.registerMethodCallDependency(myBaseMethod, m);\n        }\n      }\n      \n      // We process all method call expression children because there is a possible case like below:\n      //   new Runnable() {\n      //     void test();\n      //   }.run();\n      // Here we want to process that 'Runnable.run()' implementation.\n      super.visitMethodCallExpression(psiMethodCallExpression);\n    }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public List<JavaElementArrangementEntry> parse(@NotNull PsiElement root,\n                                                 @Nullable Document document,\n                                                 @NotNull Collection<TextRange> ranges,\n                                                 @Nullable ArrangementSettings settings)\n  {\n    // Following entries are subject to arrangement: class, interface, field, method.\n    JavaArrangementParseInfo parseInfo = new JavaArrangementParseInfo();\n    root.accept(new JavaArrangementVisitor(parseInfo, document, ranges, getGroupingRules(settings)));\n    if (settings != null) {\n      for (ArrangementGroupingRule rule : settings.getGroupings()) {\n        if (GETTERS_AND_SETTERS.equals(rule.getGroupingType())) {\n          setupGettersAndSetters(parseInfo);\n        }\n        else if (DEPENDENT_METHODS.equals(rule.getGroupingType())) {\n          setupUtilityMethods(parseInfo, rule.getOrderType());\n        }\n        else if (OVERRIDDEN_METHODS.equals(rule.getGroupingType())) {\n          setupOverriddenMethods(parseInfo);\n        }\n      }\n    }\n    return parseInfo.getEntries();\n  }","id":35642,"modified_method":"@NotNull\n  @Override\n  public List<JavaElementArrangementEntry> parse(@NotNull PsiElement root,\n                                                 @Nullable Document document,\n                                                 @NotNull Collection<TextRange> ranges,\n                                                 @Nullable ArrangementSettings settings)\n  {\n    // Following entries are subject to arrangement: class, interface, field, method.\n    JavaArrangementParseInfo parseInfo = new JavaArrangementParseInfo();\n    root.accept(new JavaArrangementVisitor(parseInfo, document, ranges, getGroupingRules(settings)));\n    if (settings != null) {\n      for (ArrangementGroupingRule rule : settings.getGroupings()) {\n        if (GETTERS_AND_SETTERS.equals(rule.getGroupingType())) {\n          setupGettersAndSetters(parseInfo);\n        }\n        else if (DEPENDENT_METHODS.equals(rule.getGroupingType())) {\n          setupUtilityMethods(parseInfo, rule.getOrderType());\n        }\n        else if (OVERRIDDEN_METHODS.equals(rule.getGroupingType())) {\n          setupOverriddenMethods(parseInfo);\n        }\n      }\n    }\n    setupFieldInitializationDependencies(parseInfo.getFieldDependencyRoots());\n    return parseInfo.getEntries();\n  }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void setupDepthFirstDependency(@NotNull JavaArrangementMethodDependencyInfo info) {\n    for (JavaArrangementMethodDependencyInfo dependencyInfo : info.getDependentMethodInfos()) {\n      setupDepthFirstDependency(dependencyInfo);\n      JavaElementArrangementEntry dependentEntry = dependencyInfo.getAnchorMethod();\n      if (dependentEntry.getDependencies() == null) {\n        dependentEntry.addDependency(info.getAnchorMethod());\n      }\n    }\n  }","id":35643,"modified_method":"private static void setupDepthFirstDependency(@NotNull ArrangementEntryDependencyInfo info) {\n    for (ArrangementEntryDependencyInfo dependencyInfo : info.getDependentEntriesInfos()) {\n      setupDepthFirstDependency(dependencyInfo);\n      JavaElementArrangementEntry dependentEntry = dependencyInfo.getAnchorEntry();\n      if (dependentEntry.getDependencies() == null) {\n        dependentEntry.addDependency(info.getAnchorEntry());\n      }\n    }\n  }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void setupUtilityMethods(@NotNull JavaArrangementParseInfo info, @NotNull ArrangementSettingsToken orderType) {\n    if (DEPTH_FIRST.equals(orderType)) {\n      for (JavaArrangementMethodDependencyInfo rootInfo : info.getMethodDependencyRoots()) {\n        setupDepthFirstDependency(rootInfo);\n      }\n    }\n    else if (BREADTH_FIRST.equals(orderType)) {\n      for (JavaArrangementMethodDependencyInfo rootInfo : info.getMethodDependencyRoots()) {\n        setupBreadthFirstDependency(rootInfo);\n      }\n    }\n    else {\n      assert false : orderType;\n    }\n  }","id":35644,"modified_method":"private static void setupUtilityMethods(@NotNull JavaArrangementParseInfo info, @NotNull ArrangementSettingsToken orderType) {\n    if (DEPTH_FIRST.equals(orderType)) {\n      for (ArrangementEntryDependencyInfo rootInfo : info.getMethodDependencyRoots()) {\n        setupDepthFirstDependency(rootInfo);\n      }\n    }\n    else if (BREADTH_FIRST.equals(orderType)) {\n      for (ArrangementEntryDependencyInfo rootInfo : info.getMethodDependencyRoots()) {\n        setupBreadthFirstDependency(rootInfo);\n      }\n    }\n    else {\n      assert false : orderType;\n    }\n  }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void setupBreadthFirstDependency(@NotNull JavaArrangementMethodDependencyInfo info) {\n    Deque<JavaArrangementMethodDependencyInfo> toProcess = new ArrayDeque<JavaArrangementMethodDependencyInfo>();\n    toProcess.add(info);\n    while (!toProcess.isEmpty()) {\n      JavaArrangementMethodDependencyInfo current = toProcess.removeFirst();\n      for (JavaArrangementMethodDependencyInfo dependencyInfo : current.getDependentMethodInfos()) {\n        JavaElementArrangementEntry dependencyMethod = dependencyInfo.getAnchorMethod();\n        if (dependencyMethod.getDependencies() == null) {\n          dependencyMethod.addDependency(current.getAnchorMethod());\n        }\n        toProcess.addLast(dependencyInfo);\n      }\n    }\n  }","id":35645,"modified_method":"private static void setupBreadthFirstDependency(@NotNull ArrangementEntryDependencyInfo info) {\n    Deque<ArrangementEntryDependencyInfo> toProcess = new ArrayDeque<ArrangementEntryDependencyInfo>();\n    toProcess.add(info);\n    while (!toProcess.isEmpty()) {\n      ArrangementEntryDependencyInfo current = toProcess.removeFirst();\n      for (ArrangementEntryDependencyInfo dependencyInfo : current.getDependentEntriesInfos()) {\n        JavaElementArrangementEntry dependencyMethod = dependencyInfo.getAnchorEntry();\n        if (dependencyMethod.getDependencies() == null) {\n          dependencyMethod.addDependency(current.getAnchorEntry());\n        }\n        toProcess.addLast(dependencyInfo);\n      }\n    }\n  }","commit_id":"7f01bcd7b53c0c913445fbfee73e17bbac60461e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isComparison(@Nullable PsiExpression expression,\n                                       @NotNull PsiLocalVariable variable) {\n        expression =\n                ParenthesesUtils.stripParentheses(expression);\n        if (!(expression instanceof PsiBinaryExpression)) {\n            return false;\n        }\n        final PsiBinaryExpression binaryExpression =\n                (PsiBinaryExpression)expression;\n        final PsiJavaToken sign = binaryExpression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if (tokenType.equals(JavaTokenType.LT) ||\n                tokenType.equals(JavaTokenType.LE)) {\n            PsiExpression lhs = binaryExpression.getLOperand();\n            lhs = ParenthesesUtils.stripParentheses(lhs);\n            return VariableAccessUtils.evaluatesToVariable(lhs, variable);\n        } else if (tokenType.equals(JavaTokenType.GT) ||\n                tokenType.equals(JavaTokenType.GE)) {\n            PsiExpression rhs = binaryExpression.getROperand();\n            rhs = ParenthesesUtils.stripParentheses(rhs);\n            return VariableAccessUtils.evaluatesToVariable(rhs, variable);\n        }\n        return false;\n    }","id":35646,"modified_method":"public static boolean isVariableLessThanComparison(\n            @Nullable PsiExpression expression,\n            @NotNull PsiVariable variable) {\n        expression = ParenthesesUtils.stripParentheses(expression);\n        if (!(expression instanceof PsiBinaryExpression)) {\n            return false;\n        }\n        final PsiBinaryExpression binaryExpression =\n                (PsiBinaryExpression)expression;\n        final PsiJavaToken sign = binaryExpression.getOperationSign();\n        final IElementType tokenType = sign.getTokenType();\n        if (tokenType.equals(JavaTokenType.LT) ||\n                tokenType.equals(JavaTokenType.LE)) {\n            PsiExpression lhs = binaryExpression.getLOperand();\n            lhs = ParenthesesUtils.stripParentheses(lhs);\n            return VariableAccessUtils.evaluatesToVariable(lhs, variable);\n        } else if (tokenType.equals(JavaTokenType.GT) ||\n                tokenType.equals(JavaTokenType.GE)) {\n            PsiExpression rhs = binaryExpression.getROperand();\n            rhs = ParenthesesUtils.stripParentheses(rhs);\n            return VariableAccessUtils.evaluatesToVariable(rhs, variable);\n        }\n        return false;\n    }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitForStatement(\n                @NotNull PsiForStatement statement) {\n            super.visitForStatement(statement);\n            final PsiStatement initialization = statement.getInitialization();\n            if (!(initialization instanceof PsiDeclarationStatement)) {\n                return;\n            }\n            final PsiDeclarationStatement declaration =\n                    (PsiDeclarationStatement)initialization;\n            final PsiElement[] declaredElements =\n                    declaration.getDeclaredElements();\n            if (declaredElements.length != 1) {\n                return;\n            }\n            final PsiElement declaredElement = declaredElements[0];\n            if (!(declaredElement instanceof PsiLocalVariable)) {\n                return;\n            }\n            final PsiLocalVariable variable = (PsiLocalVariable)declaredElement;\n            final PsiExpression initialValue = variable.getInitializer();\n            if (initialValue == null) {\n                return;\n            }\n            final PsiExpression condition = statement.getCondition();\n            if (!ExpressionUtils.isComparison(condition, variable)) {\n                return;\n            }\n            final PsiStatement update = statement.getUpdate();\n            if (!VariableAccessUtils.variableIsIncremented(variable, update)) {\n                return;\n            }\n            final PsiStatement body = statement.getBody();\n            if (!bodyIsArrayCopy(body, variable, null)) {\n                return;\n            }\n            registerStatementError(statement);\n        }","id":35647,"modified_method":"@Override public void visitForStatement(\n                @NotNull PsiForStatement statement) {\n            super.visitForStatement(statement);\n            final PsiStatement initialization = statement.getInitialization();\n            if (!(initialization instanceof PsiDeclarationStatement)) {\n                return;\n            }\n            final PsiDeclarationStatement declaration =\n                    (PsiDeclarationStatement)initialization;\n            final PsiElement[] declaredElements =\n                    declaration.getDeclaredElements();\n            if (declaredElements.length != 1) {\n                return;\n            }\n            final PsiElement declaredElement = declaredElements[0];\n            if (!(declaredElement instanceof PsiLocalVariable)) {\n                return;\n            }\n            final PsiLocalVariable variable = (PsiLocalVariable)declaredElement;\n            final PsiExpression initialValue = variable.getInitializer();\n            if (initialValue == null) {\n                return;\n            }\n            final PsiStatement update = statement.getUpdate();\n            final boolean decrement;\n            if (VariableAccessUtils.variableIsIncremented(variable, update)) {\n                decrement = false;\n            } else if (VariableAccessUtils.variableIsDecremented(variable,\n                    update)) {\n                decrement = true;\n            } else {\n                return;\n            }\n            final PsiExpression condition = statement.getCondition();\n            if (decrement) {\n                if (!ExpressionUtils.isVariableGreaterThanComparison(\n                        condition, variable)) {\n                    return;\n                }\n            } else {\n                if (!ExpressionUtils.isVariableLessThanComparison(\n                        condition, variable)) {\n                    return;\n                }\n            }\n            final PsiStatement body = statement.getBody();\n            if (!bodyIsArrayCopy(body, variable, null)) {\n                return;\n            }\n            registerStatementError(statement, Boolean.valueOf(decrement));\n        }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String buildExpressionText(PsiExpression expression,\n                                                  boolean plusOne) {\n            if (!plusOne) {\n                return expression.getText();\n            }\n            if (expression instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression) expression;\n                final IElementType tokenType =\n                        binaryExpression.getOperationTokenType();\n                if (tokenType == JavaTokenType.MINUS)  {\n                    final PsiExpression rhs =\n                            binaryExpression.getROperand();\n                    if (ExpressionUtils.isOne(rhs)) {\n                        return binaryExpression.getLOperand().getText();\n                    }\n                }\n            }\n            final int precedence = ParenthesesUtils.getPrecedence(expression);\n            if (precedence > ParenthesesUtils.ADDITIVE_PRECEDENCE) {\n                return '(' + expression.getText() + \")+1\";\n            } else {\n                return expression.getText() + \"+1\";\n            }\n        }","id":35648,"modified_method":"private static String buildExpressionText(PsiExpression expression,\n                                                  boolean plusOne,\n                                                  boolean parenthesize) {\n            if (!plusOne) {\n                final int precedence =\n                        ParenthesesUtils.getPrecedence(expression);\n                if ( precedence > ParenthesesUtils.ADDITIVE_PRECEDENCE) {\n                    return '(' + expression.getText() + ')';\n                } else {\n                    if (parenthesize && precedence >=\n                            ParenthesesUtils.ADDITIVE_PRECEDENCE) {\n                        return '(' + expression.getText() + ')';\n                    }\n                    return expression.getText();\n                }\n            }\n            if (expression instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression) expression;\n                final IElementType tokenType =\n                        binaryExpression.getOperationTokenType();\n                if (tokenType == JavaTokenType.MINUS)  {\n                    final PsiExpression rhs =\n                            binaryExpression.getROperand();\n                    if (ExpressionUtils.isOne(rhs)) {\n                        return binaryExpression.getLOperand().getText();\n                    }\n                }\n            } else if (expression instanceof PsiLiteralExpression) {\n                final PsiLiteralExpression literalExpression =\n                        (PsiLiteralExpression) expression;\n                final Object value = literalExpression.getValue();\n                if (value instanceof Integer) {\n                    final Integer integer = (Integer) value;\n                    return String.valueOf(integer.intValue() + 1);\n                }\n            }\n            final int precedence = ParenthesesUtils.getPrecedence(expression);\n            final String result;\n            if (precedence > ParenthesesUtils.ADDITIVE_PRECEDENCE) {\n                result = '(' + expression.getText() + \")+1\";\n            } else {\n                result = expression.getText() + \"+1\";\n            }\n            if (parenthesize) {\n                return '(' + result + ')';\n            }\n            return result;\n        }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n        private static String buildSystemArrayCopyText(\n                PsiForStatement forStatement)\n                throws IncorrectOperationException {\n            final PsiExpression condition = forStatement.getCondition();\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression)ParenthesesUtils.stripParentheses(\n                            condition);\n            if (binaryExpression == null) {\n                return null;\n            }\n            final IElementType tokenType =\n                    binaryExpression.getOperationTokenType();\n            final PsiExpression limit;\n            if (JavaTokenType.LT.equals(tokenType) ||\n                    JavaTokenType.LE.equals(tokenType)) {\n                limit = binaryExpression.getROperand();\n            } else {\n                limit = binaryExpression.getLOperand();\n            }\n            if (limit == null) {\n                return null;\n            }\n            final PsiStatement initialization =\n                    forStatement.getInitialization();\n            if (initialization == null) {\n                return null;\n            }\n            if (!(initialization instanceof PsiDeclarationStatement)) {\n                return null;\n            }\n            final PsiDeclarationStatement declaration =\n                    (PsiDeclarationStatement)initialization;\n            final PsiElement[] declaredElements =\n                    declaration.getDeclaredElements();\n            if (declaredElements.length != 1) {\n                return null;\n            }\n            final PsiElement declaredElement = declaredElements[0];\n            if (!(declaredElement instanceof PsiLocalVariable)) {\n                return null;\n            }\n            final PsiLocalVariable variable = (PsiLocalVariable)declaredElement;\n            final String lengthText = buildLengthText(limit, variable,\n                    JavaTokenType.LE.equals(tokenType) ||\n                            JavaTokenType.GE.equals(tokenType));\n            final PsiArrayAccessExpression lhs =\n                    getLhsArrayAccessExpression(forStatement);\n            if (lhs == null) {\n                return null;\n            }\n            final PsiExpression lArray = lhs.getArrayExpression();\n            final String toArrayText = lArray.getText();\n            final PsiArrayAccessExpression rhs =\n                    getRhsArrayAccessExpression(forStatement);\n            if (rhs == null) {\n                return null;\n            }\n            final PsiExpression rArray = rhs.getArrayExpression();\n            final String fromArrayText = rArray.getText();\n            final PsiExpression rhsIndexExpression = rhs.getIndexExpression();\n            final PsiExpression strippedRhsIndexExpression =\n                    ParenthesesUtils.stripParentheses(rhsIndexExpression);\n            final String fromOffsetText =\n                    buildOffsetText(strippedRhsIndexExpression, variable);\n            final PsiExpression lhsIndexExpression = lhs.getIndexExpression();\n            final PsiExpression strippedLhsIndexExpression =\n                    ParenthesesUtils.stripParentheses(lhsIndexExpression);\n            final String toOffsetText =\n                    buildOffsetText(strippedLhsIndexExpression, variable);\n            @NonNls final StringBuilder buffer = new StringBuilder(60);\n            buffer.append(\"System.arraycopy(\");\n            buffer.append(fromArrayText);\n            buffer.append(\", \");\n            buffer.append(fromOffsetText);\n            buffer.append(\", \");\n            buffer.append(toArrayText);\n            buffer.append(\", \");\n            buffer.append(toOffsetText);\n            buffer.append(\", \");\n            buffer.append(lengthText);\n            buffer.append(\");\");\n            return buffer.toString();\n        }","id":35649,"modified_method":"@Nullable\n        private String buildSystemArrayCopyText(PsiForStatement forStatement)\n                throws IncorrectOperationException {\n            final PsiExpression condition = forStatement.getCondition();\n            final PsiBinaryExpression binaryExpression =\n                    (PsiBinaryExpression)ParenthesesUtils.stripParentheses(\n                            condition);\n            if (binaryExpression == null) {\n                return null;\n            }\n            final IElementType tokenType =\n                    binaryExpression.getOperationTokenType();\n            final PsiExpression limit;\n            if (decrement ^ JavaTokenType.LT.equals(tokenType) ||\n                    JavaTokenType.LE.equals(tokenType)) {\n                limit = binaryExpression.getROperand();\n            } else {\n                limit = binaryExpression.getLOperand();\n            }\n            if (limit == null) {\n                return null;\n            }\n            final PsiStatement initialization =\n                    forStatement.getInitialization();\n            if (initialization == null) {\n                return null;\n            }\n            if (!(initialization instanceof PsiDeclarationStatement)) {\n                return null;\n            }\n            final PsiDeclarationStatement declaration =\n                    (PsiDeclarationStatement)initialization;\n            final PsiElement[] declaredElements =\n                    declaration.getDeclaredElements();\n            if (declaredElements.length != 1) {\n                return null;\n            }\n            final PsiElement declaredElement = declaredElements[0];\n            if (!(declaredElement instanceof PsiLocalVariable)) {\n                return null;\n            }\n            final PsiLocalVariable variable = (PsiLocalVariable)declaredElement;\n            final String lengthText = buildLengthText(limit, variable,\n                    decrement ^ (JavaTokenType.LE.equals(tokenType) ||\n                            JavaTokenType.GE.equals(tokenType)));\n            if (lengthText == null) {\n                return null;\n            }\n            final PsiArrayAccessExpression lhs =\n                    getLhsArrayAccessExpression(forStatement);\n            if (lhs == null) {\n                return null;\n            }\n            final PsiExpression lArray = lhs.getArrayExpression();\n            final String toArrayText = lArray.getText();\n            final PsiArrayAccessExpression rhs =\n                    getRhsArrayAccessExpression(forStatement);\n            if (rhs == null) {\n                return null;\n            }\n            final PsiExpression rArray = rhs.getArrayExpression();\n            final String fromArrayText = rArray.getText();\n            final PsiExpression rhsIndexExpression = rhs.getIndexExpression();\n            final PsiExpression strippedRhsIndexExpression =\n                    ParenthesesUtils.stripParentheses(rhsIndexExpression);\n            final PsiExpression limitExpression;\n            if (decrement) {\n                limitExpression = limit;\n            } else {\n                limitExpression = variable.getInitializer();\n            }\n            final String fromOffsetText =\n                    buildOffsetText(strippedRhsIndexExpression, variable,\n                            limitExpression, decrement &&\n                                    (JavaTokenType.LT.equals(tokenType) ||\n                                            JavaTokenType.GT.equals(tokenType)));\n            final PsiExpression lhsIndexExpression = lhs.getIndexExpression();\n            final PsiExpression strippedLhsIndexExpression =\n                    ParenthesesUtils.stripParentheses(lhsIndexExpression);\n            final String toOffsetText =\n                    buildOffsetText(strippedLhsIndexExpression, variable,\n                            limitExpression, decrement &&\n                                    (JavaTokenType.LT.equals(tokenType) ||\n                                            JavaTokenType.GT.equals(tokenType)));\n            @NonNls final StringBuilder buffer = new StringBuilder(60);\n            buffer.append(\"System.arraycopy(\");\n            buffer.append(fromArrayText);\n            buffer.append(\", \");\n            buffer.append(fromOffsetText);\n            buffer.append(\", \");\n            buffer.append(toArrayText);\n            buffer.append(\", \");\n            buffer.append(toOffsetText);\n            buffer.append(\", \");\n            buffer.append(lengthText);\n            buffer.append(\");\");\n            return buffer.toString();\n        }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n        public String getName() {\n            return InspectionGadgetsBundle.message(\n                    \"manual.array.copy.replace.quickfix\");\n        }","id":35650,"modified_method":"public ManualArrayCopyFix(boolean decrement) {\n            this.decrement = decrement;\n        }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public InspectionGadgetsFix buildFix(Object... infos) {\n        return new ManualArrayCopyFix();\n    }","id":35651,"modified_method":"@Override\n    public InspectionGadgetsFix buildFix(Object... infos) {\n        final Boolean decrement = (Boolean) infos[0];\n        return new ManualArrayCopyFix(decrement.booleanValue());\n    }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NonNls @Nullable\n        private static String buildOffsetText(PsiExpression expression,\n                                            PsiLocalVariable variable)\n                throws IncorrectOperationException {\n            if (expression == null) {\n                return null;\n            }\n            final String expressionText = expression.getText();\n            final String variableName = variable.getName();\n            if (expressionText.equals(variableName)) {\n                final PsiExpression initialValue = variable.getInitializer();\n                if (initialValue == null) {\n                    return null;\n                }\n                return initialValue.getText();\n            }\n            if (expression instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)expression;\n                final PsiExpression lhs = binaryExpression.getLOperand();\n                final PsiExpression rhs = binaryExpression.getROperand();\n                final String rhsText = buildOffsetText(rhs, variable);\n                final PsiJavaToken sign = binaryExpression.getOperationSign();\n                final IElementType tokenType = sign.getTokenType();\n                if (ExpressionUtils.isZero(lhs)) {\n                    if (tokenType.equals(JavaTokenType.MINUS)) {\n                        return '-' + rhsText;\n                    }\n                    return rhsText;\n                }\n                final String lhsText = buildOffsetText(lhs, variable);\n                if (ExpressionUtils.isZero(rhs)) {\n                    return lhsText;\n                }\n                return collapseConstant(lhsText + sign.getText() + rhsText,\n                        variable);\n            }\n            return collapseConstant(expression.getText(), variable);\n        }","id":35652,"modified_method":"@NonNls @Nullable\n        private static String buildOffsetText(PsiExpression expression,\n                                              PsiLocalVariable variable,\n                                              PsiExpression limitExpression,\n                                              boolean plusOne)\n                throws IncorrectOperationException {\n            if (expression == null) {\n                return null;\n            }\n            final String expressionText = expression.getText();\n            final String variableName = variable.getName();\n            if (expressionText.equals(variableName)) {\n                final PsiExpression initialValue =\n                        ParenthesesUtils.stripParentheses(limitExpression);\n                if (initialValue == null) {\n                    return null;\n                }\n                return buildExpressionText(initialValue, plusOne, false);\n            } else if (expression instanceof PsiBinaryExpression) {\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression)expression;\n                final PsiExpression lhs = binaryExpression.getLOperand();\n                final PsiExpression rhs = binaryExpression.getROperand();\n                final String rhsText =\n                        buildOffsetText(rhs, variable, limitExpression, plusOne);\n                final PsiJavaToken sign = binaryExpression.getOperationSign();\n                final IElementType tokenType = sign.getTokenType();\n                if (ExpressionUtils.isZero(lhs)) {\n                    if (tokenType.equals(JavaTokenType.MINUS)) {\n                        return '-' + rhsText;\n                    }\n                    return rhsText;\n                }\n                if (plusOne && tokenType.equals(JavaTokenType.MINUS) &&\n                        ExpressionUtils.isOne(rhs)) {\n                    return buildOffsetText(lhs, variable, limitExpression,\n                            false);\n                }\n                final String lhsText = buildOffsetText(lhs, variable,\n                        limitExpression, plusOne);\n                if (ExpressionUtils.isZero(rhs)) {\n                    return lhsText;\n                }\n                return collapseConstant(lhsText + sign.getText() + rhsText,\n                        variable);\n            }\n            return collapseConstant(expression.getText(), variable);\n        }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NonNls @Nullable\n        private static String buildLengthText(PsiExpression expression,\n                                            PsiVariable variable,\n                                            boolean plusOne) {\n            expression = ParenthesesUtils.stripParentheses(expression);\n            if (expression == null) {\n                return null;\n            }\n            final String expressionText =\n                    buildExpressionText(expression, plusOne);\n            final PsiExpression initializer = variable.getInitializer();\n            if (initializer == null) {\n                return expressionText;\n            }\n            if (ExpressionUtils.isZero(initializer)) {\n                return expressionText;\n            }\n            final int precedence = ParenthesesUtils.getPrecedence(initializer);\n            final String initializerText;\n            if (precedence > ParenthesesUtils.ADDITIVE_PRECEDENCE) {\n                initializerText = '(' + initializer.getText() + ')';\n            } else {\n                initializerText = initializer.getText();\n            }\n            return expressionText + '-' + initializerText;\n        }","id":35653,"modified_method":"@NonNls @Nullable\n        private String buildLengthText(PsiExpression expression,\n                                       PsiVariable variable,\n                                       boolean plusOne) {\n            if (decrement) {\n                final PsiExpression initializer =\n                        ParenthesesUtils.stripParentheses(\n                                variable.getInitializer());\n                if (initializer == null) {\n                    return null;\n                }\n                final String initializerText =\n                        buildExpressionText(initializer, true, false);\n                if (ExpressionUtils.isZero(expression)) {\n                    return initializerText;\n                }\n                final String expressionText =\n                        buildExpressionText(expression, plusOne, true);\n                return initializerText + '-' + expressionText;\n            } else {\n                expression = ParenthesesUtils.stripParentheses(expression);\n                if (expression == null) {\n                    return null;\n                }\n                final String expressionText =\n                        buildExpressionText(expression, plusOne, false);\n                final PsiExpression initializer =\n                        ParenthesesUtils.stripParentheses(\n                                variable.getInitializer());\n                if (initializer == null) {\n                    return expressionText;\n                }\n                if (ExpressionUtils.isZero(initializer)) {\n                    return expressionText;\n                }\n                final int precedence =\n                        ParenthesesUtils.getPrecedence(initializer);\n                final String initializerText;\n                if (precedence > ParenthesesUtils.ADDITIVE_PRECEDENCE) {\n                    initializerText = '(' + initializer.getText() + ')';\n                } else {\n                    initializerText = initializer.getText();\n                }\n                return expressionText + '-' + initializerText;\n            }\n        }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override public void visitForStatement(\n                @NotNull PsiForStatement statement) {\n            super.visitForStatement(statement);\n            final PsiStatement initialization = statement.getInitialization();\n            if (!(initialization instanceof PsiDeclarationStatement)) {\n                return;\n            }\n            final PsiDeclarationStatement declaration =\n                    (PsiDeclarationStatement)initialization;\n            final PsiElement[] declaredElements =\n                    declaration.getDeclaredElements();\n            if (declaredElements.length != 1) {\n                return;\n            }\n            final PsiElement declaredElement = declaredElements[0];\n            if (!(declaredElement instanceof PsiLocalVariable)) {\n                return;\n            }\n            final PsiLocalVariable variable = (PsiLocalVariable)declaredElement;\n            final PsiExpression initialValue = variable.getInitializer();\n            if (initialValue == null) {\n                return;\n            }\n            final PsiExpression condition = statement.getCondition();\n            if (!ExpressionUtils.isComparison(condition, variable)) {\n                return;\n            }\n            final PsiStatement update = statement.getUpdate();\n            if (!VariableAccessUtils.variableIsIncremented(variable, update)) {\n                return;\n            }\n            final PsiStatement body = statement.getBody();\n            if (!bodyIsArrayToCollectionCopy(body, variable, true)) {\n                return;\n            }\n            registerStatementError(statement);\n        }","id":35654,"modified_method":"@Override public void visitForStatement(\n                @NotNull PsiForStatement statement) {\n            super.visitForStatement(statement);\n            final PsiStatement initialization = statement.getInitialization();\n            if (!(initialization instanceof PsiDeclarationStatement)) {\n                return;\n            }\n            final PsiDeclarationStatement declaration =\n                    (PsiDeclarationStatement)initialization;\n            final PsiElement[] declaredElements =\n                    declaration.getDeclaredElements();\n            if (declaredElements.length != 1) {\n                return;\n            }\n            final PsiElement declaredElement = declaredElements[0];\n            if (!(declaredElement instanceof PsiLocalVariable)) {\n                return;\n            }\n            final PsiLocalVariable variable = (PsiLocalVariable)declaredElement;\n            final PsiExpression initialValue = variable.getInitializer();\n            if (initialValue == null) {\n                return;\n            }\n            final PsiExpression condition = statement.getCondition();\n            if (!ExpressionUtils.isVariableLessThanComparison(condition,\n                    variable)) {\n                return;\n            }\n            final PsiStatement update = statement.getUpdate();\n            if (!VariableAccessUtils.variableIsIncremented(variable, update)) {\n                return;\n            }\n            final PsiStatement body = statement.getBody();\n            if (!bodyIsArrayToCollectionCopy(body, variable, true)) {\n                return;\n            }\n            registerStatementError(statement);\n        }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean variableIsIncremented(\n            @NotNull PsiVariable variable, @Nullable PsiStatement statement) {\n        if (!(statement instanceof PsiExpressionStatement)) {\n            return false;\n        }\n        final PsiExpressionStatement expressionStatement =\n                (PsiExpressionStatement)statement;\n        PsiExpression expression = expressionStatement.getExpression();\n        expression = ParenthesesUtils.stripParentheses(expression);\n        if (expression instanceof PsiPrefixExpression) {\n            final PsiPrefixExpression prefixExpression =\n                    (PsiPrefixExpression)expression;\n            final PsiJavaToken sign = prefixExpression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.PLUSPLUS)) {\n                return false;\n            }\n            final PsiExpression operand = prefixExpression.getOperand();\n            return evaluatesToVariable(operand, variable);\n        } else if (expression instanceof PsiPostfixExpression) {\n            final PsiPostfixExpression postfixExpression =\n                    (PsiPostfixExpression)expression;\n            final PsiJavaToken sign = postfixExpression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.PLUSPLUS)) {\n                return false;\n            }\n            final PsiExpression operand = postfixExpression.getOperand();\n            return evaluatesToVariable(operand, variable);\n        } else if (expression instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression assignmentExpression =\n                    (PsiAssignmentExpression) expression;\n            final IElementType tokenType =\n                    assignmentExpression.getOperationTokenType();\n            PsiExpression lhs = assignmentExpression.getLExpression();\n            lhs = ParenthesesUtils.stripParentheses(lhs);\n            if (!evaluatesToVariable(lhs, variable)) {\n                return false;\n            }\n            PsiExpression rhs = assignmentExpression.getRExpression();\n            rhs = ParenthesesUtils.stripParentheses(rhs);\n            if (tokenType == JavaTokenType.EQ) {\n                if (!(rhs instanceof PsiBinaryExpression)) {\n                    return false;\n                }\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression) rhs;\n                PsiExpression lOperand = binaryExpression.getLOperand();\n                lOperand = ParenthesesUtils.stripParentheses(lOperand);\n                PsiExpression rOperand = binaryExpression.getROperand();\n                rOperand = ParenthesesUtils.stripParentheses(rOperand);\n                if (ExpressionUtils.isOne(lOperand)) {\n                    if (evaluatesToVariable(rOperand, variable)) {\n                        return true;\n                    }\n                } else if (ExpressionUtils.isOne(rOperand)) {\n                    if (evaluatesToVariable(lOperand, variable)) {\n                        return true;\n                    }\n                }\n            } else if (tokenType == JavaTokenType.PLUSEQ) {\n                if (ExpressionUtils.isOne(rhs)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","id":35655,"modified_method":"public static boolean variableIsIncremented(\n            @NotNull PsiVariable variable, @Nullable PsiStatement statement) {\n        if (!(statement instanceof PsiExpressionStatement)) {\n            return false;\n        }\n        final PsiExpressionStatement expressionStatement =\n                (PsiExpressionStatement)statement;\n        PsiExpression expression = expressionStatement.getExpression();\n        expression = ParenthesesUtils.stripParentheses(expression);\n        if (expression instanceof PsiPrefixExpression) {\n            final PsiPrefixExpression prefixExpression =\n                    (PsiPrefixExpression)expression;\n            final PsiJavaToken sign = prefixExpression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.PLUSPLUS)) {\n                return false;\n            }\n            final PsiExpression operand = prefixExpression.getOperand();\n            return evaluatesToVariable(operand, variable);\n        } else if (expression instanceof PsiPostfixExpression) {\n            final PsiPostfixExpression postfixExpression =\n                    (PsiPostfixExpression)expression;\n            final PsiJavaToken sign = postfixExpression.getOperationSign();\n            final IElementType tokenType = sign.getTokenType();\n            if (!tokenType.equals(JavaTokenType.PLUSPLUS)) {\n                return false;\n            }\n            final PsiExpression operand = postfixExpression.getOperand();\n            return evaluatesToVariable(operand, variable);\n        } else if (expression instanceof PsiAssignmentExpression) {\n            final PsiAssignmentExpression assignmentExpression =\n                    (PsiAssignmentExpression) expression;\n            final IElementType tokenType =\n                    assignmentExpression.getOperationTokenType();\n            PsiExpression lhs = assignmentExpression.getLExpression();\n            lhs = ParenthesesUtils.stripParentheses(lhs);\n            if (!evaluatesToVariable(lhs, variable)) {\n                return false;\n            }\n            PsiExpression rhs = assignmentExpression.getRExpression();\n            rhs = ParenthesesUtils.stripParentheses(rhs);\n            if (tokenType == JavaTokenType.EQ) {\n                if (!(rhs instanceof PsiBinaryExpression)) {\n                    return false;\n                }\n                final PsiBinaryExpression binaryExpression =\n                        (PsiBinaryExpression) rhs;\n                final IElementType binaryTokenType =\n                        binaryExpression.getOperationTokenType();\n                if (binaryTokenType != JavaTokenType.PLUS) {\n                    return false;\n                }\n                PsiExpression lOperand = binaryExpression.getLOperand();\n                lOperand = ParenthesesUtils.stripParentheses(lOperand);\n                PsiExpression rOperand = binaryExpression.getROperand();\n                rOperand = ParenthesesUtils.stripParentheses(rOperand);\n                if (ExpressionUtils.isOne(lOperand)) {\n                    if (evaluatesToVariable(rOperand, variable)) {\n                        return true;\n                    }\n                } else if (ExpressionUtils.isOne(rOperand)) {\n                    if (evaluatesToVariable(lOperand, variable)) {\n                        return true;\n                    }\n                }\n            } else if (tokenType == JavaTokenType.PLUSEQ) {\n                if (ExpressionUtils.isOne(rhs)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"fd9b47e6d156294339d68bf3307ea9c44a783564","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n   private static String[] getNamesForIdentifier(Project project, PsiIdentifier identifier){\n     if (identifier.getParent() instanceof PsiVariable){\n       PsiVariable var = (PsiVariable)identifier.getParent();\n       if (identifier.equals(var.getNameIdentifier())){\n         CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(project);\n         VariableKind variableKind = codeStyleManager.getVariableKind(var);\n         SuggestedNameInfo suggestedInfo = codeStyleManager.suggestVariableName(variableKind, null, var.getInitializer(), var.getType());\n         return suggestedInfo.names;\n       }\n     }\n     return null;\n   }","id":35656,"modified_method":"@Nullable\n   private static String[] getNamesForIdentifier(Project project, PsiIdentifier identifier){\n     if (identifier.getParent() instanceof PsiVariable){\n       PsiVariable var = (PsiVariable)identifier.getParent();\n       if (identifier.equals(var.getNameIdentifier())){\n         CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(project);\n         VariableKind variableKind = codeStyleManager.getVariableKind(var);\n         PsiExpression initializer = var.getInitializer();\n         if (var instanceof PsiParameter && ((PsiParameter)var).getDeclarationScope() instanceof PsiForeachStatement) {\n           //synthesize initializer\n           PsiForeachStatement foreachStatement = (PsiForeachStatement)((PsiParameter)var).getDeclarationScope();\n           final PsiExpression iteratedValue = foreachStatement.getIteratedValue();\n           if (iteratedValue != null) {\n             try {\n               final PsiArrayAccessExpression expr = (PsiArrayAccessExpression)iteratedValue.getManager().getElementFactory().createExpressionFromText(\"a[0]\", var);\n               expr.getArrayExpression().replace(iteratedValue);\n               initializer = expr; //note: non physical with no parent\n             }\n             catch (IncorrectOperationException e) {\n               //do nothing\n             }\n           }\n         }\n         SuggestedNameInfo suggestedInfo = codeStyleManager.suggestVariableName(variableKind, null, initializer, var.getType());\n         return suggestedInfo.names;\n       }\n     }\n     return null;\n   }","commit_id":"5dc43ab0ba2a5a917013e97745bb8dab235b3ad7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void renameReferences(PsiElement scope) throws IncorrectOperationException {\n    PsiSearchHelper helper = myManager.getSearchHelper();\n    PsiElementFactory factory = myManager.getElementFactory();\n    for (VariableInfo info : myVariableInfos) {\n      PsiReference[] references = helper.findReferences(info.variable, new LocalSearchScope(scope), false);\n      if (references.length > 0) {\n        for (PsiReference reference : references) {\n          PsiElement ref = reference.getElement();\n          PsiIdentifier identifier = (PsiIdentifier)((PsiJavaCodeReferenceElement)ref).getReferenceNameElement();\n          boolean renameToFieldName = !isUsedInInitializer(ref);\n          PsiIdentifier newNameIdentifier = factory.createIdentifier(renameToFieldName ? info.fieldName : info.parameterName);\n          if (renameToFieldName) {\n            identifier.replace(newNameIdentifier);\n          }\n          else {\n            if (info.passAsParameter) {\n              identifier.replace(newNameIdentifier);\n            }\n          }\n        }\n      }\n    }\n  }","id":35657,"modified_method":"private void renameReferences(PsiElement scope) throws IncorrectOperationException {\n    PsiElementFactory factory = myManager.getElementFactory();\n    for (VariableInfo info : myVariableInfos) {\n      Collection<PsiReference> references = ReferencesSearch.search(info.variable, new LocalSearchScope(scope)).findAll();\n      for (PsiReference reference : references) {\n        PsiElement ref = reference.getElement();\n        PsiIdentifier identifier = (PsiIdentifier)((PsiJavaCodeReferenceElement)ref).getReferenceNameElement();\n        assert identifier != null;\n        boolean renameToFieldName = !isUsedInInitializer(ref);\n        PsiIdentifier newNameIdentifier = factory.createIdentifier(renameToFieldName ? info.fieldName : info.parameterName);\n        if (renameToFieldName) {\n          identifier.replace(newNameIdentifier);\n        }\n        else {\n          if (info.passAsParameter) {\n            identifier.replace(newNameIdentifier);\n          }\n        }\n      }\n    }\n  }","commit_id":"dc83d56ca1f536110155421ee5be043a0e8650b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createSuperStatement(PsiMethod constructor, PsiExpression[] paramExpressions) throws IncorrectOperationException {\n    PsiCodeBlock body = constructor.getBody();\n    final PsiElementFactory factory = constructor.getManager().getElementFactory();\n\n    PsiStatement statement = factory.createStatementFromText(\"super();\", null);\n    statement = (PsiStatement) CodeStyleManager.getInstance(myProject).reformat(statement);\n    statement = (PsiStatement) body.add(statement);\n\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression) ((PsiExpressionStatement) statement).getExpression();\n    PsiExpressionList exprList = methodCall.getArgumentList();\n\n\n    {\n      final PsiThisExpression qualifiedThis =\n        (PsiThisExpression) factory.createExpressionFromText(\"A.this\", null);\n      final PsiJavaCodeReferenceElement targetClassRef = factory.createClassReferenceElement(myTargetClass);\n      qualifiedThis.getQualifier().replace(targetClassRef);\n\n      for (PsiExpression expr : paramExpressions) {\n        ChangeContextUtil.encodeContextInfo(expr, true);\n        final PsiElement newExpr = exprList.add(expr);\n        ChangeContextUtil.decodeContextInfo(newExpr, myTargetClass, qualifiedThis);\n      }\n    }\n\n    class SupersConvertor extends PsiRecursiveElementVisitor {\n      public void visitThisExpression(PsiThisExpression expression) {\n        try {\n          final PsiThisExpression qualifiedThis =\n                  (PsiThisExpression) factory.createExpressionFromText(\"A.this\", null);\n          final PsiJavaCodeReferenceElement targetClassRef = factory.createClassReferenceElement(myTargetClass);\n          qualifiedThis.getQualifier().replace(targetClassRef);\n          expression.replace(qualifiedThis);\n        } catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n      }\n    }\n\n    final SupersConvertor supersConvertor = new SupersConvertor();\n    methodCall.getArgumentList().accept(supersConvertor);\n  }","id":35658,"modified_method":"private void createSuperStatement(PsiMethod constructor, PsiExpression[] paramExpressions) throws IncorrectOperationException {\n    PsiCodeBlock body = constructor.getBody();\n    assert body != null;\n    final PsiElementFactory factory = constructor.getManager().getElementFactory();\n\n    PsiStatement statement = factory.createStatementFromText(\"super();\", null);\n    statement = (PsiStatement) CodeStyleManager.getInstance(myProject).reformat(statement);\n    statement = (PsiStatement) body.add(statement);\n\n    PsiMethodCallExpression methodCall = (PsiMethodCallExpression) ((PsiExpressionStatement) statement).getExpression();\n    PsiExpressionList exprList = methodCall.getArgumentList();\n\n\n    {\n      final PsiThisExpression qualifiedThis =\n        (PsiThisExpression) factory.createExpressionFromText(\"A.this\", null);\n      final PsiJavaCodeReferenceElement targetClassRef = factory.createClassReferenceElement(myTargetClass);\n      PsiJavaCodeReferenceElement thisQualifier = qualifiedThis.getQualifier();\n      assert thisQualifier != null;\n      thisQualifier.replace(targetClassRef);\n\n      for (PsiExpression expr : paramExpressions) {\n        ChangeContextUtil.encodeContextInfo(expr, true);\n        final PsiElement newExpr = exprList.add(expr);\n        ChangeContextUtil.decodeContextInfo(newExpr, myTargetClass, qualifiedThis);\n      }\n    }\n\n    class SupersConvertor extends PsiRecursiveElementVisitor {\n      public void visitThisExpression(PsiThisExpression expression) {\n        try {\n          final PsiThisExpression qualifiedThis =\n                  (PsiThisExpression) factory.createExpressionFromText(\"A.this\", null);\n          final PsiJavaCodeReferenceElement targetClassRef = factory.createClassReferenceElement(myTargetClass);\n          PsiJavaCodeReferenceElement thisQualifier = qualifiedThis.getQualifier();\n          assert thisQualifier != null;\n          thisQualifier.replace(targetClassRef);\n          expression.replace(qualifiedThis);\n        } catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n      }\n    }\n\n    final SupersConvertor supersConvertor = new SupersConvertor();\n    methodCall.getArgumentList().accept(supersConvertor);\n  }","commit_id":"dc83d56ca1f536110155421ee5be043a0e8650b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void appendInitializers(final PsiMethod constructor) throws IncorrectOperationException {\n    final PsiClassInitializer[] initializers = myAnonClass.getInitializers();\n    for (PsiClassInitializer initializer : initializers) {\n      if (!initializer.hasModifierProperty(PsiModifier.STATIC)) {\n        final PsiCodeBlock body = initializer.getBody();\n        if (body != null) {\n          PsiElement firstBodyElement = body.getFirstBodyElement();\n          if (firstBodyElement != null) {\n            constructor.getBody().addRange(firstBodyElement, body.getLastBodyElement());\n          }\n        }\n      }\n    }\n    final PsiField[] fields = myAnonClass.getFields();\n    for (PsiField field : fields) {\n      if (!field.hasModifierProperty(PsiModifier.STATIC) && field.getInitializer() != null) {\n        final PsiExpressionStatement statement = (PsiExpressionStatement)myManager.getElementFactory()\n          .createStatementFromText(field.getName() + \"= 0;\", null);\n        ((PsiAssignmentExpression)statement.getExpression()).getRExpression().replace(field.getInitializer());\n        constructor.getBody().add(statement);\n      }\n    }\n  }","id":35659,"modified_method":"private void appendInitializers(final PsiMethod constructor) throws IncorrectOperationException {\n    PsiCodeBlock constructorBody = constructor.getBody();\n    assert constructorBody != null;\n\n    List<PsiElement> toAdd = new ArrayList<PsiElement>();\n    for (PsiClassInitializer initializer : myAnonClass.getInitializers()) {\n      if (!initializer.hasModifierProperty(PsiModifier.STATIC)) {\n        toAdd.add(initializer);\n      }\n    }\n    for (PsiField field : myAnonClass.getFields()) {\n      if (!field.hasModifierProperty(PsiModifier.STATIC) && field.getInitializer() != null) {\n        toAdd.add(field);\n      }\n    }\n\n    Collections.sort(toAdd, new Comparator<PsiElement>() {\n      public int compare(PsiElement e1, PsiElement e2) {\n        return e1.getTextRange().getStartOffset() - e2.getTextRange().getStartOffset();\n      }\n    });\n\n    for (PsiElement element : toAdd) {\n      if (element instanceof PsiClassInitializer) {\n        PsiClassInitializer initializer = (PsiClassInitializer) element;\n        final PsiCodeBlock initializerBody = initializer.getBody();\n        PsiElement firstBodyElement = initializerBody.getFirstBodyElement();\n        if (firstBodyElement != null) {\n          constructorBody.addRange(firstBodyElement, initializerBody.getLastBodyElement());\n        }\n      } else {\n        PsiField field = (PsiField) element;\n        final PsiExpressionStatement statement = (PsiExpressionStatement)myManager.getElementFactory()\n          .createStatementFromText(field.getName() + \"= 0;\", null);\n        PsiExpression rightExpression = ((PsiAssignmentExpression) statement.getExpression()).getRExpression();\n        assert rightExpression != null;\n        PsiExpression fieldInitializer = field.getInitializer();\n        assert fieldInitializer != null;\n        rightExpression.replace(fieldInitializer);\n        constructorBody.add(statement);\n      }\n    }\n  }","commit_id":"dc83d56ca1f536110155421ee5be043a0e8650b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createAssignmentStatements(PsiMethod constructor) throws IncorrectOperationException {\n    PsiElementFactory factory = constructor.getManager().getElementFactory();\n    for (VariableInfo info : myVariableInfos) {\n      if (info.saveInField) {\n        @NonNls String text = info.fieldName + \"=a;\";\n        boolean useThis = info.passAsParameter && info.parameterName.equals(info.fieldName);\n        if (useThis) {\n          text = \"this.\" + text;\n        }\n        PsiExpressionStatement statement = (PsiExpressionStatement)factory.createStatementFromText(text, null);\n        statement = (PsiExpressionStatement)CodeStyleManager.getInstance(myProject).reformat(statement);\n        // in order for \"...\" trick to work, the statement must be added to constructor first\n        statement = (PsiExpressionStatement)constructor.getBody().add(statement);\n\n        PsiAssignmentExpression assignment = (PsiAssignmentExpression)statement.getExpression();\n        PsiReferenceExpression rExpr = (PsiReferenceExpression)assignment.getRExpression();\n        PsiIdentifier identifier = (PsiIdentifier)rExpr.getReferenceNameElement();\n        if (info.passAsParameter) {\n          identifier.replace(factory.createIdentifier(info.parameterName));\n        }\n        else {\n          TextRange range = rExpr.getTextRange();\n          BlockSupport blockSupport = myProject.getComponent(BlockSupport.class);\n          blockSupport.reparseRange(statement.getContainingFile(), range.getStartOffset(), range.getEndOffset(), \"...\");\n        }\n      }\n    }\n  }","id":35660,"modified_method":"private void createAssignmentStatements(PsiMethod constructor) throws IncorrectOperationException {\n    PsiElementFactory factory = constructor.getManager().getElementFactory();\n    for (VariableInfo info : myVariableInfos) {\n      if (info.saveInField) {\n        @NonNls String text = info.fieldName + \"=a;\";\n        boolean useThis = info.passAsParameter && info.parameterName.equals(info.fieldName);\n        if (useThis) {\n          text = \"this.\" + text;\n        }\n        PsiExpressionStatement statement = (PsiExpressionStatement)factory.createStatementFromText(text, null);\n        statement = (PsiExpressionStatement)CodeStyleManager.getInstance(myProject).reformat(statement);\n        // in order for \"...\" trick to work, the statement must be added to constructor first\n        PsiCodeBlock constructorBody = constructor.getBody();\n        assert constructorBody != null;\n        statement = (PsiExpressionStatement)constructorBody.add(statement);\n\n        PsiAssignmentExpression assignment = (PsiAssignmentExpression)statement.getExpression();\n        PsiReferenceExpression rExpr = (PsiReferenceExpression)assignment.getRExpression();\n        assert rExpr != null;\n        if (info.passAsParameter) {\n          rExpr.replace(factory.createExpressionFromText(info.parameterName, null));\n        }\n        else {\n          TextRange range = rExpr.getTextRange();\n          BlockSupport blockSupport = myProject.getComponent(BlockSupport.class);\n          blockSupport.reparseRange(statement.getContainingFile(), range.getStartOffset(), range.getEndOffset(), \"...\");\n        }\n      }\n    }\n  }","commit_id":"dc83d56ca1f536110155421ee5be043a0e8650b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiClass createClass(String name) throws IncorrectOperationException {\n    PsiElementFactory factory = myAnonClass.getManager().getElementFactory();\n    CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(myProject);\n    final PsiNewExpression newExpression = (PsiNewExpression) myAnonClass.getParent();\n    final PsiMethod superConstructor = newExpression.resolveConstructor();\n\n    PsiClass aClass = factory.createClass(name);\n    if (!myTargetClass.isInterface()) {\n      aClass.getModifierList().setModifierProperty(PsiModifier.PRIVATE, true);\n    }\n    PsiModifierListOwner owner = PsiTreeUtil.getParentOfType(myAnonClass, PsiModifierListOwner.class);\n    if (owner != null && owner.hasModifierProperty(PsiModifier.STATIC)) {\n      aClass.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n    }\n    PsiJavaCodeReferenceElement baseClassRef = myAnonClass.getBaseClassReference();\n    PsiClass baseClass = (PsiClass)baseClassRef.resolve();\n    if (baseClass != null && baseClass.isInterface()) {\n      aClass.getImplementsList().add(baseClassRef);\n    }\n    else {\n      aClass.getExtendsList().add(baseClassRef);\n    }\n\n    renameReferences(myAnonClass);\n    copyClassBody(myAnonClass, aClass, myVariableInfos.length > 0);\n\n    if (myVariableInfos.length > 0) {\n      createFields(aClass);\n    }\n\n    PsiExpressionList exprList = newExpression.getArgumentList();\n    PsiExpression[] originalExpressions = exprList.getExpressions();\n    final PsiReferenceList superConstructorThrowsList =\n            superConstructor != null && superConstructor.getThrowsList().getReferencedTypes().length > 0\n            ? superConstructor.getThrowsList()\n            : null;\n    if (myVariableInfos.length > 0 || originalExpressions.length > 0 || superConstructorThrowsList != null) {\n      PsiMethod constructor = factory.createConstructor();\n      if (superConstructorThrowsList != null) {\n        constructor.getThrowsList().replace(superConstructorThrowsList);\n      }\n      if (originalExpressions.length > 0) {\n        createSuperStatement(constructor, originalExpressions);\n      }\n      if (myVariableInfos.length > 0) {\n        fillParameterList(constructor);\n        createAssignmentStatements(constructor);\n\n        appendInitializers(constructor);\n      }\n\n      constructor = (PsiMethod) codeStyleManager.reformat(constructor);\n      aClass.add(constructor);\n    }\n\n    if (!needsThis() && myMakeStatic) {\n      aClass.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n    }\n    PsiElement lastChild = aClass.getLastChild();\n    if (lastChild instanceof PsiJavaToken && ((PsiJavaToken)lastChild).getTokenType() == JavaTokenType.SEMICOLON) {\n      lastChild.delete();\n    }\n\n    return aClass;\n  }","id":35661,"modified_method":"private PsiClass createClass(String name) throws IncorrectOperationException {\n    PsiElementFactory factory = myAnonClass.getManager().getElementFactory();\n    CodeStyleManager codeStyleManager = CodeStyleManager.getInstance(myProject);\n    final PsiNewExpression newExpression = (PsiNewExpression) myAnonClass.getParent();\n    final PsiMethod superConstructor = newExpression.resolveConstructor();\n\n    PsiClass aClass = factory.createClass(name);\n    if (!myTargetClass.isInterface()) {\n      aClass.getModifierList().setModifierProperty(PsiModifier.PRIVATE, true);\n    }\n    PsiModifierListOwner owner = PsiTreeUtil.getParentOfType(myAnonClass, PsiModifierListOwner.class);\n    if (owner != null && owner.hasModifierProperty(PsiModifier.STATIC)) {\n      aClass.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n    }\n    PsiJavaCodeReferenceElement baseClassRef = myAnonClass.getBaseClassReference();\n    PsiClass baseClass = (PsiClass)baseClassRef.resolve();\n    PsiReferenceList refList = baseClass != null && baseClass.isInterface() ?\n                               aClass.getImplementsList() :\n                               aClass.getExtendsList();\n    if (refList != null) refList.add(baseClassRef);\n\n    renameReferences(myAnonClass);\n    copyClassBody(myAnonClass, aClass, myVariableInfos.length > 0);\n\n    if (myVariableInfos.length > 0) {\n      createFields(aClass);\n    }\n\n    PsiExpressionList argList = newExpression.getArgumentList();\n    assert argList != null;\n    PsiExpression[] originalExpressions = argList.getExpressions();\n    final PsiReferenceList superConstructorThrowsList =\n            superConstructor != null && superConstructor.getThrowsList().getReferencedTypes().length > 0\n            ? superConstructor.getThrowsList()\n            : null;\n    if (myVariableInfos.length > 0 || originalExpressions.length > 0 || superConstructorThrowsList != null) {\n      PsiMethod constructor = factory.createConstructor();\n      if (superConstructorThrowsList != null) {\n        constructor.getThrowsList().replace(superConstructorThrowsList);\n      }\n      if (originalExpressions.length > 0) {\n        createSuperStatement(constructor, originalExpressions);\n      }\n      if (myVariableInfos.length > 0) {\n        fillParameterList(constructor);\n        createAssignmentStatements(constructor);\n\n        appendInitializers(constructor);\n      }\n\n      constructor = (PsiMethod) codeStyleManager.reformat(constructor);\n      aClass.add(constructor);\n    }\n\n    if (!needsThis() && myMakeStatic) {\n      aClass.getModifierList().setModifierProperty(PsiModifier.STATIC, true);\n    }\n    PsiElement lastChild = aClass.getLastChild();\n    if (lastChild instanceof PsiJavaToken && ((PsiJavaToken)lastChild).getTokenType() == JavaTokenType.SEMICOLON) {\n      lastChild.delete();\n    }\n\n    return aClass;\n  }","commit_id":"dc83d56ca1f536110155421ee5be043a0e8650b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void copyClassBody(PsiClass sourceClass,\n                                    PsiClass targetClass,\n                                    boolean appendInitializersToConstructor) throws IncorrectOperationException {\n    PsiElement lbrace = sourceClass.getLBrace();\n    PsiElement rbrace = sourceClass.getRBrace();\n    if (lbrace != null) {\n      targetClass.addRange(lbrace.getNextSibling(), rbrace != null ? rbrace.getPrevSibling() : sourceClass.getLastChild());\n      if (appendInitializersToConstructor) {  //see SCR 41692\n        final PsiClassInitializer[] initializers = targetClass.getInitializers();\n        for (PsiClassInitializer initializer : initializers) {\n          if (!initializer.hasModifierProperty(PsiModifier.STATIC)) initializer.delete();\n        }\n        final PsiField[] fields = targetClass.getFields();\n        for (PsiField field : fields) {\n          if (!field.hasModifierProperty(PsiModifier.STATIC) && field.getInitializer() != null) {\n            field.getInitializer().delete();\n          }\n        }\n      }\n    }\n  }","id":35662,"modified_method":"private static void copyClassBody(PsiClass sourceClass,\n                                    PsiClass targetClass,\n                                    boolean appendInitializersToConstructor) throws IncorrectOperationException {\n    PsiElement lbrace = sourceClass.getLBrace();\n    PsiElement rbrace = sourceClass.getRBrace();\n    if (lbrace != null) {\n      targetClass.addRange(lbrace.getNextSibling(), rbrace != null ? rbrace.getPrevSibling() : sourceClass.getLastChild());\n      if (appendInitializersToConstructor) {  //see SCR 41692\n        final PsiClassInitializer[] initializers = targetClass.getInitializers();\n        for (PsiClassInitializer initializer : initializers) {\n          if (!initializer.hasModifierProperty(PsiModifier.STATIC)) initializer.delete();\n        }\n        final PsiField[] fields = targetClass.getFields();\n        for (PsiField field : fields) {\n          PsiExpression initializer = field.getInitializer();\n          if (!field.hasModifierProperty(PsiModifier.STATIC) && initializer != null) {\n            initializer.delete();\n          }\n        }\n      }\n    }\n  }","commit_id":"dc83d56ca1f536110155421ee5be043a0e8650b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean needsThis() {\n    if(cachedNeedsThis == null) {\n\n      ElementNeedsThis memberNeedsThis = new ElementNeedsThis(myTargetClass, myAnonClass);\n      myAnonClass.accept(memberNeedsThis);\n      class HasExplicitThis extends PsiRecursiveElementVisitor {\n        boolean hasExplicitThis = false;\n        public void visitReferenceExpression(PsiReferenceExpression expression) {\n        }\n\n        public void visitThisExpression(PsiThisExpression expression) {\n          hasExplicitThis = true;\n        }\n      }\n      final HasExplicitThis hasExplicitThis = new HasExplicitThis();\n      ((PsiNewExpression) myAnonClass.getParent()).getArgumentList().accept(hasExplicitThis);\n      cachedNeedsThis = new Boolean(memberNeedsThis.usesMembers() || hasExplicitThis.hasExplicitThis);\n    }\n    return cachedNeedsThis.booleanValue();\n  }","id":35663,"modified_method":"private boolean needsThis() {\n    if(cachedNeedsThis == null) {\n\n      ElementNeedsThis memberNeedsThis = new ElementNeedsThis(myTargetClass, myAnonClass);\n      myAnonClass.accept(memberNeedsThis);\n      class HasExplicitThis extends PsiRecursiveElementVisitor {\n        boolean hasExplicitThis = false;\n        public void visitReferenceExpression(PsiReferenceExpression expression) {\n        }\n\n        public void visitThisExpression(PsiThisExpression expression) {\n          hasExplicitThis = true;\n        }\n      }\n      final HasExplicitThis hasExplicitThis = new HasExplicitThis();\n      PsiExpressionList argList = myAnonClass.getArgumentList();\n      if (argList != null) argList.accept(hasExplicitThis);\n      cachedNeedsThis = memberNeedsThis.usesMembers() || hasExplicitThis.hasExplicitThis;\n    }\n    return cachedNeedsThis.booleanValue();\n  }","commit_id":"dc83d56ca1f536110155421ee5be043a0e8650b7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitField(PsiField field) {\n    // There is a possible case that more than one field is declared for the same type like 'int i, j;'. We want to process only\n    // the first one then.\n    PsiElement fieldPrev = getPreviousNonWsComment(field.getPrevSibling(), 0);\n    if (fieldPrev instanceof PsiJavaToken && ((PsiJavaToken)fieldPrev).getTokenType() == JavaTokenType.COMMA) {\n      return;\n    }\n\n    // There is a possible case that fields which share the same type declaration are located on different document lines, e.g.:\n    //    int i1,\n    //        i2;\n    // We want to consider only the first declaration then but need to expand its range to all affected lines (up to semicolon).\n    TextRange range = field.getTextRange();\n    PsiElement child = field.getLastChild();\n    boolean needSpecialProcessing = true;\n    if (isSemicolon(child)) {\n      needSpecialProcessing = false;\n    }\n    else if (child instanceof PsiComment) {\n      // There is a possible field definition like below:\n      //   int f; // my comment.\n      // The comment goes into field PSI here, that's why we need to handle it properly.\n      PsiElement prev = getPreviousNonWsComment(child, range.getStartOffset());\n      needSpecialProcessing = prev != null && !isSemicolon(prev);\n    }\n    \n    if (needSpecialProcessing) {\n      for (PsiElement e = field.getNextSibling(); e != null; e = e.getNextSibling()) {\n        if (e instanceof PsiWhiteSpace || e instanceof PsiComment) { // Skip white space and comment\n          continue;\n        }\n        else if (e instanceof PsiJavaToken) {\n          if (((PsiJavaToken)e).getTokenType() == JavaTokenType.COMMA) { // Skip comma\n            continue;\n          }\n          else {\n            break;\n          }\n        }\n        else if (e instanceof PsiField) {\n          PsiElement c = e.getLastChild();\n          if (c != null) {\n            c = getPreviousNonWsComment(c, range.getStartOffset());\n          }\n          // Stop if current field ends by a semicolon.\n          if (c instanceof PsiErrorElement // Incomplete field without trailing semicolon\n              || (c instanceof PsiJavaToken && ((PsiJavaToken)c).getTokenType() == JavaTokenType.SEMICOLON))\n          {\n            range = TextRange.create(range.getStartOffset(), expandToCommentIfPossible(c));\n          }\n          else {\n            continue;\n          }\n        }\n        break;\n      }\n    }\n\n    JavaElementArrangementEntry entry = createNewEntry(field, range, FIELD, field.getName(), true);\n    if (entry == null)\n      return;\n\n    PsiExpression fieldInitializer = field.getInitializer();\n    processEntry(entry, field, fieldInitializer);\n    myInfo.onFieldEntryCreated(field, entry);\n\n    if (fieldInitializer != null) {\n      List<PsiField> referencedFields = getReferencedFields(fieldInitializer);\n      for (PsiField referencedField : referencedFields) {\n        myInfo.registerFieldInitializationDependency(field, referencedField);\n      }\n    }\n  }","id":35664,"modified_method":"@Override\n  public void visitField(PsiField field) {\n    // There is a possible case that more than one field is declared for the same type like 'int i, j;'. We want to process only\n    // the first one then.\n    PsiElement fieldPrev = getPreviousNonWsComment(field.getPrevSibling(), 0);\n    if (fieldPrev instanceof PsiJavaToken && ((PsiJavaToken)fieldPrev).getTokenType() == JavaTokenType.COMMA) {\n      return;\n    }\n\n    // There is a possible case that fields which share the same type declaration are located on different document lines, e.g.:\n    //    int i1,\n    //        i2;\n    // We want to consider only the first declaration then but need to expand its range to all affected lines (up to semicolon).\n    TextRange range = field.getTextRange();\n    PsiElement child = field.getLastChild();\n    boolean needSpecialProcessing = true;\n    if (isSemicolon(child)) {\n      needSpecialProcessing = false;\n    }\n    else if (child instanceof PsiComment) {\n      // There is a possible field definition like below:\n      //   int f; // my comment.\n      // The comment goes into field PSI here, that's why we need to handle it properly.\n      PsiElement prev = getPreviousNonWsComment(child, range.getStartOffset());\n      needSpecialProcessing = prev != null && !isSemicolon(prev);\n    }\n    \n    if (needSpecialProcessing) {\n      for (PsiElement e = field.getNextSibling(); e != null; e = e.getNextSibling()) {\n        if (e instanceof PsiWhiteSpace || e instanceof PsiComment) { // Skip white space and comment\n          continue;\n        }\n        else if (e instanceof PsiJavaToken) {\n          if (((PsiJavaToken)e).getTokenType() == JavaTokenType.COMMA) { // Skip comma\n            continue;\n          }\n          else {\n            break;\n          }\n        }\n        else if (e instanceof PsiField) {\n          PsiElement c = e.getLastChild();\n          if (c != null) {\n            c = getPreviousNonWsComment(c, range.getStartOffset());\n          }\n          // Stop if current field ends by a semicolon.\n          if (c instanceof PsiErrorElement // Incomplete field without trailing semicolon\n              || (c instanceof PsiJavaToken && ((PsiJavaToken)c).getTokenType() == JavaTokenType.SEMICOLON))\n          {\n            range = TextRange.create(range.getStartOffset(), expandToCommentIfPossible(c));\n          }\n          else {\n            continue;\n          }\n        }\n        break;\n      }\n    }\n\n    JavaElementArrangementEntry entry = createNewEntry(field, range, FIELD, field.getName(), true);\n    if (entry == null)\n      return;\n\n    processEntry(entry, field, field.getInitializer());\n    myInfo.onFieldEntryCreated(field, entry);\n\n    List<PsiField> referencedFields = getReferencedFields(field);\n    for (PsiField referencedField : referencedFields) {\n      myInfo.registerFieldInitializationDependency(field, referencedField);\n    }\n  }","commit_id":"1cf61ab41492ba63261bd9698e001add88ee3a9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private List<PsiField> getReferencedFields(@NotNull PsiExpression expression) {\n    final List<PsiField> referencedElements = new ArrayList<PsiField>();\n    expression.accept(new JavaRecursiveElementVisitor() {\n      @Override\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n        PsiElement ref = expression.resolve();\n        if (ref instanceof PsiField) {\n          referencedElements.add((PsiField)ref);\n        }\n      }\n    });\n\n    return referencedElements;\n  }","id":35665,"modified_method":"@NotNull\n  private List<PsiField> getReferencedFields(@NotNull PsiField field) {\n    final List<PsiField> referencedElements = new ArrayList<PsiField>();\n\n    PsiExpression fieldInitializer = field.getInitializer();\n    PsiClass containingClass = field.getContainingClass();\n\n    if (fieldInitializer == null || containingClass == null) {\n      return referencedElements;\n    }\n\n    if (classFields == null) {\n      classFields = ContainerUtil.map2Set(containingClass.getFields(), new Function.Self<PsiField, PsiField>());\n    }\n\n    fieldInitializer.accept(new JavaRecursiveElementVisitor() {\n      @Override\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n        PsiElement ref = expression.resolve();\n        if (ref instanceof PsiField && classFields.contains(ref)) {\n          referencedElements.add((PsiField)ref);\n        }\n      }\n    });\n\n    return referencedElements;\n  }","commit_id":"1cf61ab41492ba63261bd9698e001add88ee3a9d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public ProblemDescriptor[] checkField(@NotNull PsiField field, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    final PsiExpression initializer = field.getInitializer();\n    if (initializer != null) return checkElement(initializer, manager, isOnTheFly);\n\n    if (field instanceof PsiEnumConstant) {\n      return checkElement(((PsiEnumConstant)field).getArgumentList(), manager, isOnTheFly);\n    }\n    return null;\n  }","id":35666,"modified_method":"@Override\n  @Nullable\n  public ProblemDescriptor[] checkField(@NotNull PsiField field, @NotNull InspectionManager manager, boolean isOnTheFly) {\n    List<ProblemDescriptor> result = new ArrayList<ProblemDescriptor>();\n    appendProblems(manager, isOnTheFly, result, field.getInitializer());\n    appendProblems(manager, isOnTheFly, result, field.getModifierList());\n    if (field instanceof PsiEnumConstant) {\n      appendProblems(manager, isOnTheFly, result, ((PsiEnumConstant)field).getArgumentList());\n    }\n    return result.isEmpty() ? null : result.toArray(new ProblemDescriptor[result.size()]);\n  }","commit_id":"0f0f7aa682e993904b4b3d980d559c92e967d9e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isMethodParameterAnnotatedWith(final PsiMethod method,\n                                                       final int idx,\n                                                       @Nullable Collection<PsiMethod> processed,\n                                                       final String annFqn,\n                                                       @Nullable Map<String, Object> annotationAttributeValues,\n                                                       @Nullable final Set<PsiModifierListOwner> nonNlsTargets) {\n    if (processed != null) {\n      if (processed.contains(method)) return false;\n    }\n    else {\n      processed = new THashSet<PsiMethod>();\n    }\n    processed.add(method);\n\n    final PsiParameter[] params = method.getParameterList().getParameters();\n    PsiParameter param;\n    if (idx >= params.length) {\n      if (params.length == 0) {\n        return false;\n      }\n      PsiParameter lastParam = params [params.length-1];\n      if (lastParam.isVarArgs()) {\n        param = lastParam;\n      }\n      else {\n        return false;\n      }\n    }\n    else {\n      param = params[idx];\n    }\n    final PsiAnnotation annotation = AnnotationUtil.findAnnotation(param, annFqn);\n    if (annotation != null) {\n      if (annotationAttributeValues != null) {\n        final PsiAnnotationParameterList parameterList = annotation.getParameterList();\n        final PsiNameValuePair[] attributes = parameterList.getAttributes();\n        for (PsiNameValuePair attribute : attributes) {\n          final String name = attribute.getName();\n          if (annotationAttributeValues.containsKey(name)) {\n            annotationAttributeValues.put(name, attribute.getValue());\n          }\n        }\n      }\n      return true;\n    }\n    if (nonNlsTargets != null) {\n      nonNlsTargets.add(param);\n    }\n\n    final PsiMethod[] superMethods = method.findSuperMethods();\n    for (PsiMethod superMethod : superMethods) {\n      if (isMethodParameterAnnotatedWith(superMethod, idx, processed, annFqn, annotationAttributeValues, null)) return true;\n    }\n\n    return false;\n  }","id":35667,"modified_method":"public static boolean isMethodParameterAnnotatedWith(final PsiMethod method,\n                                                       final int idx,\n                                                       @Nullable Collection<PsiMethod> processed,\n                                                       final String annFqn,\n                                                       @Nullable Map<String, Object> annotationAttributeValues,\n                                                       @Nullable final Set<PsiModifierListOwner> nonNlsTargets) {\n    if (processed != null) {\n      if (processed.contains(method)) return false;\n    }\n    else {\n      processed = new THashSet<PsiMethod>();\n    }\n    processed.add(method);\n\n    final PsiParameter[] params = method.getParameterList().getParameters();\n    PsiParameter param;\n    if (idx >= params.length) {\n      if (params.length == 0) {\n        return false;\n      }\n      PsiParameter lastParam = params [params.length-1];\n      if (lastParam.isVarArgs()) {\n        param = lastParam;\n      }\n      else {\n        return false;\n      }\n    }\n    else {\n      param = params[idx];\n    }\n    final PsiAnnotation annotation = AnnotationUtil.findAnnotation(param, annFqn);\n    if (annotation != null) {\n      return processAnnotationAttributes(annotationAttributeValues, annotation);\n    }\n    if (nonNlsTargets != null) {\n      nonNlsTargets.add(param);\n    }\n\n    final PsiMethod[] superMethods = method.findSuperMethods();\n    for (PsiMethod superMethod : superMethods) {\n      if (isMethodParameterAnnotatedWith(superMethod, idx, processed, annFqn, annotationAttributeValues, null)) return true;\n    }\n\n    return false;\n  }","commit_id":"0f0f7aa682e993904b4b3d980d559c92e967d9e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean mustBePropertyKey(@NotNull Project project,\n                                          @NotNull PsiLiteralExpression expression,\n                                          @NotNull Map<String, Object> annotationAttributeValues) {\n    return isPassedToAnnotatedParam(project, expression, AnnotationUtil.PROPERTY_KEY, annotationAttributeValues, null);\n  }","id":35668,"modified_method":"public static boolean mustBePropertyKey(@NotNull Project project,\n                                          @NotNull PsiLiteralExpression expression,\n                                          @NotNull Map<String, Object> annotationAttributeValues) {\n    final PsiElement parent = expression.getParent();\n    if (parent instanceof PsiVariable) {\n      final PsiAnnotation annotation = AnnotationUtil.findAnnotation((PsiVariable)parent, AnnotationUtil.PROPERTY_KEY);\n      if (annotation != null) {\n        return processAnnotationAttributes(annotationAttributeValues, annotation); \n      }\n    }\n    return isPassedToAnnotatedParam(project, expression, AnnotationUtil.PROPERTY_KEY, annotationAttributeValues, null);\n  }","commit_id":"0f0f7aa682e993904b4b3d980d559c92e967d9e3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void replace(final ReplacementInfo info, ReplaceOptions options) {\n    PsiElement elementToReplace = info.getMatch(0);\n    PsiElement elementParent = elementToReplace.getParent();\n    String replacementToMake = info.getReplacement();\n    PsiElement el = findRealSubstitutionElement(elementToReplace);\n    boolean listContext = isListContext(el);\n\n    if (el instanceof PsiAnnotation && !replacementToMake.isEmpty() && !StringUtil.startsWithChar(replacementToMake, '@')) {\n      replacementToMake = \"@\" + replacementToMake;\n    }\n\n    PsiElement[] statements = ReplacerUtil\n      .createTreeForReplacement(replacementToMake, el instanceof PsiMember && !isSymbolReplacement(el) ?\n                                                   PatternTreeContext.Class :\n                                                   PatternTreeContext.Block, myContext);\n\n    if (el instanceof PsiAnnotation && statements.length == 1) {\n      final PsiElement parent = el.getParent();\n      final PsiElement statement = statements[0];\n      if (statement instanceof PsiDeclarationStatement) {\n        final PsiDeclarationStatement declarationStatement = (PsiDeclarationStatement)statement;\n        final PsiElement firstChild = declarationStatement.getFirstChild();\n        if (firstChild instanceof PsiModifierList) {\n          final PsiModifierList modifierList = (PsiModifierList)firstChild;\n          for (PsiElement child : modifierList.getChildren()) {\n            parent.add(child);\n          }\n        }\n      }\n      el.delete();\n      return;\n    }\n    if (listContext) {\n      if (statements.length > 1) {\n        elementParent.addRangeBefore(statements[0], statements[statements.length - 1], elementToReplace);\n      }\n      else if (statements.length == 1) {\n        PsiElement replacement = getMatchExpr(statements[0], elementToReplace);\n\n        handleModifierList(el, replacement);\n        replacement = handleSymbolReplacement(replacement, el);\n\n        if (replacement instanceof PsiTryStatement) {\n          final PsiTryStatement tryStatement = (PsiTryStatement)replacement;\n          final List<PsiElement> unmatchedElements = el.getUserData(GlobalMatchingVisitor.UNMATCHED_ELEMENTS_KEY);\n          if (unmatchedElements != null) {\n            final PsiElement firstElement = unmatchedElements.get(0);\n            if (firstElement instanceof PsiResourceList) addElementAfterAnchor(tryStatement, firstElement, tryStatement.getFirstChild());\n            final PsiCatchSection[] catches = tryStatement.getCatchSections();\n            final PsiElement anchor = catches.length == 0 ? tryStatement.getTryBlock() : catches[catches.length - 1];\n            for (int i = unmatchedElements.size() - 1; i >= 0; i--) {\n              final PsiElement element = unmatchedElements.get(i);\n              if ((element instanceof PsiCatchSection)) addElementAfterAnchor(tryStatement, element, anchor);\n            }\n            final PsiElement lastElement = unmatchedElements.get(unmatchedElements.size() - 1);\n            if (lastElement instanceof PsiCodeBlock) {\n              final PsiElement finallyKeyword = PsiTreeUtil.skipSiblingsBackward(lastElement, PsiWhiteSpace.class);\n              assert finallyKeyword != null;\n              final PsiElement finallyAnchor = tryStatement.getLastChild();\n              addElementAfterAnchor(tryStatement, lastElement, finallyAnchor);\n              addElementAfterAnchor(tryStatement, finallyKeyword, finallyAnchor);\n            }\n          }\n        }\n\n        try {\n          final PsiElement inserted = elementParent.addBefore(replacement, elementToReplace);\n\n          if (replacement instanceof PsiComment &&\n              (elementParent instanceof PsiIfStatement ||\n               elementParent instanceof PsiLoopStatement\n              )\n            ) {\n            elementParent.addAfter(createSemicolon(replacement), inserted);\n          }\n        }\n        catch (IncorrectOperationException e) {\n          elementToReplace.replace(replacement);\n        }\n      }\n    }\n    else if (statements.length > 0) {\n      PsiElement replacement = ReplacerUtil.copySpacesAndCommentsBefore(elementToReplace, statements, replacementToMake, elementParent);\n\n      replacement = getMatchExpr(replacement, elementToReplace);\n\n      if (replacement instanceof PsiStatement &&\n          !(replacement.getLastChild() instanceof PsiJavaToken) &&\n          !(replacement.getLastChild() instanceof PsiComment)\n        ) {\n        // assert w/o ;\n        final PsiElement prevLastChildInParent = replacement.getLastChild().getPrevSibling();\n\n        if (prevLastChildInParent != null) {\n          elementParent.addRangeBefore(replacement.getFirstChild(), prevLastChildInParent, el);\n        }\n        else {\n          elementParent.addBefore(replacement.getFirstChild(), el);\n        }\n\n        el.getNode().getTreeParent().removeChild(el.getNode());\n      }\n      else {\n        // preserve comments\n        handleModifierList(el, replacement);\n\n        if (replacement instanceof PsiClass) {\n          final PsiStatement[] searchStatements = getCodeBlock().getStatements();\n          if (searchStatements.length > 0 &&\n              searchStatements[0] instanceof PsiDeclarationStatement &&\n              ((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0] instanceof PsiClass\n            ) {\n            final PsiClass replaceClazz = (PsiClass)replacement;\n            final PsiClass queryClazz = (PsiClass)((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0];\n            final PsiClass clazz = (PsiClass)el;\n\n            if (replaceClazz.getExtendsList().getTextLength() == 0 &&\n                queryClazz.getExtendsList().getTextLength() == 0 &&\n                clazz.getExtendsList().getTextLength() != 0\n              ) {\n              replaceClazz.addBefore(clazz.getExtendsList().getPrevSibling(), replaceClazz.getExtendsList()); // whitespace\n              replaceClazz.getExtendsList().addRange(\n                clazz.getExtendsList().getFirstChild(), clazz.getExtendsList().getLastChild()\n              );\n            }\n\n            if (replaceClazz.getImplementsList().getTextLength() == 0 &&\n                queryClazz.getImplementsList().getTextLength() == 0 &&\n                clazz.getImplementsList().getTextLength() != 0\n              ) {\n              replaceClazz.addBefore(clazz.getImplementsList().getPrevSibling(), replaceClazz.getImplementsList()); // whitespace\n              replaceClazz.getImplementsList().addRange(\n                clazz.getImplementsList().getFirstChild(),\n                clazz.getImplementsList().getLastChild()\n              );\n            }\n\n            if (replaceClazz.getTypeParameterList().getTextLength() == 0 &&\n                queryClazz.getTypeParameterList().getTextLength() == 0 &&\n                clazz.getTypeParameterList().getTextLength() != 0\n              ) {\n              // skip < and >\n              replaceClazz.getTypeParameterList().replace(\n                clazz.getTypeParameterList()\n              );\n            }\n          }\n        }\n\n        replacement = handleSymbolReplacement(replacement, el);\n\n        el.replace(replacement);\n      }\n    }\n    else {\n      final PsiElement nextSibling = el.getNextSibling();\n      el.delete();\n      if (nextSibling instanceof PsiWhiteSpace && nextSibling.isValid()) {\n        nextSibling.delete();\n      }\n    }\n\n    if (listContext) {\n      final int matchSize = info.getMatchesCount();\n\n      for (int i = 0; i < matchSize; ++i) {\n        PsiElement matchElement = info.getMatch(i);\n        PsiElement element = findRealSubstitutionElement(matchElement);\n\n        if (element == null) continue;\n        PsiElement firstToDelete = element;\n        PsiElement lastToDelete = element;\n        PsiElement prevSibling = element.getPrevSibling();\n        PsiElement nextSibling = element.getNextSibling();\n\n        if (prevSibling instanceof PsiWhiteSpace) {\n          firstToDelete = prevSibling;\n          prevSibling = prevSibling != null ? prevSibling.getPrevSibling() : null;\n        }\n        else if (prevSibling == null && nextSibling instanceof PsiWhiteSpace) {\n          lastToDelete = nextSibling;\n        }\n\n        if (element instanceof PsiExpression) {\n          final PsiElement parent = element.getParent().getParent();\n          if ((parent instanceof PsiCall ||\n               parent instanceof PsiAnonymousClass\n          ) &&\n              prevSibling instanceof PsiJavaToken &&\n              ((PsiJavaToken)prevSibling).getTokenType() == JavaTokenType.COMMA\n            ) {\n            firstToDelete = prevSibling;\n          }\n        }\n        else if (element instanceof PsiParameter &&\n                 prevSibling instanceof PsiJavaToken &&\n                 ((PsiJavaToken)prevSibling).getTokenType() == JavaTokenType.COMMA\n          ) {\n          firstToDelete = prevSibling;\n        }\n\n        element.getParent().deleteChildRange(firstToDelete, lastToDelete);\n      }\n    }\n  }","id":35669,"modified_method":"public void replace(final ReplacementInfo info, ReplaceOptions options) {\n    PsiElement elementToReplace = info.getMatch(0);\n    if (elementToReplace == null) {\n      return;\n    }\n    final PsiElement elementParent = elementToReplace.getParent();\n    String replacementToMake = info.getReplacement();\n    PsiElement el = findRealSubstitutionElement(elementToReplace);\n    final boolean listContext = isListContext(el);\n\n    if (el instanceof PsiAnnotation && !replacementToMake.isEmpty() && !StringUtil.startsWithChar(replacementToMake, '@')) {\n      replacementToMake = \"@\" + replacementToMake;\n    }\n\n    final PsiElement[] statements = ReplacerUtil\n      .createTreeForReplacement(replacementToMake, el instanceof PsiMember && !isSymbolReplacement(elementToReplace) ?\n                                                   PatternTreeContext.Class :\n                                                   PatternTreeContext.Block, myContext);\n\n    if (el instanceof PsiAnnotation && statements.length == 1) {\n      final PsiElement parent = el.getParent();\n      final PsiElement statement = statements[0];\n      if (statement instanceof PsiDeclarationStatement) {\n        final PsiDeclarationStatement declarationStatement = (PsiDeclarationStatement)statement;\n        final PsiElement firstChild = declarationStatement.getFirstChild();\n        if (firstChild instanceof PsiModifierList) {\n          final PsiModifierList modifierList = (PsiModifierList)firstChild;\n          for (PsiElement child : modifierList.getChildren()) {\n            parent.add(child);\n          }\n        }\n      }\n      el.delete();\n      return;\n    }\n    if (listContext) {\n      if (statements.length > 1) {\n        final PsiElement replacement = elementParent.addRangeBefore(statements[0], statements[statements.length - 1], elementToReplace);\n        handleModifierList(el, replacement);\n      }\n      else if (statements.length == 1) {\n        PsiElement replacement = getMatchExpr(statements[0], elementToReplace);\n\n        handleModifierList(el, replacement);\n        replacement = handleSymbolReplacement(replacement, el);\n\n        if (replacement instanceof PsiTryStatement) {\n          final PsiTryStatement tryStatement = (PsiTryStatement)replacement;\n          final List<PsiElement> unmatchedElements = el.getUserData(GlobalMatchingVisitor.UNMATCHED_ELEMENTS_KEY);\n          if (unmatchedElements != null) {\n            final PsiElement firstElement = unmatchedElements.get(0);\n            if (firstElement instanceof PsiResourceList) addElementAfterAnchor(tryStatement, firstElement, tryStatement.getFirstChild());\n            final PsiCatchSection[] catches = tryStatement.getCatchSections();\n            final PsiElement anchor = catches.length == 0 ? tryStatement.getTryBlock() : catches[catches.length - 1];\n            for (int i = unmatchedElements.size() - 1; i >= 0; i--) {\n              final PsiElement element = unmatchedElements.get(i);\n              if ((element instanceof PsiCatchSection)) addElementAfterAnchor(tryStatement, element, anchor);\n            }\n            final PsiElement lastElement = unmatchedElements.get(unmatchedElements.size() - 1);\n            if (lastElement instanceof PsiCodeBlock) {\n              final PsiElement finallyKeyword = PsiTreeUtil.skipSiblingsBackward(lastElement, PsiWhiteSpace.class);\n              assert finallyKeyword != null;\n              final PsiElement finallyAnchor = tryStatement.getLastChild();\n              addElementAfterAnchor(tryStatement, lastElement, finallyAnchor);\n              addElementAfterAnchor(tryStatement, finallyKeyword, finallyAnchor);\n            }\n          }\n        }\n\n        try {\n          final PsiElement inserted = elementParent.addBefore(replacement, elementToReplace);\n\n          if (replacement instanceof PsiComment &&\n              (elementParent instanceof PsiIfStatement ||\n               elementParent instanceof PsiLoopStatement\n              )\n            ) {\n            elementParent.addAfter(createSemicolon(replacement), inserted);\n          }\n        }\n        catch (IncorrectOperationException e) {\n          elementToReplace.replace(replacement);\n        }\n      }\n    }\n    else if (statements.length > 0) {\n      PsiElement replacement = ReplacerUtil.copySpacesAndCommentsBefore(elementToReplace, statements, replacementToMake, elementParent);\n\n      replacement = getMatchExpr(replacement, elementToReplace);\n\n      if (replacement instanceof PsiStatement &&\n          !(replacement.getLastChild() instanceof PsiJavaToken) &&\n          !(replacement.getLastChild() instanceof PsiComment)\n        ) {\n        // assert w/o ;\n        final PsiElement prevLastChildInParent = replacement.getLastChild().getPrevSibling();\n\n        if (prevLastChildInParent != null) {\n          elementParent.addRangeBefore(replacement.getFirstChild(), prevLastChildInParent, el);\n        }\n        else {\n          elementParent.addBefore(replacement.getFirstChild(), el);\n        }\n\n        el.getNode().getTreeParent().removeChild(el.getNode());\n      }\n      else {\n        // preserve comments\n        handleModifierList(el, replacement);\n\n        if (replacement instanceof PsiClass) {\n          final PsiStatement[] searchStatements = getCodeBlock().getStatements();\n          if (searchStatements.length > 0 &&\n              searchStatements[0] instanceof PsiDeclarationStatement &&\n              ((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0] instanceof PsiClass\n            ) {\n            final PsiClass replaceClazz = (PsiClass)replacement;\n            final PsiClass queryClazz = (PsiClass)((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0];\n            final PsiClass clazz = (PsiClass)el;\n\n            if (replaceClazz.getExtendsList().getTextLength() == 0 &&\n                queryClazz.getExtendsList().getTextLength() == 0 &&\n                clazz.getExtendsList().getTextLength() != 0\n              ) {\n              replaceClazz.addBefore(clazz.getExtendsList().getPrevSibling(), replaceClazz.getExtendsList()); // whitespace\n              replaceClazz.getExtendsList().addRange(\n                clazz.getExtendsList().getFirstChild(), clazz.getExtendsList().getLastChild()\n              );\n            }\n\n            if (replaceClazz.getImplementsList().getTextLength() == 0 &&\n                queryClazz.getImplementsList().getTextLength() == 0 &&\n                clazz.getImplementsList().getTextLength() != 0\n              ) {\n              replaceClazz.addBefore(clazz.getImplementsList().getPrevSibling(), replaceClazz.getImplementsList()); // whitespace\n              replaceClazz.getImplementsList().addRange(\n                clazz.getImplementsList().getFirstChild(),\n                clazz.getImplementsList().getLastChild()\n              );\n            }\n\n            if (replaceClazz.getTypeParameterList().getTextLength() == 0 &&\n                queryClazz.getTypeParameterList().getTextLength() == 0 &&\n                clazz.getTypeParameterList().getTextLength() != 0\n              ) {\n              // skip < and >\n              replaceClazz.getTypeParameterList().replace(\n                clazz.getTypeParameterList()\n              );\n            }\n          }\n        }\n\n        replacement = handleSymbolReplacement(replacement, el);\n\n        el.replace(replacement);\n      }\n    }\n    else {\n      final PsiElement nextSibling = el.getNextSibling();\n      el.delete();\n      if (nextSibling instanceof PsiWhiteSpace && nextSibling.isValid()) {\n        nextSibling.delete();\n      }\n    }\n\n    if (listContext) {\n      final int matchSize = info.getMatchesCount();\n\n      for (int i = 0; i < matchSize; ++i) {\n        PsiElement matchElement = info.getMatch(i);\n        PsiElement element = findRealSubstitutionElement(matchElement);\n\n        if (element == null) continue;\n        PsiElement firstToDelete = element;\n        PsiElement lastToDelete = element;\n        PsiElement prevSibling = element.getPrevSibling();\n        PsiElement nextSibling = element.getNextSibling();\n\n        if (prevSibling instanceof PsiWhiteSpace) {\n          firstToDelete = prevSibling;\n          prevSibling = prevSibling.getPrevSibling();\n        }\n        else if (prevSibling == null && nextSibling instanceof PsiWhiteSpace) {\n          lastToDelete = nextSibling;\n        }\n\n        if (element instanceof PsiExpression) {\n          final PsiElement parent = element.getParent().getParent();\n          if ((parent instanceof PsiCall || parent instanceof PsiAnonymousClass) && PsiUtil.isJavaToken(prevSibling, JavaTokenType.COMMA)) {\n            firstToDelete = prevSibling;\n          }\n        }\n        else if (element instanceof PsiParameter && PsiUtil.isJavaToken(prevSibling, JavaTokenType.COMMA)) {\n          firstToDelete = prevSibling;\n        }\n        else if (element instanceof PsiField) {\n          while (PsiUtil.isJavaToken(nextSibling, JavaTokenType.COMMA)) {\n            lastToDelete = PsiTreeUtil.skipSiblingsForward(nextSibling, PsiWhiteSpace.class);\n            nextSibling = PsiTreeUtil.skipSiblingsForward(lastToDelete, PsiWhiteSpace.class);\n          }\n        }\n\n        element.getParent().deleteChildRange(firstToDelete, lastToDelete);\n      }\n    }\n  }","commit_id":"0761b6dfc31fabf1c310c1e4ed5f34b7c6fe58d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int handleSubstitution(final ParameterInfo info,\n                                MatchResult match,\n                                StringBuilder result,\n                                int offset,\n                                HashMap<String, MatchResult> matchMap) {\n    if (info.getName().equals(match.getName())) {\n      String replacementString = match.getMatchImage();\n      boolean forceAddingNewLine = false;\n\n      if (info.isMethodParameterContext()) {\n        StringBuilder buf = new StringBuilder();\n        handleMethodParameter(buf, info, matchMap);\n        replacementString = buf.toString();\n      }\n      else if (match.getAllSons().size() > 0 && !match.isScopeMatch()) {\n        // compound matches\n        StringBuilder buf = new StringBuilder();\n        MatchResult r = null;\n\n        for (final MatchResult matchResult : match.getAllSons()) {\n          MatchResult previous = r;\n          r = matchResult;\n\n          final PsiElement currentElement = r.getMatch();\n\n          if (buf.length() > 0) {\n            final PsiElement parent = currentElement.getParent();\n            if (info.isStatementContext()) {\n              final PsiElement previousElement = previous.getMatchRef().getElement();\n\n              if (!(previousElement instanceof PsiComment) &&\n                  ( buf.charAt(buf.length() - 1) != '}' ||\n                    previousElement instanceof PsiDeclarationStatement\n                  )\n                ) {\n                buf.append(';');\n              }\n\n              final PsiElement prevSibling = currentElement.getPrevSibling();\n\n              if (prevSibling instanceof PsiWhiteSpace &&\n                  prevSibling.getPrevSibling() == previous.getMatch()\n                ) {\n                // consequent statements matched so preserve whitespacing\n                buf.append(prevSibling.getText());\n              }\n              else {\n                buf.append('\\n');\n              }\n            }\n            else if (info.isArgumentContext()) {\n              buf.append(',');\n            }\n            else if (parent instanceof PsiClass) {\n              final PsiElement prevSibling = PsiTreeUtil.skipSiblingsBackward(currentElement, PsiWhiteSpace.class);\n              if (prevSibling instanceof PsiJavaToken && JavaTokenType.COMMA.equals(((PsiJavaToken)prevSibling).getTokenType())) {\n                buf.append(',');\n              }\n              else {\n                buf.append('\\n');\n              }\n            }\n            else if (parent instanceof PsiReferenceList) {\n              buf.append(',');\n            }\n            else if (parent instanceof PsiPolyadicExpression) {\n              final PsiPolyadicExpression expression = (PsiPolyadicExpression)parent;\n              final PsiJavaToken token = expression.getTokenBeforeOperand(expression.getOperands()[1]);\n              if (token != null) {\n                buf.append(token.getText());\n              }\n            }\n            else {\n              buf.append(' ');\n            }\n          }\n\n          buf.append(r.getMatchImage());\n          removeExtraSemicolonForSingleVarInstanceInMultipleMatch(info, r, buf);\n          forceAddingNewLine = currentElement instanceof PsiComment;\n        }\n\n        replacementString = buf.toString();\n      } else {\n        StringBuilder buf = new StringBuilder();\n        if (info.isStatementContext()) {\n          forceAddingNewLine = match.getMatch() instanceof PsiComment;\n        }\n        buf.append(replacementString);\n        removeExtraSemicolonForSingleVarInstanceInMultipleMatch(info, match, buf);\n        replacementString = buf.toString();\n      }\n\n      offset = Replacer.insertSubstitution(result, offset, info, replacementString);\n      offset = removeExtraSemicolon(info, offset, result, match);\n      if (forceAddingNewLine && info.isStatementContext()) {\n        result.insert(info.getStartIndex() + offset + 1, '\\n');\n        offset ++;\n      }\n    }\n    return offset;\n  }","id":35670,"modified_method":"@Override\n  public int handleSubstitution(final ParameterInfo info,\n                                MatchResult match,\n                                StringBuilder result,\n                                int offset,\n                                HashMap<String, MatchResult> matchMap) {\n    if (info.getName().equals(match.getName())) {\n      String replacementString = match.getMatchImage();\n      boolean forceAddingNewLine = false;\n\n      if (info.isMethodParameterContext()) {\n        StringBuilder buf = new StringBuilder();\n        handleMethodParameter(buf, info, matchMap);\n        replacementString = buf.toString();\n      }\n      else if (match.getAllSons().size() > 0 && !match.isScopeMatch()) {\n        // compound matches\n        StringBuilder buf = new StringBuilder();\n        MatchResult r = null;\n\n        for (final MatchResult matchResult : match.getAllSons()) {\n          MatchResult previous = r;\n          r = matchResult;\n\n          final PsiElement currentElement = r.getMatch();\n\n          if (buf.length() > 0) {\n            final PsiElement parent = currentElement.getParent();\n            if (parent instanceof PsiVariable) {\n              final PsiElement prevSibling = PsiTreeUtil.skipSiblingsBackward(parent, PsiWhiteSpace.class);\n              if (prevSibling instanceof PsiJavaToken && JavaTokenType.COMMA.equals(((PsiJavaToken)prevSibling).getTokenType())) {\n                buf.append(',');\n              }\n            }\n            else if (info.isStatementContext()) {\n              final PsiElement previousElement = previous.getMatchRef().getElement();\n\n              if (!(previousElement instanceof PsiComment) &&\n                  ( buf.charAt(buf.length() - 1) != '}' ||\n                    previousElement instanceof PsiDeclarationStatement\n                  )\n                ) {\n                buf.append(';');\n              }\n\n              final PsiElement prevSibling = currentElement.getPrevSibling();\n\n              if (prevSibling instanceof PsiWhiteSpace &&\n                  prevSibling.getPrevSibling() == previous.getMatch()\n                ) {\n                // consequent statements matched so preserve whitespacing\n                buf.append(prevSibling.getText());\n              }\n              else {\n                buf.append('\\n');\n              }\n            }\n            else if (info.isArgumentContext()) {\n              buf.append(',');\n            }\n            else if (parent instanceof PsiClass) {\n              final PsiElement prevSibling = PsiTreeUtil.skipSiblingsBackward(currentElement, PsiWhiteSpace.class);\n              if (prevSibling instanceof PsiJavaToken && JavaTokenType.COMMA.equals(((PsiJavaToken)prevSibling).getTokenType())) {\n                buf.append(',');\n              }\n              else {\n                buf.append('\\n');\n              }\n            }\n            else if (parent instanceof PsiReferenceList) {\n              buf.append(',');\n            }\n            else if (parent instanceof PsiPolyadicExpression) {\n              final PsiPolyadicExpression expression = (PsiPolyadicExpression)parent;\n              final PsiJavaToken token = expression.getTokenBeforeOperand(expression.getOperands()[1]);\n              if (token != null) {\n                buf.append(token.getText());\n              }\n            }\n            else {\n              buf.append(' ');\n            }\n          }\n\n          buf.append(r.getMatchImage());\n          removeExtraSemicolonForSingleVarInstanceInMultipleMatch(info, r, buf);\n          forceAddingNewLine = currentElement instanceof PsiComment;\n        }\n\n        replacementString = buf.toString();\n      } else {\n        if (info.isStatementContext()) {\n          forceAddingNewLine = match.getMatch() instanceof PsiComment;\n        }\n        StringBuilder buf = new StringBuilder(replacementString);\n        removeExtraSemicolonForSingleVarInstanceInMultipleMatch(info, match, buf);\n        replacementString = buf.toString();\n      }\n\n      offset = Replacer.insertSubstitution(result, offset, info, replacementString);\n      offset = removeExtraSemicolon(info, offset, result, match);\n      if (forceAddingNewLine && info.isStatementContext()) {\n        result.insert(info.getStartIndex() + offset + 1, '\\n');\n        offset ++;\n      }\n    }\n    return offset;\n  }","commit_id":"0761b6dfc31fabf1c310c1e4ed5f34b7c6fe58d7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unwrap(Editor editor, PsiElement element) throws IncorrectOperationException {\n    extractFromBlockOrSingleStatement((PsiStatement)element, element);\n    element.delete();\n  }","id":35671,"modified_method":"@Override\n  protected void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException {\n    context.extractFromBlockOrSingleStatement((PsiStatement)element, element);\n    context.delete(element);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unwrap(Editor editor, PsiElement element) throws IncorrectOperationException {\n    element.delete();\n  }","id":35672,"modified_method":"@Override\n  protected void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException {\n    context.delete(element);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void deleteSelectedElseIf(PsiIfStatement selectedBranch) throws IncorrectOperationException {\n    PsiIfStatement parentIf = (PsiIfStatement)selectedBranch.getParent();\n    PsiStatement childElse = selectedBranch.getElseBranch();\n\n    if (childElse == null) {\n      selectedBranch.delete();\n      return;\n    }\n\n    parentIf.setElseBranch(copyElement(childElse));\n  }","id":35673,"modified_method":"private void deleteSelectedElseIf(PsiIfStatement selectedBranch, Context context) throws IncorrectOperationException {\n    PsiIfStatement parentIf = (PsiIfStatement)selectedBranch.getParent();\n    PsiStatement childElse = selectedBranch.getElseBranch();\n\n    if (childElse == null) {\n      context.delete(selectedBranch);\n      return;\n    }\n\n    context.addElementToExtract(childElse);\n    parentIf.setElseBranch(copyElement(childElse));\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiStatement copyElement(PsiStatement el) throws IncorrectOperationException {\n    // we can not call el.copy() for 'else' since it sets context to parent 'if'. This cause copy to be invalidated\n    // after parent 'if' removal in setElseBranch method.\n\n    PsiManager manager = PsiManager.getInstance(el.getProject());\n    PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n    return factory.createStatementFromText(el.getText(), null);\n  }","id":35674,"modified_method":"private PsiStatement copyElement(PsiStatement e) throws IncorrectOperationException {\n    // we can not call el.copy() for 'else' since it sets context to parent 'if'. This cause copy to be invalidated\n    // after parent 'if' removal in setElseBranch method.\n\n    PsiManager manager = PsiManager.getInstance(e.getProject());\n    PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n    return factory.createStatementFromText(e.getText(), null);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void unwrapElseBranch(PsiStatement branch, PsiElement parent) throws IncorrectOperationException {\n    if (branch instanceof PsiIfStatement) {\n      deleteSelectedElseIf((PsiIfStatement)branch);\n    }\n    else {\n      branch.delete();\n    }\n  }","id":35675,"modified_method":"@Override\n  protected void unwrapElseBranch(PsiStatement branch, PsiElement parent, Context context) throws IncorrectOperationException {\n    if (branch instanceof PsiIfStatement) {\n      deleteSelectedElseIf((PsiIfStatement)branch, context);\n    }\n    else {\n      context.delete(branch);\n    }\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void unwrapElseBranch(PsiStatement branch, PsiElement parent) throws IncorrectOperationException {\n    // if we have 'else if' then we have to extract statements from the 'if' branch\n    if (branch instanceof PsiIfStatement) {\n      branch = ((PsiIfStatement)branch).getThenBranch();\n    }\n\n    parent = findTopmostIfStatement(parent);\n\n    extractFromBlockOrSingleStatement(branch, parent);\n    parent.delete();\n  }","id":35676,"modified_method":"@Override\n  protected void unwrapElseBranch(PsiStatement branch, PsiElement parent, Context context) throws IncorrectOperationException {\n    // if we have 'else if' then we have to extract statements from the 'if' branch\n    if (branch instanceof PsiIfStatement) {\n      branch = ((PsiIfStatement)branch).getThenBranch();\n    }\n\n    parent = findTopmostIfStatement(parent);\n\n    context.extractFromBlockOrSingleStatement(branch, parent);\n    context.delete(parent);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isApplicableTo(PsiElement e) {\n    return isElseBlock(e) || isElseKeyword(e);\n  }","id":35677,"modified_method":"public boolean isApplicableTo(PsiElement e) {\n    return (isElseBlock(e) || isElseKeyword(e)) && isValidConstruct(e);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unwrap(Editor editor, PsiElement element) throws IncorrectOperationException {\n    PsiStatement elseBranch;\n\n    if (isElseKeyword(element)) {\n      elseBranch = ((PsiIfStatement)element.getParent()).getElseBranch();\n      if (elseBranch == null) return;\n    }\n    else {\n      elseBranch = (PsiStatement)element;\n    }\n\n    unwrapElseBranch(elseBranch, element.getParent());\n  }","id":35678,"modified_method":"@Override\n  protected void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException {\n    PsiStatement elseBranch;\n\n    if (isElseKeyword(element)) {\n      elseBranch = ((PsiIfStatement)element.getParent()).getElseBranch();\n    }\n    else {\n      elseBranch = (PsiStatement)element;\n    }\n\n    unwrapElseBranch(elseBranch, element.getParent(), context);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract void unwrapElseBranch(PsiStatement branch, PsiElement parent) throws IncorrectOperationException;","id":35679,"modified_method":"protected abstract void unwrapElseBranch(PsiStatement branch, PsiElement parent, Context context) throws IncorrectOperationException;","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void unwrapInitializer(PsiElement element) throws IncorrectOperationException {\n    PsiStatement init = ((PsiForStatement)element).getInitialization();\n    extractFromBlockOrSingleStatement(init, element);\n  }","id":35680,"modified_method":"private void unwrapInitializer(PsiElement element, Context context) throws IncorrectOperationException {\n    PsiStatement init = ((PsiForStatement)element).getInitialization();\n    context.extractFromBlockOrSingleStatement(init, element);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void unwrapBody(PsiElement element) throws IncorrectOperationException {\n    PsiStatement body = ((PsiLoopStatement)element).getBody();\n    extractFromBlockOrSingleStatement(body, element);\n  }","id":35681,"modified_method":"private void unwrapBody(PsiElement element, Context context) throws IncorrectOperationException {\n    PsiStatement body = ((PsiLoopStatement)element).getBody();\n    context.extractFromBlockOrSingleStatement(body, element);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unwrap(Editor editor, PsiElement element) throws IncorrectOperationException {\n    if (element instanceof PsiForStatement) {\n      unwrapInitializer(element);\n    }\n    unwrapBody(element);\n\n    element.delete();\n  }","id":35682,"modified_method":"@Override\n  protected void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException {\n    if (element instanceof PsiForStatement) {\n      unwrapInitializer(element, context);\n    }\n    unwrapBody(element, context);\n\n    context.delete(element);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unwrap(Editor editor, PsiElement element) throws IncorrectOperationException {\n    PsiStatement then = ((PsiIfStatement)element).getThenBranch();\n    extractFromBlockOrSingleStatement(then, element);\n\n    element.delete();\n  }","id":35683,"modified_method":"@Override\n  protected void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException {\n    PsiStatement then = ((PsiIfStatement)element).getThenBranch();\n    context.extractFromBlockOrSingleStatement(then, element);\n\n    context.delete(element);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unwrap(Editor editor, PsiElement element) throws IncorrectOperationException {\n    PsiCodeBlock body = ((PsiSynchronizedStatement)element).getBody();\n    extractFromCodeBlock(body, element);\n\n    element.delete();\n  }","id":35684,"modified_method":"@Override\n  protected void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException {\n    PsiCodeBlock body = ((PsiSynchronizedStatement)element).getBody();\n    context.extractFromCodeBlock(body, element);\n\n    context.delete(element);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unwrap(Editor editor, PsiElement element) throws IncorrectOperationException {\n    PsiTryStatement trySt = (PsiTryStatement)element;\n\n    extractFromCodeBlock(trySt.getTryBlock(), trySt);\n    extractFromCodeBlock(trySt.getFinallyBlock(), trySt);\n\n    trySt.delete();\n  }","id":35685,"modified_method":"@Override\n  protected void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException {\n    PsiTryStatement trySt = (PsiTryStatement)element;\n\n    context.extractFromCodeBlock(trySt.getTryBlock(), trySt);\n    context.extractFromCodeBlock(trySt.getFinallyBlock(), trySt);\n\n    context.delete(trySt);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void extract(PsiElement first, PsiElement last, PsiElement from) throws IncorrectOperationException {\n    if (first == null)  return;\n\n    // trim leading empty spaces\n    while (first != last && first instanceof PsiWhiteSpace) {\n      first = first.getNextSibling();\n    }\n\n    // trim trailing empty spaces\n    while (last != first && last instanceof PsiWhiteSpace) {\n      last = last.getPrevSibling();\n    }\n\n    // nothing to extract\n    if (first == last && last instanceof PsiWhiteSpace) return;\n\n    from.getParent().addRangeBefore(first, last, from);\n  }","id":35686,"modified_method":"protected abstract void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException;","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unwrap(Editor editor, PsiElement element) throws IncorrectOperationException {\n    PsiStatement body = ((PsiLoopStatement)element).getBody();\n    extractFromBlockOrSingleStatement(body, element);\n\n    element.delete();\n  }","id":35687,"modified_method":"@Override\n  protected void doUnwrap(PsiElement element, Context context) throws IncorrectOperationException {\n    PsiStatement body = ((PsiLoopStatement)element).getBody();\n\n    context.extractFromBlockOrSingleStatement(body, element);\n    context.delete(element);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void showPopup(final List<AnAction> options, Editor editor) {\n    final MyScopeHighlighter highlighter = new MyScopeHighlighter(editor);\n\n    DefaultListModel m = new DefaultListModel();\n    for (AnAction a : options) {\n      m.addElement(((MyUnwrapAction)a).getName());\n    }\n\n    final JList list = new JList(m);\n    list.setVisibleRowCount(options.size());\n\n    list.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        int index = list.getSelectedIndex();\n        if (index < 0) return;\n\n        MyUnwrapAction a = (MyUnwrapAction)options.get(index);\n        highlighter.highlight(a.getElement());\n      }\n    });\n\n    PopupChooserBuilder builder = JBPopupFactory.getInstance().createListPopupBuilder(list);\n    builder\n      .setTitle(CodeInsightBundle.message(\"unwrap.popup.title\"))\n      .setMovable(false)\n      .setResizable(false)\n      .setRequestFocus(true)\n      .setItemChoosenCallback(new Runnable() {\n        public void run() {\n          MyUnwrapAction a = (MyUnwrapAction)options.get(list.getSelectedIndex());\n          a.actionPerformed(null);\n        }\n      })\n      .addListener(new JBPopupAdapter() {\n        @Override\n        public void onClosed(JBPopup popup) {\n          highlighter.dropHighlight();\n        }\n      });\n\n    JBPopup popup = builder.createPopup();\n    popup.showInBestPositionFor(editor);\n  }","id":35688,"modified_method":"private void showPopup(final List<AnAction> options, Editor editor) {\n    final MyScopeHighlighter highlighter = new MyScopeHighlighter(editor);\n\n    DefaultListModel m = new DefaultListModel();\n    for (AnAction a : options) {\n      m.addElement(((MyUnwrapAction)a).getName());\n    }\n\n    final JList list = new JList(m);\n    list.setVisibleRowCount(options.size());\n\n    list.addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e) {\n        int index = list.getSelectedIndex();\n        if (index < 0) return;\n\n        MyUnwrapAction a = (MyUnwrapAction)options.get(index);\n\n        List<TextRange> toExtract = new ArrayList<TextRange>();\n        TextRange wholeRange = a.collectTextRanges(toExtract);\n        highlighter.highlight(wholeRange, toExtract);\n      }\n    });\n\n    PopupChooserBuilder builder = JBPopupFactory.getInstance().createListPopupBuilder(list);\n    builder\n      .setTitle(CodeInsightBundle.message(\"unwrap.popup.title\"))\n      .setMovable(false)\n      .setResizable(false)\n      .setRequestFocus(true)\n      .setItemChoosenCallback(new Runnable() {\n        public void run() {\n          MyUnwrapAction a = (MyUnwrapAction)options.get(list.getSelectedIndex());\n          a.actionPerformed(null);\n        }\n      })\n      .addListener(new JBPopupAdapter() {\n        @Override\n        public void onClosed(JBPopup popup) {\n          highlighter.dropHighlight();\n        }\n      });\n\n    JBPopup popup = builder.createPopup();\n    popup.showInBestPositionFor(editor);\n  }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TextAttributes getTestAttributes() {\n      EditorColorsManager manager = EditorColorsManager.getInstance();\n      return manager.getGlobalScheme().getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES);\n    }","id":35689,"modified_method":"private TextAttributes getTestAttributesForExtract() {\n      EditorColorsManager manager = EditorColorsManager.getInstance();\n      return manager.getGlobalScheme().getAttributes(EditorColors.SEARCH_RESULT_ATTRIBUTES);\n    }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dropHighlight() {\n      if (myPreviousHighliter == null) return;\n      myEditor.getMarkupModel().removeHighlighter(myPreviousHighliter);\n    }","id":35690,"modified_method":"public void dropHighlight() {\n      for (RangeHighlighter h : myActiveHighliters) {\n        myEditor.getMarkupModel().removeHighlighter(h);\n      }\n      myActiveHighliters.clear();\n    }","commit_id":"734b7fe3984664e4a63cb2829fbeac7f4a8f98d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doReplacement(final ReplacementInfoImpl info,\n                             final PsiElement elementToReplace,\n                             final String replacementToMake,\n                             final PsiElement elementParent) {\n    boolean listContext = false;\n\n    try {\n      if (context == null) context = new ReplacementContext(options, project);\n      context.replacementInfo = info;\n\n      PsiElement el = findRealSubstitutionElement(elementToReplace);\n      listContext = isListContext(el);\n\n      PsiElement[] statements = MatcherImplUtil.createTreeFromText(\n        replacementToMake,\n        el instanceof PsiMember && !isSymbolReplacement(el, context)?\n        MatcherImplUtil.TreeContext.Class :\n        MatcherImplUtil.TreeContext.Block,\n        options.getMatchOptions().getFileType(),\n        project\n      );\n\n\n      if (listContext) {\n        if (statements.length > 1) {\n          elementParent.addRangeBefore(statements[0],statements[statements.length-1],elementToReplace);\n        } else if (statements.length==1) {\n          PsiElement replacement = getMatchExpr(statements[0], elementToReplace);\n\n          handleModifierList(el, replacement, context);\n          replacement = handleSymbolReplacemenent(replacement, el, context);\n\n          if (replacement instanceof PsiTryStatement) {\n            final List<PsiCodeBlock> unmatchedCatchBlocks = el.getUserData(MatcherImplUtil.UNMATCHED_CATCH_BLOCK_CONTENT_VAR_KEY);\n            final List<PsiParameter> unmatchedCatchParams = el.getUserData(MatcherImplUtil.UNMATCHED_CATCH_PARAM_CONTENT_VAR_KEY);\n            final PsiCatchSection[] catches = ((PsiTryStatement)replacement).getCatchSections();\n\n            if (unmatchedCatchBlocks!=null && unmatchedCatchParams!=null) {\n              for(int i = unmatchedCatchBlocks.size()-1; i >= 0; --i) {\n                final PsiParameter parameter = unmatchedCatchParams.get(i);\n                final PsiCatchSection catchSection = PsiManager.getInstance(project).getElementFactory().createCatchSection(\n                  (PsiClassType)parameter.getType(),\n                  parameter.getName(),\n                  null\n                );\n\n                catchSection.getCatchBlock().replace(\n                  unmatchedCatchBlocks.get(i)\n                );\n                replacement.addAfter(\n                  catchSection, catches[catches.length-1]\n                );\n                replacement.addBefore(createWhiteSpace(replacement), replacement.getLastChild());\n              }\n            }\n          }\n\n          final PsiElement inserted = elementParent.addBefore(replacement,elementToReplace);\n\n          if (replacement instanceof PsiComment &&\n               ( elementParent instanceof PsiIfStatement ||\n                 elementParent instanceof PsiLoopStatement\n               )\n              ) {\n            elementParent.addAfter(createSemicolon(replacement),inserted);\n          }\n        }\n      } else if (statements.length > 0) {\n        int i = 0;\n        while( true ) {    // if it goes out of bounds then deep error happens\n          if (!(statements[i] instanceof PsiComment ||\n                statements[i] instanceof PsiWhiteSpace\n          )\n            ) {\n            break;\n          }\n          ++i;\n        }\n\n        if (i != 0) {\n          elementParent.addRangeBefore(statements[0],statements[i-1],el);\n        }\n        PsiElement replacement = getMatchExpr(statements[i], elementToReplace);\n\n        if (replacement instanceof PsiStatement &&\n            !(replacement.getLastChild() instanceof PsiJavaToken)\n           ) {\n          // assert w/o ;\n          elementParent.addRangeBefore(replacement.getFirstChild(),replacement.getLastChild().getPrevSibling(),el);\n          el.delete();\n        } else {\n          // preserve comments\n          handleModifierList(el, replacement, context);\n\n          if (replacement instanceof PsiClass) {\n            // modifier list\n            final PsiStatement[] searchStatements = context.getCodeBlock().getStatements();\n            if (searchStatements.length > 0 &&\n                searchStatements[0] instanceof PsiDeclarationStatement &&\n                ((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0] instanceof PsiClass\n               ) {\n              final PsiClass replaceClazz = (PsiClass)replacement;\n              final PsiClass queryClazz = (PsiClass)((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0];\n              final PsiClass clazz = (PsiClass)el;\n\n              if (replaceClazz.getExtendsList().getTextLength() == 0 &&\n                  queryClazz.getExtendsList().getTextLength() == 0 &&\n                  clazz.getExtendsList().getTextLength() != 0\n                  ) {\n                replaceClazz.addBefore(clazz.getExtendsList().getPrevSibling(),replaceClazz.getExtendsList()); // whitespace\n                replaceClazz.getExtendsList().addRange(\n                  clazz.getExtendsList().getFirstChild(),clazz.getExtendsList().getLastChild()\n                );\n              }\n\n              if (replaceClazz.getImplementsList().getTextLength() == 0 &&\n                  queryClazz.getImplementsList().getTextLength() == 0 &&\n                  clazz.getImplementsList().getTextLength() != 0\n                  ) {\n                replaceClazz.addBefore(clazz.getImplementsList().getPrevSibling(),replaceClazz.getImplementsList()); // whitespace\n                replaceClazz.getImplementsList().addRange(\n                  clazz.getImplementsList().getFirstChild(),\n                  clazz.getImplementsList().getLastChild()\n                );\n              }\n\n              if (replaceClazz.getTypeParameterList().getTextLength() == 0 &&\n                  queryClazz.getTypeParameterList().getTextLength() == 0 &&\n                  clazz.getTypeParameterList().getTextLength() != 0\n                  ) {\n                // skip < and >\n                replaceClazz.getTypeParameterList().replace(\n                  clazz.getTypeParameterList()\n                );\n              }\n            }\n          }\n\n          replacement = handleSymbolReplacemenent(replacement, el, context);\n\n          el.replace(replacement);\n        }\n      } else {\n        final PsiElement nextSibling = el.getNextSibling();\n        el.delete();\n        if(nextSibling.isValid()){\n          if (nextSibling instanceof PsiWhiteSpace) {\n            nextSibling.delete();\n          }\n        }\n      }\n\n    } catch(IncorrectOperationException ex) {\n      ex.printStackTrace();\n    }\n\n    if (listContext) {\n      for (SmartPsiElementPointer aMatchesPtrList : info.matchesPtrList) {\n        try {\n          PsiElement element = findRealSubstitutionElement(\n            aMatchesPtrList.getElement()\n          );\n\n          PsiElement firstToDelete = element;\n          PsiElement lastToDelete = element;\n          PsiElement prevSibling = element.getPrevSibling();\n          PsiElement nextSibling = element.getNextSibling();\n\n          if (prevSibling instanceof PsiWhiteSpace) {\n            firstToDelete = prevSibling;\n            prevSibling = prevSibling != null ? prevSibling.getPrevSibling(): null;\n          } else if (prevSibling == null && nextSibling instanceof PsiWhiteSpace) {\n            lastToDelete = nextSibling;\n          }\n\n          if (element instanceof PsiExpression) {\n            final PsiElement parent = element.getParent().getParent();\n            if ((parent instanceof PsiCall ||\n                 parent instanceof PsiAnonymousClass\n                ) &&\n                prevSibling instanceof PsiJavaToken &&\n                ((PsiJavaToken)prevSibling).getTokenType() == ElementType.COMMA\n               ) {\n              firstToDelete = prevSibling;\n            }\n          }\n\n          element.getParent().deleteChildRange(firstToDelete,lastToDelete);\n        }\n        catch (IncorrectOperationException ex) {\n          ex.printStackTrace();\n        }\n      }\n    }\n  }","id":35691,"modified_method":"private void doReplacement(final ReplacementInfoImpl info,\n                             final PsiElement elementToReplace,\n                             final String replacementToMake,\n                             final PsiElement elementParent) {\n    boolean listContext = false;\n\n    try {\n      if (context == null) context = new ReplacementContext(options, project);\n      context.replacementInfo = info;\n\n      PsiElement el = findRealSubstitutionElement(elementToReplace);\n      listContext = isListContext(el);\n\n      PsiElement[] statements = MatcherImplUtil.createTreeFromText(\n        replacementToMake,\n        el instanceof PsiMember && !isSymbolReplacement(el, context)?\n        MatcherImplUtil.TreeContext.Class :\n        MatcherImplUtil.TreeContext.Block,\n        options.getMatchOptions().getFileType(),\n        project\n      );\n\n\n      if (listContext) {\n        if (statements.length > 1) {\n          elementParent.addRangeBefore(statements[0],statements[statements.length-1],elementToReplace);\n        } else if (statements.length==1) {\n          PsiElement replacement = getMatchExpr(statements[0], elementToReplace);\n\n          handleModifierList(el, replacement, context);\n          replacement = handleSymbolReplacemenent(replacement, el, context);\n\n          if (replacement instanceof PsiTryStatement) {\n            final List<PsiCodeBlock> unmatchedCatchBlocks = el.getUserData(MatcherImplUtil.UNMATCHED_CATCH_BLOCK_CONTENT_VAR_KEY);\n            final List<PsiParameter> unmatchedCatchParams = el.getUserData(MatcherImplUtil.UNMATCHED_CATCH_PARAM_CONTENT_VAR_KEY);\n            final PsiCatchSection[] catches = ((PsiTryStatement)replacement).getCatchSections();\n\n            if (unmatchedCatchBlocks!=null && unmatchedCatchParams!=null) {\n              for(int i = unmatchedCatchBlocks.size()-1; i >= 0; --i) {\n                final PsiParameter parameter = unmatchedCatchParams.get(i);\n                final PsiCatchSection catchSection = PsiManager.getInstance(project).getElementFactory().createCatchSection(\n                  (PsiClassType)parameter.getType(),\n                  parameter.getName(),\n                  null\n                );\n\n                catchSection.getCatchBlock().replace(\n                  unmatchedCatchBlocks.get(i)\n                );\n                replacement.addAfter(\n                  catchSection, catches[catches.length-1]\n                );\n                replacement.addBefore(createWhiteSpace(replacement), replacement.getLastChild());\n              }\n            }\n          }\n\n          final PsiElement inserted = elementParent.addBefore(replacement,elementToReplace);\n\n          if (replacement instanceof PsiComment &&\n               ( elementParent instanceof PsiIfStatement ||\n                 elementParent instanceof PsiLoopStatement\n               )\n              ) {\n            elementParent.addAfter(createSemicolon(replacement),inserted);\n          }\n        }\n      } else if (statements.length > 0) {\n        int i = 0;\n        while( true ) {    // if it goes out of bounds then deep error happens\n          if (!(statements[i] instanceof PsiComment ||\n                statements[i] instanceof PsiWhiteSpace\n          )\n            ) {\n            break;\n          }\n          ++i;\n        }\n\n        if (i != 0) {\n          elementParent.addRangeBefore(statements[0],statements[i-1],el);\n        }\n        PsiElement replacement = getMatchExpr(statements[i], elementToReplace);\n\n        if (replacement instanceof PsiStatement &&\n            !(replacement.getLastChild() instanceof PsiJavaToken)\n           ) {\n          // assert w/o ;\n          final PsiElement prevLastChildInParent = replacement.getLastChild().getPrevSibling();\n\n          if (prevLastChildInParent != null) {\n            elementParent.addRangeBefore(replacement.getFirstChild(), prevLastChildInParent,el);\n          } else {\n            elementParent.addBefore(replacement.getFirstChild(), el);\n          }\n\n          el.delete();\n        } else {\n          // preserve comments\n          handleModifierList(el, replacement, context);\n\n          if (replacement instanceof PsiClass) {\n            // modifier list\n            final PsiStatement[] searchStatements = context.getCodeBlock().getStatements();\n            if (searchStatements.length > 0 &&\n                searchStatements[0] instanceof PsiDeclarationStatement &&\n                ((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0] instanceof PsiClass\n               ) {\n              final PsiClass replaceClazz = (PsiClass)replacement;\n              final PsiClass queryClazz = (PsiClass)((PsiDeclarationStatement)searchStatements[0]).getDeclaredElements()[0];\n              final PsiClass clazz = (PsiClass)el;\n\n              if (replaceClazz.getExtendsList().getTextLength() == 0 &&\n                  queryClazz.getExtendsList().getTextLength() == 0 &&\n                  clazz.getExtendsList().getTextLength() != 0\n                  ) {\n                replaceClazz.addBefore(clazz.getExtendsList().getPrevSibling(),replaceClazz.getExtendsList()); // whitespace\n                replaceClazz.getExtendsList().addRange(\n                  clazz.getExtendsList().getFirstChild(),clazz.getExtendsList().getLastChild()\n                );\n              }\n\n              if (replaceClazz.getImplementsList().getTextLength() == 0 &&\n                  queryClazz.getImplementsList().getTextLength() == 0 &&\n                  clazz.getImplementsList().getTextLength() != 0\n                  ) {\n                replaceClazz.addBefore(clazz.getImplementsList().getPrevSibling(),replaceClazz.getImplementsList()); // whitespace\n                replaceClazz.getImplementsList().addRange(\n                  clazz.getImplementsList().getFirstChild(),\n                  clazz.getImplementsList().getLastChild()\n                );\n              }\n\n              if (replaceClazz.getTypeParameterList().getTextLength() == 0 &&\n                  queryClazz.getTypeParameterList().getTextLength() == 0 &&\n                  clazz.getTypeParameterList().getTextLength() != 0\n                  ) {\n                // skip < and >\n                replaceClazz.getTypeParameterList().replace(\n                  clazz.getTypeParameterList()\n                );\n              }\n            }\n          }\n\n          replacement = handleSymbolReplacemenent(replacement, el, context);\n\n          el.replace(replacement);\n        }\n      } else {\n        final PsiElement nextSibling = el.getNextSibling();\n        el.delete();\n        if(nextSibling.isValid()){\n          if (nextSibling instanceof PsiWhiteSpace) {\n            nextSibling.delete();\n          }\n        }\n      }\n\n    } catch(IncorrectOperationException ex) {\n      ex.printStackTrace();\n    }\n\n    if (listContext) {\n      for (SmartPsiElementPointer aMatchesPtrList : info.matchesPtrList) {\n        try {\n          PsiElement element = findRealSubstitutionElement(\n            aMatchesPtrList.getElement()\n          );\n\n          PsiElement firstToDelete = element;\n          PsiElement lastToDelete = element;\n          PsiElement prevSibling = element.getPrevSibling();\n          PsiElement nextSibling = element.getNextSibling();\n\n          if (prevSibling instanceof PsiWhiteSpace) {\n            firstToDelete = prevSibling;\n            prevSibling = prevSibling != null ? prevSibling.getPrevSibling(): null;\n          } else if (prevSibling == null && nextSibling instanceof PsiWhiteSpace) {\n            lastToDelete = nextSibling;\n          }\n\n          if (element instanceof PsiExpression) {\n            final PsiElement parent = element.getParent().getParent();\n            if ((parent instanceof PsiCall ||\n                 parent instanceof PsiAnonymousClass\n                ) &&\n                prevSibling instanceof PsiJavaToken &&\n                ((PsiJavaToken)prevSibling).getTokenType() == ElementType.COMMA\n               ) {\n              firstToDelete = prevSibling;\n            }\n          }\n\n          element.getParent().deleteChildRange(firstToDelete,lastToDelete);\n        }\n        catch (IncorrectOperationException ex) {\n          ex.printStackTrace();\n        }\n      }\n    }\n  }","commit_id":"4ec2840e89e6cbdd8bd0d724e8ebd237a7a94de3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void replaceStatementWithUnwrapping(\n      PsiStatement branch, PsiIfStatement statement)\n      throws IncorrectOperationException {\n      if (branch instanceof PsiBlockStatement &&\n          !(statement.getParent() instanceof PsiIfStatement)) {\n        final PsiCodeBlock parentBlock =\n          PsiTreeUtil.getParentOfType(branch, PsiCodeBlock.class);\n        if (parentBlock == null) {\n          final String elseText = branch.getText();\n          replaceStatement(statement, elseText);\n          return;\n        }\n        final PsiCodeBlock block =\n          ((PsiBlockStatement)branch).getCodeBlock();\n        final boolean hasConflicts =\n          VariableSearchUtils.containsConflictingDeclarations(\n            block, parentBlock);\n        if (hasConflicts) {\n          final String elseText = branch.getText();\n          replaceStatement(statement, elseText);\n        }\n        else {\n          final PsiElement containingElement = statement.getParent();\n          final PsiStatement[] statements = block.getStatements();\n          if (statements.length > 0) {\n            assert containingElement != null;\n            final PsiElement added =\n              containingElement.addRangeBefore(statements[0],\n                                               statements[statements.length - 1], statement);\n            final Project project = statement.getProject();\n            final CodeStyleManager codeStyleManager =\n              CodeStyleManager.getInstance(project);\n            codeStyleManager.reformat(added);\n          }\n          statement.delete();\n        }\n      }\n      else {\n        final String elseText = branch.getText();\n        replaceStatement(statement, elseText);\n      }\n    }","id":35692,"modified_method":"private static void replaceStatementWithUnwrapping(\n      PsiStatement branch, PsiIfStatement statement)\n      throws IncorrectOperationException {\n      if (branch instanceof PsiBlockStatement &&\n          !(statement.getParent() instanceof PsiIfStatement)) {\n        final PsiCodeBlock parentBlock =\n          PsiTreeUtil.getParentOfType(branch, PsiCodeBlock.class);\n        if (parentBlock == null) {\n          final String elseText = branch.getText();\n          replaceStatement(statement, elseText);\n          return;\n        }\n        final PsiCodeBlock block =\n          ((PsiBlockStatement)branch).getCodeBlock();\n        final boolean hasConflicts =\n          VariableSearchUtils.containsConflictingDeclarations(\n            block, parentBlock);\n        if (hasConflicts) {\n          final String elseText = branch.getText();\n          replaceStatement(statement, elseText);\n        }\n        else {\n          final PsiElement containingElement = statement.getParent();\n          final PsiStatement[] statements = block.getStatements();\n          if (statements.length > 0) {\n            assert containingElement != null;\n            final PsiJavaToken lBrace = block.getLBrace();\n            final PsiJavaToken rBrace = block.getRBrace();\n            PsiElement added = null;\n            if (lBrace != null && rBrace != null) {\n              final PsiElement firstNonBrace = lBrace.getNextSibling();\n              final PsiElement lastNonBrace = rBrace.getPrevSibling();\n              if (firstNonBrace != null && lastNonBrace != null) {\n                added = containingElement.addRangeBefore(firstNonBrace, lastNonBrace, statement);\n              }\n            }\n            if (added == null) {\n              added = containingElement.addRangeBefore(statements[0],\n                                                       statements[statements.length - 1], statement);\n            }\n            final Project project = statement.getProject();\n            final CodeStyleManager codeStyleManager =\n              CodeStyleManager.getInstance(project);\n            codeStyleManager.reformat(added);\n          }\n          statement.delete();\n        }\n      }\n      else {\n        final String elseText = branch.getText();\n        replaceStatement(statement, elseText);\n      }\n    }","commit_id":"17d8a64c87a4c2e7af6df910d0796975e6a48b4d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static ExtractedData extractLightMethodObject(final Project project,\n                                                       final PsiFile file,\n                                                       @NotNull final PsiCodeFragment fragment,\n                                                       final String methodName) throws PrepareFailedException {\n    final PsiElement[] elements = fragment.getChildren();\n    if (elements.length == 0) {\n      return null;\n    }\n\n    final PsiFile copy = PsiFileFactory.getInstance(project)\n      .createFileFromText(file.getName(), file.getFileType(), file.getText(), file.getModificationStamp(), false);\n\n    final PsiElement originalContext = fragment.getContext();\n    if (originalContext == null) {\n      return null;\n    }\n    final TextRange range = originalContext.getTextRange();\n    final PsiElement originalAnchor =\n      CodeInsightUtil.findElementInRange(copy, range.getStartOffset(), range.getEndOffset(), originalContext.getClass());\n    //todo before this or super, not found etc\n    final PsiElement anchor = RefactoringUtil.getParentStatement(originalAnchor, false);\n    final PsiElement[] elementsCopy = new PsiElement[elements.length];\n    final PsiElement container = anchor.getParent();\n    elementsCopy[0] = container.addRangeBefore(elements[0], elements[elements.length - 1], anchor);\n    for (int i = 1; i < elements.length; i++) {\n      elementsCopy[i] = elementsCopy[i - 1].getNextSibling();\n    }\n\n    final int start = elementsCopy[0].getTextRange().getStartOffset();\n\n    final ControlFlow controlFlow;\n    try {\n      controlFlow = ControlFlowFactory.getInstance(project).getControlFlow(container, LocalsOrMyInstanceFieldsControlFlowPolicy.getInstance());\n    }\n    catch (AnalysisCanceledException e) {\n      return null;\n    }\n\n    List<PsiVariable> variables = ControlFlowUtil.getUsedVariables(controlFlow,\n                                                                   controlFlow.getStartOffset(elementsCopy[0]),\n                                                                   controlFlow.getEndOffset(elementsCopy[elementsCopy.length - 1]));\n\n    variables = ContainerUtil.filter(variables, new Condition<PsiVariable>() {\n      @Override\n      public boolean value(PsiVariable variable) {\n        final PsiElement variableScope = variable instanceof PsiParameter ? ((PsiParameter)variable).getDeclarationScope()\n                                                                          : PsiTreeUtil.getParentOfType(variable, PsiCodeBlock.class, PsiForStatement.class);\n        return variableScope != null && PsiTreeUtil.isAncestor(variableScope, elementsCopy[elementsCopy.length - 1], false);\n      }\n    });\n\n\n    final String outputVariables = StringUtil.join(variables, new Function<PsiVariable, String>() {\n                                          @Override\n                                          public String fun(PsiVariable variable) {\n                                            return \"\\\"variable: \\\" + \" + variable.getName();\n                                          }\n                                        }, \" +\");\n    PsiStatement outStatement = JavaPsiFacade.getElementFactory(project).createStatementFromText(\"System.out.println(\" + outputVariables + \");\", anchor);\n    outStatement = (PsiStatement)container.addAfter(outStatement, elementsCopy[elementsCopy.length - 1]);\n\n    final ExtractMethodObjectProcessor extractMethodObjectProcessor = new ExtractMethodObjectProcessor(project, null, elementsCopy, \"\") {\n      @Override\n      protected AbstractExtractDialog createExtractMethodObjectDialog(MyExtractMethodProcessor processor) {\n        return new LightExtractMethodObjectDialog(this, methodName);\n      }\n    };\n    extractMethodObjectProcessor.getExtractProcessor().setShowErrorDialogs(false);\n\n    final ExtractMethodObjectProcessor.MyExtractMethodProcessor extractProcessor = extractMethodObjectProcessor.getExtractProcessor();\n    if (extractProcessor.prepare()) {\n      if (extractProcessor.showDialog()) {\n        try {\n          extractProcessor.doExtract();\n          final UsageInfo[] usages = extractMethodObjectProcessor.findUsages();\n          extractMethodObjectProcessor.performRefactoring(usages);\n          extractMethodObjectProcessor.runChangeSignature();\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n        if (extractMethodObjectProcessor.isCreateInnerClass()) {\n          extractMethodObjectProcessor.changeInstanceAccess(project);\n        }\n        final PsiElement method = extractMethodObjectProcessor.getMethod();\n        LOG.assertTrue(method != null);\n        method.delete();\n      }\n    } else {\n      return null;\n    }\n\n    final String generatedCall = copy.getText().substring(start, outStatement.getTextOffset());\n    return new ExtractedData(generatedCall,\n                             (PsiClass)CodeStyleManager.getInstance(project).reformat(extractMethodObjectProcessor.getInnerClass()),\n                             originalAnchor);\n  }","id":35693,"modified_method":"@Nullable\n  public static ExtractedData extractLightMethodObject(final Project project,\n                                                       final PsiFile file,\n                                                       @NotNull final PsiCodeFragment fragment,\n                                                       final String methodName) throws PrepareFailedException {\n    final PsiElement[] elements = CodeInsightUtil.findStatementsInRange(fragment, 0, fragment.getTextLength());\n    if (elements.length == 0) {\n      return null;\n    }\n\n    final PsiFile copy = PsiFileFactory.getInstance(project)\n      .createFileFromText(file.getName(), file.getFileType(), file.getText(), file.getModificationStamp(), false);\n\n    final PsiElement originalContext = fragment.getContext();\n    if (originalContext == null) {\n      return null;\n    }\n    final TextRange range = originalContext.getTextRange();\n    final PsiElement originalAnchor =\n      CodeInsightUtil.findElementInRange(copy, range.getStartOffset(), range.getEndOffset(), originalContext.getClass());\n    //todo before this or super, not found etc\n    final PsiElement anchor = RefactoringUtil.getParentStatement(originalAnchor, false);\n    final PsiElement container = anchor.getParent();\n    final PsiElement firstElementCopy = container.addRangeBefore(elements[0], elements[elements.length - 1], anchor);\n    final PsiElement[] elementsCopy = CodeInsightUtil.findStatementsInRange(copy,\n                                                                            firstElementCopy.getTextRange().getStartOffset(),\n                                                                            anchor.getTextRange().getStartOffset());\n\n    final int start = elementsCopy[0].getTextRange().getStartOffset();\n\n    final ControlFlow controlFlow;\n    try {\n      controlFlow = ControlFlowFactory.getInstance(project).getControlFlow(container, LocalsOrMyInstanceFieldsControlFlowPolicy.getInstance());\n    }\n    catch (AnalysisCanceledException e) {\n      return null;\n    }\n\n    List<PsiVariable> variables = ControlFlowUtil.getUsedVariables(controlFlow,\n                                                                   controlFlow.getStartOffset(elementsCopy[0]),\n                                                                   controlFlow.getEndOffset(elementsCopy[elementsCopy.length - 1]));\n\n    variables = ContainerUtil.filter(variables, new Condition<PsiVariable>() {\n      @Override\n      public boolean value(PsiVariable variable) {\n        final PsiElement variableScope = variable instanceof PsiParameter ? ((PsiParameter)variable).getDeclarationScope()\n                                                                          : PsiTreeUtil.getParentOfType(variable, PsiCodeBlock.class, PsiForStatement.class);\n        return variableScope != null && PsiTreeUtil.isAncestor(variableScope, elementsCopy[elementsCopy.length - 1], false);\n      }\n    });\n\n\n    final String outputVariables = StringUtil.join(variables, new Function<PsiVariable, String>() {\n                                          @Override\n                                          public String fun(PsiVariable variable) {\n                                            return \"\\\"variable: \\\" + \" + variable.getName();\n                                          }\n                                        }, \" +\");\n    PsiStatement outStatement = JavaPsiFacade.getElementFactory(project).createStatementFromText(\"System.out.println(\" + outputVariables + \");\", anchor);\n    outStatement = (PsiStatement)container.addAfter(outStatement, elementsCopy[elementsCopy.length - 1]);\n\n    final ExtractMethodObjectProcessor extractMethodObjectProcessor = new ExtractMethodObjectProcessor(project, null, elementsCopy, \"\") {\n      @Override\n      protected AbstractExtractDialog createExtractMethodObjectDialog(MyExtractMethodProcessor processor) {\n        return new LightExtractMethodObjectDialog(this, methodName);\n      }\n    };\n    extractMethodObjectProcessor.getExtractProcessor().setShowErrorDialogs(false);\n\n    final ExtractMethodObjectProcessor.MyExtractMethodProcessor extractProcessor = extractMethodObjectProcessor.getExtractProcessor();\n    if (extractProcessor.prepare()) {\n      if (extractProcessor.showDialog()) {\n        try {\n          extractProcessor.doExtract();\n          final UsageInfo[] usages = extractMethodObjectProcessor.findUsages();\n          extractMethodObjectProcessor.performRefactoring(usages);\n          extractMethodObjectProcessor.runChangeSignature();\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n        if (extractMethodObjectProcessor.isCreateInnerClass()) {\n          extractMethodObjectProcessor.changeInstanceAccess(project);\n        }\n        final PsiElement method = extractMethodObjectProcessor.getMethod();\n        LOG.assertTrue(method != null);\n        method.delete();\n      }\n    } else {\n      return null;\n    }\n\n    final String generatedCall = copy.getText().substring(start, outStatement.getTextOffset());\n    return new ExtractedData(generatedCall,\n                             (PsiClass)CodeStyleManager.getInstance(project).reformat(extractMethodObjectProcessor.getInnerClass()),\n                             originalAnchor);\n  }","commit_id":"1304e452d91bba91bdfbce2aad75c726342aeca9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void initSystemShortcuts() {\n        // TODO: Insert system shortcuts here. See Windows and especially OSX to see how to.\n        for(int i = KeyEvent.VK_F1; i <= KeyEvent.VK_F12; ++i)\n            Shortcut.registerSystemShortcut(\"screen:toogle\"+i, \"reserved\", i, KeyEvent.CTRL_DOWN_MASK | KeyEvent.ALT_DOWN_MASK);\n    }","id":35694,"modified_method":"@Override\n    public void initSystemShortcuts() {\n        // TODO: Insert system shortcuts here. See Windows and especially OSX to see how to.\n        for(int i = KeyEvent.VK_F1; i <= KeyEvent.VK_F12; ++i)\n            Shortcut.registerSystemShortcut(\"screen:toogle\"+i, \"reserved\", i, KeyEvent.CTRL_DOWN_MASK | KeyEvent.ALT_DOWN_MASK).setAutomatic();\n    }","commit_id":"77a5098342336c5fbc558c343f7852e0d6180d0d","url":"https://github.com/openstreetmap/josm"},{"original_method":"private static Shortcut registerShortcut(String shortText, String longText, int requestedKey, int requestedGroup, Integer modifier) {\n        doInit();\n        Integer defaultModifier = findModifier(requestedGroup, modifier);\n        if (shortcuts.containsKey(shortText)) { // a re-register? maybe a sc already read from the preferences?\n            Shortcut sc = shortcuts.get(shortText);\n            sc.setLongText(longText); // or set by the platformHook, in this case the original longText doesn't match the real action\n            sc.saveDefault();\n            return sc;\n        }\n        Shortcut conflict = findShortcut(requestedKey, defaultModifier);\n        if (conflict != null) {\n            for (int m : mods) {\n                for (int k : keys) {\n                    int newmodifier = getGroupModifier(m);\n                    if ( findShortcut(k, m) == null ) {\n                        Shortcut newsc = new Shortcut(shortText, longText, requestedKey, m, k, newmodifier, false, false);\n                        System.out.println(tr(\"Silent shortcut conflict: ''{0}'' moved by ''{1}'' to ''{2}''.\",\n                            shortText, conflict.getShortText(), newsc.getKeyText()));\n                        newsc.saveDefault();\n                        shortcuts.put(shortText, newsc);\n                        return newsc;\n                    }\n                }\n            }\n        } else {\n            Shortcut newsc = new Shortcut(shortText, longText, requestedKey, requestedGroup, requestedKey, defaultModifier, true, false);\n            newsc.saveDefault();\n            shortcuts.put(shortText, newsc);\n            return newsc;\n        }\n\n        return null;\n    }","id":35695,"modified_method":"private static Shortcut registerShortcut(String shortText, String longText, int requestedKey, int requestedGroup, Integer modifier) {\n        doInit();\n        Integer defaultModifier = findModifier(requestedGroup, modifier);\n        if (shortcuts.containsKey(shortText)) { // a re-register? maybe a sc already read from the preferences?\n            Shortcut sc = shortcuts.get(shortText);\n            sc.setLongText(longText); // or set by the platformHook, in this case the original longText doesn't match the real action\n            sc.saveDefault();\n            return sc;\n        }\n        Shortcut conflict = findShortcut(requestedKey, defaultModifier);\n        if (conflict != null) {\n            for (int m : mods) {\n                for (int k : keys) {\n                    int newmodifier = getGroupModifier(m);\n                    if ( findShortcut(k, newmodifier) == null ) {\n                        Shortcut newsc = new Shortcut(shortText, longText, requestedKey, m, k, newmodifier, false, false);\n                        System.out.println(tr(\"Silent shortcut conflict: ''{0}'' moved by ''{1}'' to ''{2}''.\",\n                            shortText, conflict.getShortText(), newsc.getKeyText()));\n                        newsc.saveDefault();\n                        shortcuts.put(shortText, newsc);\n                        return newsc;\n                    }\n                }\n            }\n        } else {\n            Shortcut newsc = new Shortcut(shortText, longText, requestedKey, requestedGroup, requestedKey, defaultModifier, true, false);\n            newsc.saveDefault();\n            shortcuts.put(shortText, newsc);\n            return newsc;\n        }\n\n        return null;\n    }","commit_id":"77a5098342336c5fbc558c343f7852e0d6180d0d","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void initSystemShortcuts() {\n        //Shortcut.registerSystemCut(\"system:menuexit\", tr(\"reserved\"), VK_Q, CTRL_DOWN_MASK);\n        Shortcut.registerSystemShortcut(\"system:duplicate\", tr(\"reserved\"), VK_D, CTRL_DOWN_MASK); // not really system, but to avoid odd results\n        \n        // Windows 7 shortcuts: http://windows.microsoft.com/en-US/windows7/Keyboard-shortcuts\n\n        // Shortcuts with setAutomatic(): items with automatic shortcuts will not be added to the menu bar at all\n\n        // Don't know why Ctrl-Alt-Del isn't even listed on official Microsoft support page\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-00\", tr(\"reserved\"), VK_DELETE, CTRL_DOWN_MASK | ALT_DOWN_MASK);\n\n        // Ease of Access keyboard shortcuts\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-01\", tr(\"reserved\"), VK_PRINTSCREEN, ALT_DOWN_MASK | SHIFT_DOWN_MASK); // Turn High Contrast on or off\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-02\", tr(\"reserved\"), VK_NUM_LOCK, ALT_DOWN_MASK | SHIFT_DOWN_MASK); // Turn Mouse Keys on or off\n        //Shortcut.registerSystemCut(\"microsoft-reserved-03\", tr(\"reserved\"), VK_U, );// Open the Ease of Access Center (TODO: Windows-U, how to handle it in Java ?)\n        \n        // General keyboard shortcuts\n        Shortcut.registerSystemShortcut(\"system:help\", tr(\"reserved\"), VK_F1, 0);                            // Display Help\n        Shortcut.registerSystemShortcut(\"system:copy\", tr(\"reserved\"), VK_C, CTRL_DOWN_MASK);                // Copy the selected item\n        Shortcut.registerSystemShortcut(\"system:cut\", tr(\"reserved\"), VK_X, CTRL_DOWN_MASK);                 // Cut the selected item\n        Shortcut.registerSystemShortcut(\"system:paste\", tr(\"reserved\"), VK_V, CTRL_DOWN_MASK);               // Paste the selected item\n        Shortcut.registerSystemShortcut(\"system:undo\", tr(\"reserved\"), VK_Z, CTRL_DOWN_MASK);                    // Undo an action\n        Shortcut.registerSystemShortcut(\"system:redo\", tr(\"reserved\"), VK_Y, CTRL_DOWN_MASK);                    // Redo an action\n        //Shortcut.registerSystemCut(\"microsoft-reserved-10\", \"reserved\", VK_DELETE, 0);                  // Delete the selected item and move it to the Recycle Bin\n        //Shortcut.registerSystemCut(\"microsoft-reserved-11\", \"reserved\", VK_DELETE, SHIFT_DOWN_MASK);    // Delete the selected item without moving it to the Recycle Bin first\n        //Shortcut.registerSystemCut(\"system:rename\", tr(\"reserved\"), VK_F2, 0);                          // Rename the selected item\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-13\", tr(\"reserved\"), VK_RIGHT, CTRL_DOWN_MASK);  // Move the cursor to the beginning of the next word\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-14\", tr(\"reserved\"), VK_LEFT, CTRL_DOWN_MASK);   // Move the cursor to the beginning of the previous word\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-15\", tr(\"reserved\"), VK_DOWN, CTRL_DOWN_MASK);   // Move the cursor to the beginning of the next paragraph\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-16\", tr(\"reserved\"), VK_UP, CTRL_DOWN_MASK);     // Move the cursor to the beginning of the previous paragraph\n        //Shortcut.registerSystemCut(\"microsoft-reserved-17\", tr(\"reserved\"), VK_RIGHT, CTRL_DOWN_MASK | SHIFT_DOWN_MASK); // Select a block of text\n        //Shortcut.registerSystemCut(\"microsoft-reserved-18\", tr(\"reserved\"), VK_LEFT, CTRL_DOWN_MASK | SHIFT_DOWN_MASK);  // Select a block of text\n        //Shortcut.registerSystemCut(\"microsoft-reserved-19\", tr(\"reserved\"), VK_DOWN, CTRL_DOWN_MASK | SHIFT_DOWN_MASK);  // Select a block of text\n        //Shortcut.registerSystemCut(\"microsoft-reserved-20\", tr(\"reserved\"), VK_UP, CTRL_DOWN_MASK | SHIFT_DOWN_MASK);    // Select a block of text\n        //Shortcut.registerSystemCut(\"microsoft-reserved-21\", tr(\"reserved\"), VK_RIGHT, SHIFT_DOWN_MASK); // Select more than one item in a window or on the desktop, or select text within a document\n        //Shortcut.registerSystemCut(\"microsoft-reserved-22\", tr(\"reserved\"), VK_LEFT, SHIFT_DOWN_MASK);  // Select more than one item in a window or on the desktop, or select text within a document\n        //Shortcut.registerSystemCut(\"microsoft-reserved-23\", tr(\"reserved\"), VK_DOWN, SHIFT_DOWN_MASK);  // Select more than one item in a window or on the desktop, or select text within a document\n        //Shortcut.registerSystemCut(\"microsoft-reserved-24\", tr(\"reserved\"), VK_UP, SHIFT_DOWN_MASK);    // Select more than one item in a window or on the desktop, or select text within a document\n        //Shortcut.registerSystemCut(\"microsoft-reserved-25\", tr(\"reserved\"), VK_RIGHT+, CTRL_DOWN_MASK); // Select multiple individual items in a window or on the desktop (TODO: ctrl+arrow+spacebar, how to handle it in Java ?)\n        //Shortcut.registerSystemCut(\"microsoft-reserved-26\", tr(\"reserved\"), VK_LEFT+, CTRL_DOWN_MASK);  // Select multiple individual items in a window or on the desktop (TODO: ctrl+arrow+spacebar, how to handle it in Java ?)\n        //Shortcut.registerSystemCut(\"microsoft-reserved-27\", tr(\"reserved\"), VK_DOWN+, CTRL_DOWN_MASK);  // Select multiple individual items in a window or on the desktop (TODO: ctrl+arrow+spacebar, how to handle it in Java ?)\n        //Shortcut.registerSystemCut(\"microsoft-reserved-28\", tr(\"reserved\"), VK_UP+, CTRL_DOWN_MASK);    // Select multiple individual items in a window or on the desktop (TODO: ctrl+arrow+spacebar, how to handle it in Java ?)\n        Shortcut.registerSystemShortcut(\"system:selectall\", tr(\"reserved\"), VK_A, CTRL_DOWN_MASK);           // Select all items in a document or window\n        //Shortcut.registerSystemCut(\"system:search\", tr(\"reserved\"), VK_F3, 0);                          // Search for a file or folder\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-31\", tr(\"reserved\"), VK_ENTER, ALT_DOWN_MASK);   // Display properties for the selected item\n        Shortcut.registerSystemShortcut(\"system:exit\", tr(\"reserved\"), VK_F4, ALT_DOWN_MASK).setAutomatic(); // Close the active item, or exit the active program\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-33\", tr(\"reserved\"), VK_SPACE, ALT_DOWN_MASK);   // Open the shortcut menu for the active window\n        //Shortcut.registerSystemCut(\"microsoft-reserved-34\", tr(\"reserved\"), VK_F4, CTRL_DOWN_MASK);     // Close the active document (in programs that allow you to have multiple documents open simultaneously)\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-35\", tr(\"reserved\"), VK_TAB, ALT_DOWN_MASK);     // Switch between open items\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-36\", tr(\"reserved\"), VK_TAB, CTRL_DOWN_MASK | ALT_DOWN_MASK); // Use the arrow keys to switch between open items\n        //Shortcut.registerSystemCut(\"microsoft-reserved-37\", tr(\"reserved\"), VK_TAB, ); // Cycle through programs on the taskbar by using Aero Flip 3-D (TODO: Windows-Tab, how to handle it in Java ?)\n        //Shortcut.registerSystemCut(\"microsoft-reserved-38\", tr(\"reserved\"), VK_TAB, CTRL_DOWN_MASK | ); // Use the arrow keys to cycle through programs on the taskbar by using Aero Flip 3-D (TODO: Ctrl-Windows-Tab, how to handle it in Java ?)\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-39\", tr(\"reserved\"), VK_ESCAPE, ALT_DOWN_MASK);  // Cycle through items in the order in which they were opened\n        //Shortcut.registerSystemCut(\"microsoft-reserved-40\", tr(\"reserved\"), VK_F6, 0);                  // Cycle through screen elements in a window or on the desktop\n        //Shortcut.registerSystemCut(\"microsoft-reserved-41\", tr(\"reserved\"), VK_F4, 0);                  // Display the address bar list in Windows Explorer\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-42\", tr(\"reserved\"), VK_F10, SHIFT_DOWN_MASK);   // Display the shortcut menu for the selected item\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-43\", tr(\"reserved\"), VK_ESCAPE, CTRL_DOWN_MASK); // Open the Start menu\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-44\", tr(\"reserved\"), VK_F10, 0);                 // Activate the menu bar in the active program\n        //Shortcut.registerSystemCut(\"microsoft-reserved-45\", tr(\"reserved\"), VK_RIGHT, 0);               // Open the next menu to the right, or open a submenu\n        //Shortcut.registerSystemCut(\"microsoft-reserved-46\", tr(\"reserved\"), VK_LEFT, 0);                // Open the next menu to the left, or close a submenu\n        //Shortcut.registerSystemCut(\"microsoft-reserved-47\", tr(\"reserved\"), VK_F5, 0);                  // Refresh the active window\n        //Shortcut.registerSystemCut(\"microsoft-reserved-48\", tr(\"reserved\"), VK_UP, ALT_DOWN_MASK);      // View the folder one level up in Windows Explorer\n        //Shortcut.registerSystemCut(\"microsoft-reserved-49\", tr(\"reserved\"), VK_ESCAPE, 0);              // Cancel the current task\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-50\", tr(\"reserved\"), VK_ESCAPE, CTRL_DOWN_MASK | SHIFT_DOWN_MASK); // Open Task Manager\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-51\", tr(\"reserved\"), VK_SHIFT, ALT_DOWN_MASK);   // Switch the input language when multiple input languages are enabled\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-52\", tr(\"reserved\"), VK_SHIFT, CTRL_DOWN_MASK);  // Switch the keyboard layout when multiple keyboard layouts are enabled\n        //Shortcut.registerSystemCut(\"microsoft-reserved-53\", tr(\"reserved\"), ); // Change the reading direction of text in right-to-left reading languages (TODO: unclear)\n    }","id":35696,"modified_method":"@Override\n    public void initSystemShortcuts() {\n        //Shortcut.registerSystemCut(\"system:menuexit\", tr(\"reserved\"), VK_Q, CTRL_DOWN_MASK);\n        Shortcut.registerSystemShortcut(\"system:duplicate\", tr(\"reserved\"), VK_D, CTRL_DOWN_MASK); // not really system, but to avoid odd results\n        \n        // Windows 7 shortcuts: http://windows.microsoft.com/en-US/windows7/Keyboard-shortcuts\n\n        // Shortcuts with setAutomatic(): items with automatic shortcuts will not be added to the menu bar at all\n\n        // Don't know why Ctrl-Alt-Del isn't even listed on official Microsoft support page\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-00\", tr(\"reserved\"), VK_DELETE, CTRL_DOWN_MASK | ALT_DOWN_MASK).setAutomatic();\n\n        // Ease of Access keyboard shortcuts\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-01\", tr(\"reserved\"), VK_PRINTSCREEN, ALT_DOWN_MASK | SHIFT_DOWN_MASK).setAutomatic(); // Turn High Contrast on or off\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-02\", tr(\"reserved\"), VK_NUM_LOCK, ALT_DOWN_MASK | SHIFT_DOWN_MASK).setAutomatic(); // Turn Mouse Keys on or off\n        //Shortcut.registerSystemCut(\"microsoft-reserved-03\", tr(\"reserved\"), VK_U, );// Open the Ease of Access Center (TODO: Windows-U, how to handle it in Java ?)\n        \n        // General keyboard shortcuts\n        Shortcut.registerSystemShortcut(\"system:help\", tr(\"reserved\"), VK_F1, 0);                            // Display Help\n        Shortcut.registerSystemShortcut(\"system:copy\", tr(\"reserved\"), VK_C, CTRL_DOWN_MASK);                // Copy the selected item\n        Shortcut.registerSystemShortcut(\"system:cut\", tr(\"reserved\"), VK_X, CTRL_DOWN_MASK);                 // Cut the selected item\n        Shortcut.registerSystemShortcut(\"system:paste\", tr(\"reserved\"), VK_V, CTRL_DOWN_MASK);               // Paste the selected item\n        Shortcut.registerSystemShortcut(\"system:undo\", tr(\"reserved\"), VK_Z, CTRL_DOWN_MASK);                    // Undo an action\n        Shortcut.registerSystemShortcut(\"system:redo\", tr(\"reserved\"), VK_Y, CTRL_DOWN_MASK);                    // Redo an action\n        //Shortcut.registerSystemCut(\"microsoft-reserved-10\", \"reserved\", VK_DELETE, 0);                  // Delete the selected item and move it to the Recycle Bin\n        //Shortcut.registerSystemCut(\"microsoft-reserved-11\", \"reserved\", VK_DELETE, SHIFT_DOWN_MASK);    // Delete the selected item without moving it to the Recycle Bin first\n        //Shortcut.registerSystemCut(\"system:rename\", tr(\"reserved\"), VK_F2, 0);                          // Rename the selected item\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-13\", tr(\"reserved\"), VK_RIGHT, CTRL_DOWN_MASK).setAutomatic();  // Move the cursor to the beginning of the next word\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-14\", tr(\"reserved\"), VK_LEFT, CTRL_DOWN_MASK).setAutomatic();   // Move the cursor to the beginning of the previous word\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-15\", tr(\"reserved\"), VK_DOWN, CTRL_DOWN_MASK).setAutomatic();   // Move the cursor to the beginning of the next paragraph\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-16\", tr(\"reserved\"), VK_UP, CTRL_DOWN_MASK).setAutomatic();     // Move the cursor to the beginning of the previous paragraph\n        //Shortcut.registerSystemCut(\"microsoft-reserved-17\", tr(\"reserved\"), VK_RIGHT, CTRL_DOWN_MASK | SHIFT_DOWN_MASK); // Select a block of text\n        //Shortcut.registerSystemCut(\"microsoft-reserved-18\", tr(\"reserved\"), VK_LEFT, CTRL_DOWN_MASK | SHIFT_DOWN_MASK);  // Select a block of text\n        //Shortcut.registerSystemCut(\"microsoft-reserved-19\", tr(\"reserved\"), VK_DOWN, CTRL_DOWN_MASK | SHIFT_DOWN_MASK);  // Select a block of text\n        //Shortcut.registerSystemCut(\"microsoft-reserved-20\", tr(\"reserved\"), VK_UP, CTRL_DOWN_MASK | SHIFT_DOWN_MASK);    // Select a block of text\n        //Shortcut.registerSystemCut(\"microsoft-reserved-21\", tr(\"reserved\"), VK_RIGHT, SHIFT_DOWN_MASK); // Select more than one item in a window or on the desktop, or select text within a document\n        //Shortcut.registerSystemCut(\"microsoft-reserved-22\", tr(\"reserved\"), VK_LEFT, SHIFT_DOWN_MASK);  // Select more than one item in a window or on the desktop, or select text within a document\n        //Shortcut.registerSystemCut(\"microsoft-reserved-23\", tr(\"reserved\"), VK_DOWN, SHIFT_DOWN_MASK);  // Select more than one item in a window or on the desktop, or select text within a document\n        //Shortcut.registerSystemCut(\"microsoft-reserved-24\", tr(\"reserved\"), VK_UP, SHIFT_DOWN_MASK);    // Select more than one item in a window or on the desktop, or select text within a document\n        //Shortcut.registerSystemCut(\"microsoft-reserved-25\", tr(\"reserved\"), VK_RIGHT+, CTRL_DOWN_MASK); // Select multiple individual items in a window or on the desktop (TODO: ctrl+arrow+spacebar, how to handle it in Java ?)\n        //Shortcut.registerSystemCut(\"microsoft-reserved-26\", tr(\"reserved\"), VK_LEFT+, CTRL_DOWN_MASK);  // Select multiple individual items in a window or on the desktop (TODO: ctrl+arrow+spacebar, how to handle it in Java ?)\n        //Shortcut.registerSystemCut(\"microsoft-reserved-27\", tr(\"reserved\"), VK_DOWN+, CTRL_DOWN_MASK);  // Select multiple individual items in a window or on the desktop (TODO: ctrl+arrow+spacebar, how to handle it in Java ?)\n        //Shortcut.registerSystemCut(\"microsoft-reserved-28\", tr(\"reserved\"), VK_UP+, CTRL_DOWN_MASK);    // Select multiple individual items in a window or on the desktop (TODO: ctrl+arrow+spacebar, how to handle it in Java ?)\n        Shortcut.registerSystemShortcut(\"system:selectall\", tr(\"reserved\"), VK_A, CTRL_DOWN_MASK);           // Select all items in a document or window\n        //Shortcut.registerSystemCut(\"system:search\", tr(\"reserved\"), VK_F3, 0);                          // Search for a file or folder\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-31\", tr(\"reserved\"), VK_ENTER, ALT_DOWN_MASK).setAutomatic();   // Display properties for the selected item\n        Shortcut.registerSystemShortcut(\"system:exit\", tr(\"reserved\"), VK_F4, ALT_DOWN_MASK).setAutomatic(); // Close the active item, or exit the active program\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-33\", tr(\"reserved\"), VK_SPACE, ALT_DOWN_MASK).setAutomatic();   // Open the shortcut menu for the active window\n        //Shortcut.registerSystemCut(\"microsoft-reserved-34\", tr(\"reserved\"), VK_F4, CTRL_DOWN_MASK);     // Close the active document (in programs that allow you to have multiple documents open simultaneously)\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-35\", tr(\"reserved\"), VK_TAB, ALT_DOWN_MASK).setAutomatic();     // Switch between open items\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-36\", tr(\"reserved\"), VK_TAB, CTRL_DOWN_MASK | ALT_DOWN_MASK).setAutomatic(); // Use the arrow keys to switch between open items\n        //Shortcut.registerSystemCut(\"microsoft-reserved-37\", tr(\"reserved\"), VK_TAB, ); // Cycle through programs on the taskbar by using Aero Flip 3-D (TODO: Windows-Tab, how to handle it in Java ?)\n        //Shortcut.registerSystemCut(\"microsoft-reserved-38\", tr(\"reserved\"), VK_TAB, CTRL_DOWN_MASK | ); // Use the arrow keys to cycle through programs on the taskbar by using Aero Flip 3-D (TODO: Ctrl-Windows-Tab, how to handle it in Java ?)\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-39\", tr(\"reserved\"), VK_ESCAPE, ALT_DOWN_MASK).setAutomatic();  // Cycle through items in the order in which they were opened\n        //Shortcut.registerSystemCut(\"microsoft-reserved-40\", tr(\"reserved\"), VK_F6, 0);                  // Cycle through screen elements in a window or on the desktop\n        //Shortcut.registerSystemCut(\"microsoft-reserved-41\", tr(\"reserved\"), VK_F4, 0);                  // Display the address bar list in Windows Explorer\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-42\", tr(\"reserved\"), VK_F10, SHIFT_DOWN_MASK);   // Display the shortcut menu for the selected item\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-43\", tr(\"reserved\"), VK_ESCAPE, CTRL_DOWN_MASK).setAutomatic(); // Open the Start menu\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-44\", tr(\"reserved\"), VK_F10, 0);                 // Activate the menu bar in the active program\n        //Shortcut.registerSystemCut(\"microsoft-reserved-45\", tr(\"reserved\"), VK_RIGHT, 0);               // Open the next menu to the right, or open a submenu\n        //Shortcut.registerSystemCut(\"microsoft-reserved-46\", tr(\"reserved\"), VK_LEFT, 0);                // Open the next menu to the left, or close a submenu\n        //Shortcut.registerSystemCut(\"microsoft-reserved-47\", tr(\"reserved\"), VK_F5, 0);                  // Refresh the active window\n        //Shortcut.registerSystemCut(\"microsoft-reserved-48\", tr(\"reserved\"), VK_UP, ALT_DOWN_MASK);      // View the folder one level up in Windows Explorer\n        //Shortcut.registerSystemCut(\"microsoft-reserved-49\", tr(\"reserved\"), VK_ESCAPE, 0);              // Cancel the current task\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-50\", tr(\"reserved\"), VK_ESCAPE, CTRL_DOWN_MASK | SHIFT_DOWN_MASK).setAutomatic(); // Open Task Manager\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-51\", tr(\"reserved\"), VK_SHIFT, ALT_DOWN_MASK).setAutomatic();   // Switch the input language when multiple input languages are enabled\n        Shortcut.registerSystemShortcut(\"microsoft-reserved-52\", tr(\"reserved\"), VK_SHIFT, CTRL_DOWN_MASK).setAutomatic();  // Switch the keyboard layout when multiple keyboard layouts are enabled\n        //Shortcut.registerSystemCut(\"microsoft-reserved-53\", tr(\"reserved\"), ); // Change the reading direction of text in right-to-left reading languages (TODO: unclear)\n    }","commit_id":"680ccc8e676043940f3bbb6bcdfd5b44a0311a27","url":"https://github.com/openstreetmap/josm"},{"original_method":"private static TableCellRenderer createDisplayNameCellRenderer() {\n    return new TableCellRenderer() {\n      final SimpleColoredComponent myLabel = new SimpleColoredComponent();\n      final Pattern myPattern = Pattern.compile(\"(.+)(\\\\(\\\\S+(?:\\\\.\\\\S+)+\\\\))\");\n\n      public Component getTableCellRendererComponent(final JTable table, final Object value, final boolean isSelected, final boolean hasFocus,\n                                                     final int row,\n                                                     final int column) {\n        myLabel.clear();\n\n        final BaseInjection injection = (BaseInjection)value;\n        myLabel.append(injection.getSupportId(), SimpleTextAttributes.GRAY_ATTRIBUTES);\n        myLabel.append(\": \", SimpleTextAttributes.GRAY_ATTRIBUTES);\n\n        final String text = injection.getDisplayName();\n        final Matcher matcher = myPattern.matcher(text);\n        if (matcher.matches()) {\n          myLabel.append(matcher.group(1), SimpleTextAttributes.REGULAR_ATTRIBUTES);\n          myLabel.append(matcher.group(2), SimpleTextAttributes.GRAYED_ATTRIBUTES);\n        }\n        else {\n          myLabel.append(text, SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n        setLabelColors(myLabel, table, isSelected, row);\n        return myLabel;\n      }\n    };\n  }","id":35697,"modified_method":"private TableCellRenderer createDisplayNameCellRenderer() {\n    return new TableCellRenderer() {\n      final SimpleColoredComponent myLabel = new SimpleColoredComponent();\n      final SimpleColoredText myText = new SimpleColoredText();\n\n      public Component getTableCellRendererComponent(final JTable table, final Object value, final boolean isSelected, final boolean hasFocus,\n                                                     final int row,\n                                                     final int column) {\n        myLabel.clear();\n        final BaseInjection injection = (BaseInjection)value;\n        final SimpleTextAttributes grayAttrs = isSelected ? SimpleTextAttributes.REGULAR_ATTRIBUTES : SimpleTextAttributes.GRAY_ATTRIBUTES;\n        myText.append(injection.getSupportId() + \": \", grayAttrs);\n        mySupports.get(injection.getSupportId()).setupPresentation(injection, myText, isSelected);\n        myText.appendToComponent(myLabel);\n        myText.clear();\n        setLabelColors(myLabel, table, isSelected, row);\n        return myLabel;\n      }\n    };\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void performAdd(final AnActionEvent button) {\n    // todo add popup \n    Messages.showInfoMessage(myProject, \"Unfortunately this functionality is not yet implemented.\\nUse in place \\'Inject language\\' intention action.\", \"Add Injection\");\n  }","id":35698,"modified_method":"private void performAdd(final AnActionEvent e) {\n    final DefaultActionGroup group = new DefaultActionGroup();\n    for (AnAction action : myAddActions) {\n      group.add(action);\n    }\n\n    JBPopupFactory.getInstance().createActionGroupPopup(null, group, e.getDataContext(), JBPopupFactory.ActionSelectionAid.NUMBERING, true)\n      .showUnderneathOf(myToolbar.getComponent());\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void performRemove() {\n    final int selectedRow = myInjectionsTable.getSelectedRow();\n    if (selectedRow < 0) return;\n    myInjections.removeAll(getSelectedInjections());\n    myInjectionsTable.updateUI();\n    myInjectionsTable.getSelectionModel().setLeadSelectionIndex(Math.min(myInjections.size()-1, selectedRow));\n  }","id":35699,"modified_method":"private void performRemove() {\n    final int selectedRow = myInjectionsTable.getSelectedRow();\n    if (selectedRow < 0) return;\n    myInjections.removeAll(getSelectedInjections());\n    ((ListTableModel)myInjectionsTable.getModel()).fireTableDataChanged();\n    final int index = Math.min(myInjections.size() - 1, selectedRow);\n    myInjectionsTable.getSelectionModel().setSelectionInterval(index, index);\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InjectionsSettingsUI(final Project project, final Configuration configuration) {\n    myProject = project;\n    myConfiguration = configuration;\n\n    myOriginalInjections = ContainerUtil\n      .concat(InjectorUtils.getActiveInjectionSupportIds(), new Function<String, Collection<? extends BaseInjection>>() {\n        public Collection<? extends BaseInjection> fun(final String s) {\n          return ContainerUtil.findAll(myConfiguration.getInjections(s), new Condition<BaseInjection>() {\n            public boolean value(final BaseInjection injection) {\n              return InjectedLanguage.findLanguageById(injection.getInjectedLanguageId()) != null;\n            }\n          });\n        }\n      });\n    Collections.sort(myOriginalInjections, new Comparator<BaseInjection>() {\n      public int compare(final BaseInjection o1, final BaseInjection o2) {\n        final int support = Comparing.compare(o1.getSupportId(), o2.getSupportId());\n        if (support != 0) return support;\n        final int lang = Comparing.compare(o1.getInjectedLanguageId(), o2.getInjectedLanguageId());\n        if (lang != 0) return lang;\n        final int name = Comparing.compare(o1.getDisplayName(), o2.getDisplayName());\n        return name;\n      }\n    });\n    myInjections = new ArrayList<BaseInjection>();\n    for (BaseInjection injection : myOriginalInjections) {\n      myInjections.add(injection.copy());\n    }\n\n    myRoot = new JPanel(new BorderLayout());\n\n    myInjectionsTable = new InjectionsTable(myInjections);\n    final JPanel tablePanel = new JPanel(new BorderLayout());\n    //tablePanel.setBorder(BorderFactory.createTitledBorder(\"Available Injections\"));\n    tablePanel.add(BetterJTable.createStripedJScrollPane(myInjectionsTable), BorderLayout.CENTER);\n    tablePanel.add(Box.createVerticalStrut(10), BorderLayout.SOUTH);\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n    group.add(new AnAction(\"Add\", \"Add\", Icons.ADD_ICON) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performAdd(e);\n      }\n    });\n    group.add(new AnAction(\"Remove\", \"Remove\", Icons.DELETE_ICON) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performRemove();\n      }\n    });\n    group.add(new AnAction(\"Import\", \"Import\", IconLoader.getIcon(\"/actions/install.png\")) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        doImportAction(e.getDataContext());\n      }\n    });\n    group.addSeparator();\n    group.add(new AnAction(\"Enabled Selected Injections\", \"Enabled Selected Injections\", Icons.SELECT_ALL_ICON) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performSelectedInjectionsEnabled(true);\n      }\n    });\n    group.add(new AnAction(\"Disabled Selected Injections\", \"Disabled Selected Injections\", Icons.UNSELECT_ALL_ICON) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performSelectedInjectionsEnabled(false);\n      }\n    });\n\n    new AnAction(\"Toggle\") {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performToggleAction();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0)), myInjectionsTable);\n\n    myRoot.add(ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true).getComponent(), BorderLayout.NORTH);\n    myRoot.add(tablePanel, BorderLayout.CENTER);\n  }","id":35700,"modified_method":"public InjectionsSettingsUI(final Project project, final Configuration configuration) {\n    myProject = project;\n    myConfiguration = configuration;\n\n    myOriginalInjections = ContainerUtil\n      .concat(InjectorUtils.getActiveInjectionSupportIds(), new Function<String, Collection<? extends BaseInjection>>() {\n        public Collection<? extends BaseInjection> fun(final String s) {\n          return ContainerUtil.findAll(myConfiguration.getInjections(s), new Condition<BaseInjection>() {\n            public boolean value(final BaseInjection injection) {\n              return InjectedLanguage.findLanguageById(injection.getInjectedLanguageId()) != null;\n            }\n          });\n        }\n      });\n    sortInjections(myOriginalInjections);\n    myInjections = new ArrayList<BaseInjection>();\n    for (BaseInjection injection : myOriginalInjections) {\n      myInjections.add(injection.copy());\n    }\n\n    myRoot = new JPanel(new BorderLayout());\n\n    myInjectionsTable = new InjectionsTable(myInjections);\n    final JPanel tablePanel = new JPanel(new BorderLayout());\n    //tablePanel.setBorder(BorderFactory.createTitledBorder(\"Available Injections\"));\n    tablePanel.add(BetterJTable.createStripedJScrollPane(myInjectionsTable), BorderLayout.CENTER);\n    tablePanel.add(Box.createVerticalStrut(10), BorderLayout.SOUTH);\n\n    final DefaultActionGroup group = createActions();\n\n    myToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    myToolbar.setTargetComponent(myInjectionsTable);\n    myRoot.add(myToolbar.getComponent(), BorderLayout.NORTH);\n    myRoot.add(tablePanel, BorderLayout.CENTER);\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static ColumnInfo[] createInjectionColumnInfos() {\n    final TableCellRenderer booleanCellRenderer = createBooleanCellRenderer();\n    final TableCellRenderer displayNameCellRenderer = createDisplayNameCellRenderer();\n    final TableCellRenderer languageCellRenderer = createLanguageCellRenderer();\n    final Comparator<BaseInjection> languageComparator = new Comparator<BaseInjection>() {\n      public int compare(final BaseInjection o1, final BaseInjection o2) {\n        return Comparing.compare(o1.getInjectedLanguageId(), o2.getInjectedLanguageId());\n      }\n    };\n    final Comparator<BaseInjection> displayNameComparator = new Comparator<BaseInjection>() {\n      public int compare(final BaseInjection o1, final BaseInjection o2) {\n        final int support = Comparing.compare(o1.getSupportId(), o2.getSupportId());\n        if (support != 0) return support;\n        return Comparing.compare(o1.getDisplayName(), o2.getDisplayName());\n      }\n    };\n    return new ColumnInfo[]{new ColumnInfo<BaseInjection, Boolean>(\" \") {\n      @Override\n      public Class getColumnClass() {\n        return Boolean.class;\n      }\n\n      @Override\n      public Boolean valueOf(final BaseInjection o) {\n        return o.isEnabled();\n      }\n\n      @Override\n      public boolean isCellEditable(final BaseInjection injection) {\n        return true;\n      }\n\n      @Override\n      public void setValue(final BaseInjection injection, final Boolean value) {\n        injection.setPlaceEnabled(null, value.booleanValue());\n      }\n\n      @Override\n      public TableCellRenderer getRenderer(final BaseInjection injection) {\n        return booleanCellRenderer;\n      }\n    }, new ColumnInfo<BaseInjection, BaseInjection>(\"Display Name\") {\n      @Override\n      public BaseInjection valueOf(final BaseInjection injection) {\n        return injection;\n      }\n\n      @Override\n      public Comparator<BaseInjection> getComparator() {\n        return displayNameComparator;\n      }\n\n      @Override\n      public TableCellRenderer getRenderer(final BaseInjection injection) {\n        return displayNameCellRenderer;\n      }\n    }, new ColumnInfo<BaseInjection, BaseInjection>(\"Language\") {\n      @Override\n      public BaseInjection valueOf(final BaseInjection injection) {\n        return injection;\n      }\n\n      @Override\n      public Comparator<BaseInjection> getComparator() {\n        return languageComparator;\n      }\n\n      @Override\n      public TableCellRenderer getRenderer(final BaseInjection injection) {\n        return languageCellRenderer;\n      }\n    }};\n  }","id":35701,"modified_method":"private ColumnInfo[] createInjectionColumnInfos() {\n    final TableCellRenderer booleanCellRenderer = createBooleanCellRenderer();\n    final TableCellRenderer displayNameCellRenderer = createDisplayNameCellRenderer();\n    final TableCellRenderer languageCellRenderer = createLanguageCellRenderer();\n    final Comparator<BaseInjection> languageComparator = new Comparator<BaseInjection>() {\n      public int compare(final BaseInjection o1, final BaseInjection o2) {\n        return Comparing.compare(o1.getInjectedLanguageId(), o2.getInjectedLanguageId());\n      }\n    };\n    final Comparator<BaseInjection> displayNameComparator = new Comparator<BaseInjection>() {\n      public int compare(final BaseInjection o1, final BaseInjection o2) {\n        final int support = Comparing.compare(o1.getSupportId(), o2.getSupportId());\n        if (support != 0) return support;\n        return Comparing.compare(o1.getDisplayName(), o2.getDisplayName());\n      }\n    };\n    return new ColumnInfo[]{new ColumnInfo<BaseInjection, Boolean>(\" \") {\n      @Override\n      public Class getColumnClass() {\n        return Boolean.class;\n      }\n\n      @Override\n      public Boolean valueOf(final BaseInjection o) {\n        return o.isEnabled();\n      }\n\n      @Override\n      public boolean isCellEditable(final BaseInjection injection) {\n        return true;\n      }\n\n      @Override\n      public void setValue(final BaseInjection injection, final Boolean value) {\n        injection.setPlaceEnabled(null, value.booleanValue());\n      }\n\n      @Override\n      public TableCellRenderer getRenderer(final BaseInjection injection) {\n        return booleanCellRenderer;\n      }\n    }, new ColumnInfo<BaseInjection, BaseInjection>(\"Display Name\") {\n      @Override\n      public BaseInjection valueOf(final BaseInjection injection) {\n        return injection;\n      }\n\n      @Override\n      public Comparator<BaseInjection> getComparator() {\n        return displayNameComparator;\n      }\n\n      @Override\n      public TableCellRenderer getRenderer(final BaseInjection injection) {\n        return displayNameCellRenderer;\n      }\n    }, new ColumnInfo<BaseInjection, BaseInjection>(\"Language\") {\n      @Override\n      public BaseInjection valueOf(final BaseInjection injection) {\n        return injection;\n      }\n\n      @Override\n      public Comparator<BaseInjection> getComparator() {\n        return languageComparator;\n      }\n\n      @Override\n      public TableCellRenderer getRenderer(final BaseInjection injection) {\n        return languageCellRenderer;\n      }\n    }};\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static Set<String> getActiveInjectionSupportIds() {\n    return ContainerUtil.map2Set(Extensions.getExtensions(LanguageInjectionSupport.EP_NAME), new NotNullFunction<LanguageInjectionSupport, String>() {\n      @NotNull\n      public String fun(final LanguageInjectionSupport support) {\n        return support.getId();\n      }\n    });\n  }","id":35702,"modified_method":"@NotNull\n  public static Set<String> getActiveInjectionSupportIds() {\n    return ContainerUtil.map2Set(getActiveInjectionSupports(), new NotNullFunction<LanguageInjectionSupport, String>() {\n      @NotNull\n      public String fun(final LanguageInjectionSupport support) {\n        return support.getId();\n      }\n    });\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static LanguageInjectionSupport findInjectionSupport(final String id) {\n    return ContainerUtil.find(Extensions.getExtensions(LanguageInjectionSupport.EP_NAME), new Condition<LanguageInjectionSupport>() {\n      public boolean value(final LanguageInjectionSupport support) {\n        return support.getId().equals(id);\n      }\n    });\n  }","id":35703,"modified_method":"@Nullable\n  public static LanguageInjectionSupport findInjectionSupport(final String id) {\n    return ContainerUtil.find(getActiveInjectionSupports(), new Condition<LanguageInjectionSupport>() {\n      public boolean value(final LanguageInjectionSupport support) {\n        return support.getId().equals(id);\n      }\n    });\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doEditInjection(final Project project, final MethodParameterInjection template, final PsiMethod contextMethod) {\n    final Configuration configuration = Configuration.getInstance();\n    template.initializePlaces(false);\n    final BaseInjection baseTemplate = new BaseInjection(template.getSupportId()).copyFrom(template);\n    final MethodParameterInjection allMethodParameterInjection = createMethodParameterInjection(baseTemplate, contextMethod, true);\n    allMethodParameterInjection.initializePlaces(false);\n    // find existing injection for this class.\n    final BaseInjection originalInjection = configuration.findExistingInjection(allMethodParameterInjection);\n    final MethodParameterInjection methodParameterInjection;\n    if (originalInjection == null) {\n      methodParameterInjection = template;\n    }\n    else {\n      final BaseInjection originalCopy = originalInjection.copy();\n      final InjectionPlace currentPlace = template.getInjectionPlaces().get(0);\n      final String text = currentPlace.getText();\n      originalCopy.setPlaceEnabled(text, true);\n      methodParameterInjection = createMethodParameterInjection(originalCopy, contextMethod, false);\n    }\n    if (InjectLanguageAction.doEditConfigurable(project, new MethodParameterInjectionConfigurable(methodParameterInjection, null, project))) {\n      methodParameterInjection.initializePlaces(false);\n      final BaseInjection newInjection = new BaseInjection(methodParameterInjection.getSupportId()).copyFrom(methodParameterInjection);\n      newInjection.mergeOriginalPlacesFrom(originalInjection, true);\n      Configuration.getInstance().replaceInjectionsWithUndo(\n        project, Collections.singletonList(newInjection),\n        ContainerUtil.createMaybeSingletonList(originalInjection),\n        Collections.<PsiElement>emptyList());\n    }\n  }","id":35704,"modified_method":"private static void doEditInjection(final Project project, final MethodParameterInjection template, final PsiMethod contextMethod) {\n    final Configuration configuration = Configuration.getInstance();\n    template.initializePlaces(false);\n    final BaseInjection baseTemplate = new BaseInjection(template.getSupportId()).copyFrom(template);\n    final MethodParameterInjection allMethodParameterInjection = createMethodParameterInjection(project, baseTemplate, contextMethod, true);\n    allMethodParameterInjection.initializePlaces(false);\n    // find existing injection for this class.\n    final BaseInjection originalInjection = configuration.findExistingInjection(allMethodParameterInjection);\n    final MethodParameterInjection methodParameterInjection;\n    if (originalInjection == null) {\n      methodParameterInjection = template;\n    }\n    else {\n      final BaseInjection originalCopy = originalInjection.copy();\n      final InjectionPlace currentPlace = template.getInjectionPlaces().get(0);\n      final String text = currentPlace.getText();\n      originalCopy.setPlaceEnabled(text, true);\n      methodParameterInjection = createMethodParameterInjection(project, originalCopy, contextMethod, false);\n    }\n    if (InjectLanguageAction.doEditConfigurable(project, new MethodParameterInjectionConfigurable(methodParameterInjection, null, project))) {\n      methodParameterInjection.initializePlaces(false);\n      final BaseInjection newInjection = new BaseInjection(methodParameterInjection.getSupportId()).copyFrom(methodParameterInjection);\n      newInjection.mergeOriginalPlacesFrom(originalInjection, true);\n      Configuration.getInstance().replaceInjectionsWithUndo(\n        project, Collections.singletonList(newInjection),\n        ContainerUtil.createMaybeSingletonList(originalInjection),\n        Collections.<PsiElement>emptyList());\n    }\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static MethodParameterInjection createMethodParameterInjection(final BaseInjection injection,\n                                                                         final PsiMethod contextMethod,\n                                                                         final boolean includeAllPlaces) {\n    final PsiClass containingClass = contextMethod.getContainingClass();\n    final String className = containingClass == null ? \"\" : StringUtil.notNullize(containingClass.getQualifiedName());\n    final MethodParameterInjection result = new MethodParameterInjection();\n    result.copyFrom(injection);\n    result.getInjectionPlaces().clear();\n    result.setClassName(className);\n    if (containingClass != null) {\n      final ArrayList<MethodParameterInjection.MethodInfo> infos = new ArrayList<MethodParameterInjection.MethodInfo>();\n      for (PsiMethod method : containingClass.getMethods()) {\n        final PsiModifierList modifiers = method.getModifierList();\n        if (modifiers.hasModifierProperty(PsiModifier.PRIVATE) || modifiers.hasModifierProperty(PsiModifier.PACKAGE_LOCAL)) continue;\n        boolean add = false;\n        final MethodParameterInjection.MethodInfo methodInfo = MethodParameterInjection.createMethodInfo(method);\n        if (MethodParameterInjection.isInjectable(method.getReturnType(), method.getProject())) {\n          final int parameterIndex = -1;\n          final InjectionPlace place = injection.findPlaceByText(getPatternStringForJavaPlace(method, parameterIndex));\n          methodInfo.setReturnFlag(place != null && place.isEnabled() || includeAllPlaces);\n          add = true;\n        }\n        final PsiParameter[] parameters = method.getParameterList().getParameters();\n        for (int i = 0; i < parameters.length; i++) {\n          final PsiParameter p = parameters[i];\n          if (MethodParameterInjection.isInjectable(p.getType(), p.getProject())) {\n            final InjectionPlace place = injection.findPlaceByText(getPatternStringForJavaPlace(method, i));\n            methodInfo.getParamFlags()[i] = place != null && place.isEnabled() || includeAllPlaces;\n            add = true;\n          }\n        }\n        if (add) {\n          infos.add(methodInfo);\n        }\n      }\n      result.setMethodInfos(infos);\n    }\n    return result;\n  }","id":35705,"modified_method":"private static MethodParameterInjection createMethodParameterInjection(final Project project,\n                                                                         final BaseInjection injection,\n                                                                         final PsiMethod contextMethod,\n                                                                         final boolean includeAllPlaces) {\n    final PsiClass containingClass;\n    if (contextMethod != null) {\n      containingClass = contextMethod.getContainingClass();\n    }\n    else {\n      String found = null;\n      final Pattern pattern = Pattern.compile(\".*definedInClass\\\\(\\\"([^\\\"]*)\\\"\\\\)+\");\n      for (InjectionPlace place : injection.getInjectionPlaces()) {\n        final Matcher matcher = pattern.matcher(place.getText());\n        if (matcher.matches()) {\n          found = matcher.group(1);\n        }\n      }\n      containingClass = found != null? JavaPsiFacade.getInstance(project).findClass(found, GlobalSearchScope.allScope(project)) : null;\n    }\n    final String className = containingClass == null ? \"\" : StringUtil.notNullize(containingClass.getQualifiedName());\n    final MethodParameterInjection result = new MethodParameterInjection();\n    result.copyFrom(injection);\n    result.getInjectionPlaces().clear();\n    result.setClassName(className);\n    if (containingClass != null) {\n      final ArrayList<MethodParameterInjection.MethodInfo> infos = new ArrayList<MethodParameterInjection.MethodInfo>();\n      for (PsiMethod method : containingClass.getMethods()) {\n        final PsiModifierList modifiers = method.getModifierList();\n        if (modifiers.hasModifierProperty(PsiModifier.PRIVATE) || modifiers.hasModifierProperty(PsiModifier.PACKAGE_LOCAL)) continue;\n        boolean add = false;\n        final MethodParameterInjection.MethodInfo methodInfo = MethodParameterInjection.createMethodInfo(method);\n        if (MethodParameterInjection.isInjectable(method.getReturnType(), method.getProject())) {\n          final int parameterIndex = -1;\n          final InjectionPlace place = injection.findPlaceByText(getPatternStringForJavaPlace(method, parameterIndex));\n          methodInfo.setReturnFlag(place != null && place.isEnabled() || includeAllPlaces);\n          add = true;\n        }\n        final PsiParameter[] parameters = method.getParameterList().getParameters();\n        for (int i = 0; i < parameters.length; i++) {\n          final PsiParameter p = parameters[i];\n          if (MethodParameterInjection.isInjectable(p.getType(), p.getProject())) {\n            final InjectionPlace place = injection.findPlaceByText(getPatternStringForJavaPlace(method, i));\n            methodInfo.getParamFlags()[i] = place != null && place.isEnabled() || includeAllPlaces;\n            add = true;\n          }\n        }\n        if (add) {\n          infos.add(methodInfo);\n        }\n      }\n      result.setMethodInfos(infos);\n    }\n    return result;\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean editInjectionInPlace(final PsiLanguageInjectionHost psiElement) {\n    if (!isMine(psiElement)) return false;\n    final Configuration configuration = Configuration.getInstance();\n    final HashMap<BaseInjection, ConcatenationInjector.Info> injectionsMap = new HashMap<BaseInjection, ConcatenationInjector.Info>();\n    final ArrayList<PsiAnnotation> annotations = new ArrayList<PsiAnnotation>();\n    final PsiLiteralExpression host = (PsiLiteralExpression)psiElement;\n    final Project project = host.getProject();\n    collectInjections(host, configuration, injectionsMap, annotations);\n    if (injectionsMap.isEmpty() || !annotations.isEmpty()) return false;\n\n    final BaseInjection originalInjection = injectionsMap.keySet().iterator().next();\n    final MethodParameterInjection methodParameterInjection = createMethodParameterInjection(originalInjection, injectionsMap.get(originalInjection).method, false);\n    final MethodParameterInjection savedCopy = methodParameterInjection.copy();\n    final AbstractInjectionPanel panel = new MethodParameterPanel(methodParameterInjection, project);\n    panel.reset();\n    final DialogBuilder builder = new DialogBuilder(project);\n    builder.addOkAction();\n    builder.addCancelAction();\n    builder.setCenterPanel(panel.getComponent());\n    builder.setTitle(EditInjectionSettingsAction.EDIT_INJECTION_TITLE);\n    builder.setOkOperation(new Runnable() {\n      public void run() {\n        panel.apply();\n        builder.getDialogWrapper().close(DialogWrapper.OK_EXIT_CODE);\n      }\n    });\n    if (builder.show() == DialogWrapper.OK_EXIT_CODE) {\n      methodParameterInjection.initializePlaces(false);\n      savedCopy.initializePlaces(false);\n      methodParameterInjection.mergeOriginalPlacesFrom(savedCopy, false);\n      final BaseInjection newInjection = new BaseInjection(methodParameterInjection.getSupportId()).copyFrom(methodParameterInjection);\n      newInjection.mergeOriginalPlacesFrom(originalInjection, true);\n      final List<BaseInjection> newInjections =\n        newInjection.isEnabled()? Collections.singletonList(newInjection) : Collections.<BaseInjection>emptyList();\n      Configuration.getInstance().replaceInjectionsWithUndo(project, newInjections, Collections.singletonList(originalInjection),\n                          Collections.<PsiAnnotation>emptyList());\n    }\n    return true;\n\n  }","id":35706,"modified_method":"public boolean editInjectionInPlace(final PsiLanguageInjectionHost psiElement) {\n    if (!isMine(psiElement)) return false;\n    final Configuration configuration = Configuration.getInstance();\n    final HashMap<BaseInjection, ConcatenationInjector.Info> injectionsMap = new HashMap<BaseInjection, ConcatenationInjector.Info>();\n    final ArrayList<PsiAnnotation> annotations = new ArrayList<PsiAnnotation>();\n    final PsiLiteralExpression host = (PsiLiteralExpression)psiElement;\n    final Project project = host.getProject();\n    collectInjections(host, configuration, injectionsMap, annotations);\n    if (injectionsMap.isEmpty() || !annotations.isEmpty()) return false;\n\n    final BaseInjection originalInjection = injectionsMap.keySet().iterator().next();\n    final MethodParameterInjection methodParameterInjection = createMethodParameterInjection(psiElement.getProject(), originalInjection, injectionsMap.get(originalInjection).method, false);\n    final BaseInjection newInjection = showInjectionUI(project, methodParameterInjection);\n    if (newInjection != null) {\n      newInjection.mergeOriginalPlacesFrom(originalInjection, true);\n      final List<BaseInjection> newInjections =\n        newInjection.isEnabled() ? Collections.singletonList(newInjection) : Collections.<BaseInjection>emptyList();\n      Configuration.getInstance().replaceInjectionsWithUndo(project, newInjections, Collections.singletonList(originalInjection),\n                                                            Collections.<PsiAnnotation>emptyList());\n    }\n    return true;\n\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MethodParameterPanel(MethodParameterInjection injection, final Project project) {\n    super(injection, project);\n\n    myClassField = new ReferenceEditorWithBrowseButton(new BrowseClassListener(project), project, new Function<String, Document>() {\n      public Document fun(String s) {\n        final Document document = PsiUtilEx.createDocument(s, project);\n        document.addDocumentListener(new DocumentAdapter() {\n          @Override\n          public void documentChanged(final DocumentEvent e) {\n            updateParamTree();\n            updateTree();\n          }\n        });\n        return document;\n      }\n    }, \"\");\n    myClassPanel.add(myClassField, BorderLayout.CENTER);\n    myParamsTable.getTree().setShowsRootHandles(true);\n    myParamsTable.getTree().setCellRenderer(new ColoredTreeCellRenderer() {\n\n      public void customizeCellRenderer(final JTree tree,\n                                        final Object value,\n                                        final boolean selected,\n                                        final boolean expanded,\n                                        final boolean leaf,\n                                        final int row,\n                                        final boolean hasFocus) {\n\n        final Object o = ((DefaultMutableTreeNode)value).getUserObject();\n        setIcon(o instanceof PsiMethod ? Icons.METHOD_ICON : o instanceof PsiParameter ? Icons.PARAMETER_ICON : null);\n        final String name;\n        if (o instanceof PsiMethod) {\n          name = PsiFormatUtil.formatMethod((PsiMethod)o, PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_PARAMETERS,\n                                            PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_TYPE);\n        }\n        else if (o instanceof PsiParameter) {\n          name = PsiFormatUtil.formatVariable((PsiParameter)o, PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_TYPE, PsiSubstitutor.EMPTY);\n        }\n        else name = null;\n        final boolean missing = o instanceof PsiElement && !((PsiElement)o).isPhysical();\n        if (name != null) {\n          append(name, missing? SimpleTextAttributes.ERROR_ATTRIBUTES : SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n      }\n\n    });\n    init(injection.copy());\n    PeerFactory.getInstance().getUIHelper().installTreeTableSpeedSearch(myParamsTable, new Convertor<TreePath, String>() {\n      @Nullable\n      public String convert(final TreePath o) {\n        final Object userObject = ((DefaultMutableTreeNode)o.getLastPathComponent()).getUserObject();\n        return userObject instanceof PsiNamedElement? ((PsiNamedElement)userObject).getName() : null;\n      }\n    });\n  }","id":35707,"modified_method":"public MethodParameterPanel(MethodParameterInjection injection, final Project project) {\n    super(injection, project);\n\n    myClassField = new ReferenceEditorWithBrowseButton(new BrowseClassListener(project), project, new Function<String, Document>() {\n      public Document fun(String s) {\n        final Document document = PsiUtilEx.createDocument(s, project);\n        document.addDocumentListener(new DocumentAdapter() {\n          @Override\n          public void documentChanged(final DocumentEvent e) {\n            updateParamTree();\n            updateTree();\n          }\n        });\n        return document;\n      }\n    }, \"\");\n    myClassPanel.add(myClassField, BorderLayout.CENTER);\n    myParamsTable.getTree().setShowsRootHandles(true);\n    myParamsTable.getTree().setCellRenderer(new ColoredTreeCellRenderer() {\n\n      public void customizeCellRenderer(final JTree tree,\n                                        final Object value,\n                                        final boolean selected,\n                                        final boolean expanded,\n                                        final boolean leaf,\n                                        final int row,\n                                        final boolean hasFocus) {\n\n        final Object o = ((DefaultMutableTreeNode)value).getUserObject();\n        setIcon(o instanceof PsiMethod ? Icons.METHOD_ICON : o instanceof PsiParameter ? Icons.PARAMETER_ICON : null);\n        final String name;\n        if (o instanceof PsiMethod) {\n          name = PsiFormatUtil.formatMethod((PsiMethod)o, PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_PARAMETERS,\n                                            PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_TYPE);\n        }\n        else if (o instanceof PsiParameter) {\n          name = PsiFormatUtil.formatVariable((PsiParameter)o, PsiFormatUtil.SHOW_NAME | PsiFormatUtil.SHOW_TYPE, PsiSubstitutor.EMPTY);\n        }\n        else name = null;\n        final boolean missing = o instanceof PsiElement && !((PsiElement)o).isPhysical();\n        if (name != null) {\n          append(name, missing? SimpleTextAttributes.ERROR_ATTRIBUTES : SimpleTextAttributes.REGULAR_ATTRIBUTES);\n        }\n      }\n\n    });\n    init(injection.copy());\n    PeerFactory.getInstance().getUIHelper().installTreeTableSpeedSearch(myParamsTable, new Convertor<TreePath, String>() {\n      @Nullable\n      public String convert(final TreePath o) {\n        final Object userObject = ((DefaultMutableTreeNode)o.getLastPathComponent()).getUserObject();\n        return userObject instanceof PsiNamedElement? ((PsiNamedElement)userObject).getName() : null;\n      }\n    });\n    new AnAction(\"Toggle\") {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performToggleAction();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0)), myParamsTable);\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ColumnInfo[] createColumnInfos() {\n    return new ColumnInfo[]{\n        new ColumnInfo<DefaultMutableTreeNode, Boolean>(\" \") { // \"\" for the first column's name isn't a good idea\n          final BooleanTableCellRenderer myRenderer = new BooleanTableCellRenderer();\n\n          public Boolean valueOf(DefaultMutableTreeNode o) {\n            final Object userObject = o.getUserObject();\n            if (userObject instanceof PsiMethod) {\n              final PsiMethod method = (PsiMethod)userObject;\n              return MethodParameterInjection.isInjectable(method.getReturnType(), method.getProject()) ?\n                     myData.get(method).isReturnFlag() : null;\n            }\n            else if (userObject instanceof PsiParameter) {\n              final PsiMethod method = getMethod(o);\n              final PsiParameter parameter = (PsiParameter)userObject;\n              final int index = method.getParameterList().getParameterIndex(parameter);\n              return MethodParameterInjection.isInjectable(parameter.getType(), method.getProject()) ?\n                     myData.get(method).getParamFlags()[index] : null;\n            }\n            return null;\n          }\n\n          public int getWidth(JTable table) {\n            return myRenderer.getPreferredSize().width;\n          }\n\n          public TableCellEditor getEditor(DefaultMutableTreeNode o) {\n            return new DefaultCellEditor(new JCheckBox());\n          }\n\n          public TableCellRenderer getRenderer(DefaultMutableTreeNode o) {\n            myRenderer.setEnabled(isCellEditable(o));\n            return myRenderer;\n          }\n\n          public void setValue(DefaultMutableTreeNode o, Boolean value) {\n            final Object userObject = o.getUserObject();\n            if (userObject instanceof PsiMethod) {\n              myData.get((PsiMethod)userObject).setReturnFlag(Boolean.TRUE.equals(value));\n            }\n            else if (userObject instanceof PsiParameter) {\n              final PsiMethod method = getMethod(o);\n              final int index = method.getParameterList().getParameterIndex((PsiParameter)userObject);\n              myData.get(method).getParamFlags()[index] = Boolean.TRUE.equals(value);\n            }\n          }\n\n          public Class<Boolean> getColumnClass() {\n            return Boolean.class;\n          }\n\n          public boolean isCellEditable(DefaultMutableTreeNode o) {\n            return valueOf(o) != null;\n          }\n\n          private PsiMethod getMethod(final DefaultMutableTreeNode o) {\n            return (PsiMethod)((DefaultMutableTreeNode)o.getParent()).getUserObject();\n          }\n\n\n        }, new TreeColumnInfo(\"Method/Parameters\")\n    };\n  }","id":35708,"modified_method":"private ColumnInfo[] createColumnInfos() {\n    return new ColumnInfo[]{\n        new ColumnInfo<DefaultMutableTreeNode, Boolean>(\" \") { // \"\" for the first column's name isn't a good idea\n          final BooleanTableCellRenderer myRenderer = new BooleanTableCellRenderer();\n\n          public Boolean valueOf(DefaultMutableTreeNode o) {\n            return isNodeSelected(o);\n          }\n\n          public int getWidth(JTable table) {\n            return myRenderer.getPreferredSize().width;\n          }\n\n          public TableCellEditor getEditor(DefaultMutableTreeNode o) {\n            return new DefaultCellEditor(new JCheckBox());\n          }\n\n          public TableCellRenderer getRenderer(DefaultMutableTreeNode o) {\n            myRenderer.setEnabled(isCellEditable(o));\n            return myRenderer;\n          }\n\n          public void setValue(DefaultMutableTreeNode o, Boolean value) {\n            setNodeSelected(o, Boolean.TRUE.equals(value));\n          }\n\n          public Class<Boolean> getColumnClass() {\n            return Boolean.class;\n          }\n\n          public boolean isCellEditable(DefaultMutableTreeNode o) {\n            return valueOf(o) != null;\n          }\n\n        }, new TreeColumnInfo(\"Method/Parameters\")\n    };\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static BaseInjection createFrom(final BaseInjection injection, final XmlText xmlText) {\n    final XmlTagInjection result = new XmlTagInjection().copyFrom(injection);\n    result.getInjectionPlaces().clear();\n    final XmlTag xmlTag = xmlText.getParentTag();\n    if (xmlTag == null) return null;\n    for (InjectionPlace place : injection.getInjectionPlaces()) {\n      if (place.isEnabled() && place.getElementPattern() != null && place.getElementPattern().accepts(xmlTag)) {\n        final Matcher matcher = Pattern.compile(\"withLocalName[^\\\"]*\\\"([^\\\"]*)\\\".*withNamespace[^\\\"]*\\\"([^\\\"]*)\\\"\").matcher(place.getText());\n        if (matcher.find()) {\n          result.setTagName(matcher.group(1));\n          result.setTagNamespace(matcher.group(2));\n        }\n        if (injection instanceof AbstractTagInjection) {\n          result.setApplyToSubTagTexts(((AbstractTagInjection)injection).isApplyToSubTagTexts());\n        }\n      }\n    }\n    return result;\n  }","id":35709,"modified_method":"@Nullable\n  private static BaseInjection createFrom(final BaseInjection injection, final PsiLanguageInjectionHost host) {\n    final PsiElement element;\n    AbstractTagInjection result;\n    if (host instanceof XmlText) {\n      final XmlTag xmlTag = ((XmlText)host).getParentTag();\n      if (xmlTag == null) return null;\n      element = xmlTag;\n      result = new XmlTagInjection().copyFrom(injection);\n    }\n    else if (host instanceof XmlAttributeValue) {\n      final PsiElement parent = host.getParent();\n      if (!(parent instanceof XmlAttribute)) return null;\n      element = parent;\n      result = new XmlAttributeInjection().copyFrom(injection);\n    }\n    else {\n      result = null;\n      element = null;\n    }\n    final Pattern pattern = Pattern.compile(\"withLocalName[^\\\"]*\\\"([^\\\"]*)\\\"\\\\)+(?:\\\\.withNamespace[^\\\"]*\\\"([^\\\"]*)\\\")?\");\n    for (InjectionPlace place : injection.getInjectionPlaces()) {\n      if (place.isEnabled() && place.getElementPattern() != null && (element == null || place.getElementPattern().accepts(element))) {\n        final Matcher matcher = pattern.matcher(place.getText());\n        if (matcher.find()) {\n          final Pair<String, String> pair1 = Pair.create(matcher.group(1), matcher.group(2));\n          final Pair<String, String> pair2;\n          if (matcher.find(Math.max(matcher.end(1), matcher.end(2)))) {\n            pair2 = Pair.create(matcher.group(1), matcher.group(2));\n          }\n          else pair2 = null;\n\n          if (result == null) {\n            if (place.getText().startsWith(\"xmlTag\")) result = new XmlTagInjection().copyFrom(injection);\n            if (place.getText().startsWith(\"xmlAttribute\")) result = new XmlAttributeInjection().copyFrom(injection);\n            else continue;\n          }\n          if (result instanceof XmlAttributeInjection) {\n            ((XmlAttributeInjection)result).setAttributeName(pair1.first);\n            ((XmlAttributeInjection)result).setAttributeNamespace(StringUtil.notNullize(pair1.second));\n            if (pair2 != null) {\n              result.setTagName(pair2.first);\n              result.setTagNamespace(pair2.second);\n            }\n          }\n          else if (result instanceof XmlTagInjection) {\n            result.setTagName(pair1.first);\n            result.setTagNamespace(StringUtil.notNullize(pair1.second));\n          }\n          else continue;\n          // for debugging\n          //result.initializePlaces(false);\n          //if (!place.getText().equals(result.getInjectionPlaces().get(0).getText())) {\n          //}\n          break;\n        }\n      }\n    }\n    if (result != null) result.getInjectionPlaces().clear();\n    return result;\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean editInjectionInPlace(final PsiLanguageInjectionHost host) {\n    if (!isMine(host)) return false;\n    final Configuration configuration = Configuration.getInstance();\n    final ArrayList<BaseInjection> injections = collectInjections(host, configuration);\n    if (injections.isEmpty()) return false;\n    final Project project = host.getProject();\n    final BaseInjection originalInjection = injections.get(0);\n    final BaseInjection xmlInjection;\n\n    final AbstractInjectionPanel panel;\n    if (host instanceof XmlText) {\n      xmlInjection = createFrom(originalInjection, (XmlText)host);\n      panel = new XmlTagPanel((XmlTagInjection)xmlInjection, project);\n    }\n    else if (host instanceof XmlAttributeValue) {\n      xmlInjection = createFrom(originalInjection, (XmlAttributeValue)host);\n      panel = new XmlAttributePanel((XmlAttributeInjection)xmlInjection, project);\n    }\n    else {\n      return false;\n    }\n    if (xmlInjection == null) return false;\n    panel.reset();\n    final DialogBuilder builder = new DialogBuilder(project);\n    builder.addOkAction();\n    builder.addCancelAction();\n    builder.setCenterPanel(panel.getComponent());\n    builder.setTitle(EditInjectionSettingsAction.EDIT_INJECTION_TITLE);\n    builder.setOkOperation(new Runnable() {\n      public void run() {\n        panel.apply();\n        builder.getDialogWrapper().close(DialogWrapper.OK_EXIT_CODE);\n      }\n    });\n    if (builder.show() == DialogWrapper.OK_EXIT_CODE) {\n      xmlInjection.initializePlaces(false);\n      final AbstractTagInjection newInjection = new AbstractTagInjection().copyFrom(xmlInjection);\n      newInjection.mergeOriginalPlacesFrom(originalInjection, true);\n      Configuration.getInstance().replaceInjectionsWithUndo(\n        project, Collections.singletonList(xmlInjection),\n        Collections.singletonList(originalInjection),\n        Collections.<PsiElement>emptyList());\n    }\n    return true;\n  }","id":35710,"modified_method":"public boolean editInjectionInPlace(final PsiLanguageInjectionHost host) {\n    if (!isMine(host)) return false;\n    final Configuration configuration = Configuration.getInstance();\n    final ArrayList<BaseInjection> injections = collectInjections(host, configuration);\n    if (injections.isEmpty()) return false;\n    final Project project = host.getProject();\n    final BaseInjection originalInjection = injections.get(0);\n    final BaseInjection xmlInjection = createFrom(originalInjection, host);\n    if (xmlInjection == null) return false;\n    final AbstractTagInjection newInjection = showInjectionUI(project, xmlInjection);\n    if (newInjection != null) {\n      newInjection.mergeOriginalPlacesFrom(originalInjection, true);\n      Configuration.getInstance().replaceInjectionsWithUndo(\n        project, Collections.singletonList(xmlInjection),\n        Collections.singletonList(originalInjection),\n        Collections.<PsiElement>emptyList());\n    }\n    return true;\n  }","commit_id":"0598d7a0af4507d4debf6c88466c0765b9ebb5b3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doEditInjection(final Project project, final MethodParameterInjection template, final PsiMethod contextMethod) {\n    final Configuration configuration = InjectorUtils.getEditableInstance(project);\n    final BaseInjection baseTemplate = new BaseInjection(template.getSupportId()).copyFrom(template);\n    final MethodParameterInjection allMethodParameterInjection = createFrom(project, baseTemplate, contextMethod, true);\n    // find existing injection for this class.\n    final BaseInjection originalInjection = configuration.findExistingInjection(allMethodParameterInjection);\n    final MethodParameterInjection methodParameterInjection;\n    if (originalInjection == null) {\n      methodParameterInjection = template;\n    }\n    else {\n      final BaseInjection originalCopy = originalInjection.copy();\n      final InjectionPlace currentPlace = template.getInjectionPlaces()[0];\n      originalCopy.mergeOriginalPlacesFrom(template, true);\n      originalCopy.setPlaceEnabled(currentPlace.getText(), true);\n      methodParameterInjection = createFrom(project, originalCopy, contextMethod, false);\n    }\n    if (InjectLanguageAction.doEditConfigurable(project, new MethodParameterInjectionConfigurable(methodParameterInjection, null, project))) {\n      final BaseInjection newInjection = new BaseInjection(methodParameterInjection.getSupportId()).copyFrom(methodParameterInjection);\n      if (originalInjection != null) {\n        newInjection.mergeOriginalPlacesFrom(originalInjection, true);\n      }\n      configuration.replaceInjectionsWithUndo(\n        project, Collections.singletonList(newInjection),\n        ContainerUtil.createMaybeSingletonList(originalInjection),\n        Collections.<PsiElement>emptyList());\n    }\n  }","id":35711,"modified_method":"private static void doEditInjection(final Project project, final MethodParameterInjection template, final PsiMethod contextMethod) {\n    final Configuration configuration = InjectorUtils.getEditableInstance(project);\n    final BaseInjection baseTemplate = new BaseInjection(template.getSupportId()).copyFrom(template);\n    final MethodParameterInjection allMethodParameterInjection = createFrom(project, baseTemplate, contextMethod, true);\n    // find existing injection for this class.\n    final BaseInjection originalInjection = configuration.findExistingInjection(allMethodParameterInjection);\n    final MethodParameterInjection methodParameterInjection;\n    if (originalInjection == null) {\n      methodParameterInjection = template;\n    }\n    else {\n      final BaseInjection originalCopy = originalInjection.copy();\n      final InjectionPlace currentPlace = template.getInjectionPlaces()[0];\n      originalCopy.mergeOriginalPlacesFrom(template, true);\n      originalCopy.setPlaceEnabled(currentPlace.getText(), true);\n      methodParameterInjection = createFrom(project, originalCopy, contextMethod, false);\n    }\n    mergePlacesAndAddToConfiguration(project, configuration, methodParameterInjection, originalInjection);\n  }","commit_id":"f5ade744d2662303d4910508f885b436371f0f70","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doEditInjection(final Project project, final XmlTagInjection template) {\n    final Configuration configuration = InjectorUtils.getEditableInstance(project);\n    final AbstractTagInjection originalInjection = (AbstractTagInjection)configuration.findExistingInjection(template);\n\n    final XmlTagInjection newInjection = originalInjection == null? template : new XmlTagInjection().copyFrom(originalInjection);\n    if (InjectLanguageAction.doEditConfigurable(project, new XmlTagInjectionConfigurable(newInjection, null, project))) {\n      configuration.replaceInjectionsWithUndo(\n        project, Collections.singletonList(newInjection),\n        ContainerUtil.createMaybeSingletonList(originalInjection),\n        Collections.<PsiElement>emptyList());\n    }\n  }","id":35712,"modified_method":"private static void doEditInjection(final Project project, final XmlTagInjection template) {\n    final Configuration configuration = InjectorUtils.getEditableInstance(project);\n    final AbstractTagInjection originalInjection = (AbstractTagInjection)configuration.findExistingInjection(template);\n\n    final XmlTagInjection newInjection = originalInjection == null? template : new XmlTagInjection().copyFrom(originalInjection);\n    configuration.replaceInjectionsWithUndo(\n      project, Collections.singletonList(newInjection),\n      ContainerUtil.createMaybeSingletonList(originalInjection),\n      Collections.<PsiElement>emptyList());\n  }","commit_id":"f5ade744d2662303d4910508f885b436371f0f70","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void doEditInjection(final Project project, final XmlAttributeInjection template) {\n    final Configuration configuration = InjectorUtils.getEditableInstance(project);\n    final BaseInjection originalInjection = configuration.findExistingInjection(template);\n    final BaseInjection newInjection = originalInjection == null ? template : originalInjection.copy();\n    if (InjectLanguageAction.doEditConfigurable(project, new XmlAttributeInjectionConfigurable((XmlAttributeInjection)newInjection, null, project))) {\n      configuration.replaceInjectionsWithUndo(\n        project, Collections.singletonList(newInjection),\n        ContainerUtil.createMaybeSingletonList(originalInjection),\n        Collections.<PsiElement>emptyList());\n    }\n  }","id":35713,"modified_method":"private static void doEditInjection(final Project project, final XmlAttributeInjection template) {\n    final Configuration configuration = InjectorUtils.getEditableInstance(project);\n    final BaseInjection originalInjection = configuration.findExistingInjection(template);\n    final BaseInjection newInjection = originalInjection == null ? template : originalInjection.copy();\n    configuration.replaceInjectionsWithUndo(\n      project, Collections.singletonList(newInjection),\n      ContainerUtil.createMaybeSingletonList(originalInjection),\n      Collections.<PsiElement>emptyList());\n  }","commit_id":"f5ade744d2662303d4910508f885b436371f0f70","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Checks the status of a Program\n   *\n   * @param token\n   * @param id\n   */\n  @Override\n  public FlowStatus status(AuthToken token, FlowIdentifier id)\n    throws AppFabricServiceException, TException {\n\n    try {\n      ProgramRuntimeService.RuntimeInfo runtimeInfo = findRuntimeInfo(id);\n\n      int version = 1;  // FIXME, how to get version?\n      if (runtimeInfo == null) {\n        return new FlowStatus(id.getApplicationId(), id.getFlowId(),\n                              version, null, ProgramController.State.STOPPED.toString());\n      }\n\n      Id.Program programId = runtimeInfo.getProgramId();\n      RunIdentifier runId = new RunIdentifier(runtimeInfo.getController().getRunId().getId());\n\n      // NOTE: This was a temporary hack done to map the status to something that is\n      // UI friendly. Internal states of program controller are reasonable and hence\n      // no point in changing them.\n      String status = controllerStateToString(runtimeInfo.getController().getState());\n      return new FlowStatus(programId.getApplicationId(), programId.getId(), version, runId, status);\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n  }","id":35714,"modified_method":"/**\n   * Checks the status of a Program\n   *\n   * @param token\n   * @param id\n   */\n  @Override\n  public FlowStatus status(AuthToken token, FlowIdentifier id)\n    throws AppFabricServiceException, TException {\n\n    try {\n      ProgramRuntimeService.RuntimeInfo runtimeInfo = findRuntimeInfo(id);\n\n      int version = 1;  // FIXME, how to get version?\n      if (runtimeInfo == null) {\n        return new FlowStatus(id.getApplicationId(), id.getFlowId(),\n                              version, null, ProgramController.State.STOPPED.toString());\n      }\n\n      Id.Program programId = runtimeInfo.getProgramId();\n      RunIdentifier runId = new RunIdentifier(runtimeInfo.getController().getRunId().getId());\n\n      // NOTE: This was a temporary hack done to map the status to something that is\n      // UI friendly. Internal states of program controller are reasonable and hence\n      // no point in changing them.\n      String status = controllerStateToString(runtimeInfo.getController().getState());\n      return new FlowStatus(programId.getApplicationId(), programId.getId(), version, runId, status);\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Promotes a FAR from single node to cloud.\n   *\n   * @param id of the flow.\n   * @return true if successful; false otherwise.\n   * @throws AppFabricServiceException\n   */\n  @Override\n  public boolean promote(AuthToken authToken, ResourceIdentifier id, String hostname)\n    throws AppFabricServiceException {\n    Preconditions.checkArgument(authToken.isSetToken(), \"API key is not set\");\n    Preconditions.checkArgument(!hostname.isEmpty(), \"Empty hostname passed.\");\n\n    final Location appArchive = getApplicationLocation(Id.Application.from(id.getAccountId(),\n                                                                               id.getApplicationId()));\n    try {\n      if(! appArchive.exists()) {\n        throw new AppFabricServiceException(\"Unable to locate the application.\");\n      }\n\n      String schema = \"https\";\n      if(\"localhost\".equals(hostname)) {\n        schema = \"http\";\n      }\n\n      int port = configuration.getInt( \"app.rest.port\", 10007);\n      String url = String.format(\"%s://%s:%d/app\", schema, hostname, port);\n      SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n        .setUrl(url)\n        .setRequestTimeoutInMs(UPLOAD_TIMEOUT)\n        .setHeader(\"X-Archive-Name\", appArchive.getName())\n        .setHeader(\"X-Continuuity-ApiKey\", authToken.getToken())\n        .build();\n\n      try {\n        Future<Response> future = client.put(new LocationBodyGenerator(appArchive));\n        Response response = future.get(UPLOAD_TIMEOUT, TimeUnit.MILLISECONDS);\n        if(response.getStatusCode() != 200) {\n          throw new RuntimeException(response.getResponseBody());\n        }\n        return true;\n      } finally {\n        client.close();\n      }\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getLocalizedMessage());\n    }\n  }","id":35715,"modified_method":"/**\n   * Promotes a FAR from single node to cloud.\n   *\n   * @param id of the flow.\n   * @return true if successful; false otherwise.\n   * @throws AppFabricServiceException\n   */\n  @Override\n  public boolean promote(AuthToken authToken, ResourceIdentifier id, String hostname)\n    throws AppFabricServiceException {\n    Preconditions.checkArgument(authToken.isSetToken(), \"API key is not set\");\n    Preconditions.checkArgument(!hostname.isEmpty(), \"Empty hostname passed.\");\n\n    final Location appArchive = getApplicationLocation(Id.Application.from(id.getAccountId(),\n                                                                               id.getApplicationId()));\n    try {\n      if(! appArchive.exists()) {\n        throw new AppFabricServiceException(\"Unable to locate the application.\");\n      }\n\n      String schema = \"https\";\n      if(\"localhost\".equals(hostname)) {\n        schema = \"http\";\n      }\n\n      int port = configuration.getInt( \"app.rest.port\", 10007);\n      String url = String.format(\"%s://%s:%d/app\", schema, hostname, port);\n      SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n        .setUrl(url)\n        .setRequestTimeoutInMs(UPLOAD_TIMEOUT)\n        .setHeader(\"X-Archive-Name\", appArchive.getName())\n        .setHeader(\"X-Continuuity-ApiKey\", authToken.getToken())\n        .build();\n\n      try {\n        Future<Response> future = client.put(new LocationBodyGenerator(appArchive));\n        Response response = future.get(UPLOAD_TIMEOUT, TimeUnit.MILLISECONDS);\n        if(response.getStatusCode() != 200) {\n          throw new RuntimeException(response.getResponseBody());\n        }\n        return true;\n      } finally {\n        client.close();\n      }\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getLocalizedMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Deletes metrics for a given account.\n   *\n   * @param account for which the metrics need to be reset.\n   * @throws AppFabricServiceException throw due to issue in reseting metrics for\n   * account.\n   */\n  private void deleteMetrics(String account) throws AppFabricServiceException {\n    try {\n      LOG.info(\"Deleting all metrics for account '\" + account + \"'.\");\n      MetricsFrontendServiceImpl mfs =\n        new MetricsFrontendServiceImpl(configuration);\n      mfs.reset(account);\n      LOG.info(\"All metrics for account '\" + account + \"'deleted.\");\n    } catch (Exception e) {\n      String message = String.format(\"Error clearing the metrics for \" +\n                                       \"account '%s': %s. At %s\", account, e.getMessage(),\n                                     StackTraceUtil.toStringStackTrace(e));\n      LOG.error(message, e);\n      throw new AppFabricServiceException(message);\n    }\n  }","id":35716,"modified_method":"/**\n   * Deletes metrics for a given account.\n   *\n   * @param account for which the metrics need to be reset.\n   * @throws AppFabricServiceException throw due to issue in reseting metrics for\n   * account.\n   */\n  private void deleteMetrics(String account) throws AppFabricServiceException {\n    try {\n      LOG.info(\"Deleting all metrics for account '\" + account + \"'.\");\n      MetricsFrontendServiceImpl mfs =\n        new MetricsFrontendServiceImpl(configuration);\n      mfs.reset(account);\n      LOG.info(\"All metrics for account '\" + account + \"'deleted.\");\n    } catch (Throwable throwable) {\n      String message = String.format(\"Error clearing the metrics for \" +\n                                       \"account '%s': %s. At %s\", account, throwable.getMessage(),\n                                     StackTraceUtil.toStringStackTrace(throwable));\n      LOG.error(message, throwable);\n      throw new AppFabricServiceException(message);\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void reset(AuthToken token, String account) throws AppFabricServiceException {\n    Preconditions.checkNotNull(account);\n\n    final Id.Account accountId = Id.Account.from(account);\n\n    // Check if any program is still running\n    Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n      @Override\n      public boolean apply(Id.Program programId) {\n        return programId.getAccountId().equals(accountId);\n      }\n    }, Type.values()), \"There are program still running under account \" + accountId.getId());\n\n\n    deleteMetrics(account);\n    // delete all meta data\n    try {\n      store.removeAll(accountId);\n    } catch (Exception e) {\n      String message = String.format(\"Error deleting all meta data for \" +\n                                       \"account '%s': %s. At %s\", account, e.getMessage(),\n                                     StackTraceUtil.toStringStackTrace(e));\n      LOG.error(message, e);\n      throw new AppFabricServiceException(message);\n    }\n\n    // wipe the data fabric\n    try {\n      LOG.info(\"Deleting all data for account '\" + account + \"'.\");\n      opex.execute(\n                    new OperationContext(account),\n                    new ClearFabric(ClearFabric.ToClear.ALL)\n      );\n      LOG.info(\"All data for account '\" + account + \"' deleted.\");\n    } catch (Exception e) {\n      String message = String.format(\"Error deleting the data for \" +\n                                       \"account '%s': %s. At %s\", account, e.getMessage(),\n                                     StackTraceUtil.toStringStackTrace(e));\n      LOG.error(message, e);\n      throw new AppFabricServiceException(message);\n    }\n  }","id":35717,"modified_method":"@Override\n  public void reset(AuthToken token, String account) throws AppFabricServiceException {\n    final Id.Account accountId;\n    try {\n      Preconditions.checkNotNull(account);\n      accountId = Id.Account.from(account);\n\n      // Check if any program is still running\n      Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.getAccountId().equals(accountId);\n        }\n      }, Type.values()), \"There are program still running under account \" + accountId.getId());\n\n\n      deleteMetrics(account);\n      // delete all meta data\n      store.removeAll(accountId);\n      LOG.info(\"Deleting all data for account '\" + account + \"'.\");\n      opex.execute(\n        new OperationContext(account),\n        new ClearFabric(ClearFabric.ToClear.ALL)\n      );\n      LOG.info(\"All data for account '\" + account + \"' deleted.\");\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to rest account \" + throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Deletes a program specified by {@code FlowIdentifier}.\n   *\n   * @param identifier of a flow.\n   * @throws AppFabricServiceException when there is an issue deactivating the flow.\n   */\n  @Override\n  public void remove(AuthToken token, FlowIdentifier identifier) throws AppFabricServiceException {\n    Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n    Id.Program programId = Id.Program.from(identifier.getAccountId(),\n                                           identifier.getApplicationId(),\n                                           identifier.getFlowId());\n\n    // Make sure it is not running\n    Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n      @Override\n      public boolean apply(Id.Program programId) {\n        return programId.equals(programId);\n      }\n    }, Type.values()), \"Program still running for application \" + programId.getApplication() + \",\" + programId.getId());\n\n\n    Type programType = entityTypeToType(identifier);\n    for (Map.Entry<RunId, ProgramRuntimeService.RuntimeInfo> entry : runtimeService.list(programType).entrySet()) {\n      Preconditions.checkState(!programId.equals(entry.getValue().getProgramId()),\n                               \"Program still running: application=%s, type=%s, program=%s\",\n                               programId.getApplication(), programType, programId.getId());\n    }\n\n    // Delete the program from store.\n    try {\n      store.remove(programId);\n    } catch (OperationException e) {\n      throw new AppFabricServiceException(\"Fail to delete program \" + e.getMessage());\n    }\n  }","id":35718,"modified_method":"/**\n   * Deletes a program specified by {@code FlowIdentifier}.\n   *\n   * @param identifier of a flow.\n   * @throws AppFabricServiceException when there is an issue deactivating the flow.\n   */\n  @Override\n  public void remove(AuthToken token, FlowIdentifier identifier) throws AppFabricServiceException {\n    try {\n      Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n\n      Id.Program programId = Id.Program.from(identifier.getAccountId(),\n                                             identifier.getApplicationId(),\n                                             identifier.getFlowId());\n\n      // Make sure it is not running\n      Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.equals(programId);\n        }\n      }, Type.values()), \"Program still running for application \" + programId.getApplication() + \",\" + programId.getId());\n\n\n      Type programType = entityTypeToType(identifier);\n      for (Map.Entry<RunId, ProgramRuntimeService.RuntimeInfo> entry : runtimeService.list(programType).entrySet()) {\n        Preconditions.checkState(!programId.equals(entry.getValue().getProgramId()),\n                                 \"Program still running: application=%s, type=%s, program=%s\",\n                                 programId.getApplication(), programType, programId.getId());\n      }\n      // Delete the program from store.\n      store.remove(programId);\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to delete program \" + throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns definition of a flow.\n   *\n   * @param id\n   */\n  @Override\n  public String getFlowDefinition(FlowIdentifier id)\n    throws AppFabricServiceException, TException {\n    try {\n      if(id.getType() == EntityType.FLOW) {\n        FlowDefinitionImpl flowDef = getFlowDef(id);\n        return new Gson().toJson(flowDef);\n      } else if(id.getType() == EntityType.QUERY) {\n        QueryDefinitionImpl queryDef = getQueryDefn(id);\n        return new Gson().toJson(queryDef);\n      }\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n    return null;\n  }","id":35719,"modified_method":"/**\n   * Returns definition of a flow.\n   *\n   * @param id\n   */\n  @Override\n  public String getFlowDefinition(FlowIdentifier id)\n    throws AppFabricServiceException, TException {\n    try {\n      if(id.getType() == EntityType.FLOW) {\n        FlowDefinitionImpl flowDef = getFlowDef(id);\n        return new Gson().toJson(flowDef);\n      } else if(id.getType() == EntityType.QUERY) {\n        QueryDefinitionImpl queryDef = getQueryDefn(id);\n        return new Gson().toJson(queryDef);\n      }\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n    return null;\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns run information for a given flow id.\n   *\n   * @param id of the program.\n   */\n  @Override\n  public List<FlowRunRecord> getFlowHistory(FlowIdentifier id) throws AppFabricServiceException, TException {\n    List<RunRecord> log;\n    try {\n      Id.Program programId = Id.Program.from(id.getAccountId(), id.getApplicationId(), id.getFlowId());\n      try {\n        log = store.getRunHistory(programId);\n      } catch(OperationException e) {\n        throw  new AppFabricServiceException(\"Unable to retrieve application for \" +\n                                             id.toString() + e.getMessage());\n      }\n      List<FlowRunRecord> history = new ArrayList<FlowRunRecord>();\n      for (RunRecord runRecord : log) {\n        history.add(new FlowRunRecord(runRecord.getPid(), runRecord.getStartTs(),\n                                      runRecord.getStopTs(),runRecord.getEndStatus())\n        );\n      }\n      return history;\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n  }","id":35720,"modified_method":"/**\n   * Returns run information for a given flow id.\n   *\n   * @param id of the program.\n   */\n  @Override\n  public List<FlowRunRecord> getFlowHistory(FlowIdentifier id) throws AppFabricServiceException, TException {\n    List<RunRecord> log;\n    try {\n      Id.Program programId = Id.Program.from(id.getAccountId(), id.getApplicationId(), id.getFlowId());\n      try {\n        log = store.getRunHistory(programId);\n      } catch(OperationException e) {\n        throw  new AppFabricServiceException(\"Unable to retrieve application for \" +\n                                             id.toString() + e.getMessage());\n      }\n      List<FlowRunRecord> history = new ArrayList<FlowRunRecord>();\n      for (RunRecord runRecord : log) {\n        history.add(new FlowRunRecord(runRecord.getPid(), runRecord.getStartTs(),\n                                      runRecord.getStopTs(),runRecord.getEndStatus())\n        );\n      }\n      return history;\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Stops a Program\n   *\n   * @param token\n   * @param identifier\n   */\n  @Override\n  public RunIdentifier stop(AuthToken token, FlowIdentifier identifier)\n    throws AppFabricServiceException, TException {\n    try {\n      ProgramRuntimeService.RuntimeInfo runtimeInfo = findRuntimeInfo(identifier);\n      Preconditions.checkNotNull(runtimeInfo, \"Unable to find runtime info for %s\", identifier);\n      ProgramController controller = runtimeInfo.getController();\n      RunId runId = controller.getRunId();\n      controller.stop().get();\n      store.setStop(runtimeInfo.getProgramId(), runId.getId(), System.currentTimeMillis() /1000,\n                    runtimeInfo.getController().getState().toString());\n      return new RunIdentifier(runId.getId());\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n  }","id":35721,"modified_method":"/**\n   * Stops a Program\n   *\n   * @param token\n   * @param identifier\n   */\n  @Override\n  public RunIdentifier stop(AuthToken token, FlowIdentifier identifier)\n    throws AppFabricServiceException, TException {\n    try {\n      ProgramRuntimeService.RuntimeInfo runtimeInfo = findRuntimeInfo(identifier);\n      Preconditions.checkNotNull(runtimeInfo, \"Unable to find runtime info for %s\", identifier);\n      ProgramController controller = runtimeInfo.getController();\n      RunId runId = controller.getRunId();\n      controller.stop().get();\n      store.setStop(runtimeInfo.getProgramId(), runId.getId(), System.currentTimeMillis() /1000,\n                    runtimeInfo.getController().getState().toString());\n      return new RunIdentifier(runId.getId());\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Writes chunk of data transmitted from the client. Along with data, there is the session id also\n   * being returned.\n   *\n   * @param resource identifier.\n   * @param chunk binary data of the resource transmitted from the client.\n   * @throws AppFabricServiceException\n   */\n  @Override\n  public void chunk(AuthToken token, ResourceIdentifier resource, ByteBuffer chunk) throws AppFabricServiceException {\n    if(! sessions.containsKey(resource.getAccountId())) {\n      throw new AppFabricServiceException(\"A session id has not been created for upload. Please call #init\");\n    }\n\n    SessionInfo info = sessions.get(resource.getAccountId()).setStatus(DeployStatus.UPLOADING);\n    try {\n      OutputStream stream = info.getOutputStream();\n      // Read the chunk from ByteBuffer and write it to file\n      if(chunk != null) {\n        byte[] buffer = new byte[chunk.remaining()];\n        chunk.get(buffer);\n        stream.write(buffer);\n      } else {\n        sessions.remove(resource.getAccountId());\n        throw new AppFabricServiceException(\"Invalid chunk received.\");\n      }\n    } catch (IOException e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      sessions.remove(resource.getAccountId());\n      throw new AppFabricServiceException(\"Failed to write archive chunk\");\n    }\n  }","id":35722,"modified_method":"/**\n   * Writes chunk of data transmitted from the client. Along with data, there is the session id also\n   * being returned.\n   *\n   * @param resource identifier.\n   * @param chunk binary data of the resource transmitted from the client.\n   * @throws AppFabricServiceException\n   */\n  @Override\n  public void chunk(AuthToken token, ResourceIdentifier resource, ByteBuffer chunk) throws AppFabricServiceException {\n    if(! sessions.containsKey(resource.getAccountId())) {\n      throw new AppFabricServiceException(\"A session id has not been created for upload. Please call #init\");\n    }\n\n    SessionInfo info = sessions.get(resource.getAccountId()).setStatus(DeployStatus.UPLOADING);\n    try {\n      OutputStream stream = info.getOutputStream();\n      // Read the chunk from ByteBuffer and write it to file\n      if(chunk != null) {\n        byte[] buffer = new byte[chunk.remaining()];\n        chunk.get(buffer);\n        stream.write(buffer);\n      } else {\n        sessions.remove(resource.getAccountId());\n        throw new AppFabricServiceException(\"Invalid chunk received.\");\n      }\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      sessions.remove(resource.getAccountId());\n      throw new AppFabricServiceException(\"Failed to write archive chunk\");\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns the state of flows within a given account id.\n   *\n   * @param accountId\n   */\n  @Override\n  public List<ActiveFlow> getFlows(String accountId) throws AppFabricServiceException, TException {\n\n    try {\n      Table<Type, Id.Program, List<RunRecord>> histories = store.getAllRunHistory(Id.Account.from(accountId));\n      List<ActiveFlow> result = Lists.newLinkedList();\n      for (Table.Cell<Type, Id.Program, List<RunRecord>> cell : histories.cellSet()) {\n        Id.Program programId = cell.getColumnKey();\n        for (RunRecord runRecord : cell.getValue()) {\n          ActiveFlow activeFlow = new ActiveFlow(programId.getApplicationId(),\n                                                 programId.getId(),\n                                                 typeToEntityType(cell.getRowKey()),\n                                                 runRecord.getStopTs(),\n                                                 runRecord.getStartTs(),\n                                                 null,        // TODO\n                                                 0            // TODO\n                                                 );\n            result.add(activeFlow);\n        }\n      }\n      return result;\n\n    } catch (OperationException e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(\"Exception when getting all run histories: \" + e.getMessage());\n    }\n  }","id":35723,"modified_method":"/**\n   * Returns the state of flows within a given account id.\n   *\n   * @param accountId\n   */\n  @Override\n  public List<ActiveFlow> getFlows(String accountId) throws AppFabricServiceException, TException {\n\n    try {\n      Table<Type, Id.Program, List<RunRecord>> histories = store.getAllRunHistory(Id.Account.from(accountId));\n      List<ActiveFlow> result = Lists.newLinkedList();\n      for (Table.Cell<Type, Id.Program, List<RunRecord>> cell : histories.cellSet()) {\n        Id.Program programId = cell.getColumnKey();\n        for (RunRecord runRecord : cell.getValue()) {\n          ActiveFlow activeFlow = new ActiveFlow(programId.getApplicationId(),\n                                                 programId.getId(),\n                                                 typeToEntityType(cell.getRowKey()),\n                                                 runRecord.getStopTs(),\n                                                 runRecord.getStartTs(),\n                                                 null,        // TODO\n                                                 0            // TODO\n                                                 );\n            result.add(activeFlow);\n        }\n      }\n      return result;\n\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Exception when getting all run histories: \" + throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void removeApplication(AuthToken token, FlowIdentifier identifier) throws AppFabricServiceException {\n    Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n    Id.Account accountId = Id.Account.from(identifier.getAccountId());\n    final Id.Application appId = Id.Application.from(accountId, identifier.getApplicationId());\n\n    // Check if all are stopped.\n    Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n      @Override\n      public boolean apply(Id.Program programId) {\n        return programId.getApplication().equals(appId);\n      }\n    }, Type.values()), \"There are program still running for application \" + appId.getId());\n\n    // Delete the App from store\n    try {\n      store.removeApplication(appId);\n    } catch (OperationException e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n\n    // Remove the Program jar\n    Location appArchive = getApplicationLocation(appId);\n    try {\n      appArchive.delete();\n    } catch (IOException e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n\n    // Reset metrics\n    try {\n      MetricsFrontendServiceImpl mfs = new MetricsFrontendServiceImpl(configuration);\n      mfs.clear(accountId.getId(), appId.getId());\n    } catch (Exception e) {\n      LOG.error(\"Fail to clear metrics for application \" + appId.getId() + \" for account \" + accountId);\n      throw new AppFabricServiceException(e.getMessage());\n    }\n  }","id":35724,"modified_method":"@Override\n  public void removeApplication(AuthToken token, FlowIdentifier identifier) throws AppFabricServiceException {\n    Id.Account accountId = null;\n    final Id.Application appId;\n    try {\n      Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n      accountId = Id.Account.from(identifier.getAccountId());\n      appId = Id.Application.from(accountId, identifier.getApplicationId());\n\n      // Check if all are stopped.\n      Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.getApplication().equals(appId);\n        }\n      }, Type.values()), \"There are program still running for application \" + appId.getId());\n\n      store.removeApplication(appId);\n      Location appArchive = getApplicationLocation(appId);\n      appArchive.delete();\n      MetricsFrontendServiceImpl mfs = new MetricsFrontendServiceImpl(configuration);\n      mfs.clear(accountId.getId(), appId.getId());\n    } catch (Throwable  throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to delete program \" + throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns status of deployment of archive.\n   *\n   * @param resource identifier\n   * @return status of resource processing.\n   * @throws AppFabricServiceException\n   */\n  @Override\n  public DeploymentStatus dstatus(AuthToken token, ResourceIdentifier resource) throws AppFabricServiceException {\n    if(!sessions.containsKey(resource.getAccountId())) {\n      SessionInfo info = retrieve(resource.getAccountId());\n      DeploymentStatus status = new DeploymentStatus(info.getStatus().getCode(),\n                                                     info.getStatus().getMessage(), null);\n      return status;\n    } else {\n      SessionInfo info = sessions.get(resource.getAccountId());\n      DeploymentStatus status = new DeploymentStatus(info.getStatus().getCode(),\n                                                     info.getStatus().getMessage(), null);\n      return status;\n    }\n  }","id":35725,"modified_method":"/**\n   * Returns status of deployment of archive.\n   *\n   * @param resource identifier\n   * @return status of resource processing.\n   * @throws AppFabricServiceException\n   */\n  @Override\n  public DeploymentStatus dstatus(AuthToken token, ResourceIdentifier resource) throws AppFabricServiceException {\n    try {\n      if(!sessions.containsKey(resource.getAccountId())) {\n        SessionInfo info = retrieve(resource.getAccountId());\n        DeploymentStatus status = new DeploymentStatus(info.getStatus().getCode(),\n                                                       info.getStatus().getMessage(), null);\n        return status;\n      } else {\n        SessionInfo info = sessions.get(resource.getAccountId());\n        DeploymentStatus status = new DeploymentStatus(info.getStatus().getCode(),\n                                                       info.getStatus().getMessage(), null);\n        return status;\n      }\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Initializes deployment of resources from the client.\n   * <p>\n   *   Upon receiving a request to initialize an upload with auth-token and resource information,\n   *   we create a unique identifier for the upload and also create directories needed for storing\n   *   the uploading archive. At this point the upload has not yet begun. The bytes of the archive\n   *   are still on the client machine. An session id is returned back to client - which will use\n   *   the session id provided to upload the chunks.\n   * <\/p>\n   * <p>\n   *   <i>Note:<\/i> As the state of upload are transient they are not being persisted on the server.\n   * <\/p>\n   *\n   * @param info ResourceInfo\n   * @return ResourceIdentifier instance containing the resource id and\n   * resource version.\n   */\n  @Override\n  public ResourceIdentifier init(AuthToken token, ResourceInfo info) throws AppFabricServiceException {\n    ResourceIdentifier identifier = new ResourceIdentifier( info.getAccountId(), \"appId\", \"resourceId\", 1);\n\n    try {\n      if(sessions.containsKey(info.getAccountId())) {\n        throw new AppFabricServiceException(\"An upload is already in progress for this account.\");\n      }\n      Location uploadDir = locationFactory.create(archiveDir + \"/\" + info.getAccountId());\n      if(! uploadDir.exists() && ! uploadDir.mkdirs()) {\n        LOG.warn(\"Unable to create directory '{}'\", uploadDir.getName());\n      }\n      Location archive = uploadDir.append(info.getFilename());\n      SessionInfo sessionInfo = new SessionInfo(identifier, info, archive, DeployStatus.REGISTERED);\n      sessions.put(info.getAccountId(), sessionInfo);\n      return identifier;\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n  }","id":35726,"modified_method":"/**\n   * Initializes deployment of resources from the client.\n   * <p>\n   *   Upon receiving a request to initialize an upload with auth-token and resource information,\n   *   we create a unique identifier for the upload and also create directories needed for storing\n   *   the uploading archive. At this point the upload has not yet begun. The bytes of the archive\n   *   are still on the client machine. An session id is returned back to client - which will use\n   *   the session id provided to upload the chunks.\n   * <\/p>\n   * <p>\n   *   <i>Note:<\/i> As the state of upload are transient they are not being persisted on the server.\n   * <\/p>\n   *\n   * @param info ResourceInfo\n   * @return ResourceIdentifier instance containing the resource id and\n   * resource version.\n   */\n  @Override\n  public ResourceIdentifier init(AuthToken token, ResourceInfo info) throws AppFabricServiceException {\n    ResourceIdentifier identifier = new ResourceIdentifier( info.getAccountId(), \"appId\", \"resourceId\", 1);\n\n    try {\n      if(sessions.containsKey(info.getAccountId())) {\n        throw new AppFabricServiceException(\"An upload is already in progress for this account.\");\n      }\n      Location uploadDir = locationFactory.create(archiveDir + \"/\" + info.getAccountId());\n      if(! uploadDir.exists() && ! uploadDir.mkdirs()) {\n        LOG.warn(\"Unable to create directory '{}'\", uploadDir.getName());\n      }\n      Location archive = uploadDir.append(info.getFilename());\n      SessionInfo sessionInfo = new SessionInfo(identifier, info, archive, DeployStatus.REGISTERED);\n      sessions.put(info.getAccountId(), sessionInfo);\n      return identifier;\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Starts a Program\n   *\n   * @param token\n   * @param descriptor\n   */\n  @Override\n  public RunIdentifier start(AuthToken token, FlowDescriptor descriptor)\n    throws AppFabricServiceException, TException {\n\n    FlowIdentifier id = descriptor.getIdentifier();\n    Id.Program programId = Id.Program.from(id.getAccountId(), id.getApplicationId(), id.getFlowId());\n    try {\n      Program program = store.loadProgram(programId, entityTypeToType(id));\n      // TODO: User arguments\n      ProgramRuntimeService.RuntimeInfo runtimeInfo =\n        runtimeService.run(program, new SimpleProgramOptions(id.getFlowId(),\n                                                             new BasicArguments(),\n                                                             new BasicArguments()));\n      store.setStart(programId, runtimeInfo.getController().getRunId().getId(),\n                     System.currentTimeMillis()/1000);\n      return new RunIdentifier(runtimeInfo.getController().getRunId().toString());\n\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n  }","id":35727,"modified_method":"/**\n   * Starts a Program\n   *\n   * @param token\n   * @param descriptor\n   */\n  @Override\n  public RunIdentifier start(AuthToken token, FlowDescriptor descriptor)\n    throws AppFabricServiceException, TException {\n\n    FlowIdentifier id = descriptor.getIdentifier();\n    Id.Program programId = Id.Program.from(id.getAccountId(), id.getApplicationId(), id.getFlowId());\n    try {\n      Program program = store.loadProgram(programId, entityTypeToType(id));\n      // TODO: User arguments\n      ProgramRuntimeService.RuntimeInfo runtimeInfo =\n        runtimeService.run(program, new SimpleProgramOptions(id.getFlowId(),\n                                                             new BasicArguments(),\n                                                             new BasicArguments()));\n      store.setStart(programId, runtimeInfo.getController().getRunId().getId(),\n                     System.currentTimeMillis()/1000);\n      return new RunIdentifier(runtimeInfo.getController().getRunId().toString());\n\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Set number of instance of a flowlet.\n   *\n   * @param token\n   * @param identifier\n   * @param flowletId\n   * @param instances\n   */\n  @Override\n  public void setInstances(AuthToken token, FlowIdentifier identifier, String flowletId, short instances)\n    throws AppFabricServiceException, TException {\n    ProgramRuntimeService.RuntimeInfo runtimeInfo = findRuntimeInfo(identifier);\n    Preconditions.checkNotNull(runtimeInfo, \"Unable to find runtime info for %s\", identifier);\n\n    try {\n      runtimeInfo.getController().command(\"instances\", ImmutableMap.of(flowletId, (int) instances)).get();\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n\n    // storing the info about instances count after increasing the count of running flowlets: even if it fails, we\n    // can at least set instances count for this session\n    try {\n      store.setFlowletInstances(Id.Program.from(identifier.getAccountId(), identifier.getApplicationId(),\n                                                identifier.getFlowId()), flowletId, instances);\n    } catch (OperationException e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n  }","id":35728,"modified_method":"/**\n   * Set number of instance of a flowlet.\n   *\n   * @param token\n   * @param identifier\n   * @param flowletId\n   * @param instances\n   */\n  @Override\n  public void setInstances(AuthToken token, FlowIdentifier identifier, String flowletId, short instances)\n    throws AppFabricServiceException, TException {\n    // storing the info about instances count after increasing the count of running flowlets: even if it fails, we\n    // can at least set instances count for this session\n    try {\n      ProgramRuntimeService.RuntimeInfo runtimeInfo = findRuntimeInfo(identifier);\n      Preconditions.checkNotNull(runtimeInfo, \"Unable to find runtime info for %s\", identifier);\n      runtimeInfo.getController().command(\"instances\", ImmutableMap.of(flowletId, (int) instances)).get();\n      store.setFlowletInstances(Id.Program.from(identifier.getAccountId(), identifier.getApplicationId(),\n                                                identifier.getFlowId()), flowletId, instances);\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Returns run information for a given flow id.\n   *\n   * @param id\n   */\n  @Override\n  public void stopAll(String id) throws AppFabricServiceException, TException {\n    // FIXME: Is id application id?\n    try {\n      List<ListenableFuture<?>> futures = Lists.newLinkedList();\n      for (Type type : Type.values()) {\n        for (Map.Entry<RunId, ProgramRuntimeService.RuntimeInfo> entry : runtimeService.list(type).entrySet()) {\n          ProgramRuntimeService.RuntimeInfo runtimeInfo = entry.getValue();\n          if (runtimeInfo.getProgramId().getApplicationId().equals(id)) {\n            futures.add(runtimeInfo.getController().stop());\n          }\n        }\n      }\n      if (!futures.isEmpty()) {\n        try {\n          Futures.successfulAsList(futures).get();\n        } catch (Exception e) {\n          LOG.warn(StackTraceUtil.toStringStackTrace(e));\n          throw new AppFabricServiceException(e.getMessage());\n        }\n      }\n    } catch (Exception e) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(e));\n      throw new AppFabricServiceException(e.getMessage());\n    }\n  }","id":35729,"modified_method":"/**\n   * Returns run information for a given flow id.\n   *\n   * @param id\n   */\n  @Override\n  public void stopAll(String id) throws AppFabricServiceException, TException {\n    // FIXME: Is id application id?\n    try {\n      List<ListenableFuture<?>> futures = Lists.newLinkedList();\n      for (Type type : Type.values()) {\n        for (Map.Entry<RunId, ProgramRuntimeService.RuntimeInfo> entry : runtimeService.list(type).entrySet()) {\n          ProgramRuntimeService.RuntimeInfo runtimeInfo = entry.getValue();\n          if (runtimeInfo.getProgramId().getApplicationId().equals(id)) {\n            futures.add(runtimeInfo.getController().stop());\n          }\n        }\n      }\n      if (!futures.isEmpty()) {\n        try {\n          Futures.successfulAsList(futures).get();\n        } catch (Exception e) {\n          LOG.warn(StackTraceUtil.toStringStackTrace(e));\n          throw new AppFabricServiceException(e.getMessage());\n        }\n      }\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getMessage());\n    }\n  }","commit_id":"a23f878557acd1fe30bea88d872c05b84103acb3","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Promotes a FAR from single node to cloud.\n   *\n   * @param id of the flow.\n   * @return true if successful; false otherwise.\n   * @throws AppFabricServiceException\n   */\n  @Override\n  public boolean promote(AuthToken authToken, ResourceIdentifier id, String hostname)\n    throws AppFabricServiceException {\n    Preconditions.checkArgument(authToken.isSetToken(), \"API key is not set\");\n    Preconditions.checkArgument(!hostname.isEmpty(), \"Empty hostname passed.\");\n\n    final Location appArchive = getApplicationLocation(Id.Application.from(id.getAccountId(),\n                                                                               id.getApplicationId()));\n    try {\n      if(! appArchive.exists()) {\n        throw new AppFabricServiceException(\"Unable to locate the application.\");\n      }\n\n      String schema = \"https\";\n      if(\"localhost\".equals(hostname)) {\n        schema = \"http\";\n      }\n\n      int port = configuration.getInt( \"app.rest.port\", 10007);\n      String url = String.format(\"%s://%s:%d/app\", schema, hostname, port);\n      SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n        .setUrl(url)\n        .setRequestTimeoutInMs(UPLOAD_TIMEOUT)\n        .setHeader(\"X-Archive-Name\", appArchive.getName())\n        .setHeader(\"X-Continuuity-ApiKey\", authToken.getToken())\n        .build();\n\n      try {\n        Future<Response> future = client.put(new LocationBodyGenerator(appArchive));\n        Response response = future.get(UPLOAD_TIMEOUT, TimeUnit.MILLISECONDS);\n        if(response.getStatusCode() != 200) {\n          throw new RuntimeException(response.getResponseBody());\n        }\n        return true;\n      } finally {\n        client.close();\n      }\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getLocalizedMessage());\n    }\n  }","id":35730,"modified_method":"/**\n   * Promotes a FAR from single node to cloud.\n   *\n   * @param id of the flow.\n   * @return true if successful; false otherwise.\n   * @throws AppFabricServiceException\n   */\n  @Override\n  public boolean promote(AuthToken authToken, ResourceIdentifier id, String hostname)\n    throws AppFabricServiceException {\n\n    try {\n      Preconditions.checkArgument(authToken.isSetToken(), \"API key is not set\");\n      Preconditions.checkArgument(!hostname.isEmpty(), \"Empty hostname passed.\");\n\n      final Location appArchive = store.getApplicationArchiveLocation(Id.Application.from(id.getAccountId(),\n                                                                                          id.getApplicationId()));\n      if(! appArchive.exists()) {\n        throw new AppFabricServiceException(\"Unable to locate the application.\");\n      }\n\n      String schema = \"https\";\n      if(\"localhost\".equals(hostname)) {\n        schema = \"http\";\n      }\n\n      int port = configuration.getInt( \"app.rest.port\", 10007);\n      String url = String.format(\"%s://%s:%d/app\", schema, hostname, port);\n      SimpleAsyncHttpClient client = new SimpleAsyncHttpClient.Builder()\n        .setUrl(url)\n        .setRequestTimeoutInMs(UPLOAD_TIMEOUT)\n        .setHeader(\"X-Archive-Name\", appArchive.getName())\n        .setHeader(\"X-Continuuity-ApiKey\", authToken.getToken())\n        .build();\n\n      try {\n        Future<Response> future = client.put(new LocationBodyGenerator(appArchive));\n        Response response = future.get(UPLOAD_TIMEOUT, TimeUnit.MILLISECONDS);\n        if(response.getStatusCode() != 200) {\n          throw new RuntimeException(response.getResponseBody());\n        }\n        return true;\n      } finally {\n        client.close();\n      }\n    } catch (Throwable throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(throwable.getLocalizedMessage());\n    }\n  }","commit_id":"9234656c3bdcab9a7a2c7b0feccb13433f526ce4","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void removeApplication(AuthToken token, FlowIdentifier identifier) throws AppFabricServiceException {\n    Id.Account accountId = null;\n    final Id.Application appId;\n    try {\n      Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n      accountId = Id.Account.from(identifier.getAccountId());\n      appId = Id.Application.from(accountId, identifier.getApplicationId());\n\n      // Check if all are stopped.\n      Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.getApplication().equals(appId);\n        }\n      }, Type.values()), \"There are program still running for application \" + appId.getId());\n\n      store.removeApplication(appId);\n      Location appArchive = getApplicationLocation(appId);\n      appArchive.delete();\n      MetricsFrontendServiceImpl mfs = new MetricsFrontendServiceImpl(configuration);\n      mfs.clear(accountId.getId(), appId.getId());\n    } catch (Throwable  throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to delete program \" + throwable.getMessage());\n    }\n  }","id":35731,"modified_method":"@Override\n  public void removeApplication(AuthToken token, FlowIdentifier identifier) throws AppFabricServiceException {\n    try {\n      Preconditions.checkNotNull(identifier, \"No application id provided.\");\n\n      Id.Account accountId = Id.Account.from(identifier.getAccountId());\n      final Id.Application appId = Id.Application.from(accountId, identifier.getApplicationId());\n\n      // Check if all are stopped.\n      Preconditions.checkState(!anyRunning(new Predicate<Id.Program>() {\n        @Override\n        public boolean apply(Id.Program programId) {\n          return programId.getApplication().equals(appId);\n        }\n      }, Type.values()), \"There are program still running for application \" + appId.getId());\n\n      Location appArchive = store.getApplicationArchiveLocation(appId);\n      appArchive.delete();\n      store.removeApplication(appId);\n      MetricsFrontendServiceImpl mfs = new MetricsFrontendServiceImpl(configuration);\n      mfs.clear(accountId.getId(), appId.getId());\n    } catch (Throwable  throwable) {\n      LOG.warn(StackTraceUtil.toStringStackTrace(throwable));\n      throw new AppFabricServiceException(\"Fail to delete program \" + throwable.getMessage());\n    }\n  }","commit_id":"9234656c3bdcab9a7a2c7b0feccb13433f526ce4","url":"https://github.com/caskdata/cdap"},{"original_method":"@BeforeClass\n  public static void before() throws Exception {\n    configuration = CConfiguration.create();\n    configuration.set(Constants.CFG_APP_FABRIC_OUTPUT_DIR, \"/tmp/app\");\n    configuration.set(Constants.CFG_APP_FABRIC_TEMP_DIR, \"/tmp/temp\");\n\n    final Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                                   new BigMamaModule(configuration));\n\n    server = injector.getInstance(AppFabricService.Iface.class);\n\n    // Create location factory.\n    lf = injector.getInstance(LocationFactory.class);\n\n    // Create store\n    sFactory = injector.getInstance(StoreFactory.class);\n  }","id":35732,"modified_method":"@BeforeClass\n  public static void before() throws Exception {\n    final Injector injector = TestHelper.getInjector();\n    server = injector.getInstance(AppFabricService.Iface.class);\n    // Create location factory.\n    lf = injector.getInstance(LocationFactory.class);\n    // Create store\n    sFactory = injector.getInstance(StoreFactory.class);\n  }","commit_id":"9234656c3bdcab9a7a2c7b0feccb13433f526ce4","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * @return Returns an instance of {@link LocalManager}\n   */\n  public static Manager<Location, ApplicationWithPrograms> getLocalManager(CConfiguration configuration) {\n    LocationFactory lf = new LocalLocationFactory();\n    PipelineFactory pf = new SynchronousPipelineFactory();\n\n    final Injector injector = Guice.createInjector(new BigMamaModule(configuration),\n                                                   new DataFabricModules().getInMemoryModules());\n\n\n    ManagerFactory factory = injector.getInstance(ManagerFactory.class);\n    return (Manager<Location, ApplicationWithPrograms>)factory.create();\n  }","id":35733,"modified_method":"/**\n   * @return Returns an instance of {@link LocalManager}\n   */\n  public static Manager<Location, ApplicationWithPrograms> getLocalManager(CConfiguration configuration) {\n    injector = Guice.createInjector(new BigMamaModule(configuration),\n                                                   new DataFabricModules().getInMemoryModules());\n\n\n    ManagerFactory factory = injector.getInstance(ManagerFactory.class);\n    return (Manager<Location, ApplicationWithPrograms>)factory.create();\n  }","commit_id":"9234656c3bdcab9a7a2c7b0feccb13433f526ce4","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   *\n   */\n  public static void deployApplication(Class<? extends Application> application, String fileName) throws Exception {\n    AppFabricService.Iface server;\n\n    final Injector injector = Guice.createInjector(new DataFabricModules().getInMemoryModules(),\n                                                   new BigMamaModule(configuration));\n\n    server = injector.getInstance(AppFabricService.Iface.class);\n\n    // Create location factory.\n    LocationFactory lf = injector.getInstance(LocationFactory.class);\n\n    // Create a local jar - simulate creation of application archive.\n    Location deployedJar = lf.create(\n      JarFinder.getJar(application, TestHelper.getManifestWithMainClass(application))\n    );\n    deployedJar.deleteOnExit();\n\n    // Call init to get a session identifier - yes, the name needs to be changed.\n    AuthToken token = new AuthToken(\"12345\");\n    ResourceIdentifier id = server.init(token, new ResourceInfo(\"developer\",\"\", fileName, 123455, 45343));\n\n    // Upload the jar file to remote location.\n    BufferFileInputStream is =\n      new BufferFileInputStream(deployedJar.getInputStream(), 100*1024);\n    try {\n      while(true) {\n        byte[] toSubmit = is.read();\n        if(toSubmit.length==0) break;\n        server.chunk(token, id, ByteBuffer.wrap(toSubmit));\n        DeploymentStatus status = server.dstatus(token, id);\n        Assert.assertEquals(2, status.getOverall());\n      }\n    } finally {\n      is.close();\n    }\n\n    server.deploy(token, id);\n    int status = server.dstatus(token, id).getOverall();\n    while(status == 3) {\n      status = server.dstatus(token, id).getOverall();\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(5, status); // Deployed successfully.\n  }","id":35734,"modified_method":"/**\n   *\n   */\n  public static void deployApplication(Class<? extends Application> application, String fileName) throws Exception {\n    AppFabricService.Iface server;\n\n    server = injector.getInstance(AppFabricService.Iface.class);\n\n    // Create location factory.\n    LocationFactory lf = injector.getInstance(LocationFactory.class);\n\n    // Create a local jar - simulate creation of application archive.\n    Location deployedJar = lf.create(\n      JarFinder.getJar(application, TestHelper.getManifestWithMainClass(application))\n    );\n    deployedJar.deleteOnExit();\n\n    // Call init to get a session identifier - yes, the name needs to be changed.\n    AuthToken token = new AuthToken(\"12345\");\n    ResourceIdentifier id = server.init(token, new ResourceInfo(\"developer\",\"\", fileName, 123455, 45343));\n\n    // Upload the jar file to remote location.\n    BufferFileInputStream is =\n      new BufferFileInputStream(deployedJar.getInputStream(), 100*1024);\n    try {\n      while(true) {\n        byte[] toSubmit = is.read();\n        if(toSubmit.length==0) break;\n        server.chunk(token, id, ByteBuffer.wrap(toSubmit));\n        DeploymentStatus status = server.dstatus(token, id);\n        Assert.assertEquals(2, status.getOverall());\n      }\n    } finally {\n      is.close();\n    }\n\n    server.deploy(token, id);\n    int status = server.dstatus(token, id).getOverall();\n    while(status == 3) {\n      status = server.dstatus(token, id).getOverall();\n      Thread.sleep(100);\n    }\n    Assert.assertEquals(5, status); // Deployed successfully.\n  }","commit_id":"9234656c3bdcab9a7a2c7b0feccb13433f526ce4","url":"https://github.com/caskdata/cdap"},{"original_method":"public void reset(final CodeStyleSettings settings) {\n      myModel.removeAllElements();\n      String[] strings = getStrings(settings);\n      for (String string : strings) {\n        myModel.addElement(string);\n      }\n\n      setSelectedIndex(0);\n    }","id":35735,"modified_method":"public void reset(final CodeStyleSettings settings) {\n      myModel.removeAllElements();\n      for (String string : getPropertyNames(settings)) {\n        myModel.addElement(string);\n      }\n\n      setSelectedIndex(0);\n    }","commit_id":"8b5da664cff90f7491944ff238f43e5e7aa0f8a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MembersOrderList() {\n      myModel = new DefaultListModel();\n      setModel(myModel);\n      setVisibleRowCount(4);\n    }","id":35736,"modified_method":"public MembersOrderList() {\n      myModel = new DefaultListModel();\n      setModel(myModel);\n      setVisibleRowCount(PROPERTIES.size());\n    }","commit_id":"8b5da664cff90f7491944ff238f43e5e7aa0f8a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String[] getStrings(final CodeStyleSettings settings) {\n      String[] strings = new String[]{FIELDS, METHODS, CONSTRUCTORS, INNER_CLASSES};\n\n      Arrays.sort(strings, new Comparator<String>() {\n        public int compare(String o1, String o2) {\n          int weight1 = getWeight(o1);\n          int weight2 = getWeight(o2);\n          return weight1 - weight2;\n        }\n\n        private int getWeight(String o) {\n          if (FIELDS.equals(o)) {\n            return settings.FIELDS_ORDER_WEIGHT;\n          }\n          else if (METHODS.equals(o)) {\n            return settings.METHODS_ORDER_WEIGHT;\n          }\n          else if (CONSTRUCTORS.equals(o)) {\n            return settings.CONSTRUCTORS_ORDER_WEIGHT;\n          }\n          else if (INNER_CLASSES.equals(o)) {\n            return settings.INNER_CLASSES_ORDER_WEIGHT;\n          }\n          else {\n            throw new IllegalArgumentException(\"unexpected \" + o);\n          }\n        }\n      });\n      return strings;\n    }","id":35737,"modified_method":"private static Iterable<String> getPropertyNames(final CodeStyleSettings settings) {\n      List<String> result = new ArrayList<String>(PROPERTIES.keySet());\n      Collections.sort(result, new Comparator<String>() {\n        public int compare(String o1, String o2) {\n          int weight1 = getWeight(o1);\n          int weight2 = getWeight(o2);\n          return weight1 - weight2;\n        }\n\n        private int getWeight(String o) {\n          PropertyManager propertyManager = PROPERTIES.get(o);\n          if (propertyManager == null) {\n            throw new IllegalArgumentException(\"unexpected \" + o);\n          }\n          return propertyManager.getValue(settings);\n        }\n      });\n      return result;\n    }","commit_id":"8b5da664cff90f7491944ff238f43e5e7aa0f8a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isModified(CodeStyleSettings settings) {\n      String[] oldStrings = getStrings(settings);\n      String[] newStrings = new String[myModel.size()];\n      for (int i = 0; i < newStrings.length; i++) {\n        newStrings[i] = (String)myModel.getElementAt(i);\n      }\n\n      return !Arrays.equals(newStrings, oldStrings);\n    }","id":35738,"modified_method":"public boolean isModified(CodeStyleSettings settings) {\n      Iterable<String> oldProperties = getPropertyNames(settings);\n      int i = 0;\n      for (String property : oldProperties) {\n        if (i >= myModel.size() || !property.equals(myModel.getElementAt(i))) {\n          return true;\n        }\n        i++;\n      }\n      return false;\n    }","commit_id":"8b5da664cff90f7491944ff238f43e5e7aa0f8a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void apply(CodeStyleSettings settings) {\n      for (int i = 0; i < myModel.size(); i++) {\n        Object o = myModel.getElementAt(i);\n        int weight = i + 1;\n\n        if (FIELDS.equals(o)) {\n          settings.FIELDS_ORDER_WEIGHT = weight;\n        }\n        else if (METHODS.equals(o)) {\n          settings.METHODS_ORDER_WEIGHT = weight;\n        }\n        else if (CONSTRUCTORS.equals(o)) {\n          settings.CONSTRUCTORS_ORDER_WEIGHT = weight;\n        }\n        else if (INNER_CLASSES.equals(o)) {\n          settings.INNER_CLASSES_ORDER_WEIGHT = weight;\n        }\n        else {\n          throw new IllegalArgumentException(\"unexpected \" + o);\n        }\n      }\n    }","id":35739,"modified_method":"public void apply(CodeStyleSettings settings) {\n      for (int i = 0; i < myModel.size(); i++) {\n        Object o = myModel.getElementAt(i);\n        if (o == null) {\n          throw new IllegalArgumentException(\"unexpected \" + o);\n        }\n        PropertyManager propertyManager = PROPERTIES.get(o.toString());\n        if (propertyManager == null) {\n          throw new IllegalArgumentException(\"unexpected \" + o);\n        }\n        propertyManager.apply(settings, i + 1);\n      }\n    }","commit_id":"8b5da664cff90f7491944ff238f43e5e7aa0f8a6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Used to set the trees to be displayed in this panel (which should match\n   * the tregex expression).\n   *\n   * @param matches trees that match the expression\n   */\n  public void setMatches(List<TreeFromFile> matches, Map<TreeFromFile, List<Tree>> matchedParts) {\n    // cdm Nov 2010: I rewrote this so the performance wasn't dreadful.\n    // In the old days, one by one updates to active Swing components gave dreadful performance, so\n    // I changed that, but that wasn't really the problem, it was that the if part didn't honor\n    // maxMatches!\n    removeAllMatches();\n    final DefaultListModel<TreeFromFile> newModel = new DefaultListModel<TreeFromFile>();\n    newModel.ensureCapacity(matches.size());\n\n    //Two cases:\n    // 1) Trees contain file and sentence annotations -> we can display differences\n    // 2) Trees do not contain file and sentence annotations -> we display all matches with no differences\n    //\n    if(TregexGUI.getInstance().isTdiffEnabled()) {\n      FileTreeNode refTreebank = FilePanel.getInstance().getActiveTreebanks().get(0); //First selected treebank is the reference\n      String refFileName = refTreebank.getFilename();\n      List<Tree> treeList = null;\n      Map<TreeFromFile, List<Tree>> filteredMatchedParts = Generics.newHashMap();\n\n      for (TreeFromFile t2 : matches) {\n        if (t2.getFilename() == null || t2.getSentenceId() < 0) { //Trees were not read by PennTreeReader.\n          newModel.addElement(t2);\n          filteredMatchedParts.put(t2, matchedParts.get(t2));\n\n        } else if( ! t2.getFilename().equals(refFileName)) {\n          if (treeList == null) //Lazy loading to account for the if statement above\n            treeList = getTreebankAsList(refTreebank.getTreebank());\n\n          int treeId = t2.getSentenceId() - 1;\n          if(treeId >= treeList.size())\n            continue;\n\n          Tree t1 = treeList.get(treeId);\n          Tree treeT2 = t2.getTree();\n          Set<Constituent> inT1notT2 = Tdiff.markDiff(t1, treeT2);\n          t2.setDiffConstituents(inT1notT2);\n          t2.setDiffDecoratedTree(treeT2);\n\n          newModel.addElement(t2);\n          if(matchedParts != null && matchedParts.containsKey(t2))\n            filteredMatchedParts.put(t2, matchedParts.get(t2));\n        } //else skip this tree\n        if(newModel.size() >= maxMatches) break;\n      }\n      matchedParts = filteredMatchedParts;\n\n    } else if (!showOnlyMatchedPortion || matchedParts == null) {\n      int i = 0;\n      for (TreeFromFile t : matches) {\n        newModel.addElement(t);\n        i++;\n        if (i >= maxMatches) break;\n      }\n    } else {\n      int i = 0;\n      for (TreeFromFile t : matchedParts.keySet()) {\n        List<Tree> curMatches = matchedParts.get(t);\n        for (Tree match : curMatches) {\n          newModel.addElement(new TreeFromFile(match, t.getFilename()));\n          i++;\n          if (i >= maxMatches) break;\n        }\n      }\n    }\n\n    if (! newModel.isEmpty())\n      SwingUtilities.invokeLater(new Runnable() {\n        public void run() {\n          list.setModel(newModel);\n          list.setSelectedIndex(0);\n          sendToListeners();\n        }\n      });\n\n    setMatchedParts(matchedParts);\n    this.setPreferredSize(this.getSize());\n  }","id":35740,"modified_method":"/**\n   * Used to set the trees to be displayed in this panel (which should match\n   * the tregex expression).\n   *\n   * @param matches trees that match the expression\n   */\n  public void setMatches(List<TreeFromFile> matches, Map<TreeFromFile, List<Tree>> matchedParts) {\n    // cdm Nov 2010: I rewrote this so the performance wasn't dreadful.\n    // In the old days, one by one updates to active Swing components gave dreadful performance, so\n    // I changed that, but that wasn't really the problem, it was that the if part didn't honor\n    // maxMatches!\n    removeAllMatches();\n    final DefaultListModel<TreeFromFile> newModel = new DefaultListModel<TreeFromFile>();\n    newModel.ensureCapacity(matches.size());\n\n    //Two cases:\n    // 1) Trees contain file and sentence annotations -> we can display differences\n    // 2) Trees do not contain file and sentence annotations -> we display all matches with no differences\n    //\n    if(TregexGUI.getInstance().isTdiffEnabled()) {\n      FileTreeNode refTreebank = FilePanel.getInstance().getActiveTreebanks().get(0); //First selected treebank is the reference\n      String refFileName = refTreebank.getFilename();\n      List<Tree> treeList = null;\n      Map<TreeFromFile, List<Tree>> filteredMatchedParts = Generics.newHashMap();\n\n      for (TreeFromFile t2 : matches) {\n        if (t2.getFilename() == null || t2.getSentenceId() < 0) { //Trees were not read by PennTreeReader.\n          newModel.addElement(t2);\n          filteredMatchedParts.put(t2, matchedParts.get(t2));\n\n        } else if( ! t2.getFilename().equals(refFileName)) {\n          if (treeList == null) //Lazy loading to account for the if statement above\n            treeList = getTreebankAsList(refTreebank.getTreebank());\n\n          int treeId = t2.getSentenceId() - 1;\n          if(treeId >= treeList.size())\n            continue;\n\n          Tree t1 = treeList.get(treeId);\n          Tree treeT2 = t2.getTree();\n          Set<Constituent> inT1notT2 = Tdiff.markDiff(t1, treeT2);\n          t2.setDiffConstituents(inT1notT2);\n          t2.setDiffDecoratedTree(treeT2);\n\n          newModel.addElement(t2);\n          if(matchedParts != null && matchedParts.containsKey(t2))\n            filteredMatchedParts.put(t2, matchedParts.get(t2));\n        } //else skip this tree\n        if(newModel.size() >= maxMatches) break;\n      }\n      matchedParts = filteredMatchedParts;\n\n    } else if (!showOnlyMatchedPortion || matchedParts == null) {\n      int i = 0;\n      for (TreeFromFile t : matches) {\n        newModel.addElement(t);\n        i++;\n        if (i >= maxMatches) break;\n      }\n    } else {\n      int i = 0;\n      for (TreeFromFile t : matchedParts.keySet()) {\n        List<Tree> curMatches = matchedParts.get(t);\n        for (Tree match : curMatches) {\n          newModel.addElement(new TreeFromFile(match, t.getFilename()));\n          i++;\n          if (i >= maxMatches) break;\n        }\n      }\n    }\n\n    if (! newModel.isEmpty())\n      SwingUtilities.invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          list.setModel(newModel);\n          list.setSelectedIndex(0);\n          sendToListeners();\n        }\n      });\n\n    setMatchedParts(matchedParts);\n    this.setPreferredSize(this.getSize());\n  }","commit_id":"f1383ad9bf51b5f6711751bb49defbe64f40e340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Returns all currently displayed sentences in string buffer, plain text form\n   * @return StringBuffer filled with the plain text form of all sentences in the matches panel\n   */\n  public StringBuffer getMatchedSentences() {\n    StringBuffer sb = new StringBuffer();\n    for(int i = 0; i < list.getModel().getSize(); i++) {\n      String t = ((TreeFromFile) list.getModel().getElementAt(i)).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb;\n  }","id":35741,"modified_method":"/**\n   * Returns all currently displayed sentences in plain text form.\n   *\n   * @return String filled with the plain text form of all sentences in the matches panel\n   */\n  public String getMatchedSentences() {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0, sz = list.getModel().getSize(); i < sz; i++) {\n      String t = list.getModel().getElementAt(i).getLabel().getText();\n      sb.append(t);\n      sb.append(\"\\n\");\n    }\n    return sb.toString();\n  }","commit_id":"f1383ad9bf51b5f6711751bb49defbe64f40e340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Returns all currently displayed matches in string buffer, penn treebank form\n   * (suitable for writing out, for instance)\n   *\n   * @return String filled with the Penn treebank forms of all trees in the matches panel\n   */\n  public String getMatches() {\n    StringBuilder sb = new StringBuilder();\n    for(int i = 0, sz = list.getModel().getSize(); i < sz; i++) {\n      Tree t = ((TreeFromFile) list.getModel().getElementAt(i)).getTree();\n      sb.append(t.pennString());\n      sb.append(\"\\n\\n\");\n    }\n    return sb.toString();\n  }","id":35742,"modified_method":"/**\n   * Returns all currently displayed matches in string buffer, penn treebank form\n   * (suitable for writing out, for instance)\n   *\n   * @return String filled with the Penn treebank forms of all trees in the matches panel\n   */\n  public String getMatches() {\n    StringBuilder sb = new StringBuilder();\n    for(int i = 0, sz = list.getModel().getSize(); i < sz; i++) {\n      Tree t = list.getModel().getElementAt(i).getTree();\n      sb.append(t.pennString());\n      sb.append(\"\\n\\n\");\n    }\n    return sb.toString();\n  }","commit_id":"f1383ad9bf51b5f6711751bb49defbe64f40e340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private MatchesPanel() {\n    //data\n    DefaultListModel model = new DefaultListModel();\n    list = new TooltipJList(model);\n    list.setCellRenderer(new MatchCellRenderer());\n    list.setTransferHandler(new TreeTransferHandler());\n    matchedParts = Generics.newHashMap();\n    list.addListSelectionListener(this);\n    MouseInputAdapter mouseListener = new MouseInputAdapter() {\n      private boolean dragNDrop = false;\n      @Override\n      public void mousePressed(MouseEvent e) {\n        if (MatchesPanel.getInstance().isEmpty()) return;\n        if(firstMouseEvent == null) {\n          firstMouseEvent = e;\n        }\n        e.consume();\n        TreeFromFile selectedValue = (TreeFromFile) list.getSelectedValue();\n        if(selectedValue == null) return;\n        JTextField label = selectedValue.getLabel();\n        if(((e.getModifiersEx()) & InputEvent.SHIFT_DOWN_MASK) == InputEvent.SHIFT_DOWN_MASK) {\n          //shift is being held\n          addHighlight(label, firstMouseEvent, e);\n        } else if(!HighlightUtils.isInHighlight(e, label, label.getHighlighter())) {\n          label.getHighlighter().removeAllHighlights();\n          firstMouseEvent = e;\n          dragNDrop = false;\n          list.repaint();\n        } else {\n          //in a highlight, if we drag after this, we'll be DnDing\n          dragNDrop = true;\n        }\n      }\n\n      private boolean addHighlight(JTextField label, MouseEvent mouseEvent1, MouseEvent mouseEvent2) {\n        //Two parts: adding the highlight on the label, and scrolling the list appropriately\n        //HighlightUtils handles the first part, we handle the second part here\n        boolean highlightSuccessful = HighlightUtils.addHighlight(label, mouseEvent1, mouseEvent2);\n        FontMetrics fm = label.getFontMetrics(label.getFont());\n        int firstXpos = mouseEvent1.getX();\n        int lastXpos = mouseEvent2.getX();\n        int firstOffset = getCharOffset(fm, label.getText(), firstXpos);\n        int lastOffset = getCharOffset(fm, label.getText(), lastXpos);\n        if(lastOffset != firstOffset) {\n          if(firstOffset > lastOffset) {\n            int tmp = firstOffset;\n            firstOffset = lastOffset;\n            lastOffset = tmp;\n          }\n          Rectangle curVisible = list.getVisibleRect();\n          if(lastXpos > curVisible.x+curVisible.width) {\n            list.scrollRectToVisible(new Rectangle(new Point(lastXpos-curVisible.width, curVisible.y), curVisible.getSize()));\n          } else if(lastXpos < curVisible.x) {\n            list.scrollRectToVisible(new Rectangle(new Point(lastXpos, curVisible.y), curVisible.getSize()));\n          }\n          list.repaint();\n          return highlightSuccessful;\n        } else\n          return false;\n      }\n\n      @Override\n      public void mouseDragged(MouseEvent e) {\n        if (MatchesPanel.getInstance().isEmpty()) return;\n\n        if (firstMouseEvent != null) {\n          e.consume();\n          JTextField label = ((TreeFromFile) list.getSelectedValue()).getLabel();\n          if(dragNDrop) {\n            if(label == null)\n              return;\n            if(Point2D.distanceSq(e.getX(), e.getY(), firstMouseEvent.getX(), firstMouseEvent.getY()) > 25) {\n              //do DnD\n              list.getTransferHandler().exportAsDrag((JComponent) e.getSource(), firstMouseEvent, TransferHandler.COPY);\n            }\n          } else {\n            addHighlight(label, firstMouseEvent, e);\n          }\n        }\n      }\n\n      private int getCharOffset(FontMetrics fm, String characters, int xPos) {\n        StringBuilder s = new StringBuilder();\n        char[] sArray = characters.toCharArray();\n        int i;\n        for(i = 0; i < characters.length() && fm.stringWidth(s.toString()) < xPos; i++) {\n          s.append(sArray[i]);\n        }\n        return i;\n\n      }\n    };\n\n    list.addMouseMotionListener(mouseListener);\n    list.addMouseListener(mouseListener);\n    listeners = new ArrayList<MatchesPanelListener>();\n    //layout\n    this.setLayout(new BorderLayout());\n    this.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(),\"Matches: \"));\n    JScrollPane scroller = new JScrollPane(list);\n    this.add(scroller, BorderLayout.CENTER);\n  }","id":35743,"modified_method":"private MatchesPanel() {\n    //data\n    DefaultListModel model = new DefaultListModel();\n    list = new TooltipJList<TreeFromFile>(model);\n    list.setCellRenderer(new MatchCellRenderer());\n    list.setTransferHandler(new TreeTransferHandler());\n    matchedParts = Generics.newHashMap();\n    list.addListSelectionListener(this);\n    MouseInputAdapter mouseListener = new MouseInputAdapter() {\n      private boolean dragNDrop = false;\n      @Override\n      public void mousePressed(MouseEvent e) {\n        if (MatchesPanel.getInstance().isEmpty()) return;\n        if(firstMouseEvent == null) {\n          firstMouseEvent = e;\n        }\n        e.consume();\n        TreeFromFile selectedValue = list.getSelectedValue();\n        if(selectedValue == null) return;\n        JTextField label = selectedValue.getLabel();\n        if(((e.getModifiersEx()) & InputEvent.SHIFT_DOWN_MASK) == InputEvent.SHIFT_DOWN_MASK) {\n          //shift is being held\n          addHighlight(label, firstMouseEvent, e);\n        } else if(!HighlightUtils.isInHighlight(e, label, label.getHighlighter())) {\n          label.getHighlighter().removeAllHighlights();\n          firstMouseEvent = e;\n          dragNDrop = false;\n          list.repaint();\n        } else {\n          //in a highlight, if we drag after this, we'll be DnDing\n          dragNDrop = true;\n        }\n      }\n\n      private boolean addHighlight(JTextField label, MouseEvent mouseEvent1, MouseEvent mouseEvent2) {\n        //Two parts: adding the highlight on the label, and scrolling the list appropriately\n        //HighlightUtils handles the first part, we handle the second part here\n        boolean highlightSuccessful = HighlightUtils.addHighlight(label, mouseEvent1, mouseEvent2);\n        FontMetrics fm = label.getFontMetrics(label.getFont());\n        int firstXpos = mouseEvent1.getX();\n        int lastXpos = mouseEvent2.getX();\n        int firstOffset = getCharOffset(fm, label.getText(), firstXpos);\n        int lastOffset = getCharOffset(fm, label.getText(), lastXpos);\n        if(lastOffset != firstOffset) {\n          if(firstOffset > lastOffset) {\n            int tmp = firstOffset;\n            firstOffset = lastOffset;\n            lastOffset = tmp;\n          }\n          Rectangle curVisible = list.getVisibleRect();\n          if(lastXpos > curVisible.x+curVisible.width) {\n            list.scrollRectToVisible(new Rectangle(new Point(lastXpos-curVisible.width, curVisible.y), curVisible.getSize()));\n          } else if(lastXpos < curVisible.x) {\n            list.scrollRectToVisible(new Rectangle(new Point(lastXpos, curVisible.y), curVisible.getSize()));\n          }\n          list.repaint();\n          return highlightSuccessful;\n        } else\n          return false;\n      }\n\n      @Override\n      public void mouseDragged(MouseEvent e) {\n        if (MatchesPanel.getInstance().isEmpty()) return;\n\n        if (firstMouseEvent != null) {\n          e.consume();\n          JTextField label = list.getSelectedValue().getLabel();\n          if(dragNDrop) {\n            if(label == null)\n              return;\n            if(Point2D.distanceSq(e.getX(), e.getY(), firstMouseEvent.getX(), firstMouseEvent.getY()) > 25) {\n              //do DnD\n              list.getTransferHandler().exportAsDrag((JComponent) e.getSource(), firstMouseEvent, TransferHandler.COPY);\n            }\n          } else {\n            addHighlight(label, firstMouseEvent, e);\n          }\n        }\n      }\n\n      private int getCharOffset(FontMetrics fm, String characters, int xPos) {\n        StringBuilder s = new StringBuilder();\n        char[] sArray = characters.toCharArray();\n        int i;\n        for(i = 0; i < characters.length() && fm.stringWidth(s.toString()) < xPos; i++) {\n          s.append(sArray[i]);\n        }\n        return i;\n\n      }\n    };\n\n    list.addMouseMotionListener(mouseListener);\n    list.addMouseListener(mouseListener);\n    listeners = new ArrayList<MatchesPanelListener>();\n    //layout\n    this.setLayout(new BorderLayout());\n    this.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEmptyBorder(),\"Matches: \"));\n    JScrollPane scroller = new JScrollPane(list);\n    this.add(scroller, BorderLayout.CENTER);\n  }","commit_id":"f1383ad9bf51b5f6711751bb49defbe64f40e340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Get the selected tree and its corresponding matched parts\n   * @return a tree that matches the tregex expression\n   */\n  public Pair<TreeFromFile, List<Tree>> getSelectedMatch() {\n    if(!isEmpty()) {\n      TreeFromFile selectedTree = (TreeFromFile) list.getSelectedValue();\n      return new Pair<TreeFromFile,List<Tree>>(selectedTree, matchedParts.get(selectedTree));\n    }\n    else\n      return null;\n  }","id":35744,"modified_method":"/**\n   * Get the selected tree and its corresponding matched parts\n   * @return a tree that matches the tregex expression\n   */\n  public Pair<TreeFromFile, List<Tree>> getSelectedMatch() {\n    if(!isEmpty()) {\n      TreeFromFile selectedTree = list.getSelectedValue();\n      return new Pair<TreeFromFile,List<Tree>>(selectedTree, matchedParts.get(selectedTree));\n    }\n    else\n      return null;\n  }","commit_id":"f1383ad9bf51b5f6711751bb49defbe64f40e340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TooltipJList(ListModel model, int lineWrapLength) {\n    super(model);\n    PROBLEM_LINE_LENGTH = lineWrapLength;\n    \n  }","id":35745,"modified_method":"public TooltipJList(ListModel<E> model, int lineWrapLength) {\n    super(model);\n    PROBLEM_LINE_LENGTH = lineWrapLength;\n  }","commit_id":"f1383ad9bf51b5f6711751bb49defbe64f40e340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public TooltipJList(ListModel model) {\n    this(model, PROBLEM_LINE_LENGTH);\n  }","id":35746,"modified_method":"public TooltipJList(ListModel<E> model) {\n    this(model, PROBLEM_LINE_LENGTH);\n  }","commit_id":"f1383ad9bf51b5f6711751bb49defbe64f40e340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Method for saving the sentences with trees that match the current tregex expression\n   */\n  private void doSaveSentencesFile() {\n    if (chooser == null)\n      chooser = createFileChooser();\n    int status = chooser.showSaveDialog(this);\n    if(status == JFileChooser.APPROVE_OPTION) {\n      Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(chooser.getSelectedFile()), FileTreeModel.getCurEncoding()));\n            StringBuffer sb = MatchesPanel.getInstance().getMatchedSentences();\n            out.write(sb.toString());\n            out.flush();\n            out.close();\n          } catch(Exception e) {\n            System.err.println(\"Exception in save\");\n            e.printStackTrace();\n          }\n        }\n      };\n      t.start();\n    }\n  }","id":35747,"modified_method":"/**\n   * Method for saving the sentences with trees that match the current tregex expression\n   */\n  private void doSaveSentencesFile() {\n    if (chooser == null)\n      chooser = createFileChooser();\n    int status = chooser.showSaveDialog(this);\n    if(status == JFileChooser.APPROVE_OPTION) {\n      Thread t = new Thread() {\n        @Override\n        public void run() {\n          try {\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(chooser.getSelectedFile()), FileTreeModel.getCurEncoding()));\n            String str = MatchesPanel.getInstance().getMatchedSentences();\n            out.write(str);\n            out.flush();\n            out.close();\n          } catch(Exception e) {\n            System.err.println(\"Exception in save\");\n            e.printStackTrace();\n          }\n        }\n      };\n      t.start();\n    }\n  }","commit_id":"f1383ad9bf51b5f6711751bb49defbe64f40e340","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void remove(@NotNull final T element) {\n    int i = myItems.indexOf(element);\n    myItems.remove(element);\n    fireIntervalRemoved(this, i, i);\n  }","id":35748,"modified_method":"public void remove(@NotNull final T element) {\n    int i = myItems.indexOf(element);\n    if (myItems.remove(element)) {\n      fireIntervalRemoved(this, i, i);\n    }\n  }","commit_id":"13e62b1b7c08507e90390604114e2cda622c3cf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Collection<Configuration> getHistoryConfigurations() {\n    return historyConfigurations;\n  }","id":35749,"modified_method":"@NotNull\n  public Collection<Configuration> getHistoryConfigurations() {\n    if (historyConfigurations == null) {\n      return Collections.emptyList();\n    }\n    return historyConfigurations;\n  }","commit_id":"13e62b1b7c08507e90390604114e2cda622c3cf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadConfigurations(Element element) {\n    if (configurations != null) return;\n    ArrayList<Configuration> configurations = new ArrayList<Configuration>();\n    ArrayList<Configuration> historyConfigurations = new ArrayList<Configuration>();\n    readConfigurations(element, configurations, historyConfigurations);\n    for (Configuration configuration : historyConfigurations) {\n      addHistoryConfigurationToFront(configuration);\n    }\n    for (Configuration configuration : configurations) {\n      addConfiguration(configuration);\n    }\n    if (this.historyConfigurations != null) {\n      Collections.reverse(this.historyConfigurations);\n    }\n  }","id":35750,"modified_method":"public void loadConfigurations(Element element) {\n    if (configurations != null) return;\n    ArrayList<Configuration> configurations = new ArrayList<Configuration>();\n    ArrayList<Configuration> historyConfigurations = new ArrayList<Configuration>();\n    readConfigurations(element, configurations, historyConfigurations);\n    this.configurations = configurations;\n    this.historyConfigurations = historyConfigurations;\n  }","commit_id":"13e62b1b7c08507e90390604114e2cda622c3cf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addHistoryConfigurationToFront(Configuration configuration) {\n    if (historyConfigurations == null) historyConfigurations = new LinkedList<Configuration>();\n\n    if (historyConfigurations.indexOf(configuration) == -1) {\n      historyConfigurations.addFirst(configuration);\n    }\n  }","id":35751,"modified_method":"public void addHistoryConfigurationToFront(Configuration configuration) {\n    if (historyConfigurations == null) historyConfigurations = new ArrayList<Configuration>();\n\n    historyConfigurations.remove(configuration);\n    historyConfigurations.add(0, configuration);\n  }","commit_id":"13e62b1b7c08507e90390604114e2cda622c3cf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void addConfigurationToHistory(Configuration configuration) {\n    //configuration.setName( configuration.getName() +\" \"+new Date());\n    historyModel.insertElementAt(configuration, 0);\n    ConfigurationManager configurationManager = StructuralSearchPlugin.getInstance(project).getConfigurationManager();\n    configurationManager.addHistoryConfigurationToFront(configuration);\n    historyList.setSelectedIndex(0);\n\n    if (historyModel.getSize() > 25) {\n      configurationManager.removeHistoryConfiguration(\n        (Configuration)historyModel.getElementAt(25)\n      );\n      // we add by one!\n      historyModel.removeElementAt(25);\n    }\n  }","id":35752,"modified_method":"void addConfigurationToHistory(Configuration configuration) {\n    historyModel.remove(configuration);\n    historyModel.add(0, configuration);\n    final ConfigurationManager configurationManager = StructuralSearchPlugin.getInstance(project).getConfigurationManager();\n    configurationManager.addHistoryConfigurationToFront(configuration);\n    historyList.setSelectedIndex(0);\n\n    if (historyModel.getSize() > 25) {\n      configurationManager.removeHistoryConfiguration(historyModel.getElementAt(25));\n      // we add by one!\n      historyModel.remove(25);\n    }\n  }","commit_id":"13e62b1b7c08507e90390604114e2cda622c3cf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ExistingTemplatesComponent(Project project) {\n\n    this.project = project;\n    final DefaultMutableTreeNode root;\n    patternTreeModel = new DefaultTreeModel(\n      root = new DefaultMutableTreeNode(null)\n    );\n\n    DefaultMutableTreeNode parent = null;\n    String lastCategory = null;\n    LinkedList<Object> nodesToExpand = new LinkedList<Object>();\n\n    final List<Configuration> predefined = StructuralSearchUtil.getPredefinedTemplates();\n    for (final Configuration info : predefined) {\n      final DefaultMutableTreeNode node = new DefaultMutableTreeNode(info);\n\n      if (lastCategory == null || !lastCategory.equals(info.getCategory())) {\n        if (info.getCategory().length() > 0) {\n          root.add(parent = new DefaultMutableTreeNode(info.getCategory()));\n          nodesToExpand.add(parent);\n          lastCategory = info.getCategory();\n        }\n        else {\n          root.add(node);\n          continue;\n        }\n      }\n\n      parent.add(node);\n    }\n\n    parent = new DefaultMutableTreeNode(SSRBundle.message(\"user.defined.category\"));\n    userTemplatesNode = parent;\n    root.add(parent);\n    nodesToExpand.add(parent);\n\n    final ConfigurationManager configurationManager = StructuralSearchPlugin.getInstance(this.project).getConfigurationManager();\n    if (configurationManager.getConfigurations() != null) {\n      for (final Configuration config : configurationManager.getConfigurations()) {\n        parent.add(new DefaultMutableTreeNode(config));\n      }\n    }\n\n    patternTree = createTree(patternTreeModel);\n\n    for (final Object aNodesToExpand : nodesToExpand) {\n      patternTree.expandPath(\n        new TreePath(new Object[]{root, aNodesToExpand})\n      );\n    }\n\n    panel = ToolbarDecorator.createDecorator(patternTree)\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final Object selection = patternTree.getLastSelectedPathComponent();\n          if (!(selection instanceof DefaultMutableTreeNode)) {\n            return;\n          }\n          final DefaultMutableTreeNode node = (DefaultMutableTreeNode)selection;\n          if (!(node.getUserObject() instanceof Configuration)) {\n            return;\n          }\n          final Configuration configuration = (Configuration)node.getUserObject();\n          if (configuration.isPredefined()) {\n            return;\n          }\n          patternTreeModel.removeNodeFromParent(node);\n          configurationManager.removeConfiguration(configuration);\n        }\n      }).setRemoveActionUpdater(new AnActionButtonUpdater() {\n        @Override\n        public boolean isEnabled(AnActionEvent e) {\n          final Object selection = patternTree.getLastSelectedPathComponent();\n          if (selection instanceof DefaultMutableTreeNode) {\n            final DefaultMutableTreeNode node = (DefaultMutableTreeNode)selection;\n            final Object userObject = node.getUserObject();\n            if (userObject instanceof Configuration) {\n              final Configuration configuration = (Configuration)userObject;\n              return !configuration.isPredefined();\n            }\n          }\n          return false;\n        }\n      }).createPanel();\n\n      new JPanel(new BorderLayout());\n\n    configureSelectTemplateAction(patternTree);\n\n    historyModel = new DefaultListModel();\n    historyPanel = new JPanel(new BorderLayout());\n    historyPanel.add(BorderLayout.NORTH, new JLabel(SSRBundle.message(\"used.templates\")));\n\n    historyList = new JBList(historyModel);\n    historyPanel.add(BorderLayout.CENTER, ScrollPaneFactory.createScrollPane(historyList));\n    historyList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n\n    final ListSpeedSearch speedSearch = new ListSpeedSearch(historyList, new Convertor<Object, String>() {\n      @Override\n      public String convert(Object o) {\n        return o instanceof Configuration ? ((Configuration)o).getName() : o.toString();\n      }\n    });\n    historyList.setCellRenderer(new ExistingTemplatesListCellRenderer(speedSearch));\n\n    if (configurationManager.getHistoryConfigurations() != null) {\n      for (final Configuration configuration : configurationManager.getHistoryConfigurations()) {\n        historyModel.addElement(configuration);\n      }\n\n      historyList.setSelectedIndex(0);\n    }\n\n    configureSelectTemplateAction(historyList);\n  }","id":35753,"modified_method":"private ExistingTemplatesComponent(Project project) {\n\n    this.project = project;\n    final DefaultMutableTreeNode root;\n    patternTreeModel = new DefaultTreeModel(\n      root = new DefaultMutableTreeNode(null)\n    );\n\n    DefaultMutableTreeNode parent = null;\n    String lastCategory = null;\n    LinkedList<Object> nodesToExpand = new LinkedList<Object>();\n\n    final List<Configuration> predefined = StructuralSearchUtil.getPredefinedTemplates();\n    for (final Configuration info : predefined) {\n      final DefaultMutableTreeNode node = new DefaultMutableTreeNode(info);\n\n      if (lastCategory == null || !lastCategory.equals(info.getCategory())) {\n        if (info.getCategory().length() > 0) {\n          root.add(parent = new DefaultMutableTreeNode(info.getCategory()));\n          nodesToExpand.add(parent);\n          lastCategory = info.getCategory();\n        }\n        else {\n          root.add(node);\n          continue;\n        }\n      }\n\n      parent.add(node);\n    }\n\n    parent = new DefaultMutableTreeNode(SSRBundle.message(\"user.defined.category\"));\n    userTemplatesNode = parent;\n    root.add(parent);\n    nodesToExpand.add(parent);\n\n    final ConfigurationManager configurationManager = StructuralSearchPlugin.getInstance(this.project).getConfigurationManager();\n    if (configurationManager.getConfigurations() != null) {\n      for (final Configuration config : configurationManager.getConfigurations()) {\n        parent.add(new DefaultMutableTreeNode(config));\n      }\n    }\n\n    patternTree = createTree(patternTreeModel);\n\n    for (final Object aNodesToExpand : nodesToExpand) {\n      patternTree.expandPath(\n        new TreePath(new Object[]{root, aNodesToExpand})\n      );\n    }\n\n    panel = ToolbarDecorator.createDecorator(patternTree)\n      .setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          final Object selection = patternTree.getLastSelectedPathComponent();\n          if (!(selection instanceof DefaultMutableTreeNode)) {\n            return;\n          }\n          final DefaultMutableTreeNode node = (DefaultMutableTreeNode)selection;\n          if (!(node.getUserObject() instanceof Configuration)) {\n            return;\n          }\n          final Configuration configuration = (Configuration)node.getUserObject();\n          if (configuration.isPredefined()) {\n            return;\n          }\n          patternTreeModel.removeNodeFromParent(node);\n          configurationManager.removeConfiguration(configuration);\n        }\n      }).setRemoveActionUpdater(new AnActionButtonUpdater() {\n        @Override\n        public boolean isEnabled(AnActionEvent e) {\n          final Object selection = patternTree.getLastSelectedPathComponent();\n          if (selection instanceof DefaultMutableTreeNode) {\n            final DefaultMutableTreeNode node = (DefaultMutableTreeNode)selection;\n            final Object userObject = node.getUserObject();\n            if (userObject instanceof Configuration) {\n              final Configuration configuration = (Configuration)userObject;\n              return !configuration.isPredefined();\n            }\n          }\n          return false;\n        }\n      }).createPanel();\n\n      new JPanel(new BorderLayout());\n\n    configureSelectTemplateAction(patternTree);\n\n    historyModel = new CollectionListModel<Configuration>(configurationManager.getHistoryConfigurations());\n    historyPanel = new JPanel(new BorderLayout());\n    historyPanel.add(BorderLayout.NORTH, new JLabel(SSRBundle.message(\"used.templates\")));\n\n    historyList = new JBList(historyModel);\n    historyPanel.add(BorderLayout.CENTER, ScrollPaneFactory.createScrollPane(historyList));\n    historyList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    historyList.setSelectedIndex(0);\n\n    final ListSpeedSearch speedSearch = new ListSpeedSearch(historyList, new Convertor<Object, String>() {\n      @Override\n      public String convert(Object o) {\n        return o instanceof Configuration ? ((Configuration)o).getName() : o.toString();\n      }\n    });\n    historyList.setCellRenderer(new ExistingTemplatesListCellRenderer(speedSearch));\n    configureSelectTemplateAction(historyList);\n  }","commit_id":"13e62b1b7c08507e90390604114e2cda622c3cf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"DebuggerManagerThreadImpl() {\n    //noinspection HardCodedStringLiteral\n    super(\"DebuggerManagerThreadImpl\", 2);\n  }","id":35754,"modified_method":"DebuggerManagerThreadImpl() {\n    //noinspection HardCodedStringLiteral\n    super(\"DebuggerManagerThreadImpl\", 3);\n  }","commit_id":"fb7c84df643b46a911f0bd1c15ee361ca34ca262","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void rebuild(final DebuggerContextImpl context) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final DebugProcessImpl process = context.getDebugProcess();\n    if (process == null) {\n      return; // empty context, no process available yet\n    }\n    myDebuggerContext = context;\n    saveState();\n    process.getManagerThread().invokeLater(new DebuggerContextCommandImpl(context){\n      public void threadAction() {\n        getNodeFactory().setHistoryByContext(context);\n      }\n    });\n\n    build(context);\n  }","id":35755,"modified_method":"public void rebuild(final DebuggerContextImpl context) {\n    LOG.assertTrue(SwingUtilities.isEventDispatchThread());\n    final DebugProcessImpl process = context.getDebugProcess();\n    if (process == null) {\n      return; // empty context, no process available yet\n    }\n    myDebuggerContext = context;\n    saveState();\n    process.getManagerThread().invokeLater(new DebuggerContextCommandImpl(context){\n      public void threadAction() {\n        getNodeFactory().setHistoryByContext(context);\n      }\n    }, DebuggerManagerThreadImpl.MEDIUM_PRIORITY);\n\n    build(context);\n  }","commit_id":"fb7c84df643b46a911f0bd1c15ee361ca34ca262","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void buildNode(final DebuggerTreeNodeImpl node) {\n    if (node == null || node.getDescriptor() == null) {\n      return;\n    }\n    final DebugProcessImpl debugProcess = getDebuggerContext().getDebugProcess();\n    if (debugProcess != null) {\n      BuildNodeCommand command = getBuildNodeCommand(node);\n      command.getNode().add(myNodeManager.createMessageNode(MessageDescriptor.EVALUATING));\n      debugProcess.getManagerThread().invokeLater(command);\n    }\n  }","id":35756,"modified_method":"private void buildNode(final DebuggerTreeNodeImpl node) {\n    if (node == null || node.getDescriptor() == null) {\n      return;\n    }\n    final DebugProcessImpl debugProcess = getDebuggerContext().getDebugProcess();\n    if (debugProcess != null) {\n      BuildNodeCommand command = getBuildNodeCommand(node);\n      command.getNode().add(myNodeManager.createMessageNode(MessageDescriptor.EVALUATING));\n      debugProcess.getManagerThread().invokeLater(command, DebuggerManagerThreadImpl.MEDIUM_PRIORITY);\n    }\n  }","commit_id":"fb7c84df643b46a911f0bd1c15ee361ca34ca262","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void buildWhenPaused(DebuggerContextImpl context, RefreshDebuggerTreeCommand command) {\n    DebuggerSession debuggerSession = context.getDebuggerSession();\n\n    if(ApplicationManager.getApplication().isUnitTestMode() || debuggerSession.getState() == DebuggerSession.STATE_PAUSED) {\n      showMessage(MessageDescriptor.EVALUATING);\n      context.getDebugProcess().getManagerThread().invokeLater(command);\n    }\n    else {\n      showMessage(context.getDebuggerSession().getStateDescription());\n    }\n  }","id":35757,"modified_method":"protected final void buildWhenPaused(DebuggerContextImpl context, RefreshDebuggerTreeCommand command) {\n    DebuggerSession debuggerSession = context.getDebuggerSession();\n\n    if(ApplicationManager.getApplication().isUnitTestMode() || debuggerSession.getState() == DebuggerSession.STATE_PAUSED) {\n      showMessage(MessageDescriptor.EVALUATING);\n      context.getDebugProcess().getManagerThread().invokeLater(command, DebuggerManagerThreadImpl.MEDIUM_PRIORITY);\n    }\n    else {\n      showMessage(context.getDebuggerSession().getStateDescription());\n    }\n  }","commit_id":"fb7c84df643b46a911f0bd1c15ee361ca34ca262","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateFrameList(ThreadReferenceProxyImpl thread) {\n      try {\n        if(!getSuspendContext().getDebugProcess().getSuspendManager().isSuspended(thread)) {\n          return;\n        }\n      }\n      catch (ObjectCollectedException e) {\n        return;\n      }\n      EvaluationContextImpl evaluationContext = getDebuggerContext().createEvaluationContext();\n      final DefaultListModel model = myFramesList.getModel();\n      final int size = model.getSize();\n      for (int i = 0; i < size; i++) {\n        final StackFrameDescriptorImpl descriptor = (StackFrameDescriptorImpl)model.getElementAt(i);\n        descriptor.setContext(evaluationContext);\n        descriptor.updateRepresentation(evaluationContext, DescriptorLabelListener.DUMMY_LISTENER);\n      }\n    }","id":35758,"modified_method":"private void updateFrameList(ThreadReferenceProxyImpl thread) {\n      try {\n        if(!getSuspendContext().getDebugProcess().getSuspendManager().isSuspended(thread)) {\n          return;\n        }\n      }\n      catch (ObjectCollectedException e) {\n        return;\n      }\n      EvaluationContextImpl evaluationContext = getDebuggerContext().createEvaluationContext();\n      final DefaultListModel model = myFramesList.getModel();\n      final int size = model.getSize();\n      for (int i = 0; i < size; i++) {\n        final Object elem = model.getElementAt(i);\n        if (elem instanceof StackFrameDescriptorImpl) {\n          final StackFrameDescriptorImpl descriptor = (StackFrameDescriptorImpl)elem;\n          descriptor.setContext(evaluationContext);\n          descriptor.updateRepresentation(evaluationContext, DescriptorLabelListener.DUMMY_LISTENER);\n        }\n      }\n    }","commit_id":"fb7c84df643b46a911f0bd1c15ee361ca34ca262","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void contextAction() throws Exception {\n      final List<StackFrameDescriptorImpl> frameItems = getFrameList(myDebuggerContext.getThreadProxy());\n      DebuggerInvocationUtil.invokeLater(getProject(), new Runnable() {\n        public void run() {\n          try {\n            myFramesListener.setEnabled(false);\n            myFramesList.clear();\n            final DefaultListModel listModel = myFramesList.getModel();\n            for (final StackFrameDescriptorImpl frameItem : frameItems) {\n              listModel.addElement(frameItem);\n            }\n            final StackFrameProxyImpl contextFrame = getDebuggerContext().getFrameProxy();\n            if(contextFrame != null) {\n              selectFrame(contextFrame);\n            }\n          }\n          finally {\n            myFramesListener.setEnabled(true);\n          }\n        }\n      });\n\n    }","id":35759,"modified_method":"public void contextAction() throws Exception {\n      final ThreadReferenceProxyImpl thread = myDebuggerContext.getThreadProxy();\n      try {\n        if(!getSuspendContext().getDebugProcess().getSuspendManager().isSuspended(thread)) {\n          return;\n        }\n      }\n      catch (ObjectCollectedException e) {\n        return;\n      }\n      \n      List<StackFrameProxyImpl> frames;\n      try {\n        frames = thread.frames();\n      }\n      catch (EvaluateException e) {\n        frames = Collections.emptyList();\n      }\n\n      final StackFrameProxyImpl contextFrame = myDebuggerContext.getFrameProxy();\n      final EvaluationContextImpl evaluationContext = myDebuggerContext.createEvaluationContext();\n      final DebuggerManagerThreadImpl managerThread = myDebuggerContext.getDebugProcess().getManagerThread();\n      final MethodsTracker tracker = new MethodsTracker();\n      final int totalFramesCount = frames.size();\n      int index = 0;\n      for (StackFrameProxyImpl stackFrameProxy : frames) {\n        managerThread.invokeLater(\n          new AppendFrameCommand(getSuspendContext(), stackFrameProxy, evaluationContext, tracker, index++, stackFrameProxy.equals(contextFrame), totalFramesCount)\n        );\n      }\n    }","commit_id":"fb7c84df643b46a911f0bd1c15ee361ca34ca262","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void selectFrame(StackFrameProxy frame) {\n    final int count = myFramesList.getElementCount();\n    final StackFrameDescriptorImpl selectedValue = (StackFrameDescriptorImpl)myFramesList.getSelectedValue();\n    final DefaultListModel model = myFramesList.getModel();\n    for (int idx = 0; idx < count; idx++) {\n      StackFrameDescriptorImpl item = (StackFrameDescriptorImpl)model.getElementAt(idx);\n      if (frame.equals(item.getFrameProxy())) {\n        if (!item.equals(selectedValue)) {\n          myFramesList.setSelectedIndex(idx);\n        }\n        return;\n      }\n    }\n  }","id":35760,"modified_method":"private void selectFrame(StackFrameProxy frame) {\n    final int count = myFramesList.getElementCount();\n    final Object selectedValue = myFramesList.getSelectedValue();\n    final DefaultListModel model = myFramesList.getModel();\n    for (int idx = 0; idx < count; idx++) {\n      final Object elem = model.getElementAt(idx);\n      if (elem instanceof StackFrameDescriptorImpl) {\n        final StackFrameDescriptorImpl item = (StackFrameDescriptorImpl)elem;\n        if (frame.equals(item.getFrameProxy())) {\n          if (!item.equals(selectedValue)) {\n            myFramesList.setSelectedIndex(idx);\n          }\n          return;\n        }\n      }\n    }\n  }","commit_id":"fb7c84df643b46a911f0bd1c15ee361ca34ca262","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void customizeCellRenderer(final JList list, final Object item, final int index, final boolean selected, final boolean hasFocus) {\n    final StackFrameDescriptorImpl descriptor = (StackFrameDescriptorImpl)item;\n    setIcon(descriptor.getIcon());\n    final StackFrameDescriptorImpl selectedDescriptor = (StackFrameDescriptorImpl)((FramesList)list).getSelectedValue();\n    final boolean shouldHighlightAsRecursive = isOccurrenceOfSelectedFrame(selectedDescriptor, descriptor);\n\n    final ValueMarkup markup = descriptor.getValueMarkup();\n    if (markup != null) {\n      append(markup.getText(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_BOLD, markup.getColor()));\n    }\n    \n    if (selected) {\n      setBackground(com.intellij.util.ui.UIUtil.getListSelectionBackground());\n    }\n    else {\n      setBackground(shouldHighlightAsRecursive ? myColorScheme.getColor(DebuggerColors.RECURSIVE_CALL_ATTRIBUTES) : com.intellij.util.ui.UIUtil.getListBackground());\n    }\n\n    final String label = descriptor.getLabel();\n    final int openingBrace = label.indexOf(\"{\");\n    final int closingBrace = (openingBrace < 0) ? -1 : label.indexOf(\"}\");\n    final SimpleTextAttributes attributes = getAttributes(descriptor);\n    if (openingBrace < 0 || closingBrace < 0) {\n      append(label, attributes);\n    }\n    else {\n      append(label.substring(0, openingBrace - 1), attributes);\n\n      final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n      try {\n        builder.append(\" (\");\n        builder.append(label.substring(openingBrace + 1, closingBrace));\n        builder.append(\")\");\n        append(builder.toString(), SimpleTextAttributes.GRAY_ITALIC_ATTRIBUTES);\n      }\n      finally {\n        StringBuilderSpinAllocator.dispose(builder);\n      }\n\n      append(label.substring(closingBrace + 1, label.length()), attributes);\n      if (shouldHighlightAsRecursive && descriptor.isRecursiveCall()) {\n        final StringBuilder _builder = StringBuilderSpinAllocator.alloc();\n        try {\n          _builder.append(\" [\").append(descriptor.getOccurrenceIndex()).append(\"]\");\n          append(_builder.toString(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n        }\n        finally {\n          StringBuilderSpinAllocator.dispose(_builder);\n        }\n      }\n    }\n  }","id":35761,"modified_method":"protected void customizeCellRenderer(final JList list, final Object item, final int index, final boolean selected, final boolean hasFocus) {\n    if (!(item instanceof StackFrameDescriptorImpl)) {\n      append(item.toString(), SimpleTextAttributes.GRAYED_ATTRIBUTES);\n    }\n    else {\n      final StackFrameDescriptorImpl descriptor = (StackFrameDescriptorImpl)item;\n      setIcon(descriptor.getIcon());\n      final StackFrameDescriptorImpl selectedDescriptor = (StackFrameDescriptorImpl)((FramesList)list).getSelectedValue();\n      final boolean shouldHighlightAsRecursive = isOccurrenceOfSelectedFrame(selectedDescriptor, descriptor);\n\n      final ValueMarkup markup = descriptor.getValueMarkup();\n      if (markup != null) {\n        append(markup.getText(), new SimpleTextAttributes(SimpleTextAttributes.STYLE_BOLD, markup.getColor()));\n      }\n\n      if (selected) {\n        setBackground(com.intellij.util.ui.UIUtil.getListSelectionBackground());\n      }\n      else {\n        setBackground(shouldHighlightAsRecursive ? myColorScheme.getColor(DebuggerColors.RECURSIVE_CALL_ATTRIBUTES) : com.intellij.util.ui.UIUtil.getListBackground());\n      }\n\n      final String label = descriptor.getLabel();\n      final int openingBrace = label.indexOf(\"{\");\n      final int closingBrace = (openingBrace < 0) ? -1 : label.indexOf(\"}\");\n      final SimpleTextAttributes attributes = getAttributes(descriptor);\n      if (openingBrace < 0 || closingBrace < 0) {\n        append(label, attributes);\n      }\n      else {\n        append(label.substring(0, openingBrace - 1), attributes);\n\n        final StringBuilder builder = StringBuilderSpinAllocator.alloc();\n        try {\n          builder.append(\" (\");\n          builder.append(label.substring(openingBrace + 1, closingBrace));\n          builder.append(\")\");\n          append(builder.toString(), SimpleTextAttributes.GRAY_ITALIC_ATTRIBUTES);\n        }\n        finally {\n          StringBuilderSpinAllocator.dispose(builder);\n        }\n\n        append(label.substring(closingBrace + 1, label.length()), attributes);\n        if (shouldHighlightAsRecursive && descriptor.isRecursiveCall()) {\n          final StringBuilder _builder = StringBuilderSpinAllocator.alloc();\n          try {\n            _builder.append(\" [\").append(descriptor.getOccurrenceIndex()).append(\"]\");\n            append(_builder.toString(), SimpleTextAttributes.REGULAR_BOLD_ATTRIBUTES);\n          }\n          finally {\n            StringBuilderSpinAllocator.dispose(_builder);\n          }\n        }\n      }\n    }\n  }","commit_id":"fb7c84df643b46a911f0bd1c15ee361ca34ca262","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FilterComponent(@NonNls String propertyName, int historySize, boolean onTheFlyUpdate) {\n    super(new BorderLayout());\n    myOnTheFly = onTheFlyUpdate;\n    myFilter = new SearchTextFieldWithStoredHistory(propertyName) {\n      @Override\n      protected Runnable createItemChosenCallback(JList list) {\n        final Runnable callback = super.createItemChosenCallback(list);\n        return new Runnable() {\n          @Override\n          public void run() {\n            callback.run();\n            filter();\n          }\n        };\n      }\n\n      @Override\n      protected Component getPopupLocationComponent() {\n        return FilterComponent.this.getPopupLocationComponent();\n      }\n    };\n    myFilter.getTextEditor().addKeyListener(new KeyAdapter() {\n      //to consume enter in combo box - do not process this event by default button from DialogWrapper\n      public void keyPressed(final KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n          e.consume();\n          myFilter.addCurrentTextToHistory();\n          filter();\n        } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n          onEscape(e);\n        }\n      }\n    });\n\n    myFilter.addDocumentListener(new DocumentListener() {\n      public void insertUpdate(DocumentEvent e) {\n        onChange();\n      }\n\n      public void removeUpdate(DocumentEvent e) {\n        onChange();\n      }\n\n      public void changedUpdate(DocumentEvent e) {\n        onChange();\n      }\n    });\n\n    myFilter.setHistorySize(historySize);\n    add(myFilter, BorderLayout.CENTER);    \n  }","id":35762,"modified_method":"public FilterComponent(@NonNls String propertyName, int historySize, boolean onTheFlyUpdate) {\n    super(new BorderLayout());\n    myOnTheFly = onTheFlyUpdate;\n    myFilter = new SearchTextFieldWithStoredHistory(propertyName) {\n      @Override\n      protected Runnable createItemChosenCallback(JList list) {\n        final Runnable callback = super.createItemChosenCallback(list);\n        return new Runnable() {\n          @Override\n          public void run() {\n            callback.run();\n            filter();\n          }\n        };\n      }\n\n      @Override\n      protected Component getPopupLocationComponent() {\n        return FilterComponent.this.getPopupLocationComponent();\n      }\n\n      @Override\n      protected void onFocusLost() {\n        addCurrentTextToHistory();\n        super.onFocusLost();\n      }\n    };\n    myFilter.getTextEditor().addKeyListener(new KeyAdapter() {\n      //to consume enter in combo box - do not process this event by default button from DialogWrapper\n      public void keyPressed(final KeyEvent e) {\n        if (e.getKeyCode() == KeyEvent.VK_ENTER) {\n          e.consume();\n          myFilter.addCurrentTextToHistory();\n          filter();\n        } else if (e.getKeyCode() == KeyEvent.VK_ESCAPE) {\n          onEscape(e);\n        }\n      }\n    });\n\n    myFilter.addDocumentListener(new DocumentListener() {\n      public void insertUpdate(DocumentEvent e) {\n        onChange();\n      }\n\n      public void removeUpdate(DocumentEvent e) {\n        onChange();\n      }\n\n      public void changedUpdate(DocumentEvent e) {\n        onChange();\n      }\n    });\n\n    myFilter.setHistorySize(historySize);\n    add(myFilter, BorderLayout.CENTER);    \n  }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void addCurrentTextToHistory() {\n    final String item = getText();\n    myModel.addElement(item);\n  }","id":35763,"modified_method":"public void addCurrentTextToHistory() {\n    if ((myNativeSearchPopup != null && myNativeSearchPopup.isVisible()) || (myPopup != null && myPopup.isVisible())) {\n      return;\n    }\n    final String item = getText();\n    myModel.addElement(item);\n  }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void insertElementAt(Object obj, int index) {\n      myFullList.add(index, (String)obj);\n      fireContentsChanged();\n    }","id":35764,"modified_method":"public void insertElementAt(String item, int index) {\n      myFullList.add(index, item);\n      fireContentsChanged();\n    }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<String> getHistory() {\n    final int itemsCount = myModel.getSize();\n    List<String> history = new ArrayList<String>(itemsCount);\n    for (int i = 0; i < itemsCount; i++) {\n      history.add((String)myModel.getElementAt(i));\n    }\n    return history;\n  }","id":35765,"modified_method":"public List<String> getHistory() {\n    final int itemsCount = myModel.getSize();\n    final List<String> history = new ArrayList<String>(itemsCount);\n    for (int i = 0; i < itemsCount; i++) {\n      history.add(myModel.getElementAt(i));\n    }\n    return history;\n  }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateMenu() {\n    if (myNativeSearchPopup != null) {\n      myNativeSearchPopup.removeAll();\n      final int itemsCount = myModel.getSize();\n      if (itemsCount == 0) {\n        myNativeSearchPopup.add(myNoItems);\n      }\n      else {\n        for (int i = 0; i < itemsCount; i++) {\n          String item = (String)myModel.getElementAt(i);\n          addMenuItem(item);\n        }\n      }\n    }\n  }","id":35766,"modified_method":"private void updateMenu() {\n    if (myNativeSearchPopup != null) {\n      myNativeSearchPopup.removeAll();\n      final int itemsCount = myModel.getSize();\n      if (itemsCount == 0) {\n        myNativeSearchPopup.add(myNoItems);\n      }\n      else {\n        for (int i = 0; i < itemsCount; i++) {\n          final String item = myModel.getElementAt(i);\n          addMenuItem(item);\n        }\n      }\n    }\n  }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setSelectedItem(Object anItem) {\n      mySelectedItem = anItem;\n    }","id":35767,"modified_method":"public void setSelectedItem(String anItem) {\n      mySelectedItem = anItem;\n    }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getSelectedItem() {\n      return mySelectedItem;\n    }","id":35768,"modified_method":"public String getSelectedItem() {\n      return mySelectedItem;\n    }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Runnable createItemChosenCallback(final JList list) {\n    return new Runnable() {\n      public void run() {\n        final String value = (String)list.getSelectedValue();\n        getTextEditor().setText(value != null ? value : \"\");\n        if (myPopup != null) {\n          myPopup.cancel();\n          myPopup = null;\n        }\n      }\n    };\n  }","id":35769,"modified_method":"protected Runnable createItemChosenCallback(final JList list) {\n    return new Runnable() {\n      public void run() {\n        final String value = (String)list.getSelectedValue();\n        getTextEditor().setText(value != null ? value : \"\");\n        addCurrentTextToHistory();\n        if (myPopup != null) {\n          myPopup.cancel();\n          myPopup = null;\n        }\n      }\n    };\n  }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object getElementAt(int index) {\n      return myFullList.get(index);\n    }","id":35770,"modified_method":"public String getElementAt(int index) {\n      return myFullList.get(index);\n    }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void addMenuItem(final String item) {\n    if (myNativeSearchPopup != null) {\n      myNativeSearchPopup.remove(myNoItems);\n      final JMenuItem menuItem = new JBMenuItem(item);\n      myNativeSearchPopup.add(menuItem);\n      menuItem.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n          myTextField.setText(item);\n        }\n      });\n    }\n  }","id":35771,"modified_method":"private void addMenuItem(final String item) {\n    if (myNativeSearchPopup != null) {\n      myNativeSearchPopup.remove(myNoItems);\n      final JMenuItem menuItem = new JBMenuItem(item);\n      myNativeSearchPopup.add(menuItem);\n      menuItem.addActionListener(new ActionListener() {\n        public void actionPerformed(final ActionEvent e) {\n          myTextField.setText(item);\n          addCurrentTextToHistory();\n        }\n      });\n    }\n  }","commit_id":"946216e607369f0f3b43dcf00879856f6b4ec28f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean hasActions(KeyEvent event) {\n    if (findAction(this, event) != null) {\n      return true;\n    }\n    if (myChildKeyMaps != null) {\n      Iterator<EditorCellKeyMap> iterator = myChildKeyMaps.iterator();\n      while (iterator.hasNext()) {\n        EditorCellKeyMap childKeyMap = iterator.next();\n        if (findAction(childKeyMap, event) != null) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":35772,"modified_method":"public boolean hasActions(KeyEvent event) {\n    if (findActions(this, event).size() > 0) {\n      return true;\n    }\n    if (myChildKeyMaps != null) {\n      Iterator<EditorCellKeyMap> iterator = myChildKeyMaps.iterator();\n      while (iterator.hasNext()) {\n        EditorCellKeyMap childKeyMap = iterator.next();\n        if (findActions(childKeyMap, event).size() > 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"e1329babb564e69c3a99c20fe019f987839f1ae6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void putAction(String modifiers, String keyCode, EditorCellKeyMapAction action) {\n    myActionMap.put(new ActionKey(modifiers, keyCode), action);\n  }","id":35773,"modified_method":"public void putAction(String modifiers, String keyCode, EditorCellKeyMapAction action) {\n    ActionKey key = new ActionKey(modifiers, keyCode);\n    if (!myActionMap.containsKey(key)) {\n      myActionMap.put(key, action);\n    } else {\n      addToDuplicatedActions(key, action);\n    }\n  }","commit_id":"e1329babb564e69c3a99c20fe019f987839f1ae6","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<EditorCellKeyMapAction> getActions(KeyEvent event) {\n    List<EditorCellKeyMapAction> list = new LinkedList<EditorCellKeyMapAction>();\n    EditorCellKeyMapAction keyMapAction = findAction(this, event);\n    if (keyMapAction != null) {\n      list.add(keyMapAction);\n    }\n    if (myChildKeyMaps != null) {\n      Iterator<EditorCellKeyMap> iterator = myChildKeyMaps.iterator();\n      while (iterator.hasNext()) {\n        EditorCellKeyMap childKeyMap = iterator.next();\n        keyMapAction = findAction(childKeyMap, event);\n        if (keyMapAction != null) {\n          list.add(keyMapAction);\n        }\n      }\n    }\n    return list;\n  }","id":35774,"modified_method":"public List<EditorCellKeyMapAction> getActions(KeyEvent event) {\n    List<EditorCellKeyMapAction> result = null;\n    List<EditorCellKeyMapAction> actions = findActions(this, event);\n    if (actions.size() > 0) {\n      if (result == null) result = new LinkedList<EditorCellKeyMapAction>();\n      result.addAll(actions);\n    }\n    if (myChildKeyMaps != null) {\n      for (EditorCellKeyMap childKeyMap : myChildKeyMaps) {\n        actions = findActions(childKeyMap, event);\n        if (actions.size() > 0) {\n          if (result == null) result = new LinkedList<EditorCellKeyMapAction>();\n          result.addAll(actions);\n        }\n      }\n    }\n    if (result == null) return Collections.emptyList();\n    return result;\n  }","commit_id":"e1329babb564e69c3a99c20fe019f987839f1ae6","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static EditorCellKeyMapAction findAction(EditorCellKeyMap keyMap, KeyEvent event) {\n    List<ActionKey> actionKeies = keyEvent2ActionKey(event);\n    for (int i = 0; i < actionKeies.size(); i++) {\n      ActionKey actionKey = actionKeies.get(i);\n      EditorCellKeyMapAction editorCellAction = keyMap.myActionMap.get(actionKey);\n      if (editorCellAction != null) {\n        LOG.debug(\"keymap action found for key: \" + actionKey);\n        return editorCellAction;\n      }\n    }\n    return null;\n  }","id":35775,"modified_method":"private static List<EditorCellKeyMapAction> findActions(EditorCellKeyMap keyMap, KeyEvent event) {\n    List<EditorCellKeyMapAction> result = null;\n    List<ActionKey> actionKeies = keyEvent2ActionKey(event);\n    for (ActionKey actionKey : actionKeies) {\n      EditorCellKeyMapAction action = keyMap.myActionMap.get(actionKey);\n      if (action != null) {\n        if (result == null) result = new LinkedList<EditorCellKeyMapAction>();\n        LOG.debug(\"keymap action \" + (result.isEmpty() ? \"\" : \"[\" + result.size() + \"]\") + \" found for key: \" + actionKey);\n        result.add(action);\n      }\n\n      List<EditorCellKeyMapAction> extraActions = lookupDuplicatedActions(actionKey, keyMap.myDuplicatedActionList);\n      if (extraActions.size() > 0) {\n        LOG.debug(\"keymap action found [\" + extraActions.size() + \"] extra actions for key: \" + actionKey);\n        if (result == null) result = new LinkedList<EditorCellKeyMapAction>();\n        result.addAll(extraActions);\n      }\n    }\n\n    if (result == null) return Collections.emptyList();\n    return result;\n  }","commit_id":"e1329babb564e69c3a99c20fe019f987839f1ae6","url":"https://github.com/JetBrains/MPS"},{"original_method":"StackMapEntry(DataInputStream file) throws IOException {\n        file.readShort();   // Unused byte_code_offset\n        file.readShort();   // Unused number_of_locals\n    }","id":35776,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    StackMapEntry(DataInputStream file) throws IOException {\n        this(file.readShort(), file.readShort(), null, -1, null);\n        types_of_locals = new StackMapType[number_of_locals];\n        for (int i = 0; i < number_of_locals; i++) {\n            types_of_locals[i] = new StackMapType(file);\n        }\n        number_of_stack_items = file.readShort();\n        types_of_stack_items = new StackMapType[number_of_stack_items];\n        for (int i = 0; i < number_of_stack_items; i++) {\n            types_of_stack_items[i] = new StackMapType(file);\n        }\n    }","commit_id":"80788f9c801e25b439cb3f00ba8fece5cec16294","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    StackMapTableEntry(DataInputStream file) throws IOException {\n        file.read();    // Unused frame_type\n    }","id":35777,"modified_method":"/**\n     * Construct object from file stream.\n     * @param file Input stream\n     * @throws IOException\n     */\n    StackMapTableEntry(DataInputStream file) throws IOException {\n        this(file.read(), -1, null, -1, null);\n\n        if (frame_type >= Constants.SAME_FRAME && frame_type <= Constants.SAME_FRAME_MAX) {\n            // NO-OP\n        } else if (frame_type >= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME && frame_type <= Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n            number_of_stack_items = 1;\n            types_of_stack_items = new StackMapType[1];\n            types_of_stack_items[0] = new StackMapType(file);\n        } else if (frame_type == Constants.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n            file.readShort(); // Unused byte_code_offset_delta\n            number_of_stack_items = 1;\n            types_of_stack_items = new StackMapType[1];\n            types_of_stack_items[0] = new StackMapType(file);\n        } else if (frame_type >= Constants.CHOP_FRAME && frame_type <= Constants.CHOP_FRAME_MAX) {\n            file.readShort(); // Unused byte_code_offset_delta\n        } else if (frame_type == Constants.SAME_FRAME_EXTENDED) {\n            file.readShort(); // Unused byte_code_offset_delta\n        } else if (frame_type >= Constants.APPEND_FRAME && frame_type <= Constants.APPEND_FRAME_MAX) {\n            file.readShort(); // Unused byte_code_offset_delta\n            number_of_locals = frame_type - 251;\n            types_of_locals = new StackMapType[number_of_locals];\n            for (int i = 0; i < number_of_locals; i++) {\n                types_of_locals[i] = new StackMapType(file);\n            }\n        } else if (frame_type == Constants.FULL_FRAME) {\n            file.readShort(); // Unused byte_code_offset_delta\n            number_of_locals = file.readShort();\n            types_of_locals = new StackMapType[number_of_locals];\n            for (int i = 0; i < number_of_locals; i++) {\n                types_of_locals[i] = new StackMapType(file);\n            }\n            number_of_stack_items = file.readShort();\n            types_of_stack_items = new StackMapType[number_of_stack_items];\n            for (int i = 0; i < number_of_stack_items; i++) {\n                types_of_stack_items[i] = new StackMapType(file);\n            }\n        } else {\n            /* Can't happen */\n            throw new ClassFormatException (\"Invalid frame type found while parsing stack map table: \" + frame_type);\n        }\n    }","commit_id":"80788f9c801e25b439cb3f00ba8fece5cec16294","url":"https://github.com/apache/tomcat"},{"original_method":"public int serializedSize() {\n        int retval=super.serializedSize();\n        retval+=Global.SHORT_SIZE; // for size of subgroups vector\n        if(subgroups == null)\n            return retval;\n        for(View v: subgroups) {\n            retval+=Global.SHORT_SIZE + Global.LONG_SIZE // creator and ID (ViewId)\n              + Global.SHORT_SIZE; // number of members in the subview\n            retval+=v.size() * Global.SHORT_SIZE; // a short (index) for each member\n        }\n        return retval;\n    }","id":35778,"modified_method":"public int serializedSize() {\n        int retval=super.serializedSize();\n        retval+=Global.SHORT_SIZE; // for size of subgroups vector\n        if(subgroups == null)\n            return retval;\n        for(View v: subgroups) {\n            retval+=Global.SHORT_SIZE + Global.LONG_SIZE // creator and ID (ViewId)\n              + Global.SHORT_SIZE; // number of members in the subview\n\n            Address creator=v.getCreator();\n            if(get(creator) < 0)\n                retval+=Util.size(creator);\n\n            retval+=v.size() * Global.SHORT_SIZE; // a short (index) for each member\n            for(Address sub_mbr: v) {\n                int index=get(sub_mbr);\n                if(index < 0)\n                    retval+=Util.size(sub_mbr);\n            }\n        }\n        return retval;\n    }","commit_id":"53b639159283d9f108675601375b658b396db421","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutput out) throws Exception {\n        super.writeTo(out);\n\n        // write subgroups\n        int len=subgroups != null? subgroups.length : 0;\n        out.writeShort(len);\n        if(len == 0)\n            return;\n        for(View v: subgroups) {\n            int index=get(v.getCreator());\n            out.writeShort(index);\n            out.writeLong(v.getViewId().getId());\n\n            int num_mbrs=v.size();\n            out.writeShort(num_mbrs);\n            for(Address mbr: v)\n                out.writeShort(get(mbr));\n        }\n    }","id":35779,"modified_method":"public void writeTo(DataOutput out) throws Exception {\n        super.writeTo(out);\n\n        // write subgroups\n        int len=subgroups != null? subgroups.length : 0;\n        out.writeShort(len);\n        if(len == 0)\n            return;\n        for(View v: subgroups) {\n            int index=get(v.getCreator());\n            out.writeShort(index);\n            // if we don't find the member, write the addres (https://issues.jboss.org/browse/JGRP-1707)\n            if(index < 0)\n                Util.writeAddress(v.getCreator(), out);\n\n            out.writeLong(v.getViewId().getId());\n\n            int num_mbrs=v.size();\n            out.writeShort(num_mbrs);\n            for(Address mbr: v) {\n                index=get(mbr);\n                out.writeShort(index);\n                if(index < 0)\n                    Util.writeAddress(mbr, out);\n            }\n        }\n    }","commit_id":"53b639159283d9f108675601375b658b396db421","url":"https://github.com/belaban/JGroups"},{"original_method":"public void readFrom(DataInput in) throws Exception {\n        super.readFrom(in);\n        short len=in.readShort();\n        if(len > 0) {\n            subgroups=new View[len];\n            for(int i=0; i < len; i++) {\n                int index=in.readShort();\n                long id=in.readLong();\n                Address creator=get(index);\n                Address[] mbrs=new Address[in.readShort()];\n                for(int j=0; j < mbrs.length; j++)\n                    mbrs[j]=get(in.readShort());\n                View view=View.create(creator, id, mbrs);\n                subgroups[i]=view;\n            }\n        }\n    }","id":35780,"modified_method":"public void readFrom(DataInput in) throws Exception {\n        super.readFrom(in);\n        short len=in.readShort();\n        if(len > 0) {\n            subgroups=new View[len];\n            for(int i=0; i < len; i++) {\n                int index=in.readShort();\n                Address creator=index >= 0 ? get(index) : Util.readAddress(in);\n                long id=in.readLong();\n                Address[] mbrs=new Address[in.readShort()];\n                for(int j=0; j < mbrs.length; j++) {\n                    index=in.readShort();\n                    mbrs[j]=index >= 0? get(index) : Util.readAddress(in);\n                }\n                try {\n                    View view=View.create(creator, id, mbrs);\n                    subgroups[i]=view;\n                }\n                catch(Throwable t) {\n                }\n            }\n        }\n    }","commit_id":"53b639159283d9f108675601375b658b396db421","url":"https://github.com/belaban/JGroups"},{"original_method":"private static void _testSize(View v, Class<? extends Streamable> view_class) throws Exception {\n        long size=v.serializedSize();\n        byte[] serialized_form=Util.streamableToByteBuffer(v);\n        System.out.println(\"size=\" + size + \", serialized size=\" + serialized_form.length);\n        Assert.assertEquals(serialized_form.length, size);\n\n        View view=(View)Util.streamableFromByteBuffer(view_class,serialized_form);\n        System.out.println(\"old view: \" + v + \"\\nnew view: \" + view);\n        assert view.equals(v);\n    }","id":35781,"modified_method":"private static View _testSize(View v, Class<? extends Streamable> view_class) throws Exception {\n        long size=v.serializedSize();\n        byte[] serialized_form=Util.streamableToByteBuffer(v);\n        System.out.println(\"size=\" + size + \", serialized size=\" + serialized_form.length);\n        Assert.assertEquals(serialized_form.length, size);\n\n        View view=(View)Util.streamableFromByteBuffer(view_class,serialized_form);\n        System.out.println(\"old view: \" + v + \"\\nnew view: \" + view);\n        assert view.equals(v);\n        return view;\n    }","commit_id":"53b639159283d9f108675601375b658b396db421","url":"https://github.com/belaban/JGroups"},{"original_method":"public static ReteooStatefulSession readSession (ReteooStatefulSession session, \n                                                     DefaultAgenda agenda, \n                                                     long time, \n                                                     boolean multithread,\n                                                     MarshallerReaderContext context) throws IOException, ClassNotFoundException {\n               if ( session.getTimerService() instanceof PseudoClockScheduler ) {            \n                   PseudoClockScheduler clock = ( PseudoClockScheduler )  session.getTimerService();\n                   clock.advanceTime( time, TimeUnit.MILLISECONDS );\n               }           \n               \n               // RuleFlowGroups need to reference the session\n               for ( RuleFlowGroup group : agenda.getRuleFlowGroupsMap().values() ) {\n                   ((RuleFlowGroupImpl) group).setWorkingMemory( session );\n               }\n\n               context.wm = session;\n               \n               context.handles.put( context.wm.getInitialFactHandle().getId(),  context.wm.getInitialFactHandle() );\n\n               int token;\n               \n               if ( context.stream.readBoolean() ) {\n                   InternalFactHandle initialFactHandle = context.wm.getInitialFactHandle();\n                   int sinkId = context.stream.readInt();\n                   ObjectTypeNode initialFactNode = (ObjectTypeNode) context.sinks.get( sinkId );\n                   ObjectHashSet initialFactMemory = (ObjectHashSet) context.wm.getNodeMemory( initialFactNode );\n\n                   initialFactMemory.add( initialFactHandle );\n                   readRightTuples( initialFactHandle,\n                                    context );\n               }           \n               while ((token = context.readShort()) == PersisterEnums.ENTRY_POINT) {\n                   String entryPointId = context.stream.readUTF();\n                   WorkingMemoryEntryPoint wmep = context.wm.getEntryPoints().get( entryPointId );\n                   readFactHandles( context,  (( NamedEntryPoint )wmep).getObjectStore() ); \n               }\n               InternalFactHandle handle = context.wm.getInitialFactHandle();\n               while ( context.stream.readShort() == PersisterEnums.LEFT_TUPLE ) {\n                   LeftTupleSink sink = (LeftTupleSink) context.sinks.get( context.stream.readInt() );\n                   LeftTuple leftTuple = sink.createLeftTuple( handle,\n                                                               sink,\n                                                               true );\n                   readLeftTuple( leftTuple,\n                                  context );\n               }               \n               \n               readPropagationContexts( context );\n\n               readActivations( context ); \n\n               readActionQueue( context );\n\n               readTruthMaintenanceSystem( context );\n\n               if ( processMarshaller != null) {\n                   processMarshaller.readProcessInstances( context );\n               }\n               else { \n                   short type = context.stream.readShort(); \n                   if( PersisterEnums.END != type ) { \n                       throw new IllegalStateException(\"No process marshaller, unable to unmarshall type: \" + type);\n                   }\n               }\n\n               if ( processMarshaller != null) {\n                   processMarshaller.readWorkItems( context );\n               }\n               else { \n                   short type = context.stream.readShort();\n                   if( PersisterEnums.END != type ) { \n                       throw new IllegalStateException(\"No process marshaller, unable to unmarshall type: \" + type);\n                   }\n               }\n\n               if (processMarshaller != null) {\n                   // This actually does ALL timers, due to backwards compatability issues\n                   // It will read in old JBPM binaries, but always write to the new binary format.\n                   processMarshaller.readProcessTimers( context );\n               } else {\n                   short type = context.stream.readShort();\n                   if( PersisterEnums.END != type ) { \n                       throw new IllegalStateException(\"No process marshaller, unable to unmarshall type: \" + type);\n                   }\n               }\n                   \n               // no legacy jBPM timers, so handle locally\n               while ((token = context.readShort()) == PersisterEnums.DEFAULT_TIMER) {\n                   InputMarshaller.readTimer( context ); \n               }             \n               \n               if( multithread ) {\n                   session.startPartitionManagers();\n               }\n\n               return session;        \n           }","id":35782,"modified_method":"public static ReteooStatefulSession readSession( ReteooStatefulSession session,\n            DefaultAgenda agenda,\n            long time,\n            boolean multithread,\n            MarshallerReaderContext context ) throws IOException, ClassNotFoundException {\n        if (session.getTimerService() instanceof PseudoClockScheduler) {\n            PseudoClockScheduler clock = (PseudoClockScheduler) session.getTimerService();\n            clock.advanceTime( time,\n                               TimeUnit.MILLISECONDS );\n        }\n\n        // RuleFlowGroups need to reference the session\n        for (RuleFlowGroup group : agenda.getRuleFlowGroupsMap().values()) {\n            ( (RuleFlowGroupImpl) group ).setWorkingMemory( session );\n        }\n\n        context.wm = session;\n\n        context.handles.put( context.wm.getInitialFactHandle().getId(),\n                             context.wm.getInitialFactHandle() );\n\n        if (context.stream.readBoolean()) {\n            InternalFactHandle initialFactHandle = context.wm.getInitialFactHandle();\n            int sinkId = context.stream.readInt();\n            ObjectTypeNode initialFactNode = (ObjectTypeNode) context.sinks.get( sinkId );\n            if (initialFactNode == null) {\n                // ------ START RANT ------\n                // The following code is as bad as it looks, but since I was so far \n                // unable to convince Mark that creating OTNs on demand is really bad,\n                // I have to continue doing it :)\n                EntryPointNode defaultEPNode = context.ruleBase.getRete().getEntryPointNode( EntryPoint.DEFAULT );\n                BuildContext buildContext = new BuildContext( context.ruleBase,\n                                                              context.ruleBase.getReteooBuilder().getIdGenerator() );\n                buildContext.setPartitionId(RuleBasePartitionId.MAIN_PARTITION);\n                buildContext.setObjectTypeNodeMemoryEnabled( true );\n                initialFactNode = new ObjectTypeNode( sinkId, \n                                                      defaultEPNode, \n                                                      ClassObjectType.InitialFact_ObjectType,\n                                                      buildContext );\n                // isn't contention something everybody loves?\n                context.ruleBase.lock();\n                try {\n                    // Yeah, I know, because one session is being deserialized, we go and lock all of them...\n                    InternalWorkingMemory[] wms = buildContext.getWorkingMemories();\n                    if ( wms.length > 0 ) {\n                        initialFactNode.attach( wms );\n                    } else {\n                        initialFactNode.attach();\n                    }\n                } finally {\n                    context.ruleBase.unlock();\n                }\n                // ------- END RANT -----\n            }\n            ObjectHashSet initialFactMemory = (ObjectHashSet) context.wm.getNodeMemory( initialFactNode );\n\n            initialFactMemory.add( initialFactHandle );\n            readRightTuples( initialFactHandle,\n                             context );\n        }\n        while ( context.readShort() == PersisterEnums.ENTRY_POINT) {\n            String entryPointId = context.stream.readUTF();\n            WorkingMemoryEntryPoint wmep = context.wm.getEntryPoints().get( entryPointId );\n            readFactHandles( context,\n                             ( (NamedEntryPoint) wmep ).getObjectStore() );\n        }\n        InternalFactHandle handle = context.wm.getInitialFactHandle();\n        while (context.stream.readShort() == PersisterEnums.LEFT_TUPLE) {\n            LeftTupleSink sink = (LeftTupleSink) context.sinks.get( context.stream.readInt() );\n            LeftTuple leftTuple = sink.createLeftTuple( handle,\n                                                        sink,\n                                                        true );\n            readLeftTuple( leftTuple,\n                           context );\n        }\n\n        readPropagationContexts( context );\n\n        readActivations( context );\n\n        readActionQueue( context );\n\n        readTruthMaintenanceSystem( context );\n\n        if (processMarshaller != null) {\n            processMarshaller.readProcessInstances( context );\n        }\n        else {\n            short type = context.stream.readShort();\n            if (PersisterEnums.END != type) {\n                throw new IllegalStateException( \"No process marshaller, unable to unmarshall type: \" + type );\n            }\n        }\n\n        if (processMarshaller != null) {\n            processMarshaller.readWorkItems( context );\n        }\n        else {\n            short type = context.stream.readShort();\n            if (PersisterEnums.END != type) {\n                throw new IllegalStateException( \"No process marshaller, unable to unmarshall type: \" + type );\n            }\n        }\n\n        if (processMarshaller != null) {\n            // This actually does ALL timers, due to backwards compatability issues\n            // It will read in old JBPM binaries, but always write to the new binary format.\n            processMarshaller.readProcessTimers( context );\n        } else {\n            short type = context.stream.readShort();\n            if (PersisterEnums.END != type) {\n                throw new IllegalStateException( \"No process marshaller, unable to unmarshall type: \" + type );\n            }\n        }\n\n        // no legacy jBPM timers, so handle locally\n        while ( context.readShort() == PersisterEnums.DEFAULT_TIMER) {\n            InputMarshaller.readTimer( context );\n        }\n\n        if (multithread) {\n            session.startPartitionManagers();\n        }\n\n        return session;\n    }","commit_id":"d4a3f0dad084e8a8e2257c90d4f9443ba5e1e837","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testDynamicEmptyRule() throws Exception {\n        String rule1 = \"package org.test;\\n\";\n        rule1 += \"global java.util.List list\\n\";\n        rule1 += \"rule \\\"Rule 1\\\"\\n\";\n        rule1 += \"when\\n\";\n        rule1 += \"then\\n\";\n        rule1 += \"    list.add( \\\"fired1\\\" );\\n\";\n        rule1 += \"end\";\n\n        String rule2 = \"package org.test;\\n\";\n        rule2 += \"global java.util.List list\\n\";\n        rule2 += \"rule \\\"Rule 2\\\"\\n\";\n        rule2 += \"when\\n\";\n        rule2 += \"then\\n\";\n        rule2 += \"    list.add( \\\"fired2\\\" );\\n\";\n        rule2 += \"end\";\n\n        PackageBuilder builder = new PackageBuilder();\n        builder.addPackageFromDrl( new StringReader( rule1 ) );\n        Package pkg = builder.getPackage();\n\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\n        ruleBase.addPackage( pkg );\n\n        // Make sure the rete node map is created correctly\n        Map<Integer, BaseNode> nodes = RuleBaseNodes.getNodeMap( (InternalRuleBase) ruleBase );\n        assertEquals( 2,\n                nodes.size() );\n        assertEquals( \"InitialFact\",\n                ((ClassObjectType) ((ObjectTypeNode) nodes.get( 2 )).getObjectType()).getClassType().getSimpleName() );\n        assertEquals( \"Rule 1\",\n                ((RuleTerminalNode) nodes.get( 4 )).getRule().getName() );\n\n        StatefulSession session = ruleBase.newStatefulSession();\n\n        List list = new ArrayList();\n        session.setGlobal( \"list\",\n                list );\n        StatefulSession session1 = getSerialisedStatefulSession( session );\n        session1.fireAllRules();\n\n        assertEquals( 1,\n                ((List) session1.getGlobal( \"list\" )).size() );\n\n        WorkingMemory session2 = getSerialisedStatefulSession( session1,\n                true );\n\n        session.dispose();\n        session1.dispose();\n\n        builder = new PackageBuilder();\n        builder.addPackageFromDrl( new StringReader( rule2 ) );\n        pkg = builder.getPackage();\n\n        ruleBase.addPackage( pkg );\n        session2.fireAllRules();\n\n        assertEquals( 2,\n                ((List) session2.getGlobal( \"list\" )).size() );\n        assertEquals( \"fired1\",\n                ((List) session2.getGlobal( \"list\" )).get( 0 ) );\n        assertEquals( \"fired2\",\n                ((List) session2.getGlobal( \"list\" )).get( 1 ) );\n    }","id":35783,"modified_method":"@Test\n    public void testDynamicEmptyRule() throws Exception {\n        String rule1 = \"package org.test;\\n\";\n        rule1 += \"global java.util.List list\\n\";\n        rule1 += \"rule \\\"Rule 1\\\"\\n\";\n        rule1 += \"when\\n\";\n        rule1 += \"then\\n\";\n        rule1 += \"    list.add( \\\"fired1\\\" );\\n\";\n        rule1 += \"end\";\n\n        String rule2 = \"package org.test;\\n\";\n        rule2 += \"global java.util.List list\\n\";\n        rule2 += \"rule \\\"Rule 2\\\"\\n\";\n        rule2 += \"when\\n\";\n        rule2 += \"then\\n\";\n        rule2 += \"    list.add( \\\"fired2\\\" );\\n\";\n        rule2 += \"end\";\n\n        PackageBuilder builder = new PackageBuilder();\n        builder.addPackageFromDrl( new StringReader( rule1 ) );\n        Package pkg = builder.getPackage();\n\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\n        ruleBase.addPackage( pkg );\n\n        // Make sure the rete node map is created correctly\n        Map<Integer, BaseNode> nodes = RuleBaseNodes.getNodeMap( (InternalRuleBase) ruleBase );\n        assertEquals( 2,\n                nodes.size() );\n        assertEquals( \"InitialFactImpl\",\n                ((ClassObjectType) ((ObjectTypeNode) nodes.get( 2 )).getObjectType()).getClassType().getSimpleName() );\n        assertEquals( \"Rule 1\",\n                ((RuleTerminalNode) nodes.get( 4 )).getRule().getName() );\n\n        StatefulSession session = ruleBase.newStatefulSession();\n\n        List list = new ArrayList();\n        session.setGlobal( \"list\",\n                list );\n        StatefulSession session1 = getSerialisedStatefulSession( session );\n        session1.fireAllRules();\n\n        assertEquals( 1,\n                ((List) session1.getGlobal( \"list\" )).size() );\n\n        WorkingMemory session2 = getSerialisedStatefulSession( session1,\n                true );\n\n        session.dispose();\n        session1.dispose();\n\n        builder = new PackageBuilder();\n        builder.addPackageFromDrl( new StringReader( rule2 ) );\n        pkg = builder.getPackage();\n\n        ruleBase.addPackage( pkg );\n        session2.fireAllRules();\n\n        assertEquals( 2,\n                ((List) session2.getGlobal( \"list\" )).size() );\n        assertEquals( \"fired1\",\n                ((List) session2.getGlobal( \"list\" )).get( 0 ) );\n        assertEquals( \"fired2\",\n                ((List) session2.getGlobal( \"list\" )).get( 1 ) );\n    }","commit_id":"d4a3f0dad084e8a8e2257c90d4f9443ba5e1e837","url":"https://github.com/droolsjbpm/drools"},{"original_method":"@Test\n    public void testEmptyRule() throws Exception {\n        String rule = \"package org.test;\\n\";\n        rule += \"global java.util.List list\\n\";\n        rule += \"rule \\\"Rule 1\\\"\\n\";\n        rule += \"when\\n\";\n        rule += \"then\\n\";\n        rule += \"    list.add( \\\"fired\\\" );\\n\";\n        rule += \"end\";\n\n        final PackageBuilder builder = new PackageBuilder();\n        builder.addPackageFromDrl( new StringReader( rule ) );\n        assertTrue( builder.getErrors().isEmpty() );\n        final Package pkg = builder.getPackage();\n\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\n        ruleBase.addPackage( pkg );\n\n        // Make sure the rete node map is created correctly\n        Map<Integer, BaseNode> nodes = RuleBaseNodes.getNodeMap( (InternalRuleBase) ruleBase );\n        assertEquals( 2,\n                nodes.size() );\n        assertEquals( \"InitialFact\",\n                ((ClassObjectType) ((ObjectTypeNode) nodes.get( 2 )).getObjectType()).getClassType().getSimpleName() );\n        assertEquals( \"Rule 1\",\n                ((RuleTerminalNode) nodes.get( 4 )).getRule().getName() );\n\n        StatefulSession session = ruleBase.newStatefulSession();\n\n        List list = new ArrayList();\n        session.setGlobal( \"list\",\n                list );\n\n        session = getSerialisedStatefulSession( session );\n\n        session.fireAllRules();\n\n        session = getSerialisedStatefulSession( session );\n\n        assertEquals( 1,\n                ((List) session.getGlobal( \"list\" )).size() );\n        assertEquals( \"fired\",\n                ((List) session.getGlobal( \"list\" )).get( 0 ) );\n    }","id":35784,"modified_method":"@Test\n    public void testEmptyRule() throws Exception {\n        String rule = \"package org.test;\\n\";\n        rule += \"global java.util.List list\\n\";\n        rule += \"rule \\\"Rule 1\\\"\\n\";\n        rule += \"when\\n\";\n        rule += \"then\\n\";\n        rule += \"    list.add( \\\"fired\\\" );\\n\";\n        rule += \"end\";\n\n        final PackageBuilder builder = new PackageBuilder();\n        builder.addPackageFromDrl( new StringReader( rule ) );\n        assertTrue( builder.getErrors().isEmpty() );\n        final Package pkg = builder.getPackage();\n\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\n        ruleBase.addPackage( pkg );\n\n        // Make sure the rete node map is created correctly\n        Map<Integer, BaseNode> nodes = RuleBaseNodes.getNodeMap( (InternalRuleBase) ruleBase );\n        assertEquals( 2,\n                nodes.size() );\n        assertEquals( \"InitialFactImpl\",\n                ((ClassObjectType) ((ObjectTypeNode) nodes.get( 2 )).getObjectType()).getClassType().getSimpleName() );\n        assertEquals( \"Rule 1\",\n                ((RuleTerminalNode) nodes.get( 4 )).getRule().getName() );\n\n        StatefulSession session = ruleBase.newStatefulSession();\n\n        List list = new ArrayList();\n        session.setGlobal( \"list\",\n                list );\n\n        session = getSerialisedStatefulSession( session );\n\n        session.fireAllRules();\n\n        session = getSerialisedStatefulSession( session );\n\n        assertEquals( 1,\n                ((List) session.getGlobal( \"list\" )).size() );\n        assertEquals( \"fired\",\n                ((List) session.getGlobal( \"list\" )).get( 0 ) );\n    }","commit_id":"d4a3f0dad084e8a8e2257c90d4f9443ba5e1e837","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void save (File outputBMFontFile) throws IOException {\r\n\t\tFile outputDir = outputBMFontFile.getParentFile();\r\n\t\tString outputName = outputBMFontFile.getName();\r\n\t\tif (outputName.endsWith(\".fnt\")) outputName = outputName.substring(0, outputName.length() - 4);\r\n\r\n\t\tunicodeFont.loadGlyphs();\r\n\r\n\t\tPrintStream out = new PrintStream(new FileOutputStream(new File(outputDir, outputName + \".fnt\")));\r\n\t\tFont font = unicodeFont.getFont();\r\n\t\tint pageWidth = unicodeFont.getGlyphPageWidth();\r\n\t\tint pageHeight = unicodeFont.getGlyphPageHeight();\r\n\t\tout.println(\"info face=\\\"\" + font.getFontName() + \"\\\" size=\" + font.getSize() + \" bold=\" + (font.isBold() ? 1 : 0)\r\n\t\t\t+ \" italic=\" + (font.isItalic() ? 1 : 0) + \" charset=\\\"\\\" unicode=0 stretchH=100 smooth=1 aa=1 padding=\"\r\n\t\t\t+ unicodeFont.getPaddingTop() + \",\" + unicodeFont.getPaddingLeft() + \",\" + unicodeFont.getPaddingBottom() + \",\"\r\n\t\t\t+ unicodeFont.getPaddingRight() + \" spacing=\" + unicodeFont.getPaddingAdvanceX() + \",\"\r\n\t\t\t+ unicodeFont.getPaddingAdvanceY());\r\n\t\tout.println(\"common lineHeight=\" + unicodeFont.getLineHeight() + \" base=\" + unicodeFont.getAscent() + \" scaleW=\"\r\n\t\t\t+ pageWidth + \" scaleH=\" + pageHeight + \" pages=\" + unicodeFont.getGlyphPages().size() + \" packed=0\");\r\n\r\n\t\tint pageIndex = 0, glyphCount = 0;\r\n\t\tfor (Iterator pageIter = unicodeFont.getGlyphPages().iterator(); pageIter.hasNext();) {\r\n\t\t\tGlyphPage page = (GlyphPage)pageIter.next();\r\n\t\t\tString fileName;\r\n\t\t\tif (pageIndex == 0 && !pageIter.hasNext())\r\n\t\t\t\tfileName = outputName + \".png\";\r\n\t\t\telse\r\n\t\t\t\tfileName = outputName + (pageIndex + 1) + \".png\";\r\n\t\t\tout.println(\"page id=\" + pageIndex + \" file=\\\"\" + fileName + \"\\\"\");\r\n\t\t\tglyphCount += page.getGlyphs().size();\r\n\t\t\tpageIndex++;\r\n\t\t}\r\n\r\n\t\tout.println(\"chars count=\" + glyphCount);\r\n\r\n\t\t// Always output space entry (codepoint 32).\r\n\t\tint[] glyphMetrics = getGlyphMetrics(font, 32);\r\n\t\tint xAdvance = glyphMetrics[1];\r\n\t\tout.println(\"char id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=\" + unicodeFont.getAscent()\r\n\t\t\t+ \"    xadvance=\" + xAdvance + \"     page=0  chnl=0 \");\r\n\r\n\t\tpageIndex = 0;\r\n\t\tList allGlyphs = new ArrayList(512);\r\n\t\tfor (Iterator pageIter = unicodeFont.getGlyphPages().iterator(); pageIter.hasNext();) {\r\n\t\t\tGlyphPage page = (GlyphPage)pageIter.next();\r\n\t\t\tfor (Iterator glyphIter = page.getGlyphs().iterator(); glyphIter.hasNext();) {\r\n\t\t\t\tGlyph glyph = (Glyph)glyphIter.next();\r\n\r\n\t\t\t\tglyphMetrics = getGlyphMetrics(font, glyph.getCodePoint());\r\n\t\t\t\tint xOffset = glyphMetrics[0];\r\n\t\t\t\txAdvance = glyphMetrics[1];\r\n\r\n\t\t\t\tout.println(\"char id=\" + glyph.getCodePoint() + \"   \" + \"x=\" + (int)(glyph.getU() * pageWidth) + \"     y=\"\r\n\t\t\t\t\t+ (int)(glyph.getV() * pageHeight) + \"     width=\" + glyph.getWidth() + \"     height=\" + glyph.getHeight()\r\n\t\t\t\t\t+ \"     xoffset=\" + xOffset + \"     yoffset=\" + glyph.getYOffset() + \"    xadvance=\" + xAdvance + \"     page=\"\r\n\t\t\t\t\t+ pageIndex + \"  chnl=0 \");\r\n\t\t\t}\r\n\t\t\tallGlyphs.addAll(page.getGlyphs());\r\n\t\t\tpageIndex++;\r\n\t\t}\r\n\r\n\t\tString ttfFileRef = unicodeFont.getFontFile();\r\n\t\tif (ttfFileRef == null)\r\n\t\t\tSystem.out.println(\"Kerning information could not be output because a TTF font file was not specified.\");\r\n\t\telse {\r\n\t\t\tKerning kerning = new Kerning();\r\n\t\t\ttry {\r\n\t\t\t\tkerning.load(Gdx.files.internal(ttfFileRef).read(), font.getSize());\r\n\t\t\t} catch (IOException ex) {\r\n\t\t\t\tSystem.out.println(\"Unable to read kerning information from font: \" + ttfFileRef);\r\n\t\t\t}\r\n\r\n\t\t\tMap glyphCodeToCodePoint = new HashMap();\r\n\t\t\tfor (Iterator iter = allGlyphs.iterator(); iter.hasNext();) {\r\n\t\t\t\tGlyph glyph = (Glyph)iter.next();\r\n\t\t\t\tglyphCodeToCodePoint.put(new Integer(getGlyphCode(font, glyph.getCodePoint())), new Integer(glyph.getCodePoint()));\r\n\t\t\t}\r\n\r\n\t\t\tList kernings = new ArrayList(256);\r\n\t\t\tclass KerningPair {\r\n\t\t\t\tpublic int firstCodePoint, secondCodePoint, offset;\r\n\t\t\t}\r\n\t\t\tfor (Iterator iter1 = allGlyphs.iterator(); iter1.hasNext();) {\r\n\t\t\t\tGlyph firstGlyph = (Glyph)iter1.next();\r\n\t\t\t\tint firstGlyphCode = getGlyphCode(font, firstGlyph.getCodePoint());\r\n\t\t\t\tint[] values = kerning.getValues(firstGlyphCode);\r\n\t\t\t\tif (values == null) continue;\r\n\t\t\t\tfor (int i = 0; i < values.length; i++) {\r\n\t\t\t\t\tInteger secondCodePoint = (Integer)glyphCodeToCodePoint.get(new Integer(values[i] & 0xffff));\r\n\t\t\t\t\tif (secondCodePoint == null) continue; // We may not be outputting the second character.\r\n\t\t\t\t\tint offset = values[i] >> 16;\r\n\t\t\t\t\tKerningPair pair = new KerningPair();\r\n\t\t\t\t\tpair.firstCodePoint = firstGlyph.getCodePoint();\r\n\t\t\t\t\tpair.secondCodePoint = secondCodePoint.intValue();\r\n\t\t\t\t\tpair.offset = offset;\r\n\t\t\t\t\tkernings.add(pair);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tout.println(\"kernings count=\" + kerning.getCount());\r\n\t\t\tfor (Iterator iter = kernings.iterator(); iter.hasNext();) {\r\n\t\t\t\tKerningPair pair = (KerningPair)iter.next();\r\n\t\t\t\tout.println(\"kerning first=\" + pair.firstCodePoint + \"  second=\" + pair.secondCodePoint + \"  amount=\" + pair.offset);\r\n\t\t\t}\r\n\t\t}\r\n\t\tout.close();\r\n\r\n\t\tint width = unicodeFont.getGlyphPageWidth();\r\n\t\tint height = unicodeFont.getGlyphPageHeight();\r\n\t\tIntBuffer buffer = BufferUtils.createIntBuffer(width * height);\r\n\t\tBufferedImage pageImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\r\n\t\tint[] row = new int[width];\r\n\r\n\t\tpageIndex = 0;\r\n\t\tfor (Iterator pageIter = unicodeFont.getGlyphPages().iterator(); pageIter.hasNext();) {\r\n\t\t\tGlyphPage page = (GlyphPage)pageIter.next();\r\n\t\t\tString fileName;\r\n\t\t\tif (pageIndex == 0 && !pageIter.hasNext())\r\n\t\t\t\tfileName = outputName + \".png\";\r\n\t\t\telse\r\n\t\t\t\tfileName = outputName + (pageIndex + 1) + \".png\";\r\n\r\n\t\t\tpage.getTexture().bind();\r\n\t\t\tbuffer.clear();\r\n\t\t\tGL11.glGetTexImage(GL11.GL_TEXTURE_2D, 0, GL12.GL_BGRA, GL11.GL_UNSIGNED_BYTE, buffer);\r\n\t\t\tWritableRaster raster = pageImage.getRaster();\r\n\t\t\tfor (int y = 0; y < height; y++) {\r\n\t\t\t\tbuffer.get(row);\r\n\t\t\t\traster.setDataElements(0, y, width, 1, row);\r\n\t\t\t}\r\n\t\t\tFile imageOutputFile = new File(outputDir, fileName);\r\n\t\t\tImageIO.write(pageImage, \"png\", imageOutputFile);\r\n\r\n\t\t\tpageIndex++;\r\n\t\t}\r\n\t}","id":35785,"modified_method":"public void save (File outputBMFontFile) throws IOException {\r\n\t\tFile outputDir = outputBMFontFile.getParentFile();\r\n\t\tString outputName = outputBMFontFile.getName();\r\n\t\tif (outputName.endsWith(\".fnt\")) outputName = outputName.substring(0, outputName.length() - 4);\r\n\r\n\t\tunicodeFont.loadGlyphs();\r\n\r\n\t\tPrintStream out = new PrintStream(new FileOutputStream(new File(outputDir, outputName + \".fnt\")));\r\n\t\tFont font = unicodeFont.getFont();\r\n\t\tint pageWidth = unicodeFont.getGlyphPageWidth();\r\n\t\tint pageHeight = unicodeFont.getGlyphPageHeight();\r\n\t\tout.println(\"info face=\\\"\" + font.getFontName() + \"\\\" size=\" + font.getSize() + \" bold=\" + (font.isBold() ? 1 : 0)\r\n\t\t\t+ \" italic=\" + (font.isItalic() ? 1 : 0) + \" charset=\\\"\\\" unicode=0 stretchH=100 smooth=1 aa=1 padding=\"\r\n\t\t\t+ unicodeFont.getPaddingTop() + \",\" + unicodeFont.getPaddingLeft() + \",\" + unicodeFont.getPaddingBottom() + \",\"\r\n\t\t\t+ unicodeFont.getPaddingRight() + \" spacing=\" + unicodeFont.getPaddingAdvanceX() + \",\"\r\n\t\t\t+ unicodeFont.getPaddingAdvanceY());\r\n\t\tout.println(\"common lineHeight=\" + unicodeFont.getLineHeight() + \" base=\" + unicodeFont.getAscent() + \" scaleW=\"\r\n\t\t\t+ pageWidth + \" scaleH=\" + pageHeight + \" pages=\" + unicodeFont.getGlyphPages().size() + \" packed=0\");\r\n\r\n\t\tint pageIndex = 0, glyphCount = 0;\r\n\t\tfor (Iterator pageIter = unicodeFont.getGlyphPages().iterator(); pageIter.hasNext();) {\r\n\t\t\tGlyphPage page = (GlyphPage)pageIter.next();\r\n\t\t\tString fileName;\r\n\t\t\tif (pageIndex == 0 && !pageIter.hasNext())\r\n\t\t\t\tfileName = outputName + \".png\";\r\n\t\t\telse\r\n\t\t\t\tfileName = outputName + (pageIndex + 1) + \".png\";\r\n\t\t\tout.println(\"page id=\" + pageIndex + \" file=\\\"\" + fileName + \"\\\"\");\r\n\t\t\tglyphCount += page.getGlyphs().size();\r\n\t\t\tpageIndex++;\r\n\t\t}\r\n\r\n\t\tout.println(\"chars count=\" + glyphCount);\r\n\r\n\t\t// Always output space entry (codepoint 32).\r\n\t\tint[] glyphMetrics = getGlyphMetrics(font, 32);\r\n\t\tint xAdvance = glyphMetrics[1];\r\n\t\tout.println(\"char id=32   x=0     y=0     width=0     height=0     xoffset=0     yoffset=\" + unicodeFont.getAscent()\r\n\t\t\t+ \"    xadvance=\" + xAdvance + \"     page=0  chnl=0 \");\r\n\r\n\t\tpageIndex = 0;\r\n\t\tList allGlyphs = new ArrayList(512);\r\n\t\tfor (Iterator pageIter = unicodeFont.getGlyphPages().iterator(); pageIter.hasNext();) {\r\n\t\t\tGlyphPage page = (GlyphPage)pageIter.next();\r\n\t\t\tfor (Iterator glyphIter = page.getGlyphs().iterator(); glyphIter.hasNext();) {\r\n\t\t\t\tGlyph glyph = (Glyph)glyphIter.next();\r\n\r\n\t\t\t\tglyphMetrics = getGlyphMetrics(font, glyph.getCodePoint());\r\n\t\t\t\tint xOffset = glyphMetrics[0];\r\n\t\t\t\txAdvance = glyphMetrics[1];\r\n\r\n\t\t\t\tout.println(\"char id=\" + glyph.getCodePoint() + \"   \" + \"x=\" + (int)(glyph.getU() * pageWidth) + \"     y=\"\r\n\t\t\t\t\t+ (int)(glyph.getV() * pageHeight) + \"     width=\" + glyph.getWidth() + \"     height=\" + glyph.getHeight()\r\n\t\t\t\t\t+ \"     xoffset=\" + xOffset + \"     yoffset=\" + glyph.getYOffset() + \"    xadvance=\" + xAdvance + \"     page=\"\r\n\t\t\t\t\t+ pageIndex + \"  chnl=0 \");\r\n\t\t\t}\r\n\t\t\tallGlyphs.addAll(page.getGlyphs());\r\n\t\t\tpageIndex++;\r\n\t\t}\r\n\r\n\t\tString ttfFileRef = unicodeFont.getFontFile();\r\n\t\tif (ttfFileRef == null)\r\n\t\t\tSystem.out.println(\"Kerning information could not be output because a TTF font file was not specified.\");\r\n\t\telse {\r\n\t\t\tKerning kerning = new Kerning();\r\n\t\t\ttry {\r\n\t\t\t\tkerning.load(Gdx.files.internal(ttfFileRef).read(), font.getSize());\r\n\t\t\t} catch (IOException ex) {\r\n\t\t\t\tSystem.out.println(\"Unable to read kerning information from font: \" + ttfFileRef);\r\n\t\t\t\tex.printStackTrace();\r\n\t\t\t}\r\n\r\n\t\t\tIntIntMap glyphCodeToCodePoint = new IntIntMap();\r\n\t\t\tfor (Iterator iter = allGlyphs.iterator(); iter.hasNext();) {\r\n\t\t\t\tGlyph glyph = (Glyph)iter.next();\r\n\t\t\t\tglyphCodeToCodePoint.put(new Integer(getGlyphCode(font, glyph.getCodePoint())), new Integer(glyph.getCodePoint()));\r\n\t\t\t}\r\n\r\n\t\t\tList kernings = new ArrayList(256);\r\n\t\t\tclass KerningPair {\r\n\t\t\t\tpublic int firstCodePoint, secondCodePoint, offset;\r\n\t\t\t}\r\n\t\t\tfor (IntIntMap.Entry entry : kerning.getKernings()) {\r\n\t\t\t\tint firstGlyphCode = entry.key >> 16;\r\n\t\t\t\tint secondGlyphCode = entry.key & 0xffff;\r\n\t\t\t\tint offset = entry.value;\r\n\t\t\t\tint firstCodePoint = glyphCodeToCodePoint.get(firstGlyphCode, -1);\r\n\t\t\t\tint secondCodePoint = glyphCodeToCodePoint.get(secondGlyphCode, -1);\r\n\r\n\t\t\t\tif (firstCodePoint == -1 || secondCodePoint == -1 || offset == 0) {\r\n\t\t\t\t\t// We are not outputting one or both of these glyphs, or the offset is zero anyway.\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tKerningPair pair = new KerningPair();\r\n\t\t\t\tpair.firstCodePoint = firstCodePoint;\r\n\t\t\t\tpair.secondCodePoint = secondCodePoint;\r\n\t\t\t\tpair.offset = offset;\r\n\t\t\t\tkernings.add(pair);\r\n\t\t\t}\r\n\t\t\tout.println(\"kernings count=\" + kernings.size());\r\n\t\t\tfor (Iterator iter = kernings.iterator(); iter.hasNext();) {\r\n\t\t\t\tKerningPair pair = (KerningPair)iter.next();\r\n\t\t\t\tout.println(\"kerning first=\" + pair.firstCodePoint + \"  second=\" + pair.secondCodePoint + \"  amount=\" + pair.offset);\r\n\t\t\t}\r\n\t\t}\r\n\t\tout.close();\r\n\r\n\t\tint width = unicodeFont.getGlyphPageWidth();\r\n\t\tint height = unicodeFont.getGlyphPageHeight();\r\n\t\tIntBuffer buffer = BufferUtils.createIntBuffer(width * height);\r\n\t\tBufferedImage pageImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\r\n\t\tint[] row = new int[width];\r\n\r\n\t\tpageIndex = 0;\r\n\t\tfor (Iterator pageIter = unicodeFont.getGlyphPages().iterator(); pageIter.hasNext();) {\r\n\t\t\tGlyphPage page = (GlyphPage)pageIter.next();\r\n\t\t\tString fileName;\r\n\t\t\tif (pageIndex == 0 && !pageIter.hasNext())\r\n\t\t\t\tfileName = outputName + \".png\";\r\n\t\t\telse\r\n\t\t\t\tfileName = outputName + (pageIndex + 1) + \".png\";\r\n\r\n\t\t\tpage.getTexture().bind();\r\n\t\t\tbuffer.clear();\r\n\t\t\tGL11.glGetTexImage(GL11.GL_TEXTURE_2D, 0, GL12.GL_BGRA, GL11.GL_UNSIGNED_BYTE, buffer);\r\n\t\t\tWritableRaster raster = pageImage.getRaster();\r\n\t\t\tfor (int y = 0; y < height; y++) {\r\n\t\t\t\tbuffer.get(row);\r\n\t\t\t\traster.setDataElements(0, y, width, 1, row);\r\n\t\t\t}\r\n\t\t\tFile imageOutputFile = new File(outputDir, fileName);\r\n\t\t\tImageIO.write(pageImage, \"png\", imageOutputFile);\r\n\r\n\t\t\tpageIndex++;\r\n\t\t}\r\n\t}","commit_id":"5f9c06f880e5bb0cb8f296dd67805d9e2e1ca8db","url":"https://github.com/libgdx/libgdx"},{"original_method":"private void readTableDirectory (InputStream input) throws IOException {\r\n\t\tskip(input, 4);\r\n\t\tint tableCount = readUnsignedShort(input);\r\n\t\tskip(input, 6);\r\n\r\n\t\tbyte[] tagBytes = new byte[4];\r\n\t\tfor (int i = 0; i < tableCount; i++) {\r\n\t\t\ttagBytes[0] = readByte(input);\r\n\t\t\ttagBytes[1] = readByte(input);\r\n\t\t\ttagBytes[2] = readByte(input);\r\n\t\t\ttagBytes[3] = readByte(input);\r\n\t\t\tskip(input, 4);\r\n\t\t\tlong offset = readUnsignedLong(input);\r\n\t\t\tskip(input, 4);\r\n\r\n\t\t\tString tag = new String(tagBytes, \"ISO-8859-1\");\r\n\t\t\tif (tag.equals(\"head\")) {\r\n\t\t\t\theadOffset = offset;\r\n\t\t\t\tif (kernOffset != -1) break;\r\n\t\t\t} else if (tag.equals(\"kern\")) {\r\n\t\t\t\tkernOffset = offset;\r\n\t\t\t\tif (headOffset != -1) break;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":35786,"modified_method":"private void readTableDirectory () throws IOException {\r\n\t\tinput.skip(4);\r\n\t\tint tableCount = input.readUnsignedShort();\r\n\t\tinput.skip(6);\r\n\r\n\t\tbyte[] tagBytes = new byte[4];\r\n\t\tfor (int i = 0; i < tableCount; i++) {\r\n\t\t\ttagBytes[0] = input.readByte();\r\n\t\t\ttagBytes[1] = input.readByte();\r\n\t\t\ttagBytes[2] = input.readByte();\r\n\t\t\ttagBytes[3] = input.readByte();\r\n\t\t\tinput.skip(4);\r\n\t\t\tint offset = (int) input.readUnsignedLong();\r\n\t\t\tinput.skip(4);\r\n\r\n\t\t\tString tag = new String(tagBytes, \"ISO-8859-1\");\r\n\t\t\tif (tag.equals(\"head\")) {\r\n\t\t\t\theadOffset = offset;\r\n\t\t\t} else if (tag.equals(\"kern\")) {\r\n\t\t\t\tkernOffset = offset;\r\n\t\t\t} else if (tag.equals(\"GPOS\")) {\r\n\t\t\t\tgposOffset = offset;\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"5f9c06f880e5bb0cb8f296dd67805d9e2e1ca8db","url":"https://github.com/libgdx/libgdx"},{"original_method":"public int getKerning (int[] values, int otherGlyphCode) {\r\n\t\tint low = 0;\r\n\t\tint high = values.length - 1;\r\n\t\twhile (low <= high) {\r\n\t\t\tint midIndex = (low + high) >>> 1;\r\n\t\t\tint value = values[midIndex];\r\n\t\t\tint foundGlyphCode = value & 0xffff;\r\n\t\t\tif (foundGlyphCode < otherGlyphCode)\r\n\t\t\t\tlow = midIndex + 1;\r\n\t\t\telse if (foundGlyphCode > otherGlyphCode)\r\n\t\t\t\thigh = midIndex - 1;\r\n\t\t\telse\r\n\t\t\t\treturn value >> 16;\r\n\t\t}\r\n\t\treturn 0;\r\n\t}","id":35787,"modified_method":"/** @return A map from pairs of glyph codes to their kerning in pixels. Each map key encodes two glyph codes:\r\n\t * the high 16 bits form the first glyph code, and the low 16 bits form the second. */\r\n\tpublic IntIntMap getKernings () {\r\n\t\treturn kernings;\r\n\t}","commit_id":"5f9c06f880e5bb0cb8f296dd67805d9e2e1ca8db","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** @param input The data for the TTF font.\r\n\t * @param size The font size to use to determine kerning pixel offsets.\r\n\t * @throws IOException If the font could not be read. */\r\n\tpublic void load (InputStream input, int size) throws IOException {\r\n\t\tthis.size = size;\r\n\t\tif (input == null) throw new IllegalArgumentException(\"input cannot be null.\");\r\n\t\treadTableDirectory(input);\r\n\t\tif (headOffset == -1) throw new IOException(\"HEAD table not found.\");\r\n\t\tif (kernOffset == -1) {\r\n\t\t\tvalues = Collections.EMPTY_MAP;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tvalues = new HashMap(256);\r\n\t\tif (headOffset < kernOffset) {\r\n\t\t\treadHEAD(input);\r\n\t\t\treadKERN(input);\r\n\t\t} else {\r\n\t\t\treadKERN(input);\r\n\t\t\treadHEAD(input);\r\n\t\t}\r\n\t\tinput.close();\r\n\r\n\t\tfor (Iterator entryIter = values.entrySet().iterator(); entryIter.hasNext();) {\r\n\t\t\tEntry entry = (Entry)entryIter.next();\r\n\t\t\t// Scale the offset values using the font size.\r\n\t\t\tList valueList = (List)entry.getValue();\r\n\t\t\tfor (ListIterator valueIter = valueList.listIterator(); valueIter.hasNext();) {\r\n\t\t\t\tint value = ((Integer)valueIter.next()).intValue();\r\n\t\t\t\tint glyphCode = value & 0xffff;\r\n\t\t\t\tint offset = value >> 16;\r\n\t\t\t\toffset = Math.round(offset * scale);\r\n\t\t\t\tif (offset == 0)\r\n\t\t\t\t\tvalueIter.remove();\r\n\t\t\t\telse\r\n\t\t\t\t\tvalueIter.set(new Integer((offset << 16) | glyphCode));\r\n\t\t\t}\r\n\t\t\tif (valueList.isEmpty()) {\r\n\t\t\t\tentryIter.remove();\r\n\t\t\t} else {\r\n\t\t\t\t// Replace ArrayList with int[].\r\n\t\t\t\tint[] valueArray = new int[valueList.size()];\r\n\t\t\t\tint i = 0;\r\n\t\t\t\tfor (Iterator valueIter = valueList.iterator(); valueIter.hasNext(); i++)\r\n\t\t\t\t\tvalueArray[i] = ((Integer)valueIter.next()).intValue();\r\n\t\t\t\tentry.setValue(valueArray);\r\n\t\t\t\tkerningPairCount += valueArray.length;\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":35788,"modified_method":"/** @param inputStream The data for the TTF font.\r\n\t * @param fontSize The font size to use to determine kerning pixel offsets.\r\n\t * @throws IOException If the font could not be read. */\r\n\tpublic void load (InputStream inputStream, int fontSize) throws IOException {\r\n\t\tif (inputStream == null) throw new IllegalArgumentException(\"inputStream cannot be null.\");\r\n\t\tinput = new TTFInputStream(inputStream);\r\n\t\tinputStream.close();\r\n\r\n\t\treadTableDirectory();\r\n\t\tif (headOffset == -1) throw new IOException(\"HEAD table not found.\");\r\n\t\treadHEAD(fontSize);\r\n\r\n\t\t// By reading the 'kern' table last, it takes precedence over the 'GPOS' table. We are more likely to interpret\r\n\t\t// the GPOS table incorrectly because we ignore most of it, since BMFont doesn't support its features.\r\n\t\tif (gposOffset != -1) {\r\n\t\t\tinput.seek(gposOffset);\r\n\t\t\treadGPOS();\r\n\t\t}\r\n\t\tif (kernOffset != -1) {\r\n\t\t\tinput.seek(kernOffset);\r\n\t\t\treadKERN();\r\n\t\t}\r\n\t\tinput.close();\r\n\t\tinput = null;\r\n\t}","commit_id":"5f9c06f880e5bb0cb8f296dd67805d9e2e1ca8db","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * @param classContext\n     * @param method\n     */\n    private void analyzeMethod(ClassContext classContext, Method method) throws MethodUnprofitableException, CFGBuilderException, DataflowAnalysisException {\n    \tif (method.isSynthetic()) return;\n    \tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tConstantPoolGen constantPoolGen = classContext.getConstantPoolGen();\n\t\t\n\t\tlocationLoop: for (Iterator<Location> iter = cfg.locationIterator(); iter.hasNext();) {\n\t\t\tLocation location = iter.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\t// Only consider invoke instructions\n\t\t\tif (!(ins instanceof InvokeInstruction))\n\t\t\t\tcontinue;\n\t\t\tif (ins instanceof INVOKEINTERFACE) \n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tInvokeInstruction inv = (InvokeInstruction) ins;\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\t\n\t\t\tString methodName = inv.getMethodName(constantPoolGen);\n\t\t\tif (methodName.toLowerCase().indexOf(\"unsupported\") >= 0) \n\t\t\t\tcontinue;\n\t\t\tString methodSig = inv.getSignature(constantPoolGen);\n\t\t\tif (methodSig.equals(\"()Ljava/lang/UnsupportedOperationException;\"))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tSet<XMethod> targets;\n            try {\n\t            \n\t\t\t\ttargets = Hierarchy2.resolveMethodCallTargets(inv, frame, constantPoolGen);\n            } catch (ClassNotFoundException e) {\n\t            AnalysisContext.reportMissingClass(e);\n\t            continue locationLoop;\n            }\n\t\t\tif (targets.isEmpty()) \n\t\t\t\tcontinue locationLoop;\n\t\t\tint priority = targets.size() == 1 ? Priorities.HIGH_PRIORITY : Priorities.NORMAL_PRIORITY;\n\t\t\tfor(XMethod m : targets) {\n\t\t\t\tif (!m.isUnsupported()) \n\t\t\t\t\tcontinue locationLoop;\n\t\t\t\tXClass xc = AnalysisContext.currentXFactory().getXClass(m.getClassDescriptor());\n\t\t\t\tif (!(inv instanceof INVOKESTATIC) && !(m.isFinal() || xc.isFinal()))\n\t\t\t\t\tpriority = Priorities.NORMAL_PRIORITY;\n\t\t\t\tif (xc == null || xc.isAbstract()) {\n\t\t\t\t\ttry {\n\t                    if (!AnalysisContext.currentAnalysisContext().getSubtypes2().hasSubtypes(m.getClassDescriptor()))\n\t                    \tcontinue locationLoop;\n                    } catch (ClassNotFoundException e) {\n\t                    AnalysisContext.reportMissingClass(e);\n\t                    continue locationLoop;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\tBugInstance bug = new BugInstance(this, \"DMI_UNSUPPORTED_METHOD\", priority)\n\t\t\t\t.addClassAndMethod(classContext.getJavaClass(), method)\n\t\t\t\t.addCalledMethod(constantPoolGen, inv)\n\t\t\t\t.addSourceLine(classContext, method, location);\n\t\t\tbugReporter.reportBug(bug);\n\t\t\t\n\t\t}\n\t    \n    }","id":35789,"modified_method":"/**\n     * @param classContext\n     * @param method\n     */\n    private void analyzeMethod(ClassContext classContext, Method method) throws MethodUnprofitableException, CFGBuilderException, DataflowAnalysisException {\n    \tif (method.isSynthetic() || (method.getAccessFlags() & Constants.ACC_BRIDGE) == Constants.ACC_BRIDGE) return;\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\t\tConstantPoolGen constantPoolGen = classContext.getConstantPoolGen();\n\t\t\n\t\tlocationLoop: for (Iterator<Location> iter = cfg.locationIterator(); iter.hasNext();) {\n\t\t\tLocation location = iter.next();\n\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\tInstruction ins = handle.getInstruction();\n\n\t\t\t// Only consider invoke instructions\n\t\t\tif (!(ins instanceof InvokeInstruction))\n\t\t\t\tcontinue;\n\t\t\tif (ins instanceof INVOKEINTERFACE) \n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tInvokeInstruction inv = (InvokeInstruction) ins;\n\t\t\tTypeFrame frame = typeDataflow.getFactAtLocation(location);\n\t\t\t\n\t\t\tString methodName = inv.getMethodName(constantPoolGen);\n\t\t\tif (methodName.toLowerCase().indexOf(\"unsupported\") >= 0) \n\t\t\t\tcontinue;\n\t\t\tString methodSig = inv.getSignature(constantPoolGen);\n\t\t\tif (methodSig.equals(\"()Ljava/lang/UnsupportedOperationException;\"))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tSet<XMethod> targets;\n            try {\n\t            \n\t\t\t\ttargets = Hierarchy2.resolveMethodCallTargets(inv, frame, constantPoolGen);\n            } catch (ClassNotFoundException e) {\n\t            AnalysisContext.reportMissingClass(e);\n\t            continue locationLoop;\n            }\n\t\t\tif (targets.isEmpty()) \n\t\t\t\tcontinue locationLoop;\n\t\t\tint priority = targets.size() == 1 ? Priorities.HIGH_PRIORITY : Priorities.NORMAL_PRIORITY;\n\t\t\tfor(XMethod m : targets) {\n\t\t\t\tif (!m.isUnsupported()) \n\t\t\t\t\tcontinue locationLoop;\n\t\t\t\tXClass xc = AnalysisContext.currentXFactory().getXClass(m.getClassDescriptor());\n\t\t\t\tif (!(inv instanceof INVOKESTATIC) && !(m.isFinal() || xc.isFinal()))\n\t\t\t\t\tpriority = Priorities.NORMAL_PRIORITY;\n\t\t\t\tif (xc == null || xc.isAbstract()) {\n\t\t\t\t\ttry {\n\t                    if (!AnalysisContext.currentAnalysisContext().getSubtypes2().hasSubtypes(m.getClassDescriptor()))\n\t                    \tcontinue locationLoop;\n                    } catch (ClassNotFoundException e) {\n\t                    AnalysisContext.reportMissingClass(e);\n\t                    continue locationLoop;\n                    }\n\t\t\t\t}\n\t\t\t}\n\t\t\tBugInstance bug = new BugInstance(this, \"DMI_UNSUPPORTED_METHOD\", priority)\n\t\t\t\t.addClassAndMethod(classContext.getJavaClass(), method)\n\t\t\t\t.addCalledMethod(constantPoolGen, inv)\n\t\t\t\t.addSourceLine(classContext, method, location);\n\t\t\tbugReporter.reportBug(bug);\n\t\t\t\n\t\t}\n\t    \n    }","commit_id":"98f7ab2b46e0070d49bbd077c2db4a4ad00362db","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void analyzeMethod(ClassContext classContext, Method method) throws DataflowAnalysisException, CFGBuilderException {\n\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"    Analyzing method \" + classContext.getJavaClass().getClassName() + \".\" + method.getName());\n\t\t}\n\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tBitSet linesMentionedMultipleTimes = ClassContext.linesMentionedMultipleTimes(method);\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\tDataflow<BitSet, LiveLocalStoreAnalysis> llsaDataflow = classContext.getLiveLocalStoreDataflow(method);\n\n\t\tint numLocals = method.getCode().getMaxLocals();\n\t\tint[] localStoreCount = new int[numLocals];\n\t\tint[] localLoadCount = new int[numLocals];\n\t\tint[] localIncrementCount = new int[numLocals];\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tBitSet liveStoreSetAtEntry = llsaDataflow.getAnalysis().getResultFact(cfg.getEntry());\n\t\tBitSet complainedAbout = new BitSet();\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\n\t\t// Get number of locals that are parameters.\n\t\tint localsThatAreParameters = PreorderVisitor.getNumberArguments(method.getSignature());\n\t\tif (!method.isStatic())\n\t\t\tlocalsThatAreParameters++;\n\n\t\t// Scan method to determine number of loads, stores, and increments\n\t\t// of local variables.\n\t\tcountLocalStoresLoadsAndIncrements(localStoreCount, localLoadCount, localIncrementCount, cfg);\n\t\tfor (int i = 0; i < localsThatAreParameters; i++)\n\t\t\tlocalStoreCount[i]++;\n\n\t\t// For each source line, keep track of # times\n\t\t// the line was a live store.  This can eliminate false positives\n\t\t// due to inlining of finally blocks.\n\t\tBitSet liveStoreSourceLineSet = new BitSet();\n\n\t\t// Scan method for\n\t\t// - dead stores\n\t\t// - stores to parameters that are dead upon entry to the method\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\n\t\t\tBugInstance pendingBugReportAboutOverwrittenParameter = null;\n\t\t\ttry {\n\t\t\t\tWarningPropertySet<WarningProperty> propertySet = new WarningPropertySet<WarningProperty>();\n\t\t\t\t// Skip any instruction which is not a store\n\t\t\t\tif (!isStore(location))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Heuristic: exception handler blocks often contain\n\t\t\t\t// dead stores generated by the compiler.\n\t\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.EXCEPTION_HANDLER);\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tint pc = handle.getPosition();\n\t\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\n\t\t\t\tint local = ins.getIndex();\n\n\t\t\t\t// Get live stores at this instruction.\n\t\t\t\t// Note that the analysis also computes which stores were\n\t\t\t\t// killed by a subsequent unconditional store.\n\t\t\t\tBitSet liveStoreSet = llsaDataflow.getAnalysis().getFactAtLocation(location);\n\n\t\t\t\t// Is store alive?\n\t\t\t\tboolean storeLive = llsaDataflow.getAnalysis().isStoreAlive(liveStoreSet, local);\n\n\t\t\t\tLocalVariableAnnotation lvAnnotation = LocalVariableAnnotation.getLocalVariableAnnotation(method, location, ins);\n\n\t\t\t\t\n\t\t\t\tString sourceFileName = javaClass.getSourceFileName();\n\t\t\t\tif (lvAnnotation.getName().equals(\"?\")) {\n\t\t\t\t\tif (sourceFileName.endsWith(\".groovy\")) continue;\n\t\t\t\t\tif (method.getCode().getLocalVariableTable() != null) continue;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstruction(classContext,\n\t\t\t\t\t\tmethodGen, sourceFileName, location.getHandle());\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"    Store at \" + sourceLineAnnotation.getStartLine() + \"@\" +\n\t\t\t\t\t\t\tlocation.getHandle().getPosition() + \" is \" +\n\t\t\t\t\t\t\t(storeLive ? \"live\" : \"dead\"));\n\t\t\t\t\tSystem.out.println(\"Previous is: \" + \tlocation.getHandle().getPrev());\n\t\t\t\t}\n\t\t\t\n\t\t\t\t// Note source lines of live stores.\n\t\t\t\tif (storeLive && sourceLineAnnotation.getStartLine() > 0) {\n\t\t\t\t\tliveStoreSourceLineSet.set(sourceLineAnnotation.getStartLine());\n\t\t\t\t}\n\n\t\t\t\tString name = lvAnnotation.getName();\n\t\t\t\tif (name.charAt(0) == '$' || name.charAt(0) == '_')\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SYNTHETIC_NAME);\n\t\t\t\tif (EXCLUDED_LOCALS.contains(name))\n\t\t\t\t\tcontinue;\n\t\t\t\tpropertySet.setProperty(DeadLocalStoreProperty.LOCAL_NAME, name);\n\n\t\t\t\t\t\t\tboolean isParameter = local < localsThatAreParameters;\n\t\t\t\tif (isParameter)\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.IS_PARAMETER);\n\n\t\t\t\tField shadowedField = null;\n\t\t\t\t\n\t\t\t\tfor (Field f : javaClass.getFields()) {\n\t\t\t\t\tif (f.getName().equals(name)) {\n\t\t\t\t\t\tshadowedField = f;\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SHADOWS_FIELD);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Is this a store to a parameter which was dead on entry to the\n\t\t\t\t// method?\n\t\t\t\tboolean parameterThatIsDeadAtEntry = isParameter\n\t\t\t\t&& !llsaDataflow.getAnalysis().isStoreAlive(liveStoreSetAtEntry, local);\n\t\t\t\tif (parameterThatIsDeadAtEntry && !complainedAbout.get(local)) {\n\n\t\t\t\t\tint priority = storeLive ? LOW_PRIORITY : NORMAL_PRIORITY;\n\t\t\t\t\tif (shadowedField != null) priority--;\n\t\t\t\t\tpendingBugReportAboutOverwrittenParameter = new BugInstance(this, \"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN\",\n\t\t\t\t\t\t\tpriority).addClassAndMethod(methodGen,\n\t\t\t\t\t\t\t\t\tsourceFileName).add(lvAnnotation);\n\t\t\t\t\t\n\t\t\t\t\tif (shadowedField != null)\n\t\t\t\t\t\tpendingBugReportAboutOverwrittenParameter\n\t\t\t\t\t\t\t.addField(FieldAnnotation.fromBCELField(classContext.getJavaClass(), shadowedField))\n\t\t\t\t\t\t\t.describe(FieldAnnotation.DID_YOU_MEAN_ROLE);\n\t\t\t\t\t\n\t\t\t\t\tpendingBugReportAboutOverwrittenParameter.addSourceLine(classContext, methodGen,\n\t\t\t\t\t\t\t\t\t\t\tsourceFileName, location.getHandle());\n\t\t\t\t\tcomplainedAbout.set(local);\n\t\t\t\t}\n\n\t\t\t\tif (storeLive)\n\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\tTypeFrame typeFrame = typeDataflow.getAnalysis().getFactAtLocation(location);\n\t\t\t\tType typeOfValue = null;\n\t\t\t\tif (typeFrame.isValid() && typeFrame.getStackDepth() > 0) {\n\t\t\t\t\ttypeOfValue = typeFrame.getTopValue();\n\t\t\t\t}\n\n\t\t\t\tboolean storeOfNull = false;\n\t\t\t\tInstructionHandle prevInsHandle = location.getHandle().getPrev();\n\t\t\t\tif (prevInsHandle != null) {\n\t\t\t\t\tInstruction prevIns = prevInsHandle.getInstruction();\n\t\t\t\t\tboolean foundDeadClassInitialization = false;\n\t\t\t\t\tString initializationOf = null;\n\t\t\t\t\tif (prevIns instanceof ConstantPushInstruction) \n\t\t\t\t\t\tcontinue; // not an interesting dead store\n\t\t\t\t\telse if (prevIns instanceof GETSTATIC) {\n\t\t\t\t\t\t\tGETSTATIC getStatic = (GETSTATIC)prevIns;\n\t\t\t\t\t\t\tConstantPoolGen cpg = methodGen.getConstantPool();\n\t\t\t\t\t\t\tfoundDeadClassInitialization =  getStatic.getFieldName(cpg).startsWith(\"class$\")\n\t\t\t\t\t\t\t\t\t&& getStatic.getSignature(cpg).equals(\"Ljava/lang/Class;\");\n\t\t\t\t\t\t\tfor (Iterator<Location> j = cfg.locationIterator(); j.hasNext();) {\n\t\t\t\t\t\t\t\tLocation location2 = j.next();\n\t\t\t\t\t\t\t\tif (location2.getHandle().getPosition() + 15 == location.getHandle().getPosition()) {\n\t\t\t\t\t\t\t\t\tInstruction  instruction2 = location2.getHandle().getInstruction();\n\t\t\t\t\t\t\t\t\tif (instruction2 instanceof LDC) {\n\t\t\t\t\t\t\t\t\t\tObject value = ((LDC)instruction2).getValue(methodGen.getConstantPool());\n\t\t\t\t\t\t\t\t\t\tif (value instanceof String) {String n = (String) value;\n\t\t\t\t\t\t\t\t\t\tif (n.length() > 0)\n\t\t\t\t\t\t\t\t\t\t\tinitializationOf = ClassName.toSignature(n);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}}\n\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (prevIns instanceof LDC) {\n\t\t\t\t\t\tLDC ldc = (LDC) prevIns;\n\t\t\t\t\t\tType t = ldc.getType(methodGen.getConstantPool());\n\t\t\t\t\t\tif (t.getSignature().equals(\"Ljava/lang/Class;\")) {\n\t\t\t\t\t\t\tConstantClass v = (ConstantClass) ldc.getValue(methodGen.getConstantPool());\n\t\t\t\t\t\t\tinitializationOf = ClassName.toSignature(v.getBytes(javaClass.getConstantPool()));\n\t\t\t\t\t\t\tfoundDeadClassInitialization = true;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tcontinue; // not an interesting DLS\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if (prevIns instanceof DUP2) {\n\t\t\t\t\t\t// Check for the case where, due to the bytecode\n\t\t\t\t\t\t// compiler, a long is needlessly stored just\n\t\t\t\t\t\t// after we've DUP2'ed the stack and just\n\t\t\t\t\t\t// before we return \n\t\t\t\t\t\tInstruction cur = location.getHandle().getInstruction();\n\t\t\t\t\t\tInstruction nxt = location.getHandle().getNext().getInstruction();\n\t\t\t\t\t\tif(cur instanceof LSTORE && nxt instanceof LRETURN) {\n\t\t\t\t\t\t\tcontinue; // not an interesting DLS\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (foundDeadClassInitialization) {\n\t\t\t\t\t\tif (classContext.getJavaClass().getSuperclassName().equals(\n\t\t\t\t\t\t\t\t\"org.apache.axis.client.Stub\")) continue;\n\t\t\t\t\t\tBugInstance bugInstance = new BugInstance(this,  \"DLS_DEAD_STORE_OF_CLASS_LITERAL\", \n\t\t\t\t\t\t\t\tPriorities.NORMAL_PRIORITY).addClassAndMethod(\n\t\t\t\t\t\t\t\t\t\tmethodGen,\n\t\t\t\t\t\t\t\t\t\tsourceFileName).add(lvAnnotation).addType(initializationOf);\n\t\t\t\t\t\taccumulator.accumulateBug(bugInstance, sourceLineAnnotation);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (prevIns instanceof LDC || prevIns instanceof ConstantPushInstruction)\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.STORE_OF_CONSTANT);\n\t\t\t\t\telse if (prevIns instanceof ACONST_NULL) {\n\t\t\t\t\t\tstoreOfNull = true;\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.STORE_OF_NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\n\n\t\t\t\tif (typeOfValue instanceof BasicType || Type.STRING.equals(typeOfValue))\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.BASE_VALUE);\n\n\t\t\t\t// Ignore assignments that were killed by a subsequent\n\t\t\t\t// assignment.\n\t\t\t\tboolean killedBySubsequentStore = llsaDataflow.getAnalysis().killedByStore(liveStoreSet, local);\n\t\t\t\tif (killedBySubsequentStore) {\n\t\t\t\t\tif (propertySet.containsProperty(DeadLocalStoreProperty.STORE_OF_NULL) \n\t\t\t\t\t\t\t|| propertySet.containsProperty(DeadLocalStoreProperty.STORE_OF_CONSTANT) ) continue;\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.KILLED_BY_SUBSEQUENT_STORE);\n\t\t\t\t}\n\n\t\t\t\t// Ignore dead assignments of null and 0.\n\t\t\t\t// These often indicate defensive programming.\n\t\t\t\tInstructionHandle prev = location.getBasicBlock().getPredecessorOf(location.getHandle());\n\t\t\t\tint prevOpCode = -1;\n\n\t\t\t\tif (prev != null) {\n\t\t\t\t\tif (defensiveConstantValueOpcodes.get(prev.getInstruction().getOpcode())) {\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEFENSIVE_CONSTANT_OPCODE);\n\t\t\t\t\t\tprevOpCode = prev.getInstruction().getOpcode();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (prev.getInstruction() instanceof GETFIELD) {\n\t\t\t\t\t\tInstructionHandle prev2 = prev.getPrev();\n\n\t\t\t\t\t\tif (prev2 != null && prev2.getInstruction() instanceof ALOAD)\n\t\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.CACHING_VALUE);\n\t\t\t\t\t}\n\t\t\t\t\tif (prev.getInstruction() instanceof LoadInstruction)\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.COPY_VALUE);\n\t\t\t\t\tif (prev.getInstruction() instanceof InvokeInstruction)\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.METHOD_RESULT);\n\t\t\t\t}\n\t\t\t\tboolean deadObjectStore = false;\n\t\t\t\tif (ins instanceof IINC) {\n\t\t\t\t\t// special handling of IINC\n\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_INCREMENT);\n\t\t\t\t\tif (localIncrementCount[local] == 1) {\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_DEAD_INCREMENT);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpropertySet.removeProperty(DeadLocalStoreProperty.IS_PARAMETER);\n\n\t\t\t\t} else if (ins instanceof ASTORE && prev != null) {\n\t\t\t\t\t// Look for objects created but never used\n\n\t\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\t\tif ((prevIns instanceof INVOKESPECIAL && ((INVOKESPECIAL) prevIns).getMethodName(methodGen.getConstantPool())\n\t\t\t\t\t\t\t.equals(\"<init>\"))\n\t\t\t\t\t\t\t|| prevIns instanceof ANEWARRAY || prevIns instanceof NEWARRAY || prevIns instanceof MULTIANEWARRAY) {\n\t\t\t\t\t\tdeadObjectStore = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (deadObjectStore)\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_OBJECT_STORE);\n\t\t\t\telse if (!killedBySubsequentStore && localStoreCount[local] == 2 && localLoadCount[local] > 0) {\n\t\t\t\t\t// TODO: why is this significant?\n\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.TWO_STORES_MULTIPLE_LOADS);\n\n\t\t\t\t} else if (!parameterThatIsDeadAtEntry && localStoreCount[local] == 1 && localLoadCount[local] == 0\n\t\t\t\t\t\t&& propertySet.containsProperty(DeadLocalStoreProperty.DEFENSIVE_CONSTANT_OPCODE)) {\n\t\t\t\t\t// might be final local constant\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_STORE);\n\n\t\t\t\t} else if (!parameterThatIsDeadAtEntry \n\t\t\t\t\t\t&& !propertySet.containsProperty(DeadLocalStoreProperty.SHADOWS_FIELD) \n\t\t\t\t\t\t&& localLoadCount[local] == 0) {\n\t\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.NO_LOADS);\n\t\t\t\t}\n\t\t\t\tif (!storeOfNull && typeOfValue != null && !propertySet.containsProperty(DeadLocalStoreProperty.EXCEPTION_HANDLER)) {\n\t\t\t\t\tString signatureOfValue = typeOfValue.getSignature();\n\t\t\t\t\tif ((signatureOfValue.startsWith(\"Ljava/sql/\") || signatureOfValue.startsWith(\"Ljavax/sql/\")) \n\t\t\t\t\t\t\t&& !signatureOfValue.endsWith(\"Exception\"))\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.STORE_OF_DATABASE_VALUE);\n\t\t\t\t}\n\n\t\t\t\tif (parameterThatIsDeadAtEntry) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.PARAM_DEAD_ON_ENTRY);\n\t\t\t\t\tif (pendingBugReportAboutOverwrittenParameter != null)\n\t\t\t\t\t\tpendingBugReportAboutOverwrittenParameter.setPriority(Detector.HIGH_PRIORITY);\n\t\t\t\t}\n\n\t\t\t\tif (localStoreCount[local] > 3)\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.MANY_STORES);\n\t\t\t\tint occurrences = cfg.getLocationsContainingInstructionWithOffset(\n\t\t\t\t\t\tpc).size();\n\t\t\t\tif (occurrences > 2 || sourceLineAnnotation.getStartLine() > 0 && linesMentionedMultipleTimes.get(sourceLineAnnotation.getStartLine()))\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.CLONED_STORE);\n\t\t\t\tString sourceFile = javaClass.getSourceFileName();\n\t\t\t\tif (javaClass.getClassName().endsWith(\"_jsp\"))\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.IN_JSP_PAGE);\n\t\t\t\telse if (javaClass.isSynthetic() || sourceFile != null && !sourceFile.endsWith(\".java\")) {\n\t\t\t\t\tString lvName = lvAnnotation.getName();\n\t\t\t\t\tif (sourceFile.endsWith(\".gxp\") && (lvName.startsWith(\"gxp$\" ) || lvName.startsWith(\"gxp_\"))) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.NOT_JAVA);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\t\tif (priority <= Detector.EXP_PRIORITY) {\n\n\t\t\t\t\t// Report the warning\n\t\t\t\t\tBugInstance bugInstance = new BugInstance(this, storeOfNull ? \"DLS_DEAD_LOCAL_STORE_OF_NULL\"\n\t\t\t\t\t\t\t: \"DLS_DEAD_LOCAL_STORE\", priority).addClassAndMethod(\n\t\t\t\t\t\t\t\t\tmethodGen,\n\t\t\t\t\t\t\t\t\tsourceFileName).add(lvAnnotation);\n\n\t\t\t\t\tif (shadowedField != null)\n\t\t\t\t\t\tbugInstance.addField(FieldAnnotation.fromBCELField(classContext.getJavaClass(), shadowedField))\n\t\t\t\t\t\t.describe(FieldAnnotation.DID_YOU_MEAN_ROLE);\n\t\t\t\t\t\n\t\t\t\t\t// If in relaxed reporting mode, encode heuristic\n\t\t\t\t\t// information.\n\t\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\t\t// Add general-purpose warning properties\n\t\t\t\t\t\tWarningPropertyUtil.addPropertiesForLocation(propertySet, classContext, method, location);\n\n\t\t\t\t\t\t// Turn all warning properties into BugProperties\n\t\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(sourceFileName + \" : \" + methodGen.getName());\n\t\t\t\t\t\tSystem.out.println(\"priority: \" + priority);\n\t\t\t\t\t\tSystem.out.println(\"Reporting \" + bugInstance);\n\t\t\t\t\t\tSystem.out.println(propertySet);\n\t\t\t\t\t}\n\t\t\t\t\taccumulator.accumulateBug(bugInstance, sourceLineAnnotation);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (pendingBugReportAboutOverwrittenParameter != null)\n\t\t\t\t\tbugReporter.reportBug(pendingBugReportAboutOverwrittenParameter);\n\t\t\t}\n\t\t}\n\n\t\tsuppressWarningsIfOneLiveStoreOnLine(accumulator, liveStoreSourceLineSet);\n\n\t\taccumulator.reportAccumulatedBugs();\n\t}","id":35790,"modified_method":"private void analyzeMethod(ClassContext classContext, Method method) throws DataflowAnalysisException, CFGBuilderException {\n\t\tif (method.isSynthetic() || (method.getAccessFlags() & Constants.ACC_BRIDGE) == Constants.ACC_BRIDGE) return;\n\t\t\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"    Analyzing method \" + classContext.getJavaClass().getClassName() + \".\" + method.getName());\n\t\t}\n\n\t\tJavaClass javaClass = classContext.getJavaClass();\n\t\tBitSet linesMentionedMultipleTimes = ClassContext.linesMentionedMultipleTimes(method);\n\t\tBugAccumulator accumulator = new BugAccumulator(bugReporter);\n\t\tDataflow<BitSet, LiveLocalStoreAnalysis> llsaDataflow = classContext.getLiveLocalStoreDataflow(method);\n\n\t\tint numLocals = method.getCode().getMaxLocals();\n\t\tint[] localStoreCount = new int[numLocals];\n\t\tint[] localLoadCount = new int[numLocals];\n\t\tint[] localIncrementCount = new int[numLocals];\n\t\tMethodGen methodGen = classContext.getMethodGen(method);\n\t\tCFG cfg = classContext.getCFG(method);\n\t\tif ((cfg.getFlags() & CFG.FOUND_UNCONDITIONAL_THROWERS) == CFG.FOUND_UNCONDITIONAL_THROWERS)\n\t\t\treturn;\n\t\tBitSet liveStoreSetAtEntry = llsaDataflow.getAnalysis().getResultFact(cfg.getEntry());\n\t\tBitSet complainedAbout = new BitSet();\n\t\tTypeDataflow typeDataflow = classContext.getTypeDataflow(method);\n\n\t\t// Get number of locals that are parameters.\n\t\tint localsThatAreParameters = PreorderVisitor.getNumberArguments(method.getSignature());\n\t\tif (!method.isStatic())\n\t\t\tlocalsThatAreParameters++;\n\n\t\t// Scan method to determine number of loads, stores, and increments\n\t\t// of local variables.\n\t\tcountLocalStoresLoadsAndIncrements(localStoreCount, localLoadCount, localIncrementCount, cfg);\n\t\tfor (int i = 0; i < localsThatAreParameters; i++)\n\t\t\tlocalStoreCount[i]++;\n\n\t\t// For each source line, keep track of # times\n\t\t// the line was a live store.  This can eliminate false positives\n\t\t// due to inlining of finally blocks.\n\t\tBitSet liveStoreSourceLineSet = new BitSet();\n\n\t\t// Scan method for\n\t\t// - dead stores\n\t\t// - stores to parameters that are dead upon entry to the method\n\t\tfor (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {\n\t\t\tLocation location = i.next();\n\n\t\t\tBugInstance pendingBugReportAboutOverwrittenParameter = null;\n\t\t\ttry {\n\t\t\t\tWarningPropertySet<WarningProperty> propertySet = new WarningPropertySet<WarningProperty>();\n\t\t\t\t// Skip any instruction which is not a store\n\t\t\t\tif (!isStore(location))\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// Heuristic: exception handler blocks often contain\n\t\t\t\t// dead stores generated by the compiler.\n\t\t\t\tif (location.getBasicBlock().isExceptionHandler())\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.EXCEPTION_HANDLER);\n\t\t\t\tInstructionHandle handle = location.getHandle();\n\t\t\t\tint pc = handle.getPosition();\n\t\t\t\tIndexedInstruction ins = (IndexedInstruction) location.getHandle().getInstruction();\n\n\t\t\t\tint local = ins.getIndex();\n\n\t\t\t\t// Get live stores at this instruction.\n\t\t\t\t// Note that the analysis also computes which stores were\n\t\t\t\t// killed by a subsequent unconditional store.\n\t\t\t\tBitSet liveStoreSet = llsaDataflow.getAnalysis().getFactAtLocation(location);\n\n\t\t\t\t// Is store alive?\n\t\t\t\tboolean storeLive = llsaDataflow.getAnalysis().isStoreAlive(liveStoreSet, local);\n\n\t\t\t\tLocalVariableAnnotation lvAnnotation = LocalVariableAnnotation.getLocalVariableAnnotation(method, location, ins);\n\n\t\t\t\t\n\t\t\t\tString sourceFileName = javaClass.getSourceFileName();\n\t\t\t\tif (lvAnnotation.getName().equals(\"?\")) {\n\t\t\t\t\tif (sourceFileName.endsWith(\".groovy\")) continue;\n\t\t\t\t\tif (method.getCode().getLocalVariableTable() != null) continue;\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tSourceLineAnnotation sourceLineAnnotation = SourceLineAnnotation.fromVisitedInstruction(classContext,\n\t\t\t\t\t\tmethodGen, sourceFileName, location.getHandle());\n\n\t\t\t\tif (DEBUG) {\n\t\t\t\t\tSystem.out.println(\"    Store at \" + sourceLineAnnotation.getStartLine() + \"@\" +\n\t\t\t\t\t\t\tlocation.getHandle().getPosition() + \" is \" +\n\t\t\t\t\t\t\t(storeLive ? \"live\" : \"dead\"));\n\t\t\t\t\tSystem.out.println(\"Previous is: \" + \tlocation.getHandle().getPrev());\n\t\t\t\t}\n\t\t\t\n\t\t\t\t// Note source lines of live stores.\n\t\t\t\tif (storeLive && sourceLineAnnotation.getStartLine() > 0) {\n\t\t\t\t\tliveStoreSourceLineSet.set(sourceLineAnnotation.getStartLine());\n\t\t\t\t}\n\n\t\t\t\tString name = lvAnnotation.getName();\n\t\t\t\tif (name.charAt(0) == '$' || name.charAt(0) == '_')\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SYNTHETIC_NAME);\n\t\t\t\tif (EXCLUDED_LOCALS.contains(name))\n\t\t\t\t\tcontinue;\n\t\t\t\tpropertySet.setProperty(DeadLocalStoreProperty.LOCAL_NAME, name);\n\n\t\t\t\t\t\t\tboolean isParameter = local < localsThatAreParameters;\n\t\t\t\tif (isParameter)\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.IS_PARAMETER);\n\n\t\t\t\tField shadowedField = null;\n\t\t\t\t\n\t\t\t\tfor (Field f : javaClass.getFields()) {\n\t\t\t\t\tif (f.getName().equals(name)) {\n\t\t\t\t\t\tshadowedField = f;\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SHADOWS_FIELD);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Is this a store to a parameter which was dead on entry to the\n\t\t\t\t// method?\n\t\t\t\tboolean parameterThatIsDeadAtEntry = isParameter\n\t\t\t\t&& !llsaDataflow.getAnalysis().isStoreAlive(liveStoreSetAtEntry, local);\n\t\t\t\tif (parameterThatIsDeadAtEntry && !complainedAbout.get(local)) {\n\n\t\t\t\t\tint priority = storeLive ? LOW_PRIORITY : NORMAL_PRIORITY;\n\t\t\t\t\tif (shadowedField != null) priority--;\n\t\t\t\t\tpendingBugReportAboutOverwrittenParameter = new BugInstance(this, \"IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN\",\n\t\t\t\t\t\t\tpriority).addClassAndMethod(methodGen,\n\t\t\t\t\t\t\t\t\tsourceFileName).add(lvAnnotation);\n\t\t\t\t\t\n\t\t\t\t\tif (shadowedField != null)\n\t\t\t\t\t\tpendingBugReportAboutOverwrittenParameter\n\t\t\t\t\t\t\t.addField(FieldAnnotation.fromBCELField(classContext.getJavaClass(), shadowedField))\n\t\t\t\t\t\t\t.describe(FieldAnnotation.DID_YOU_MEAN_ROLE);\n\t\t\t\t\t\n\t\t\t\t\tpendingBugReportAboutOverwrittenParameter.addSourceLine(classContext, methodGen,\n\t\t\t\t\t\t\t\t\t\t\tsourceFileName, location.getHandle());\n\t\t\t\t\tcomplainedAbout.set(local);\n\t\t\t\t}\n\n\t\t\t\tif (storeLive)\n\t\t\t\t\tcontinue;\n\t\t\t\t\t\n\t\t\t\tTypeFrame typeFrame = typeDataflow.getAnalysis().getFactAtLocation(location);\n\t\t\t\tType typeOfValue = null;\n\t\t\t\tif (typeFrame.isValid() && typeFrame.getStackDepth() > 0) {\n\t\t\t\t\ttypeOfValue = typeFrame.getTopValue();\n\t\t\t\t}\n\n\t\t\t\tboolean storeOfNull = false;\n\t\t\t\tInstructionHandle prevInsHandle = location.getHandle().getPrev();\n\t\t\t\tif (prevInsHandle != null) {\n\t\t\t\t\tInstruction prevIns = prevInsHandle.getInstruction();\n\t\t\t\t\tboolean foundDeadClassInitialization = false;\n\t\t\t\t\tString initializationOf = null;\n\t\t\t\t\tif (prevIns instanceof ConstantPushInstruction) \n\t\t\t\t\t\tcontinue; // not an interesting dead store\n\t\t\t\t\telse if (prevIns instanceof GETSTATIC) {\n\t\t\t\t\t\t\tGETSTATIC getStatic = (GETSTATIC)prevIns;\n\t\t\t\t\t\t\tConstantPoolGen cpg = methodGen.getConstantPool();\n\t\t\t\t\t\t\tfoundDeadClassInitialization =  getStatic.getFieldName(cpg).startsWith(\"class$\")\n\t\t\t\t\t\t\t\t\t&& getStatic.getSignature(cpg).equals(\"Ljava/lang/Class;\");\n\t\t\t\t\t\t\tfor (Iterator<Location> j = cfg.locationIterator(); j.hasNext();) {\n\t\t\t\t\t\t\t\tLocation location2 = j.next();\n\t\t\t\t\t\t\t\tif (location2.getHandle().getPosition() + 15 == location.getHandle().getPosition()) {\n\t\t\t\t\t\t\t\t\tInstruction  instruction2 = location2.getHandle().getInstruction();\n\t\t\t\t\t\t\t\t\tif (instruction2 instanceof LDC) {\n\t\t\t\t\t\t\t\t\t\tObject value = ((LDC)instruction2).getValue(methodGen.getConstantPool());\n\t\t\t\t\t\t\t\t\t\tif (value instanceof String) {String n = (String) value;\n\t\t\t\t\t\t\t\t\t\tif (n.length() > 0)\n\t\t\t\t\t\t\t\t\t\t\tinitializationOf = ClassName.toSignature(n);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}}\n\n\t\t\t\t\t\t}\n\t\t\t\t\telse if (prevIns instanceof LDC) {\n\t\t\t\t\t\tLDC ldc = (LDC) prevIns;\n\t\t\t\t\t\tType t = ldc.getType(methodGen.getConstantPool());\n\t\t\t\t\t\tif (t.getSignature().equals(\"Ljava/lang/Class;\")) {\n\t\t\t\t\t\t\tConstantClass v = (ConstantClass) ldc.getValue(methodGen.getConstantPool());\n\t\t\t\t\t\t\tinitializationOf = ClassName.toSignature(v.getBytes(javaClass.getConstantPool()));\n\t\t\t\t\t\t\tfoundDeadClassInitialization = true;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tcontinue; // not an interesting DLS\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if (prevIns instanceof DUP2) {\n\t\t\t\t\t\t// Check for the case where, due to the bytecode\n\t\t\t\t\t\t// compiler, a long is needlessly stored just\n\t\t\t\t\t\t// after we've DUP2'ed the stack and just\n\t\t\t\t\t\t// before we return \n\t\t\t\t\t\tInstruction cur = location.getHandle().getInstruction();\n\t\t\t\t\t\tInstruction nxt = location.getHandle().getNext().getInstruction();\n\t\t\t\t\t\tif(cur instanceof LSTORE && nxt instanceof LRETURN) {\n\t\t\t\t\t\t\tcontinue; // not an interesting DLS\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (foundDeadClassInitialization) {\n\t\t\t\t\t\tif (classContext.getJavaClass().getSuperclassName().equals(\n\t\t\t\t\t\t\t\t\"org.apache.axis.client.Stub\")) continue;\n\t\t\t\t\t\tBugInstance bugInstance = new BugInstance(this,  \"DLS_DEAD_STORE_OF_CLASS_LITERAL\", \n\t\t\t\t\t\t\t\tPriorities.NORMAL_PRIORITY).addClassAndMethod(\n\t\t\t\t\t\t\t\t\t\tmethodGen,\n\t\t\t\t\t\t\t\t\t\tsourceFileName).add(lvAnnotation).addType(initializationOf);\n\t\t\t\t\t\taccumulator.accumulateBug(bugInstance, sourceLineAnnotation);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (prevIns instanceof LDC || prevIns instanceof ConstantPushInstruction)\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.STORE_OF_CONSTANT);\n\t\t\t\t\telse if (prevIns instanceof ACONST_NULL) {\n\t\t\t\t\t\tstoreOfNull = true;\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.STORE_OF_NULL);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\n\n\t\t\t\tif (typeOfValue instanceof BasicType || Type.STRING.equals(typeOfValue))\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.BASE_VALUE);\n\n\t\t\t\t// Ignore assignments that were killed by a subsequent\n\t\t\t\t// assignment.\n\t\t\t\tboolean killedBySubsequentStore = llsaDataflow.getAnalysis().killedByStore(liveStoreSet, local);\n\t\t\t\tif (killedBySubsequentStore) {\n\t\t\t\t\tif (propertySet.containsProperty(DeadLocalStoreProperty.STORE_OF_NULL) \n\t\t\t\t\t\t\t|| propertySet.containsProperty(DeadLocalStoreProperty.STORE_OF_CONSTANT) ) continue;\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.KILLED_BY_SUBSEQUENT_STORE);\n\t\t\t\t}\n\n\t\t\t\t// Ignore dead assignments of null and 0.\n\t\t\t\t// These often indicate defensive programming.\n\t\t\t\tInstructionHandle prev = location.getBasicBlock().getPredecessorOf(location.getHandle());\n\t\t\t\tint prevOpCode = -1;\n\n\t\t\t\tif (prev != null) {\n\t\t\t\t\tif (defensiveConstantValueOpcodes.get(prev.getInstruction().getOpcode())) {\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEFENSIVE_CONSTANT_OPCODE);\n\t\t\t\t\t\tprevOpCode = prev.getInstruction().getOpcode();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (prev.getInstruction() instanceof GETFIELD) {\n\t\t\t\t\t\tInstructionHandle prev2 = prev.getPrev();\n\n\t\t\t\t\t\tif (prev2 != null && prev2.getInstruction() instanceof ALOAD)\n\t\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.CACHING_VALUE);\n\t\t\t\t\t}\n\t\t\t\t\tif (prev.getInstruction() instanceof LoadInstruction)\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.COPY_VALUE);\n\t\t\t\t\tif (prev.getInstruction() instanceof InvokeInstruction)\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.METHOD_RESULT);\n\t\t\t\t}\n\t\t\t\tboolean deadObjectStore = false;\n\t\t\t\tif (ins instanceof IINC) {\n\t\t\t\t\t// special handling of IINC\n\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_INCREMENT);\n\t\t\t\t\tif (localIncrementCount[local] == 1) {\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_DEAD_INCREMENT);\n\t\t\t\t\t} else\n\t\t\t\t\t\tpropertySet.removeProperty(DeadLocalStoreProperty.IS_PARAMETER);\n\n\t\t\t\t} else if (ins instanceof ASTORE && prev != null) {\n\t\t\t\t\t// Look for objects created but never used\n\n\t\t\t\t\tInstruction prevIns = prev.getInstruction();\n\t\t\t\t\tif ((prevIns instanceof INVOKESPECIAL && ((INVOKESPECIAL) prevIns).getMethodName(methodGen.getConstantPool())\n\t\t\t\t\t\t\t.equals(\"<init>\"))\n\t\t\t\t\t\t\t|| prevIns instanceof ANEWARRAY || prevIns instanceof NEWARRAY || prevIns instanceof MULTIANEWARRAY) {\n\t\t\t\t\t\tdeadObjectStore = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (deadObjectStore)\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.DEAD_OBJECT_STORE);\n\t\t\t\telse if (!killedBySubsequentStore && localStoreCount[local] == 2 && localLoadCount[local] > 0) {\n\t\t\t\t\t// TODO: why is this significant?\n\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.TWO_STORES_MULTIPLE_LOADS);\n\n\t\t\t\t} else if (!parameterThatIsDeadAtEntry && localStoreCount[local] == 1 && localLoadCount[local] == 0\n\t\t\t\t\t\t&& propertySet.containsProperty(DeadLocalStoreProperty.DEFENSIVE_CONSTANT_OPCODE)) {\n\t\t\t\t\t// might be final local constant\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.SINGLE_STORE);\n\n\t\t\t\t} else if (!parameterThatIsDeadAtEntry \n\t\t\t\t\t\t&& !propertySet.containsProperty(DeadLocalStoreProperty.SHADOWS_FIELD) \n\t\t\t\t\t\t&& localLoadCount[local] == 0) {\n\t\t\t\t\t// TODO: why is this significant?\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.NO_LOADS);\n\t\t\t\t}\n\t\t\t\tif (!storeOfNull && typeOfValue != null && !propertySet.containsProperty(DeadLocalStoreProperty.EXCEPTION_HANDLER)) {\n\t\t\t\t\tString signatureOfValue = typeOfValue.getSignature();\n\t\t\t\t\tif ((signatureOfValue.startsWith(\"Ljava/sql/\") || signatureOfValue.startsWith(\"Ljavax/sql/\")) \n\t\t\t\t\t\t\t&& !signatureOfValue.endsWith(\"Exception\"))\n\t\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.STORE_OF_DATABASE_VALUE);\n\t\t\t\t}\n\n\t\t\t\tif (parameterThatIsDeadAtEntry) {\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.PARAM_DEAD_ON_ENTRY);\n\t\t\t\t\tif (pendingBugReportAboutOverwrittenParameter != null)\n\t\t\t\t\t\tpendingBugReportAboutOverwrittenParameter.setPriority(Detector.HIGH_PRIORITY);\n\t\t\t\t}\n\n\t\t\t\tif (localStoreCount[local] > 3)\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.MANY_STORES);\n\t\t\t\tint occurrences = cfg.getLocationsContainingInstructionWithOffset(\n\t\t\t\t\t\tpc).size();\n\t\t\t\tif (occurrences > 2 || sourceLineAnnotation.getStartLine() > 0 && linesMentionedMultipleTimes.get(sourceLineAnnotation.getStartLine()))\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.CLONED_STORE);\n\t\t\t\tString sourceFile = javaClass.getSourceFileName();\n\t\t\t\tif (javaClass.getClassName().endsWith(\"_jsp\"))\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.IN_JSP_PAGE);\n\t\t\t\telse if (javaClass.isSynthetic() || sourceFile != null && !sourceFile.endsWith(\".java\")) {\n\t\t\t\t\tString lvName = lvAnnotation.getName();\n\t\t\t\t\tif (sourceFile.endsWith(\".gxp\") && (lvName.startsWith(\"gxp$\" ) || lvName.startsWith(\"gxp_\"))) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpropertySet.addProperty(DeadLocalStoreProperty.NOT_JAVA);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint priority = propertySet.computePriority(NORMAL_PRIORITY);\n\t\t\t\tif (priority <= Detector.EXP_PRIORITY) {\n\n\t\t\t\t\t// Report the warning\n\t\t\t\t\tBugInstance bugInstance = new BugInstance(this, storeOfNull ? \"DLS_DEAD_LOCAL_STORE_OF_NULL\"\n\t\t\t\t\t\t\t: \"DLS_DEAD_LOCAL_STORE\", priority).addClassAndMethod(\n\t\t\t\t\t\t\t\t\tmethodGen,\n\t\t\t\t\t\t\t\t\tsourceFileName).add(lvAnnotation);\n\n\t\t\t\t\tif (shadowedField != null)\n\t\t\t\t\t\tbugInstance.addField(FieldAnnotation.fromBCELField(classContext.getJavaClass(), shadowedField))\n\t\t\t\t\t\t.describe(FieldAnnotation.DID_YOU_MEAN_ROLE);\n\t\t\t\t\t\n\t\t\t\t\t// If in relaxed reporting mode, encode heuristic\n\t\t\t\t\t// information.\n\t\t\t\t\tif (FindBugsAnalysisFeatures.isRelaxedMode()) {\n\t\t\t\t\t\t// Add general-purpose warning properties\n\t\t\t\t\t\tWarningPropertyUtil.addPropertiesForLocation(propertySet, classContext, method, location);\n\n\t\t\t\t\t\t// Turn all warning properties into BugProperties\n\t\t\t\t\t\tpropertySet.decorateBugInstance(bugInstance);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (DEBUG) {\n\t\t\t\t\t\tSystem.out.println(sourceFileName + \" : \" + methodGen.getName());\n\t\t\t\t\t\tSystem.out.println(\"priority: \" + priority);\n\t\t\t\t\t\tSystem.out.println(\"Reporting \" + bugInstance);\n\t\t\t\t\t\tSystem.out.println(propertySet);\n\t\t\t\t\t}\n\t\t\t\t\taccumulator.accumulateBug(bugInstance, sourceLineAnnotation);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (pendingBugReportAboutOverwrittenParameter != null)\n\t\t\t\t\tbugReporter.reportBug(pendingBugReportAboutOverwrittenParameter);\n\t\t\t}\n\t\t}\n\n\t\tsuppressWarningsIfOneLiveStoreOnLine(accumulator, liveStoreSourceLineSet);\n\n\t\taccumulator.reportAccumulatedBugs();\n\t}","commit_id":"98f7ab2b46e0070d49bbd077c2db4a4ad00362db","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private void processField(final FieldNode field, final MethodNode initializer, final ClassNode fieldHelper) {\n        if (field.isSynthetic()) return;\n        Expression initialExpression = field.getInitialExpression();\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(initializer.getParameters()[0]);\n            BlockStatement code = (BlockStatement) initializer.getCode();\n            code.addStatement(new ExpressionStatement(\n                    new BinaryExpression(new AttributeExpression(thisObject, new ConstantExpression(field.getName())),\n                            Token.newSymbol(Types.EQUAL, initialExpression.getLineNumber(), initialExpression.getColumnNumber()),\n                            initialExpression)\n            ));\n        }\n        if (fieldHelper != null) {\n            // define setter/getter helper methods\n            fieldHelper.addMethod(\n                    helperSetterName(field),\n                    ACC_PUBLIC | ACC_ABSTRACT,\n                    ClassHelper.VOID_TYPE,\n                    new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                    ClassNode.EMPTY_ARRAY,\n                    null\n            );\n            fieldHelper.addMethod(\n                    helperGetterName(field),\n                    ACC_PUBLIC | ACC_ABSTRACT,\n                    field.getOriginType(),\n                    Parameter.EMPTY_ARRAY,\n                    ClassNode.EMPTY_ARRAY,\n                    null\n            );\n        }\n    }","id":35791,"modified_method":"private void processField(final FieldNode field, final MethodNode initializer, final ClassNode fieldHelper) {\n        if (field.isSynthetic() && field.getName().indexOf('$') >= 0) return;\n        Expression initialExpression = field.getInitialExpression();\n        if (initialExpression != null) {\n            VariableExpression thisObject = new VariableExpression(initializer.getParameters()[0]);\n            BlockStatement code = (BlockStatement) initializer.getCode();\n            code.addStatement(new ExpressionStatement(\n                    new BinaryExpression(new AttributeExpression(thisObject, new ConstantExpression(field.getName())),\n                            Token.newSymbol(Types.EQUAL, initialExpression.getLineNumber(), initialExpression.getColumnNumber()),\n                            initialExpression)\n            ));\n        }\n        if (fieldHelper != null) {\n            // define setter/getter helper methods\n            fieldHelper.addMethod(\n                    helperSetterName(field),\n                    ACC_PUBLIC | ACC_ABSTRACT,\n                    ClassHelper.VOID_TYPE,\n                    new Parameter[]{new Parameter(field.getOriginType(), \"val\")},\n                    ClassNode.EMPTY_ARRAY,\n                    null\n            );\n            fieldHelper.addMethod(\n                    helperGetterName(field),\n                    ACC_PUBLIC | ACC_ABSTRACT,\n                    field.getOriginType(),\n                    Parameter.EMPTY_ARRAY,\n                    ClassNode.EMPTY_ARRAY,\n                    null\n            );\n        }\n    }","commit_id":"d6f78297dc3a82165281c4bd6c8a020845523dc1","url":"https://github.com/apache/groovy"},{"original_method":"private void createHelperClass(final ClassNode cNode) {\n        ClassNode helper = new InnerClassNode(\n                cNode,\n                helperClassName(cNode),\n                ACC_PUBLIC | ACC_STATIC | ACC_ABSTRACT | ACC_SYNTHETIC,\n                ClassHelper.OBJECT_TYPE,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        cNode.setModifiers(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n\n        MethodNode initializer = new MethodNode(\n                \"$init$\",\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{new Parameter(cNode, \"$this\")},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        helper.addMethod(initializer);\n\n        // add methods\n        Map<String, MethodNode> methods = cNode.getDeclaredMethodsMap();\n        for (MethodNode methodNode : methods.values()) {\n            if (methodNode.getDeclaringClass() == cNode) {\n                helper.addMethod(processMethod(cNode, methodNode));\n            }\n        }\n\n        // add fields\n        List<FieldNode> fields = new ArrayList<FieldNode>(cNode.getFields());\n        ClassNode fieldHelper = null;\n        if (cNode.getFields() != null) {\n            fieldHelper = new InnerClassNode(\n                    cNode,\n                    fieldHelperClassName(cNode),\n                    ACC_STATIC | ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT,\n                    ClassHelper.OBJECT_TYPE\n            );\n        }\n        for (FieldNode field : fields) {\n            processField(field, initializer, fieldHelper);\n        }\n        for (FieldNode field : fields) {\n            cNode.removeField(field.getName());\n        }\n\n        unit.getAST().addClass(helper);\n        if (fieldHelper != null) {\n            unit.getAST().addClass(fieldHelper);\n        }\n    }","id":35792,"modified_method":"private void createHelperClass(final ClassNode cNode) {\n        ClassNode helper = new InnerClassNode(\n                cNode,\n                helperClassName(cNode),\n                ACC_PUBLIC | ACC_STATIC | ACC_ABSTRACT | ACC_SYNTHETIC,\n                ClassHelper.OBJECT_TYPE,\n                ClassNode.EMPTY_ARRAY,\n                null\n        );\n        cNode.setModifiers(ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT);\n\n        MethodNode initializer = new MethodNode(\n                \"$init$\",\n                ACC_STATIC | ACC_PUBLIC | ACC_SYNTHETIC,\n                ClassHelper.VOID_TYPE,\n                new Parameter[]{new Parameter(cNode, \"$this\")},\n                ClassNode.EMPTY_ARRAY,\n                new BlockStatement()\n        );\n        helper.addMethod(initializer);\n\n        // apply the verifier to have the property nodes generated\n        generatePropertyMethods(cNode);\n\n        // add methods\n        Map<String, MethodNode> methods = cNode.getDeclaredMethodsMap();\n        for (MethodNode methodNode : methods.values()) {\n            if (methodNode.getDeclaringClass() == cNode) {\n                helper.addMethod(processMethod(cNode, methodNode));\n            }\n        }\n\n        // add fields\n        List<FieldNode> fields = new ArrayList<FieldNode>(cNode.getFields());\n        ClassNode fieldHelper = null;\n        if (cNode.getFields() != null) {\n            fieldHelper = new InnerClassNode(\n                    cNode,\n                    fieldHelperClassName(cNode),\n                    ACC_STATIC | ACC_PUBLIC | ACC_INTERFACE | ACC_ABSTRACT,\n                    ClassHelper.OBJECT_TYPE\n            );\n        }\n        for (FieldNode field : fields) {\n            processField(field, initializer, fieldHelper);\n        }\n\n        // clear properties to avoid generation of methods\n        cNode.getProperties().clear();\n\n        for (FieldNode field : fields) {\n            cNode.removeField(field.getName());\n        }\n\n        unit.getAST().addClass(helper);\n        if (fieldHelper != null) {\n            unit.getAST().addClass(fieldHelper);\n        }\n    }","commit_id":"d6f78297dc3a82165281c4bd6c8a020845523dc1","url":"https://github.com/apache/groovy"},{"original_method":"private static void applyTrait(final ClassNode cNode, final ClassNode helperClassNode, final ClassNode fieldHelperClassNode) {\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            int access = methodNode.getModifiers();\n            Parameter[] argumentTypes = methodNode.getParameters();\n            ClassNode[] exceptions = methodNode.getExceptions();\n            ClassNode returnType = methodNode.getReturnType();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && argumentTypes.length > 0 && ((access & ACC_STATIC) == ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] params = new Parameter[argumentTypes.length - 1];\n                for (int i = 1; i < argumentTypes.length; i++) {\n                    Parameter parameter = argumentTypes[i];\n                    params[i - 1] = new Parameter(parameter.getOriginType(), \"arg\" + i);\n                    argList.addExpression(new VariableExpression(params[i]));\n                }\n                MethodNode existingMethod = cNode.getDeclaredMethod(name, params);\n                if (existingMethod != null) {\n                    // override exists in the weaved class\n                    continue;\n                }\n                ClassNode[] exceptionNodes = new ClassNode[exceptions == null ? 0 : exceptions.length];\n                System.arraycopy(exceptions, 0, exceptionNodes, 0, exceptionNodes.length);\n                MethodCallExpression mce = new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        name,\n                        argList\n                );\n                mce.setImplicitThis(false);\n                MethodNode forwarder = new MethodNode(\n                        name,\n                        access ^ ACC_STATIC,\n                        returnType,\n                        params,\n                        exceptionNodes,\n                        new ExpressionStatement(mce)\n                );\n                cNode.addMethod(forwarder);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        \"$init$\",\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        if (fieldHelperClassNode != null) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, new Comparator<MethodNode>() {\n                public int compare(final MethodNode o1, final MethodNode o2) {\n                    if (o1.getName().endsWith(\"$get\")) return -1;\n                    return 1;\n                }\n            });\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(\"$get\") || fieldName.endsWith(\"$set\")) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    if (getter) {\n                        // add field\n                        cNode.addField(fieldName, ACC_PRIVATE, methodNode.getReturnType(), null);\n                    }\n                    Parameter[] newParams = getter ? Parameter.EMPTY_ARRAY :\n                            new Parameter[]{new Parameter(methodNode.getParameters()[0].getOriginType(), \"val\")};\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            ACC_PUBLIC,\n                            methodNode.getReturnType(),\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    //impl.addAnnotation(new AnnotationNode(ClassHelper.make(CompileStatic.class)));\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }","id":35793,"modified_method":"private static void applyTrait(final ClassNode cNode, final ClassNode helperClassNode, final ClassNode fieldHelperClassNode) {\n        for (MethodNode methodNode : helperClassNode.getAllDeclaredMethods()) {\n            String name = methodNode.getName();\n            int access = methodNode.getModifiers();\n            Parameter[] argumentTypes = methodNode.getParameters();\n            ClassNode[] exceptions = methodNode.getExceptions();\n            ClassNode returnType = methodNode.getReturnType();\n            boolean isAbstract = methodNode.isAbstract();\n            if (!isAbstract && argumentTypes.length > 0 && ((access & ACC_STATIC) == ACC_STATIC) && !name.contains(\"$\")) {\n                ArgumentListExpression argList = new ArgumentListExpression();\n                argList.addExpression(new VariableExpression(\"this\"));\n                Parameter[] params = new Parameter[argumentTypes.length - 1];\n                for (int i = 1; i < argumentTypes.length; i++) {\n                    Parameter parameter = argumentTypes[i];\n                    params[i - 1] = new Parameter(parameter.getOriginType(), \"arg\" + i);\n                    argList.addExpression(new VariableExpression(params[i - 1]));\n                }\n                MethodNode existingMethod = cNode.getDeclaredMethod(name, params);\n                if (existingMethod != null) {\n                    // override exists in the weaved class\n                    continue;\n                }\n                ClassNode[] exceptionNodes = new ClassNode[exceptions == null ? 0 : exceptions.length];\n                System.arraycopy(exceptions, 0, exceptionNodes, 0, exceptionNodes.length);\n                MethodCallExpression mce = new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        name,\n                        argList\n                );\n                mce.setImplicitThis(false);\n                MethodNode forwarder = new MethodNode(\n                        name,\n                        access ^ ACC_STATIC,\n                        returnType,\n                        params,\n                        exceptionNodes,\n                        new ExpressionStatement(mce)\n                );\n                cNode.addMethod(forwarder);\n            }\n        }\n        cNode.addObjectInitializerStatements(new ExpressionStatement(\n                new MethodCallExpression(\n                        new ClassExpression(helperClassNode),\n                        \"$init$\",\n                        new ArgumentListExpression(new VariableExpression(\"this\")))\n        ));\n        if (fieldHelperClassNode != null) {\n            // we should implement the field helper interface too\n            cNode.addInterface(fieldHelperClassNode);\n            // implementation of methods\n            List<MethodNode> declaredMethods = fieldHelperClassNode.getAllDeclaredMethods();\n            Collections.sort(declaredMethods, new Comparator<MethodNode>() {\n                public int compare(final MethodNode o1, final MethodNode o2) {\n                    if (o1.getName().endsWith(\"$get\")) return -1;\n                    return 1;\n                }\n            });\n            for (MethodNode methodNode : declaredMethods) {\n                String fieldName = methodNode.getName();\n                if (fieldName.endsWith(\"$get\") || fieldName.endsWith(\"$set\")) {\n                    int suffixIdx = fieldName.lastIndexOf(\"$\");\n                    fieldName = fieldName.substring(0, suffixIdx);\n                    String operation = methodNode.getName().substring(suffixIdx + 1);\n                    boolean getter = \"get\".equals(operation);\n                    if (getter) {\n                        // add field\n                        cNode.addField(fieldName, ACC_PRIVATE, methodNode.getReturnType(), null);\n                    }\n                    Parameter[] newParams = getter ? Parameter.EMPTY_ARRAY :\n                            new Parameter[]{new Parameter(methodNode.getParameters()[0].getOriginType(), \"val\")};\n                    Expression fieldExpr = new VariableExpression(cNode.getField(fieldName));\n                    Statement body =\n                            getter ? new ReturnStatement(fieldExpr) :\n                                    new ExpressionStatement(\n                                            new BinaryExpression(\n                                                    fieldExpr,\n                                                    Token.newSymbol(Types.EQUAL, 0, 0),\n                                                    new VariableExpression(newParams[0])\n                                            )\n                                    );\n                    MethodNode impl = new MethodNode(\n                            methodNode.getName(),\n                            ACC_PUBLIC,\n                            methodNode.getReturnType(),\n                            newParams,\n                            ClassNode.EMPTY_ARRAY,\n                            body\n                    );\n                    //impl.addAnnotation(new AnnotationNode(ClassHelper.make(CompileStatic.class)));\n                    cNode.addMethod(impl);\n                }\n            }\n        }\n    }","commit_id":"d6f78297dc3a82165281c4bd6c8a020845523dc1","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public Expression transform(final Expression exp) {\n            if (exp instanceof MethodCallExpression) {\n                MethodCallExpression call = (MethodCallExpression) exp;\n                Expression obj = call.getObjectExpression();\n                if (call.isImplicitThis() || obj.getText().equals(\"this\")) {\n                    MethodCallExpression transformed = new MethodCallExpression(\n                            weaved,\n                            call.getMethod(),\n                            super.transform(call.getArguments())\n                    );\n                    transformed.setSourcePosition(call);\n                    transformed.setSafe(call.isSafe());\n                    transformed.setSpreadSafe(call.isSpreadSafe());\n                    return transformed;\n                }\n            } else if (exp instanceof FieldExpression) {\n                MethodCallExpression mce = new MethodCallExpression(\n                        weaved,\n                        helperGetterName(((FieldExpression) exp).getField()),\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                mce.setSourcePosition(exp);\n                return mce;\n            } else if (exp instanceof VariableExpression) {\n                VariableExpression vexp = (VariableExpression) exp;\n                if (vexp.getAccessedVariable() instanceof FieldNode) {\n                    MethodCallExpression mce = new MethodCallExpression(\n                            weaved,\n                            helperGetterName((FieldNode) vexp.getAccessedVariable()),\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    return mce;\n                }\n            } else if (exp instanceof PropertyExpression) {\n                if (((PropertyExpression) exp).isImplicitThis() || \"this\".equals(((PropertyExpression) exp).getObjectExpression().getText())) {\n                    MethodCallExpression mce = new MethodCallExpression(\n                            weaved,\n                            ((PropertyExpression) exp).getPropertyAsString() + \"$get\",\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    return mce;\n                }\n            }\n            return super.transform(exp);\n        }","id":35794,"modified_method":"@Override\n        public Expression transform(final Expression exp) {\n            if (exp instanceof BinaryExpression) {\n                Expression leftExpression = ((BinaryExpression) exp).getLeftExpression();\n                Expression rightExpression = ((BinaryExpression) exp).getRightExpression();\n                Token operation = ((BinaryExpression) exp).getOperation();\n                if (operation.getText().equals(\"=\")) {\n                    String leftFieldName = null;\n                    // it's an assignment\n                    if (leftExpression instanceof VariableExpression && ((VariableExpression) leftExpression).getAccessedVariable() instanceof FieldNode) {\n                        leftFieldName = ((VariableExpression) leftExpression).getAccessedVariable().getName();\n                    } else if (leftExpression instanceof FieldExpression) {\n                        leftFieldName = ((FieldExpression) leftExpression).getFieldName();\n                    } else if (leftExpression instanceof PropertyExpression\n                            && (((PropertyExpression) leftExpression).isImplicitThis() || \"this\".equals(((PropertyExpression) leftExpression).getObjectExpression().getText()))) {\n                        leftFieldName = ((PropertyExpression) leftExpression).getPropertyAsString();\n                    }\n                    if (leftFieldName!=null) {\n                        MethodCallExpression mce = new MethodCallExpression(\n                                weaved,\n                                leftFieldName+\"$set\",\n                                new ArgumentListExpression(super.transform(rightExpression))\n                        );\n                        mce.setSourcePosition(exp);\n                        return mce;\n                    }\n                }\n                Expression leftTransform = super.transform(leftExpression);\n                Expression rightTransform = super.transform(rightExpression);\n                Expression ret = new BinaryExpression(leftTransform, operation, rightTransform);\n                ret.setSourcePosition(exp);\n                ret.copyNodeMetaData(exp);\n                return ret;\n            } else if (exp instanceof MethodCallExpression) {\n                MethodCallExpression call = (MethodCallExpression) exp;\n                Expression obj = call.getObjectExpression();\n                if (call.isImplicitThis() || obj.getText().equals(\"this\")) {\n                    MethodCallExpression transformed = new MethodCallExpression(\n                            weaved,\n                            call.getMethod(),\n                            super.transform(call.getArguments())\n                    );\n                    transformed.setSourcePosition(call);\n                    transformed.setSafe(call.isSafe());\n                    transformed.setSpreadSafe(call.isSpreadSafe());\n                    return transformed;\n                }\n            } else if (exp instanceof FieldExpression) {\n                MethodCallExpression mce = new MethodCallExpression(\n                        weaved,\n                        helperGetterName(((FieldExpression) exp).getField()),\n                        ArgumentListExpression.EMPTY_ARGUMENTS\n                );\n                mce.setSourcePosition(exp);\n                return mce;\n            } else if (exp instanceof VariableExpression) {\n                VariableExpression vexp = (VariableExpression) exp;\n                if (vexp.getAccessedVariable() instanceof FieldNode) {\n                    MethodCallExpression mce = new MethodCallExpression(\n                            weaved,\n                            helperGetterName((FieldNode) vexp.getAccessedVariable()),\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    return mce;\n                }\n            } else if (exp instanceof PropertyExpression) {\n                if (((PropertyExpression) exp).isImplicitThis() || \"this\".equals(((PropertyExpression) exp).getObjectExpression().getText())) {\n                    MethodCallExpression mce = new MethodCallExpression(\n                            weaved,\n                            ((PropertyExpression) exp).getPropertyAsString() + \"$get\",\n                            ArgumentListExpression.EMPTY_ARGUMENTS\n                    );\n                    mce.setSourcePosition(exp);\n                    return mce;\n                }\n            }\n            // todo: unary expressions (field++, field+=, ...)\n            return super.transform(exp);\n        }","commit_id":"d6f78297dc3a82165281c4bd6c8a020845523dc1","url":"https://github.com/apache/groovy"},{"original_method":"public CoberturaClassFileTransformer(\n\t\tString[] includes, String[] excludes, final File lockFile) {\n\n\t\t_includePatterns = new Pattern[includes.length];\n\n\t\tfor (int i = 0; i < includes.length; i++) {\n\t\t\tPattern pattern = Pattern.compile(includes[i]);\n\n\t\t\t_includePatterns[i] = pattern;\n\t\t}\n\n\t\t_excludePatterns = new Pattern[excludes.length];\n\n\t\tfor (int i = 0; i < excludes.length; i++) {\n\t\t\tPattern pattern = Pattern.compile(excludes[i]);\n\n\t\t\t_excludePatterns[i] = pattern;\n\t\t}\n\n\t\tProjectDataUtil.addShutdownHook(\n\t\t\tnew Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tFile dataFile =\n\t\t\t\t\t\tCoverageDataFileHandler.getDefaultDataFile();\n\n\t\t\t\t\tCollection<ProjectData> projectDatas =\n\t\t\t\t\t\t_projectDatas.values();\n\n\t\t\t\t\tProjectDataUtil.mergeSave(\n\t\t\t\t\t\tdataFile, lockFile,\n\t\t\t\t\t\tprojectDatas.toArray(\n\t\t\t\t\t\t\tnew ProjectData[projectDatas.size()]));\n\n\t\t\t\t\t_projectDatas.clear();\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t);\n\t}","id":35795,"modified_method":"public CoberturaClassFileTransformer(String[] includes, String[] excludes) {\n\t\t_includePatterns = new Pattern[includes.length];\n\n\t\tfor (int i = 0; i < includes.length; i++) {\n\t\t\tPattern pattern = Pattern.compile(includes[i]);\n\n\t\t\t_includePatterns[i] = pattern;\n\t\t}\n\n\t\t_excludePatterns = new Pattern[excludes.length];\n\n\t\tfor (int i = 0; i < excludes.length; i++) {\n\t\t\tPattern pattern = Pattern.compile(excludes[i]);\n\n\t\t\t_excludePatterns[i] = pattern;\n\t\t}\n\t}","commit_id":"1804a392cc9a8d94e12849d1ad23c924b6e9ab98","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void initialize() {\n\t\tProjectDataUtil.addShutdownHook(\n\t\t\tnew Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tFile dataFile =\n\t\t\t\t\t\tCoverageDataFileHandler.getDefaultDataFile();\n\n\t\t\t\t\tProjectData projectData =\n\t\t\t\t\t\tProjectDataUtil.collectProjectData();\n\n\t\t\t\t\tProjectDataUtil.mergeSave(dataFile, _lockFile, projectData);\n\t\t\t\t}\n\n\t\t\t}\n\t\t);\n\t}","id":35796,"modified_method":"public static void initialize() {\n\t\tProjectDataUtil.addMergeHook();\n\t}","commit_id":"1804a392cc9a8d94e12849d1ad23c924b6e9ab98","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void _assertClassDataCoverage(\n\t\tClass<?> clazz, ClassData classData) {\n\n\t\tif (clazz.isSynthetic()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (classData == null) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\"Class \" + clazz.getName() + \" has no coverage data\");\n\t\t}\n\n\t\tif ((classData.getBranchCoverageRate() != 1.0) ||\n\t\t\t(classData.getLineCoverageRate() != 1.0)) {\n\n\t\t\tSystem.out.printf(\n\t\t\t\t\"%n[Cobertura] %s is not fully covered.%n[Cobertura]Branch \" +\n\t\t\t\t\t\"coverage rate : %.2f, line coverage rate : %.2f.%n\" +\n\t\t\t\t\t\t\"[Cobertura]Please rerun test with -Djunit.code.\" +\n\t\t\t\t\t\t\t\"coverage=true to see coverage report.%n\",\n\t\t\t\tclassData.getName(), classData.getBranchCoverageRate(),\n\t\t\t\tclassData.getLineCoverageRate());\n\n\t\t\tSet<CoverageData> coverageDatas = classData.getLines();\n\n\t\t\tfor (CoverageData coverageData : coverageDatas) {\n\t\t\t\tif (!(coverageData instanceof LineData)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tLineData lineData = (LineData)coverageData;\n\n\t\t\t\tif (lineData.isCovered()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.printf(\n\t\t\t\t\t\"[Cobertura] %s line %d is not covered %n\",\n\t\t\t\t\tclassData.getName(), lineData.getLineNumber());\n\t\t\t}\n\n\t\t\tthrow new AssertionError(\n\t\t\t\tclassData.getName() + \" is not fully covered\");\n\t\t}\n\n\t\tSystem.out.printf(\n\t\t\t\"[Cobertura] %s is fully covered.%n\", classData.getName());\n\t}","id":35797,"modified_method":"private static void _assertClassDataCoverage(\n\t\tClass<?> clazz, ClassData classData) {\n\n\t\tif (clazz.isInterface() || clazz.isSynthetic()) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (classData == null) {\n\t\t\tthrow new RuntimeException(\n\t\t\t\t\"Class \" + clazz.getName() + \" has no coverage data\");\n\t\t}\n\n\t\tif ((classData.getBranchCoverageRate() != 1.0) ||\n\t\t\t(classData.getLineCoverageRate() != 1.0)) {\n\n\t\t\tSystem.out.printf(\n\t\t\t\t\"%n[Cobertura] %s is not fully covered.%n[Cobertura]Branch \" +\n\t\t\t\t\t\"coverage rate : %.2f, line coverage rate : %.2f.%n\" +\n\t\t\t\t\t\t\"[Cobertura]Please rerun test with -Djunit.code.\" +\n\t\t\t\t\t\t\t\"coverage=true to see coverage report.%n\",\n\t\t\t\tclassData.getName(), classData.getBranchCoverageRate(),\n\t\t\t\tclassData.getLineCoverageRate());\n\n\t\t\tSet<CoverageData> coverageDatas = classData.getLines();\n\n\t\t\tfor (CoverageData coverageData : coverageDatas) {\n\t\t\t\tif (!(coverageData instanceof LineData)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tLineData lineData = (LineData)coverageData;\n\n\t\t\t\tif (lineData.isCovered()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tSystem.out.printf(\n\t\t\t\t\t\"[Cobertura] %s line %d is not covered %n\",\n\t\t\t\t\tclassData.getName(), lineData.getLineNumber());\n\t\t\t}\n\n\t\t\tthrow new AssertionError(\n\t\t\t\tclassData.getName() + \" is not fully covered\");\n\t\t}\n\n\t\tSystem.out.printf(\n\t\t\t\"[Cobertura] %s is fully covered.%n\", classData.getName());\n\t}","commit_id":"1804a392cc9a8d94e12849d1ad23c924b6e9ab98","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static synchronized void premain(\n\t\tString agentArguments, Instrumentation instrumentation) {\n\n\t\tString[] arguments = agentArguments.split(\";\");\n\n\t\tString[] includes = arguments[0].split(\",\");\n\t\tString[] excludes = arguments[1].split(\",\");\n\n\t\tif (Boolean.getBoolean(\"junit.code.coverage\")) {\n\t\t\tCoberturaClassFileTransformer coberturaClassFileTransformer =\n\t\t\t\tnew CoberturaClassFileTransformer(\n\t\t\t\t\tincludes, excludes, _lockFile);\n\n\t\t\tinstrumentation.addTransformer(coberturaClassFileTransformer);\n\t\t}\n\t\telse if (instrumentation.isRedefineClassesSupported() &&\n\t\t\t\t instrumentation.isRetransformClassesSupported()) {\n\n\t\t\t_instrumentation = instrumentation;\n\t\t\t_includes = includes;\n\t\t\t_excludes = excludes;\n\n\t\t\t// Forcibly clear the data file to make sure that the coverage\n\t\t\t// assert is based on the current test\n\n\t\t\tFile dataFile = CoverageDataFileHandler.getDefaultDataFile();\n\n\t\t\tdataFile.delete();\n\t\t}\n\t\telse {\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tsb.append(\"Current JVM is not capable for dynamic \");\n\t\t\tsb.append(\"instrumententation. Instrumentation \");\n\n\t\t\tif (instrumentation.isRetransformClassesSupported()) {\n\t\t\t\tsb.append(\"supports \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"does not support \");\n\t\t\t}\n\n\t\t\tsb.append(\"restranforming classes. Instrumentation \");\n\n\t\t\tif (instrumentation.isRedefineClassesSupported()) {\n\t\t\t\tsb.append(\"supports \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"does not support \");\n\t\t\t}\n\n\t\t\tsb.append(\"redefining classes. Dynamic instrumententation is \");\n\t\t\tsb.append(\"disabled.\");\n\n\t\t\tSystem.out.println(sb.toString());\n\t\t}\n\t}","id":35798,"modified_method":"public static synchronized void premain(\n\t\tString agentArguments, Instrumentation instrumentation) {\n\n\t\tString[] arguments = agentArguments.split(\";\");\n\n\t\tString[] includes = arguments[0].split(\",\");\n\t\tString[] excludes = arguments[1].split(\",\");\n\n\t\tif (Boolean.getBoolean(\"junit.code.coverage\")) {\n\t\t\tfinal CoberturaClassFileTransformer coberturaClassFileTransformer =\n\t\t\t\tnew CoberturaClassFileTransformer(includes, excludes);\n\n\t\t\tinstrumentation.addTransformer(coberturaClassFileTransformer);\n\n\t\t\tRuntime runtime = Runtime.getRuntime();\n\n\t\t\truntime.addShutdownHook(\n\t\t\t\tnew Thread() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tProjectDataUtil.runMergeHooks();\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t}\n\t\telse if (instrumentation.isRedefineClassesSupported() &&\n\t\t\t\t instrumentation.isRetransformClassesSupported()) {\n\n\t\t\t_instrumentation = instrumentation;\n\t\t\t_includes = includes;\n\t\t\t_excludes = excludes;\n\n\t\t\t// Forcibly clear the data file to make sure that the coverage\n\t\t\t// assert is based on the current test\n\n\t\t\tFile dataFile = CoverageDataFileHandler.getDefaultDataFile();\n\n\t\t\tdataFile.delete();\n\t\t}\n\t\telse {\n\t\t\tStringBuilder sb = new StringBuilder();\n\n\t\t\tsb.append(\"Current JVM is not capable for dynamic \");\n\t\t\tsb.append(\"instrumententation. Instrumentation \");\n\n\t\t\tif (instrumentation.isRetransformClassesSupported()) {\n\t\t\t\tsb.append(\"supports \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"does not support \");\n\t\t\t}\n\n\t\t\tsb.append(\"restranforming classes. Instrumentation \");\n\n\t\t\tif (instrumentation.isRedefineClassesSupported()) {\n\t\t\t\tsb.append(\"supports \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"does not support \");\n\t\t\t}\n\n\t\t\tsb.append(\"redefining classes. Dynamic instrumententation is \");\n\t\t\tsb.append(\"disabled.\");\n\n\t\t\tSystem.out.println(sb.toString());\n\t\t}\n\t}","commit_id":"1804a392cc9a8d94e12849d1ad23c924b6e9ab98","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static synchronized void assertCoverage(\n\t\tboolean includeInnerClasses, Class<?>... classes) {\n\n\t\tif (!_dynamicallyInstrumented) {\n\t\t\treturn;\n\t\t}\n\n\t\tFile dataFile = CoverageDataFileHandler.getDefaultDataFile();\n\n\t\ttry {\n\t\t\tProjectData projectData = ProjectDataUtil.captureProjectData(\n\t\t\t\tdataFile, _lockFile);\n\n\t\t\tfor (Class<?> clazz : classes) {\n\t\t\t\tClassData classData = projectData.getClassData(clazz.getName());\n\n\t\t\t\t_assertClassDataCoverage(clazz, classData);\n\n\t\t\t\tif (includeInnerClasses) {\n\t\t\t\t\tClass<?>[] declaredClasses = clazz.getDeclaredClasses();\n\n\t\t\t\t\tdeclaredClass:\n\t\t\t\t\tfor (Class<?> declaredClass : declaredClasses) {\n\t\t\t\t\t\tfor (Class<?> clazz2 : classes) {\n\t\t\t\t\t\t\tif (clazz2.equals(declaredClass)) {\n\t\t\t\t\t\t\t\tcontinue declaredClass;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclassData = projectData.getClassData(\n\t\t\t\t\t\t\tdeclaredClass.getName());\n\n\t\t\t\t\t\t_assertClassDataCoverage(declaredClass, classData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tdataFile.delete();\n\n\t\t\tSystem.clearProperty(\"junit.code.coverage\");\n\n\t\t\t_dynamicallyInstrumented = false;\n\n\t\t\t_instrumentation.removeTransformer(_coberturaClassFileTransformer);\n\n\t\t\t_coberturaClassFileTransformer = null;\n\n\t\t\tif (_originalClassDefinitions != null) {\n\t\t\t\ttry {\n\t\t\t\t\tList<ClassDefinition> classDefinitions =\n\t\t\t\t\t\tnew ArrayList<ClassDefinition>(\n\t\t\t\t\t\t\t_originalClassDefinitions.size());\n\n\t\t\t\t\tfor (int i = 0; i < _originalClassDefinitions.size(); i++) {\n\t\t\t\t\t\tOriginalClassDefinition originalClassDefinition =\n\t\t\t\t\t\t\t_originalClassDefinitions.get(i);\n\n\t\t\t\t\t\tClassDefinition classDefinition =\n\t\t\t\t\t\t\toriginalClassDefinition.toClassDefinition();\n\n\t\t\t\t\t\tif (classDefinition != null) {\n\t\t\t\t\t\t\tclassDefinitions.add(classDefinition);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_originalClassDefinitions = null;\n\n\t\t\t\t\t_instrumentation.redefineClasses(\n\t\t\t\t\t\tclassDefinitions.toArray(\n\t\t\t\t\t\t\tnew ClassDefinition[classDefinitions.size()]));\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"Unable to uninstrument classes\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":35799,"modified_method":"public static synchronized void assertCoverage(\n\t\tboolean includeInnerClasses, Class<?>... classes) {\n\n\t\tif (!_dynamicallyInstrumented) {\n\t\t\treturn;\n\t\t}\n\n\t\t_instrumentation.removeTransformer(_coberturaClassFileTransformer);\n\n\t\t_coberturaClassFileTransformer = null;\n\n\t\ttry {\n\t\t\tProjectData projectData = ProjectDataUtil.captureProjectData();\n\n\t\t\tfor (Class<?> clazz : classes) {\n\t\t\t\tClassData classData = projectData.getClassData(clazz.getName());\n\n\t\t\t\t_assertClassDataCoverage(clazz, classData);\n\n\t\t\t\tif (includeInnerClasses) {\n\t\t\t\t\tClass<?>[] declaredClasses = clazz.getDeclaredClasses();\n\n\t\t\t\t\tdeclaredClass:\n\t\t\t\t\tfor (Class<?> declaredClass : declaredClasses) {\n\t\t\t\t\t\tfor (Class<?> clazz2 : classes) {\n\t\t\t\t\t\t\tif (clazz2.equals(declaredClass)) {\n\t\t\t\t\t\t\t\tcontinue declaredClass;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclassData = projectData.getClassData(\n\t\t\t\t\t\t\tdeclaredClass.getName());\n\n\t\t\t\t\t\t_assertClassDataCoverage(declaredClass, classData);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tSystem.clearProperty(\"junit.code.coverage\");\n\n\t\t\t_dynamicallyInstrumented = false;\n\n\t\t\tif (_originalClassDefinitions != null) {\n\t\t\t\ttry {\n\t\t\t\t\tList<ClassDefinition> classDefinitions =\n\t\t\t\t\t\tnew ArrayList<ClassDefinition>(\n\t\t\t\t\t\t\t_originalClassDefinitions.size());\n\n\t\t\t\t\tfor (int i = 0; i < _originalClassDefinitions.size(); i++) {\n\t\t\t\t\t\tOriginalClassDefinition originalClassDefinition =\n\t\t\t\t\t\t\t_originalClassDefinitions.get(i);\n\n\t\t\t\t\t\tClassDefinition classDefinition =\n\t\t\t\t\t\t\toriginalClassDefinition.toClassDefinition();\n\n\t\t\t\t\t\tif (classDefinition != null) {\n\t\t\t\t\t\t\tclassDefinitions.add(classDefinition);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t_originalClassDefinitions = null;\n\n\t\t\t\t\t_instrumentation.redefineClasses(\n\t\t\t\t\t\tclassDefinitions.toArray(\n\t\t\t\t\t\t\tnew ClassDefinition[classDefinitions.size()]));\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new RuntimeException(\n\t\t\t\t\t\t\"Unable to uninstrument classes\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"1804a392cc9a8d94e12849d1ad23c924b6e9ab98","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static synchronized void dynamicallyInstrument(\n\t\t\tString[] includes, String[] excludes)\n\t\tthrows UnmodifiableClassException {\n\n\t\tif ((_instrumentation == null) || _dynamicallyInstrumented) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (includes == null) {\n\t\t\tincludes = _includes;\n\t\t}\n\n\t\tif (excludes == null) {\n\t\t\texcludes = _excludes;\n\t\t}\n\n\t\tif (_coberturaClassFileTransformer == null) {\n\t\t\t_coberturaClassFileTransformer = new CoberturaClassFileTransformer(\n\t\t\t\tincludes, excludes, _lockFile);\n\t\t}\n\n\t\t_instrumentation.addTransformer(_coberturaClassFileTransformer, true);\n\n\t\tClass<?>[] allLoadedClasses =_instrumentation.getAllLoadedClasses();\n\n\t\tList<Class<?>> modifiableClasses = new ArrayList<Class<?>>();\n\n\t\tfor (Class<?> loadedClass : allLoadedClasses) {\n\t\t\tif (_instrumentation.isModifiableClass(loadedClass)) {\n\t\t\t\tString className = loadedClass.getName();\n\n\t\t\t\tclassName = className.replace('.', '/');\n\n\t\t\t\tif (_coberturaClassFileTransformer.matches(className)) {\n\t\t\t\t\tmodifiableClasses.add(loadedClass);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!modifiableClasses.isEmpty()) {\n\t\t\t_instrumentation.retransformClasses(\n\t\t\t\tmodifiableClasses.toArray(\n\t\t\t\t\tnew Class<?>[modifiableClasses.size()]));\n\t\t}\n\n\t\t_dynamicallyInstrumented = true;\n\t\t_originalClassDefinitions = null;\n\n\t\tSystem.setProperty(\"junit.code.coverage\", \"true\");\n\t}","id":35800,"modified_method":"public static synchronized void dynamicallyInstrument(\n\t\t\tString[] includes, String[] excludes)\n\t\tthrows UnmodifiableClassException {\n\n\t\tif ((_instrumentation == null) || _dynamicallyInstrumented) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (includes == null) {\n\t\t\tincludes = _includes;\n\t\t}\n\n\t\tif (excludes == null) {\n\t\t\texcludes = _excludes;\n\t\t}\n\n\t\tif (_coberturaClassFileTransformer == null) {\n\t\t\t_coberturaClassFileTransformer = new CoberturaClassFileTransformer(\n\t\t\t\tincludes, excludes);\n\t\t}\n\n\t\t_instrumentation.addTransformer(_coberturaClassFileTransformer, true);\n\n\t\tClass<?>[] allLoadedClasses =_instrumentation.getAllLoadedClasses();\n\n\t\tList<Class<?>> modifiableClasses = new ArrayList<Class<?>>();\n\n\t\tfor (Class<?> loadedClass : allLoadedClasses) {\n\t\t\tif (_instrumentation.isModifiableClass(loadedClass)) {\n\t\t\t\tString className = loadedClass.getName();\n\n\t\t\t\tclassName = className.replace('.', '/');\n\n\t\t\t\tif (_coberturaClassFileTransformer.matches(className)) {\n\t\t\t\t\tmodifiableClasses.add(loadedClass);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Ensure TouchCollector is loaded before retransform.\n\t\t// A class can be instrumented for code coverage in a new classloader,\n\t\t// but failed to initialize due to an ExceptionInInitializerError.\n\t\t// Therefor its reference to TouchCollector has not be resolved.\n\t\t// But that class will still be redefined in the end to its original\n\t\t// form, and that will sucessfully resolve TouchCollector for the first\n\t\t// time, in its original form. It will cause TouchCollector#<clinit>\n\t\t// being invoked, which in turn calls ProjectData#initialize() to add\n\t\t// net.sourceforge.cobertura.coveragedata.SaveTimer into shutdown hook,\n\t\t// causing a jvm shutdown issue.\n\n\t\tmodifiableClasses.add(TouchCollector.class);\n\n\t\t_instrumentation.retransformClasses(\n\t\t\tmodifiableClasses.toArray(new Class<?>[modifiableClasses.size()]));\n\n\t\t_dynamicallyInstrumented = true;\n\t\t_originalClassDefinitions = null;\n\n\t\tSystem.setProperty(\"junit.code.coverage\", \"true\");\n\t}","commit_id":"1804a392cc9a8d94e12849d1ad23c924b6e9ab98","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static FileLock _lockFile(File file) {\n\t\ttry {\n\t\t\tRandomAccessFile randomAccessFile = new RandomAccessFile(\n\t\t\t\tfile, \"rw\");\n\n\t\t\tFileChannel fileChannel = randomAccessFile.getChannel();\n\n\t\t\treturn fileChannel.lock();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new RuntimeException(ioe);\n\t\t}\n\t}","id":35801,"modified_method":"private static FileLock _lockFile() {\n\t\ttry {\n\t\t\tRandomAccessFile randomAccessFile = new RandomAccessFile(\n\t\t\t\tInstrumentationAgent.getLockFile(), \"rw\");\n\n\t\t\tFileChannel fileChannel = randomAccessFile.getChannel();\n\n\t\t\treturn fileChannel.lock();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new RuntimeException(ioe);\n\t\t}\n\t}","commit_id":"1804a392cc9a8d94e12849d1ad23c924b6e9ab98","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static ProjectData captureProjectData(File dataFile, File lockFile) {\n\t\tfor (Runnable runnable : _getShutdownHooks()) {\n\t\t\trunnable.run();\n\t\t}\n\n\t\tsynchronized (ProjectDataUtil.class.getName().intern()) {\n\t\t\tFileLock fileLock = _lockFile(lockFile);\n\n\t\t\ttry {\n\t\t\t\tif (dataFile.exists()) {\n\t\t\t\t\treturn _readProjectData(dataFile);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new ProjectData();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t_unlockFile(fileLock);\n\t\t\t}\n\t\t}\n\t}","id":35802,"modified_method":"public static ProjectData captureProjectData() {\n\t\trunMergeHooks();\n\n\t\tsynchronized (ProjectDataUtil.class.getName().intern()) {\n\t\t\tFileLock fileLock = _lockFile();\n\n\t\t\ttry {\n\t\t\t\tFile dataFile = CoverageDataFileHandler.getDefaultDataFile();\n\n\t\t\t\tif (dataFile.exists()) {\n\t\t\t\t\tProjectData projectData = _readProjectData(dataFile);\n\n\t\t\t\t\tdataFile.delete();\n\n\t\t\t\t\treturn projectData;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new ProjectData();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t_unlockFile(fileLock);\n\t\t\t}\n\t\t}\n\t}","commit_id":"1804a392cc9a8d94e12849d1ad23c924b6e9ab98","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\t public void report() {\n\t\tSet<String> fieldNamesSet = new HashSet<String>();\n\t\tfor(XField f : writtenNonNullFields)\n\t\t\tfieldNamesSet.add(f.getName());\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"read fields:\" );\n\t\t\tfor(XField f : readFields) \n\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t\tif (!containerFields.isEmpty()) {\n\t\t\t\tSystem.out.println(\"ejb3 fields:\" );\n\t\t\t\tfor(XField f : containerFields) \n\t\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t\t}\n\t\t\tif (!reflectiveFields.isEmpty()) {\n\t\t\t\tSystem.out.println(\"reflective fields:\" );\n\t\t\t\tfor(XField f : reflectiveFields) \n\t\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t\t}\n\n\n\t\t\tSystem.out.println(\"written fields:\" );\n\t\t\tfor (XField f : writtenFields) \n\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t\tSystem.out.println(\"written nonnull fields:\" );\n\t\t\tfor (XField f : writtenNonNullFields) \n\t\t\t\tSystem.out.println(\"  \" + f);\n\n\t\t\tSystem.out.println(\"assumed nonnull fields:\" );\n\t\t\tfor (XField f : assumedNonNull.keySet()) \n\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t}\n\t\tSet<XField> declaredFields = new HashSet<XField>();\n\t\tAnalysisContext currentAnalysisContext = AnalysisContext.currentAnalysisContext();\n\t\tXFactory xFactory = AnalysisContext.currentXFactory();\n\t\tfor(XField f : AnalysisContext.currentXFactory().allFields()) {\n\t\t\tClassDescriptor classDescriptor = f.getClassDescriptor();\n\t\t\tif (currentAnalysisContext.isApplicationClass(classDescriptor) && !xFactory.isReflectiveClass(classDescriptor)  && !f.isProtected() && !f.isPublic())\n\t\t\t\tdeclaredFields.add(f);\n\t\t}\n\t\t// Don't report anything about ejb3Fields\n\t\tdeclaredFields.removeAll(containerFields);\n\t\tdeclaredFields.removeAll(reflectiveFields);\n\t\tfor(Iterator<XField> i = declaredFields.iterator(); i.hasNext(); ) {\n\t\t\tXField f = i.next();\n\t\t\tif (f.isSynthetic() || f.getName().startsWith(\"_\"))\n\t\t\t\ti.remove();\n\t\t}\n\n\t\tTreeSet<XField> notInitializedInConstructors =\n\t\t\t\tnew TreeSet<XField>(declaredFields);\n\t\tnotInitializedInConstructors.retainAll(readFields);\n\t\tnotInitializedInConstructors.retainAll(writtenFields);\n\t\tnotInitializedInConstructors.retainAll(assumedNonNull.keySet());\n\t\tnotInitializedInConstructors.removeAll(writtenInConstructorFields);\n\t\tfor(Iterator<XField> i = notInitializedInConstructors.iterator(); i.hasNext(); ) {\n\t\t\tif (i.next().isStatic())\n\t\t\t\ti.remove();\n\t\t}\n\n\t\tTreeSet<XField> readOnlyFields =\n\t\t\t\tnew TreeSet<XField>(declaredFields);\n\t\treadOnlyFields.removeAll(writtenFields);\n\n\t\treadOnlyFields.retainAll(readFields);\n\n\t\tTreeSet<XField> nullOnlyFields =\n\t\t\tnew TreeSet<XField>(declaredFields);\n\t\tnullOnlyFields.removeAll(writtenNonNullFields);\n\n\t\tnullOnlyFields.retainAll(readFields);\n\n\t\tSet<XField> writeOnlyFields = declaredFields;\n\t\twriteOnlyFields.removeAll(readFields);\n\n\t\tMap<String, Integer> count = new HashMap<String, Integer>();\n\t\tBag<String> nullOnlyFieldNames = new Bag<String>();\n\t\tBag<ClassDescriptor> classContainingNullOnlyFields = new Bag<ClassDescriptor>();\n\t\t\n\t\tfor (XField f : nullOnlyFields) {\n\t\t\tnullOnlyFieldNames.add(f.getName());\n\t\t\tclassContainingNullOnlyFields.add(f.getClassDescriptor());\n\t\t\tint increment = 3;\n\t\t\tCollection<ProgramPoint> assumedNonNullAt = assumedNonNull.get(f);\n\t\t\tif (assumedNonNullAt != null)\n\t\t\t\tincrement += assumedNonNullAt.size();\n\t\t\tfor(String s : unknownAnnotation.get(f)) {\n\t\t\t\tInteger value = count.get(s);\n\t\t\t\tif (value == null) \n\t\t\t\t\tcount.put(s,increment);\n\t\t\t\telse count.put(s,value+increment);\n\t\t\t}\t\n\t\t}\n\t\tMap<XField, Integer> maxCount = new HashMap<XField, Integer>();\n\t\t\n\t\t\n\t\tLinkedList<XField> assumeReflective = new LinkedList<XField>();\n\t\tfor (XField f : nullOnlyFields) {\n\t\t\tint myMaxCount = 0;\n\t\t\tfor(String s : unknownAnnotation.get(f)) {\n\t\t\t\tInteger value = count.get(s);\n\t\t\t\tif (value != null && myMaxCount < value) myMaxCount = value;\n\t\t\t}\n\t\t\tif (myMaxCount > 0)\n\t\t\t\tmaxCount.put(f, myMaxCount);\n\t\t\tif (myMaxCount > 15)\n\t\t\t\tassumeReflective.add(f);\n\t\t\telse if (nullOnlyFieldNames.getCount(f.getName()) > 8)\n\t\t\t\tassumeReflective.add(f);\n\t\t\telse if (classContainingNullOnlyFields.getCount(f.getClassDescriptor()) > 4)\n\t\t\t\tassumeReflective.add(f);\n\t\t\telse if (classContainingNullOnlyFields.getCount(f.getClassDescriptor()) > 2 && f.getName().length() == 1)\n\t\t\t\tassumeReflective.add(f);\n\t\t\t\t\n\t\t}\n\t\t\t\t\n\t\treadOnlyFields.removeAll(assumeReflective);\n\t\tnullOnlyFields.removeAll(assumeReflective);\n\t\tnotInitializedInConstructors.removeAll(assumeReflective);\n\t\t\n\t\tfor (XField f : notInitializedInConstructors) {\n\t\t\tString fieldName = f.getName();\n\t\t\tString className = f.getClassName();\n\t\t\tString fieldSignature = f.getSignature();\n\t\t\tif (f.isResolved()\n\t\t\t\t\t&& !fieldsOfNativeClasses.contains(f)\n\t\t\t\t\t&& (fieldSignature.charAt(0) == 'L' || fieldSignature.charAt(0) == '[')\n\t\t\t\t\t) {\n\t\t\t\tint priority = LOW_PRIORITY;\n\t\t\t\tif (assumedNonNull.containsKey(f)) \n\t\t\t\t  bugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",\n\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClass(className)\n\t\t\t\t\t\t.addField(f));\n\t\t\t}\n\t\t}\n\n\n\t\tfor (XField f : readOnlyFields) {\n\t\t\tString fieldName = f.getName();\n\t\t\tString className = f.getClassName();\n\t\t\tString fieldSignature = f.getSignature();\n\t\t\tif (f.isResolved()\n\t\t\t\t\t&& !fieldsOfNativeClasses.contains(f)) {\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\tif (!(fieldSignature.charAt(0) == 'L' || fieldSignature.charAt(0) == '['))\n\t\t\t\t\tpriority++;\n\t\t\t\tif (maxCount.containsKey(f)) priority++;\n\t\t\t\tbugReporter.reportBug(addClassFieldAndAccess(new BugInstance(this,\n\t\t\t\t\t\t\"UWF_UNWRITTEN_FIELD\",\n\t\t\t\t\t\tpriority),f));\n\t\t\t}\n\n\t\t}\n\t\tfor (XField f : nullOnlyFields) {\n\t\t\tString fieldName = f.getName();\n\t\t\tString className = f.getClassName();\n\t\t\tString fieldSignature = f.getSignature();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Null only: \" + f);\n\t\t\t\tSystem.out.println(\"   : \" + assumedNonNull.containsKey(f));\n\t\t\t\tSystem.out.println(\"   : \" + fieldsOfSerializableOrNativeClassed.contains(f));\n\t\t\t\tSystem.out.println(\"   : \" + fieldNamesSet.contains(f.getName()));\n\t\t\t\tSystem.out.println(\"   : \" + abstractClasses.contains(f.getClassName()));\n\t\t\t\tSystem.out.println(\"   : \" + hasNonAbstractSubClass.contains(f.getClassName()));\n\t\t\t\tSystem.out.println(\"   : \" + f.isResolved());\n\t\t\t}\n\t\t\tif (!f.isResolved()) continue;\n\t\t\tif (fieldsOfNativeClasses.contains(f)) continue;\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Ready to report\");\n\t\t\t}\n\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\tif (maxCount.containsKey(f)) priority++;\n\t\t\tif (abstractClasses.contains(f.getClassName())) {\n\t\t\t\tpriority++;\n\t\t\t\tif (! hasNonAbstractSubClass.contains(f.getClassName())) priority++;\n\t\t\t}\n\t\t\t// if (fieldNamesSet.contains(f.getName())) priority++;\n\t\t\tif (assumedNonNull.containsKey(f)) {\n\t\t\t\tint npPriority = priority;\n\t\t\t\n\t\t\t\tHashSet<ProgramPoint> assumedNonNullAt = assumedNonNull.get(f);\n\t\t\t\tif (assumedNonNullAt.size() > 14) {\n\t\t\t\t\tnpPriority+=2;\n\t\t\t\t} else if (assumedNonNullAt.size() > 6) {\n\t\t\t\t\tnpPriority++;\n\t\t\t\t} else {\n\t\t\t\t\tpriority--;\n\t\t\t\t}\n\t\t\t\tfor (ProgramPoint p : assumedNonNullAt)\n\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\t\"NP_UNWRITTEN_FIELD\",\n\t\t\t\t\t\t\tnpPriority)\n\t\t\t\t\t\t\t.addClassAndMethod(p.method)\n\t\t\t\t\t\t\t.addField(f), \n\t\t\t\t\t\tp.sourceLine);\n\t\t\t\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif (f.isStatic()) priority++;\n\t\t\t\tif (f.isFinal()) priority++;\n\t\t\t\tif (fieldsOfSerializableOrNativeClassed.contains(f)) priority++;\n\t\t\t}\n\t\t\tif (!readOnlyFields.contains(f)) \n\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\taddClassFieldAndAccess(new BugInstance(this,\"UWF_NULL_FIELD\",priority), f).lowerPriorityIfDeprecated()\n\t\t\t\t\t);\n\t\t}\n\n\t\tfor (XField f : writeOnlyFields) {\n\t\t\tString fieldName = f.getName();\n\t\t\tString className = f.getClassName();\n\t\t\tint lastDollar =\n\t\t\t\t\tMath.max(className.lastIndexOf('$'),\n\t\t\t\t\t\t\tclassName.lastIndexOf('+'));\n\t\t\tboolean isAnonymousInnerClass =\n\t\t\t\t\t(lastDollar > 0)\n\t\t\t\t\t\t\t&& (lastDollar < className.length() - 1)\n\t\t\t\t\t\t\t&& Character.isDigit(className.charAt(lastDollar+1));\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Checking write only field \" + className\n\t\t\t\t\t\t+ \".\" + fieldName\n\t\t\t\t\t\t+ \"\\t\" + constantFields.contains(f)\n\t\t\t\t\t\t+ \"\\t\" + f.isStatic()\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!f.isResolved()) continue;\n\t\t\tif (dontComplainAbout.matcher(fieldName).find()) continue;\n\t\t\tif (lastDollar >= 0 && (fieldName.startsWith(\"this$\")\n\t\t\t\t\t|| fieldName.startsWith(\"this+\"))) {\n\t\t\t\tString outerClassName = className.substring(0, lastDollar);\n\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass outerClass = Repository.lookupClass(outerClassName);\n\t\t\t\t\tif (classHasParameter(outerClass)) continue;\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t\t}\n\t\t\t\tif (!innerClassCannotBeStatic.contains(className)) {\n\t\t\t\t\tboolean easyChange = !needsOuterObjectInConstructor.contains(className);\n\t\t\t\t\tif (easyChange || !isAnonymousInnerClass) {\n\n\t\t\t\t\t\t// easyChange    isAnonymousInnerClass\n\t\t\t\t\t\t// true          false\t\t\tmedium, SIC\n\t\t\t\t\t\t// true          true\t\t\t\tlow, SIC_ANON\n\t\t\t\t\t\t// false         true\t\t\t\tnot reported\n\t\t\t\t\t\t// false         false\t\t\tlow, SIC_THIS\n\t\t\t\t\t\tint priority = LOW_PRIORITY;\n\t\t\t\t\t\tif (easyChange && !isAnonymousInnerClass)\n\t\t\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\n\t\t\t\t\t\tboolean b = withinAnonymousClass.matcher(getDottedClassName()).find();\n\t\t\t\t\t\tString bug = \"SIC_INNER_SHOULD_BE_STATIC\";\n\t\t\t\t\t\tif (isAnonymousInnerClass)\n\t\t\t\t\t\t\tbug = \"SIC_INNER_SHOULD_BE_STATIC_ANON\";\n\t\t\t\t\t\telse if (!easyChange)\n\t\t\t\t\t\t\tbug = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\";\n\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, bug, priority)\n\t\t\t\t\t\t\t\t.addClass(className));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (constantFields.contains(f)) {\n\t\t\t\t\tif (!f.isStatic())\n\t\t\t\t\t\tbugReporter.reportBug(addClassFieldAndAccess(new BugInstance(this,\n\t\t\t\t\t\t\t\t\"SS_SHOULD_BE_STATIC\",\n\t\t\t\t\t\t\t\tNORMAL_PRIORITY), f));\n\t\t\t\t} else if (fieldsOfSerializableOrNativeClassed.contains(f)) {\n\t\t\t\t\t// ignore it\n\t\t\t\t} else if (!writtenFields.contains(f) && f.isResolved())\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"UUF_UNUSED_FIELD\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClass(className)\n\t\t\t\t\t\t\t.addField(f).lowerPriorityIfDeprecated());\n\t\t\t\telse if (f.getName().toLowerCase().indexOf(\"guardian\") < 0) {\n\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\tif (f.isStatic()) priority++;\n\t\t\t\t\tif (f.isFinal()) priority++;\n\t\t\t\t\tbugReporter.reportBug(addClassFieldAndAccess(new BugInstance(this, \"URF_UNREAD_FIELD\", priority),f));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbugAccumulator.reportAccumulatedBugs();\n\t}","id":35803,"modified_method":"@Override\n\t\t public void report() {\n\t\tSet<String> fieldNamesSet = new HashSet<String>();\n\t\tfor(XField f : writtenNonNullFields)\n\t\t\tfieldNamesSet.add(f.getName());\n\t\tif (DEBUG) {\n\t\t\tSystem.out.println(\"read fields:\" );\n\t\t\tfor(XField f : readFields) \n\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t\tif (!containerFields.isEmpty()) {\n\t\t\t\tSystem.out.println(\"ejb3 fields:\" );\n\t\t\t\tfor(XField f : containerFields) \n\t\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t\t}\n\t\t\tif (!reflectiveFields.isEmpty()) {\n\t\t\t\tSystem.out.println(\"reflective fields:\" );\n\t\t\t\tfor(XField f : reflectiveFields) \n\t\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t\t}\n\n\n\t\t\tSystem.out.println(\"written fields:\" );\n\t\t\tfor (XField f : writtenFields) \n\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t\tSystem.out.println(\"written nonnull fields:\" );\n\t\t\tfor (XField f : writtenNonNullFields) \n\t\t\t\tSystem.out.println(\"  \" + f);\n\n\t\t\tSystem.out.println(\"assumed nonnull fields:\" );\n\t\t\tfor (XField f : assumedNonNull.keySet()) \n\t\t\t\tSystem.out.println(\"  \" + f);\n\t\t}\n\t\tSet<XField> declaredFields = new HashSet<XField>();\n\t\tAnalysisContext currentAnalysisContext = AnalysisContext.currentAnalysisContext();\n\t\tXFactory xFactory = AnalysisContext.currentXFactory();\n\t\tfor(XField f : AnalysisContext.currentXFactory().allFields()) {\n\t\t\tClassDescriptor classDescriptor = f.getClassDescriptor();\n\t\t\tif (currentAnalysisContext.isApplicationClass(classDescriptor) && !xFactory.isReflectiveClass(classDescriptor)  && !f.isProtected() && !f.isPublic())\n\t\t\t\tdeclaredFields.add(f);\n\t\t}\n\t\t// Don't report anything about ejb3Fields\n\t\tdeclaredFields.removeAll(containerFields);\n\t\tdeclaredFields.removeAll(reflectiveFields);\n\t\tfor(Iterator<XField> i = declaredFields.iterator(); i.hasNext(); ) {\n\t\t\tXField f = i.next();\n\t\t\tif (f.isSynthetic() && !f.getName().startsWith(\"this$\") || f.getName().startsWith(\"_\"))\n\t\t\t\ti.remove();\n\t\t}\n\n\t\tTreeSet<XField> notInitializedInConstructors =\n\t\t\t\tnew TreeSet<XField>(declaredFields);\n\t\tnotInitializedInConstructors.retainAll(readFields);\n\t\tnotInitializedInConstructors.retainAll(writtenFields);\n\t\tnotInitializedInConstructors.retainAll(assumedNonNull.keySet());\n\t\tnotInitializedInConstructors.removeAll(writtenInConstructorFields);\n\t\tfor(Iterator<XField> i = notInitializedInConstructors.iterator(); i.hasNext(); ) {\n\t\t\tif (i.next().isStatic())\n\t\t\t\ti.remove();\n\t\t}\n\n\t\tTreeSet<XField> readOnlyFields =\n\t\t\t\tnew TreeSet<XField>(declaredFields);\n\t\treadOnlyFields.removeAll(writtenFields);\n\n\t\treadOnlyFields.retainAll(readFields);\n\n\t\tTreeSet<XField> nullOnlyFields =\n\t\t\tnew TreeSet<XField>(declaredFields);\n\t\tnullOnlyFields.removeAll(writtenNonNullFields);\n\n\t\tnullOnlyFields.retainAll(readFields);\n\n\t\tSet<XField> writeOnlyFields = declaredFields;\n\t\twriteOnlyFields.removeAll(readFields);\n\n\t\tMap<String, Integer> count = new HashMap<String, Integer>();\n\t\tBag<String> nullOnlyFieldNames = new Bag<String>();\n\t\tBag<ClassDescriptor> classContainingNullOnlyFields = new Bag<ClassDescriptor>();\n\t\t\n\t\tfor (XField f : nullOnlyFields) {\n\t\t\tnullOnlyFieldNames.add(f.getName());\n\t\t\tclassContainingNullOnlyFields.add(f.getClassDescriptor());\n\t\t\tint increment = 3;\n\t\t\tCollection<ProgramPoint> assumedNonNullAt = assumedNonNull.get(f);\n\t\t\tif (assumedNonNullAt != null)\n\t\t\t\tincrement += assumedNonNullAt.size();\n\t\t\tfor(String s : unknownAnnotation.get(f)) {\n\t\t\t\tInteger value = count.get(s);\n\t\t\t\tif (value == null) \n\t\t\t\t\tcount.put(s,increment);\n\t\t\t\telse count.put(s,value+increment);\n\t\t\t}\t\n\t\t}\n\t\tMap<XField, Integer> maxCount = new HashMap<XField, Integer>();\n\t\t\n\t\t\n\t\tLinkedList<XField> assumeReflective = new LinkedList<XField>();\n\t\tfor (XField f : nullOnlyFields) {\n\t\t\tint myMaxCount = 0;\n\t\t\tfor(String s : unknownAnnotation.get(f)) {\n\t\t\t\tInteger value = count.get(s);\n\t\t\t\tif (value != null && myMaxCount < value) myMaxCount = value;\n\t\t\t}\n\t\t\tif (myMaxCount > 0)\n\t\t\t\tmaxCount.put(f, myMaxCount);\n\t\t\tif (myMaxCount > 15)\n\t\t\t\tassumeReflective.add(f);\n\t\t\telse if (nullOnlyFieldNames.getCount(f.getName()) > 8)\n\t\t\t\tassumeReflective.add(f);\n\t\t\telse if (classContainingNullOnlyFields.getCount(f.getClassDescriptor()) > 4)\n\t\t\t\tassumeReflective.add(f);\n\t\t\telse if (classContainingNullOnlyFields.getCount(f.getClassDescriptor()) > 2 && f.getName().length() == 1)\n\t\t\t\tassumeReflective.add(f);\n\t\t\t\t\n\t\t}\n\t\t\t\t\n\t\treadOnlyFields.removeAll(assumeReflective);\n\t\tnullOnlyFields.removeAll(assumeReflective);\n\t\tnotInitializedInConstructors.removeAll(assumeReflective);\n\t\t\n\t\tfor (XField f : notInitializedInConstructors) {\n\t\t\tString fieldName = f.getName();\n\t\t\tString className = f.getClassName();\n\t\t\tString fieldSignature = f.getSignature();\n\t\t\tif (f.isResolved()\n\t\t\t\t\t&& !fieldsOfNativeClasses.contains(f)\n\t\t\t\t\t&& (fieldSignature.charAt(0) == 'L' || fieldSignature.charAt(0) == '[')\n\t\t\t\t\t) {\n\t\t\t\tint priority = LOW_PRIORITY;\n\t\t\t\tif (assumedNonNull.containsKey(f)) \n\t\t\t\t  bugReporter.reportBug(new BugInstance(this,\n\t\t\t\t\t\t\"UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR\",\n\t\t\t\t\t\tpriority)\n\t\t\t\t\t\t.addClass(className)\n\t\t\t\t\t\t.addField(f));\n\t\t\t}\n\t\t}\n\n\n\t\tfor (XField f : readOnlyFields) {\n\t\t\tString fieldName = f.getName();\n\t\t\tString className = f.getClassName();\n\t\t\tString fieldSignature = f.getSignature();\n\t\t\tif (f.isResolved()\n\t\t\t\t\t&& !fieldsOfNativeClasses.contains(f)) {\n\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\tif (!(fieldSignature.charAt(0) == 'L' || fieldSignature.charAt(0) == '['))\n\t\t\t\t\tpriority++;\n\t\t\t\tif (maxCount.containsKey(f)) priority++;\n\t\t\t\tbugReporter.reportBug(addClassFieldAndAccess(new BugInstance(this,\n\t\t\t\t\t\t\"UWF_UNWRITTEN_FIELD\",\n\t\t\t\t\t\tpriority),f));\n\t\t\t}\n\n\t\t}\n\t\tfor (XField f : nullOnlyFields) {\n\t\t\tString fieldName = f.getName();\n\t\t\tString className = f.getClassName();\n\t\t\tString fieldSignature = f.getSignature();\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Null only: \" + f);\n\t\t\t\tSystem.out.println(\"   : \" + assumedNonNull.containsKey(f));\n\t\t\t\tSystem.out.println(\"   : \" + fieldsOfSerializableOrNativeClassed.contains(f));\n\t\t\t\tSystem.out.println(\"   : \" + fieldNamesSet.contains(f.getName()));\n\t\t\t\tSystem.out.println(\"   : \" + abstractClasses.contains(f.getClassName()));\n\t\t\t\tSystem.out.println(\"   : \" + hasNonAbstractSubClass.contains(f.getClassName()));\n\t\t\t\tSystem.out.println(\"   : \" + f.isResolved());\n\t\t\t}\n\t\t\tif (!f.isResolved()) continue;\n\t\t\tif (fieldsOfNativeClasses.contains(f)) continue;\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Ready to report\");\n\t\t\t}\n\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\tif (maxCount.containsKey(f)) priority++;\n\t\t\tif (abstractClasses.contains(f.getClassName())) {\n\t\t\t\tpriority++;\n\t\t\t\tif (! hasNonAbstractSubClass.contains(f.getClassName())) priority++;\n\t\t\t}\n\t\t\t// if (fieldNamesSet.contains(f.getName())) priority++;\n\t\t\tif (assumedNonNull.containsKey(f)) {\n\t\t\t\tint npPriority = priority;\n\t\t\t\n\t\t\t\tHashSet<ProgramPoint> assumedNonNullAt = assumedNonNull.get(f);\n\t\t\t\tif (assumedNonNullAt.size() > 14) {\n\t\t\t\t\tnpPriority+=2;\n\t\t\t\t} else if (assumedNonNullAt.size() > 6) {\n\t\t\t\t\tnpPriority++;\n\t\t\t\t} else {\n\t\t\t\t\tpriority--;\n\t\t\t\t}\n\t\t\t\tfor (ProgramPoint p : assumedNonNullAt)\n\t\t\t\t\tbugAccumulator.accumulateBug(new BugInstance(this,\n\t\t\t\t\t\t\t\"NP_UNWRITTEN_FIELD\",\n\t\t\t\t\t\t\tnpPriority)\n\t\t\t\t\t\t\t.addClassAndMethod(p.method)\n\t\t\t\t\t\t\t.addField(f), \n\t\t\t\t\t\tp.sourceLine);\n\t\t\t\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif (f.isStatic()) priority++;\n\t\t\t\tif (f.isFinal()) priority++;\n\t\t\t\tif (fieldsOfSerializableOrNativeClassed.contains(f)) priority++;\n\t\t\t}\n\t\t\tif (!readOnlyFields.contains(f)) \n\t\t\t\tbugReporter.reportBug(\n\t\t\t\t\t\taddClassFieldAndAccess(new BugInstance(this,\"UWF_NULL_FIELD\",priority), f).lowerPriorityIfDeprecated()\n\t\t\t\t\t);\n\t\t}\n\n\t\tfor (XField f : writeOnlyFields) {\n\t\t\tString fieldName = f.getName();\n\t\t\tString className = f.getClassName();\n\t\t\tint lastDollar =\n\t\t\t\t\tMath.max(className.lastIndexOf('$'),\n\t\t\t\t\t\t\tclassName.lastIndexOf('+'));\n\t\t\tboolean isAnonymousInnerClass =\n\t\t\t\t\t(lastDollar > 0)\n\t\t\t\t\t\t\t&& (lastDollar < className.length() - 1)\n\t\t\t\t\t\t\t&& Character.isDigit(className.charAt(lastDollar+1));\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"Checking write only field \" + className\n\t\t\t\t\t\t+ \".\" + fieldName\n\t\t\t\t\t\t+ \"\\t\" + constantFields.contains(f)\n\t\t\t\t\t\t+ \"\\t\" + f.isStatic()\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (!f.isResolved()) continue;\n\t\t\tif (dontComplainAbout.matcher(fieldName).find()) continue;\n\t\t\tif (lastDollar >= 0 && (fieldName.startsWith(\"this$\")\n\t\t\t\t\t|| fieldName.startsWith(\"this+\"))) {\n\t\t\t\tString outerClassName = className.substring(0, lastDollar);\n\n\t\t\t\ttry {\n\t\t\t\t\tJavaClass outerClass = Repository.lookupClass(outerClassName);\n\t\t\t\t\tif (classHasParameter(outerClass)) continue;\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t\t}\n\t\t\t\tif (!innerClassCannotBeStatic.contains(className)) {\n\t\t\t\t\tboolean easyChange = !needsOuterObjectInConstructor.contains(className);\n\t\t\t\t\tif (easyChange || !isAnonymousInnerClass) {\n\n\t\t\t\t\t\t// easyChange    isAnonymousInnerClass\n\t\t\t\t\t\t// true          false\t\t\tmedium, SIC\n\t\t\t\t\t\t// true          true\t\t\t\tlow, SIC_ANON\n\t\t\t\t\t\t// false         true\t\t\t\tnot reported\n\t\t\t\t\t\t// false         false\t\t\tlow, SIC_THIS\n\t\t\t\t\t\tint priority = LOW_PRIORITY;\n\t\t\t\t\t\tif (easyChange && !isAnonymousInnerClass)\n\t\t\t\t\t\t\tpriority = NORMAL_PRIORITY;\n\n\t\t\t\t\t\tboolean b = withinAnonymousClass.matcher(getDottedClassName()).find();\n\t\t\t\t\t\tString bug = \"SIC_INNER_SHOULD_BE_STATIC\";\n\t\t\t\t\t\tif (isAnonymousInnerClass)\n\t\t\t\t\t\t\tbug = \"SIC_INNER_SHOULD_BE_STATIC_ANON\";\n\t\t\t\t\t\telse if (!easyChange)\n\t\t\t\t\t\t\tbug = \"SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS\";\n\n\t\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, bug, priority)\n\t\t\t\t\t\t\t\t.addClass(className));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (constantFields.contains(f)) {\n\t\t\t\t\tif (!f.isStatic())\n\t\t\t\t\t\tbugReporter.reportBug(addClassFieldAndAccess(new BugInstance(this,\n\t\t\t\t\t\t\t\t\"SS_SHOULD_BE_STATIC\",\n\t\t\t\t\t\t\t\tNORMAL_PRIORITY), f));\n\t\t\t\t} else if (fieldsOfSerializableOrNativeClassed.contains(f)) {\n\t\t\t\t\t// ignore it\n\t\t\t\t} else if (!writtenFields.contains(f) && f.isResolved())\n\t\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"UUF_UNUSED_FIELD\", NORMAL_PRIORITY)\n\t\t\t\t\t\t\t.addClass(className)\n\t\t\t\t\t\t\t.addField(f).lowerPriorityIfDeprecated());\n\t\t\t\telse if (f.getName().toLowerCase().indexOf(\"guardian\") < 0) {\n\t\t\t\t\tint priority = NORMAL_PRIORITY;\n\t\t\t\t\tif (f.isStatic()) priority++;\n\t\t\t\t\tif (f.isFinal()) priority++;\n\t\t\t\t\tbugReporter.reportBug(addClassFieldAndAccess(new BugInstance(this, \"URF_UNREAD_FIELD\", priority),f));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbugAccumulator.reportAccumulatedBugs();\n\t}","commit_id":"bc578722238ab88a0e06881a8e6b533dff3363cf","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"static void assertCommitSuccessful(Editor editor, PsiFile psiFile) {\n    Document document = editor.getDocument();\n    int docLength = document.getTextLength();\n    int psiLength = psiFile.getTextLength();\n    PsiDocumentManager manager = PsiDocumentManager.getInstance(psiFile.getProject());\n    boolean committed = !manager.isUncommited(document);\n    if (docLength == psiLength && committed) {\n      return;\n    }\n\n    String message = \"unsuccessful commit:\";\n    message += \"\\nmatching=\" + (psiFile == manager.getPsiFile(document));\n    message += \"\\ninjectedEditor=\" + (editor instanceof EditorWindow);\n    message += \"\\ninjectedFile=\" + InjectedLanguageManager.getInstance(psiFile.getProject()).isInjectedFragment(psiFile);\n    message += \"\\ncommitted=\" + committed;\n    message += \"\\nfile=\" + psiFile.getName();\n    message += \"\\nfile class=\" + psiFile.getClass();\n    message += \"\\nfile.valid=\" + psiFile.isValid();\n    message += \"\\nlanguage=\" + psiFile.getLanguage();\n    message += \"\\ndoc.length=\" + docLength;\n    message += \"\\npsiFile.length=\" + psiLength;\n    String fileText = psiFile.getText();\n    if (fileText != null) {\n      message += \"\\npsiFile.text.length=\" + fileText.length();\n    }\n    FileASTNode node = psiFile.getNode();\n    if (node != null) {\n      message += \"\\nnode.length=\" + node.getTextLength();\n      String nodeText = node.getText();\n      if (nodeText != null) {\n        message += \"\\nnode.text.length=\" + nodeText.length();\n      }\n    }\n    message += \"\\n\" + DebugUtil.currentStackTrace();\n\n    throw new LogEventException(\"Commit unsuccessful\", message,\n                                       new Attachment(psiFile.getViewProvider().getVirtualFile().getPath() + \"_file.txt\", fileText),\n                                       createAstAttachment(psiFile, psiFile),\n                                       new Attachment(\"docText.txt\", document.getText()));\n  }","id":35804,"modified_method":"static void assertCommitSuccessful(Editor editor, PsiFile psiFile) {\n    Document document = editor.getDocument();\n    int docLength = document.getTextLength();\n    int psiLength = psiFile.getTextLength();\n    PsiDocumentManager manager = PsiDocumentManager.getInstance(psiFile.getProject());\n    boolean committed = !manager.isUncommited(document);\n    if (docLength == psiLength && committed) {\n      return;\n    }\n\n    FileViewProvider viewProvider = psiFile.getViewProvider();\n\n    String message = \"unsuccessful commit:\";\n    message += \"\\nmatching=\" + (psiFile == manager.getPsiFile(document));\n    message += \"\\ninjectedEditor=\" + (editor instanceof EditorWindow);\n    message += \"\\ninjectedFile=\" + InjectedLanguageManager.getInstance(psiFile.getProject()).isInjectedFragment(psiFile);\n    message += \"\\ncommitted=\" + committed;\n    message += \"\\nfile=\" + psiFile.getName();\n    message += \"\\nfile class=\" + psiFile.getClass();\n    message += \"\\nfile.valid=\" + psiFile.isValid();\n    message += \"\\nfile.physical=\" + psiFile.isPhysical();\n    message += \"\\nfile.eventSystemEnabled=\" + viewProvider.isEventSystemEnabled();\n    message += \"\\nlanguage=\" + psiFile.getLanguage();\n    message += \"\\ndoc.length=\" + docLength;\n    message += \"\\npsiFile.length=\" + psiLength;\n    String fileText = psiFile.getText();\n    if (fileText != null) {\n      message += \"\\npsiFile.text.length=\" + fileText.length();\n    }\n    FileASTNode node = psiFile.getNode();\n    if (node != null) {\n      message += \"\\nnode.length=\" + node.getTextLength();\n      String nodeText = node.getText();\n      if (nodeText != null) {\n        message += \"\\nnode.text.length=\" + nodeText.length();\n      }\n    }\n    VirtualFile virtualFile = viewProvider.getVirtualFile();\n    message += \"\\nvirtualFile=\" + virtualFile;\n    message += \"\\nvirtualFile.class=\" + virtualFile.getClass();\n    message += \"\\n\" + DebugUtil.currentStackTrace();\n\n    throw new LogEventException(\"Commit unsuccessful\", message,\n                                       new Attachment(virtualFile.getPath() + \"_file.txt\", fileText),\n                                       createAstAttachment(psiFile, psiFile),\n                                       new Attachment(\"docText.txt\", document.getText()));\n  }","commit_id":"66da2af2db877da7321630a3443f6994f50c8dea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public Document getDocument(@NotNull PsiFile file) {\n    if (file instanceof PsiBinaryFile) return null;\n\n    Document document = getCachedDocument(file);\n    if (document != null) {\n      if (!file.getViewProvider().isPhysical() && document.getUserData(HARD_REF_TO_PSI) == null) {\n        cachePsi(document, file);\n      }\n      return document;\n    }\n\n    FileViewProvider viewProvider = file.getViewProvider();\n    if (!viewProvider.isEventSystemEnabled()) return null;\n\n    document = FileDocumentManager.getInstance().getDocument(viewProvider.getVirtualFile());\n    if (document != null) {\n      if (document.getTextLength() != file.getTextLength()) {\n        String message = \"Modified PSI with no document: \" + file + \"; physical=\" + viewProvider.isPhysical();\n        if (document.getTextLength() + file.getTextLength() < 8096) {\n          message += \"\\n=== document ===\\n\" + document.getText() + \"\\n=== PSI ===\\n\" + file.getText();\n        }\n        throw new AssertionError(message);\n      }\n\n      if (!viewProvider.isPhysical()) {\n        cachePsi(document, file);\n      }\n    }\n\n    return document;\n  }","id":35805,"modified_method":"@Nullable\n  @Override\n  public Document getDocument(@NotNull PsiFile file) {\n    if (file instanceof PsiBinaryFile) return null;\n\n    Document document = getCachedDocument(file);\n    if (document != null) {\n      if (!file.getViewProvider().isPhysical() && document.getUserData(HARD_REF_TO_PSI) == null) {\n        cachePsi(document, file);\n      }\n      return document;\n    }\n\n    FileViewProvider viewProvider = file.getViewProvider();\n    if (!viewProvider.isEventSystemEnabled()) return null;\n\n    document = FileDocumentManager.getInstance().getDocument(viewProvider.getVirtualFile());\n    if (document != null) {\n      if (document.getTextLength() != file.getTextLength()) {\n        String message = \"Modified PSI with no document: \" + file + \"; physical=\" + viewProvider.isPhysical();\n        if (document.getTextLength() + file.getTextLength() < 8096) {\n          message += \"\\n=== document ===\\n\" + document.getText() + \"\\n=== PSI ===\\n\" + file.getText();\n        }\n        throw new AssertionError(message);\n      }\n\n      if (!viewProvider.isPhysical()) {\n        cachePsi(document, file);\n        file.putUserData(HARD_REF_TO_DOCUMENT, document);\n      }\n    }\n\n    return document;\n  }","commit_id":"66da2af2db877da7321630a3443f6994f50c8dea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiFile getPsiFileInEditor(@NotNull final Editor editor, @NotNull final Project project) {\n    final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null) return null;\n\n    final Language language = getLanguageInEditor(editor, project);\n    if (language == null) return file;\n\n    if (language == file.getLanguage()) return file;\n\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    int caretOffset = editor.getCaretModel().getOffset();\n    int mostProbablyCorrectLanguageOffset = caretOffset == selectionModel.getSelectionStart() ||\n                                            caretOffset == selectionModel.getSelectionEnd()\n                                            ? selectionModel.getSelectionStart()\n                                            : caretOffset;\n    return getPsiFileAtOffset(file, mostProbablyCorrectLanguageOffset);\n  }","id":35806,"modified_method":"@Nullable\n  public static PsiFile getPsiFileInEditor(@NotNull final Editor editor, @NotNull final Project project) {\n    final PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n    if (file == null) return null;\n\n    PsiUtilCore.ensureValid(file);\n\n    final Language language = getLanguageInEditor(editor, project);\n    if (language == null) return file;\n\n    if (language == file.getLanguage()) return file;\n\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    int caretOffset = editor.getCaretModel().getOffset();\n    int mostProbablyCorrectLanguageOffset = caretOffset == selectionModel.getSelectionStart() ||\n                                            caretOffset == selectionModel.getSelectionEnd()\n                                            ? selectionModel.getSelectionStart()\n                                            : caretOffset;\n    return getPsiFileAtOffset(file, mostProbablyCorrectLanguageOffset);\n  }","commit_id":"66da2af2db877da7321630a3443f6994f50c8dea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void cleanFileLevelHighlights(@NotNull Project project, final int group, PsiFile psiFile) {\n    if (psiFile == null || !psiFile.getViewProvider().isPhysical()) return;\n    VirtualFile vFile = psiFile.getViewProvider().getVirtualFile();\n    final FileEditorManager manager = FileEditorManager.getInstance(project);\n    for (FileEditor fileEditor : manager.getEditors(vFile)) {\n      final List<HighlightInfo> infos = fileEditor.getUserData(FILE_LEVEL_HIGHLIGHTS);\n      if (infos == null) continue;\n      List<HighlightInfo> infosToRemove = new ArrayList<HighlightInfo>();\n      for (HighlightInfo info : infos) {\n        if (info.getGroup() == group) {\n          manager.removeTopComponent(fileEditor, info.fileLevelComponent);\n          infosToRemove.add(info);\n        }\n      }\n      infos.removeAll(infosToRemove);\n    }\n  }","id":35807,"modified_method":"@Override\n  public void cleanFileLevelHighlights(@NotNull Project project, final int group, PsiFile psiFile) {\n    if (psiFile == null) return;\n    FileViewProvider provider = psiFile.getViewProvider();\n    if (!provider.isPhysical() && !(provider.getVirtualFile().getFileSystem() instanceof NonPhysicalFileSystem)) return;\n    VirtualFile vFile = provider.getVirtualFile();\n    final FileEditorManager manager = FileEditorManager.getInstance(project);\n    for (FileEditor fileEditor : manager.getEditors(vFile)) {\n      final List<HighlightInfo> infos = fileEditor.getUserData(FILE_LEVEL_HIGHLIGHTS);\n      if (infos == null) continue;\n      List<HighlightInfo> infosToRemove = new ArrayList<HighlightInfo>();\n      for (HighlightInfo info : infos) {\n        if (info.getGroup() == group) {\n          manager.removeTopComponent(fileEditor, info.fileLevelComponent);\n          infosToRemove.add(info);\n        }\n      }\n      infos.removeAll(infosToRemove);\n    }\n  }","commit_id":"5e6fe63aef1ca4e21c2b242132890ea5c7c8193f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void setHighlightersOutsideRange(@NotNull final Project project,\n                                          @NotNull final Document document,\n                                          @NotNull final PsiFile psiFile,\n                                          @NotNull final List<HighlightInfo> infos,\n                                          @Nullable final EditorColorsScheme colorsScheme,\n                                          // if null global scheme will be used\n                                          final int startOffset,\n                                          final int endOffset,\n                                          @NotNull final ProperTextRange priorityRange,\n                                          final int group) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final DaemonCodeAnalyzerEx codeAnalyzer = DaemonCodeAnalyzerEx.getInstanceEx(project);\n    codeAnalyzer.cleanFileLevelHighlights(project, group, psiFile);\n\n    final MarkupModel markup = DocumentMarkupModel.forDocument(document, project, true);\n    assertMarkupConsistent(markup, project);\n\n    final SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(project);\n    final HighlightersRecycler infosToRemove = new HighlightersRecycler();\n    ContainerUtil.quickSort(infos, BY_START_OFFSET_NODUPS);\n\n    Processor<HighlightInfo> processor = new Processor<HighlightInfo>() {\n      @Override\n      public boolean process(HighlightInfo info) {\n        if (info.getGroup() == group) {\n          RangeHighlighter highlighter = info.highlighter;\n          int hiStart = highlighter.getStartOffset();\n          int hiEnd = highlighter.getEndOffset();\n          if (!info.isFromInjection() && hiEnd < document.getTextLength() && (hiEnd <= startOffset || hiStart >= endOffset)) {\n            return true; // injections are oblivious to restricting range\n          }\n          boolean toRemove = !(hiEnd == document.getTextLength() &&\n                               priorityRange.getEndOffset() == document.getTextLength()) &&\n                             !priorityRange.containsRange(hiStart, hiEnd);\n          if (toRemove) {\n            infosToRemove.recycleHighlighter(highlighter);\n            info.highlighter = null;\n          }\n        }\n        return true;\n      }\n    };\n    DaemonCodeAnalyzerEx.processHighlightsOverlappingOutside(document, project, null, priorityRange.getStartOffset(), priorityRange.getEndOffset(), processor);\n\n    final Map<TextRange, RangeMarker> ranges2markersCache = new THashMap<TextRange, RangeMarker>(10);\n    final boolean[] changed = {false};\n    RangeMarkerTree.sweep(new RangeMarkerTree.Generator<HighlightInfo>(){\n      @Override\n      public boolean generateInStartOffsetOrder(@NotNull Processor<HighlightInfo> processor) {\n        return ContainerUtil.process(infos, processor);\n      }\n    }, new SweepProcessor<HighlightInfo>() {\n      @Override\n      public boolean process(int offset, @NotNull HighlightInfo info, boolean atStart, @NotNull Collection<HighlightInfo> overlappingIntervals) {\n        if (!atStart) return true;\n        if (!info.isFromInjection() && info.getEndOffset() < document.getTextLength() && (info.getEndOffset() <= startOffset || info.getStartOffset()>=endOffset)) return true; // injections are oblivious to restricting range\n\n        if (info.isFileLevelAnnotation() && psiFile.getViewProvider().isPhysical()) {\n          codeAnalyzer.addFileLevelHighlight(project, group, info, psiFile);\n          changed[0] = true;\n          return true;\n        }\n        if (isWarningCoveredByError(info, overlappingIntervals, severityRegistrar)) {\n          return true;\n        }\n        if (info.getStartOffset() < priorityRange.getStartOffset() || info.getEndOffset() > priorityRange.getEndOffset()) {\n          createOrReuseHighlighterFor(info, colorsScheme, document, group, psiFile, (MarkupModelEx)markup, infosToRemove,\n                                        ranges2markersCache, severityRegistrar);\n          changed[0] = true;\n        }\n        return true;\n      }\n    });\n    for (RangeHighlighter highlighter : infosToRemove.forAllInGarbageBin()) {\n      highlighter.dispose();\n      changed[0] = true;\n    }\n\n    if (changed[0]) {\n      clearWhiteSpaceOptimizationFlag(document);\n    }\n    assertMarkupConsistent(markup, project);\n  }","id":35808,"modified_method":"static void setHighlightersOutsideRange(@NotNull final Project project,\n                                          @NotNull final Document document,\n                                          @NotNull final PsiFile psiFile,\n                                          @NotNull final List<HighlightInfo> infos,\n                                          @Nullable final EditorColorsScheme colorsScheme,\n                                          // if null global scheme will be used\n                                          final int startOffset,\n                                          final int endOffset,\n                                          @NotNull final ProperTextRange priorityRange,\n                                          final int group) {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n\n    final DaemonCodeAnalyzerEx codeAnalyzer = DaemonCodeAnalyzerEx.getInstanceEx(project);\n    codeAnalyzer.cleanFileLevelHighlights(project, group, psiFile);\n\n    final MarkupModel markup = DocumentMarkupModel.forDocument(document, project, true);\n    assertMarkupConsistent(markup, project);\n\n    final SeverityRegistrar severityRegistrar = SeverityRegistrar.getSeverityRegistrar(project);\n    final HighlightersRecycler infosToRemove = new HighlightersRecycler();\n    ContainerUtil.quickSort(infos, BY_START_OFFSET_NODUPS);\n\n    Processor<HighlightInfo> processor = new Processor<HighlightInfo>() {\n      @Override\n      public boolean process(HighlightInfo info) {\n        if (info.getGroup() == group) {\n          RangeHighlighter highlighter = info.highlighter;\n          int hiStart = highlighter.getStartOffset();\n          int hiEnd = highlighter.getEndOffset();\n          if (!info.isFromInjection() && hiEnd < document.getTextLength() && (hiEnd <= startOffset || hiStart >= endOffset)) {\n            return true; // injections are oblivious to restricting range\n          }\n          boolean toRemove = !(hiEnd == document.getTextLength() &&\n                               priorityRange.getEndOffset() == document.getTextLength()) &&\n                             !priorityRange.containsRange(hiStart, hiEnd);\n          if (toRemove) {\n            infosToRemove.recycleHighlighter(highlighter);\n            info.highlighter = null;\n          }\n        }\n        return true;\n      }\n    };\n    DaemonCodeAnalyzerEx.processHighlightsOverlappingOutside(document, project, null, priorityRange.getStartOffset(), priorityRange.getEndOffset(), processor);\n\n    final Map<TextRange, RangeMarker> ranges2markersCache = new THashMap<TextRange, RangeMarker>(10);\n    final boolean[] changed = {false};\n    RangeMarkerTree.sweep(new RangeMarkerTree.Generator<HighlightInfo>(){\n      @Override\n      public boolean generateInStartOffsetOrder(@NotNull Processor<HighlightInfo> processor) {\n        return ContainerUtil.process(infos, processor);\n      }\n    }, new SweepProcessor<HighlightInfo>() {\n      @Override\n      public boolean process(int offset, @NotNull HighlightInfo info, boolean atStart, @NotNull Collection<HighlightInfo> overlappingIntervals) {\n        if (!atStart) return true;\n        if (!info.isFromInjection() && info.getEndOffset() < document.getTextLength() && (info.getEndOffset() <= startOffset || info.getStartOffset()>=endOffset)) return true; // injections are oblivious to restricting range\n\n        FileViewProvider provider = psiFile.getViewProvider();\n        if (info.isFileLevelAnnotation() && (provider.isPhysical() || provider.getVirtualFile().getFileSystem() instanceof NonPhysicalFileSystem)) {\n          codeAnalyzer.addFileLevelHighlight(project, group, info, psiFile);\n          changed[0] = true;\n          return true;\n        }\n        if (isWarningCoveredByError(info, overlappingIntervals, severityRegistrar)) {\n          return true;\n        }\n        if (info.getStartOffset() < priorityRange.getStartOffset() || info.getEndOffset() > priorityRange.getEndOffset()) {\n          createOrReuseHighlighterFor(info, colorsScheme, document, group, psiFile, (MarkupModelEx)markup, infosToRemove,\n                                        ranges2markersCache, severityRegistrar);\n          changed[0] = true;\n        }\n        return true;\n      }\n    });\n    for (RangeHighlighter highlighter : infosToRemove.forAllInGarbageBin()) {\n      highlighter.dispose();\n      changed[0] = true;\n    }\n\n    if (changed[0]) {\n      clearWhiteSpaceOptimizationFlag(document);\n    }\n    assertMarkupConsistent(markup, project);\n  }","commit_id":"5e6fe63aef1ca4e21c2b242132890ea5c7c8193f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public FileType getFileType() {\n\n    return getViewProvider().getVirtualFile().getFileType();\n  }","id":35809,"modified_method":"@NotNull\n  @Override\n  public FileType getFileType() {\n    return getViewProvider().getFileType();\n  }","commit_id":"22228ed1b07eeefca675a127f44149e162ffe111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static synchronized void doValidation(final XmlDocument document, final Validator.ValidationHost host) {\n    final PsiFile containingFile = document.getContainingFile();\n    if (containingFile == null) {\n      return;\n    }\n\n    if (containingFile.getViewProvider() instanceof TemplateLanguageFileViewProvider) {\n      return;\n    }\n\n    final FileType fileType = containingFile.getViewProvider().getVirtualFile().getFileType();\n    if (fileType != XmlFileType.INSTANCE && fileType != XHtmlFileType.INSTANCE) {\n      return;\n    }\n\n    for(Language lang: containingFile.getViewProvider().getLanguages()) {\n      if (\"ANT\".equals(lang.getID())) return;\n    }\n\n    final XmlTag rootTag = document.getRootTag();\n    if (rootTag == null) return;\n\n    String namespace = rootTag.getNamespace();\n    if (XmlUtil.ANT_URI.equals(namespace)) return;\n\n    final Project project = document.getProject();\n\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final InspectionToolWrapper toolWrapper =\n      profile.getInspectionTool(INSPECTION_SHORT_NAME, containingFile);\n\n    if (toolWrapper == null) return;\n    if (!profile.isToolEnabled(HighlightDisplayKey.find(INSPECTION_SHORT_NAME), containingFile)) return;\n\n    SoftReference<ExternalDocumentValidator> validatorReference = project.getUserData(validatorInstanceKey);\n    ExternalDocumentValidator validator = SoftReference.dereference(validatorReference);\n\n    if(validator == null) {\n      validator = new ExternalDocumentValidator();\n      project.putUserData(validatorInstanceKey,new SoftReference<ExternalDocumentValidator>(validator));\n    }\n\n    validator.runJaxpValidation(document,host);\n  }","id":35810,"modified_method":"public static synchronized void doValidation(final XmlDocument document, final Validator.ValidationHost host) {\n    final PsiFile containingFile = document.getContainingFile();\n    if (containingFile == null) {\n      return;\n    }\n\n    if (containingFile.getViewProvider() instanceof TemplateLanguageFileViewProvider) {\n      return;\n    }\n\n    final FileType fileType = containingFile.getViewProvider().getFileType();\n    if (fileType != XmlFileType.INSTANCE && fileType != XHtmlFileType.INSTANCE) {\n      return;\n    }\n\n    for(Language lang: containingFile.getViewProvider().getLanguages()) {\n      if (\"ANT\".equals(lang.getID())) return;\n    }\n\n    final XmlTag rootTag = document.getRootTag();\n    if (rootTag == null) return;\n\n    String namespace = rootTag.getNamespace();\n    if (XmlUtil.ANT_URI.equals(namespace)) return;\n\n    final Project project = document.getProject();\n\n    final InspectionProfile profile = InspectionProjectProfileManager.getInstance(project).getInspectionProfile();\n    final InspectionToolWrapper toolWrapper =\n      profile.getInspectionTool(INSPECTION_SHORT_NAME, containingFile);\n\n    if (toolWrapper == null) return;\n    if (!profile.isToolEnabled(HighlightDisplayKey.find(INSPECTION_SHORT_NAME), containingFile)) return;\n\n    SoftReference<ExternalDocumentValidator> validatorReference = project.getUserData(validatorInstanceKey);\n    ExternalDocumentValidator validator = SoftReference.dereference(validatorReference);\n\n    if(validator == null) {\n      validator = new ExternalDocumentValidator();\n      project.putUserData(validatorInstanceKey,new SoftReference<ExternalDocumentValidator>(validator));\n    }\n\n    validator.runJaxpValidation(document,host);\n  }","commit_id":"22228ed1b07eeefca675a127f44149e162ffe111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public StructureViewBuilder createStructureViewBuilder(@NotNull final XmlFile file) {\n    if (file.getViewProvider().getVirtualFile().getFileType() != HtmlFileType.INSTANCE) return null;\n\n    return new TreeBasedStructureViewBuilder() {\n      @Override\n      public boolean isRootNodeShown() {\n        return false;\n      }\n\n      @Override\n      @NotNull\n      public StructureViewModel createStructureViewModel(@Nullable Editor editor) {\n        return new HtmlStructureViewTreeModel(file, editor);\n      }\n    };\n  }","id":35811,"modified_method":"@Override\n  @Nullable\n  public StructureViewBuilder createStructureViewBuilder(@NotNull final XmlFile file) {\n    if (file.getViewProvider().getFileType() != HtmlFileType.INSTANCE) return null;\n\n    return new TreeBasedStructureViewBuilder() {\n      @Override\n      public boolean isRootNodeShown() {\n        return false;\n      }\n\n      @Override\n      @NotNull\n      public StructureViewModel createStructureViewModel(@Nullable Editor editor) {\n        return new HtmlStructureViewTreeModel(file, editor);\n      }\n    };\n  }","commit_id":"22228ed1b07eeefca675a127f44149e162ffe111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public final boolean canPutAt(@NotNull final VirtualFile file, final int line, @NotNull Project project) {\n    final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    // JSPX supports jvm debugging, but not in XHTML files\n    if (psiFile == null || psiFile.getVirtualFile().getFileType() == StdFileTypes.XHTML) {\n      return false;\n    }\n\n    if (!StdFileTypes.CLASS.equals(psiFile.getFileType()) && !DebuggerUtils.isBreakpointAware(psiFile)) {\n      return false;\n    }\n\n    final Document document = FileDocumentManager.getInstance().getDocument(file);\n    if (document == null) return false;\n    final Ref<Class<? extends JavaLineBreakpointTypeBase>> result = Ref.create();\n    XDebuggerUtil.getInstance().iterateLine(project, document, line, new Processor<PsiElement>() {\n      @Override\n      public boolean process(PsiElement element) {\n        // avoid comments\n        if ((element instanceof PsiWhiteSpace)\n            || (PsiTreeUtil.getParentOfType(element, PsiComment.class, PsiImportStatementBase.class, PsiPackageStatement.class) != null)) {\n          return true;\n        }\n        PsiElement parent = element;\n        while(element != null) {\n          // skip modifiers\n          if (element instanceof PsiModifierList) {\n            element = element.getParent();\n            continue;\n          }\n\n          final int offset = element.getTextOffset();\n          if (offset >= 0) {\n            if (document.getLineNumber(offset) != line) {\n              break;\n            }\n          }\n          parent = element;\n          element = element.getParent();\n        }\n\n        if(parent instanceof PsiMethod) {\n          if (parent.getTextRange().getEndOffset() >= document.getLineEndOffset(line)) {\n            PsiCodeBlock body = ((PsiMethod)parent).getBody();\n            if (body != null) {\n              PsiStatement[] statements = body.getStatements();\n              if (statements.length > 0 && document.getLineNumber(statements[0].getTextOffset()) == line) {\n                result.set(JavaLineBreakpointType.class);\n              }\n            }\n          }\n          if (result.isNull()) {\n            result.set(JavaMethodBreakpointType.class);\n          }\n        }\n        else if (parent instanceof PsiField) {\n          if (result.isNull()) {\n            result.set(JavaFieldBreakpointType.class);\n          }\n        }\n        else {\n          result.set(JavaLineBreakpointType.class);\n        }\n        return true;\n      }\n    });\n    return result.get() == getClass();\n  }","id":35812,"modified_method":"@Override\n  public final boolean canPutAt(@NotNull final VirtualFile file, final int line, @NotNull Project project) {\n    final PsiFile psiFile = PsiManager.getInstance(project).findFile(file);\n    // JSPX supports jvm debugging, but not in XHTML files\n    if (psiFile == null || psiFile.getViewProvider().getFileType() == StdFileTypes.XHTML) {\n      return false;\n    }\n\n    if (!StdFileTypes.CLASS.equals(psiFile.getFileType()) && !DebuggerUtils.isBreakpointAware(psiFile)) {\n      return false;\n    }\n\n    final Document document = FileDocumentManager.getInstance().getDocument(file);\n    if (document == null) return false;\n    final Ref<Class<? extends JavaLineBreakpointTypeBase>> result = Ref.create();\n    XDebuggerUtil.getInstance().iterateLine(project, document, line, new Processor<PsiElement>() {\n      @Override\n      public boolean process(PsiElement element) {\n        // avoid comments\n        if ((element instanceof PsiWhiteSpace)\n            || (PsiTreeUtil.getParentOfType(element, PsiComment.class, PsiImportStatementBase.class, PsiPackageStatement.class) != null)) {\n          return true;\n        }\n        PsiElement parent = element;\n        while(element != null) {\n          // skip modifiers\n          if (element instanceof PsiModifierList) {\n            element = element.getParent();\n            continue;\n          }\n\n          final int offset = element.getTextOffset();\n          if (offset >= 0) {\n            if (document.getLineNumber(offset) != line) {\n              break;\n            }\n          }\n          parent = element;\n          element = element.getParent();\n        }\n\n        if(parent instanceof PsiMethod) {\n          if (parent.getTextRange().getEndOffset() >= document.getLineEndOffset(line)) {\n            PsiCodeBlock body = ((PsiMethod)parent).getBody();\n            if (body != null) {\n              PsiStatement[] statements = body.getStatements();\n              if (statements.length > 0 && document.getLineNumber(statements[0].getTextOffset()) == line) {\n                result.set(JavaLineBreakpointType.class);\n              }\n            }\n          }\n          if (result.isNull()) {\n            result.set(JavaMethodBreakpointType.class);\n          }\n        }\n        else if (parent instanceof PsiField) {\n          if (result.isNull()) {\n            result.set(JavaFieldBreakpointType.class);\n          }\n        }\n        else {\n          result.set(JavaLineBreakpointType.class);\n        }\n        return true;\n      }\n    });\n    return result.get() == getClass();\n  }","commit_id":"22228ed1b07eeefca675a127f44149e162ffe111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public FileType getFileType() {\n    return getViewProvider().getVirtualFile().getFileType();\n  }","id":35813,"modified_method":"@NotNull\n  @Override\n  public FileType getFileType() {\n    return getViewProvider().getFileType();\n  }","commit_id":"22228ed1b07eeefca675a127f44149e162ffe111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiBinaryFileImpl(PsiManagerImpl manager, FileViewProvider viewProvider) {\n    myViewProvider = viewProvider;\n    myManager = manager;\n    final VirtualFile virtualFile = myViewProvider.getVirtualFile();\n    myModificationStamp = virtualFile.getModificationStamp();\n    myFileType = viewProvider.getVirtualFile().getFileType();\n  }","id":35814,"modified_method":"public PsiBinaryFileImpl(PsiManagerImpl manager, FileViewProvider viewProvider) {\n    myViewProvider = viewProvider;\n    myManager = manager;\n    final VirtualFile virtualFile = myViewProvider.getVirtualFile();\n    myModificationStamp = virtualFile.getModificationStamp();\n  }","commit_id":"22228ed1b07eeefca675a127f44149e162ffe111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public FileType getFileType() {\n    return myFileType;\n  }","id":35815,"modified_method":"@Override\n  @NotNull\n  public FileType getFileType() {\n    return myViewProvider.getFileType();\n  }","commit_id":"22228ed1b07eeefca675a127f44149e162ffe111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiPlainTextFileImpl(FileViewProvider viewProvider) {\n    super(PlainTextTokenTypes.PLAIN_TEXT_FILE, PlainTextTokenTypes.PLAIN_TEXT_FILE, viewProvider);\n    myFileType = viewProvider.getBaseLanguage() != PlainTextLanguage.INSTANCE ? PlainTextFileType.INSTANCE : viewProvider.getVirtualFile().getFileType();\n  }","id":35816,"modified_method":"public PsiPlainTextFileImpl(FileViewProvider viewProvider) {\n    super(PlainTextTokenTypes.PLAIN_TEXT_FILE, PlainTextTokenTypes.PLAIN_TEXT_FILE, viewProvider);\n    myFileType = viewProvider.getBaseLanguage() != PlainTextLanguage.INSTANCE ? PlainTextFileType.INSTANCE : viewProvider.getFileType();\n  }","commit_id":"22228ed1b07eeefca675a127f44149e162ffe111","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n      public void render(Cell.Context context, Field value, SafeHtmlBuilder sb)\n      {\n         sb.appendEscaped(value.getName() + \": \" + value.getType());\n      }","id":35817,"modified_method":"@Override\n      public void render(Cell.Context context, Field value, SafeHtmlBuilder sb)\n      {\n         SafeHtmlUtil.appendSpan(sb, \n                                 RES.cellTreeStyle().fieldName(), \n                                 value.getName());\n         sb.appendEscaped(value.getType());\n      }","commit_id":"0d42a43c3a0c38b89c312b96571c7693434876e2","url":"https://github.com/rstudio/rstudio"},{"original_method":"private void initPackagesTable()\n   {\n      packagesTable_.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.DISABLED);\n      packagesTable_.setSelectionModel(new NoSelectionModel<PackageInfo>());\n        \n      LoadedColumn loadedColumn = new LoadedColumn();\n      \n      NameColumn nameColumn = new NameColumn();\n    \n      Column<PackageInfo, PackageInfo> descColumn = \n         new Column<PackageInfo, PackageInfo>(new DescriptionCell()) {\n\n            @Override\n            public PackageInfo getValue(PackageInfo object)\n            {\n               return object;\n            } \n      };  \n      \n      Column<PackageInfo, PackageInfo> versionColumn = \n         new Column<PackageInfo, PackageInfo>(new VersionCell()) {\n\n            @Override\n            public PackageInfo getValue(PackageInfo object)\n            {\n               return object;\n            }\n      };\n      \n      ImageButtonColumn<PackageInfo> removeColumn = \n        new ImageButtonColumn<PackageInfo>(\n          AbstractImagePrototype.create(ThemeResources.INSTANCE.removePackage()),\n          new OperationWithInput<PackageInfo>() {\n            @Override\n            public void execute(PackageInfo packageInfo)\n            {\n               observer_.removePackage(packageInfo);          \n            }  \n          },\n          \"Remove package\");\n\n      // add common columns\n      packagesTable_.addColumn(loadedColumn, new TextHeader(\"\"));\n      packagesTable_.addColumn(nameColumn, new TextHeader(\"Name\"));\n      packagesTable_.addColumn(descColumn, new TextHeader(\"Description\"));\n      packagesTable_.addColumn(versionColumn, new TextHeader(\"Version\"));\n      packagesTable_.setColumnWidth(loadedColumn, 30, Unit.PX);\n\n      // set up Packrat-specific columns\n      if (packratContext_ != null &&\n          packratContext_.isModeOn())\n      {\n         TextColumn<PackageInfo> packratVersionColumn = \n               new TextColumn<PackageInfo>() {\n                  @Override\n                  public String getValue(PackageInfo pkgInfo)\n                  {\n                     if (pkgInfo.getInPackratLibary())\n                        return pkgInfo.getPackratVersion();\n                     else\n                        return \"\";\n                  }\n         };\n         TextColumn<PackageInfo> packratSourceColumn = \n               new TextColumn<PackageInfo>() {\n                  @Override\n                  public String getValue(PackageInfo pkgInfo)\n                  {\n                     if (pkgInfo.getInPackratLibary())\n                     {\n                        String source = pkgInfo.getPackratSource();\n                        if (source.equals(\"github\"))\n                           return \"GitHub\";\n                        else if (source.equals(\"Bioconductor\"))\n                           return \"BioC\";\n                        else\n                           return source;\n                     }\n                     else\n                        return \"\";\n                  }\n         };\n\n         packagesTable_.addColumn(packratVersionColumn, new TextHeader(\"Packrat\"));\n         packagesTable_.addColumn(packratSourceColumn, new TextHeader(\"Source\"));\n\n         // distribute columns for extended package information\n         packagesTable_.setColumnWidth(nameColumn, 15, Unit.PCT);\n         packagesTable_.setColumnWidth(descColumn, 45, Unit.PCT);\n         packagesTable_.setColumnWidth(versionColumn, 15, Unit.PCT);\n         packagesTable_.setColumnWidth(packratVersionColumn, 15, Unit.PCT);\n         packagesTable_.setColumnWidth(packratSourceColumn, 10, Unit.PCT);\n         \n         // highlight rows that are out of sync in packrat\n         packagesTable_.setRowStyles(new PackageRowStyles());\n      }\n      else\n      {\n         // distribute columns for non-extended package information\n         packagesTable_.setColumnWidth(nameColumn, 25, Unit.PCT);\n         packagesTable_.setColumnWidth(descColumn, 60, Unit.PCT);\n         packagesTable_.setColumnWidth(versionColumn, 15, Unit.PCT);\n      }\n     \n      // remove column is common\n      packagesTable_.addColumn(removeColumn, new TextHeader(\"\"));\n      packagesTable_.setColumnWidth(removeColumn, 35, Unit.PX);\n\n      packagesTable_.setHeaderBuilder(new \n            PackageHeaderBuilder(packagesTable_, false));\n      packagesTable_.setTableBuilder(new \n            PackageTableBuilder(packagesTable_));\n      packagesTable_.setSkipRowHoverCheck(true);\n      packagesTableContainer_.add(packagesTable_);\n      packagesDataProvider_.addDataDisplay(packagesTable_);\n   }","id":35818,"modified_method":"private void initPackagesTable()\n   {\n      packagesTable_.setKeyboardSelectionPolicy(KeyboardSelectionPolicy.DISABLED);\n      packagesTable_.setSelectionModel(new NoSelectionModel<PackageInfo>());\n        \n      LoadedColumn loadedColumn = new LoadedColumn();\n      \n      NameColumn nameColumn = new NameColumn();\n    \n      Column<PackageInfo, PackageInfo> descColumn = \n         new Column<PackageInfo, PackageInfo>(new DescriptionCell()) {\n\n            @Override\n            public PackageInfo getValue(PackageInfo object)\n            {\n               return object;\n            } \n      };  \n      \n      Column<PackageInfo, PackageInfo> versionColumn = \n         new Column<PackageInfo, PackageInfo>(new VersionCell(false)) {\n\n            @Override\n            public PackageInfo getValue(PackageInfo object)\n            {\n               return object;\n            }\n      };\n      \n      ImageButtonColumn<PackageInfo> removeColumn = \n        new ImageButtonColumn<PackageInfo>(\n          AbstractImagePrototype.create(ThemeResources.INSTANCE.removePackage()),\n          new OperationWithInput<PackageInfo>() {\n            @Override\n            public void execute(PackageInfo packageInfo)\n            {\n               observer_.removePackage(packageInfo);          \n            }  \n          },\n          \"Remove package\");\n\n      // add common columns\n      packagesTable_.addColumn(loadedColumn, new TextHeader(\"\"));\n      packagesTable_.addColumn(nameColumn, new TextHeader(\"Name\"));\n      packagesTable_.addColumn(descColumn, new TextHeader(\"Description\"));\n      packagesTable_.addColumn(versionColumn, new TextHeader(\"Version\"));\n      packagesTable_.setColumnWidth(loadedColumn, 30, Unit.PX);\n\n      // set up Packrat-specific columns\n      if (packratContext_ != null &&\n          packratContext_.isModeOn())\n      {\n         Column<PackageInfo, PackageInfo> packratVersionColumn = \n            new Column<PackageInfo, PackageInfo>(new VersionCell(true)) {\n\n               @Override\n               public PackageInfo getValue(PackageInfo object)\n               {\n                  return object;\n               }\n         };\n      \n         TextColumn<PackageInfo> packratSourceColumn = \n               new TextColumn<PackageInfo>() {\n                  @Override\n                  public String getValue(PackageInfo pkgInfo)\n                  {\n                     if (pkgInfo.getInPackratLibary())\n                     {\n                        String source = pkgInfo.getPackratSource();\n                        if (source.equals(\"github\"))\n                           return \"GitHub\";\n                        else if (source.equals(\"Bioconductor\"))\n                           return \"BioC\";\n                        else\n                           return source;\n                     }\n                     else\n                        return \"\";\n                  }\n         };\n\n         packagesTable_.addColumn(packratVersionColumn, new TextHeader(\"Packrat\"));\n         packagesTable_.addColumn(packratSourceColumn, new TextHeader(\"Source\"));\n\n         // distribute columns for extended package information\n         packagesTable_.setColumnWidth(nameColumn, 15, Unit.PCT);\n         packagesTable_.setColumnWidth(descColumn, 45, Unit.PCT);\n         packagesTable_.setColumnWidth(versionColumn, 15, Unit.PCT);\n         packagesTable_.setColumnWidth(packratVersionColumn, 15, Unit.PCT);\n         packagesTable_.setColumnWidth(packratSourceColumn, 10, Unit.PCT);\n         \n         // highlight rows that are out of sync in packrat\n         packagesTable_.setRowStyles(new PackageRowStyles());\n      }\n      else\n      {\n         // distribute columns for non-extended package information\n         packagesTable_.setColumnWidth(nameColumn, 25, Unit.PCT);\n         packagesTable_.setColumnWidth(descColumn, 60, Unit.PCT);\n         packagesTable_.setColumnWidth(versionColumn, 15, Unit.PCT);\n      }\n     \n      // remove column is common\n      packagesTable_.addColumn(removeColumn, new TextHeader(\"\"));\n      packagesTable_.setColumnWidth(removeColumn, 35, Unit.PX);\n\n      packagesTable_.setHeaderBuilder(new \n            PackageHeaderBuilder(packagesTable_, false));\n      packagesTable_.setTableBuilder(new \n            PackageTableBuilder(packagesTable_));\n      packagesTable_.setSkipRowHoverCheck(true);\n      packagesTableContainer_.add(packagesTable_);\n      packagesDataProvider_.addDataDisplay(packagesTable_);\n   }","commit_id":"308babd65b4f25c2abd39c60b4393917a730b4d6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n      public void render(Context context, PackageInfo value, SafeHtmlBuilder sb)\n      {\n         sb.appendHtmlConstant(\"<div title=\\\"\");\n         sb.appendEscaped(PackageLibraryUtils.getLibraryDescription(\n               session_, value.getLibrary()) + \" (\" +\n               value.getLibrary() + \")\");\n         sb.appendHtmlConstant(\"\\\"\");\n         sb.appendHtmlConstant(\" class=\\\"\");\n         sb.appendEscaped(ThemeStyles.INSTANCE.adornedText());\n         sb.appendHtmlConstant(\"\\\"\");\n         sb.appendHtmlConstant(\">\");\n         sb.appendEscaped(value.getVersion());\n         sb.appendHtmlConstant(\"<\/div>\"); \n      }","id":35819,"modified_method":"@Override\n      public void render(Context context, PackageInfo value, SafeHtmlBuilder sb)\n      {\n         sb.appendHtmlConstant(\"<div title=\\\"\");\n         if (!packratVersion_)\n            sb.appendEscaped(value.getLibrary());\n         sb.appendHtmlConstant(\"\\\"\");\n         sb.appendHtmlConstant(\" class=\\\"\");\n         sb.appendEscaped(ThemeStyles.INSTANCE.adornedText());\n         sb.appendHtmlConstant(\"\\\"\");\n         sb.appendHtmlConstant(\">\");\n         if (packratVersion_)\n         {\n            sb.appendEscaped(value.getVersion());\n         }\n         else\n         {\n            sb.appendEscaped(value.getPackratVersion());\n         }\n         sb.appendHtmlConstant(\"<\/div>\"); \n      }","commit_id":"308babd65b4f25c2abd39c60b4393917a730b4d6","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n  public ASTNode parseContents(ASTNode chameleon) {\n    final CharTable table = SharedImplUtil.findCharTableByTree(chameleon);\n    final FileElement treeElement = new DummyHolder(((TreeElement)chameleon).getManager(), null, table).getTreeElement();\n    final FileElement fileElement = TreeUtil.getFileElement((TreeElement)chameleon);\n    final PsiFile file = (PsiFile)fileElement.getPsi();\n    PsiFile originalFile = file.getOriginalFile();\n\n    final TemplateLanguageFileViewProvider viewProvider = (TemplateLanguageFileViewProvider)originalFile.getViewProvider();\n\n    final Language language = getTemplateFileLanguage(viewProvider);\n    final CharSequence chars = chameleon.getChars();\n\n    final PsiFile templateFile = createTemplateFile(file, language, chars, viewProvider);\n\n    final FileElement parsed = ((PsiFileImpl)templateFile).calcTreeElement();\n\n    DebugUtil.startPsiModification(\"template language parsing\");\n    try {\n      prepareParsedTemplateFile(parsed);\n      Lexer langLexer = LanguageParserDefinitions.INSTANCE.forLanguage(language).createLexer(file.getProject());\n      final Lexer lexer = new MergingLexerAdapter(\n        new TemplateBlackAndWhiteLexer(createBaseLexer(viewProvider), langLexer, myTemplateElementType, myOuterElementType),\n        TokenSet.create(myTemplateElementType, myOuterElementType));\n      lexer.start(chars);\n      insertOuters(parsed, lexer, table);\n\n      final TreeElement element = parsed.getFirstChildNode();\n      if (element != null) {\n        parsed.rawRemoveAllChildren();\n        treeElement.rawAddChildren(element);\n      }\n    }\n    finally {\n      DebugUtil.finishPsiModification();\n    }\n\n    treeElement.subtreeChanged();\n    TreeElement childNode = treeElement.getFirstChildNode();\n\n    DebugUtil.checkTreeStructure(parsed);\n    DebugUtil.checkTreeStructure(treeElement);\n    DebugUtil.checkTreeStructure(chameleon);\n    if (fileElement != chameleon) {\n      DebugUtil.checkTreeStructure(file.getNode());\n      DebugUtil.checkTreeStructure(originalFile.getNode());\n    }\n\n    return childNode;\n  }","id":35820,"modified_method":"@Override\n  public ASTNode parseContents(ASTNode chameleon) {\n    final CharTable table = SharedImplUtil.findCharTableByTree(chameleon);\n    final FileElement fileElement = TreeUtil.getFileElement((TreeElement)chameleon);\n    final PsiFile file = (PsiFile)fileElement.getPsi();\n    PsiFile originalFile = file.getOriginalFile();\n\n    final TemplateLanguageFileViewProvider viewProvider = (TemplateLanguageFileViewProvider)originalFile.getViewProvider();\n\n    final Language language = getTemplateFileLanguage(viewProvider);\n    final CharSequence chars = chameleon.getChars();\n\n    final PsiFile templateFile = createTemplateFile(file, language, chars, viewProvider);\n\n    final FileElement parsed = ((PsiFileImpl)templateFile).calcTreeElement();\n\n    DebugUtil.startPsiModification(\"template language parsing\");\n    try {\n      prepareParsedTemplateFile(parsed);\n      Lexer langLexer = LanguageParserDefinitions.INSTANCE.forLanguage(language).createLexer(file.getProject());\n      final Lexer lexer = new MergingLexerAdapter(\n        new TemplateBlackAndWhiteLexer(createBaseLexer(viewProvider), langLexer, myTemplateElementType, myOuterElementType),\n        TokenSet.create(myTemplateElementType, myOuterElementType));\n      lexer.start(chars);\n      insertOuters(parsed, lexer, table);\n\n      TreeElement childNode = parsed.getFirstChildNode();\n\n      DebugUtil.checkTreeStructure(parsed);\n      DebugUtil.checkTreeStructure(chameleon);\n      if (fileElement != chameleon) {\n        DebugUtil.checkTreeStructure(file.getNode());\n        DebugUtil.checkTreeStructure(originalFile.getNode());\n      }\n\n      return childNode;\n    }\n    finally {\n      DebugUtil.finishPsiModification();\n    }\n  }","commit_id":"9398533281eabbf93d0c01934ee21fac78d99e10","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void replace(final TreeChangeEvent sourceTreeChange,\n                              final TreeElement oldChild,\n                              final TreeElement newChild) {\n    oldChild.rawReplaceWithList(newChild);\n    final ReplaceChangeInfoImpl change = (ReplaceChangeInfoImpl)ChangeInfoImpl.create(ChangeInfo.REPLACE, newChild);\n    sourceTreeChange.addElementaryChange(newChild, change);\n    change.setReplaced(oldChild);\n  }","id":35821,"modified_method":"private static void replace(final TreeChangeEvent sourceTreeChange,\n                              final TreeElement oldChild,\n                              final TreeElement newChild) {\n    oldChild.rawReplaceWithList(newChild);\n    final ReplaceChangeInfoImpl change = new ReplaceChangeInfoImpl(newChild);\n    sourceTreeChange.addElementaryChange(newChild, change);\n    change.setReplaced(oldChild);\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void replaceAllChildrenToChildrenOf(final ASTNode anotherParent) {\n    TreeUtil.ensureParsed(getFirstChildNode());\n    TreeUtil.ensureParsed(anotherParent.getFirstChildNode());\n    final ASTNode firstChild1 = anotherParent.getFirstChildNode();\n    ChangeUtil.prepareAndRunChangeAction(new ChangeUtil.ChangeAction(){\n      public void makeChange(TreeChangeEvent destinationTreeChange) {\n        destinationTreeChange.addElementaryChange(anotherParent, ChangeInfoImpl.create(ChangeInfo.CONTENTS_CHANGED, anotherParent));\n        ((CompositeElement)anotherParent).rawRemoveAllChildren();\n      }\n    }, (TreeElement)anotherParent);\n\n    if (firstChild1 != null) {\n      ChangeUtil.prepareAndRunChangeAction(new ChangeUtil.ChangeAction(){\n        public void makeChange(TreeChangeEvent destinationTreeChange) {\n          if(getTreeParent() != null){\n            final ChangeInfoImpl changeInfo = ChangeInfoImpl.create(ChangeInfo.CONTENTS_CHANGED, CompositeElement.this);\n            changeInfo.setOldLength(getTextLength());\n            destinationTreeChange.addElementaryChange(CompositeElement.this, changeInfo);\n            rawRemoveAllChildren();\n            rawAddChildren((TreeElement)firstChild1);\n          }\n          else{\n            final TreeElement first = getFirstChildNode();\n            remove(destinationTreeChange, first, null);\n            add(destinationTreeChange, CompositeElement.this, (TreeElement)firstChild1);\n            repairRemovedElement(CompositeElement.this, first);\n          }\n        }\n      }, this);\n    }\n    else {\n      removeAllChildren();\n    }\n  }","id":35822,"modified_method":"public void replaceAllChildrenToChildrenOf(final ASTNode anotherParent) {\n    TreeUtil.ensureParsed(getFirstChildNode());\n    TreeUtil.ensureParsed(anotherParent.getFirstChildNode());\n    final ASTNode firstChild = anotherParent.getFirstChildNode();\n    ChangeUtil.prepareAndRunChangeAction(new ChangeUtil.ChangeAction(){\n      public void makeChange(TreeChangeEvent destinationTreeChange) {\n        destinationTreeChange.addElementaryChange(anotherParent, ChangeInfoImpl.create(ChangeInfo.CONTENTS_CHANGED, anotherParent));\n        ((CompositeElement)anotherParent).rawRemoveAllChildren();\n      }\n    }, (TreeElement)anotherParent);\n\n    if (firstChild != null) {\n      ChangeUtil.prepareAndRunChangeAction(new ChangeUtil.ChangeAction(){\n        public void makeChange(TreeChangeEvent destinationTreeChange) {\n          if(getTreeParent() != null){\n            final ChangeInfoImpl changeInfo = ChangeInfoImpl.create(ChangeInfo.CONTENTS_CHANGED, CompositeElement.this);\n            changeInfo.setOldLength(getTextLength());\n            destinationTreeChange.addElementaryChange(CompositeElement.this, changeInfo);\n            rawRemoveAllChildren();\n            rawAddChildren((TreeElement)firstChild);\n          }\n          else{\n            final TreeElement first = getFirstChildNode();\n            remove(destinationTreeChange, first, null);\n            add(destinationTreeChange, CompositeElement.this, (TreeElement)firstChild);\n            repairRemovedElement(CompositeElement.this, first);\n          }\n        }\n      }, this);\n    }\n    else {\n      removeAllChildren();\n    }\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void rawAddChildren(@NotNull TreeElement first) {\n    final TreeElement last = getLastChildNode();\n    if (last == null){\n      setFirstChildNode(first);\n      first.setTreePrev(null);\n      while(true){\n        final TreeElement treeNext = first.getTreeNext();\n        first.setTreeParent(this);\n        if(treeNext == null) break;\n        first = treeNext;\n      }\n      setLastChildNode(first);\n      first.setTreeParent(this);\n    }\n    else {\n      last.rawInsertAfterMe(first);\n    }\n\n    if (DebugUtil.CHECK) DebugUtil.checkTreeStructure(this);\n  }","id":35823,"modified_method":"public void rawAddChildren(@NotNull TreeElement first) {\n    final TreeElement last = getLastChildNode();\n    if (last == null){\n      setFirstChildNode(first);\n      first.setTreePrev(null);\n      while(true){\n        final TreeElement treeNext = first.getTreeNext();\n        first.setTreeParent(this);\n        if(treeNext == null) break;\n        first = treeNext;\n      }\n      setLastChildNode(first);\n      first.setTreeParent(this);\n    }\n    else {\n      last.rawInsertAfterMe(first);\n    }\n\n    DebugUtil.checkTreeStructure(this);\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"final PsiElement createAndStorePsi() {\n    PsiElement psi = createPsiNoLock();\n    myWrapper = psi;\n    return psi;\n  }","id":35824,"modified_method":"private PsiElement createAndStorePsi() {\n    PsiElement psi = createPsiNoLock();\n    myWrapper = psi;\n    return psi;\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected int textMatches(CharSequence buffer, int start) {\n    synchronized (lock) {\n      if (myText != null) {\n        return LeafElement.leafTextMatches(myText, buffer, start);\n      }\n    }\n    return super.textMatches(buffer, start);\n  }","id":35825,"modified_method":"@Override\n  protected int textMatches(@NotNull CharSequence buffer, int start) {\n    CharSequence text = myText();\n    if (text != null) {\n      return LeafElement.leafTextMatches(text, buffer, start);\n    }\n    return super.textMatches(buffer, start);\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CharSequence getChars() {\n    synchronized (lock) {\n      if (myText != null) {\n        return myText;\n      }\n    }\n    return getText();\n  }","id":35826,"modified_method":"@NotNull\n  public CharSequence getChars() {\n    CharSequence text = myText();\n    if (text != null) {\n      return text;\n    }\n    return super.getText();\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setFirstChildNode(TreeElement child) {\n    if (myText != null) {\n      LOG.error(\"Mutating collapsed chameleon\");\n    }\n    super.setFirstChildNode(child);\n  }","id":35827,"modified_method":"@Override\n  public void setFirstChildNode(TreeElement child) {\n    if (myText() != null) {\n      LOG.error(\"Mutating collapsed chameleon\");\n    }\n    super.setFirstChildNode(child);\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getNotCachedLength() {\n    synchronized (lock) {\n      if (myText != null) {\n        return myText.length();\n      }\n    }\n    return super.getNotCachedLength();\n  }","id":35828,"modified_method":"@Override\n  public int getNotCachedLength() {\n    CharSequence text = myText();\n    if (text != null) {\n      return text.length();\n    }\n    return super.getNotCachedLength();\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int hc() {\n    synchronized (lock) {\n      if (myText != null) {\n        return LeafElement.leafHC(myText);\n      }\n      else {\n        return super.hc();\n      }\n    }\n  }","id":35829,"modified_method":"@Override\n  public int hc() {\n    CharSequence text = myText();\n    return text == null ? super.hc() : LeafElement.leafHC(text);\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void ensureParsed() {\n    if (myText == null) return;\n    if (rawFirstChild() != null) {\n      LOG.error(\"Reentrant parsing?\");\n    }\n\n    if (TreeUtil.getFileElement(this) == null) {\n      LOG.error(\"Chameleons must not be parsed till they're in file tree: \" + this);\n    }\n\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    ILazyParseableElementType type = (ILazyParseableElementType)getElementType();\n    ASTNode parsedNode = type.parseContents(this);\n\n    if (parsedNode == null && myText.length() > 0) {\n      if (ApplicationManagerEx.getApplicationEx().isInternal() && !ApplicationManager.getApplication().isUnitTestMode()) {\n        LOG.error(\"No parse for a non-empty string: \" + myText + \"; type=\" + LogUtil.objectAndClass(type));\n      } else {\n        LOG.error(\"No parse for a non-empty string: type=\" + LogUtil.objectAndClass(type));\n      }\n    }\n\n    //CharSequence text = myText;\n    myText = null;\n\n    if (parsedNode != null) {\n      rawAddChildren((TreeElement)parsedNode);\n\n      //if (getNotCachedLength() != text.length()) {\n      //  if (ApplicationManagerEx.getApplicationEx().isInternal()) {\n      //    LOG.error(\"Inconsistent reparse: type=\" + getElementType() + \"; text=\" + text + \"; treeText=\" + getText());\n      //  } else {\n      //    LOG.error(\"Inconsistent reparse: type=\" + getElementType());\n      //  }\n      //}\n\n      //ensure PSI is created all at once, to reduce contention of PsiLock in CompositeElement.getPsi()\n      ((TreeElement)parsedNode).acceptTree(CREATE_PSI);\n      parsedNode.getTreeNext();\n    }\n  }","id":35830,"modified_method":"private void ensureParsed() {\n    if (myText == null) return;\n    if (rawFirstChild() != null) {\n      LOG.error(\"Reentrant parsing?\");\n    }\n\n    if (TreeUtil.getFileElement(this) == null) {\n      LOG.error(\"Chameleons must not be parsed till they're in file tree: \" + this);\n    }\n\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n\n    ILazyParseableElementType type = (ILazyParseableElementType)getElementType();\n    ASTNode parsedNode = type.parseContents(this);\n\n    if (parsedNode == null && myText.length() > 0) {\n      if (ApplicationManagerEx.getApplicationEx().isInternal() && !ApplicationManager.getApplication().isUnitTestMode()) {\n        LOG.error(\"No parse for a non-empty string: \" + myText + \"; type=\" + LogUtil.objectAndClass(type));\n      } else {\n        LOG.error(\"No parse for a non-empty string: type=\" + LogUtil.objectAndClass(type));\n      }\n    }\n\n    //CharSequence text = myText;\n    myText = null;\n\n    if (parsedNode != null) {\n      rawAddChildren((TreeElement)parsedNode);\n\n      //if (getNotCachedLength() != text.length()) {\n      //  if (ApplicationManagerEx.getApplicationEx().isInternal()) {\n      //    LOG.error(\"Inconsistent reparse: type=\" + getElementType() + \"; text=\" + text + \"; treeText=\" + getText());\n      //  } else {\n      //    LOG.error(\"Inconsistent reparse: type=\" + getElementType());\n      //  }\n      //}\n\n      //ensure PSI is created all at once, to reduce contention of PsiLock in CompositeElement.getPsi()\n      if (parsedNode instanceof CompositeElement) {\n        ((CompositeElement)parsedNode).createAllChildrenPsi();\n      }\n      parsedNode.getTreeNext();\n    }\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setLastChildNode(TreeElement child) {\n    if (myText != null) {\n      LOG.error(\"Mutating collapsed chameleon\");\n    }\n    super.setLastChildNode(child);\n  }","id":35831,"modified_method":"@Override\n  public void setLastChildNode(TreeElement child) {\n    if (myText() != null) {\n      LOG.error(\"Mutating collapsed chameleon\");\n    }\n    super.setLastChildNode(child);\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String getText() {\n    synchronized (lock) {\n      if (myText != null) {\n        return myText.toString();\n      }\n    }\n    return super.getText();\n  }","id":35832,"modified_method":"@NotNull\n  @Override\n  public String getText() {\n    CharSequence text = myText();\n    if (text != null) {\n      return text.toString();\n    }\n    return super.getText();\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int copyTo(char[] buffer, int start) {\n    synchronized (lock) {\n      if (myText == null) return -1;\n      \n      if (buffer != null) {\n        CharArrayUtil.getChars(myText, buffer, start);\n      }\n      return start + myText.length();\n    }\n  }","id":35833,"modified_method":"public int copyTo(char[] buffer, int start) {\n    CharSequence text = myText();\n    if (text == null) return -1;\n\n    if (buffer != null) {\n      CharArrayUtil.getChars(text, buffer, start);\n    }\n    return start + text.length();\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isParsed() {\n    synchronized (lock) {\n      return myText == null;\n    }\n  }","id":35834,"modified_method":"public boolean isParsed() {\n    return myText() == null;\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void rawAddChildren(@NotNull TreeElement first) {\n    if (myText != null) {\n      LOG.error(\"Mutating collapsed chameleon\");\n    }\n    super.rawAddChildren(first);\n  }","id":35835,"modified_method":"@Override\n  public void rawAddChildren(@NotNull TreeElement first) {\n    if (myText() != null) {\n      LOG.error(\"Mutating collapsed chameleon\");\n    }\n    super.rawAddChildren(first);\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getTextLength() {\n    synchronized (lock) {\n      if (myText != null) {\n        return myText.length();\n      }\n    }\n    return super.getTextLength();\n  }","id":35836,"modified_method":"@Override\n  public int getTextLength() {\n    CharSequence text = myText();\n    if (text != null) {\n      return text.length();\n    }\n    return super.getTextLength();\n  }","commit_id":"36d8ee303e55741d29d37ee2053c5c5f14f7233e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#init(com.xpn.xwiki.XWikiContext)\n     */\n    @Override\n    public void init(XWikiContext context)\n    {\n        try {\n            String initialDb = !context.getDatabase().equals(\"\") ? context.getDatabase() : context.getMainXWiki();\n            List<String> wikiServers = Collections.emptyList();\n\n            if (context.getWiki().isVirtualMode()) {\n                try {\n                    wikiServers = context.getWiki().getVirtualWikisDatabaseNames(context);\n                    if (!wikiServers.contains(context.getMainXWiki())) {\n                        wikiServers.add(context.getMainXWiki());\n                    }\n                } catch (Exception e) {\n                    LOG.error(\"error getting list of wiki servers!\", e);\n                }\n            } else {\n                wikiServers = new ArrayList<String>();\n                wikiServers.add(context.getMainXWiki());\n            }\n\n            try {\n                for (String wikiName : wikiServers) {\n                    context.setDatabase(wikiName);\n                    updateSchedulerJobClass(context);\n                }\n            } finally {\n                context.setDatabase(initialDb);\n            }\n\n            // Before we start the thread ensure that Quartz will create daemon threads so that\n            // the JVM can exit properly.\n            System.setProperty(\"org.quartz.scheduler.makeSchedulerThreadDaemon\", \"true\");\n            System.setProperty(\"org.quartz.threadPool.makeThreadsDaemons\", \"true\");\n\n            setScheduler(getDefaultSchedulerInstance());\n            setStatusListener();\n            getScheduler().start();\n\n            try {\n                // Iterate on all virtual wikis\n                for (String wikiName : wikiServers) {\n                    context.setDatabase(wikiName);\n                    restoreExistingJobs(context);\n                }\n            } finally {\n                context.setDatabase(initialDb);\n            }\n        } catch (SchedulerException e) {\n            LOG.error(\"Failed to start the scheduler\", e);\n        } catch (SchedulerPluginException e) {\n            LOG.error(\"Failed to initialize the scheduler\", e);\n        }\n        super.init(context);\n    }","id":35837,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#init(com.xpn.xwiki.XWikiContext)\n     */\n    @Override\n    public void init(XWikiContext context)\n    {\n        try {\n            String initialDb = !context.getDatabase().equals(\"\") ? context.getDatabase() : context.getMainXWiki();\n\n            List<String> wikiServers;\n            if (context.getWiki().isVirtualMode()) {\n                try {\n                    wikiServers = context.getWiki().getVirtualWikisDatabaseNames(context);\n                } catch (Exception e) {\n                    LOG.error(\"error getting list of wiki servers!\", e);\n                    wikiServers = new ArrayList<String>();\n                }\n            } else {\n                wikiServers = new ArrayList<String>();\n            }\n\n            if (!wikiServers.contains(context.getMainXWiki())) {\n                wikiServers.add(context.getMainXWiki());\n            }\n\n            // Init class\n            \n            try {\n                for (String wikiName : new ArrayList<String>(wikiServers)) {\n                    context.setDatabase(wikiName);\n                    try {\n                        updateSchedulerJobClass(context);\n                    } catch (Exception e) {\n                        LOG.error(\"Failed to update scheduler job class for in wiki [\" + wikiName + \"]\", e);\n\n                        // Removing the wiki from the list since it will be impossible start jobs for it\n                        wikiServers.remove(wikiName);\n                    }\n                }\n            } finally {\n                context.setDatabase(initialDb);\n            }\n\n            // Before we start the thread ensure that Quartz will create daemon threads so that\n            // the JVM can exit properly.\n            System.setProperty(\"org.quartz.scheduler.makeSchedulerThreadDaemon\", \"true\");\n            System.setProperty(\"org.quartz.threadPool.makeThreadsDaemons\", \"true\");\n\n            setScheduler(getDefaultSchedulerInstance());\n            setStatusListener();\n            getScheduler().start();\n\n            // Restore jobs\n            \n            try {\n                // Iterate on all virtual wikis\n                for (String wikiName : wikiServers) {\n                    context.setDatabase(wikiName);\n                    restoreExistingJobs(context);\n                }\n            } finally {\n                context.setDatabase(initialDb);\n            }\n        } catch (SchedulerException e) {\n            LOG.error(\"Failed to start the scheduler\", e);\n        } catch (SchedulerPluginException e) {\n            LOG.error(\"Failed to initialize the scheduler\", e);\n        }\n\n        super.init(context);\n    }","commit_id":"6771fc4df9d99bd30259683069747598d1ddb720","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the next fire time for the given job name SchedulerJob\n     *\n     * @param object unwrapped XObject job for which the next fire time will be given\n     * @return the next Date the job will be fired at\n     */\n    public Date getNextFireTime(BaseObject object) throws SchedulerPluginException\n    {\n        return getTrigger(object).getNextFireTime();\n    }","id":35838,"modified_method":"/**\n     * Get the next fire time for the given job name SchedulerJob\n     *\n     * @param object unwrapped XObject job for which the next fire time will be given\n     * @return the next Date the job will be fired at\n     */\n    public Date getNextFireTime(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        return getTrigger(object, context).getNextFireTime();\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Restore the existing job, by looking up for such job in the database and re-scheduling those\n     * according to their stored status. If a Job is stored with the status \"Normal\", it is just\n     * scheduled If a Job is stored with the status \"Paused\", then it is both scheduled and paused\n     * Jobs with other status (None, Complete) are not rescheduled.\n     *\n     * @param context The XWikiContext when initializing the plugin\n     */\n    private void restoreExistingJobs(XWikiContext context) throws SchedulerPluginException\n    {\n        String hql = \", BaseObject as obj where doc.web='Scheduler'\" +\n            \" and obj.name=doc.fullName and obj.className='XWiki.SchedulerJobClass'\";\n        try {\n            List jobsDocsNames = context.getWiki().getStore().searchDocumentsNames(hql, context);\n            for (int i = 0; i < jobsDocsNames.size(); i++) {\n                XWikiDocument jobDoc =\n                    context.getWiki().getDocument((String) jobsDocsNames.get(i), context);\n                BaseObject jobObj = jobDoc.getObject(XWIKI_JOB_CLASS);\n                String jobName = jobObj.getStringValue(\"jobName\");\n                try {\n                    String status = jobObj.getStringValue(\"status\");\n                    if (status.equals(JobState.STATE_NORMAL) ||\n                        status.equals(JobState.STATE_PAUSED))\n                    {\n                        this.scheduleJob(jobObj, context);\n                    }\n                    if (status.equals(JobState.STATE_PAUSED)) {\n                        this.pauseJob(jobObj, context);\n                    }\n                } catch (XWikiException e) {\n                    throw new SchedulerPluginException(\n                        SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESTORE_JOB,\n                        \"Failed to restore job with job name \" + jobName, e);\n                }\n            }\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESTORE_EXISTING_JOBS,\n                \"Failed to restore existing scheduler jobs\", e);\n        }\n    }","id":35839,"modified_method":"/**\n     * Restore the existing job, by looking up for such job in the database and re-scheduling those\n     * according to their stored status. If a Job is stored with the status \"Normal\", it is just\n     * scheduled If a Job is stored with the status \"Paused\", then it is both scheduled and paused\n     * Jobs with other status (None, Complete) are not rescheduled.\n     *\n     * @param context The XWikiContext when initializing the plugin\n     */\n    private void restoreExistingJobs(XWikiContext context) throws SchedulerPluginException\n    {\n        int retval = 0;\n\n        String hql = \", BaseObject as obj where doc.web='Scheduler'\" +\n            \" and obj.name=doc.fullName and obj.className='XWiki.SchedulerJobClass'\";\n        try {\n            List jobsDocsNames = context.getWiki().getStore().searchDocumentsNames(hql, context);\n            for (int i = 0; i < jobsDocsNames.size(); i++) {\n                XWikiDocument jobDoc =\n                    context.getWiki().getDocument((String) jobsDocsNames.get(i), context);\n                BaseObject jobObj = jobDoc.getObject(XWIKI_JOB_CLASS);\n                String jobName = jobObj.getStringValue(\"jobName\");\n                try {\n                    String status = jobObj.getStringValue(\"status\");\n                    if (status.equals(JobState.STATE_NORMAL) ||\n                        status.equals(JobState.STATE_PAUSED))\n                    {\n                        this.scheduleJob(jobObj, context);\n                    }\n                    if (status.equals(JobState.STATE_PAUSED)) {\n                        this.pauseJob(jobObj, context);\n                    }\n                } catch (XWikiException e) {\n                    throw new SchedulerPluginException(\n                        SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESTORE_JOB,\n                        \"Failed to restore job with job name \" + jobName, e);\n                }\n            }\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESTORE_EXISTING_JOBS,\n                \"Failed to restore existing scheduler jobs\", e);\n        }\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Retrieve the job's status of a given {@link com.xpn.xwiki.plugin.scheduler.SchedulerPlugin#XWIKI_JOB_CLASS}\n     * job XObject, by asking the actual job status to the quartz scheduler instance. It's the\n     * actual status, as the one stored in the XObject may be changed manually by users.\n     *\n     * @param object the XObject to give the status of\n     * @return the status of the Job inside the quartz scheduler, as {@link\n     *         com.xpn.xwiki.plugin.scheduler.JobState} instance\n     */\n    public JobState getJobStatus(BaseObject object) throws SchedulerException\n    {\n        int state = getScheduler()\n            .getTriggerState(getObjectUniqueId(object), Scheduler.DEFAULT_GROUP);\n        return new JobState(state);\n    }","id":35840,"modified_method":"/**\n     * Retrieve the job's status of a given {@link com.xpn.xwiki.plugin.scheduler.SchedulerPlugin#XWIKI_JOB_CLASS}\n     * job XObject, by asking the actual job status to the quartz scheduler instance. It's the\n     * actual status, as the one stored in the XObject may be changed manually by users.\n     *\n     * @param object the XObject to give the status of\n     * @return the status of the Job inside the quartz scheduler, as {@link\n     *         com.xpn.xwiki.plugin.scheduler.JobState} instance\n     */\n    public JobState getJobStatus(BaseObject object, XWikiContext context) throws SchedulerException\n    {\n        int state = getScheduler()\n            .getTriggerState(getObjectUniqueId(object, context), Scheduler.DEFAULT_GROUP);\n        return new JobState(state);\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get Trigger object of the given job\n     *\n     * @param object the unwrapped XObject to be retrieve the trigger for\n     * @return the trigger object of the given job\n     */\n    private Trigger getTrigger(BaseObject object) throws SchedulerPluginException\n    {\n        String job = getObjectUniqueId(object);\n        Trigger trigger;\n        try {\n            trigger = getScheduler().getTrigger(job, Scheduler.DEFAULT_GROUP);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while getting trigger for job \" + job, e);\n        }\n        if (trigger == null) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_DOES_NOT_EXITS,\n                \"Job does not exists\");\n        }\n\n        return trigger;\n    }","id":35841,"modified_method":"/**\n     * Get Trigger object of the given job\n     *\n     * @param object the unwrapped XObject to be retrieve the trigger for\n     * @return the trigger object of the given job\n     */\n    private Trigger getTrigger(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        String job = getObjectUniqueId(object, context);\n        Trigger trigger;\n        try {\n            trigger = getScheduler().getTrigger(job, Scheduler.DEFAULT_GROUP);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while getting trigger for job \" + job, e);\n        }\n        if (trigger == null) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_DOES_NOT_EXITS,\n                \"Job does not exists\");\n        }\n\n        return trigger;\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#init(com.xpn.xwiki.XWikiContext)\n     */\n    public void init(XWikiContext context)\n    {\n        super.init(context);\n        try {\n            updateSchedulerJobClass(context);\n            setScheduler(getDefaultSchedulerInstance());\n            setStatusListener();\n            getScheduler().start();\n            restoreExistingJobs(context);\n        } catch (SchedulerException e) {\n            LOG.error(\"Failed to start the scheduler\", e);\n        } catch (SchedulerPluginException e) {\n            LOG.error(\"Failed to initialize the scheduler\", e);\n        }\n    }","id":35842,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#init(com.xpn.xwiki.XWikiContext)\n     */\n    public void init(XWikiContext context)\n    {\n        try {\n            String initialDb =\n                !context.getDatabase().equals(\"\") ? context.getDatabase() : context.getMainXWiki();\n            List wikiServers = Collections.EMPTY_LIST;\n\n            if (context.getWiki().isVirtual()) {\n                try {\n                    wikiServers = context.getWiki().getVirtualWikisDatabaseNames(context);\n                    if (!wikiServers.contains(context.getMainXWiki())) {\n                        wikiServers.add(context.getMainXWiki());\n                    }\n                } catch (Exception e) {\n                    LOG.error(\"error getting list of wiki servers!\", e);\n                }\n            } else {\n                wikiServers = new ArrayList();\n                wikiServers.add(context.getMainXWiki());\n            }\n\n            try {\n                for (Iterator iter = wikiServers.iterator(); iter.hasNext();) {\n                    context.setDatabase((String) iter.next());\n                    updateSchedulerJobClass(context);\n                }\n            } finally {\n                context.setDatabase(initialDb);\n            }\n\n            setScheduler(getDefaultSchedulerInstance());\n            setStatusListener();\n            getScheduler().start();\n\n            try {\n                // Iterate on all virtual wikis\n                for (Iterator iter = wikiServers.iterator(); iter.hasNext();) {\n                    context.setDatabase((String) iter.next());\n                    restoreExistingJobs(context);\n                }\n            } finally {\n                context.setDatabase(initialDb);\n            }\n        } catch (SchedulerException e) {\n            LOG.error(\"Failed to start the scheduler\", e);\n        } catch (SchedulerPluginException e) {\n            LOG.error(\"Failed to initialize the scheduler\", e);\n        }\n        super.init(context);\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see XWikiDefaultPlugin#XWikiDefaultPlugin(String,String,com.xpn.xwiki.XWikiContext)\n     */\n    public SchedulerPlugin(String name, String className, XWikiContext context)\n    {\n        super(name, className, context);\n        init(context);\n    }","id":35843,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @see XWikiDefaultPlugin#XWikiDefaultPlugin(String,String,com.xpn.xwiki.XWikiContext)\n     */\n    public SchedulerPlugin(String name, String className, XWikiContext context)\n    {\n        super(name, className, context);        \n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#virtualInit(com.xpn.xwiki.XWikiContext)\n     */\n    public void virtualInit(XWikiContext context)\n    {\n        super.virtualInit(context);\n        init(context);\n    }","id":35844,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#virtualInit(com.xpn.xwiki.XWikiContext)\n     */\n    public void virtualInit(XWikiContext context)\n    {\n        super.virtualInit(context);\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unschedule the given job\n     *\n     * @param object the unwrapped XObject job to be unscheduled\n     */\n    public void unscheduleJob(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        try {\n            getScheduler().deleteJob(getObjectUniqueId(object), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"None\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while unscheduling job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while saving status of job \" + object.getStringValue(\"jobName\"), e);\n        }\n    }","id":35845,"modified_method":"/**\n     * Unschedule the given job\n     *\n     * @param object the unwrapped XObject job to be unscheduled\n     */\n    public void unscheduleJob(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        try {\n            getScheduler().deleteJob(getObjectUniqueId(object, context), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"None\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while unscheduling job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while saving status of job \" + object.getStringValue(\"jobName\"), e);\n        }\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Pause the job with the given name by pausing all of its current triggers.\n     *\n     * @param object the non-wrapped XObject Job to be paused\n     */\n    public void pauseJob(BaseObject object, XWikiContext context) throws SchedulerPluginException\n    {\n        try {\n            getScheduler().pauseJob(getObjectUniqueId(object), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"Paused\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_PAUSE_JOB,\n                \"Error occured while trying to pause job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_PAUSE_JOB,\n                \"Error occured while trying to save status of job \" +\n                    object.getStringValue(\"jobName\"), e);\n        }\n    }","id":35846,"modified_method":"/**\n     * Pause the job with the given name by pausing all of its current triggers.\n     *\n     * @param object the non-wrapped XObject Job to be paused\n     */\n    public void pauseJob(BaseObject object, XWikiContext context) throws SchedulerPluginException\n    {\n        try {\n            getScheduler().pauseJob(getObjectUniqueId(object, context), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"Paused\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_PAUSE_JOB,\n                \"Error occured while trying to pause job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_PAUSE_JOB,\n                \"Error occured while trying to save status of job \" +\n                    object.getStringValue(\"jobName\"), e);\n        }\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Compute a cross-document unique {@link com.xpn.xwiki.objects.BaseObject} id, by concatenating\n     * its name (it's document holder full name, such as \"SomeSpace.SomeDoc\") and it's instance\n     * number inside this document. <p/> The scheduler uses this unique object id to assure the\n     * unicity of jobs\n     *\n     * @return a unique String that can identify the object\n     */\n    private String getObjectUniqueId(BaseObject object)\n    {\n        return object.getName() + \"_\" + object.getNumber();\n    }","id":35847,"modified_method":"/**\n     * Compute a cross-document unique {@link com.xpn.xwiki.objects.BaseObject} id, by concatenating\n     * its name (it's document holder full name, such as \"SomeSpace.SomeDoc\") and it's instance\n     * number inside this document. <p/> The scheduler uses this unique object id to assure the\n     * unicity of jobs\n     *\n     * @return a unique String that can identify the object\n     */\n    private String getObjectUniqueId(BaseObject object, XWikiContext context)\n    {\n        return context.getDatabase() + \":\" + object.getName() + \"_\" + object.getNumber();\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create and feed a stub context for the job execution thread. Stub context data are retrieved\n     * from job object fields \"contextUser\", \"contextLang\", \"contextDatabase\". If one of this field\n     * is empty (this would typically happen on the first schedule operation), it is instead\n     * retrieved from the passed context, and the job object is updated with this value. This mean\n     * that this method may modify the passed object.\n     *\n     * @param job the job for which the context will be prepared\n     * @param context the XWikiContext at preparation time. This is a real context associated with a\n     * servlet request\n     * @return the stub context prepared with job datas.\n     */\n    private XWikiContext prepareJobStubContext(BaseObject job, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        boolean jobNeedsUpdate = true;\n        String cUser = job.getStringValue(\"contextUser\");\n        if (cUser.equals(\"\")) {\n            // The context user has not been filled yet.\n            // We can suppose it's the first scheduling. Let's assume it's the context user\n            cUser = context.getUser();\n            job.setStringValue(\"contextUser\", cUser);\n            jobNeedsUpdate = true;\n        }\n        String cLang = job.getStringValue(\"contextLang\");\n        if (cLang.equals(\"\")) {\n            cLang = context.getLanguage();\n            job.setStringValue(\"contextLang\", cLang);\n            jobNeedsUpdate = true;\n        }\n        String cDb = job.getStringValue(\"contextDatabase\");\n        if (cDb.equals(\"\")) {\n            cDb = context.getDatabase();\n            job.setStringValue(\"contextDatabase\", cDb);\n            jobNeedsUpdate = true;\n        }\n\n        if (jobNeedsUpdate) {\n            try {\n                XWikiDocument jobHolder = context.getWiki().getDocument(job.getName(), context);\n                BaseObject jObj =\n                    jobHolder.getObject(SchedulerPlugin.XWIKI_JOB_CLASS, job.getNumber());\n                jobHolder.setMinorEdit(true);\n                context.getWiki().saveDocument(jobHolder, context);\n            }\n            catch (XWikiException e) {\n                throw new SchedulerPluginException(\n                    SchedulerPluginException.ERROR_SCHEDULERPLUGIN_UNABLE_TO_PREPARE_JOB_CONTEXT,\n                    \"Failed to prepare context for job with job name \" +\n                        job.getStringValue(\"jobName\"), e);\n            }\n        }\n\n        //lets now build the stub context\n        XWikiContext scontext = new XWikiContext();\n        scontext.setWiki(context.getWiki());\n\n        // We are sure the context request is a real servlet request\n        // So we force the dummy request with the current host\n        XWikiServletRequestStub dummy = new XWikiServletRequestStub();\n        dummy.setHost(context.getRequest().getHeader(\"x-forwarded-host\"));\n        XWikiServletRequest request = new XWikiServletRequest(dummy);\n        scontext.setRequest(request);\n\n        // feed the dummy context\n        scontext.setUser(cUser);\n        scontext.setLanguage(cLang);\n        scontext.setDatabase(cDb);\n        scontext.setMainXWiki(context.getMainXWiki());\n        scontext.setVirtual(context.isVirtual());        \n\n        com.xpn.xwiki.web.XWikiURLFactory xurf = context.getURLFactory();\n        if (xurf == null) {\n            xurf = context.getWiki().getURLFactoryService()\n                .createURLFactory(context.getMode(), context);\n        }\n        scontext.setURLFactory(xurf);\n\n        try {\n            XWikiDocument cDoc = context.getWiki().getDocument(job.getName(), context);\n            scontext.setDoc(cDoc);\n        }\n        catch (Exception e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_UNABLE_TO_PREPARE_JOB_CONTEXT,\n                \"Failed to prepare context for job with job name \" + job.getStringValue(\"jobName\"),\n                e);\n        }\n\n        return scontext;\n    }","id":35848,"modified_method":"/**\n     * Create and feed a stub context for the job execution thread. Stub context data are retrieved\n     * from job object fields \"contextUser\", \"contextLang\", \"contextDatabase\". If one of this field\n     * is empty (this would typically happen on the first schedule operation), it is instead\n     * retrieved from the passed context, and the job object is updated with this value. This mean\n     * that this method may modify the passed object.\n     *\n     * @param job the job for which the context will be prepared\n     * @param context the XWikiContext at preparation time. This is a real context associated with a\n     * servlet request\n     * @return the stub context prepared with job datas.\n     */\n    private XWikiContext prepareJobStubContext(BaseObject job, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        boolean jobNeedsUpdate = true;\n        String cUser = job.getStringValue(\"contextUser\");\n        if (cUser.equals(\"\")) {\n            // The context user has not been filled yet.\n            // We can suppose it's the first scheduling. Let's assume it's the context user\n            cUser = context.getUser();\n            job.setStringValue(\"contextUser\", cUser);\n            jobNeedsUpdate = true;\n        }\n        String cLang = job.getStringValue(\"contextLang\");\n        if (cLang.equals(\"\")) {\n            cLang = context.getLanguage();\n            job.setStringValue(\"contextLang\", cLang);\n            jobNeedsUpdate = true;\n        }\n        String iDb = context.getDatabase();\n        String cDb = job.getStringValue(\"contextDatabase\");\n        if (cDb.equals(\"\") || !cDb.equals(iDb)) {\n            cDb = context.getDatabase();\n            job.setStringValue(\"contextDatabase\", cDb);\n            jobNeedsUpdate = true;\n        }\n\n        if (jobNeedsUpdate) {\n            try {\n                context.setDatabase(cDb);\n                XWikiDocument jobHolder = context.getWiki().getDocument(job.getName(), context);\n                BaseObject jObj =\n                    jobHolder.getObject(SchedulerPlugin.XWIKI_JOB_CLASS, job.getNumber());\n                jobHolder.setMinorEdit(true);\n                context.getWiki().saveDocument(jobHolder, context);\n            }\n            catch (XWikiException e) {\n                throw new SchedulerPluginException(\n                    SchedulerPluginException.ERROR_SCHEDULERPLUGIN_UNABLE_TO_PREPARE_JOB_CONTEXT,\n                    \"Failed to prepare context for job with job name \" +\n                        job.getStringValue(\"jobName\"), e);\n            } finally {\n                context.setDatabase(iDb);\n            }\n        }\n\n        //lets now build the stub context\n        XWikiContext scontext = new XWikiContext();\n        scontext.setWiki(context.getWiki());\n\n        // We are sure the context request is a real servlet request\n        // So we force the dummy request with the current host\n        XWikiServletRequestStub dummy = new XWikiServletRequestStub();\n        dummy.setHost(context.getRequest().getHeader(\"x-forwarded-host\"));\n        XWikiServletRequest request = new XWikiServletRequest(dummy);\n        scontext.setRequest(request);\n\n        // feed the dummy context\n        scontext.setUser(cUser);\n        scontext.setLanguage(cLang);\n        scontext.setDatabase(cDb);\n        scontext.setMainXWiki(context.getMainXWiki());\n        scontext.setVirtual(context.isVirtual());\n\n        com.xpn.xwiki.web.XWikiURLFactory xurf = context.getURLFactory();\n        if (xurf == null) {\n            xurf = context.getWiki().getURLFactoryService()\n                .createURLFactory(context.getMode(), context);\n        }\n        scontext.setURLFactory(xurf);\n\n        try {\n            XWikiDocument cDoc = context.getWiki().getDocument(job.getName(), context);\n            scontext.setDoc(cDoc);\n        }\n        catch (Exception e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_UNABLE_TO_PREPARE_JOB_CONTEXT,\n                \"Failed to prepare context for job with job name \" + job.getStringValue(\"jobName\"),\n                e);\n        }\n\n        return scontext;\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean scheduleJob(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        boolean scheduled = true;\n        try {\n            JobDataMap data = new JobDataMap();\n\n            // compute the job unique Id\n            String xjob = getObjectUniqueId(object);\n\n            JobDetail job = new JobDetail(xjob, Scheduler.DEFAULT_GROUP,\n                Class.forName(object.getStringValue(\"jobClass\")));\n\n            Trigger trigger = new CronTrigger(xjob, Scheduler.DEFAULT_GROUP, xjob,\n                Scheduler.DEFAULT_GROUP, object.getStringValue(\"cron\"));\n\n            // Let's prepare an execution context...\n            XWikiContext stubContext = prepareJobStubContext(object, context);\n            Context stub = new Context(stubContext);\n\n            data.put(\"context\", stub);\n            data.put(\"xwiki\", new com.xpn.xwiki.api.XWiki(context.getWiki(), stubContext));\n            data.put(\"xjob\", object);\n\n            job.setJobDataMap(data);\n\n            getScheduler().addJob(job, true);\n\n            JobState status = getJobStatus(object);\n\n            switch (status.getState()) {\n                case Trigger.STATE_PAUSED:\n                    // a paused job must be resumed, not scheduled\n                    break;\n                case Trigger.STATE_NORMAL:\n                    if (getTrigger(object).compareTo(trigger) != 0) {\n                        LOG.debug(\"Reschedule Job : \" + object.getStringValue(\"jobName\"));\n                    }\n                    getScheduler().rescheduleJob(trigger.getName(), trigger.getGroup(), trigger);\n                    break;\n                case Trigger.STATE_NONE:\n                    LOG.debug(\"Schedule Job : \" + object.getStringValue(\"jobName\"));\n                    getScheduler().scheduleJob(trigger);\n                    LOG.info(\"XWiki Job Status :\" + object.getStringValue(\"status\"));\n                    if (object.getStringValue(\"status\").equals(\"Paused\")) {\n                        getScheduler().pauseJob(xjob, Scheduler.DEFAULT_GROUP);\n                        saveStatus(\"Paused\", object, context);\n                    } else {\n                        saveStatus(\"Normal\", object, context);\n                    }\n                    break;\n                default:\n                    LOG.debug(\"Schedule Job : \" + object.getStringValue(\"jobName\"));\n                    getScheduler().scheduleJob(trigger);\n                    saveStatus(\"Normal\", object, context);\n                    break;\n            }\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_SCHEDULE_JOB,\n                \"Error while scheduling job \" + object.getStringValue(\"jobName\"), e);\n        } catch (ParseException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_BAD_CRON_EXPRESSION,\n                \"Error while parsing cron expression for job \" + object.getStringValue(\"jobName\"),\n                e);\n        } catch (ClassNotFoundException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while loading job class for job : \" + object.getStringValue(\"jobName\"),\n                e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while saving job status for job : \" + object.getStringValue(\"jobName\"),\n                e);\n        }\n        return scheduled;\n    }","id":35849,"modified_method":"public boolean scheduleJob(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        boolean scheduled = true;\n        try {\n            JobDataMap data = new JobDataMap();\n\n// compute the job unique Id\n            String xjob = getObjectUniqueId(object, context);\n\n            JobDetail job = new JobDetail(xjob, Scheduler.DEFAULT_GROUP,\n                Class.forName(object.getStringValue(\"jobClass\")));\n\n            Trigger trigger = new CronTrigger(xjob, Scheduler.DEFAULT_GROUP, xjob,\n                Scheduler.DEFAULT_GROUP, object.getStringValue(\"cron\"));\n\n// Let's prepare an execution context...\n            XWikiContext stubContext = prepareJobStubContext(object, context);\n            Context stub = new Context(stubContext);\n\n            data.put(\"context\", stub);\n            data.put(\"xwiki\", new com.xpn.xwiki.api.XWiki(context.getWiki(), stubContext));\n            data.put(\"xjob\", object);\n\n            job.setJobDataMap(data);\n\n            getScheduler().addJob(job, true);\n\n            JobState status = getJobStatus(object, context);\n\n            switch (status.getState()) {\n                case Trigger.STATE_PAUSED:\n                    // a paused job must be resumed, not scheduled\n                    break;\n                case Trigger.STATE_NORMAL:\n                    if (getTrigger(object, context).compareTo(trigger) != 0) {\n                        LOG.debug(\"Reschedule Job : \" + object.getStringValue(\"jobName\"));\n                    }\n                    getScheduler().rescheduleJob(trigger.getName(), trigger.getGroup(), trigger);\n                    break;\n                case Trigger.STATE_NONE:\n                    LOG.debug(\"Schedule Job : \" + object.getStringValue(\"jobName\"));\n                    getScheduler().scheduleJob(trigger);\n                    LOG.info(\"XWiki Job Status :\" + object.getStringValue(\"status\"));\n                    if (object.getStringValue(\"status\").equals(\"Paused\")) {\n                        getScheduler().pauseJob(xjob, Scheduler.DEFAULT_GROUP);\n                        saveStatus(\"Paused\", object, context);\n                    } else {\n                        saveStatus(\"Normal\", object, context);\n                    }\n                    break;\n                default:\n                    LOG.debug(\"Schedule Job : \" + object.getStringValue(\"jobName\"));\n                    getScheduler().scheduleJob(trigger);\n                    saveStatus(\"Normal\", object, context);\n                    break;\n            }\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_SCHEDULE_JOB,\n                \"Error while scheduling job \" + object.getStringValue(\"jobName\"), e);\n        } catch (ParseException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_BAD_CRON_EXPRESSION,\n                \"Error while parsing cron expression for job \" + object.getStringValue(\"jobName\"),\n                e);\n        } catch (ClassNotFoundException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while loading job class for job : \" + object.getStringValue(\"jobName\"),\n                e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while saving job status for job : \" + object.getStringValue(\"jobName\"),\n                e);\n        }\n        return scheduled;\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Resume the job with the given name (un-pause)\n     *\n     * @param object the non-wrapped XObject Job to be resumed\n     */\n    public void resumeJob(BaseObject object, XWikiContext context) throws SchedulerPluginException\n    {\n        try {\n            getScheduler().resumeJob(getObjectUniqueId(object), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"Normal\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESUME_JOB,\n                \"Error occured while trying to resume job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESUME_JOB,\n                \"Error occured while trying to save status of job \" +\n                    object.getStringValue(\"jobName\"), e);\n        }\n    }","id":35850,"modified_method":"/**\n     * Resume the job with the given name (un-pause)\n     *\n     * @param object the non-wrapped XObject Job to be resumed\n     */\n    public void resumeJob(BaseObject object, XWikiContext context) throws SchedulerPluginException\n    {\n        try {\n            getScheduler().resumeJob(getObjectUniqueId(object, context), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"Normal\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESUME_JOB,\n                \"Error occured while trying to resume job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESUME_JOB,\n                \"Error occured while trying to save status of job \" +\n                    object.getStringValue(\"jobName\"), e);\n        }\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public JobState getJobStatus(Object object) throws SchedulerException, SchedulerPluginException\n    {\n        return plugin.getJobStatus(retrieveBaseObject(object));\n    }","id":35851,"modified_method":"public JobState getJobStatus(Object object) throws SchedulerException, SchedulerPluginException\n    {\n        return plugin.getJobStatus(retrieveBaseObject(object), context);\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Date getNextFireTime(BaseObject object)\n    {\n        try {\n            return plugin.getNextFireTime(object);\n        }\n        catch (SchedulerPluginException e) {\n            context.put(\"error\", e.getMessage());\n            return null;\n        }\n    }","id":35852,"modified_method":"public Date getNextFireTime(BaseObject object)\n    {\n        try {\n            return plugin.getNextFireTime(object, context);\n        }\n        catch (SchedulerPluginException e) {\n            context.put(\"error\", e.getMessage());\n            return null;\n        }\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Return the trigger state as a ${@link JobState}, that holds both the integer trigger's inner\n     * value of the state and a String as a human readable representation of that state\n     */\n    public JobState getJobStatus(BaseObject object)\n        throws SchedulerException, SchedulerPluginException\n    {\n        return plugin.getJobStatus(object);\n    }","id":35853,"modified_method":"/**\n     * Return the trigger state as a ${@link JobState}, that holds both the integer trigger's inner\n     * value of the state and a String as a human readable representation of that state\n     */\n    public JobState getJobStatus(BaseObject object)\n        throws SchedulerException, SchedulerPluginException\n    {\n        return plugin.getJobStatus(object, context);\n    }","commit_id":"326b5ebe1edf591c1306357e49e9408c43c30990","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean scheduleJob(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        boolean scheduled = true;\n        try {\n            JobDataMap data = new JobDataMap();\n\n            // compute the job unique Id\n            String xjob = getObjectUniqueId(object);\n\n            JobDetail job = new JobDetail(xjob, Scheduler.DEFAULT_GROUP,\n                Class.forName(object.getStringValue(\"jobClass\")));\n\n            Trigger trigger = new CronTrigger(xjob, Scheduler.DEFAULT_GROUP, xjob,\n                Scheduler.DEFAULT_GROUP, object.getStringValue(\"cron\"));\n\n            // Let's prepare an execution context...\n            XWikiContext stubContext = prepareJobStubContext(object, context);\n            Context stub = new Context(stubContext);\n\n            data.put(\"context\", stub);\n            data.put(\"xwiki\", new com.xpn.xwiki.api.XWiki(context.getWiki(), stubContext));\n            data.put(\"xjob\", object);\n\n            job.setJobDataMap(data);\n\n            getScheduler().addJob(job, true);\n\n            JobState status = getJobStatus(object);\n\n            switch (status.getState()) {\n                case Trigger.STATE_PAUSED:\n                    // a paused job must be resumed, not scheduled\n                    break;\n                case Trigger.STATE_NORMAL:\n                    if (getTrigger(object).compareTo(trigger) != 0) {\n                        LOG.debug(\"Reschedule Job : \" + object.getStringValue(\"jobName\"));\n                    }\n                    getScheduler().rescheduleJob(trigger.getName(), trigger.getGroup(), trigger);\n                    break;\n                case Trigger.STATE_NONE:\n                    LOG.debug(\"Schedule Job : \" + object.getStringValue(\"jobName\"));\n                    getScheduler().scheduleJob(trigger);\n                    LOG.info(\"XWiki Job Status :\" + object.getStringValue(\"status\"));\n                    if (object.getStringValue(\"status\").equals(\"Paused\")) {\n                        getScheduler().pauseJob(xjob, Scheduler.DEFAULT_GROUP);\n                        saveStatus(\"Paused\", object, context);\n                    } else {\n                        saveStatus(\"Normal\", object, context);\n                    }\n                    break;\n                default:\n                    LOG.debug(\"Schedule Job : \" + object.getStringValue(\"jobName\"));\n                    getScheduler().scheduleJob(trigger);\n                    saveStatus(\"Normal\", object, context);\n                    break;\n            }\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_SCHEDULE_JOB,\n                \"Error while scheduling job \" + object.getStringValue(\"jobName\"), e);\n        } catch (ParseException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_BAD_CRON_EXPRESSION,\n                \"Error while parsing cron expression for job \" + object.getStringValue(\"jobName\"),\n                e);\n        } catch (ClassNotFoundException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while loading job class for job : \" + object.getStringValue(\"jobName\"),\n                e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while saving job status for job : \" + object.getStringValue(\"jobName\"),\n                e);\n        }\n        return scheduled;\n    }","id":35854,"modified_method":"public boolean scheduleJob(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        boolean scheduled = true;\n        try {\n            JobDataMap data = new JobDataMap();\n\n// compute the job unique Id\n            String xjob = getObjectUniqueId(object, context);\n\n            JobDetail job = new JobDetail(xjob, Scheduler.DEFAULT_GROUP,\n                Class.forName(object.getStringValue(\"jobClass\")));\n\n            Trigger trigger = new CronTrigger(xjob, Scheduler.DEFAULT_GROUP, xjob,\n                Scheduler.DEFAULT_GROUP, object.getStringValue(\"cron\"));\n\n// Let's prepare an execution context...\n            XWikiContext stubContext = prepareJobStubContext(object, context);\n            Context stub = new Context(stubContext);\n\n            data.put(\"context\", stub);\n            data.put(\"xwiki\", new com.xpn.xwiki.api.XWiki(context.getWiki(), stubContext));\n            data.put(\"xjob\", object);\n\n            job.setJobDataMap(data);\n\n            getScheduler().addJob(job, true);\n\n            JobState status = getJobStatus(object, context);\n\n            switch (status.getState()) {\n                case Trigger.STATE_PAUSED:\n                    // a paused job must be resumed, not scheduled\n                    break;\n                case Trigger.STATE_NORMAL:\n                    if (getTrigger(object, context).compareTo(trigger) != 0) {\n                        LOG.debug(\"Reschedule Job : \" + object.getStringValue(\"jobName\"));\n                    }\n                    getScheduler().rescheduleJob(trigger.getName(), trigger.getGroup(), trigger);\n                    break;\n                case Trigger.STATE_NONE:\n                    LOG.debug(\"Schedule Job : \" + object.getStringValue(\"jobName\"));\n                    getScheduler().scheduleJob(trigger);\n                    LOG.info(\"XWiki Job Status :\" + object.getStringValue(\"status\"));\n                    if (object.getStringValue(\"status\").equals(\"Paused\")) {\n                        getScheduler().pauseJob(xjob, Scheduler.DEFAULT_GROUP);\n                        saveStatus(\"Paused\", object, context);\n                    } else {\n                        saveStatus(\"Normal\", object, context);\n                    }\n                    break;\n                default:\n                    LOG.debug(\"Schedule Job : \" + object.getStringValue(\"jobName\"));\n                    getScheduler().scheduleJob(trigger);\n                    saveStatus(\"Normal\", object, context);\n                    break;\n            }\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_SCHEDULE_JOB,\n                \"Error while scheduling job \" + object.getStringValue(\"jobName\"), e);\n        } catch (ParseException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_BAD_CRON_EXPRESSION,\n                \"Error while parsing cron expression for job \" + object.getStringValue(\"jobName\"),\n                e);\n        } catch (ClassNotFoundException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while loading job class for job : \" + object.getStringValue(\"jobName\"),\n                e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while saving job status for job : \" + object.getStringValue(\"jobName\"),\n                e);\n        }\n        return scheduled;\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Pause the job with the given name by pausing all of its current triggers.\n     *\n     * @param object the non-wrapped XObject Job to be paused\n     */\n    public void pauseJob(BaseObject object, XWikiContext context) throws SchedulerPluginException\n    {\n        try {\n            getScheduler().pauseJob(getObjectUniqueId(object), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"Paused\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_PAUSE_JOB,\n                \"Error occured while trying to pause job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_PAUSE_JOB,\n                \"Error occured while trying to save status of job \" +\n                    object.getStringValue(\"jobName\"), e);\n        }\n    }","id":35855,"modified_method":"/**\n     * Pause the job with the given name by pausing all of its current triggers.\n     *\n     * @param object the non-wrapped XObject Job to be paused\n     */\n    public void pauseJob(BaseObject object, XWikiContext context) throws SchedulerPluginException\n    {\n        try {\n            getScheduler().pauseJob(getObjectUniqueId(object, context), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"Paused\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_PAUSE_JOB,\n                \"Error occured while trying to pause job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_PAUSE_JOB,\n                \"Error occured while trying to save status of job \" +\n                    object.getStringValue(\"jobName\"), e);\n        }\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Compute a cross-document unique {@link com.xpn.xwiki.objects.BaseObject} id, by concatenating\n     * its name (it's document holder full name, such as \"SomeSpace.SomeDoc\") and it's instance\n     * number inside this document. <p/> The scheduler uses this unique object id to assure the\n     * unicity of jobs\n     *\n     * @return a unique String that can identify the object\n     */\n    private String getObjectUniqueId(BaseObject object)\n    {\n        return object.getName() + \"_\" + object.getNumber();\n    }","id":35856,"modified_method":"/**\n     * Compute a cross-document unique {@link com.xpn.xwiki.objects.BaseObject} id, by concatenating\n     * its name (it's document holder full name, such as \"SomeSpace.SomeDoc\") and it's instance\n     * number inside this document. <p/> The scheduler uses this unique object id to assure the\n     * unicity of jobs\n     *\n     * @return a unique String that can identify the object\n     */\n    private String getObjectUniqueId(BaseObject object, XWikiContext context)\n    {\n        return context.getDatabase() + \":\" + object.getName() + \"_\" + object.getNumber();\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Restore the existing job, by looking up for such job in the database and re-scheduling those\n     * according to their stored status. If a Job is stored with the status \"Normal\", it is just\n     * scheduled If a Job is stored with the status \"Paused\", then it is both scheduled and paused\n     * Jobs with other status (None, Complete) are not rescheduled.\n     *\n     * @param context The XWikiContext when initializing the plugin\n     */\n    private void restoreExistingJobs(XWikiContext context) throws SchedulerPluginException\n    {\n        String hql = \", BaseObject as obj where doc.web='Scheduler'\" +\n            \" and obj.name=doc.fullName and obj.className='XWiki.SchedulerJobClass'\";\n        try {\n            List jobsDocsNames = context.getWiki().getStore().searchDocumentsNames(hql, context);\n            for (int i = 0; i < jobsDocsNames.size(); i++) {\n                XWikiDocument jobDoc =\n                    context.getWiki().getDocument((String) jobsDocsNames.get(i), context);\n                BaseObject jobObj = jobDoc.getObject(XWIKI_JOB_CLASS);\n                String jobName = jobObj.getStringValue(\"jobName\");\n                try {\n                    String status = jobObj.getStringValue(\"status\");\n                    if (status.equals(JobState.STATE_NORMAL) ||\n                        status.equals(JobState.STATE_PAUSED))\n                    {\n                        this.scheduleJob(jobObj, context);\n                    }\n                    if (status.equals(JobState.STATE_PAUSED)) {\n                        this.pauseJob(jobObj, context);\n                    }\n                } catch (XWikiException e) {\n                    throw new SchedulerPluginException(\n                        SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESTORE_JOB,\n                        \"Failed to restore job with job name \" + jobName, e);\n                }\n            }\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESTORE_EXISTING_JOBS,\n                \"Failed to restore existing scheduler jobs\", e);\n        }\n    }","id":35857,"modified_method":"/**\n     * Restore the existing job, by looking up for such job in the database and re-scheduling those\n     * according to their stored status. If a Job is stored with the status \"Normal\", it is just\n     * scheduled If a Job is stored with the status \"Paused\", then it is both scheduled and paused\n     * Jobs with other status (None, Complete) are not rescheduled.\n     *\n     * @param context The XWikiContext when initializing the plugin\n     */\n    private void restoreExistingJobs(XWikiContext context) throws SchedulerPluginException\n    {\n        int retval = 0;\n\n        String hql = \", BaseObject as obj where doc.web='Scheduler'\" +\n            \" and obj.name=doc.fullName and obj.className='XWiki.SchedulerJobClass'\";\n        try {\n            List jobsDocsNames = context.getWiki().getStore().searchDocumentsNames(hql, context);\n            for (int i = 0; i < jobsDocsNames.size(); i++) {\n                XWikiDocument jobDoc =\n                    context.getWiki().getDocument((String) jobsDocsNames.get(i), context);\n                BaseObject jobObj = jobDoc.getObject(XWIKI_JOB_CLASS);\n                String jobName = jobObj.getStringValue(\"jobName\");\n                try {\n                    String status = jobObj.getStringValue(\"status\");\n                    if (status.equals(JobState.STATE_NORMAL) ||\n                        status.equals(JobState.STATE_PAUSED))\n                    {\n                        this.scheduleJob(jobObj, context);\n                    }\n                    if (status.equals(JobState.STATE_PAUSED)) {\n                        this.pauseJob(jobObj, context);\n                    }\n                } catch (XWikiException e) {\n                    throw new SchedulerPluginException(\n                        SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESTORE_JOB,\n                        \"Failed to restore job with job name \" + jobName, e);\n                }\n            }\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESTORE_EXISTING_JOBS,\n                \"Failed to restore existing scheduler jobs\", e);\n        }\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get the next fire time for the given job name SchedulerJob\n     *\n     * @param object unwrapped XObject job for which the next fire time will be given\n     * @return the next Date the job will be fired at\n     */\n    public Date getNextFireTime(BaseObject object) throws SchedulerPluginException\n    {\n        return getTrigger(object).getNextFireTime();\n    }","id":35858,"modified_method":"/**\n     * Get the next fire time for the given job name SchedulerJob\n     *\n     * @param object unwrapped XObject job for which the next fire time will be given\n     * @return the next Date the job will be fired at\n     */\n    public Date getNextFireTime(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        return getTrigger(object, context).getNextFireTime();\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Get Trigger object of the given job\n     *\n     * @param object the unwrapped XObject to be retrieve the trigger for\n     * @return the trigger object of the given job\n     */\n    private Trigger getTrigger(BaseObject object) throws SchedulerPluginException\n    {\n        String job = getObjectUniqueId(object);\n        Trigger trigger;\n        try {\n            trigger = getScheduler().getTrigger(job, Scheduler.DEFAULT_GROUP);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while getting trigger for job \" + job, e);\n        }\n        if (trigger == null) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_DOES_NOT_EXITS,\n                \"Job does not exists\");\n        }\n\n        return trigger;\n    }","id":35859,"modified_method":"/**\n     * Get Trigger object of the given job\n     *\n     * @param object the unwrapped XObject to be retrieve the trigger for\n     * @return the trigger object of the given job\n     */\n    private Trigger getTrigger(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        String job = getObjectUniqueId(object, context);\n        Trigger trigger;\n        try {\n            trigger = getScheduler().getTrigger(job, Scheduler.DEFAULT_GROUP);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while getting trigger for job \" + job, e);\n        }\n        if (trigger == null) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_DOES_NOT_EXITS,\n                \"Job does not exists\");\n        }\n\n        return trigger;\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Unschedule the given job\n     *\n     * @param object the unwrapped XObject job to be unscheduled\n     */\n    public void unscheduleJob(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        try {\n            getScheduler().deleteJob(getObjectUniqueId(object), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"None\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while unscheduling job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while saving status of job \" + object.getStringValue(\"jobName\"), e);\n        }\n    }","id":35860,"modified_method":"/**\n     * Unschedule the given job\n     *\n     * @param object the unwrapped XObject job to be unscheduled\n     */\n    public void unscheduleJob(BaseObject object, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        try {\n            getScheduler().deleteJob(getObjectUniqueId(object, context), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"None\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while unscheduling job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_JOB_XCLASS_NOT_FOUND,\n                \"Error while saving status of job \" + object.getStringValue(\"jobName\"), e);\n        }\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#init(com.xpn.xwiki.XWikiContext)\n     */\n    public void init(XWikiContext context)\n    {\n        super.init(context);\n        try {\n            updateSchedulerJobClass(context);\n            setScheduler(getDefaultSchedulerInstance());\n            setStatusListener();\n            getScheduler().start();\n            restoreExistingJobs(context);\n        } catch (SchedulerException e) {\n            LOG.error(\"Failed to start the scheduler\", e);\n        } catch (SchedulerPluginException e) {\n            LOG.error(\"Failed to initialize the scheduler\", e);\n        }\n    }","id":35861,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#init(com.xpn.xwiki.XWikiContext)\n     */\n    public void init(XWikiContext context)\n    {\n        try {\n            String initialDb =\n                !context.getDatabase().equals(\"\") ? context.getDatabase() : context.getMainXWiki();\n            List wikiServers = Collections.EMPTY_LIST;\n\n            if (context.getWiki().isVirtual()) {\n                try {\n                    wikiServers = context.getWiki().getVirtualWikisDatabaseNames(context);\n                    if (!wikiServers.contains(context.getMainXWiki())) {\n                        wikiServers.add(context.getMainXWiki());\n                    }\n                } catch (Exception e) {\n                    LOG.error(\"error getting list of wiki servers!\", e);\n                }\n            } else {\n                wikiServers = new ArrayList();\n                wikiServers.add(context.getMainXWiki());\n            }\n\n            try {\n                for (Iterator iter = wikiServers.iterator(); iter.hasNext();) {\n                    context.setDatabase((String) iter.next());\n                    updateSchedulerJobClass(context);\n                }\n            } finally {\n                context.setDatabase(initialDb);\n            }\n\n            setScheduler(getDefaultSchedulerInstance());\n            setStatusListener();\n            getScheduler().start();\n\n            try {\n                // Iterate on all virtual wikis\n                for (Iterator iter = wikiServers.iterator(); iter.hasNext();) {\n                    context.setDatabase((String) iter.next());\n                    restoreExistingJobs(context);\n                }\n            } finally {\n                context.setDatabase(initialDb);\n            }\n        } catch (SchedulerException e) {\n            LOG.error(\"Failed to start the scheduler\", e);\n        } catch (SchedulerPluginException e) {\n            LOG.error(\"Failed to initialize the scheduler\", e);\n        }\n        super.init(context);\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Create and feed a stub context for the job execution thread. Stub context data are retrieved\n     * from job object fields \"contextUser\", \"contextLang\", \"contextDatabase\". If one of this field\n     * is empty (this would typically happen on the first schedule operation), it is instead\n     * retrieved from the passed context, and the job object is updated with this value. This mean\n     * that this method may modify the passed object.\n     *\n     * @param job the job for which the context will be prepared\n     * @param context the XWikiContext at preparation time. This is a real context associated with a\n     * servlet request\n     * @return the stub context prepared with job datas.\n     */\n    private XWikiContext prepareJobStubContext(BaseObject job, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        boolean jobNeedsUpdate = true;\n        String cUser = job.getStringValue(\"contextUser\");\n        if (cUser.equals(\"\")) {\n            // The context user has not been filled yet.\n            // We can suppose it's the first scheduling. Let's assume it's the context user\n            cUser = context.getUser();\n            job.setStringValue(\"contextUser\", cUser);\n            jobNeedsUpdate = true;\n        }\n        String cLang = job.getStringValue(\"contextLang\");\n        if (cLang.equals(\"\")) {\n            cLang = context.getLanguage();\n            job.setStringValue(\"contextLang\", cLang);\n            jobNeedsUpdate = true;\n        }\n        String cDb = job.getStringValue(\"contextDatabase\");\n        if (cDb.equals(\"\")) {\n            cDb = context.getDatabase();\n            job.setStringValue(\"contextDatabase\", cDb);\n            jobNeedsUpdate = true;\n        }\n\n        if (jobNeedsUpdate) {\n            try {\n                XWikiDocument jobHolder = context.getWiki().getDocument(job.getName(), context);\n                BaseObject jObj =\n                    jobHolder.getObject(SchedulerPlugin.XWIKI_JOB_CLASS, job.getNumber());\n                jobHolder.setMinorEdit(true);\n                context.getWiki().saveDocument(jobHolder, context);\n            }\n            catch (XWikiException e) {\n                throw new SchedulerPluginException(\n                    SchedulerPluginException.ERROR_SCHEDULERPLUGIN_UNABLE_TO_PREPARE_JOB_CONTEXT,\n                    \"Failed to prepare context for job with job name \" +\n                        job.getStringValue(\"jobName\"), e);\n            }\n        }\n\n        //lets now build the stub context\n        XWikiContext scontext = new XWikiContext();\n        scontext.setWiki(context.getWiki());\n\n        // We are sure the context request is a real servlet request\n        // So we force the dummy request with the current host\n        XWikiServletRequestStub dummy = new XWikiServletRequestStub();\n        dummy.setHost(context.getRequest().getHeader(\"x-forwarded-host\"));\n        XWikiServletRequest request = new XWikiServletRequest(dummy);\n        scontext.setRequest(request);\n\n        // feed the dummy context\n        scontext.setUser(cUser);\n        scontext.setLanguage(cLang);\n        scontext.setDatabase(cDb);\n        scontext.setMainXWiki(context.getMainXWiki());\n        scontext.setVirtual(context.isVirtual());        \n\n        com.xpn.xwiki.web.XWikiURLFactory xurf = context.getURLFactory();\n        if (xurf == null) {\n            xurf = context.getWiki().getURLFactoryService()\n                .createURLFactory(context.getMode(), context);\n        }\n        scontext.setURLFactory(xurf);\n\n        try {\n            XWikiDocument cDoc = context.getWiki().getDocument(job.getName(), context);\n            scontext.setDoc(cDoc);\n        }\n        catch (Exception e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_UNABLE_TO_PREPARE_JOB_CONTEXT,\n                \"Failed to prepare context for job with job name \" + job.getStringValue(\"jobName\"),\n                e);\n        }\n\n        return scontext;\n    }","id":35862,"modified_method":"/**\n     * Create and feed a stub context for the job execution thread. Stub context data are retrieved\n     * from job object fields \"contextUser\", \"contextLang\", \"contextDatabase\". If one of this field\n     * is empty (this would typically happen on the first schedule operation), it is instead\n     * retrieved from the passed context, and the job object is updated with this value. This mean\n     * that this method may modify the passed object.\n     *\n     * @param job the job for which the context will be prepared\n     * @param context the XWikiContext at preparation time. This is a real context associated with a\n     * servlet request\n     * @return the stub context prepared with job datas.\n     */\n    private XWikiContext prepareJobStubContext(BaseObject job, XWikiContext context)\n        throws SchedulerPluginException\n    {\n        boolean jobNeedsUpdate = true;\n        String cUser = job.getStringValue(\"contextUser\");\n        if (cUser.equals(\"\")) {\n            // The context user has not been filled yet.\n            // We can suppose it's the first scheduling. Let's assume it's the context user\n            cUser = context.getUser();\n            job.setStringValue(\"contextUser\", cUser);\n            jobNeedsUpdate = true;\n        }\n        String cLang = job.getStringValue(\"contextLang\");\n        if (cLang.equals(\"\")) {\n            cLang = context.getLanguage();\n            job.setStringValue(\"contextLang\", cLang);\n            jobNeedsUpdate = true;\n        }\n        String iDb = context.getDatabase();\n        String cDb = job.getStringValue(\"contextDatabase\");\n        if (cDb.equals(\"\") || !cDb.equals(iDb)) {\n            cDb = context.getDatabase();\n            job.setStringValue(\"contextDatabase\", cDb);\n            jobNeedsUpdate = true;\n        }\n\n        if (jobNeedsUpdate) {\n            try {\n                context.setDatabase(cDb);\n                XWikiDocument jobHolder = context.getWiki().getDocument(job.getName(), context);\n                BaseObject jObj =\n                    jobHolder.getObject(SchedulerPlugin.XWIKI_JOB_CLASS, job.getNumber());\n                jobHolder.setMinorEdit(true);\n                context.getWiki().saveDocument(jobHolder, context);\n            }\n            catch (XWikiException e) {\n                throw new SchedulerPluginException(\n                    SchedulerPluginException.ERROR_SCHEDULERPLUGIN_UNABLE_TO_PREPARE_JOB_CONTEXT,\n                    \"Failed to prepare context for job with job name \" +\n                        job.getStringValue(\"jobName\"), e);\n            } finally {\n                context.setDatabase(iDb);\n            }\n        }\n\n        //lets now build the stub context\n        XWikiContext scontext = new XWikiContext();\n        scontext.setWiki(context.getWiki());\n\n        // We are sure the context request is a real servlet request\n        // So we force the dummy request with the current host\n        XWikiServletRequestStub dummy = new XWikiServletRequestStub();\n        dummy.setHost(context.getRequest().getHeader(\"x-forwarded-host\"));\n        XWikiServletRequest request = new XWikiServletRequest(dummy);\n        scontext.setRequest(request);\n\n        // feed the dummy context\n        scontext.setUser(cUser);\n        scontext.setLanguage(cLang);\n        scontext.setDatabase(cDb);\n        scontext.setMainXWiki(context.getMainXWiki());\n        scontext.setVirtual(context.isVirtual());\n\n        com.xpn.xwiki.web.XWikiURLFactory xurf = context.getURLFactory();\n        if (xurf == null) {\n            xurf = context.getWiki().getURLFactoryService()\n                .createURLFactory(context.getMode(), context);\n        }\n        scontext.setURLFactory(xurf);\n\n        try {\n            XWikiDocument cDoc = context.getWiki().getDocument(job.getName(), context);\n            scontext.setDoc(cDoc);\n        }\n        catch (Exception e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_UNABLE_TO_PREPARE_JOB_CONTEXT,\n                \"Failed to prepare context for job with job name \" + job.getStringValue(\"jobName\"),\n                e);\n        }\n\n        return scontext;\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#virtualInit(com.xpn.xwiki.XWikiContext)\n     */\n    public void virtualInit(XWikiContext context)\n    {\n        super.virtualInit(context);\n        init(context);\n    }","id":35863,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @see com.xpn.xwiki.plugin.XWikiPluginInterface#virtualInit(com.xpn.xwiki.XWikiContext)\n     */\n    public void virtualInit(XWikiContext context)\n    {\n        super.virtualInit(context);\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Retrieve the job's status of a given {@link com.xpn.xwiki.plugin.scheduler.SchedulerPlugin#XWIKI_JOB_CLASS}\n     * job XObject, by asking the actual job status to the quartz scheduler instance. It's the\n     * actual status, as the one stored in the XObject may be changed manually by users.\n     *\n     * @param object the XObject to give the status of\n     * @return the status of the Job inside the quartz scheduler, as {@link\n     *         com.xpn.xwiki.plugin.scheduler.JobState} instance\n     */\n    public JobState getJobStatus(BaseObject object) throws SchedulerException\n    {\n        int state = getScheduler()\n            .getTriggerState(getObjectUniqueId(object), Scheduler.DEFAULT_GROUP);\n        return new JobState(state);\n    }","id":35864,"modified_method":"/**\n     * Retrieve the job's status of a given {@link com.xpn.xwiki.plugin.scheduler.SchedulerPlugin#XWIKI_JOB_CLASS}\n     * job XObject, by asking the actual job status to the quartz scheduler instance. It's the\n     * actual status, as the one stored in the XObject may be changed manually by users.\n     *\n     * @param object the XObject to give the status of\n     * @return the status of the Job inside the quartz scheduler, as {@link\n     *         com.xpn.xwiki.plugin.scheduler.JobState} instance\n     */\n    public JobState getJobStatus(BaseObject object, XWikiContext context) throws SchedulerException\n    {\n        int state = getScheduler()\n            .getTriggerState(getObjectUniqueId(object, context), Scheduler.DEFAULT_GROUP);\n        return new JobState(state);\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Resume the job with the given name (un-pause)\n     *\n     * @param object the non-wrapped XObject Job to be resumed\n     */\n    public void resumeJob(BaseObject object, XWikiContext context) throws SchedulerPluginException\n    {\n        try {\n            getScheduler().resumeJob(getObjectUniqueId(object), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"Normal\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESUME_JOB,\n                \"Error occured while trying to resume job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESUME_JOB,\n                \"Error occured while trying to save status of job \" +\n                    object.getStringValue(\"jobName\"), e);\n        }\n    }","id":35865,"modified_method":"/**\n     * Resume the job with the given name (un-pause)\n     *\n     * @param object the non-wrapped XObject Job to be resumed\n     */\n    public void resumeJob(BaseObject object, XWikiContext context) throws SchedulerPluginException\n    {\n        try {\n            getScheduler().resumeJob(getObjectUniqueId(object, context), Scheduler.DEFAULT_GROUP);\n            saveStatus(\"Normal\", object, context);\n        } catch (SchedulerException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESUME_JOB,\n                \"Error occured while trying to resume job \" + object.getStringValue(\"jobName\"), e);\n        } catch (XWikiException e) {\n            throw new SchedulerPluginException(\n                SchedulerPluginException.ERROR_SCHEDULERPLUGIN_RESUME_JOB,\n                \"Error occured while trying to save status of job \" +\n                    object.getStringValue(\"jobName\"), e);\n        }\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     *\n     * @see XWikiDefaultPlugin#XWikiDefaultPlugin(String,String,com.xpn.xwiki.XWikiContext)\n     */\n    public SchedulerPlugin(String name, String className, XWikiContext context)\n    {\n        super(name, className, context);\n        init(context);\n    }","id":35866,"modified_method":"/**\n     * {@inheritDoc}\n     *\n     * @see XWikiDefaultPlugin#XWikiDefaultPlugin(String,String,com.xpn.xwiki.XWikiContext)\n     */\n    public SchedulerPlugin(String name, String className, XWikiContext context)\n    {\n        super(name, className, context);        \n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public Date getNextFireTime(BaseObject object)\n    {\n        try {\n            return plugin.getNextFireTime(object);\n        }\n        catch (SchedulerPluginException e) {\n            context.put(\"error\", e.getMessage());\n            return null;\n        }\n    }","id":35867,"modified_method":"public Date getNextFireTime(BaseObject object)\n    {\n        try {\n            return plugin.getNextFireTime(object, context);\n        }\n        catch (SchedulerPluginException e) {\n            context.put(\"error\", e.getMessage());\n            return null;\n        }\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public JobState getJobStatus(Object object) throws SchedulerException, SchedulerPluginException\n    {\n        return plugin.getJobStatus(retrieveBaseObject(object));\n    }","id":35868,"modified_method":"public JobState getJobStatus(Object object) throws SchedulerException, SchedulerPluginException\n    {\n        return plugin.getJobStatus(retrieveBaseObject(object), context);\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Return the trigger state as a ${@link JobState}, that holds both the integer trigger's inner\n     * value of the state and a String as a human readable representation of that state\n     */\n    public JobState getJobStatus(BaseObject object)\n        throws SchedulerException, SchedulerPluginException\n    {\n        return plugin.getJobStatus(object);\n    }","id":35869,"modified_method":"/**\n     * Return the trigger state as a ${@link JobState}, that holds both the integer trigger's inner\n     * value of the state and a String as a human readable representation of that state\n     */\n    public JobState getJobStatus(BaseObject object)\n        throws SchedulerException, SchedulerPluginException\n    {\n        return plugin.getJobStatus(object, context);\n    }","commit_id":"8cdef54d59b333b23452c011d5baee96ca98290f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public boolean installPackage(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage) throws DistributionException {\n\n        DistributionRequestType actionType = distributionPackage.getInfo().getRequestType();\n\n        if (!type.equals(distributionPackage.getType())) {\n            throw new DistributionException(\"not supported package type\" + distributionPackage.getType());\n        }\n\n        boolean installed = false;\n        if (DistributionRequestType.DELETE.equals(actionType)) {\n            installed = installDeletePackage(resourceResolver, distributionPackage);\n        } else if (DistributionRequestType.TEST.equals(actionType)) {\n            // do nothing for test packages\n            installed = true;\n        } else if (DistributionRequestType.ADD.equals(actionType)) {\n            installed = installPackageInternal(resourceResolver, distributionPackage);\n        }\n\n        return installed;\n    }","id":35870,"modified_method":"public boolean installPackage(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage) throws DistributionException {\n\n        DistributionRequestType actionType = distributionPackage.getInfo().getRequestType();\n\n        if (!type.equals(distributionPackage.getType())) {\n            throw new DistributionException(\"not supported package type\" + distributionPackage.getType());\n        }\n\n        boolean installed = false;\n        if (DistributionRequestType.DELETE.equals(actionType)) {\n            installed = installDeletePackage(resourceResolver, distributionPackage);\n        } else if (DistributionRequestType.TEST.equals(actionType)) {\n            // do nothing for test packages\n            installed = true;\n        } else if (DistributionRequestType.ADD.equals(actionType)) {\n            installed = installAddPackage(resourceResolver, distributionPackage);\n        }\n\n        return installed;\n    }","commit_id":"eed5e49f110be19a774c80f2e1d9f7f40a4c7c9f","url":"https://github.com/apache/sling"},{"original_method":"protected abstract boolean installPackageInternal(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage)\n            throws DistributionException;","id":35871,"modified_method":"private boolean installAddPackage(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage)\n            throws DistributionException {\n        InputStream inputStream = null;\n        try {\n            inputStream = distributionPackage.createInputStream();\n            return installPackageInternal(resourceResolver, inputStream);\n        } catch (IOException e) {\n            throw new DistributionException(e);\n        } finally {\n            IOUtils.closeQuietly(inputStream);\n        }\n\n    }","commit_id":"eed5e49f110be19a774c80f2e1d9f7f40a4c7c9f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected boolean installPackageInternal(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage)\n            throws DistributionException {\n        InputStream inputStream = null;\n        try {\n            inputStream = distributionPackage.createInputStream();\n            distributionContentSerializer.importFromStream(resourceResolver, inputStream);\n            return true;\n        } catch (IOException e) {\n            throw new DistributionException(e);\n        } finally {\n            IOUtils.closeQuietly(inputStream);\n        }\n    }","id":35872,"modified_method":"@Override\n    protected boolean installPackageInternal(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream  inputStream)\n            throws DistributionException {\n        try {\n            distributionContentSerializer.importFromStream(resourceResolver, inputStream);\n\n            return true;\n        } finally {\n            IOUtils.closeQuietly(inputStream);\n        }\n    }","commit_id":"eed5e49f110be19a774c80f2e1d9f7f40a4c7c9f","url":"https://github.com/apache/sling"},{"original_method":"@Nonnull\n    public DistributionPackageInfo importStream(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream stream) throws DistributionException {\n        DistributionPackage distributionPackage = null;\n        try {\n            distributionPackage = packageBuilder.readPackage(resourceResolver, stream);\n\n            boolean success = packageBuilder.installPackage(resourceResolver, distributionPackage);\n\n            if (!success) {\n                log.warn(\"could not install distribution package {}\", distributionPackage.getId());\n            }\n\n            return distributionPackage.getInfo();\n        } finally {\n            DistributionPackageUtils.deleteSafely(distributionPackage);\n        }\n    }","id":35873,"modified_method":"@Nonnull\n    public DistributionPackageInfo importStream(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream stream) throws DistributionException {\n        DistributionPackageInfo packageInfo = packageBuilder.installPackage(resourceResolver, stream);\n\n        return packageInfo;\n    }","commit_id":"eed5e49f110be19a774c80f2e1d9f7f40a4c7c9f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected boolean installPackageInternal(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage)\n            throws DistributionException {\n        InputStream  inputStream = null;\n        try {\n            inputStream = distributionPackage.createInputStream();\n            distributionContentSerializer.importFromStream(resourceResolver, inputStream);\n            return true;\n        } catch (IOException e) {\n            throw new DistributionException(e);\n        } finally {\n            IOUtils.closeQuietly(inputStream);\n        }\n    }","id":35874,"modified_method":"@Override\n    protected boolean installPackageInternal(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream  inputStream)\n            throws DistributionException {\n        try {\n            distributionContentSerializer.importFromStream(resourceResolver, inputStream);\n\n            return true;\n        } finally {\n            IOUtils.closeQuietly(inputStream);\n        }\n    }","commit_id":"eed5e49f110be19a774c80f2e1d9f7f40a4c7c9f","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public void importPackage(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage) throws DistributionException {\n        boolean success = packageBuilder.installPackage(resourceResolver, distributionPackage);\n\n        if (!success) {\n            log.warn(\"could not install distribution package {}\", distributionPackage.getId());\n        }\n    }","id":35875,"modified_method":"@Override\n    public void importPackage(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage) throws DistributionException {\n        boolean success = packageBuilder.installPackage(resourceResolver, distributionPackage);\n\n        if (!success) {\n            log.warn(\"could not install distribution package {}\", distributionPackage.getId());\n        }\n\n        eventFactory.generatePackageEvent(DistributionEventTopics.IMPORTER_PACKAGE_IMPORTED, DistributionComponentKind.IMPORTER, name, distributionPackage.getInfo());\n    }","commit_id":"0d7e0107a76408556df2b4e7168099ee927a5106","url":"https://github.com/apache/sling"},{"original_method":"public LocalDistributionPackageImporter(DistributionPackageBuilder packageBuilder) {\n\n        if (packageBuilder == null) {\n            throw new IllegalArgumentException(\"A package builder is required\");\n        }\n\n        this.packageBuilder = packageBuilder;\n    }","id":35876,"modified_method":"public LocalDistributionPackageImporter(String name, DistributionEventFactory eventFactory, DistributionPackageBuilder packageBuilder) {\n\n        if (packageBuilder == null) {\n            throw new IllegalArgumentException(\"A package builder is required\");\n        }\n\n        if (eventFactory == null) {\n            throw new IllegalArgumentException(\"EventFactory is required\");\n        }\n\n        if (name == null) {\n            throw new IllegalArgumentException(\"An importer name is required\");\n        }\n\n        this.packageBuilder = packageBuilder;\n        this.eventFactory = eventFactory;\n        this.name = name;\n    }","commit_id":"0d7e0107a76408556df2b4e7168099ee927a5106","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    @Nonnull\n    public DistributionPackageInfo importStream(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream stream) throws DistributionException {\n        return packageBuilder.installPackage(resourceResolver, stream);\n    }","id":35877,"modified_method":"@Override\n    @Nonnull\n    public DistributionPackageInfo importStream(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream stream) throws DistributionException {\n        DistributionPackageInfo packageInfo = packageBuilder.installPackage(resourceResolver, stream);\n        eventFactory.generatePackageEvent(DistributionEventTopics.IMPORTER_PACKAGE_IMPORTED, DistributionComponentKind.IMPORTER, name, packageInfo);\n        return packageInfo;\n    }","commit_id":"0d7e0107a76408556df2b4e7168099ee927a5106","url":"https://github.com/apache/sling"},{"original_method":"@Nonnull\n    public DistributionPackageInfo importStream(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream stream) throws DistributionException {\n        DistributionPackageInfo distributionPackageInfo = importer.importStream(resourceResolver, stream);\n\n        eventFactory.generatePackageEvent(DistributionEventTopics.IMPORTER_PACKAGE_IMPORTED, DistributionComponentKind.IMPORTER, name, distributionPackageInfo);\n\n        return distributionPackageInfo;\n    }","id":35878,"modified_method":"@Nonnull\n    public DistributionPackageInfo importStream(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream stream) throws DistributionException {\n        return importer.importStream(resourceResolver, stream);\n    }","commit_id":"0d7e0107a76408556df2b4e7168099ee927a5106","url":"https://github.com/apache/sling"},{"original_method":"public void importPackage(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage) throws DistributionException {\n        importer.importPackage(resourceResolver, distributionPackage);\n        eventFactory.generatePackageEvent(DistributionEventTopics.IMPORTER_PACKAGE_IMPORTED, DistributionComponentKind.IMPORTER, name, distributionPackage.getInfo());\n    }","id":35879,"modified_method":"public void importPackage(@Nonnull ResourceResolver resourceResolver, @Nonnull DistributionPackage distributionPackage) throws DistributionException {\n        importer.importPackage(resourceResolver, distributionPackage);\n    }","commit_id":"0d7e0107a76408556df2b4e7168099ee927a5106","url":"https://github.com/apache/sling"},{"original_method":"@Activate\n    public void activate(Map<String, Object> config) {\n        name = PropertiesUtil.toString(config.get(NAME), null);\n        importer = new LocalDistributionPackageImporter(packageBuilder);\n    }","id":35880,"modified_method":"@Activate\n    public void activate(Map<String, Object> config) {\n        String name = PropertiesUtil.toString(config.get(NAME), null);\n        importer = new LocalDistributionPackageImporter(name, eventFactory, packageBuilder);\n    }","commit_id":"0d7e0107a76408556df2b4e7168099ee927a5106","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testDummyImport() throws Exception {\n        DistributionPackageBuilder packageBuilder = mock(DistributionPackageBuilder.class);\n        LocalDistributionPackageImporter localdistributionPackageImporter = new LocalDistributionPackageImporter(packageBuilder);\n        ResourceResolver resourceResolver = mock(ResourceResolver.class);\n        DistributionPackage distributionPackage = mock(DistributionPackage.class);\n        localdistributionPackageImporter.importPackage(resourceResolver, distributionPackage);\n    }","id":35881,"modified_method":"@Test\n    public void testDummyImport() throws Exception {\n        DistributionPackageBuilder packageBuilder = mock(DistributionPackageBuilder.class);\n        DistributionEventFactory distributionEventFactory = mock(DistributionEventFactory.class);\n        LocalDistributionPackageImporter localdistributionPackageImporter =\n                new LocalDistributionPackageImporter(\"mockImporter\", distributionEventFactory, packageBuilder);\n        ResourceResolver resourceResolver = mock(ResourceResolver.class);\n        DistributionPackage distributionPackage = mock(DistributionPackage.class);\n        localdistributionPackageImporter.importPackage(resourceResolver, distributionPackage);\n    }","commit_id":"0d7e0107a76408556df2b4e7168099ee927a5106","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    protected SimpleDistributionAgent createAgent(String agentName, BundleContext context, Map<String, Object> config, DefaultDistributionLog distributionLog) {\n        String serviceName = PropertiesUtil.toString(config.get(SERVICE_NAME), null);\n        boolean queueProcessingEnabled = PropertiesUtil.toBoolean(config.get(QUEUE_PROCESSING_ENABLED), true);\n\n\n        String[] exporterEndpoints = PropertiesUtil.toStringArray(config.get(EXPORTER_ENDPOINTS), new String[0]);\n        exporterEndpoints = SettingsUtils.removeEmptyEntries(exporterEndpoints);\n\n\n        int pullItems = PropertiesUtil.toInteger(config.get(PULL_ITEMS), Integer.MAX_VALUE);\n\n\n        DistributionPackageExporter packageExporter = new RemoteDistributionPackageExporter(distributionLog, packageBuilder, transportSecretProvider, exporterEndpoints, pullItems);\n        DistributionPackageImporter packageImporter = new LocalDistributionPackageImporter(packageBuilder);\n        DistributionQueueProvider queueProvider = new JobHandlingDistributionQueueProvider(agentName, jobManager, context);\n\n        DistributionQueueDispatchingStrategy exportQueueStrategy = new SingleQueueDispatchingStrategy();\n        DistributionQueueDispatchingStrategy importQueueStrategy = null;\n\n        DistributionRequestType[] allowedRequests = new DistributionRequestType[]{DistributionRequestType.PULL};\n        Set<String> processingQueues = new HashSet<String>();\n        processingQueues.addAll(exportQueueStrategy.getQueueNames());\n\n\n        return new SimpleDistributionAgent(agentName, queueProcessingEnabled, processingQueues,\n                serviceName, packageImporter, packageExporter, requestAuthorizationStrategy,\n                queueProvider, exportQueueStrategy, importQueueStrategy, distributionEventFactory, resourceResolverFactory, slingRepository, distributionLog, allowedRequests, null, 0);\n\n\n    }","id":35882,"modified_method":"@Override\n    protected SimpleDistributionAgent createAgent(String agentName, BundleContext context, Map<String, Object> config, DefaultDistributionLog distributionLog) {\n        String serviceName = PropertiesUtil.toString(config.get(SERVICE_NAME), null);\n        boolean queueProcessingEnabled = PropertiesUtil.toBoolean(config.get(QUEUE_PROCESSING_ENABLED), true);\n\n        String[] exporterEndpoints = PropertiesUtil.toStringArray(config.get(EXPORTER_ENDPOINTS), new String[0]);\n        exporterEndpoints = SettingsUtils.removeEmptyEntries(exporterEndpoints);\n\n        int pullItems = PropertiesUtil.toInteger(config.get(PULL_ITEMS), Integer.MAX_VALUE);\n\n        DistributionPackageExporter packageExporter = new RemoteDistributionPackageExporter(distributionLog, packageBuilder, transportSecretProvider, exporterEndpoints, pullItems);\n        DistributionPackageImporter packageImporter = new LocalDistributionPackageImporter(agentName, distributionEventFactory, packageBuilder);\n        DistributionQueueProvider queueProvider = new JobHandlingDistributionQueueProvider(agentName, jobManager, context);\n\n        DistributionQueueDispatchingStrategy exportQueueStrategy = new SingleQueueDispatchingStrategy();\n        DistributionQueueDispatchingStrategy importQueueStrategy = null;\n\n        DistributionRequestType[] allowedRequests = new DistributionRequestType[]{DistributionRequestType.PULL};\n        Set<String> processingQueues = new HashSet<String>();\n        processingQueues.addAll(exportQueueStrategy.getQueueNames());\n\n\n        return new SimpleDistributionAgent(agentName, queueProcessingEnabled, processingQueues,\n                serviceName, packageImporter, packageExporter, requestAuthorizationStrategy,\n                queueProvider, exportQueueStrategy, importQueueStrategy, distributionEventFactory, resourceResolverFactory, slingRepository, distributionLog, allowedRequests, null, 0);\n\n    }","commit_id":"0d7e0107a76408556df2b4e7168099ee927a5106","url":"https://github.com/apache/sling"},{"original_method":"@Nonnull\n    public DistributionPackageInfo importStream(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream stream) throws DistributionException {\n        DistributionPackageInfo packageInfo = packageBuilder.installPackage(resourceResolver, stream);\n\n        return packageInfo;\n    }","id":35883,"modified_method":"@Override\n    @Nonnull\n    public DistributionPackageInfo importStream(@Nonnull ResourceResolver resourceResolver, @Nonnull InputStream stream) throws DistributionException {\n        return packageBuilder.installPackage(resourceResolver, stream);\n    }","commit_id":"a9739ee7d15992287a6c850d932ffb6ff4f5c531","url":"https://github.com/apache/sling"},{"original_method":"protected Format[] getMatchingOutputFormats(Format in)\n    {\n        VideoFormat ivf = (VideoFormat) in;\n        Dimension inSize = ivf.getSize();\n\n        VideoFormat ovf;\n        // return the default size/currently decoder and encoder\n        // set to transmit/receive at this size\n        if (inSize == null)\n        {\n            ovf = outputFormats[0];\n        }\n        else\n        {\n            /* output in same size as input */\n            ovf = ivf;\n        }\n\n        if (ovf == null)\n            return null;\n\n        Dimension outSize = ovf.getSize();\n        return new Format[]\n        { new RGBFormat(outSize, -1, Format.intArray,\n            ensureFrameRate(ivf.getFrameRate()), 32, RED_MASK, GREEN_MASK,\n            BLUE_MASK, 1, outSize.width, Format.FALSE, Format.NOT_SPECIFIED) };\n    }","id":35884,"modified_method":"protected Format[] getMatchingOutputFormats(Format in)\n    {\n        VideoFormat ivf = (VideoFormat) in;\n        Dimension inSize = ivf.getSize();\n        Dimension outSize;\n\n        // return the default size/currently decoder and encoder\n        // set to transmit/receive at this size\n        if (inSize == null)\n        {\n            VideoFormat ovf = outputFormats[0];\n\n            if (ovf == null)\n                return null;\n            else\n                outSize = ovf.getSize();\n        }\n        else\n            outSize = inSize; // Output in same size as input.\n\n        return\n            new Format[]\n            {\n                new RGBFormat(\n                        outSize,\n                        -1,\n                        Format.intArray,\n                        ensureFrameRate(ivf.getFrameRate()),\n                        32,\n                        RED_MASK, GREEN_MASK, BLUE_MASK,\n                        1,\n                        outSize.width,\n                        Format.FALSE,\n                        Format.NOT_SPECIFIED)\n            };\n    }","commit_id":"4ea47d57cfd3164a2e6f75cda3ffc9f77ecfe400","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Set the data input format.\n     *\n     * @return false if the format is not supported.\n     */\n    @Override\n    public Format setInputFormat(Format format)\n    {\n        if (super.setInputFormat(format) != null)\n        {\n            reset();\n            return format;\n        }\n        else\n            return null;\n    }","id":35885,"modified_method":"/**\n     * Set the data input format.\n     *\n     * @return false if the format is not supported.\n     */\n    @Override\n    public Format setInputFormat(Format format)\n    {\n        Format setFormat = super.setInputFormat(format);\n\n        if (setFormat != null)\n            reset();\n        return setFormat;\n    }","commit_id":"4ea47d57cfd3164a2e6f75cda3ffc9f77ecfe400","url":"https://github.com/jitsi/jitsi"},{"original_method":"public synchronized int process(Buffer inputBuffer, Buffer outputBuffer)\n    {\n        if (!checkInputBuffer(inputBuffer))\n        {\n            return BUFFER_PROCESSED_FAILED;\n        }\n\n        if (isEOM(inputBuffer) || !opened)\n        {\n            propagateEOM(outputBuffer);\n            return BUFFER_PROCESSED_OK;\n        }\n\n        if (inputBuffer.isDiscard())\n        {\n            inputBuffer.setDiscard(true);\n            reset();\n            return BUFFER_PROCESSED_OK;\n        }\n\n        if(waitingForMarker)\n        {\n            lastReceivedSeq = inputBuffer.getSequenceNumber();\n            if((inputBuffer.getFlags() & Buffer.FLAG_RTP_MARKER) != 0)\n            {\n                waitingForMarker = false;\n                outputBuffer.setDiscard(true);\n                return BUFFER_PROCESSED_OK;\n            }\n            else\n                return OUTPUT_BUFFER_NOT_FILLED;\n        }\n\n        if (lastReceivedSeq != -1\n            && inputBuffer.getSequenceNumber() - lastReceivedSeq > 1)\n        {\n            long oldRecv = lastReceivedSeq;\n            lastReceivedSeq = inputBuffer.getSequenceNumber();\n            waitingForMarker = true;\n            logger.trace(\"DROP rtp data! \" + oldRecv + \"/\" + lastReceivedSeq);\n            parser.reset();\n            reset();\n            return OUTPUT_BUFFER_NOT_FILLED;\n        }\n        else if (!parser.pushRTPInput(inputBuffer))\n        {\n            lastReceivedSeq = inputBuffer.getSequenceNumber();\n            return OUTPUT_BUFFER_NOT_FILLED;\n        }\n\n        lastReceivedSeq = inputBuffer.getSequenceNumber();\n\n        // decodes the data\n        got_picture[0] = false;\n        FFMPEG.avcodec_decode_video(avcontext, avframe, got_picture, parser\n            .getEncodedFrame(), parser.getEncodedFrameLen());\n\n        int avctxWidth = FFMPEG.avcodeccontext_get_width(avcontext);\n        int avctxHeight = FFMPEG.avcodeccontext_get_height(avcontext);\n\n        if (avctxWidth != 0 && currentVideoWidth != avctxWidth)\n        {\n            currentVideoWidth = avctxWidth;\n\n            VideoFormat ivf = (VideoFormat) inputBuffer.getFormat();\n            /* output format with same size as input */\n            VideoFormat ovf = new RGBFormat(new Dimension(avctxWidth, \n                        avctxHeight), -1, Format.intArray,\n                        ensureFrameRate(ivf.getFrameRate()), 32, RED_MASK, GREEN_MASK,\n                        BLUE_MASK, 1, avctxWidth, Format.FALSE, \n                        Format.NOT_SPECIFIED);\n\n            if (ovf != null)\n            {\n                outputFormat = ovf;\n            }\n        }\n        outputBuffer.setFormat(outputFormat);\n\n        if (!got_picture[0])\n        {\n            outputBuffer.setDiscard(true);\n            return BUFFER_PROCESSED_OK;\n        }\n\n        // convert the picture in RGB Format\n        int numBytes =\n            FFMPEG.avpicture_get_size(FFMPEG.PIX_FMT_RGB32, avctxWidth,\n                avctxHeight);\n        long buffer = FFMPEG.av_malloc(numBytes);\n\n        FFMPEG.avpicture_fill(frameRGB, buffer, FFMPEG.PIX_FMT_RGB32,\n            avctxWidth, avctxHeight);\n\n        // Convert the image from its native format to RGB\n        FFMPEG.img_convert(frameRGB, FFMPEG.PIX_FMT_RGB32, avframe, FFMPEG\n            .avcodeccontext_get_pix_fmt(avcontext), avctxWidth, avctxHeight);\n\n        Object outData = outputBuffer.getData();\n        int dataLength = numBytes / 4;\n        int[] data;\n        if ((outData instanceof int[])\n            && ((int[]) outData).length >= dataLength)\n            data = (int[]) outData;\n        else\n            data = new int[dataLength];\n\n        FFMPEG\n            .memcpy(data, 0, dataLength, FFMPEG.avpicture_get_data0(frameRGB));\n\n        outputBuffer.setOffset(0);\n        outputBuffer.setLength(dataLength);\n        outputBuffer.setData(data);\n\n        FFMPEG.av_free(buffer);\n        return BUFFER_PROCESSED_OK;\n    }","id":35886,"modified_method":"public synchronized int process(Buffer inputBuffer, Buffer outputBuffer)\n    {\n        if (!checkInputBuffer(inputBuffer))\n        {\n            return BUFFER_PROCESSED_FAILED;\n        }\n\n        if (isEOM(inputBuffer) || !opened)\n        {\n            propagateEOM(outputBuffer);\n            return BUFFER_PROCESSED_OK;\n        }\n\n        if (inputBuffer.isDiscard())\n        {\n            inputBuffer.setDiscard(true);\n            reset();\n            return BUFFER_PROCESSED_OK;\n        }\n\n        if(waitingForMarker)\n        {\n            lastReceivedSeq = inputBuffer.getSequenceNumber();\n            if((inputBuffer.getFlags() & Buffer.FLAG_RTP_MARKER) != 0)\n            {\n                waitingForMarker = false;\n                outputBuffer.setDiscard(true);\n                return BUFFER_PROCESSED_OK;\n            }\n            else\n                return OUTPUT_BUFFER_NOT_FILLED;\n        }\n\n        if (lastReceivedSeq != -1\n            && inputBuffer.getSequenceNumber() - lastReceivedSeq > 1)\n        {\n            long oldRecv = lastReceivedSeq;\n            lastReceivedSeq = inputBuffer.getSequenceNumber();\n            waitingForMarker = true;\n            logger.trace(\"DROP rtp data! \" + oldRecv + \"/\" + lastReceivedSeq);\n            parser.reset();\n            reset();\n            return OUTPUT_BUFFER_NOT_FILLED;\n        }\n        else if (!parser.pushRTPInput(inputBuffer))\n        {\n            lastReceivedSeq = inputBuffer.getSequenceNumber();\n            return OUTPUT_BUFFER_NOT_FILLED;\n        }\n\n        lastReceivedSeq = inputBuffer.getSequenceNumber();\n\n        // decodes the data\n        got_picture[0] = false;\n        FFMPEG.avcodec_decode_video(avcontext, avframe, got_picture, parser\n            .getEncodedFrame(), parser.getEncodedFrameLen());\n\n        int avctxWidth = FFMPEG.avcodeccontext_get_width(avcontext);\n        int avctxHeight = FFMPEG.avcodeccontext_get_height(avcontext);\n\n        if (avctxWidth != 0 && currentVideoWidth != avctxWidth)\n        {\n            currentVideoWidth = avctxWidth;\n\n            VideoFormat ivf = (VideoFormat) inputBuffer.getFormat();\n            /* output format with same size as input */\n            VideoFormat ovf\n                = new RGBFormat(\n                        new Dimension(avctxWidth, avctxHeight),\n                        -1,\n                        Format.intArray,\n                        ensureFrameRate(ivf.getFrameRate()),\n                        32,\n                        RED_MASK, GREEN_MASK, BLUE_MASK,\n                        1,\n                        avctxWidth, Format.FALSE, \n                        Format.NOT_SPECIFIED);\n\n            if (ovf != null)\n                outputFormat = ovf;\n        }\n        outputBuffer.setFormat(outputFormat);\n\n        if (!got_picture[0])\n        {\n            outputBuffer.setDiscard(true);\n            return BUFFER_PROCESSED_OK;\n        }\n\n        // convert the picture in RGB Format\n        int numBytes =\n            FFMPEG.avpicture_get_size(FFMPEG.PIX_FMT_RGB32, avctxWidth,\n                avctxHeight);\n        long buffer = FFMPEG.av_malloc(numBytes);\n\n        FFMPEG.avpicture_fill(frameRGB, buffer, FFMPEG.PIX_FMT_RGB32,\n            avctxWidth, avctxHeight);\n\n        // Convert the image from its native format to RGB\n        FFMPEG.img_convert(frameRGB, FFMPEG.PIX_FMT_RGB32, avframe, FFMPEG\n            .avcodeccontext_get_pix_fmt(avcontext), avctxWidth, avctxHeight);\n\n        Object outData = outputBuffer.getData();\n        int dataLength = numBytes / 4;\n        int[] data;\n        if ((outData instanceof int[])\n            && ((int[]) outData).length >= dataLength)\n            data = (int[]) outData;\n        else\n            data = new int[dataLength];\n\n        FFMPEG\n            .memcpy(data, 0, dataLength, FFMPEG.avpicture_get_data0(frameRGB));\n\n        outputBuffer.setData(data);\n        outputBuffer.setLength(dataLength);\n        outputBuffer.setOffset(0);\n        //outputBuffer.setTimeStamp(inputBuffer.getTimeStamp());\n\n        FFMPEG.av_free(buffer);\n\n        return BUFFER_PROCESSED_OK;\n    }","commit_id":"4ea47d57cfd3164a2e6f75cda3ffc9f77ecfe400","url":"https://github.com/jitsi/jitsi"},{"original_method":"public Dimension getOutputSize()\n    {\n        Format outputFormat = getOutputFormat();\n\n        if (outputFormat == null)\n        {\n            // They all have one and the same size.\n            outputFormat = supportedOutputFormats[0];\n        }\n        return ((VideoFormat) outputFormat).getSize();\n    }","id":35887,"modified_method":"/**\n     * Gets the output size.\n     *\n     * @return the output size\n     */\n    public Dimension getOutputSize()\n    {\n        Format outputFormat = getOutputFormat();\n\n        if (outputFormat == null)\n        {\n            // They all have one and the same size.\n            outputFormat = supportedOutputFormats[0];\n        }\n        return ((VideoFormat) outputFormat).getSize();\n    }","commit_id":"4ea47d57cfd3164a2e6f75cda3ffc9f77ecfe400","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Processes (converts color space and/or scales) a buffer.\n     *\n     * @param input input buffer\n     * @param output output buffer\n     * @return <tt>BUFFER_PROCESSED_OK<\/tt> if buffer has been successfully\n     * processed\n     */\n    @Override\n    public int process(Buffer input, Buffer output) \n    {\n        if (!checkInputBuffer(input))\n            return BUFFER_PROCESSED_FAILED;\n\n        if (isEOM(input))\n        {\n            propagateEOM(output);   // TODO Can there be any data?\n            return BUFFER_PROCESSED_OK;\n        }\n\n        VideoFormat outputFormat = (VideoFormat) getOutputFormat();\n\n        if(outputFormat == null)\n        {\n            /*\n             * The format of the output Buffer is not documented to be used as\n             * input to the #process method. Anyway, we're trying to use it in\n             * case this Codec doesn't have an outputFormat set which is\n             * unlikely to ever happen.\n             */\n            outputFormat = (VideoFormat) output.getFormat();\n            if (outputFormat == null) // first buffer has no output format set\n                return BUFFER_PROCESSED_FAILED;\n        }\n\n        int dstFmt;\n        int dstLength;\n        Dimension outputSize = outputFormat.getSize();\n        int outputWidth = outputSize.width;\n        int outputHeight = outputSize.height;\n\n        /* determine output format and output size needed */\n        if(outputFormat instanceof YUVFormat)\n        {\n            dstFmt = FFMPEG.PIX_FMT_YUV420P;\n            /* YUV420P is 12 bpp (bit per pixel) => 1,5 bytes */\n            dstLength = (int)(outputWidth * outputHeight * 1.5);\n        }\n        else /* RGB format */\n        {\n            dstFmt = FFMPEG.PIX_FMT_RGB32;\n            dstLength = (outputWidth * outputHeight * 4);\n        }\n        \n        /* determine input format */\n        VideoFormat inputFormat = (VideoFormat)input.getFormat();\n        int srcFmt;\n\n        if(inputFormat instanceof YUVFormat)\n            srcFmt = FFMPEG.PIX_FMT_YUV420P;\n        else // RGBFormat\n            srcFmt = getNativeRGBFormat((RGBFormat)inputFormat);\n\n        Class<?> outputDataType = outputFormat.getDataType();\n        Object dst = output.getData();\n\n        if(Format.byteArray.equals(outputDataType))\n        {\n            if(dst == null || ((byte[])dst).length < dstLength)\n                dst = new byte[dstLength];\n        }\n        else if(Format.intArray.equals(outputDataType))\n        {\n            /* Java int is always 4 bytes */\n            dstLength = (dstLength % 4) + dstLength / 4;\n            if(dst == null || ((int[])dst).length < dstLength)\n                dst = new int[dstLength];\n        }\n        else if(Format.shortArray.equals(outputDataType))\n        {\n            /* Java short is always 2 bytes */\n            dstLength = (dstLength % 2) + dstLength / 2;\n            if(dst == null || ((short[])dst).length < dstLength)\n                dst = new short[dstLength];\n        }\n        else\n        {\n            logger.error(\"Unknown data type \" + outputDataType);\n            return BUFFER_PROCESSED_FAILED;\n        }\n\n        Object src = input.getData();\n\n        synchronized(src)\n        {\n            /* conversion! */\n            Dimension inputSize = inputFormat.getSize();\n\n            FFMPEG.img_convert(\n                    dst, dstFmt,\n                    src, srcFmt,\n                    inputSize.width, inputSize.height,\n                    outputWidth, outputHeight);\n        }\n\n        output.setData(dst);\n        output.setFormat(outputFormat);\n        output.setLength(dstLength);\n        output.setOffset(0);\n\n        return BUFFER_PROCESSED_OK;   \n    }","id":35888,"modified_method":"/**\n     * Processes (converts color space and/or scales) a buffer.\n     *\n     * @param input input buffer\n     * @param output output buffer\n     * @return <tt>BUFFER_PROCESSED_OK<\/tt> if buffer has been successfully\n     * processed\n     */\n    @Override\n    public int process(Buffer input, Buffer output) \n    {\n        if (!checkInputBuffer(input))\n            return BUFFER_PROCESSED_FAILED;\n\n        if (isEOM(input))\n        {\n            propagateEOM(output);   // TODO Can there be any data?\n            return BUFFER_PROCESSED_OK;\n        }\n        if (input.isDiscard() || frameProcessingControl.isMinimalProcessing())\n        {\n            output.setDiscard(true);\n            return BUFFER_PROCESSED_OK;\n        }\n\n        /* determine input format */\n        VideoFormat inputFormat = (VideoFormat)input.getFormat();\n        Format thisInputFormat = getInputFormat();\n\n        if ((inputFormat != thisInputFormat)\n                && !inputFormat.equals(thisInputFormat))\n            setInputFormat(inputFormat);\n\n        int srcFmt;\n\n        if(inputFormat instanceof YUVFormat)\n            srcFmt = FFMPEG.PIX_FMT_YUV420P;\n        else // RGBFormat\n            srcFmt = getNativeRGBFormat((RGBFormat)inputFormat);\n\n        VideoFormat outputFormat = (VideoFormat) getOutputFormat();\n\n        if(outputFormat == null)\n        {\n            /*\n             * The format of the output Buffer is not documented to be used as\n             * input to the #process method. Anyway, we're trying to use it in\n             * case this Codec doesn't have an outputFormat set which is\n             * unlikely to ever happen.\n             */\n            outputFormat = (VideoFormat) output.getFormat();\n            if (outputFormat == null) // first buffer has no output format set\n                return BUFFER_PROCESSED_FAILED;\n        }\n\n        int dstFmt;\n        int dstLength;\n        Dimension outputSize = outputFormat.getSize();\n        int outputWidth = outputSize.width;\n        int outputHeight = outputSize.height;\n\n        /* determine output format and output size needed */\n        if(outputFormat instanceof YUVFormat)\n        {\n            dstFmt = FFMPEG.PIX_FMT_YUV420P;\n            /* YUV420P is 12 bpp (bit per pixel) => 1,5 bytes */\n            dstLength = (int)(outputWidth * outputHeight * 1.5);\n        }\n        else /* RGB format */\n        {\n            dstFmt = FFMPEG.PIX_FMT_RGB32;\n            dstLength = (outputWidth * outputHeight * 4);\n        }\n\n        Class<?> outputDataType = outputFormat.getDataType();\n        Object dst = output.getData();\n\n        if(Format.byteArray.equals(outputDataType))\n        {\n            if(dst == null || ((byte[])dst).length < dstLength)\n                dst = new byte[dstLength];\n        }\n        else if(Format.intArray.equals(outputDataType))\n        {\n            /* Java int is always 4 bytes */\n            dstLength = (dstLength % 4) + dstLength / 4;\n            if(dst == null || ((int[])dst).length < dstLength)\n                dst = new int[dstLength];\n        }\n        else if(Format.shortArray.equals(outputDataType))\n        {\n            /* Java short is always 2 bytes */\n            dstLength = (dstLength % 2) + dstLength / 2;\n            if(dst == null || ((short[])dst).length < dstLength)\n                dst = new short[dstLength];\n        }\n        else\n        {\n            logger.error(\"Unknown data type \" + outputDataType);\n            return BUFFER_PROCESSED_FAILED;\n        }\n\n        Object src = input.getData();\n\n        synchronized(src)\n        {\n            /* conversion! */\n            Dimension inputSize = inputFormat.getSize();\n\n            FFMPEG.img_convert(\n                    dst, dstFmt,\n                    src, srcFmt,\n                    inputSize.width, inputSize.height,\n                    outputWidth, outputHeight);\n        }\n\n        output.setData(dst);\n        output.setDuration(input.getDuration());\n        output.setFlags(input.getFlags());\n        output.setFormat(outputFormat);\n        output.setLength(dstLength);\n        output.setOffset(0);\n        output.setSequenceNumber(input.getSequenceNumber());\n        output.setTimeStamp(input.getTimeStamp());\n\n        return BUFFER_PROCESSED_OK;   \n    }","commit_id":"4ea47d57cfd3164a2e6f75cda3ffc9f77ecfe400","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the input format.\n     *\n     * @param format format to set\n     * @return format\n     */\n    @Override\n    public Format setInputFormat(Format format)\n    {\n        Format inputFormat\n            = ((format instanceof VideoFormat)\n                    && (((VideoFormat) format).getSize() == null))\n                ? null // size is required\n                : super.setInputFormat(format);\n\n        if (logger.isDebugEnabled() && (inputFormat != null))\n            logger.debug(\"SwScaler set to input in \" + inputFormat);\n        return inputFormat;\n    }","id":35889,"modified_method":"/**\n     * Sets the input format.\n     *\n     * @param format format to set\n     * @return format\n     */\n    @Override\n    public Format setInputFormat(Format format)\n    {\n        Format inputFormat\n            = ((format instanceof VideoFormat)\n                    && (((VideoFormat) format).getSize() == null))\n                ? null // size is required\n                : super.setInputFormat(format);\n\n        if (inputFormat != null)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"SwScaler set to input in \" + inputFormat);\n        }\n        return inputFormat;\n    }","commit_id":"4ea47d57cfd3164a2e6f75cda3ffc9f77ecfe400","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets the supported output formats for an input one.\n     *\n     * @param input input format to get supported output ones for\n     * @return array of supported output formats\n     */\n    @Override\n    public Format[] getSupportedOutputFormats(Format input)\n    {\n        if(input == null)\n            return supportedOutputFormats;\n\n        /* if size is set for element 0 (YUVFormat), it is also set \n         * for element 1 (RGBFormat) and so on...\n         */\n        Dimension size = ((VideoFormat)supportedOutputFormats[0]).getSize();\n\n        if(size != null)\n            return supportedOutputFormats;\n\n        /* no specified size set so return the same size as input\n         * in output format supported\n         */\n        size = ((VideoFormat)input).getSize();\n\n        return new Format[] { \n                              new YUVFormat(size, -1, Format.byteArray, -1.0f,\n                                      YUVFormat.YUV_420, -1, -1, 0, -1, -1),\n                              new YUVFormat(size, -1, Format.intArray, -1.0f,\n                                      YUVFormat.YUV_420, -1, -1, 0, -1, -1),\n                              new YUVFormat(size, -1, Format.shortArray, -1.0f,\n                                      YUVFormat.YUV_420, -1, -1, 0, -1, -1),\n                              new RGBFormat(size, -1, Format.byteArray, -1.0f,\n                                      32, -1, -1, -1),\n                              new RGBFormat(size, -1, Format.intArray, -1.0f,\n                                      32, -1, -1, -1),\n                              new RGBFormat(size, -1, Format.shortArray, -1.0f,\n                                      32, -1, -1, -1),\n                              new RGBFormat(size, -1, Format.byteArray, -1.0f,\n                                      24, -1, -1, -1),\n                              new RGBFormat(size, -1, Format.intArray, -1.0f,\n                                      24, -1, -1, -1),\n                              new RGBFormat(size, -1, Format.shortArray, -1.0f,\n                                      24, -1, -1, -1),\n                            };\n    }","id":35890,"modified_method":"/**\n     * Gets the supported output formats for an input one.\n     *\n     * @param input input format to get supported output ones for\n     * @return array of supported output formats\n     */\n    @Override\n    public Format[] getSupportedOutputFormats(Format input)\n    {\n        if(input == null)\n            return supportedOutputFormats;\n\n        /* if size is set for element 0 (YUVFormat), it is also set \n         * for element 1 (RGBFormat) and so on...\n         */\n        Dimension size = ((VideoFormat) supportedOutputFormats[0]).getSize();\n\n        /* no specified size set so return the same size as input\n         * in output format supported\n         */\n        VideoFormat videoInput = (VideoFormat) input;\n\n        if(size == null)\n            size = videoInput.getSize();\n\n        float frameRate = videoInput.getFrameRate();\n\n        return\n            new Format[]\n            { \n                new YUVFormat(size, -1, Format.byteArray, frameRate,\n                        YUVFormat.YUV_420, -1, -1, 0, -1, -1),\n                new YUVFormat(size, -1, Format.intArray, frameRate,\n                        YUVFormat.YUV_420, -1, -1, 0, -1, -1),\n                new YUVFormat(size, -1, Format.shortArray, frameRate,\n                        YUVFormat.YUV_420, -1, -1, 0, -1, -1),\n                new RGBFormat(size, -1, Format.byteArray, frameRate, 32, -1, -1,\n                        -1),\n                new RGBFormat(size, -1, Format.intArray, frameRate, 32, -1, -1,\n                        -1),\n                new RGBFormat(size, -1, Format.shortArray, frameRate, 32, -1,\n                        -1, -1),\n                new RGBFormat(size, -1, Format.byteArray, frameRate, 24, -1, -1,\n                        -1),\n                new RGBFormat(size, -1, Format.intArray, frameRate, 24, -1, -1,\n                        -1),\n                new RGBFormat(size, -1, Format.shortArray, frameRate, 24, -1,\n                        -1, -1)\n            };\n    }","commit_id":"4ea47d57cfd3164a2e6f75cda3ffc9f77ecfe400","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets a <tt>MediaDevice<\/tt> which is capable of capture and/or playback\n     * of media of the specified <tt>MediaType<\/tt>, is the default choice of\n     * the user for a <tt>MediaDevice<\/tt> with the specified <tt>MediaType<\/tt>\n     * and is appropriate for the current state of this <tt>Call<\/tt>.\n     * <p>\n     * For example, when the local peer represented by this <tt>Call<\/tt>\n     * instance is acting as a conference focus, the audio device must be a\n     * mixer.\n     * <\/p>\n     *\n     * @param mediaType the <tt>MediaType<\/tt> in which the retrieved\n     * <tt>MediaDevice<\/tt> is to capture and/or play back media\n     * @return a <tt>MediaDevice<\/tt> which is capable of capture and/or\n     * playback of media of the specified <tt>mediaType<\/tt>, is the default\n     * choice of the user for a <tt>MediaDevice<\/tt> with the specified\n     * <tt>mediaType<\/tt> and is appropriate for the current state of this\n     * <tt>Call<\/tt>\n     */\n    public MediaDevice getDefaultDevice(MediaType mediaType)\n    {\n        MediaDevice device;\n\n        switch (mediaType)\n        {\n        case AUDIO:\n            device = audioDevice;\n            break;\n        case VIDEO:\n            device = videoDevice;\n            break;\n        default:\n            /* no other type supported */\n            return null;\n        }\n\n        MediaService mediaService = ProtocolMediaActivator.getMediaService();\n\n        if (device == null)\n            device = mediaService.getDefaultDevice(mediaType, mediaUseCase);\n\n        /*\n         * Make sure that the audio device has an AudioMixer in order to support\n         * conferencing and call recording.\n         */\n        switch (mediaType)\n        {\n        case AUDIO:\n            if ((conferenceAudioMixer == null) && (device != null))\n                conferenceAudioMixer = mediaService.createMixer(device);\n            device = conferenceAudioMixer;\n            break;\n\n        case VIDEO:\n            if (isConferenceFocus())\n            {\n                if ((conferenceVideoMixer == null) && (device != null)) \n                    conferenceVideoMixer = mediaService.createMixer(device);\n                device = conferenceVideoMixer;\n            }\n            break;\n        }\n\n        return device;\n    }","id":35891,"modified_method":"/**\n     * Gets a <tt>MediaDevice<\/tt> which is capable of capture and/or playback\n     * of media of the specified <tt>MediaType<\/tt>, is the default choice of\n     * the user for a <tt>MediaDevice<\/tt> with the specified <tt>MediaType<\/tt>\n     * and is appropriate for the current state of this <tt>Call<\/tt>.\n     * <p>\n     * For example, when the local peer represented by this <tt>Call<\/tt>\n     * instance is acting as a conference focus, the audio device must be a\n     * mixer.\n     * <\/p>\n     *\n     * @param mediaType the <tt>MediaType<\/tt> in which the retrieved\n     * <tt>MediaDevice<\/tt> is to capture and/or play back media\n     * @return a <tt>MediaDevice<\/tt> which is capable of capture and/or\n     * playback of media of the specified <tt>mediaType<\/tt>, is the default\n     * choice of the user for a <tt>MediaDevice<\/tt> with the specified\n     * <tt>mediaType<\/tt> and is appropriate for the current state of this\n     * <tt>Call<\/tt>\n     */\n    public MediaDevice getDefaultDevice(MediaType mediaType)\n    {\n        MediaDevice device;\n\n        switch (mediaType)\n        {\n        case AUDIO:\n            device = audioDevice;\n            break;\n        case VIDEO:\n            device = videoDevice;\n            break;\n        default:\n            /* no other type supported */\n            return null;\n        }\n\n        MediaService mediaService = ProtocolMediaActivator.getMediaService();\n\n        if (device == null)\n            device = mediaService.getDefaultDevice(mediaType, mediaUseCase);\n\n        /*\n         * Make sure that the audio device has an AudioMixer in order to support\n         * conferencing and call recording.\n         */\n        switch (mediaType)\n        {\n        case AUDIO:\n            /*\n             * TODO AudioMixer leads to very poor audio quality on Android so do\n             * not use it unless it is really really necessary.\n             */\n            if ((conferenceAudioMixer == null)\n                    && (device != null)\n                    && (!OSUtils.IS_ANDROID || isConferenceFocus()))\n                conferenceAudioMixer = mediaService.createMixer(device);\n            if (conferenceAudioMixer != null)\n                device = conferenceAudioMixer;\n            break;\n\n        case VIDEO:\n            if (isConferenceFocus())\n            {\n                if ((conferenceVideoMixer == null) && (device != null)) \n                    conferenceVideoMixer = mediaService.createMixer(device);\n                if (conferenceVideoMixer != null)\n                    device = conferenceVideoMixer;\n            }\n            break;\n        }\n\n        return device;\n    }","commit_id":"ee69f66fe49880758a639a3336df1b32e7175c5d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the input format.\n     *\n     * @param format format to set\n     * @return format\n     */\n    @Override\n    public Format setInputFormat(Format format)\n    {\n        Format inputFormat\n            = ((format instanceof VideoFormat)\n                    && (((VideoFormat) format).getSize() == null))\n                ? null // size is required\n                : super.setInputFormat(format);\n\n        if (inputFormat != null)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"SwScaler set to input in \" + inputFormat);\n        }\n        return inputFormat;\n    }","id":35892,"modified_method":"/**\n     * Sets the input format.\n     *\n     * @param format format to set\n     * @return format\n     */\n    @Override\n    public Format setInputFormat(Format format)\n    {\n        Format inputFormat\n            = (format instanceof VideoFormat)\n                ? super.setInputFormat(format)\n                : null /* A size is not required, the input must be video. */;\n\n        if (inputFormat != null)\n        {\n            if (logger.isDebugEnabled())\n                logger.debug(\"SwScaler set to input in \" + inputFormat);\n        }\n        return inputFormat;\n    }","commit_id":"ee69f66fe49880758a639a3336df1b32e7175c5d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Processes (converts color space and/or scales) a buffer.\n     *\n     * @param input input buffer\n     * @param output output buffer\n     * @return <tt>BUFFER_PROCESSED_OK<\/tt> if buffer has been successfully\n     * processed\n     */\n    @Override\n    public int process(Buffer input, Buffer output)\n    {\n        if (!checkInputBuffer(input))\n            return BUFFER_PROCESSED_FAILED;\n        if (isEOM(input))\n        {\n            propagateEOM(output);\n            return BUFFER_PROCESSED_OK;\n        }\n        if (input.isDiscard() || frameProcessingControl.isMinimalProcessing())\n        {\n            output.setDiscard(true);\n            return BUFFER_PROCESSED_OK;\n        }\n\n        // Determine the input Format.\n        VideoFormat inputFormat = (VideoFormat) input.getFormat();\n        Format thisInputFormat = getInputFormat();\n\n        if ((inputFormat != thisInputFormat)\n                && !inputFormat.equals(thisInputFormat))\n            setInputFormat(inputFormat);\n\n        // Determine the output Format and size.\n        VideoFormat outputFormat = (VideoFormat) getOutputFormat();\n\n        if (outputFormat == null)\n        {\n            /*\n             * The format of the output Buffer is not documented to be used as\n             * input to the #process method. Anyway, we're trying to use it in\n             * case this Codec doesn't have an outputFormat set which is\n             * unlikely to ever happen.\n             */\n            outputFormat = (VideoFormat) output.getFormat();\n            if (outputFormat == null)\n                return BUFFER_PROCESSED_FAILED;\n        }\n\n        Dimension outputSize = outputFormat.getSize();\n        int outputWidth = outputSize.width;\n        int outputHeight = outputSize.height;\n\n        if ((outputWidth < 2) || (outputHeight < 2)) // FFmpeg will crash.\n            return OUTPUT_BUFFER_NOT_FILLED;\n\n        int dstFmt;\n        int dstLength;\n\n        if (outputFormat instanceof YUVFormat)\n        {\n            dstFmt = FFmpeg.PIX_FMT_YUV420P;\n            /* YUV420P is 12 bits per pixel i.e. 1.5 bytes. */\n            dstLength = (int) (outputWidth * outputHeight * 1.5);\n        }\n        else /* RGB format */\n        {\n            dstFmt = FFmpeg.PIX_FMT_RGB32;\n            dstLength = (outputWidth * outputHeight * 4);\n        }\n\n        Class<?> outputDataType = outputFormat.getDataType();\n        Object dst = output.getData();\n\n        if (Format.byteArray.equals(outputDataType))\n        {\n            if(dst == null || ((byte[])dst).length < dstLength)\n                dst = new byte[dstLength];\n        }\n        else if (Format.intArray.equals(outputDataType))\n        {\n            /* Java int is always 4 bytes. */\n            dstLength = dstLength / 4 + ((dstLength % 4 == 0) ? 0 : 1);\n            if(dst == null || ((int[])dst).length < dstLength)\n                dst = new int[dstLength];\n        }\n        else if (Format.shortArray.equals(outputDataType))\n        {\n            /* Java short is always 2 bytes. */\n            dstLength = dstLength / 2 + ((dstLength % 2 == 0) ? 0 : 1);\n            if(dst == null || ((short[])dst).length < dstLength)\n                dst = new short[dstLength];\n        }\n        else\n        {\n            logger.error(\"Unknown data type \" + outputDataType);\n            return BUFFER_PROCESSED_FAILED;\n        }\n\n        Dimension inputSize = inputFormat.getSize();\n        int inputWidth = inputSize.width;\n        int inputHeight = inputSize.height;\n        Object src = input.getData();\n        int srcFmt;\n        long srcPicture;\n\n        if (src instanceof AVFrame)\n        {\n            srcFmt = ((AVFrameFormat) inputFormat).getPixFmt();\n            srcPicture = ((AVFrame) src).getPtr();\n        }\n        else\n        {\n            srcFmt\n                = (inputFormat instanceof YUVFormat)\n                    ? FFmpeg.PIX_FMT_YUV420P\n                    : getNativeRGBFormat((RGBFormat) inputFormat);\n            srcPicture = 0;\n        }\n\n        swsContext\n            = FFmpeg.sws_getCachedContext(\n                    swsContext,\n                    inputWidth, inputHeight, srcFmt,\n                    outputWidth, outputHeight, dstFmt,\n                    FFmpeg.SWS_BICUBIC);\n\n        if (srcPicture == 0)\n        {\n            FFmpeg.sws_scale(\n                    swsContext,\n                    src, srcFmt, inputWidth, inputHeight, 0, inputHeight,\n                    dst, dstFmt, outputWidth, outputHeight);\n        }\n        else\n        {\n            FFmpeg.sws_scale(\n                    swsContext,\n                    srcPicture, 0, inputHeight,\n                    dst, dstFmt, outputWidth, outputHeight);\n        }\n\n        output.setData(dst);\n        output.setDuration(input.getDuration());\n        output.setFlags(input.getFlags());\n        output.setFormat(outputFormat);\n        output.setLength(dstLength);\n        output.setOffset(0);\n        output.setSequenceNumber(input.getSequenceNumber());\n        output.setTimeStamp(input.getTimeStamp());\n\n        // flags\n        int inFlags = input.getFlags();\n        int outFlags = output.getFlags();\n\n        if ((inFlags & Buffer.FLAG_LIVE_DATA) != 0)\n            outFlags |= Buffer.FLAG_LIVE_DATA;\n        if ((inFlags & Buffer.FLAG_NO_WAIT) != 0)\n            outFlags |= Buffer.FLAG_NO_WAIT;\n        if ((inFlags & Buffer.FLAG_RELATIVE_TIME) != 0)\n            outFlags |= Buffer.FLAG_RELATIVE_TIME;\n        if ((inFlags & Buffer.FLAG_RTP_TIME) != 0)\n            outFlags |= Buffer.FLAG_RTP_TIME;\n        if ((inFlags & Buffer.FLAG_SYSTEM_TIME) != 0)\n            outFlags |= Buffer.FLAG_SYSTEM_TIME;\n        output.setFlags(outFlags);\n\n        return BUFFER_PROCESSED_OK;\n    }","id":35893,"modified_method":"/**\n     * Processes (converts color space and/or scales) a buffer.\n     *\n     * @param input input buffer\n     * @param output output buffer\n     * @return <tt>BUFFER_PROCESSED_OK<\/tt> if buffer has been successfully\n     * processed\n     */\n    @Override\n    public int process(Buffer input, Buffer output)\n    {\n        if (!checkInputBuffer(input))\n            return BUFFER_PROCESSED_FAILED;\n        if (isEOM(input))\n        {\n            propagateEOM(output);\n            return BUFFER_PROCESSED_OK;\n        }\n        if (input.isDiscard() || frameProcessingControl.isMinimalProcessing())\n        {\n            output.setDiscard(true);\n            return BUFFER_PROCESSED_OK;\n        }\n\n        // Determine the input Format.\n        VideoFormat inputFormat = (VideoFormat) input.getFormat();\n        Format thisInputFormat = getInputFormat();\n\n        if ((inputFormat != thisInputFormat)\n                && !inputFormat.equals(thisInputFormat))\n            setInputFormat(inputFormat);\n\n        // Determine the output Format and size.\n        VideoFormat outputFormat = (VideoFormat) getOutputFormat();\n\n        if (outputFormat == null)\n        {\n            /*\n             * The format of the output Buffer is not documented to be used as\n             * input to the #process method. Anyway, we're trying to use it in\n             * case this Codec doesn't have an outputFormat set which is\n             * unlikely to ever happen.\n             */\n            outputFormat = (VideoFormat) output.getFormat();\n            if (outputFormat == null)\n                return BUFFER_PROCESSED_FAILED;\n        }\n\n        Dimension outputSize = outputFormat.getSize();\n\n        if (outputSize == null)\n        {\n            outputSize = inputFormat.getSize();\n            if (outputSize == null)\n                return BUFFER_PROCESSED_FAILED;\n        }\n\n        int outputWidth = outputSize.width;\n        int outputHeight = outputSize.height;\n\n        if ((outputWidth < 2) || (outputHeight < 2)) // FFmpeg will crash.\n            return OUTPUT_BUFFER_NOT_FILLED;\n\n        // Apply the outputSize to the outputFormat of the output Buffer.\n        outputFormat = setSize(outputFormat, outputSize);\n        if (outputFormat == null)\n            return BUFFER_PROCESSED_FAILED;\n\n        int dstFmt;\n        int dstLength;\n\n        if (outputFormat instanceof YUVFormat)\n        {\n            dstFmt = FFmpeg.PIX_FMT_YUV420P;\n            /* YUV420P is 12 bits per pixel i.e. 1.5 bytes. */\n            dstLength = (int) (outputWidth * outputHeight * 1.5);\n        }\n        else /* RGB format */\n        {\n            dstFmt\n                = OSUtils.IS_ANDROID\n                    ? getNativeRGBFormat((RGBFormat) outputFormat)\n                    : FFmpeg.PIX_FMT_RGB32;\n            dstLength = (outputWidth * outputHeight * 4);\n        }\n\n        Class<?> outputDataType = outputFormat.getDataType();\n        Object dst = output.getData();\n\n        if (Format.byteArray.equals(outputDataType))\n        {\n            if(dst == null || ((byte[])dst).length < dstLength)\n                dst = new byte[dstLength];\n        }\n        else if (Format.intArray.equals(outputDataType))\n        {\n            /* Java int is always 4 bytes. */\n            dstLength = dstLength / 4 + ((dstLength % 4 == 0) ? 0 : 1);\n            if(dst == null || ((int[])dst).length < dstLength)\n                dst = new int[dstLength];\n        }\n        else if (Format.shortArray.equals(outputDataType))\n        {\n            /* Java short is always 2 bytes. */\n            dstLength = dstLength / 2 + ((dstLength % 2 == 0) ? 0 : 1);\n            if(dst == null || ((short[])dst).length < dstLength)\n                dst = new short[dstLength];\n        }\n        else\n        {\n            logger.error(\"Unknown data type \" + outputDataType);\n            return BUFFER_PROCESSED_FAILED;\n        }\n\n        Dimension inputSize = inputFormat.getSize();\n\n        if (inputSize == null)\n            return BUFFER_PROCESSED_FAILED;\n\n        int inputWidth = inputSize.width;\n        int inputHeight = inputSize.height;\n        Object src = input.getData();\n        int srcFmt;\n        long srcPicture;\n\n        if (src instanceof AVFrame)\n        {\n            srcFmt = ((AVFrameFormat) inputFormat).getPixFmt();\n            srcPicture = ((AVFrame) src).getPtr();\n        }\n        else\n        {\n            srcFmt\n                = (inputFormat instanceof YUVFormat)\n                    ? FFmpeg.PIX_FMT_YUV420P\n                    : getNativeRGBFormat((RGBFormat) inputFormat);\n            srcPicture = 0;\n        }\n\n        swsContext\n            = FFmpeg.sws_getCachedContext(\n                    swsContext,\n                    inputWidth, inputHeight, srcFmt,\n                    outputWidth, outputHeight, dstFmt,\n                    FFmpeg.SWS_BICUBIC);\n\n        if (srcPicture == 0)\n        {\n            FFmpeg.sws_scale(\n                    swsContext,\n                    src, srcFmt, inputWidth, inputHeight, 0, inputHeight,\n                    dst, dstFmt, outputWidth, outputHeight);\n        }\n        else\n        {\n            FFmpeg.sws_scale(\n                    swsContext,\n                    srcPicture, 0, inputHeight,\n                    dst, dstFmt, outputWidth, outputHeight);\n        }\n\n        output.setData(dst);\n        output.setDuration(input.getDuration());\n        output.setFlags(input.getFlags());\n        output.setFormat(outputFormat);\n        output.setLength(dstLength);\n        output.setOffset(0);\n        output.setSequenceNumber(input.getSequenceNumber());\n        output.setTimeStamp(input.getTimeStamp());\n\n        // flags\n        int inFlags = input.getFlags();\n        int outFlags = output.getFlags();\n\n        if ((inFlags & Buffer.FLAG_LIVE_DATA) != 0)\n            outFlags |= Buffer.FLAG_LIVE_DATA;\n        if ((inFlags & Buffer.FLAG_NO_WAIT) != 0)\n            outFlags |= Buffer.FLAG_NO_WAIT;\n        if ((inFlags & Buffer.FLAG_RELATIVE_TIME) != 0)\n            outFlags |= Buffer.FLAG_RELATIVE_TIME;\n        if ((inFlags & Buffer.FLAG_RTP_TIME) != 0)\n            outFlags |= Buffer.FLAG_RTP_TIME;\n        if ((inFlags & Buffer.FLAG_SYSTEM_TIME) != 0)\n            outFlags |= Buffer.FLAG_SYSTEM_TIME;\n        output.setFlags(outFlags);\n\n        return BUFFER_PROCESSED_OK;\n    }","commit_id":"ee69f66fe49880758a639a3336df1b32e7175c5d","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Sets the output size.\n     *\n     * @param size the size to set as the output size\n     */\n    public void setOutputSize(Dimension size)\n    {\n        if(size == null)\n            size = new Dimension(640, 480);\n\n        supportedOutputFormats[0]\n            = new YUVFormat(size, -1, Format.byteArray, -1.0f,\n                    YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[1]\n            = new YUVFormat(size, -1, Format.intArray, -1.0f, YUVFormat.YUV_420,\n                    -1, -1, 0, -1, -1);\n        supportedOutputFormats[2]\n            = new YUVFormat(size, -1, Format.shortArray, -1.0f,\n                    YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[3]\n            = new RGBFormat(size, -1, Format.byteArray, -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[4]\n            = new RGBFormat(size, -1, Format.intArray, -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[5]\n            = new RGBFormat(size, -1, Format.shortArray, -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[6]\n            = new RGBFormat(size, -1, Format.byteArray, -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[7]\n            = new RGBFormat(size, -1, Format.intArray, -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[8]\n            = new RGBFormat(size, -1, Format.shortArray, -1.0f, 24, -1, -1, -1);\n\n        // Set the size to the outputFormat as well.\n        VideoFormat outputFormat = (VideoFormat) getOutputFormat();\n\n        /*\n         * Since the size of the Format has changed, its size-related properties\n         * should change as well. Format#intersects doesn't seem to be cool\n         * because it preserves them and thus the resulting Format is\n         * inconsistent.\n         */\n        if (outputFormat instanceof RGBFormat)\n        {\n            RGBFormat rgbOutputFormat = (RGBFormat) outputFormat;\n            Class<?> dataType = outputFormat.getDataType();\n            int bitsPerPixel = rgbOutputFormat.getBitsPerPixel();\n            int pixelStride = rgbOutputFormat.getPixelStride();\n\n            if ((pixelStride == Format.NOT_SPECIFIED)\n                    && (dataType != null)\n                    && (bitsPerPixel != Format.NOT_SPECIFIED))\n                pixelStride\n                    = dataType.equals(Format.byteArray)\n                        ? (bitsPerPixel / 8)\n                        : 1;\n            setOutputFormat(\n                new RGBFormat(\n                        size,\n                        Format.NOT_SPECIFIED,\n                        dataType,\n                        outputFormat.getFrameRate(),\n                        bitsPerPixel,\n                        rgbOutputFormat.getRedMask(),\n                        rgbOutputFormat.getGreenMask(),\n                        rgbOutputFormat.getBlueMask(),\n                        pixelStride,\n                        (pixelStride == Format.NOT_SPECIFIED)\n                            ? Format.NOT_SPECIFIED\n                            : (pixelStride * size.width), // lineStride\n                        rgbOutputFormat.getFlipped(),\n                        rgbOutputFormat.getEndian()));\n        }\n        else if (outputFormat instanceof YUVFormat)\n        {\n            YUVFormat yuvOutputFormat = (YUVFormat) outputFormat;\n\n            setOutputFormat(\n                new YUVFormat(\n                        size,\n                        Format.NOT_SPECIFIED,\n                        outputFormat.getDataType(),\n                        outputFormat.getFrameRate(),\n                        yuvOutputFormat.getYuvType(),\n                        Format.NOT_SPECIFIED,\n                        Format.NOT_SPECIFIED,\n                        0,\n                        Format.NOT_SPECIFIED,\n                        Format.NOT_SPECIFIED));\n        }\n        else if (outputFormat != null)\n            logger.warn(\n                    \"SwScaler outputFormat of type \"\n                        + outputFormat.getClass().getSimpleName()\n                        + \" is not supported for optimized scaling.\");\n    }","id":35894,"modified_method":"/**\n     * Sets the output size.\n     *\n     * @param size the size to set as the output size\n     */\n    public void setOutputSize(Dimension size)\n    {\n        supportedOutputFormats[0]\n            = new YUVFormat(size, -1, Format.byteArray, -1.0f,\n                    YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[1]\n            = new YUVFormat(size, -1, Format.intArray, -1.0f, YUVFormat.YUV_420,\n                    -1, -1, 0, -1, -1);\n        supportedOutputFormats[2]\n            = new YUVFormat(size, -1, Format.shortArray, -1.0f,\n                    YUVFormat.YUV_420, -1, -1, 0, -1, -1);\n        supportedOutputFormats[3]\n            = new RGBFormat(size, -1, Format.byteArray, -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[4]\n            = new RGBFormat(size, -1, Format.intArray, -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[5]\n            = new RGBFormat(size, -1, Format.shortArray, -1.0f, 32, -1, -1, -1);\n        supportedOutputFormats[6]\n            = new RGBFormat(size, -1, Format.byteArray, -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[7]\n            = new RGBFormat(size, -1, Format.intArray, -1.0f, 24, -1, -1, -1);\n        supportedOutputFormats[8]\n            = new RGBFormat(size, -1, Format.shortArray, -1.0f, 24, -1, -1, -1);\n\n        // Set the size to the outputFormat as well.\n        setOutputFormatSize(size);\n    }","commit_id":"ee69f66fe49880758a639a3336df1b32e7175c5d","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public int process(Buffer input, Buffer output) \n    {\n        if (!checkInputBuffer(input))\n        {\n            return BUFFER_PROCESSED_FAILED;\n        }\n\n        if (isEOM(input))\n        {\n            propagateEOM(output);   // TODO: what about data? can there be any?\n            return BUFFER_PROCESSED_OK;\n        }\n        \n        // sometimes format sizes are the same but some other field is different\n        // and jmf use the scaler (in my case length field was not sent in \n        // one of the formats) the check for sizes is made in method\n        // setInputFormat\n        if(!toProcess)\n        {\n            output.setData(input.getData());\n            output.setLength(input.getLength());\n            output.setOffset(input.getOffset());\n            return BUFFER_PROCESSED_OK;\n        }\n        \n        final BufferedImage image = (BufferedImage) bufferToImage.createImage(input);\n        \n        final Dimension inputSize = ((VideoFormat) inputFormat).getSize();\n        final Dimension outputSize = ((VideoFormat) outputFormat).getSize();\n        final double scaleX = ((double) outputSize.width) / ((double) inputSize.width);\n        final double scaleY = ((double) outputSize.height) / ((double) inputSize.height);\n        \n        final BufferedImage scaled = scale(image, scaleX, scaleY);  // TODO: is the size exact?  what about rounding errors?\n        \n//        System.out.println(\"scaled: \" + scaled.getWidth() + \"x\" + scaled.getHeight());\n        final Buffer b = ImageToBuffer.createBuffer(scaled, ((VideoFormat) outputFormat).getFrameRate());\n        output.setData(b.getData());\n        output.setLength(b.getLength());\n        output.setOffset(b.getOffset());\n        output.setFormat(b.getFormat());\n        // TODO: what about format?\n    \n        return BUFFER_PROCESSED_OK;\n\n        \n    }","id":35895,"modified_method":"@Override\n    public int process(Buffer input, Buffer output) \n    {\n        if (!checkInputBuffer(input))\n        {\n            return BUFFER_PROCESSED_FAILED;\n        }\n\n        if (isEOM(input))\n        {\n            propagateEOM(output);   // TODO: what about data? can there be any?\n            return BUFFER_PROCESSED_OK;\n        }\n        \n        // sometimes format sizes are the same but some other field is different\n        // and jmf use the scaler (in my case length field was not sent in \n        // one of the formats) the check for sizes is made in method\n        // setInputFormat\n        if(passthrough)\n        {\n            output.setData(input.getData());\n            output.setLength(input.getLength());\n            output.setOffset(input.getOffset());\n            return BUFFER_PROCESSED_OK;\n        }\n        \n        final BufferedImage image = (BufferedImage) bufferToImage.createImage(input);\n        \n        final Dimension inputSize = ((VideoFormat) inputFormat).getSize();\n        final Dimension outputSize = ((VideoFormat) outputFormat).getSize();\n        final double scaleX = ((double) outputSize.width) / ((double) inputSize.width);\n        final double scaleY = ((double) outputSize.height) / ((double) inputSize.height);\n        \n        final BufferedImage scaled = scale(image, scaleX, scaleY);  // TODO: is the size exact?  what about rounding errors?\n        \n//        System.out.println(\"scaled: \" + scaled.getWidth() + \"x\" + scaled.getHeight());\n        final Buffer b = ImageToBuffer.createBuffer(scaled, ((VideoFormat) outputFormat).getFrameRate());\n        output.setData(b.getData());\n        output.setLength(b.getLength());\n        output.setOffset(b.getOffset());\n        output.setFormat(b.getFormat());\n        // TODO: what about format?\n    \n        return BUFFER_PROCESSED_OK;\n\n        \n    }","commit_id":"a832239300e3479bffad2a955b00bb555e55c44a","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public Format setInputFormat(Format format)\n    {\n        final VideoFormat videoFormat = (VideoFormat) format;\n        if (videoFormat.getSize() == null)\n            return null;    // must set a size.\n        \n//      logger.fine(\"FORMAT: \" + MediaCGUtils.formatToStr(format));\n\n        if(outputFormat != null)\n        {\n            VideoFormat outVFormat = (VideoFormat)outputFormat;\n            if(outVFormat.getSize() != null)\n                toProcess = !outVFormat.getSize().equals(videoFormat.getSize());\n        }\n        \n        // TODO: check VideoFormat and compatibility\n        bufferToImage = new BufferToImage((VideoFormat) format);\n        return super.setInputFormat(format);\n    }","id":35896,"modified_method":"@Override\n    public Format setInputFormat(Format format)\n    {\n        final VideoFormat videoFormat = (VideoFormat) format;\n        if (videoFormat.getSize() == null)\n            return null;    // must set a size.\n        \n        // TODO: check VideoFormat and compatibility\n        bufferToImage = new BufferToImage(videoFormat);\n\n        format = super.setInputFormat(format);\n        updatePassthrough();\n        return format;\n    }","commit_id":"a832239300e3479bffad2a955b00bb555e55c44a","url":"https://github.com/jitsi/jitsi"},{"original_method":"private static boolean askSaveIfModified(LWMap map) {\n        final Object[] defaultOrderButtons = { \"Save\", \"Don't Save\", \"Cancel\"};\n        // oddly, mac aqua is reversing order of these buttons\n        final Object[] macAquaOrderButtons = { \"Cancel\", \"Don't Save\", \"Save\" };\n        \n        if (!map.isModified())\n            return true;\n\n        if (inNativeFullScreen())\n            toggleFullScreen();\n        \n        int response = JOptionPane.showOptionDialog\n        (VUE.getRootParent(),\n        \n        \"Do you want to save the changes you made to \\n\"\n        + \"'\" + map.getLabel() + \"'?\"\n        + (DEBUG.EVENTS?(\"\\n[modifications=\"+map.getModCount()+\"]\"):\"\"),\n        \n        \" Save changes?\",\n        JOptionPane.YES_NO_CANCEL_OPTION,\n        JOptionPane.PLAIN_MESSAGE,\n        null,\n        VueUtil.isMacAquaLookAndFeel() ? macAquaOrderButtons : defaultOrderButtons,\n        \"Save\"\n        );\n        \n        if (VueUtil.isMacAquaLookAndFeel())\n            response = (macAquaOrderButtons.length-1) - response;\n        \n        if (response == JOptionPane.YES_OPTION) { // Save\n            return SaveAction.saveMap(map);\n        } else if (response == JOptionPane.NO_OPTION) { // Don't Save\n            // don't save -- just close\n            return true;\n        } else // anything else (Cancel or dialog window closed)\n            return false;\n    }","id":35897,"modified_method":"private static boolean askSaveIfModified(LWMap map) {\n        final Object[] defaultOrderButtons = { \"Save\", \"Don't Save\", \"Cancel\"};\n        // oddly, mac aqua is reversing order of these buttons\n        final Object[] macAquaOrderButtons = { \"Cancel\", \"Don't Save\", \"Save\" };\n        \n        if (!map.isModified())\n            return true;\n\n        // todo: won't need this if full screen is child of root frame\n        if (inNativeFullScreen())\n            toggleFullScreen();\n        \n        int response = JOptionPane.showOptionDialog\n            (VUE.getDialogParent(),\n        \n             \"Do you want to save the changes you made to \\n\"\n             + \"'\" + map.getLabel() + \"'?\"\n             + (DEBUG.EVENTS?(\"\\n[modifications=\"+map.getModCount()+\"]\"):\"\"),\n        \n             \" Save changes?\",\n             JOptionPane.YES_NO_CANCEL_OPTION,\n             JOptionPane.PLAIN_MESSAGE,\n             null,\n             GUI.isMacAqua() ? macAquaOrderButtons : defaultOrderButtons,\n             \"Save\"\n             );\n        \n        if (GUI.isMacAqua())\n            response = (macAquaOrderButtons.length-1) - response;\n        \n        // If they change focus to another button, then hit \"return\"\n        // (v.s. \"space\" for kbd button press), do action of button\n        // that had focus instead of always save?\n\n        if (response == JOptionPane.YES_OPTION) { // Save\n            return SaveAction.saveMap(map);\n        } else if (response == JOptionPane.NO_OPTION) { // Don't Save\n            // don't save -- just close\n            return true;\n        } else // anything else (Cancel or dialog window closed)\n            return false;\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"public static synchronized void activateWaitCursor() {\n        if (oldRootCursor != null) {\n            out(\"multiple wait-cursors: already have \" + oldRootCursor + \"\\n\");\n            return;\n        }\n        if (getActiveViewer() != null) {\n            waitedViewer = getActiveViewer();\n            oldViewerCursor = waitedViewer.getCursor();\n            waitedViewer.setCursor(CURSOR_WAIT);\n        }\n        JRootPane root = SwingUtilities.getRootPane(VUE.frame);\n        if (root != null) {\n            //out(\"ACTIVATING WAIT CURSOR: current =  \" + oldRootCursor + \"\\n\");\n            oldRootCursor = root.getCursor();\n            root.setCursor(CURSOR_WAIT);\n        }\n    }","id":35898,"modified_method":"public static synchronized void activateWaitCursor() {\n        if (oldRootCursor != null) {\n            if (DEBUG.FOCUS) out(\"multiple wait-cursors: already have \" + oldRootCursor + \"\\n\");\n            return;\n        }\n        if (getActiveViewer() != null) {\n            waitedViewer = getActiveViewer();\n            oldViewerCursor = waitedViewer.getCursor();\n            waitedViewer.setCursor(CURSOR_WAIT);\n        }\n        JRootPane root = SwingUtilities.getRootPane(VUE.ApplicationFrame);\n        if (root != null) {\n            //out(\"ACTIVATING WAIT CURSOR: current =  \" + oldRootCursor + \"\\n\");\n            oldRootCursor = root.getCursor();\n            root.setCursor(CURSOR_WAIT);\n        }\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"private static void _clearWaitCursor() {\n        //out(\"restoring old cursor \" + oldRootCursor + \"\\n\");\n        if (oldRootCursor == null)\n            return;\n        if (waitedViewer != null) {\n            waitedViewer.setCursor(oldViewerCursor);\n            waitedViewer = null;\n        }\n        SwingUtilities.getRootPane(VUE.frame).setCursor(oldRootCursor);\n        oldRootCursor = null;\n    }","id":35899,"modified_method":"private static void _clearWaitCursor() {\n        //out(\"restoring old cursor \" + oldRootCursor + \"\\n\");\n        if (oldRootCursor == null)\n            return;\n        if (waitedViewer != null) {\n            waitedViewer.setCursor(oldViewerCursor);\n            waitedViewer = null;\n        }\n        SwingUtilities.getRootPane(VUE.ApplicationFrame).setCursor(oldRootCursor);\n        oldRootCursor = null;\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"/** return the root VUE component used for parenting */\n    public static Component getRootParent() {\n        return getRootWindow();\n    }","id":35900,"modified_method":"/**\n     * @return the root VUE Frame used for parenting dialogs -- currently always NULL do to java\n     * bugs w/dialogs\n     */\n    \n    // WARNING: opening a dialog appears to cause our full-screen\n    // window as root parent of everything hack to fail and\n    // permit DockWindow's to start going over it -- thus we must\n    // use \"null\" as a parent.  TODO: we'll prob need to do this\n    // for all dialogs...  We can still manually center the\n    // window if we like...\n    // CORRECTION: popping this at ALL seems to do it\n    \n    public static Component getDialogParent() {\n         \t\n        final Component dialogParent;\n\n        // any dialog parent at all in 1.4.2 causes the full-screen\n        // window to go behind the DockWindow's\n        \n        if (Util.getJavaVersion() >= 1.5f)\n            dialogParent = getActiveViewer();\n        else\n            dialogParent = null;\n\n        if (DEBUG.FOCUS) out(\"getDialogParent: \" + dialogParent);\n        \n        return dialogParent;\n\n        /*\n        // this is not helping for preving dialogs from screwing us up and\n        // sending them behind the full-screen window as soon as the dialog pops\n        if (true)\n            // this will put dialogs at screen bottom when it's off-screen\n            return GUI.getFullScreenWindow();\n        else\n            return null;\n        */\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"/**End of overview related method*/\n    \n    static void initUI() {\n        initUI(false);\n    }","id":35901,"modified_method":"static void initUI() {\n        GUI.init(forceWindowsLookAndFeel);\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"static boolean inNativeFullScreen() {\n        return FullScreen.inNativeFullScreen();\n    }","id":35902,"modified_method":"public static boolean inNativeFullScreen() {\n        return FullScreen.inNativeFullScreen();\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"static boolean inFullScreen() {\n        return FullScreen.inFullScreen();\n    }","id":35903,"modified_method":"public static boolean inFullScreen() {\n        return FullScreen.inFullScreen();\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"public static void main(String[] args) {\n        System.out.println(\"VUE: main invoked.\");\n        Logger.getRootLogger().removeAllAppenders(); // need to do this or we get everything twice\n        //BasicConfigurator.configure();\n        Logger.getRootLogger().addAppender(new ConsoleAppender(new PatternLayout(\"VUE [%t] %-5p %c:%x %m%n\")));\n        //Log.addAppender(new ConsoleAppender(new PatternLayout(\"[%t] %-5p %c %x - %m%n\")));\n        Log.setLevel(Level.DEBUG);\n        Log.info(\"build: \" + tufts.vue.Version.AllInfo);\n\n        if (VUE.TUFTS)\n            Log.info(\"TUFTS features only (no MIT/development)\");\n        else\n            Log.info(\"MIT/development features enabled\");\n\n        parseArgs(args);\n\n        // initUI installs the VueTheme (unless mac look), which must be done\n        // before any other GUI code (including the SlpashScreen)\n        // or our VueTheme gets ignored by swing.\n        initUI();\n\n        Window splashScreen = null;\n        if (nodr)\n            DEBUG.Enabled = true;\n        else\n            splashScreen = new SplashScreen();\n\n        //Preferences p = Preferences.userNodeForPackage(VUE.class);\n        //p.put(\"DRBROWSER.RUN\", \"yes, it has\");\n        \n\n        //-------------------------------------------------------\n        // Create the tabbed pane for the viewers\n        //-------------------------------------------------------\n        \n        mMapTabsLeft = new MapTabbedPane(\"*left\");\n        mMapTabsLeft.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsLeft.setPreferredSize(new Dimension(300,400));\n        \n        mMapTabsRight = new MapTabbedPane(\"right\");\n        mMapTabsRight.setTabPlacement(SwingConstants.BOTTOM);\n        mMapTabsRight.setPreferredSize(new Dimension(300,400));\n        \n        //-------------------------------------------------------\n        // create a an application frame and layout components\n        //-------------------------------------------------------\n        \n        toolPanel = new JPanel();\n        //toolPanel.setMinimumSize(new Dimension(329,1)); // until DRBrowser loaded\n        toolPanel.setLayout(new BorderLayout());\n        DRBrowser drBrowser = null;\n        if (nodr == false)  {\n            drBrowser = new DRBrowser(true);\n            //if (VueUtil.isMacAquaLookAndFeel()) drBrowser.setBackground(SystemColor.control);\n            toolPanel.add(drBrowser, BorderLayout.CENTER);\n            \n            /*\n            try {\n                drBrowser = new DRBrowser();\n                toolPanel.add(new DRBrowser(), BorderLayout.CENTER);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                System.err.println(\"DR browser blowing up -- try another day.\");\n            }\n            */\n        }\n\n        \n        JSplitPane splitPane = new JSplitPane();\n        //splitPane.setResizeWeight(0.40); // 25% space to the left component\n        splitPane.setContinuousLayout(false);\n        splitPane.setOneTouchExpandable(true);\n        splitPane.setLeftComponent(toolPanel);\n        //if (VUE.NARRAVISION) splitPane.setDividerLocation(0);\n        //splitPane.setLeftComponent(leftScroller);\n        \n        viewerSplit = new JSplitPane();\n        viewerSplit.setOneTouchExpandable(true);\n        viewerSplit.setRightComponent(mMapTabsRight);\n        // NOTE: set left component AFTER set right component -- the\n        // LAST set left/right call determines the default focus component!\n        // It needs to be the LEFT component as the right one isn't\n        // even visible at startup!\n        viewerSplit.setLeftComponent(mMapTabsLeft);\n        viewerSplit.setResizeWeight(0.5);\n        viewerSplit.setDividerLocation(9999);\n\n        viewerSplit.addPropertyChangeListener(new PropertyChangeListener() {\n                public void propertyChange(PropertyChangeEvent e) {\n                    //System.out.println(\"VS \" + e);\n                    if (!e.getPropertyName().equals(\"dividerLocation\"))\n                        return;\n                    if (DEBUG.FOCUS) out(\"viewerSplit: \" + e.getPropertyName()\n                                       + \"=\" + e.getNewValue().getClass().getName()\n                                       + \" \" + e.getNewValue());\n                    MapViewer leftViewer = null;\n                    MapViewer rightViewer = null;\n                    if (mMapTabsLeft != null)\n                        leftViewer = mMapTabsLeft.getSelectedViewer();\n                    if (mMapTabsRight != null)\n                        rightViewer = mMapTabsRight.getSelectedViewer();\n\n                    if (multipleMapsVisible()) {\n                        /*\n                          // should be handled by MapVewer.reshape\n                        if (leftViewer != null)\n                            leftViewer.fireViewerEvent(MapViewerEvent.PAN);\n                        if (rightViewer != null)\n                            rightViewer.fireViewerEvent(MapViewerEvent.PAN);\n                        */\n                    } else {\n                        if (leftViewer != null && leftViewer != getActiveViewer()) {\n                            if (DEBUG.FOCUS) out(\"viewerSplit: default focus to \" + leftViewer);\n                            leftViewer.requestFocus();\n                            if (rightViewer != null)\n                                rightViewer.fireViewerEvent(MapViewerEvent.HIDDEN);\n                        }\n                    }\n                }});\n        \n        \n        //splitPane.setRightComponent(mMapTabsLeft);\n        splitPane.setRightComponent(viewerSplit);\n        //JPanel vuePanel = new AAPanel();\n        JPanel vuePanel = new JPanel();\n        vuePanel.setLayout(new BorderLayout());\n        vuePanel.add(splitPane, BorderLayout.CENTER);\n\n        if (DEBUG.INIT) out(\"creating VueFrame...\");\n\n        VUE.frame = new VueFrame();\n\n        if (DEBUG.INIT) out(\"created VueFrame\");\n        \n        // Create the tool windows\n        ToolWindow pannerTool = createToolWindow(\"Panner\");\n        pannerTool.setSize(120,120);\n        pannerTool.addTool(new MapPanner());\n\n        if (DEBUG.INIT) out(\"created PannerTool\");\n        \n        ToolWindow inspectorTool = null;\n        /*\n        if (nodr) {\n            inspectorTool = createToolWindow(\"Inspector\");\n            inspectorTool.addTool(new LWCInspector());\n        }\n        */\n        \n        ToolWindow drBrowserTool = null;\n        //DataSourceViewer currently breaks if more than one DRBrowser\n        //ToolWindow drBrowserTool = createToolWindow(\"Data Sources\", frame);\n        //if (drBrowser != null) drBrowserTool.addTool(drBrowser);\n        \n        // The real tool palette window withtools and contextual tools\n        ToolWindow toolbarWindow = null;\n        VueToolbarController tbc = VueToolbarController.getController();\n        ModelSelection.addListener(tbc);\n        /*\n        ToolWindow toolbarWindow = createToolWindow( VueResources.getString(\"tbWindowName\"));\n        tbc.setToolWindow( toolbarWindow);\n        toolbarWindow.getContentPane().add( tbc.getToolbar() );\n        toolbarWindow.pack();\n         */\n\n        //frame.getContentPane().add(tbc.getToolbar(), BorderLayout.NORTH);\n                \n        JPanel toolBarPanel = null;\n\n        if (JIDE_TEST) {\n            /* JIDE ENABLE\n            frame.getDockableBarManager().addDockableBar(new VueToolBar());\n            frame.getDockableBarManager().setShowInitial(false);            \n            frame.getDockableBarManager().resetToDefault();\n            */\n        } else if (true||VUE.TUFTS) {\n            //toolBarPanel = new JPanel();\n            //toolBarPanel.add(tbc.getToolbar());\n            frame.addComp(tbc.getToolbar(), BorderLayout.NORTH);\n        } else {\n\n            //JDialog.setDefaultLookAndFeelDecorated(false);\n            \n            toolBarPanel = new JPanel(new BorderLayout());\n            //toolBarPanel.add(tbc.getToolbar(), BorderLayout.NORTH);\n            JPanel floatingToolbarContainer = new JPanel(new BorderLayout());\n            //JPanel floatingToolbarContainer = new com.jidesoft.action.DockableBarDockableHolderPanel(frame);\n            \n            //floatingToolbarContainer.setPreferredSize(new Dimension(500,50));\n            //floatingToolbarContainer.setMinimumSize(new Dimension(500,5));\n            floatingToolbarContainer.setBackground(Color.orange);\n            VueToolBar vueToolBar = new VueToolBar();\n            floatingToolbarContainer.add(vueToolBar, BorderLayout.PAGE_START);\n            //toolBarPanel.add(new VueToolBar(), BorderLayout.SOUTH);\n            if (false) {\n                // Yes: drop-downs work in a JToolBar (note that our MenuButtons\n                // that are rounded become square tho)\n                JToolBar tb = new JToolBar();\n                tb.add(tbc.getToolbar());\n                toolBarPanel.add(tb);\n            } else {\n                toolBarPanel.add(tbc.getToolbar(), BorderLayout.NORTH);\n            }\n            toolBarPanel.add(floatingToolbarContainer, BorderLayout.SOUTH);\n            frame.addComp(toolBarPanel, BorderLayout.NORTH);\n\n            ////frame.getDockableBarManager().addDockableBar(vueToolBar);\n            \n        }\n\n        if (DEBUG.INIT) out(\"created VueToolBar\");\n        // Map Inspector\n        \n        // get the proper scree/main frame size\n        sMapInspector = createToolWindow(VueResources.getString(\"mapInspectorTitle\"));\n        MapInspectorPanel mi = new MapInspectorPanel();\n        sMapInspector.addTool(mi);\n        \n        //ToolWindow objectInspector = createToolWindow( VueResources.getString(\"objectInspectorTitle\"), frame);\n        objectInspector = createToolWindow(VueResources.getString(\"objectInspectorTitle\"));\n        objectInspectorPanel = new ObjectInspectorPanel();\n        ModelSelection.addListener(objectInspectorPanel);\n        //sResourceSelection.addListener( objectInspectorPanel);\n        objectInspector.addTool(objectInspectorPanel);\n        \n        \n        if (false) {\n            JFrame testFrame = new JFrame(\"Debug\");\n            testFrame.setSize(300,300);\n            //testFrame.getContentPane().add( new NodeInspectorPanel() );\n            testFrame.getContentPane().add(objectInspectorPanel);\n            testFrame.show();\n        }\n        \n        if (DEBUG.INIT) out(\"creating LWOutlineView...\");\n        outlineView = new LWOutlineView(getRootFrame());\n        //outlineView = new LWOutlineView(VUE.frame);\n        \n        VUE.ToolWindows = new ToolWindow[] {\n            objectInspector,\n            sMapInspector,\n            drBrowserTool,\n            toolbarWindow,\n            pannerTool,\n            //htWindow,\n            outlineView,\n            inspectorTool,\n        };\n\n        // adding the menus and toolbars\n        if (DEBUG.INIT) out(\"setting JMenuBar...\");\n        frame.setJMenuBar(VueMenuBar.RootMenuBar = new VueMenuBar(VUE.ToolWindows));\n        if (DEBUG.INIT) out(\"VueMenuBar installed.\");;\n\n        // On Mac, need to set any frame's to have a duplicate\n        // of the main menu bar, so it stay's active at top\n        // when they have focus.\n        if (useMacLAF && VueUtil.isMacPlatform()) {\n            for (int i = 0; i < ToolWindows.length; i++) {\n                ToolWindow toolWindow = VUE.ToolWindows[i];\n                if (toolWindow == null)\n                    continue;\n                Window w = toolWindow.getWindow();\n\n                if (w instanceof JFrame) {\n                    if (nodr) {\n                        // we're hitting bug in java 1.4.2 on Tiger here (apple.laf.ScreenMenuBar bounds exception)\n                        // Mysteriously, it only happens using the debug option -nodr for no DR browser.\n                        if (DEBUG.INIT) out(\"adding menu bar to \" + w);\n                    }\n                    try {\n                        ((JFrame)w).setJMenuBar(new VueMenuBar(ToolWindows));\n                    } catch (ArrayIndexOutOfBoundsException e) {\n                        Log.error(\"OSX TIGER JAVA BUG\", e);\n                    }\n                    toolWindow.setProcessKeyBindingsToMenuBar(false);\n                }\n            }\n            if (DEBUG.INIT) out(\"Mac ToolWindow VueMenuBar's installed.\");\n        }\n        \n        frame.addComp(vuePanel,BorderLayout.CENTER);\n        //frame.getContentPane().setBackground(Color.red);\n        //frame.setContentPane(vuePanel);\n        //frame.setContentPane(splitPane);\n        //frame.setBackground(Color.white);\n        try {\n            frame.pack();\n        } catch (ArrayIndexOutOfBoundsException e) {\n            Log.error(\"OSX TIGER JAVA BUG at frame.pack()\", e);\n        }\n        if (nodr) {\n            frame.setSize(750,450);\n        } else {\n            frame.setSize(800,600);// todo: make % of screen, make sure tool windows below don't go off screen!\n        }\n        if (DEBUG.INIT) out(\"validating frame...\");\n        frame.validate();\n        if (DEBUG.INIT) out(\"frame validated\");\n\n        VueUtil.centerOnScreen(frame);\n        frame.setExtendedState(Frame.MAXIMIZED_BOTH);\n        \n        // position inspectors pased on frame location\n        //int inspectorx = frame.getX() + frame.getWidth() - sMapInspector.getWidth();\n        int inspectorx = frame.getX() + frame.getWidth();\n        sMapInspector.suggestLocation(inspectorx, frame.getY());\n        objectInspector.suggestLocation(inspectorx, frame.getY() + sMapInspector.getHeight() );\n        pannerTool.suggestLocation(frame.getX() - pannerTool.getWidth(), frame.getY());\n        \n        frame.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {\n                Log.warn(e);\n                ExitAction.exitVue();\n                //-------------------------------------------------------\n                // if we get here, it means exit was aborted.\n                // (something wasn't saved & they decided to cancel or\n                // there was an error during the save)\n                //-------------------------------------------------------\n                //frame.show(); not working!  How to cancel this\n                // windowClose?  According to WindowEvent.java &\n                // WindowAdapter.java, canceling this windowClosing is\n                // supposed to be possible, but they don't mention\n                // how. Anyway, we've overriden setVisible on VueFrame\n                // to make it impossible to hide it, and that works,\n                // so this event just becomes the they've pressed on\n                // the close button event.\n                return;\n            }\n            public void windowClosed(WindowEvent e) {\n                // I've never see us even get this event...\n                Log.fatal(\"Too late: window disposed: exiting. \" + e);\n                System.exit(-1);\n            }\n            public void windowStateChanged(WindowEvent e) {\n                Log.debug(e);\n            }\n        });\n\n        VUE.isStartupUnderway = false;\n        \n        if (!nodr) {\n            LWMap startupMap = null;\n            try {\n                final java.net.URL startupURL;\n                startupURL = VueResources.getURL(\"resource.startmap\");\n                startupMap = OpenAction.loadMap(startupURL);\n                startupMap.setFile(null); // dissassociate startup map from it's file so we don't write over it\n                startupMap.setLabel(\"Welcome\");\n                startupMap.markAsSaved();\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                VueUtil.alert(null, \"Cannot load the Start-up map\", \"Start Up Map Error\");\n            }\n\n            try {\n                if (startupMap != null)\n                    displayMap(startupMap);\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                VueUtil.alert(null, \"Failed to display Start-up Map\", \"Internal Error\");\n            }\n            \n        } else {\n            //pannerTool.setVisible(true);\n        }\n\n        Log.debug(\"showing frame...\");\n        frame.show();\n        if (DEBUG.INIT) out(\"frame visible\");\n        \n        if (splashScreen != null)\n            splashScreen.setVisible(false);\n\n        VUE.activateWaitCursor();\n\n        boolean gotMapFromCommandLine = false;\n        \n        if (args.length > 0) {\n            try {\n                for (int i = 0; i < args.length; i++) {\n                    if (args[i].charAt(0) == '-')\n                        continue;\n                    LWMap map = OpenAction.loadMap(args[i]);\n                    if (map != null) {\n                        displayMap(map);\n                        gotMapFromCommandLine = true;\n                    }\n                }\n            } finally {\n                //VUE.clearWaitCursor();                \n            }\n        }\n        \n        if (nodr && gotMapFromCommandLine == false) {\n            //-------------------------------------------------------\n            // create example map(s)\n            //-------------------------------------------------------\n            //LWMap map1 = new LWMap(\"Map 1\");\n            LWMap map2 = new LWMap(\"Map 2\");\n            \n            //installExampleNodes(map1);\n            installExampleMap(map2);\n            \n            //map1.setFillColor(new Color(255, 255, 192));\n            \n            //displayMap(map1);\n            displayMap(map2);\n            //toolPanel.add(new JLabel(\"Empty Label\"), BorderLayout.CENTER);\n        }\n\n        if (DEBUG.INIT) out(\"map loaded\");\n        if (drBrowser != null) {\n            drBrowser.loadDataSourceViewer();\n            if (VUE.TUFTS) // leave collapsed if NarraVision\n                splitPane.resetToPreferredSizes();\n        }\n\n        Log.debug(\"loading fonts...\");\n        FontEditorPanel.getFontNames();\n        \n        if (nodr == false) {\n            Log.debug(\"caching tool panels...\");\n            NodeTool.getNodeToolPanel();\n            LinkTool.getLinkToolPanel();\n        }\n        \n        if (drBrowser != null && drBrowserTool != null)\n            drBrowserTool.addTool(new DRBrowser());\n\n        if (VueUtil.isMacPlatform())\n            installMacOSXApplicationEventHandlers();\n\n        // MAC v.s. PC WINDOW PARENTAGE & FOCUS BEHAVIOUR:\n        //\n        // Window's that are shown before their parent's are shown do\n        // NOT adopt a stay-on-top-of-parent behaviour! (at least on\n        // mac).  FURTHERMORE: if you iconfiy the parent and\n        // de-iconify it, the keep-on-top is also lost permanently!\n        // (Even if you hide/show the child window after that) None of\n        // this happens on the PC, only Mac OS X.  Iconifying also\n        // hides the child windows on the PC, but not on Mac.  On the\n        // PC, there's also no automatic way to install the action\n        // behaviours to take effect (the ones in the menu bar) when a\n        // tool window has focus.  Actually, mac appears to do\n        // something smart also: if parent get's MAXIMIZED, it\n        // will return to the keep on top behaviour, but you\n        // have to manually hide/show it to get it back on top.\n        //\n        // Also: for some odd reason, if we use an intermediate\n        // root window as the master parent, the MapPanner display\n        // doesn't repaint itself when dragging it or it's map!\n        \n        getRootWindow().show();\n\n        //out(\"ACTIONTMAP \" + java.util.Arrays.asList(frame.getRootPane().getActionMap().allKeys()));\n        //out(\"INPUTMAP \" + java.util.Arrays.asList(frame.getRootPane().getInputMap().allKeys()));\n        //out(\"\\n\\nACTIONTMAP \" + java.util.Arrays.asList(frame.getActionMap().allKeys()));\n        //out(\"ACTIONTMAP \" + Arrays.asList(VUE.getActiveViewer().getActionMap().allKeys()));\n        //out(\"INPUTMAP \" + Arrays.asList(VUE.getActiveViewer().getInputMap().keys()));\n        //out(\"INPUTMAP \" + Arrays.asList(getInputMap().keys()));\n\n        VUE.clearWaitCursor();\n        \n        Log.info(\"main completed.\");\n\n        if (exitAfterInit)\n            System.exit(0);\n    }","id":35904,"modified_method":"public static void main(String[] args) {\n\n        Log.debug(\"VUE: main entered\");\n        \n        VUE.isStartupUnderway = true;\n\n        parseArgs(args);\n        \n        Log.info(\"startup; build: \" + tufts.vue.Version.AllInfo);\n        \n        try {\n            initApplication(args);\n        } catch (Throwable t) {\n            Util.printStackTrace(t, \"VUE initApplication failed\");\n        }\n\n        VUE.isStartupUnderway = false;\n        \n        Log.info(\"startup completed.\");\n        \n        if (exitAfterInit) {\n            out(\"init completed: exiting\");\n            System.exit(0);\n        }\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"/** return the root VUE window, mainly for those who'd like it to be their parent */\n    public static Window getRootWindow() {\n        return VUE.frame;\n        /*\n        if (true) {\n            return VUE.frame;\n        } else {\n            if (rootWindow == null) {\n                //rootWindow = makeRootFrame();\n                rootWindow = makeRootWindow();\n            }\n            return rootWindow;\n        }\n        */\n    }","id":35905,"modified_method":"/** return the root VUE window, mainly for those who'd like it to be their parent */\n    public static Window getRootWindow() {\n        return VUE.ApplicationFrame;\n        /*\n        if (true) {\n            return VUE.frame;\n        } else {\n            if (rootWindow == null) {\n                //rootWindow = makeRootFrame();\n                rootWindow = makeRootWindow();\n            }\n            return rootWindow;\n        }\n        */\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"static protected void out(Object o) {\n        Log.info(o == null ? \"null\" : o.toString());\n    }","id":35906,"modified_method":"static protected void out(Object o) {\n        System.out.println(o == null ? \"null\" : o.toString());\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"/** Return the main VUE window.  Usually == getRoowWindow, unless we're\n     * using a special root window for parenting the tool windows.\n     */\n    // todo: wanted package private\n    public static Window getMainWindow() {\n        return VUE.frame;\n    }","id":35907,"modified_method":"/** Return the main VUE window.  Usually == getRoowWindow, unless we're\n     * using a special root window for parenting the tool windows.\n     */\n    // todo: wanted package private\n    public static Window getMainWindow() {\n        return VUE.ApplicationFrame;\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Create a new viewer and display the given map in it.\n     */\n    public static MapViewer displayMap(LWMap pMap) {\n        NDC.push(\"displayMap\");\n        out(pMap);\n        MapViewer leftViewer = null;\n        MapViewer rightViewer = null;\n        \n        for (int i = 0; i < mMapTabsLeft.getTabCount(); i++) {\n            LWMap map = mMapTabsLeft.getMapAt(i);\n            if (map == null)\n                continue;\n            File existingFile = map.getFile();\n            if (existingFile != null && existingFile.equals(pMap.getFile())) {\n                Log.error(\"** found open map with same file! \" + map);\n                // TODO: pop dialog asking to revert existing if there any changes.\n                //break;\n            }\n        }\n        \n        if (leftViewer == null) {\n            leftViewer = new MapViewer(pMap, \"*LEFT\");\n            rightViewer = new MapViewer(pMap, \"right\");\n            rightViewer.setFocusable(false); // so doesn't grab focus till we're ready\n\n            out(\"currently active viewer: \" + getActiveViewer());\n            out(\"created new left viewer: \" + leftViewer);\n\n            mMapTabsLeft.addViewer(leftViewer);\n            mMapTabsRight.addViewer(rightViewer);\n        }\n        \n        mMapTabsLeft.setSelectedComponent(leftViewer);\n\n        NDC.pop();\n        return leftViewer;\n    }","id":35908,"modified_method":"/**\n     * Create a new viewer and display the given map in it.\n     */\n    public static MapViewer displayMap(LWMap pMap) {\n        NDC.push(\"displayMap\");\n        if (DEBUG.INIT) out(pMap.toString());\n        MapViewer leftViewer = null;\n        MapViewer rightViewer = null;\n        \n        for (int i = 0; i < mMapTabsLeft.getTabCount(); i++) {\n            LWMap map = mMapTabsLeft.getMapAt(i);\n            if (map == null)\n                continue;\n            File existingFile = map.getFile();\n            if (existingFile != null && existingFile.equals(pMap.getFile())) {\n                Log.error(\"** found open map with same file! \" + map);\n                // TODO: pop dialog asking to revert existing if there any changes.\n                //break;\n            }\n        }\n\n        \n        if (leftViewer == null) {\n            leftViewer = new MapViewer(pMap, \"*LEFT\");\n            rightViewer = new MapViewer(pMap, \"right\");\n\n            if (isActiveViewerOnLeft())\n                rightViewer.setFocusable(false); // so doesn't grab focus till we're ready\n\n            if (DEBUG.FOCUS) {\n                out(\"currently active viewer: \" + getActiveViewer());\n                out(\"created new left viewer: \" + leftViewer);\n            }\n\n            mMapTabsLeft.addViewer(leftViewer);\n            mMapTabsRight.addViewer(rightViewer);\n        }\n        \n        if (isActiveViewerOnLeft())\n            mMapTabsLeft.setSelectedComponent(leftViewer);\n        else\n            mMapTabsRight.setSelectedComponent(rightViewer);\n\n        NDC.pop();\n        return leftViewer;\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * If any open maps have been modified and not saved, run\n     * dialogs to determine what to do.\n     * @return true if we're cleared to exit, false if we want to abort the exit\n     */\n    public static boolean isOkayToExit() {\n        int tabs = mMapTabsLeft.getTabCount();\n        for (int i = 0; i < tabs; i++)\n            if (!askSaveIfModified(mMapTabsLeft.getMapAt(i)))\n                return false;\n        return true;\n    }","id":35909,"modified_method":"/**\n     * If any open maps have been modified and not saved, run\n     * dialogs to determine what to do.\n     * @return true if we're cleared to exit, false if we want to abort the exit\n     */\n    public static boolean isOkayToExit() {\n        int tabs = mMapTabsLeft.getTabCount();\n        LWMap ensureChecked = getActiveMap(); // in case of full-screen\n        for (int i = 0; i < tabs; i++) {\n            LWMap map = mMapTabsLeft.getMapAt(i);\n            if (map == ensureChecked)\n                ensureChecked = null;\n            if (!askSaveIfModified(mMapTabsLeft.getMapAt(i)))\n                return false;\n        }\n        if (ensureChecked != null && !askSaveIfModified(ensureChecked))\n            return false;\n        else\n            return true;\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * If we already have open a map tied to the given file, display it.\n     * Otherwise, open it anew and display it.\n     */\n    public static void displayMap(File mapFile) {\n        out(\"displayMap \" + mapFile);\n        for (int i = 0; i < mMapTabsLeft.getTabCount(); i++) {\n            LWMap map = mMapTabsLeft.getMapAt(i);\n            if (map == null)\n                continue;\n            File existingFile = map.getFile();\n            if (existingFile != null && existingFile.equals(mapFile)) {\n                out(\"displayMap found existing open map \" + map);\n                mMapTabsLeft.setSelectedIndex(i);\n                return;\n            }\n        }\n        OpenAction.displayMap(mapFile);\n    }","id":35910,"modified_method":"/**\n     * If we already have open a map tied to the given file, display it.\n     * Otherwise, open it anew and display it.\n     */\n    public static void displayMap(File mapFile) {\n        if (DEBUG.INIT || DEBUG.IO) out(\"displayMap \" + mapFile);\n        for (int i = 0; i < mMapTabsLeft.getTabCount(); i++) {\n            LWMap map = mMapTabsLeft.getMapAt(i);\n            if (map == null)\n                continue;\n            File existingFile = map.getFile();\n            if (existingFile != null && existingFile.equals(mapFile)) {\n                out(\"displayMap found existing open map \" + map);\n                mMapTabsLeft.setSelectedIndex(i);\n                return;\n            }\n        }\n        OpenAction.displayMap(mapFile);\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"public static boolean multipleMapsVisible() {\n        if (viewerSplit == null)\n            return false;\n        int dl = viewerSplit.getDividerLocation();\n        return dl >= viewerSplit.getMinimumDividerLocation()\n            && dl <= viewerSplit.getMaximumDividerLocation();\n        \n    }","id":35911,"modified_method":"public static boolean multipleMapsVisible() {\n        // TODO: don't think this works in java 1.5\n        if (mViewerSplit == null)\n            return false;\n        int dl = mViewerSplit.getDividerLocation();\n        return dl >= mViewerSplit.getMinimumDividerLocation()\n            && dl <= mViewerSplit.getMaximumDividerLocation();\n        \n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"/** call the given runnable after all pending AWT events are completed */\n    static void invokeAfterAWT(Runnable runnable) {\n        java.awt.EventQueue.invokeLater(runnable);\n    }","id":35912,"modified_method":"/** call the given runnable after all pending AWT events are completed */\n    public static void invokeAfterAWT(Runnable runnable) {\n        java.awt.EventQueue.invokeLater(runnable);\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"public static String getSystemProperty(String name) {\n        // If we're an applet, System.getProperty will trhow an AccessControlException\n        if (false && isApplet())\n            return null;\n        else {\n            String prop;\n            try {\n                prop = System.getProperty(name);\n                if (DEBUG.INIT) {\n                    out(\"got property \" + name);\n                    if (name.equals(\"apple.awt.brushMetalLook\"))\n                        new Throwable(\"apple.awt.brushMetalLook\").printStackTrace();\n                }\n            } catch (java.security.AccessControlException e) {\n                System.err.println(e);\n                prop = null;\n            }\n            return prop;\n        }\n    }","id":35913,"modified_method":"public static String getSystemProperty(String name) {\n        // If we're an applet, System.getProperty will trhow an AccessControlException\n        if (false && isApplet())\n            return null;\n        else {\n            String prop;\n            try {\n                prop = System.getProperty(name);\n                if (DEBUG.INIT) out(\"got property \" + name);\n            } catch (java.security.AccessControlException e) {\n                System.err.println(e);\n                prop = null;\n            }\n            return prop;\n        }\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"public static void parseArgs(String[] args) {\n        String allArgs = \"\";\n        for (int i = 0; i < args.length; i++) {\n            allArgs += \"[\" + args[i] + \"]\";\n            if (args[i].equals(\"-nodr\"))\n                nodr = true;\n            else if (args[i].equals(\"-mac\") || args[i].equals(\"-useMacLookAndFeel\"))\n                useMacLAF = true;\n            else if (args[i].equals(\"-exit_after_init\")) // for startup time trials\n                exitAfterInit = true;\n            else\n                DEBUG.parseArg(args[i]);\n\n            if (args[i].startsWith(\"-debug\")) DEBUG.Enabled = true;\n\n        }\n        out(\"parsed args \" + allArgs);\n    }","id":35914,"modified_method":"public static void parseArgs(String[] args) {\n        String allArgs = \"\";\n        for (int i = 0; i < args.length; i++) {\n            allArgs += \"[\" + args[i] + \"]\";\n            if (args[i].equals(\"-nosplash\")) {\n                SKIP_SPLASH = true;\n            } else if (args[i].equals(\"-nodr\")) {\n                DEBUG.Enabled = true;\n                SKIP_DR = true;\n            } else if (args[i].equals(\"-win\") || args[i].equals(\"-useWindowsLookAndFeel\")) {\n                forceWindowsLookAndFeel = true;\n            } else if (args[i].equals(\"-exit_after_init\")) // for startup time trials\n                exitAfterInit = true;\n            else\n                DEBUG.parseArg(args[i]);\n\n            if (args[i].startsWith(\"-debug\")) DEBUG.Enabled = true;\n\n        }\n        if (DEBUG.INIT) System.out.println(\"VUE: parsed args \" + allArgs);\n    }","commit_id":"ff22041df65584b11760d5c9ea00515585b019ff","url":"https://github.com/VUE/VUE"},{"original_method":"@Override\r\n\tprotected void onResume () {\r\n\t\tif (wakeLock != null) wakeLock.acquire();\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\t\tGdx.net = this.getNet();\r\n\r\n\t\t((AndroidInput)getInput()).registerSensorListeners();\r\n\r\n\t\tif (graphics != null && ((AndroidGraphics)graphics).view != null) {\r\n\t\t\tif (((AndroidGraphics)graphics).view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)((AndroidGraphics)graphics).view).onResume();\r\n\t\t\tif (((AndroidGraphics)graphics).view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)((AndroidGraphics)graphics).view).onResume();\r\n\t\t}\r\n\r\n\t\tif (!firstResume) {\r\n\t\t\tgraphics.resume();\r\n\t\t} else\r\n\t\t\tfirstResume = false;\r\n\t\tsuper.onResume();\r\n\t}","id":35915,"modified_method":"@Override\r\n\tprotected void onResume () {\r\n\t\tif (wakeLock != null) wakeLock.acquire();\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\t\tGdx.net = this.getNet();\r\n\r\n\t\t((AndroidInput)getInput()).registerSensorListeners();\r\n\r\n\t\tif (graphics != null && graphics.view != null) {\r\n\t\t\tif (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)graphics.view).onResume();\r\n\t\t\tif (graphics.view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)graphics.view).onResume();\r\n\t\t}\r\n\r\n\t\tif (!firstResume) {\r\n\t\t\tgraphics.resume();\r\n\t\t} else\r\n\t\t\tfirstResume = false;\r\n\t\tsuper.onResume();\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tprotected void onPause () {\r\n\t\tif (wakeLock != null) wakeLock.release();\r\n\t\tboolean isContinuous = graphics.isContinuousRendering();\r\n\t\tgraphics.setContinuousRendering(true);\r\n\t\tgraphics.pause();\r\n\r\n\t\tinput.unregisterSensorListeners();\r\n\t\t// erase pointer ids. this sucks donkeyballs...\r\n\t\tint[] realId = input.realId;\r\n\t\tfor (int i = 0; i < realId.length; i++)\r\n\t\t\trealId[i] = -1;\r\n\r\n\t\tif (isFinishing()) {\r\n\t\t\tgraphics.clearManagedCaches();\r\n\t\t\tgraphics.destroy();\r\n\t\t}\r\n\t\tgraphics.setContinuousRendering(isContinuous);\r\n\r\n\t\tif (graphics != null && ((AndroidGraphics)graphics).view != null) {\r\n\t\t\tif (((AndroidGraphics)graphics).view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)((AndroidGraphics)graphics).view).onPause();\r\n\t\t\tif (((AndroidGraphics)graphics).view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)((AndroidGraphics)graphics).view).onPause();\r\n\t\t}\r\n\r\n\t\tsuper.onPause();\r\n\t}","id":35916,"modified_method":"@Override\r\n\tprotected void onPause () {\r\n\t\tif (wakeLock != null) wakeLock.release();\r\n\t\tboolean isContinuous = graphics.isContinuousRendering();\r\n\t\tgraphics.setContinuousRendering(true);\r\n\t\tgraphics.pause();\r\n\r\n\t\tinput.unregisterSensorListeners();\r\n\t\t// erase pointer ids. this sucks donkeyballs...\r\n\t\tint[] realId = input.realId;\r\n\t\tfor (int i = 0; i < realId.length; i++)\r\n\t\t\trealId[i] = -1;\r\n\r\n\t\tif (isFinishing()) {\r\n\t\t\tgraphics.clearManagedCaches();\r\n\t\t\tgraphics.destroy();\r\n\t\t}\r\n\t\tgraphics.setContinuousRendering(isContinuous);\r\n\r\n\t\tif (graphics != null && graphics.view != null) {\r\n\t\t\tif (graphics.view instanceof GLSurfaceViewCupcake) ((GLSurfaceViewCupcake)graphics.view).onPause();\r\n\t\t\tif (graphics.view instanceof android.opengl.GLSurfaceView) ((android.opengl.GLSurfaceView)graphics.view).onPause();\r\n\t\t}\r\n\r\n\t\tsuper.onPause();\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get\r\n\t * input, render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create an OpenGL ES 2.0\r\n\t * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be\r\n\t * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the\r\n\t * {@link Graphics#isGL20Available()} method. You can configure other aspects of the application with the rest of the fields in\r\n\t * the {@link AndroidApplicationConfiguration} instance.\r\n\t * \r\n\t * @param listener the {@link ApplicationListener} implementing the program logic\r\n\t * @param config the {@link AndroidApplicationConfiguration}, defining various settings of the application (use accelerometer,\r\n\t *           etc.). */\r\n\tpublic void initialize (ApplicationListener listener, AndroidApplicationConfiguration config) {\r\n\t\tgraphics = new AndroidGraphics(this, config, config.resolutionStrategy == null ? new FillResolutionStrategy()\r\n\t\t\t: config.resolutionStrategy);\r\n\t\tinput = new AndroidInput(this, ((AndroidGraphics)graphics).view, config);\r\n\t\taudio = new AndroidAudio(this, config);\r\n\t\tfiles = new AndroidFiles(this.getAssets(), this.getFilesDir().getAbsolutePath());\r\n\t\tnet = new AndroidNet(this);\r\n\t\tthis.listener = listener;\r\n\t\tthis.handler = new Handler();\r\n\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\t\tGdx.net = this.getNet();\r\n\r\n\t\ttry {\r\n\t\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\r\n\t\t} catch (Exception ex) {\r\n\t\t\tlog(\"AndroidApplication\", \"Content already displayed, cannot request FEATURE_NO_TITLE\", ex);\r\n\t\t}\r\n\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\r\n\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);\r\n\t\tsetContentView(((AndroidGraphics)graphics).getView(), createLayoutParams());\r\n\t\tcreateWakeLock(config);\r\n\t\thideStatusBar(config);\r\n\t}","id":35917,"modified_method":"/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get\r\n\t * input, render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create an OpenGL ES 2.0\r\n\t * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be\r\n\t * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the\r\n\t * {@link Graphics#isGL20Available()} method. You can configure other aspects of the application with the rest of the fields in\r\n\t * the {@link AndroidApplicationConfiguration} instance.\r\n\t * \r\n\t * @param listener the {@link ApplicationListener} implementing the program logic\r\n\t * @param config the {@link AndroidApplicationConfiguration}, defining various settings of the application (use accelerometer,\r\n\t *           etc.). */\r\n\tpublic void initialize (ApplicationListener listener, AndroidApplicationConfiguration config) {\r\n\t\tgraphics = new AndroidGraphics(this, config, config.resolutionStrategy == null ? new FillResolutionStrategy()\r\n\t\t\t: config.resolutionStrategy);\r\n\t\tinput = new AndroidInput(this, this, graphics.view, config);\r\n\t\taudio = new AndroidAudio(this, config);\r\n\t\tfiles = new AndroidFiles(this.getAssets(), this.getFilesDir().getAbsolutePath());\r\n\t\tnet = new AndroidNet(this);\r\n\t\tthis.listener = listener;\r\n\t\tthis.handler = new Handler();\r\n\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\t\tGdx.net = this.getNet();\r\n\r\n\t\ttry {\r\n\t\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\r\n\t\t} catch (Exception ex) {\r\n\t\t\tlog(\"AndroidApplication\", \"Content already displayed, cannot request FEATURE_NO_TITLE\", ex);\r\n\t\t}\r\n\t\tgetWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);\r\n\t\tgetWindow().clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);\r\n\t\tsetContentView(graphics.getView(), createLayoutParams());\r\n\t\tcreateWakeLock(config);\r\n\t\thideStatusBar(config);\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get\r\n\t * input, render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create an OpenGL ES 2.0\r\n\t * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be\r\n\t * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the\r\n\t * {@link Graphics#isGL20Available()} method. You can configure other aspects of the application with the rest of the fields in\r\n\t * the {@link AndroidApplicationConfiguration} instance.\r\n\t * <p/>\r\n\t * Note: you have to add the returned view to your layout!\r\n\t * \r\n\t * @param listener the {@link ApplicationListener} implementing the program logic\r\n\t * @param config the {@link AndroidApplicationConfiguration}, defining various settings of the application (use accelerometer,\r\n\t *           etc.).\r\n\t * @return the GLSurfaceView of the application */\r\n\tpublic View initializeForView (ApplicationListener listener, AndroidApplicationConfiguration config) {\r\n\t\tgraphics = new AndroidGraphics(this, config, config.resolutionStrategy == null ? new FillResolutionStrategy()\r\n\t\t\t: config.resolutionStrategy);\r\n\t\tinput = new AndroidInput(this, ((AndroidGraphics)graphics).view, config);\r\n\t\taudio = new AndroidAudio(this, config);\r\n\t\tfiles = new AndroidFiles(this.getAssets(), this.getFilesDir().getAbsolutePath());\r\n\t\tnet = new AndroidNet(this);\r\n\t\tthis.listener = listener;\r\n\t\tthis.handler = new Handler();\r\n\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\t\tGdx.net = this.getNet();\r\n\r\n\t\tcreateWakeLock(config);\r\n\t\thideStatusBar(config);\r\n\t\treturn ((AndroidGraphics)graphics).getView();\r\n\t}","id":35918,"modified_method":"/** This method has to be called in the {@link Activity#onCreate(Bundle)} method. It sets up all the things necessary to get\r\n\t * input, render via OpenGL and so on. If config.useGL20 is set the AndroidApplication will try to create an OpenGL ES 2.0\r\n\t * context which can then be used via {@link Graphics#getGL20()}. The {@link GL10} and {@link GL11} interfaces should not be\r\n\t * used when OpenGL ES 2.0 is enabled. To query whether enabling OpenGL ES 2.0 was successful use the\r\n\t * {@link Graphics#isGL20Available()} method. You can configure other aspects of the application with the rest of the fields in\r\n\t * the {@link AndroidApplicationConfiguration} instance.\r\n\t * <p/>\r\n\t * Note: you have to add the returned view to your layout!\r\n\t * \r\n\t * @param listener the {@link ApplicationListener} implementing the program logic\r\n\t * @param config the {@link AndroidApplicationConfiguration}, defining various settings of the application (use accelerometer,\r\n\t *           etc.).\r\n\t * @return the GLSurfaceView of the application */\r\n\tpublic View initializeForView (ApplicationListener listener, AndroidApplicationConfiguration config) {\r\n\t\tgraphics = new AndroidGraphics(this, config, config.resolutionStrategy == null ? new FillResolutionStrategy()\r\n\t\t\t: config.resolutionStrategy);\r\n\t\tinput = new AndroidInput(this, this, graphics.view, config);\r\n\t\taudio = new AndroidAudio(this, config);\r\n\t\tfiles = new AndroidFiles(this.getAssets(), this.getFilesDir().getAbsolutePath());\r\n\t\tnet = new AndroidNet(this);\r\n\t\tthis.listener = listener;\r\n\t\tthis.handler = new Handler();\r\n\r\n\t\tGdx.app = this;\r\n\t\tGdx.input = this.getInput();\r\n\t\tGdx.audio = this.getAudio();\r\n\t\tGdx.files = this.getFiles();\r\n\t\tGdx.graphics = this.getGraphics();\r\n\t\tGdx.net = this.getNet();\r\n\r\n\t\tcreateWakeLock(config);\r\n\t\thideStatusBar(config);\r\n\t\treturn graphics.getView();\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"public AndroidAudio (Activity context, AndroidApplicationConfiguration config) {\r\n\t\tsoundPool = new SoundPool(config.maxSimultaneousSounds, AudioManager.STREAM_MUSIC, 100);\r\n\t\tmanager = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);\r\n\t\tcontext.setVolumeControlStream(AudioManager.STREAM_MUSIC);\r\n\t}","id":35919,"modified_method":"public AndroidAudio (Context context, AndroidApplicationConfiguration config) {\r\n\t\tsoundPool = new SoundPool(config.maxSimultaneousSounds, AudioManager.STREAM_MUSIC, 100);\r\n\t\tmanager = (AudioManager)context.getSystemService(Context.AUDIO_SERVICE);\r\n\t\tif(context instanceof Activity) {\r\n\t\t\t((Activity)context).setVolumeControlStream(AudioManager.STREAM_MUSIC);\r\n\t\t}\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void clearManagedCaches () {\r\n\t\tMesh.clearAllMeshes(app);\r\n\t\tTexture.clearAllTextures(app);\r\n\t\tShaderProgram.clearAllShaderPrograms(app);\r\n\t\tFrameBuffer.clearAllFrameBuffers(app);\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", Mesh.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", Texture.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", ShaderProgram.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", FrameBuffer.getManagedStatus());\r\n\t}","id":35920,"modified_method":"public void clearManagedCaches () {\r\n\t\tMesh.clearAllMeshes(app);\r\n\t\tTexture.clearAllTextures(app);\r\n\t\tShaderProgram.clearAllShaderPrograms(app);\r\n\t\tFrameBuffer.clearAllFrameBuffers(app);\r\n\r\n\t\tGdx.app.log(\"AndroidGraphics\", Mesh.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", Texture.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", ShaderProgram.getManagedStatus());\r\n\t\tGdx.app.log(\"AndroidGraphics\", FrameBuffer.getManagedStatus());\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic int getRotation () {\r\n\t\tint orientation = app.getWindowManager().getDefaultDisplay().getOrientation();\r\n\t\tswitch (orientation) {\r\n\t\tcase Surface.ROTATION_0:\r\n\t\t\treturn 0;\r\n\t\tcase Surface.ROTATION_90:\r\n\t\t\treturn 90;\r\n\t\tcase Surface.ROTATION_180:\r\n\t\t\treturn 180;\r\n\t\tcase Surface.ROTATION_270:\r\n\t\t\treturn 270;\r\n\t\tdefault:\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}","id":35921,"modified_method":"@Override\r\n\tpublic int getRotation () {\r\n\t\tif(context instanceof Activity) {\r\n\t\t\tint orientation = ((Activity)context).getWindowManager().getDefaultDisplay().getOrientation();\r\n\t\t\tswitch (orientation) {\r\n\t\t\tcase Surface.ROTATION_0:\r\n\t\t\t\treturn 0;\r\n\t\t\tcase Surface.ROTATION_90:\r\n\t\t\t\treturn 90;\r\n\t\t\tcase Surface.ROTATION_180:\r\n\t\t\t\treturn 180;\r\n\t\t\tcase Surface.ROTATION_270:\r\n\t\t\t\treturn 270;\r\n\t\t\tdefault:\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// FIXME livewallpaper support\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void getTextInput (final TextInputListener listener, final String title, final String text) {\r\n\t\thandle.post(new Runnable() {\r\n\t\t\tpublic void run () {\r\n\t\t\t\tAlertDialog.Builder alert = new AlertDialog.Builder(AndroidInput.this.app);\r\n\t\t\t\talert.setTitle(title);\r\n\t\t\t\tfinal EditText input = new EditText(AndroidInput.this.app);\r\n\t\t\t\tinput.setText(text);\r\n\t\t\t\tinput.setSingleLine();\r\n\t\t\t\talert.setView(input);\r\n\t\t\t\talert.setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n\t\t\t\t\tpublic void onClick (DialogInterface dialog, int whichButton) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.input(input.getText().toString());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\r\n\t\t\t\t\tpublic void onClick (DialogInterface dialog, int whichButton) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.canceled();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.setOnCancelListener(new OnCancelListener() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onCancel (DialogInterface arg0) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.canceled();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.show();\r\n\t\t\t}\r\n\t\t});\r\n\t}","id":35922,"modified_method":"@Override\r\n\tpublic void getTextInput (final TextInputListener listener, final String title, final String text) {\r\n\t\thandle.post(new Runnable() {\r\n\t\t\tpublic void run () {\r\n\t\t\t\tAlertDialog.Builder alert = new AlertDialog.Builder(context);\r\n\t\t\t\talert.setTitle(title);\r\n\t\t\t\tfinal EditText input = new EditText(context);\r\n\t\t\t\tinput.setText(text);\r\n\t\t\t\tinput.setSingleLine();\r\n\t\t\t\talert.setView(input);\r\n\t\t\t\talert.setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n\t\t\t\t\tpublic void onClick (DialogInterface dialog, int whichButton) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.input(input.getText().toString());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.setNegativeButton(\"Cancel\", new DialogInterface.OnClickListener() {\r\n\t\t\t\t\tpublic void onClick (DialogInterface dialog, int whichButton) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.canceled();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.setOnCancelListener(new OnCancelListener() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onCancel (DialogInterface arg0) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.canceled();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.show();\r\n\t\t\t}\r\n\t\t});\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void setOnscreenKeyboardVisible (final boolean visible) {\r\n// onscreenKeyboard.setVisible(visible);\r\n\t\thandle.post(new Runnable() {\r\n\t\t\tpublic void run () {\r\n\t\t\t\tInputMethodManager manager = (InputMethodManager)app.getSystemService(Context.INPUT_METHOD_SERVICE);\r\n\t\t\t\tif (visible) {\r\n\t\t\t\t\tView view = ((AndroidGraphics)app.getGraphics()).getView();\r\n\t\t\t\t\tview.setFocusable(true);\r\n\t\t\t\t\tview.setFocusableInTouchMode(true);\r\n\t\t\t\t\tmanager.showSoftInput(((AndroidGraphics)app.getGraphics()).getView(), 0);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmanager.hideSoftInputFromWindow(((AndroidGraphics)app.getGraphics()).getView().getWindowToken(), 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}","id":35923,"modified_method":"@Override\r\n\tpublic void setOnscreenKeyboardVisible (final boolean visible) {\r\n// onscreenKeyboard.setVisible(visible);\r\n\t\thandle.post(new Runnable() {\r\n\t\t\tpublic void run () {\r\n\t\t\t\tInputMethodManager manager = (InputMethodManager)context.getSystemService(Context.INPUT_METHOD_SERVICE);\r\n\t\t\t\tif (visible) {\r\n\t\t\t\t\tView view = ((AndroidGraphics)app.getGraphics()).getView();\r\n\t\t\t\t\tview.setFocusable(true);\r\n\t\t\t\t\tview.setFocusableInTouchMode(true);\r\n\t\t\t\t\tmanager.showSoftInput(((AndroidGraphics)app.getGraphics()).getView(), 0);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tmanager.hideSoftInputFromWindow(((AndroidGraphics)app.getGraphics()).getView().getWindowToken(), 0);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void registerSensorListeners () {\r\n\t\tif (config.useAccelerometer) {\r\n\t\t\tmanager = (SensorManager)app.getSystemService(Context.SENSOR_SERVICE);\r\n\t\t\tif (manager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() == 0) {\r\n\t\t\t\taccelerometerAvailable = false;\r\n\t\t\t} else {\r\n\t\t\t\tSensor accelerometer = manager.getSensorList(Sensor.TYPE_ACCELEROMETER).get(0);\r\n\t\t\t\taccelerometerListener = new SensorListener(this.nativeOrientation, this.accelerometerValues, this.magneticFieldValues);\r\n\t\t\t\taccelerometerAvailable = manager.registerListener(accelerometerListener, accelerometer,\r\n\t\t\t\t\tSensorManager.SENSOR_DELAY_GAME);\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\taccelerometerAvailable = false;\r\n\r\n\t\tif (config.useCompass) {\r\n\t\t\tif (manager == null) manager = (SensorManager)app.getSystemService(Context.SENSOR_SERVICE);\r\n\t\t\tSensor sensor = manager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\r\n\t\t\tif (sensor != null) {\r\n\t\t\t\tcompassAvailable = accelerometerAvailable;\r\n\t\t\t\tif (compassAvailable) {\r\n\t\t\t\t\tcompassListener = new SensorListener(this.nativeOrientation, this.accelerometerValues, this.magneticFieldValues);\r\n\t\t\t\t\tcompassAvailable = manager.registerListener(compassListener, sensor, SensorManager.SENSOR_DELAY_GAME);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcompassAvailable = false;\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tcompassAvailable = false;\r\n\t\tGdx.app.log(\"AndroidInput\", \"sensor listener setup\");\r\n\t}","id":35924,"modified_method":"void registerSensorListeners () {\r\n\t\tif (config.useAccelerometer) {\r\n\t\t\tmanager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);\r\n\t\t\tif (manager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() == 0) {\r\n\t\t\t\taccelerometerAvailable = false;\r\n\t\t\t} else {\r\n\t\t\t\tSensor accelerometer = manager.getSensorList(Sensor.TYPE_ACCELEROMETER).get(0);\r\n\t\t\t\taccelerometerListener = new SensorListener(this.nativeOrientation, this.accelerometerValues, this.magneticFieldValues);\r\n\t\t\t\taccelerometerAvailable = manager.registerListener(accelerometerListener, accelerometer,\r\n\t\t\t\t\tSensorManager.SENSOR_DELAY_GAME);\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\taccelerometerAvailable = false;\r\n\r\n\t\tif (config.useCompass) {\r\n\t\t\tif (manager == null) manager = (SensorManager)context.getSystemService(Context.SENSOR_SERVICE);\r\n\t\t\tSensor sensor = manager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\r\n\t\t\tif (sensor != null) {\r\n\t\t\t\tcompassAvailable = accelerometerAvailable;\r\n\t\t\t\tif (compassAvailable) {\r\n\t\t\t\t\tcompassListener = new SensorListener(this.nativeOrientation, this.accelerometerValues, this.magneticFieldValues);\r\n\t\t\t\t\tcompassAvailable = manager.registerListener(compassListener, sensor, SensorManager.SENSOR_DELAY_GAME);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tcompassAvailable = false;\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tcompassAvailable = false;\r\n\t\tGdx.app.log(\"AndroidInput\", \"sensor listener setup\");\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void getPlaceholderTextInput (final TextInputListener listener, final String title, final String placeholder) {\r\n\t\thandle.post(new Runnable() {\r\n\t\t\tpublic void run () {\r\n\t\t\t\tAlertDialog.Builder alert = new AlertDialog.Builder(AndroidInput.this.app);\r\n\t\t\t\talert.setTitle(title);\r\n\t\t\t\tfinal EditText input = new EditText(AndroidInput.this.app);\r\n\t\t\t\tinput.setHint(placeholder);\r\n\t\t\t\tinput.setSingleLine();\r\n\t\t\t\talert.setView(input);\r\n\t\t\t\talert.setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n\t\t\t\t\tpublic void onClick (DialogInterface dialog, int whichButton) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.input(input.getText().toString());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.setOnCancelListener(new OnCancelListener() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onCancel (DialogInterface arg0) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.canceled();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.show();\r\n\t\t\t}\r\n\t\t});\r\n\t}","id":35925,"modified_method":"public void getPlaceholderTextInput (final TextInputListener listener, final String title, final String placeholder) {\r\n\t\thandle.post(new Runnable() {\r\n\t\t\tpublic void run () {\r\n\t\t\t\tAlertDialog.Builder alert = new AlertDialog.Builder(context);\r\n\t\t\t\talert.setTitle(title);\r\n\t\t\t\tfinal EditText input = new EditText(context);\r\n\t\t\t\tinput.setHint(placeholder);\r\n\t\t\t\tinput.setSingleLine();\r\n\t\t\t\talert.setView(input);\r\n\t\t\t\talert.setPositiveButton(\"Ok\", new DialogInterface.OnClickListener() {\r\n\t\t\t\t\tpublic void onClick (DialogInterface dialog, int whichButton) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.input(input.getText().toString());\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.setOnCancelListener(new OnCancelListener() {\r\n\t\t\t\t\t@Override\r\n\t\t\t\t\tpublic void onCancel (DialogInterface arg0) {\r\n\t\t\t\t\t\tGdx.app.postRunnable(new Runnable() {\r\n\t\t\t\t\t\t\t@Override\r\n\t\t\t\t\t\t\tpublic void run () {\r\n\t\t\t\t\t\t\t\tlistener.canceled();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t\talert.show();\r\n\t\t\t}\r\n\t\t});\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"public AndroidInput (AndroidApplication activity, View view, AndroidApplicationConfiguration config) {\r\n\t\tview.setOnKeyListener(this);\r\n\t\tview.setOnTouchListener(this);\r\n\t\tview.setFocusable(true);\r\n\t\tview.setFocusableInTouchMode(true);\r\n\t\tview.requestFocus();\r\n\t\tview.requestFocusFromTouch();\r\n\t\tthis.config = config;\r\n\t\tthis.onscreenKeyboard = new AndroidOnscreenKeyboard(activity, new Handler(), this);\r\n\r\n\t\tfor (int i = 0; i < realId.length; i++)\r\n\t\t\trealId[i] = -1;\r\n\t\thandle = new Handler();\r\n\t\tthis.app = activity;\r\n\t\tthis.sleepTime = config.touchSleepTime;\r\n\t\tint sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);\r\n\t\tif (sdkVersion >= 5)\r\n\t\t\ttouchHandler = new AndroidMultiTouchHandler();\r\n\t\telse\r\n\t\t\ttouchHandler = new AndroidSingleTouchHandler();\r\n\t\thasMultitouch = touchHandler.supportsMultitouch((AndroidApplication)app);\r\n\r\n\t\tvibrator = (Vibrator)activity.getSystemService(Context.VIBRATOR_SERVICE);\r\n\r\n\t\tint rotation = getRotation();\r\n\t\tDisplayMode mode = app.graphics.getDesktopDisplayMode();\r\n\t\tif (((rotation == 0 || rotation == 180) && (mode.width >= mode.height))\r\n\t\t\t|| ((rotation == 90 || rotation == 270) && (mode.width <= mode.height))) {\r\n\t\t\tnativeOrientation = Orientation.Landscape;\r\n\t\t} else {\r\n\t\t\tnativeOrientation = Orientation.Portrait;\r\n\t\t}\r\n\t}","id":35926,"modified_method":"public AndroidInput (Application activity, Context context, View view, AndroidApplicationConfiguration config) {\r\n\t\tif(view != null) {\r\n\t\t\tview.setOnKeyListener(this);\r\n\t\t\tview.setOnTouchListener(this);\r\n\t\t\tview.setFocusable(true);\r\n\t\t\tview.setFocusableInTouchMode(true);\r\n\t\t\tview.requestFocus();\r\n\t\t\tview.requestFocusFromTouch();\r\n\t\t}\r\n\t\tthis.config = config;\r\n\t\tthis.onscreenKeyboard = new AndroidOnscreenKeyboard(context, new Handler(), this);\r\n\r\n\t\tfor (int i = 0; i < realId.length; i++)\r\n\t\t\trealId[i] = -1;\r\n\t\thandle = new Handler();\r\n\t\tthis.app = activity;\r\n\t\tthis.context = context;\r\n\t\tthis.sleepTime = config.touchSleepTime;\r\n\t\tint sdkVersion = Integer.parseInt(android.os.Build.VERSION.SDK);\r\n\t\tif (sdkVersion >= 5)\r\n\t\t\ttouchHandler = new AndroidMultiTouchHandler();\r\n\t\telse\r\n\t\t\ttouchHandler = new AndroidSingleTouchHandler();\r\n\t\thasMultitouch = touchHandler.supportsMultitouch(context);\r\n\r\n\t\tvibrator = (Vibrator)context.getSystemService(Context.VIBRATOR_SERVICE);\r\n\r\n\t\tint rotation = getRotation();\r\n\t\tDisplayMode mode = app.getGraphics().getDesktopDisplayMode();\r\n\t\tif (((rotation == 0 || rotation == 180) && (mode.width >= mode.height))\r\n\t\t\t|| ((rotation == 90 || rotation == 270) && (mode.width <= mode.height))) {\r\n\t\t\tnativeOrientation = Orientation.Landscape;\r\n\t\t} else {\r\n\t\t\tnativeOrientation = Orientation.Portrait;\r\n\t\t}\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void unregisterSensorListeners () {\r\n\t\tif (manager != null) {\r\n\t\t\tif (accelerometerListener != null) {\r\n\t\t\t\tmanager.unregisterListener(accelerometerListener);\r\n\t\t\t\taccelerometerListener = null;\r\n\t\t\t}\r\n\t\t\tif (compassListener != null) {\r\n\t\t\t\tmanager.unregisterListener(compassListener);\r\n\t\t\t\tcompassListener = null;\r\n\t\t\t}\r\n\t\t\tmanager = null;\r\n\t\t}\r\n\t\tGdx.app.log(\"AndroidInput\", \"sensor listener tear down\");\r\n\t}","id":35927,"modified_method":"void unregisterSensorListeners () {\r\n\t\tif (manager != null) {\r\n\t\t\tif (accelerometerListener != null) {\r\n\t\t\t\tmanager.unregisterListener(accelerometerListener);\r\n\t\t\t\taccelerometerListener = null;\r\n\t\t\t}\r\n\t\t\tif (compassListener != null) {\r\n\t\t\t\tmanager.unregisterListener(compassListener);\r\n\t\t\t\tcompassListener = null;\r\n\t\t\t}\r\n\t\t\tmanager = null;\r\n\t\t}\r\n\t\tGdx.app.log(\"AndroidInput\", \"sensor listener tear down\");\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"protected void processEvents () {\r\n\t\tsynchronized (this) {\r\n\t\t\tjustTouched = false;\r\n\r\n\t\t\tif (processor != null) {\r\n\t\t\t\tfinal InputProcessor processor = this.processor;\r\n\r\n\t\t\t\tint len = keyEvents.size();\r\n\t\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\t\tKeyEvent e = keyEvents.get(i);\r\n\t\t\t\t\tcurrentEventTimeStamp = e.timeStamp;\r\n\t\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\tcase KeyEvent.KEY_DOWN:\r\n\t\t\t\t\t\tprocessor.keyDown(e.keyCode);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase KeyEvent.KEY_UP:\r\n\t\t\t\t\t\tprocessor.keyUp(e.keyCode);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase KeyEvent.KEY_TYPED:\r\n\t\t\t\t\t\tprocessor.keyTyped(e.keyChar);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tusedKeyEvents.free(e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlen = touchEvents.size();\r\n\t\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\t\tTouchEvent e = touchEvents.get(i);\r\n\t\t\t\t\tcurrentEventTimeStamp = e.timeStamp;\r\n\t\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\tcase TouchEvent.TOUCH_DOWN:\r\n\t\t\t\t\t\tprocessor.touchDown(e.x, e.y, e.pointer, Buttons.LEFT);\r\n\t\t\t\t\t\tjustTouched = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase TouchEvent.TOUCH_UP:\r\n\t\t\t\t\t\tprocessor.touchUp(e.x, e.y, e.pointer, Buttons.LEFT);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase TouchEvent.TOUCH_DRAGGED:\r\n\t\t\t\t\t\tprocessor.touchDragged(e.x, e.y, e.pointer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tusedTouchEvents.free(e);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tint len = touchEvents.size();\r\n\t\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\t\tTouchEvent e = touchEvents.get(i);\r\n\t\t\t\t\tif (e.type == TouchEvent.TOUCH_DOWN) justTouched = true;\r\n\t\t\t\t\tusedTouchEvents.free(e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlen = keyEvents.size();\r\n\t\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\t\tusedKeyEvents.free(keyEvents.get(i));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (touchEvents.size() == 0) {\r\n\t\t\t\tfor (int i = 0; i < deltaX.length; i++) {\r\n\t\t\t\t\tdeltaX[0] = 0;\r\n\t\t\t\t\tdeltaY[0] = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tkeyEvents.clear();\r\n\t\t\ttouchEvents.clear();\r\n\t\t}\r\n\t}","id":35928,"modified_method":"void processEvents () {\r\n\t\tsynchronized (this) {\r\n\t\t\tjustTouched = false;\r\n\r\n\t\t\tif (processor != null) {\r\n\t\t\t\tfinal InputProcessor processor = this.processor;\r\n\r\n\t\t\t\tint len = keyEvents.size();\r\n\t\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\t\tKeyEvent e = keyEvents.get(i);\r\n\t\t\t\t\tcurrentEventTimeStamp = e.timeStamp;\r\n\t\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\tcase KeyEvent.KEY_DOWN:\r\n\t\t\t\t\t\tprocessor.keyDown(e.keyCode);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase KeyEvent.KEY_UP:\r\n\t\t\t\t\t\tprocessor.keyUp(e.keyCode);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase KeyEvent.KEY_TYPED:\r\n\t\t\t\t\t\tprocessor.keyTyped(e.keyChar);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tusedKeyEvents.free(e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlen = touchEvents.size();\r\n\t\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\t\tTouchEvent e = touchEvents.get(i);\r\n\t\t\t\t\tcurrentEventTimeStamp = e.timeStamp;\r\n\t\t\t\t\tswitch (e.type) {\r\n\t\t\t\t\tcase TouchEvent.TOUCH_DOWN:\r\n\t\t\t\t\t\tprocessor.touchDown(e.x, e.y, e.pointer, Buttons.LEFT);\r\n\t\t\t\t\t\tjustTouched = true;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase TouchEvent.TOUCH_UP:\r\n\t\t\t\t\t\tprocessor.touchUp(e.x, e.y, e.pointer, Buttons.LEFT);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase TouchEvent.TOUCH_DRAGGED:\r\n\t\t\t\t\t\tprocessor.touchDragged(e.x, e.y, e.pointer);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tusedTouchEvents.free(e);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tint len = touchEvents.size();\r\n\t\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\t\tTouchEvent e = touchEvents.get(i);\r\n\t\t\t\t\tif (e.type == TouchEvent.TOUCH_DOWN) justTouched = true;\r\n\t\t\t\t\tusedTouchEvents.free(e);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlen = keyEvents.size();\r\n\t\t\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\t\t\tusedKeyEvents.free(keyEvents.get(i));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (touchEvents.size() == 0) {\r\n\t\t\t\tfor (int i = 0; i < deltaX.length; i++) {\r\n\t\t\t\t\tdeltaX[0] = 0;\r\n\t\t\t\t\tdeltaY[0] = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tkeyEvents.clear();\r\n\t\t\ttouchEvents.clear();\r\n\t\t}\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"public boolean supportsMultitouch (AndroidApplication activity) {\r\n\t\treturn activity.getPackageManager().hasSystemFeature(\"android.hardware.touchscreen.multitouch\");\r\n\t}","id":35929,"modified_method":"public boolean supportsMultitouch (Context activity) {\r\n\t\treturn activity.getPackageManager().hasSystemFeature(\"android.hardware.touchscreen.multitouch\");\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"public boolean supportsMultitouch (AndroidApplication activity) {\r\n\t\treturn false;\r\n\t}","id":35930,"modified_method":"public boolean supportsMultitouch (Context activity) {\r\n\t\treturn false;\r\n\t}","commit_id":"bb7b8e452d17627800ad17da64b0cf9696f67a02","url":"https://github.com/libgdx/libgdx"},{"original_method":"private JComponent buildTopPanel(boolean enablePipette) throws ParseException {\n    final JPanel result = new JPanel(new BorderLayout());\n\n    final JPanel previewPanel = new JPanel(new BorderLayout());\n    if (enablePipette && ColorPipette.isAvailable()) {\n      final JButton pipette = new JButton(PICK);\n      pipette.setFocusable(false);\n      pipette.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          myPicker.myOldColor = getColor();\n          myPicker.pick();\n          //JBPopupFactory.getInstance().createBalloonBuilder(new JLabel(\"Press ESC button to close pipette\"))\n          //  .setAnimationCycle(2000)\n          //  .setSmallVariant(true)\n          //  .createBalloon().show(new RelativePoint(pipette, new Point(pipette.getWidth() / 2, 0)), Balloon.Position.above);\n        }\n      });\n      previewPanel.add(pipette, BorderLayout.WEST);\n    }\n\n    myPreviewComponent = new ColorPreviewComponent();\n    previewPanel.add(myPreviewComponent, BorderLayout.CENTER);\n\n    result.add(previewPanel, BorderLayout.NORTH);\n\n    final JPanel rgbPanel = new JPanel();\n    rgbPanel.setLayout(new BoxLayout(rgbPanel, BoxLayout.X_AXIS));\n    rgbPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));\n    rgbPanel.add(new JLabel(\"R:\"));\n    rgbPanel.add(Box.createHorizontalStrut(2));\n    rgbPanel.add(myRed);\n    rgbPanel.add(Box.createHorizontalStrut(5));\n    rgbPanel.add(new JLabel(\"G:\"));\n    rgbPanel.add(Box.createHorizontalStrut(2));\n    rgbPanel.add(myGreen);\n    rgbPanel.add(Box.createHorizontalStrut(5));\n    rgbPanel.add(new JLabel(\"B:\"));\n    rgbPanel.add(Box.createHorizontalStrut(2));\n    rgbPanel.add(myBlue);\n\n    result.add(rgbPanel, BorderLayout.WEST);\n\n    final JPanel hexPanel = new JPanel();\n    hexPanel.setLayout(new BoxLayout(hexPanel, BoxLayout.X_AXIS));\n    hexPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));\n    hexPanel.add(new JLabel(\"#:\"));\n    hexPanel.add(Box.createHorizontalStrut(3));\n    hexPanel.add(myHex);\n\n    result.add(hexPanel, BorderLayout.EAST);\n\n    return result;\n  }","id":35931,"modified_method":"private JComponent buildTopPanel(boolean enablePipette) throws ParseException {\n    final JPanel result = new JPanel(new BorderLayout());\n\n    final JPanel previewPanel = new JPanel(new BorderLayout());\n    if (enablePipette && ColorPipette.isAvailable()) {\n      final JButton pipette = new JButton();\n      pipette.setUI(new BasicButtonUI());\n      pipette.setRolloverEnabled(true);\n      pipette.setIcon(PICK);\n      pipette.setBorder(IdeBorderFactory.createEmptyBorder(0));\n      pipette.setRolloverIcon(PICK_ROLLOVER);\n      pipette.setFocusable(false);\n      pipette.addActionListener(new ActionListener() {\n        @Override\n        public void actionPerformed(ActionEvent e) {\n          myPicker.myOldColor = getColor();\n          myPicker.pick();\n          //JBPopupFactory.getInstance().createBalloonBuilder(new JLabel(\"Press ESC button to close pipette\"))\n          //  .setAnimationCycle(2000)\n          //  .setSmallVariant(true)\n          //  .createBalloon().show(new RelativePoint(pipette, new Point(pipette.getWidth() / 2, 0)), Balloon.Position.above);\n        }\n      });\n      previewPanel.add(pipette, BorderLayout.WEST);\n    }\n\n    myPreviewComponent = new ColorPreviewComponent();\n    previewPanel.add(myPreviewComponent, BorderLayout.CENTER);\n\n    result.add(previewPanel, BorderLayout.NORTH);\n\n    final JPanel rgbPanel = new JPanel();\n    rgbPanel.setLayout(new BoxLayout(rgbPanel, BoxLayout.X_AXIS));\n    rgbPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));\n    rgbPanel.add(new JLabel(\"R:\"));\n    rgbPanel.add(Box.createHorizontalStrut(2));\n    rgbPanel.add(myRed);\n    rgbPanel.add(Box.createHorizontalStrut(5));\n    rgbPanel.add(new JLabel(\"G:\"));\n    rgbPanel.add(Box.createHorizontalStrut(2));\n    rgbPanel.add(myGreen);\n    rgbPanel.add(Box.createHorizontalStrut(5));\n    rgbPanel.add(new JLabel(\"B:\"));\n    rgbPanel.add(Box.createHorizontalStrut(2));\n    rgbPanel.add(myBlue);\n\n    result.add(rgbPanel, BorderLayout.WEST);\n\n    final JPanel hexPanel = new JPanel();\n    hexPanel.setLayout(new BoxLayout(hexPanel, BoxLayout.X_AXIS));\n    hexPanel.setBorder(BorderFactory.createEmptyBorder(10, 0, 0, 0));\n    hexPanel.add(new JLabel(\"#:\"));\n    hexPanel.add(Box.createHorizontalStrut(3));\n    hexPanel.add(myHex);\n\n    result.add(hexPanel, BorderLayout.EAST);\n\n    return result;\n  }","commit_id":"5e8638bcb12bf361339113dff6ad54df179a203a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ColorPicker(Disposable parent, @Nullable Color color, boolean restoreColors, boolean enableOpacity) {\n    myUpdateQueue = new Alarm(Alarm.ThreadToUse.SWING_THREAD, parent);\n    myRed = createColorField(false);\n    myGreen = createColorField(false);\n    myBlue = createColorField(false);\n    myHex = createColorField(true);\n    setLayout(new BorderLayout());\n    setBorder(BorderFactory.createEmptyBorder(5, 5, 0, 5));\n\n    myColorWheelPanel = new ColorWheelPanel(this, enableOpacity);\n    myPicker = new ColorPipette(this, getColor());\n    myPicker.setListener(new ColorListener() {\n      @Override\n      public void colorChanged(Color color, Object source) {\n        setColor(color, source);\n      }\n    });\n    try {\n      add(buildTopPanel(true), BorderLayout.NORTH);\n      add(myColorWheelPanel, BorderLayout.CENTER);\n\n      myRecentColorsComponent = new RecentColorsComponent(new ColorListener() {\n        @Override\n        public void colorChanged(Color color, Object source) {\n          setColor(color, source);\n        }\n      }, restoreColors);\n\n      add(myRecentColorsComponent, BorderLayout.SOUTH);\n    }\n    catch (ParseException ignore) {\n    }\n\n    Color c = color == null ? myRecentColorsComponent.getMostRecentColor() : color;\n    if (c == null) {\n      c = Color.WHITE;\n    }\n    setColor(c, this);\n\n    setSize(300, 350);\n  }","id":35932,"modified_method":"private ColorPicker(Disposable parent, @Nullable Color color, boolean restoreColors, boolean enableOpacity) {\n    myUpdateQueue = new Alarm(Alarm.ThreadToUse.SWING_THREAD, parent);\n    myRed = createColorField(false);\n    myGreen = createColorField(false);\n    myBlue = createColorField(false);\n    myHex = createColorField(true);\n    setLayout(new BorderLayout());\n    setBorder(BorderFactory.createEmptyBorder(5, 5, 0, 5));\n\n    myColorWheelPanel = new ColorWheelPanel(this, enableOpacity);\n\n    myRGB = new JRadioButton(\"RGB\", true);\n    myHSB = new JRadioButton(\"HSB\", false);\n    final ButtonGroup group = new ButtonGroup();\n    myRGB.getModel().setGroup(group);\n    myHSB.getModel().setGroup(group);\n\n\n    myPicker = new ColorPipette(this, getColor());\n    myPicker.setListener(new ColorListener() {\n      @Override\n      public void colorChanged(Color color, Object source) {\n        setColor(color, source);\n      }\n    });\n    try {\n      add(buildTopPanel(true), BorderLayout.NORTH);\n      add(myColorWheelPanel, BorderLayout.CENTER);\n\n      myRecentColorsComponent = new RecentColorsComponent(new ColorListener() {\n        @Override\n        public void colorChanged(Color color, Object source) {\n          setColor(color, source);\n        }\n      }, restoreColors);\n\n      add(myRecentColorsComponent, BorderLayout.SOUTH);\n    }\n    catch (ParseException ignore) {\n    }\n\n    Color c = color == null ? myRecentColorsComponent.getMostRecentColor() : color;\n    if (c == null) {\n      c = Color.WHITE;\n    }\n    setColor(c, this);\n\n    setSize(300, 350);\n  }","commit_id":"5e8638bcb12bf361339113dff6ad54df179a203a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static void init(AbstractButton b, String key)\n    {\n        if (key == null) {\n            // from an action init w/no action command\n            VueButtonIcon.installGenerated(b, b.getIcon(), null);\n        } else {\n            installResourceConfiguration(b, key);\n        }\n\n        if (true) {\n            b.setBorder(null);\n            b.setBorderPainted(false);\n            b.setFocusable(false);\n            b.setOpaque(false);\n        }\n\n        if (b.getIcon() != null) {\n            Dimension imageSize = new Dimension(b.getIcon().getIconWidth(), b.getIcon().getIconHeight());\n            //System.out.println(b + \" icon size is \" + VueUtil.out(imageSize));\n            b.setPreferredSize(imageSize);\n        } else {\n            //if (DEBUG.Enabled) System.out.println(b + \" init\");\n        }\n\n        //setBackground(Color.white);\n        //setBackground(Color.red);\n        if (DEBUG.INIT) System.out.println(\"Created new \" + b);\n        //if (true||DEBUG.SELECTION&&DEBUG.META) new Throwable().printStackTrace();\n    }","id":35933,"modified_method":"static void init(AbstractButton b, String key)\n    {\n        if (key == null) {\n            // from an action init w/no action command\n            VueButtonIcon.installGenerated(b, b.getIcon(), null);\n        } else {\n            installResourceConfiguration(b, key);\n        }\n\n        b.setFocusable(false);\n        b.setName(key);\n        \n        if (false && GUI.isOceanTheme()) {\n            //b.setRolloverEnabled(true);\n            // todo: need some kind of border, but then will need\n            // to change rollover icon (or maybe change border\n            // on rollover instead of changing icon)\n            b.setBorder(new LineBorder(Color.blue));\n        } else {\n            b.setBorder(null);\n            b.setBorderPainted(false);\n            b.setOpaque(false);\n        }\n\n        if (b.getIcon() != null) {\n            Dimension imageSize = new Dimension(b.getIcon().getIconWidth(), b.getIcon().getIconHeight());\n            //System.out.println(b + \" icon size is \" + VueUtil.out(imageSize));\n            b.setPreferredSize(imageSize);\n        } else {\n            //if (DEBUG.Enabled) System.out.println(b + \" init\");\n        }\n\n        //setBackground(Color.white);\n        //setBackground(Color.red);\n        if (DEBUG.INIT) System.out.println(\"Created new \" + b);\n        //if (true||DEBUG.SELECTION&&DEBUG.META) new Throwable().printStackTrace();\n    }","commit_id":"0a6750c970af56d8ecb31f04794e278530241e0d","url":"https://github.com/VUE/VUE"},{"original_method":"public String toString() {\n        String label;\n        if (key == null)\n            label = \"action=\" + getText();\n        else\n            label = key;\n        return \"VueButton[\" + label + \"]\";\n    }","id":35934,"modified_method":"public String toString() {\n        String label;\n        if (key == null) {\n            if (getAction() == null)\n                label = \"txt=\" + getText();\n            else\n                label = getAction().toString();\n        } else\n            label = key;\n        return \"VueButton[\" + label + \"]\";\n    }","commit_id":"0a6750c970af56d8ecb31f04794e278530241e0d","url":"https://github.com/VUE/VUE"},{"original_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n        {\n            return fun.returnType().equals(receiver.type);\n        }","id":35935,"modified_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n        {\n            return fun.returnType().asCQL3Type().equals(receiver.type.asCQL3Type());\n        }","commit_id":"7eae57aeac291799d54d5a1b5a444e27336215f1","url":"https://github.com/apache/cassandra"},{"original_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n        {\n            return type.equals(receiver.type);\n        }","id":35936,"modified_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n        {\n            return type.asCQL3Type().equals(receiver.type.asCQL3Type());\n        }","commit_id":"7eae57aeac291799d54d5a1b5a444e27336215f1","url":"https://github.com/apache/cassandra"},{"original_method":"private static Selector makeSelector(CFDefinition cfDef, RawSelector raw, List<CFDefinition.Name> names, List<ColumnSpecification> metadata) throws InvalidRequestException\n    {\n        if (raw instanceof ColumnIdentifier)\n        {\n            CFDefinition.Name name = cfDef.get((ColumnIdentifier)raw);\n            if (name == null)\n                throw new InvalidRequestException(String.format(\"Undefined name %s in selection clause\", raw));\n            if (metadata != null)\n                metadata.add(name);\n            return new SimpleSelector(addAndGetIndex(name, names), name.type);\n        }\n        else if (raw instanceof RawSelector.WritetimeOrTTL)\n        {\n            RawSelector.WritetimeOrTTL tot = (RawSelector.WritetimeOrTTL)raw;\n            CFDefinition.Name name = cfDef.get(tot.id);\n            if (name == null)\n                throw new InvalidRequestException(String.format(\"Undefined name %s in selection clause\", tot.id));\n            if (name.kind != CFDefinition.Name.Kind.COLUMN_METADATA && name.kind != CFDefinition.Name.Kind.VALUE_ALIAS)\n                throw new InvalidRequestException(String.format(\"Cannot use selection function %s on PRIMARY KEY part %s\", tot.isWritetime ? \"writeTime\" : \"ttl\", name));\n            if (name.type.isCollection())\n                throw new InvalidRequestException(String.format(\"Cannot use selection function %s on collections\", tot.isWritetime ? \"writeTime\" : \"ttl\"));\n\n            if (metadata != null)\n                metadata.add(makeWritetimeOrTTLSpec(cfDef, tot));\n            return new WritetimeOrTTLSelector(addAndGetIndex(name, names), tot.isWritetime);\n        }\n        else\n        {\n            RawSelector.WithFunction withFun = (RawSelector.WithFunction)raw;\n            List<Selector> args = new ArrayList<Selector>(withFun.args.size());\n            for (RawSelector rawArg : withFun.args)\n                args.add(makeSelector(cfDef, rawArg, names, null));\n\n            AbstractType<?> returnType = Functions.getReturnType(withFun.functionName, cfDef.cfm.ksName, cfDef.cfm.cfName);\n            if (returnType == null)\n                throw new InvalidRequestException(String.format(\"Unknown function '%s'\", withFun.functionName));\n            ColumnSpecification spec = makeFunctionSpec(cfDef, withFun, returnType);\n            Function fun = Functions.get(withFun.functionName, args, spec);\n            if (metadata != null)\n                metadata.add(spec);\n            return new FunctionSelector(fun, args);\n        }\n    }","id":35937,"modified_method":"private static Selector makeSelector(CFDefinition cfDef, RawSelector raw, List<CFDefinition.Name> names, List<ColumnSpecification> metadata) throws InvalidRequestException\n    {\n        if (raw instanceof ColumnIdentifier)\n        {\n            CFDefinition.Name name = cfDef.get((ColumnIdentifier)raw);\n            if (name == null)\n                throw new InvalidRequestException(String.format(\"Undefined name %s in selection clause\", raw));\n            if (metadata != null)\n                metadata.add(name);\n            return new SimpleSelector(name.toString(), addAndGetIndex(name, names), name.type);\n        }\n        else if (raw instanceof RawSelector.WritetimeOrTTL)\n        {\n            RawSelector.WritetimeOrTTL tot = (RawSelector.WritetimeOrTTL)raw;\n            CFDefinition.Name name = cfDef.get(tot.id);\n            if (name == null)\n                throw new InvalidRequestException(String.format(\"Undefined name %s in selection clause\", tot.id));\n            if (name.kind != CFDefinition.Name.Kind.COLUMN_METADATA && name.kind != CFDefinition.Name.Kind.VALUE_ALIAS)\n                throw new InvalidRequestException(String.format(\"Cannot use selection function %s on PRIMARY KEY part %s\", tot.isWritetime ? \"writeTime\" : \"ttl\", name));\n            if (name.type.isCollection())\n                throw new InvalidRequestException(String.format(\"Cannot use selection function %s on collections\", tot.isWritetime ? \"writeTime\" : \"ttl\"));\n\n            if (metadata != null)\n                metadata.add(makeWritetimeOrTTLSpec(cfDef, tot));\n            return new WritetimeOrTTLSelector(name.toString(), addAndGetIndex(name, names), tot.isWritetime);\n        }\n        else\n        {\n            RawSelector.WithFunction withFun = (RawSelector.WithFunction)raw;\n            List<Selector> args = new ArrayList<Selector>(withFun.args.size());\n            for (RawSelector rawArg : withFun.args)\n                args.add(makeSelector(cfDef, rawArg, names, null));\n\n            AbstractType<?> returnType = Functions.getReturnType(withFun.functionName, cfDef.cfm.ksName, cfDef.cfm.cfName);\n            if (returnType == null)\n                throw new InvalidRequestException(String.format(\"Unknown function '%s'\", withFun.functionName));\n            ColumnSpecification spec = makeFunctionSpec(cfDef, withFun, returnType);\n            Function fun = Functions.get(withFun.functionName, args, spec);\n            if (metadata != null)\n                metadata.add(spec);\n            return new FunctionSelector(fun, args);\n        }\n    }","commit_id":"7eae57aeac291799d54d5a1b5a444e27336215f1","url":"https://github.com/apache/cassandra"},{"original_method":"public SimpleSelector(int idx, AbstractType<?> type)\n        {\n            this.idx = idx;\n            this.type = type;\n        }","id":35938,"modified_method":"public SimpleSelector(String columnName, int idx, AbstractType<?> type)\n        {\n            this.columnName = columnName;\n            this.idx = idx;\n            this.type = type;\n        }","commit_id":"7eae57aeac291799d54d5a1b5a444e27336215f1","url":"https://github.com/apache/cassandra"},{"original_method":"public WritetimeOrTTLSelector(int idx, boolean isWritetime)\n        {\n            this.idx = idx;\n            this.isWritetime = isWritetime;\n        }","id":35939,"modified_method":"public WritetimeOrTTLSelector(String columnName, int idx, boolean isWritetime)\n        {\n            this.columnName = columnName;\n            this.idx = idx;\n            this.isWritetime = isWritetime;\n        }","commit_id":"7eae57aeac291799d54d5a1b5a444e27336215f1","url":"https://github.com/apache/cassandra"},{"original_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n        {\n            AbstractType<?> returnType = Functions.getReturnType(functionName, receiver.ksName, receiver.cfName);\n            return receiver.type.equals(returnType);\n        }","id":35940,"modified_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n        {\n            AbstractType<?> returnType = Functions.getReturnType(functionName, receiver.ksName, receiver.cfName);\n            return receiver.type.asCQL3Type().equals(returnType.asCQL3Type());\n        }","commit_id":"b72af485f625b734cecaa8556578890f346cd274","url":"https://github.com/apache/cassandra"},{"original_method":"private static boolean isValidType(Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver)\n    {\n        if (!receiver.type.equals(fun.returnType()))\n            return false;\n\n        if (providedArgs.size() != fun.argsType().size())\n            return false;\n\n        for (int i = 0; i < providedArgs.size(); i++)\n        {\n            AssignementTestable provided = providedArgs.get(i);\n\n            // If the concrete argument is a bind variables, it can have any type.\n            // We'll validate the actually provided value at execution time.\n            if (provided == null)\n                continue;\n\n            ColumnSpecification expected = makeArgSpec(receiver, fun, i);\n            if (!provided.isAssignableTo(expected))\n                return false;\n        }\n        return true;\n    }","id":35941,"modified_method":"private static boolean isValidType(Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver)\n    {\n        if (!receiver.type.asCQL3Type().equals(fun.returnType().asCQL3Type()))\n            return false;\n\n        if (providedArgs.size() != fun.argsType().size())\n            return false;\n\n        for (int i = 0; i < providedArgs.size(); i++)\n        {\n            AssignementTestable provided = providedArgs.get(i);\n\n            // If the concrete argument is a bind variables, it can have any type.\n            // We'll validate the actually provided value at execution time.\n            if (provided == null)\n                continue;\n\n            ColumnSpecification expected = makeArgSpec(receiver, fun, i);\n            if (!provided.isAssignableTo(expected))\n                return false;\n        }\n        return true;\n    }","commit_id":"b72af485f625b734cecaa8556578890f346cd274","url":"https://github.com/apache/cassandra"},{"original_method":"private static void validateTypes(Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver) throws InvalidRequestException\n    {\n        if (!receiver.type.equals(fun.returnType()))\n            throw new InvalidRequestException(String.format(\"Type error: cannot assign result of function %s (type %s) to %s (type %s)\", fun.name(), fun.returnType().asCQL3Type(), receiver, receiver.type.asCQL3Type()));\n\n        if (providedArgs.size() != fun.argsType().size())\n            throw new InvalidRequestException(String.format(\"Invalid number of arguments in call to function %s: %d required but %d provided\", fun.name(), fun.argsType().size(), providedArgs.size()));\n\n        for (int i = 0; i < providedArgs.size(); i++)\n        {\n            AssignementTestable provided = providedArgs.get(i);\n\n            // If the concrete argument is a bind variables, it can have any type.\n            // We'll validate the actually provided value at execution time.\n            if (provided == null)\n                continue;\n\n            ColumnSpecification expected = makeArgSpec(receiver, fun, i);\n            if (!provided.isAssignableTo(expected))\n                throw new InvalidRequestException(String.format(\"Type error: %s cannot be passed as argument %d of function %s of type %s\", provided, i, fun.name(), expected.type.asCQL3Type()));\n        }\n    }","id":35942,"modified_method":"private static void validateTypes(Function fun, List<? extends AssignementTestable> providedArgs, ColumnSpecification receiver) throws InvalidRequestException\n    {\n        if (!receiver.type.asCQL3Type().equals(fun.returnType().asCQL3Type()))\n            throw new InvalidRequestException(String.format(\"Type error: cannot assign result of function %s (type %s) to %s (type %s)\", fun.name(), fun.returnType().asCQL3Type(), receiver, receiver.type.asCQL3Type()));\n\n        if (providedArgs.size() != fun.argsType().size())\n            throw new InvalidRequestException(String.format(\"Invalid number of arguments in call to function %s: %d required but %d provided\", fun.name(), fun.argsType().size(), providedArgs.size()));\n\n        for (int i = 0; i < providedArgs.size(); i++)\n        {\n            AssignementTestable provided = providedArgs.get(i);\n\n            // If the concrete argument is a bind variables, it can have any type.\n            // We'll validate the actually provided value at execution time.\n            if (provided == null)\n                continue;\n\n            ColumnSpecification expected = makeArgSpec(receiver, fun, i);\n            if (!provided.isAssignableTo(expected))\n                throw new InvalidRequestException(String.format(\"Type error: %s cannot be passed as argument %d of function %s of type %s\", provided, i, fun.name(), expected.type.asCQL3Type()));\n        }\n    }","commit_id":"b72af485f625b734cecaa8556578890f346cd274","url":"https://github.com/apache/cassandra"},{"original_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n        {\n            return receiver.type.equals(isWritetime ? LongType.instance : Int32Type.instance);\n        }","id":35943,"modified_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n        {\n            return receiver.type.asCQL3Type().equals(isWritetime ? CQL3Type.Native.BIGINT : CQL3Type.Native.INT);\n        }","commit_id":"b72af485f625b734cecaa8556578890f346cd274","url":"https://github.com/apache/cassandra"},{"original_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n    {\n        return receiver.type.equals(type.getType());\n    }","id":35944,"modified_method":"public boolean isAssignableTo(ColumnSpecification receiver)\n    {\n        return receiver.type.asCQL3Type().equals(type);\n    }","commit_id":"b72af485f625b734cecaa8556578890f346cd274","url":"https://github.com/apache/cassandra"},{"original_method":"@Before\n    public void setUp()\n    {\n        this.testUser = RandomStringUtils.randomAlphanumeric(5);\n        this.testSpace = this.testUser + \"Test\";\n\n        this.existingPageName = \"existingPage\";\n        getUtil().loginAsSuperAdmin();\n        getUtil().createPage(this.testSpace, existingPageName, null, null);\n\n        getUtil().createUserAndLogin(this.testUser, \"password\");\n    }","id":35945,"modified_method":"@Before\n    public void setUp()\n    {\n        getUtil().loginAsSuperAdmin();\n        getUtil().createPage(this.testSpace, existingPageName, null, null);\n\n        // Delete the user if it already exists.\n        getUtil().deletePage(\"XWiki\", testUserName);\n\n        getUtil().createUserAndLogin(testUserName, \"password\");\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason = \"See http://jira.xwiki.org/browse/XE-1177\")\n    public void testAutomaticWatchDefaultAndNone()\n    {\n        /*\n         * Scenario 1: 'Default' autowatch mode should watch new and modified documents.\n         */\n        WatchlistUserProfilePage watchlistPage = WatchlistUserProfilePage.gotoPage(this.testUser);\n\n        String newPageName1 = \"testpage\";\n\n        // Ensure the pages are not already watched.\n        Assert.assertFalse(\"The test page should not be already watched when just starting\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, newPageName1));\n        Assert.assertFalse(\"The test page should not be already watched when just starting\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, this.existingPageName));\n\n        // Set to 'default' automatic watch mode.\n        WatchlistPreferencesEditPage preferences = watchlistPage.editPreferences();\n        preferences.setAutomaticWatchDefault();\n        preferences.clickSaveAndContinue();\n\n        // Create the new page and modify the existing one.\n        getUtil().createPage(this.testSpace, newPageName1, null, null);\n        getUtil().gotoPage(this.testSpace, this.existingPageName, \"save\", \"content\", \"Test content\");\n\n        // Go back to watchlist profile.\n        watchlistPage = WatchlistUserProfilePage.gotoPage(this.testUser);\n\n        // Check if they are registered in the watchlist.\n        Assert.assertTrue(\"Newly created page is not watched\",\n            watchlistPage.getWatchlistMacro().isWatched(this.testSpace, newPageName1));\n        Assert.assertTrue(\"Newly created page is not watched\",\n            watchlistPage.getWatchlistMacro().isWatched(this.testSpace, this.existingPageName));\n\n        /*\n         * Scenario 2: 'None' autowatch mode should not watch new or modified documents.\n         */\n        String newPageName2 = \"testpage2\";\n\n        // Cleanup from the previous test. Assume the existing page is unwatched.\n        watchlistPage.getWatchlistMacro().unWatch(this.testSpace, this.existingPageName);\n\n        // Ensure the pages are not already watched.\n        Assert.assertFalse(\"The test page should not be already watched when just starting\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, newPageName2));\n        Assert.assertFalse(\"The test page should not be already watched when just starting\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, this.existingPageName));\n\n        // Set to 'none' automatic watch mode.\n        preferences = watchlistPage.editPreferences();\n        preferences.setAutomaticWatchNone();\n        preferences.clickSaveAndContinue();\n\n        // Create the new page and modify the existing one.\n        getUtil().createPage(this.testSpace, newPageName2, null, null);\n        getUtil().gotoPage(this.testSpace, this.existingPageName, \"save\", \"content\", \"Test content\");\n\n        // Go back to watchlist profile\n        watchlistPage = WatchlistUserProfilePage.gotoPage(this.testUser);\n\n        // Check if it's registered in the watchlist\n        Assert.assertFalse(\"Newly created page is watched even if autowatch is set to 'none'\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, newPageName2));\n        Assert.assertFalse(\"Modified page is watched even if autowatch is set to 'none'\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, this.existingPageName));\n    }","id":35946,"modified_method":"@Test\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason = \"See http://jira.xwiki.org/browse/XE-1177\")\n    public void testAutomaticWatchDefaultAndNone()\n    {\n        /*\n         * Scenario 1: 'Default' autowatch mode should watch new and modified documents.\n         */\n        WatchlistUserProfilePage watchlistPage = WatchlistUserProfilePage.gotoPage(testUserName);\n\n        String newPageName1 = \"testpage\";\n\n        // Ensure the pages are not already watched.\n        Assert.assertFalse(\"The test page should not be already watched when just starting\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, newPageName1));\n        Assert.assertFalse(\"The test page should not be already watched when just starting\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, this.existingPageName));\n\n        // Set to 'default' automatic watch mode.\n        WatchlistPreferencesEditPage preferences = watchlistPage.editPreferences();\n        preferences.setAutomaticWatchDefault();\n        preferences.clickSaveAndContinue();\n\n        // Create the new page and modify the existing one.\n        getUtil().createPage(this.testSpace, newPageName1, null, null);\n        getUtil().gotoPage(this.testSpace, this.existingPageName, \"save\", \"content\", \"Test content\");\n\n        // Go back to watchlist profile.\n        watchlistPage = WatchlistUserProfilePage.gotoPage(testUserName);\n\n        // Check if they are registered in the watchlist.\n        Assert.assertTrue(\"Newly created page is not watched\",\n            watchlistPage.getWatchlistMacro().isWatched(this.testSpace, newPageName1));\n        Assert.assertTrue(\"Newly created page is not watched\",\n            watchlistPage.getWatchlistMacro().isWatched(this.testSpace, this.existingPageName));\n\n        /*\n         * Scenario 2: 'None' autowatch mode should not watch new or modified documents.\n         */\n        String newPageName2 = \"testpage2\";\n\n        // Cleanup from the previous test. Assume the existing page is unwatched.\n        watchlistPage.getWatchlistMacro().unWatch(this.testSpace, this.existingPageName);\n\n        // Ensure the pages are not already watched.\n        Assert.assertFalse(\"The test page should not be already watched when just starting\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, newPageName2));\n        Assert.assertFalse(\"The test page should not be already watched when just starting\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, this.existingPageName));\n\n        // Set to 'none' automatic watch mode.\n        preferences = watchlistPage.editPreferences();\n        preferences.setAutomaticWatchNone();\n        preferences.clickSaveAndContinue();\n\n        // Create the new page and modify the existing one.\n        getUtil().createPage(this.testSpace, newPageName2, null, null);\n        getUtil().gotoPage(this.testSpace, this.existingPageName, \"save\", \"content\", \"Test content\");\n\n        // Go back to watchlist profile\n        watchlistPage = WatchlistUserProfilePage.gotoPage(testUserName);\n\n        // Check if it's registered in the watchlist\n        Assert.assertFalse(\"Newly created page is watched even if autowatch is set to 'none'\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, newPageName2));\n        Assert.assertFalse(\"Modified page is watched even if autowatch is set to 'none'\", watchlistPage\n            .getWatchlistMacro().isWatched(this.testSpace, this.existingPageName));\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void sendNotification(String subscriber, List<WatchListEvent> events, String templateDocument,\n        Date previousFireTime) throws XWikiException\n    {\n        XWikiContext context = contextProvider.get();\n\n        // Get user email\n        XWikiDocument subscriberDocument = context.getWiki().getDocument(subscriber, context);\n        BaseObject userObj = subscriberDocument.getObject(XWIKI_USER_CLASS);\n        String emailAddr = userObj.getStringValue(XWIKI_USER_CLASS_EMAIL_PROP);\n        if (emailAddr == null || emailAddr.length() == 0 || emailAddr.indexOf(\"@\") < 0) {\n            // Invalid email\n            return;\n        }\n\n        List<String> modifiedDocuments = new ArrayList<>();\n        for (WatchListEvent event : events) {\n            if (!modifiedDocuments.contains(event.getPrefixedFullName())) {\n                modifiedDocuments.add(event.getPrefixedFullName());\n            }\n        }\n\n        // Prepare email template (wiki page) context\n        VelocityContext vcontext = new VelocityContext();\n        vcontext.put(XWIKI_USER_CLASS_FIRST_NAME_PROP, userObj.getStringValue(XWIKI_USER_CLASS_FIRST_NAME_PROP));\n        vcontext.put(XWIKI_USER_CLASS_LAST_NAME_PROP, userObj.getStringValue(XWIKI_USER_CLASS_LAST_NAME_PROP));\n        vcontext.put(\"events\", events);\n        vcontext.put(\"xwiki\", new com.xpn.xwiki.api.XWiki(context.getWiki(), context));\n        vcontext.put(\"util\", new com.xpn.xwiki.api.Util(context.getWiki(), context));\n        vcontext.put(\"msg\", context.getMessageTool());\n        vcontext.put(\"modifiedDocuments\", modifiedDocuments);\n        vcontext.put(\"previousFireTime\", previousFireTime);\n        vcontext.put(\"context\", new DeprecatedContext(context));\n        vcontext.put(\"xcontext\", new Context(context));\n        vcontext.put(\"services\", scriptServiceManager);\n\n        // Get wiki's default language (default en)\n        String language = context.getWiki().getXWikiPreference(\"default_language\", \"en\", context);\n\n        // Get mailsenderplugin\n        // FIXME: Use the new mail module instead.\n        MailSenderPlugin emailService = (MailSenderPlugin) context.getWiki().getPlugin(MailSenderPlugin.ID, context);\n        if (emailService == null) {\n            return;\n        }\n\n        // Get from email address from the configuration (default : mailer@xwiki.localdomain.com)\n        String from = getFromAddress();\n\n        // Set email template\n        String template = getTemplateDocument(templateDocument, context);\n\n        // Send message from template\n        emailService.sendMailFromTemplate(template, from, emailAddr, null, null, language, vcontext, context);\n    }","id":35947,"modified_method":"@Override\n    public void sendNotification(String subscriber, List<WatchListEvent> events, String templateDocument,\n        Date previousFireTime) throws XWikiException\n    {\n        Map<String, Object> notificationData = new HashMap<>();\n        notificationData.put(WatchListEventMimeMessageFactory.TEMPLATE_PARAMETER, templateDocument);\n        notificationData.put(PREVIOUS_FIRE_TIME_VARIABLE, previousFireTime);\n\n        try {\n            this.sendNotification(Arrays.asList(subscriber), events, notificationData);\n        } catch (WatchListException e) {\n            throw new XWikiException(\"\", e);\n        }\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        this.xcontext = mock(XWikiContext.class);\n\n        Provider<XWikiContext> contextProvider =\n            mocker.getInstance(new DefaultParameterizedType(null, Provider.class, XWikiContext.class));\n        when(contextProvider.get()).thenReturn(this.xcontext);\n\n        this.xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(this.xcontext.getWiki()).thenReturn(this.xwiki);\n\n        XWikiDocument subscriberDocument = mock(XWikiDocument.class);\n        when(this.xwiki.getDocument(\"subscriber\", this.xcontext)).thenReturn(subscriberDocument);\n\n        this.userObject = mock(BaseObject.class);\n        when(subscriberDocument.getObject(\"XWiki.XWikiUsers\")).thenReturn(this.userObject);\n    }","id":35948,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        this.xcontext = mock(XWikiContext.class);\n\n        Provider<XWikiContext> contextProvider =\n            mocker.getInstance(new DefaultParameterizedType(null, Provider.class, XWikiContext.class));\n        when(contextProvider.get()).thenReturn(this.xcontext);\n\n        this.xwiki = mock(com.xpn.xwiki.XWiki.class);\n        when(this.xcontext.getWiki()).thenReturn(this.xwiki);\n\n        DocumentReferenceResolver<String> defaultDocumentReferenceResolver =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_STRING);\n\n        DocumentReferenceResolver<String> currentmixedResolver =\n            mocker.registerMockComponent(DocumentReferenceResolver.TYPE_STRING, \"currentmixed\");\n\n        EntityReferenceSerializer<String> defaultStringEntityReferenceSerializer =\n            mocker.registerMockComponent(EntityReferenceSerializer.TYPE_STRING);\n\n        Utils.setComponentManager(mocker);\n\n        mockMailSender = mocker.getInstance(MailSender.class);\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void onEvent(Event event, Object source, Object data)\n    {\n        XWikiDocument currentDoc = (XWikiDocument) source;\n        XWikiContext context = (XWikiContext) data;\n\n        // Skip evens that are executed in the context of other event, thus not directly generated by a user.\n        if (observationContext.isIn(AutomaticWatchModeListener.SKIPPED_EVENTS)) {\n            return;\n        }\n\n        // XXX: Probably the code below could go in a separate thread to avoid blocking the save operation and the UI.\n\n        try {\n            // Get a corresponding watchlist event.\n            WatchListEvent watchListEvent = getWatchListEvent(event, currentDoc, context);\n\n            if (watchlistEventMatcher.isEventSkipped(watchListEvent)) {\n                // Stop here if the event is skipped.\n                return;\n            }\n\n            // Get all the realtime notification subscribers.\n            Collection<String> subscribers =\n                store.getSubscribers(DefaultWatchListNotificationCache.REALTIME_INTERVAL_ID);\n            if (subscribers.size() == 0) {\n                // Stop here if no one is interested.\n                return;\n            }\n\n            // Go through each subscriber.\n            for (String subscriber : subscribers) {\n                DocumentReference userReference = resolver.resolve(subscriber);\n                if (userReference.equals(context.getUserReference())) {\n                    // Skip the current user since he does not want to be notified by his own actions.\n                    continue;\n                }\n\n                if (!watchlistEventMatcher.isEventViewable(watchListEvent, subscriber)) {\n                    // Skip events that are not viewable by the subscriber.\n                    continue;\n                }\n\n                // If the current event matches for the current subscriber, notify him.\n                if (watchlistEventMatcher.isEventMatching(watchListEvent, subscriber)) {\n                    List<WatchListEvent> events = Arrays.asList(watchListEvent);\n                    Date previousDate = new Date();\n                    // Use the default template document.\n                    notifier.sendNotification(subscriber, events, null, previousDate);\n                }\n            }\n        } catch (Exception e) {\n            logger.error(\"Failed to send realtime notification to user [{}]\", context.getUserReference(), e);\n        }\n    }","id":35949,"modified_method":"@Override\n    public void onEvent(Event event, Object source, Object data)\n    {\n        XWikiDocument currentDoc = (XWikiDocument) source;\n        XWikiContext context = (XWikiContext) data;\n\n        // Skip evens that are executed in the context of other event, thus not directly generated by a user.\n        if (observationContext.isIn(AutomaticWatchModeListener.SKIPPED_EVENTS)) {\n            return;\n        }\n\n        // Prepare the notification and send it for processing in a separate thread so that the UI does not block.\n\n        try {\n            // Get a corresponding watchlist event.\n            WatchListEvent watchListEvent = getWatchListEvent(event, currentDoc, context);\n\n            // Early optimization since this is not related to a user but to the event itself.\n            if (watchlistEventMatcher.isEventSkipped(watchListEvent)) {\n                // Stop here if the event is skipped.\n                return;\n            }\n\n            // Get all the realtime notification subscribers.\n            Collection<String> subscribers =\n                store.getSubscribers(DefaultWatchListNotificationCache.REALTIME_INTERVAL_ID);\n            if (subscribers.size() == 0) {\n                // Stop here if no one is interested.\n                return;\n            }\n\n            // Build the notification parameters.\n            Map<String, Object> notificationData = new HashMap<>();\n            Date previousFireTime = new Date();\n            notificationData.put(DefaultWatchListNotifier.PREVIOUS_FIRE_TIME_VARIABLE, previousFireTime);\n            notificationData.put(WatchListEventMimeMessageFactory.TEMPLATE_PARAMETER,\n                DefaultWatchListNotifier.DEFAULT_EMAIL_TEMPLATE);\n            notificationData.put(WatchListEventMimeMessageFactory.SKIP_CONTEXT_USER_PARAMETER, true);\n\n            // Send the notification for processing.\n            notifier.sendNotification(subscribers, Arrays.asList(watchListEvent), notificationData);\n        } catch (Exception e) {\n            logger.error(\"Failed to send realtime notification to user [{}]\", context.getUserReference(), e);\n        }\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Method called from the scheduler.\n     * \n     * @param jobContext Context of the request\n     * @throws JobExecutionException if the job execution fails.\n     */\n    @Override\n    public void executeJob(JobExecutionContext jobContext) throws JobExecutionException\n    {\n        try {\n            init(jobContext);\n\n            if (this.watchListJobObject == null) {\n                return;\n            }\n\n            Collection<String> subscribers = getSubscribers();\n\n            // Stop here if nobody is interested.\n            if (!hasSubscribers()) {\n                return;\n            }\n\n            // Determine what happened since the last execution for everybody.\n            Date previousFireTime = getPreviousFireTime();\n            WatchListEventMatcher eventMatcher = Utils.getComponent(WatchListEventMatcher.class);\n            List<WatchListEvent> events = eventMatcher.getEventsSince(previousFireTime);\n            setPreviousFireTime();\n\n            // Stop here if nothing happened in the meantime.\n            if (events.size() == 0) {\n                return;\n            }\n\n            // Notify all interested subscribers, one at a time.\n            for (String subscriber : subscribers) {\n                try {\n                    // Determine what happened since the last execution on the watched elements of the current\n                    // subscriber only.\n                    List<WatchListEvent> matchingEvents = eventMatcher.getMatchingVisibleEvents(events, subscriber);\n                    String userWiki = StringUtils.substringBefore(subscriber, DefaultWatchListStore.WIKI_SPACE_SEP);\n\n                    // If events have occurred on at least one element watched by the user, send the email\n                    if (matchingEvents.size() > 0) {\n                        this.watchlist.getNotifier().sendNotification(subscriber, matchingEvents,\n                            getEmailTemplate(userWiki), previousFireTime);\n                    }\n                } catch (Exception e) {\n                    LOGGER.error(\"Failed to send watchlist notification to user [{}]\", subscriber, e);\n                }\n            }\n        } catch (Exception e) {\n            // We're in a job, we don't throw exceptions\n            LOGGER.error(\"Exception while running job\", e);\n        } finally {\n            this.context.getWiki().getStore().cleanUp(this.context);\n            cleanupComponents();\n        }\n    }","id":35950,"modified_method":"/**\n     * Method called from the scheduler.\n     *\n     * @param jobContext Context of the request\n     * @throws JobExecutionException if the job execution fails.\n     */\n    @Override\n    public void executeJob(JobExecutionContext jobContext) throws JobExecutionException\n    {\n        try {\n            init(jobContext);\n\n            if (this.watchListJobObject == null) {\n                return;\n            }\n\n            Collection<String> subscribers = getSubscribers();\n\n            // Stop here if nobody is interested.\n            if (!hasSubscribers()) {\n                return;\n            }\n\n            // Determine what happened since the last execution for everybody.\n            Date previousFireTime = getPreviousFireTime();\n            WatchListEventMatcher eventMatcher = Utils.getComponent(WatchListEventMatcher.class);\n            List<WatchListEvent> events = eventMatcher.getEventsSince(previousFireTime);\n            setPreviousFireTime();\n\n            // Stop here if nothing happened in the meantime.\n            if (events.size() == 0) {\n                return;\n            }\n\n            // Notify all the interested subscribers of the events that occurred.\n            // When processing the events, a subscriber will only be notified of events that interest him.\n            Map<String, Object> notificationData = new HashMap<>();\n            notificationData.put(DefaultWatchListNotifier.PREVIOUS_FIRE_TIME_VARIABLE, previousFireTime);\n\n            String mailTemplate =\n                this.watchListJobObject.getStringValue(WatchListJobClassDocumentInitializer.TEMPLATE_FIELD);\n            notificationData.put(WatchListEventMimeMessageFactory.TEMPLATE_PARAMETER, mailTemplate);\n\n            // Send the notification for processing.\n            this.watchlist.getNotifier().sendNotification(subscribers, events, notificationData);\n        } catch (Exception e) {\n            // We're in a job, we don't throw exceptions\n            LOGGER.error(\"Exception while running job\", e);\n        } finally {\n            this.context.getWiki().getStore().cleanUp(this.context);\n            cleanupComponents();\n        }\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    @IgnoreBrowsers({\n    @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason = \"See http://jira.xwiki.org/browse/XE-1146\"),\n    @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason = \"See http://jira.xwiki.org/browse/XE-1177\")})\n    public void testWatchThisPageAndWholeSpace() throws Exception\n    {\n        // Clear the list of watched documents and spaces\n        getUtil().updateObject(\"XWiki\", this.watchlistPage.getUsername(), \"XWiki.WatchListClass\", 0, \"spaces\", \"\",\n            \"documents\", \"\");\n\n        // Watch Test.TestWatchThisPage\n        ViewPage page = getUtil().createPage(\"Test\", \"TestWatchThisPage\", \"TestWatchThisPage ui\", null);\n        page.watchDocument();\n\n        // Watch TestWatchWholeSpace.Test1\n        page = getUtil().createPage(\"TestWatchWholeSpace\", \"Test1\", \"TestWatchWholeSpace ui\", null);\n        page.watchSpace();\n\n        // Verify that the watched page & space are present in the watchlist manager\n        this.watchlistPage = WatchlistUserProfilePage.gotoPage(this.watchlistPage.getUsername());\n        Assert.assertTrue(this.watchlistPage.getWatchlistMacro().isWatched(\"Test\", \"TestWatchThisPage\"));\n        Assert.assertTrue(this.watchlistPage.getWatchlistMacro().isWatched(\"TestWatchWholeSpace\"));\n\n        // Ensure that the watchlist notified is set to Daily since we're going to trigger that notifier scheduler job\n        WatchlistPreferencesEditPage watchlistPreferences = this.watchlistPage.editPreferences();\n        watchlistPreferences.setNotifierDaily();\n        watchlistPreferences.clickSaveAndContinue();\n\n        // Switch to superadmin user and go to the scheduler home page\n        SchedulerHomePage schedulerHomePage = new SchedulerHomePage();\n        getUtil().loginAsSuperAdminAndGotoPage(schedulerHomePage.getURL());\n\n        // Trigger the notification for the Daily job\n        schedulerHomePage.clickJobActionTrigger(\"WatchList daily notifier\");\n\n        // Wait for the email with a timeout\n        Assert.assertTrue(\"Mail not received\", this.greenMail.waitForIncomingEmail(70000, 1));\n\n        // Verify email content\n        String messageFromXWiki = GreenMailUtil.getBody(this.greenMail.getReceivedMessages()[0]);\n        Assert.assertFalse(\"should have no exception in \" + messageFromXWiki, messageFromXWiki.contains(\"Exception\"));\n        Assert.assertTrue(\"should have test page in message \" + messageFromXWiki,\n            messageFromXWiki.contains(\"TestWatchThisPage\"));\n        Assert.assertTrue(\"should have test space in message \" + messageFromXWiki,\n            messageFromXWiki.contains(\"TestWatchWholeSpace\"));\n    }","id":35951,"modified_method":"@Test\n    @IgnoreBrowsers({\n        @IgnoreBrowser(value = \"internet.*\", version = \"8\\\\.*\", reason = \"See http://jira.xwiki.org/browse/XE-1146\"),\n        @IgnoreBrowser(value = \"internet.*\", version = \"9\\\\.*\", reason = \"See http://jira.xwiki.org/browse/XE-1177\")})\n    public void testWatchThisPageAndWholeSpace() throws Exception\n    {\n        // Clear the list of watched documents and spaces\n        getUtil().updateObject(\"XWiki\", this.testUserName, \"XWiki.WatchListClass\", 0, \"spaces\", \"\", \"documents\", \"\");\n\n        // Watch Test.TestWatchThisPage\n        ViewPage page =\n            getUtil().createPage(testSinglePageToWatchSpace, testSinglePageToWatch, \"TestWatchThisPage ui\", null);\n        page.watchDocument();\n\n        // Watch TestWatchWholeSpace.Test1\n        page = getUtil().createPage(testSpaceToWatch, testSpaceToWatchPage, \"TestWatchWholeSpace ui\", null);\n        page.watchSpace();\n\n        // Verify that the watched page & space are present in the watchlist manager\n        WatchlistUserProfilePage watchlistPage = WatchlistUserProfilePage.gotoPage(this.testUserName);\n        Assert.assertTrue(watchlistPage.getWatchlistMacro()\n            .isWatched(testSinglePageToWatchSpace, testSinglePageToWatch));\n        Assert.assertTrue(watchlistPage.getWatchlistMacro().isWatched(testSpaceToWatch));\n\n        // Ensure that the watchlist notified is set to Daily since we're going to trigger that notifier scheduler job\n        WatchlistPreferencesEditPage watchlistPreferences = watchlistPage.editPreferences();\n        watchlistPreferences.setNotifierDaily();\n        watchlistPreferences.clickSaveAndContinue();\n\n        // Switch to superadmin user and go to the scheduler home page\n        SchedulerHomePage schedulerHomePage = new SchedulerHomePage();\n        getUtil().loginAsSuperAdminAndGotoPage(schedulerHomePage.getURL());\n\n        // Trigger the notification for the Daily job\n        schedulerHomePage.clickJobActionTrigger(\"WatchList daily notifier\");\n\n        // Wait for the email with a timeout\n        Assert.assertTrue(\"Scheduled notification mail not received\", this.greenMail.waitForIncomingEmail(70000, 1));\n\n        // Verify email content\n        MimeMessage[] receivedMails = this.greenMail.getReceivedMessages();\n        assertEquals(1, receivedMails.length);\n        String messageFromXWiki = GreenMailUtil.getBody(receivedMails[0]).replaceAll(\"=\\r?\\n\", \"\");\n        Assert.assertFalse(\"should have no exception in \" + messageFromXWiki, messageFromXWiki.contains(\"Exception\"));\n        Assert.assertTrue(\"should have test page in the message \" + messageFromXWiki,\n            messageFromXWiki.contains(testSinglePageToWatch));\n        Assert.assertTrue(\"should have test space in the message \" + messageFromXWiki,\n            messageFromXWiki.contains(testSpaceToWatch));\n\n        // // Clear the mock inbox for the following step.\n        // GreenMailUser mailUser = this.greenMail.getManagers().getUserManager().getUser(\"admin@localhost\");\n        // this.greenMail.getManagers().getImapHostManager().deleteMailbox(mailUser, \"INBOX\");\n        // TODO: we might need the commented code above to make sure the mail is destined for our current test user and\n        // not other users created by previous tests.\n\n        /*\n         * Realtime notifications.\n         */\n\n        // Log back in with the user to test realtime notifications.\n        getUtil().login(testUserName, PASSWORD);\n\n        // Set the notifier to 'Realtime'.\n        WatchlistUserProfilePage profilePage = WatchlistUserProfilePage.gotoPage(testUserName);\n        watchlistPage = profilePage.switchToWatchlist();\n\n        watchlistPreferences = watchlistPage.editPreferences();\n        watchlistPreferences.setNotifierRealtime();\n        watchlistPreferences.clickSaveAndContinue();\n\n        // Make a change in a watched document.\n        // Note: Taking a shortcut and just using the save action.\n        String content = \"New content that watchlist should ignore.\";\n        getUtil().gotoPage(testSinglePageToWatchSpace, testSinglePageToWatch, \"save\", \"content\", content);\n\n        // Wait for an email that should never come.\n        Assert.assertFalse(\"Mail should not be received for own changes\", this.greenMail.waitForIncomingEmail(3000, 2));\n\n        // Create a second user that should trigger a realtime notification to the first user.\n        getUtil().createUserAndLogin(testUserName2, PASSWORD);\n\n        // Make a change in a document watched by the first user.\n        // Note: Taking a shortcut and just using the save action.\n        String newContent = \"New content that watchlist should notify about.\";\n        content += \"\\n\" + newContent;\n        getUtil().gotoPage(testSinglePageToWatchSpace, testSinglePageToWatch, \"save\", \"content\", content);\n\n        // Wait for the email with a timeout.\n        Assert.assertTrue(\"Realtime notification mail not received\", this.greenMail.waitForIncomingEmail(70000, 2));\n\n        // Verify email content.\n        receivedMails = this.greenMail.getReceivedMessages();\n        assertEquals(2, receivedMails.length);\n        messageFromXWiki = GreenMailUtil.getBody(receivedMails[1]).replaceAll(\"=\\r?\\n\", \"\");\n        Assert.assertFalse(\"should have no exception in \" + messageFromXWiki, messageFromXWiki.contains(\"Exception\"));\n        Assert.assertTrue(\"should have test page in the message \" + messageFromXWiki,\n            messageFromXWiki.contains(\"TestWatchThisPage\"));\n        Assert.assertTrue(\"should have test content in the message \" + messageFromXWiki,\n            messageFromXWiki.contains(newContent));\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Before\n    public void setUp() throws Exception\n    {\n        // Set the SMTP port to the default port used by Greenmail (3025)\n        getUtil().updateObject(\"Mail\", \"MailConfig\", \"Mail.SendMailConfigClass\", 0, \"host\", \"localhost\", \"port\",\n            \"3025\", \"sendWaitTime\", \"0\");\n\n        // Start GreenMail test server\n        this.greenMail = new GreenMail();\n        this.greenMail.start();\n\n        // Create a user for the test\n        String userName = RandomStringUtils.randomAlphanumeric(5);\n        getUtil().createUserAndLogin(userName, \"password\");\n        WatchlistUserProfilePage profilePage = WatchlistUserProfilePage.gotoPage(userName);\n\n        // Set the test user's email address to use a localhost domain so that the mail is caught by our\n        // GreenMail Mock mail server.\n        getUtil().updateObject(\"XWiki\", profilePage.getUsername(), \"XWiki.XWikiUsers\", 0, \"email\", \"admin@localhost\");\n\n        this.watchlistPage = profilePage.switchToWatchlist();\n\n        // Disable auto watch\n        WatchlistPreferencesEditPage watchlistPreferences = this.watchlistPage.editPreferences();\n        watchlistPreferences.setAutomaticWatchNone();\n        watchlistPreferences.clickSaveAndContinue();\n    }","id":35952,"modified_method":"@Before\n    public void setUp() throws Exception\n    {\n        // Set the SMTP port to the default port used by Greenmail (3025)\n        getUtil().updateObject(\"Mail\", \"MailConfig\", \"Mail.SendMailConfigClass\", 0, \"host\", \"localhost\", \"port\",\n            \"3025\", \"sendWaitTime\", \"0\");\n\n        // Start GreenMail test server\n        this.greenMail = new GreenMail();\n        this.greenMail.start();\n\n        // Delete the users if they already exists.\n        getUtil().deletePage(\"XWiki\", testUserName);\n        getUtil().deletePage(\"XWiki\", testUserName2);\n\n        // Delete the test pages.\n        getUtil().deletePage(testSinglePageToWatchSpace, testSinglePageToWatch);\n        getUtil().deletePage(testSpaceToWatch, testSpaceToWatchPage);\n\n        // Create a user for the test.\n        getUtil().createUserAndLogin(testUserName, PASSWORD, \"email\", testEmail);\n\n        WatchlistUserProfilePage watchlistPage = WatchlistUserProfilePage.gotoPage(testUserName);\n\n        // Disable auto watch.\n        WatchlistPreferencesEditPage watchlistPreferences = watchlistPage.editPreferences();\n        watchlistPreferences.setAutomaticWatchNone();\n        watchlistPreferences.clickSaveAndContinue();\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void testFollowUser() throws Exception\n    {\n        // Create 2 test users and log in with Bob, the creepy guy :).\n        String alice = \"Alice\";\n        getUtil().deletePage(\"XWiki\", alice);\n        getUtil().createUser(alice, \"password\", null);\n\n        String bob = \"Bob\";\n        getUtil().deletePage(\"XWiki\", bob);\n        getUtil().createUserAndLogin(bob, \"password\");\n\n        // Check that Bob does not follow anyone at the start.\n        NetworkUserProfilePage networkPage = NetworkUserProfilePage.gotoPage(bob);\n        List<String> followedUsers = networkPage.getFollowedUsers();\n        assertEquals(\"The list of followed users should be empty in the start\", 0, followedUsers.size());\n\n        // Go to Alice's profile, check that she is not followed then start following her.\n        ProfileUserProfilePage profilePage = ProfileUserProfilePage.gotoPage(alice);\n        assertFalse(\"Another users should not be followed by default\", profilePage.isFollowed());\n        profilePage = profilePage.toggleFollowButton();\n        assertTrue(\"After following, the UI should show the unfollow option\", profilePage.isFollowed());\n\n        // Go to Bob's Network profile tab and check that Alice is followed.\n        networkPage = NetworkUserProfilePage.gotoPage(bob);\n        followedUsers = networkPage.getFollowedUsers();\n        assertEquals(\"There should be 1 user in the list of followed users\", 1, followedUsers.size());\n        assertTrue(\"The user Alice should be in the list of followed users\", followedUsers.contains(alice));\n\n        // Unfollow Alice.\n        networkPage.unfollowUser(alice);\n        followedUsers = networkPage.getFollowedUsers();\n        assertEquals(\"There should be no more users in the list of followed users\", 0, followedUsers.size());\n    }","id":35953,"modified_method":"@Test\n    public void testFollowUser() throws Exception\n    {\n        // Create 2 test users and log in with Bob, the creepy guy :).\n        String alice = \"Alice\";\n        getUtil().deletePage(\"XWiki\", alice);\n        getUtil().createUser(alice, \"password\", null);\n\n        String bob = \"Bob\";\n        getUtil().deletePage(\"XWiki\", bob);\n        getUtil().createUserAndLogin(bob, \"password\");\n\n        // Check that Bob does not follow anyone at the start.\n        NetworkUserProfilePage networkPage = NetworkUserProfilePage.gotoPage(bob);\n        List<String> followedUsers = networkPage.getFollowedUsers();\n        assertEquals(\"The list of followed users should be empty in the start\", 0, followedUsers.size());\n\n        // Go to Alice's profile, check that she is not followed then start following her.\n        ProfileUserProfilePage profilePage = ProfileUserProfilePage.gotoPage(alice);\n        assertFalse(\"Another users should not be followed by default\", profilePage.isFollowed());\n        profilePage = profilePage.toggleFollowButton();\n        assertTrue(\"After following, the UI should show the unfollow option\", profilePage.isFollowed());\n\n        // Go to Bob's Network profile tab and check that Alice is followed.\n        networkPage = NetworkUserProfilePage.gotoPage(bob);\n        followedUsers = networkPage.getFollowedUsers();\n        assertEquals(\"There should be 1 user in the list of followed users\", 1, followedUsers.size());\n        assertTrue(\"The user Alice should be in the list of followed users\", followedUsers.contains(alice));\n\n        // Unfollow Alice.\n        networkPage.unfollowUser(alice);\n        followedUsers = networkPage.getFollowedUsers();\n        assertEquals(\"There should be no more users in the list of followed users\", 0, followedUsers.size());\n\n        // Cleanup\n        getUtil().deletePage(\"XWiki\", alice);\n        getUtil().deletePage(\"XWiki\", bob);\n    }","commit_id":"07a3cedbc659a04cb83c86115c6850d22cb7dea3","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Creates the OpenCms JUnit test suite.<p>\n     * \n     * @return the OpenCms JUnit test suite\n     */\n    public static Test suite() {\n\n        TestSuite suite = new TestSuite(\"OpenCms complete tests\");\n\n        suite.addTest(org.opencms.setup.AllTests.suite());\n        suite.addTest(org.opencms.ade.configuration.AllTests.suite());\n        suite.addTest(org.opencms.ade.publish.AllTests.suite());\n        suite.addTest(org.opencms.ade.sitemap.AllTests.suite());\n        suite.addTest(org.opencms.cache.AllTests.suite());\n        suite.addTest(org.opencms.configuration.AllTests.suite());\n        suite.addTest(org.opencms.db.AllTests.suite());\n        suite.addTest(org.opencms.file.AllTests.suite());\n        suite.addTest(org.opencms.file.collectors.AllTests.suite());\n        suite.addTest(org.opencms.file.types.AllTests.suite());\n        suite.addTest(org.opencms.file.wrapper.AllTests.suite());\n        suite.addTest(org.opencms.flex.AllTests.suite());\n        suite.addTest(org.opencms.i18n.AllTests.suite());\n        suite.addTest(org.opencms.importexport.AllTests.suite());\n        suite.addTest(org.opencms.jsp.decorator.AllTests.suite());\n        suite.addTest(org.opencms.jsp.util.AllTests.suite());\n        suite.addTest(org.opencms.loader.AllTests.suite());\n        suite.addTest(org.opencms.mail.AllTests.suite());\n        suite.addTest(org.opencms.main.AllTests.suite());\n        suite.addTest(org.opencms.module.AllTests.suite());\n        suite.addTest(org.opencms.monitor.AllTests.suite());\n        suite.addTest(org.opencms.notification.AllTests.suite());\n        suite.addTest(org.opencms.publish.AllTests.suite());\n        suite.addTest(org.opencms.relations.AllTests.suite());\n        suite.addTest(org.opencms.scheduler.AllTests.suite());\n        suite.addTest(org.opencms.search.AllTests.suite());\n        suite.addTest(org.opencms.search.extractors.AllTests.suite());\n        suite.addTest(org.opencms.search.gallery.AllTests.suite());\n        suite.addTest(org.opencms.security.AllTests.suite());\n        suite.addTest(org.opencms.staticexport.AllTests.suite());\n        suite.addTest(org.opencms.synchronize.AllTests.suite());\n        suite.addTest(org.opencms.util.AllTests.suite());\n        suite.addTest(org.opencms.widgets.AllTests.suite());\n        suite.addTest(org.opencms.workplace.AllTests.suite());\n        suite.addTest(org.opencms.xml.AllTests.suite());\n        suite.addTest(org.opencms.xml.containerpage.AllTests.suite());\n        suite.addTest(org.opencms.xml.content.AllTests.suite());\n        suite.addTest(org.opencms.xml.page.AllTests.suite());\n\n        TestSetup wrapper = new TestSetup(suite) {\n\n            @Override\n            protected void setUp() {\n\n                oneTimeSetUp();\n            }\n\n            @Override\n            protected void tearDown() {\n\n                oneTimeTearDown();\n            }\n        };\n\n        return wrapper;\n    }","id":35954,"modified_method":"/**\n     * Creates the OpenCms JUnit test suite.<p>\n     * \n     * @return the OpenCms JUnit test suite\n     */\n    public static Test suite() {\n\n        TestSuite suite = new TestSuite(\"OpenCms complete tests\");\n\n        suite.addTest(org.opencms.setup.AllTests.suite());\n        suite.addTest(org.opencms.ade.configuration.AllTests.suite());\n        suite.addTest(org.opencms.ade.publish.AllTests.suite());\n        suite.addTest(org.opencms.ade.sitemap.AllTests.suite());\n        suite.addTest(org.opencms.cache.AllTests.suite());\n        suite.addTest(org.opencms.configuration.AllTests.suite());\n        suite.addTest(org.opencms.db.AllTests.suite());\n        suite.addTest(org.opencms.file.AllTests.suite());\n        suite.addTest(org.opencms.file.collectors.AllTests.suite());\n        suite.addTest(org.opencms.file.types.AllTests.suite());\n        suite.addTest(org.opencms.file.wrapper.AllTests.suite());\n        suite.addTest(org.opencms.flex.AllTests.suite());\n        suite.addTest(org.opencms.i18n.AllTests.suite());\n        suite.addTest(org.opencms.importexport.AllTests.suite());\n        suite.addTest(org.opencms.jsp.decorator.AllTests.suite());\n        suite.addTest(org.opencms.jsp.util.AllTests.suite());\n        suite.addTest(org.opencms.loader.AllTests.suite());\n        suite.addTest(org.opencms.mail.AllTests.suite());\n        suite.addTest(org.opencms.main.AllTests.suite());\n        suite.addTest(org.opencms.module.AllTests.suite());\n        suite.addTest(org.opencms.monitor.AllTests.suite());\n        suite.addTest(org.opencms.notification.AllTests.suite());\n        suite.addTest(org.opencms.publish.AllTests.suite());\n        suite.addTest(org.opencms.relations.AllTests.suite());\n        suite.addTest(org.opencms.scheduler.AllTests.suite());\n        suite.addTest(org.opencms.search.AllTests.suite());\n        suite.addTest(org.opencms.search.extractors.AllTests.suite());\n        suite.addTest(org.opencms.search.gallery.AllTests.suite());\n        suite.addTest(org.opencms.security.AllTests.suite());\n        suite.addTest(org.opencms.staticexport.AllTests.suite());\n        suite.addTest(org.opencms.synchronize.AllTests.suite());\n        suite.addTest(org.opencms.util.AllTests.suite());\n        suite.addTest(org.opencms.widgets.AllTests.suite());\n        suite.addTest(org.opencms.workplace.AllTests.suite());\n        suite.addTest(org.opencms.xml.AllTests.suite());\n        suite.addTest(org.opencms.xml.containerpage.AllTests.suite());\n        suite.addTest(org.opencms.xml.content.AllTests.suite());\n        suite.addTest(org.opencms.xml.page.AllTests.suite());\n        suite.addTest(org.opencms.workflow.AllTests.suite());\n\n        TestSetup wrapper = new TestSetup(suite) {\n\n            @Override\n            protected void setUp() {\n\n                oneTimeSetUp();\n            }\n\n            @Override\n            protected void tearDown() {\n\n                oneTimeTearDown();\n            }\n        };\n\n        return wrapper;\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void onFinishPublishJob(CmsPublishJobRunning publishJob) {\r\n\r\n        System.out.println(\"###CmsWorkflowManager: publish job finished!\");\r\n        CmsPublishList publishList = publishJob.getPublishList();\r\n        Set<CmsUUID> projectIds = new HashSet<CmsUUID>();\r\n        for (CmsResource resource : publishList.getAllResources()) {\r\n            projectIds.add(resource.getProjectLastModified());\r\n        }\r\n        for (CmsUUID projectId : projectIds) {\r\n            try {\r\n                CmsProject project = m_adminCms.readProject(projectId);\r\n                cleanupProjectIfEmpty(project);\r\n            } catch (CmsException e) {\r\n                LOG.info(\"Project \" + projectId + \" doesn't exist anymore.\");\r\n            }\r\n        }\r\n    }","id":35955,"modified_method":"/**\r\n     * Handles finished publish jobs by removing projects of resources in the publish job if they are empty workflow projects.<p>\r\n     * \r\n     * @param publishJob the finished published job \r\n     */\r\n    public void onFinishPublishJob(CmsPublishJobRunning publishJob) {\r\n\r\n        CmsPublishList publishList = publishJob.getPublishList();\r\n        Set<CmsUUID> projectIds = new HashSet<CmsUUID>();\r\n        for (CmsResource resource : publishList.getAllResources()) {\r\n            projectIds.add(resource.getProjectLastModified());\r\n        }\r\n        for (CmsUUID projectId : projectIds) {\r\n            try {\r\n                CmsProject project = m_adminCms.readProject(projectId);\r\n                cleanupProjectIfEmpty(project);\r\n            } catch (CmsException e) {\r\n                LOG.info(\"Project \" + projectId + \" doesn't exist anymore.\");\r\n            }\r\n        }\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Helper method for generating the workflow response which should be sent when publishing the resources would break relations.<p>\r\n     * \r\n     * @param publishResources the resources whose links would be broken\r\n     *  \r\n     * @return the workflow response \r\n     */\r\n    protected CmsWorkflowResponse getPublishBrokenRelationsResponse(List<CmsPublishResource> publishResources) {\r\n\r\n        List<CmsWorkflowActionBean> actions = new ArrayList<CmsWorkflowActionBean>();\r\n        CmsWorkflowActionBean forcePublish = new CmsWorkflowActionBean(ACTION_FORCE_PUBLISH, \"Publish\", true);\r\n        return new CmsWorkflowResponse(\r\n            false,\r\n            \"$ broken relations - use message bundle here $\",\r\n            publishResources,\r\n            actions,\r\n            null);\r\n    }","id":35956,"modified_method":"/**\r\n     * Helper method for generating the workflow response which should be sent when publishing the resources would break relations.<p>\r\n     * \r\n     * @param publishResources the resources whose links would be broken\r\n     *  \r\n     * @return the workflow response \r\n     */\r\n    protected CmsWorkflowResponse getPublishBrokenRelationsResponse(\r\n        CmsObject userCms,\r\n        List<CmsPublishResource> publishResources) {\r\n\r\n        List<CmsWorkflowActionBean> actions = new ArrayList<CmsWorkflowActionBean>();\r\n        String forcePublishLabel = Messages.get().getBundle(getLocale(userCms)).key(\r\n            Messages.GUI_WORKFLOW_ACTION_FORCE_PUBLISH_0);\r\n\r\n        CmsWorkflowActionBean forcePublish = new CmsWorkflowActionBean(ACTION_FORCE_PUBLISH, forcePublishLabel, true);\r\n        return new CmsWorkflowResponse(false, Messages.get().getBundle(getLocale(userCms)).key(\r\n            Messages.GUI_BROKEN_LINKS_0), publishResources, actions, null);\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Creates a new workflow manager instance.<p>\r\n     *  \r\n     * @param adminCms a CMS context with admin privileges \r\n     */\r\n    public CmsWorkflowManager(CmsObject adminCms, CmsPublishManager publishManager) {\r\n\r\n        m_adminCms = adminCms;\r\n        publishManager.addPublishListener(new CmsPublishEventAdapter() {\r\n\r\n            @Override\r\n            public void onFinish(CmsPublishJobRunning publishJob) {\r\n\r\n                CmsWorkflowManager.this.onFinishPublishJob(publishJob);\r\n            }\r\n        });\r\n    }","id":35957,"modified_method":"/**\r\n     * Creates a new workflow manager instance.<p>\r\n     *  \r\n     * @param adminCms a CMS context with admin privileges \r\n     * @param publishManager the publish manager\r\n     */\r\n    public CmsWorkflowManager(CmsObject adminCms, CmsPublishManager publishManager) {\r\n\r\n        m_adminCms = adminCms;\r\n        publishManager.addPublishListener(new CmsPublishEventAdapter() {\r\n\r\n            @Override\r\n            public void onFinish(CmsPublishJobRunning publishJob) {\r\n\r\n                CmsWorkflowManager.this.onFinishPublishJob(publishJob);\r\n            }\r\n\r\n            public void onStart(CmsPublishJobEnqueued publishJob) {\r\n\r\n                //CmsWorkflowManager.this.onStartPublishJob(publishJob);\r\n            }\r\n        });\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Implementation of the 'release' workflow action.<p>\r\n     * \r\n     * @param userCms the current user's CMS context \r\n     * @param resources the resources which should be released\r\n     *  \r\n     * @return the workflow response for this action \r\n     * \r\n     * @throws CmsException if something goes wrong \r\n     */\r\n    protected CmsWorkflowResponse actionRelease(CmsObject userCms, List<CmsResource> resources) throws CmsException {\r\n\r\n        String projectName = generateProjectName(userCms);\r\n        String projectDescription = generateProjectDescription(userCms);\r\n        CmsObject offlineAdminCms = OpenCms.initCmsObject(m_adminCms);\r\n        offlineAdminCms.getRequestContext().setCurrentProject(userCms.getRequestContext().getCurrentProject());\r\n        String managerGroup = getWorkflowProjectManagerGroup();\r\n        String userGroup = getWorkflowProjectUserGroup();\r\n        CmsProject workflowProject = m_adminCms.createProject(\r\n            projectName,\r\n            projectDescription,\r\n            userGroup,\r\n            managerGroup,\r\n            CmsProject.PROJECT_TYPE_WORKFLOW);\r\n        for (CmsResource resource : resources) {\r\n            offlineAdminCms.writeProjectLastModified(resource, workflowProject);\r\n            System.out.println(\"Releasing resource \" + resource.getRootPath());\r\n        }\r\n        sendNotification(userCms, workflowProject, resources);\r\n        return new CmsWorkflowResponse(\r\n            true,\r\n            \"ok\",\r\n            new ArrayList<CmsPublishResource>(),\r\n            new ArrayList<CmsWorkflowActionBean>(),\r\n            workflowProject.getUuid());\r\n    }","id":35958,"modified_method":"/**\r\n     * Implementation of the 'release' workflow action.<p>\r\n     * \r\n     * @param userCms the current user's CMS context \r\n     * @param resources the resources which should be released\r\n     *  \r\n     * @return the workflow response for this action \r\n     * \r\n     * @throws CmsException if something goes wrong \r\n     */\r\n    protected CmsWorkflowResponse actionRelease(CmsObject userCms, List<CmsResource> resources) throws CmsException {\r\n\r\n        String projectName = generateProjectName(userCms);\r\n        String projectDescription = generateProjectDescription(userCms);\r\n        CmsObject offlineAdminCms = OpenCms.initCmsObject(m_adminCms);\r\n        offlineAdminCms.getRequestContext().setCurrentProject(userCms.getRequestContext().getCurrentProject());\r\n        String managerGroup = getWorkflowProjectManagerGroup();\r\n        String userGroup = getWorkflowProjectUserGroup();\r\n        CmsProject workflowProject = m_adminCms.createProject(\r\n            projectName,\r\n            projectDescription,\r\n            userGroup,\r\n            managerGroup,\r\n            CmsProject.PROJECT_TYPE_WORKFLOW);\r\n        CmsUser admin = offlineAdminCms.getRequestContext().getCurrentUser();\r\n        clearLocks(userCms.getRequestContext().getCurrentProject(), resources);\r\n        for (CmsResource resource : resources) {\r\n            CmsLock lock = offlineAdminCms.getLock(resource);\r\n            if (lock.isUnlocked()) {\r\n                offlineAdminCms.lockResource(resource);\r\n            } else if (!lock.isOwnedBy(admin)) {\r\n                offlineAdminCms.changeLock(resource);\r\n            }\r\n            offlineAdminCms.writeProjectLastModified(resource, workflowProject);\r\n        }\r\n        for (CmsUser user : getNotificationMailRecipients()) {\r\n            sendNotification(userCms, user, workflowProject, resources);\r\n        }\r\n        return new CmsWorkflowResponse(\r\n            true,\r\n            \"\",\r\n            new ArrayList<CmsPublishResource>(),\r\n            new ArrayList<CmsWorkflowActionBean>(),\r\n            workflowProject.getUuid());\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Gets the group which should be used as the 'manager' group for newly created workflow projects.<p>\r\n     * @return\r\n     */\r\n    public String getWorkflowProjectManagerGroup() {\r\n\r\n        return OpenCms.getDefaultUsers().getGroupProjectmanagers();\r\n    }","id":35959,"modified_method":"/**\r\n     * Gets the name of the group which should be used as the 'manager' group for newly created workflow projects.<p>\r\n     * \r\n     * @return a group name \r\n     */\r\n    public String getWorkflowProjectManagerGroup() {\r\n\r\n        return OpenCms.getDefaultUsers().getGroupProjectmanagers();\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Returns the workflow actions which should be available to the user.<p>\r\n     * \r\n     * @param userCms the user's CMS object \r\n     * \r\n     * @return the list of workflow actions which should be available to the user \r\n     */\r\n    public List<CmsWorkflowActionBean> getAvailableActions(CmsObject userCms) {\r\n\r\n        List<CmsWorkflowActionBean> actions = new ArrayList<CmsWorkflowActionBean>();\r\n        CmsWorkflowActionBean publish = new CmsWorkflowActionBean(ACTION_PUBLISH, \"Publish\", true);\r\n        CmsWorkflowActionBean release = new CmsWorkflowActionBean(ACTION_RELEASE, \"Release\", true);\r\n        actions.add(publish);\r\n        actions.add(release);\r\n        return actions;\r\n    }","id":35960,"modified_method":"/**\r\n     * Returns the workflow actions which should be available to the user.<p>\r\n     * \r\n     * @param userCms the user's CMS object \r\n     * \r\n     * @return the list of workflow actions which should be available to the user \r\n     */\r\n    public List<CmsWorkflowActionBean> getAvailableActions(CmsObject userCms) {\r\n\r\n        List<CmsWorkflowActionBean> actions = new ArrayList<CmsWorkflowActionBean>();\r\n        Locale locale = getLocale(userCms);\r\n        String publishLabel = Messages.get().getBundle(locale).key(Messages.GUI_WORKFLOW_ACTION_PUBLISH_0);\r\n        String releaseLabel = Messages.get().getBundle(locale).key(Messages.GUI_WORKFLOW_ACTION_RELEASE_0);\r\n        CmsWorkflowActionBean publish = new CmsWorkflowActionBean(ACTION_PUBLISH, publishLabel, true);\r\n        CmsWorkflowActionBean release = new CmsWorkflowActionBean(ACTION_RELEASE, releaseLabel, true);\r\n        actions.add(publish);\r\n        actions.add(release);\r\n        return actions;\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Sends the notification for released resources.<p>\r\n     * \r\n     * @param userCms the user's CMS context \r\n     * @param workflowProject the workflow project which \r\n     * @param resources\r\n     * @throws CmsException\r\n     */\r\n    protected void sendNotification(CmsObject userCms, CmsProject workflowProject, List<CmsResource> resources)\r\n    throws CmsException {\r\n\r\n        try {\r\n            CmsWorkflowNotification notification = new CmsWorkflowNotification(\r\n                userCms.getRequestContext().getCurrentUser(),\r\n                workflowProject,\r\n                resources);\r\n            notification.send();\r\n        } catch (EmailException e) {\r\n            LOG.error(e.getLocalizedMessage(), e);\r\n        }\r\n    }","id":35961,"modified_method":"/**\r\n     * Sends the notification for released resources.<p>\r\n     * \r\n     * @param userCms the user's CMS context \r\n     * @param recipient the OpenCms user to whom the notification should be sent \r\n     * @param workflowProject the workflow project which \r\n     * @param resources the resources which have been affected by a workflow action \r\n     */\r\n    protected void sendNotification(\r\n        CmsObject userCms,\r\n        CmsUser recipient,\r\n        CmsProject workflowProject,\r\n        List<CmsResource> resources) {\r\n\r\n        try {\r\n            CmsWorkflowNotification notification = new CmsWorkflowNotification(\r\n                recipient,\r\n                userCms.getRequestContext().getCurrentUser(),\r\n                workflowProject,\r\n                resources);\r\n            notification.send();\r\n        } catch (EmailException e) {\r\n            LOG.error(e.getLocalizedMessage(), e);\r\n        }\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"protected boolean isProjectEmpty(CmsProject project) throws CmsException {\r\n\r\n        CmsPublishManager publishManager = OpenCms.getPublishManager();\r\n        CmsObject projectCms = OpenCms.initCmsObject(m_adminCms);\r\n        projectCms.getRequestContext().setCurrentProject(project);\r\n        CmsPublishList publishList = publishManager.getPublishList(projectCms);\r\n        List resourcesModifiedInProject = publishList.getAllResources();\r\n        return resourcesModifiedInProject.isEmpty();\r\n    }","id":35962,"modified_method":"/**\r\n     * Checks whether there are resources which have last been modified in a given project.<p>\r\n     * \r\n     * @param project the project which should be checked \r\n     * @return true if there are no resources which have been last modified inside the project \r\n     * \r\n     * @throws CmsException if something goes wrong \r\n     */\r\n    protected boolean isProjectEmpty(CmsProject project) throws CmsException {\r\n\r\n        CmsPublishManager publishManager = OpenCms.getPublishManager();\r\n        CmsObject projectCms = OpenCms.initCmsObject(m_adminCms);\r\n        projectCms.getRequestContext().setCurrentProject(project);\r\n        CmsPublishList publishList = publishManager.getPublishList(projectCms);\r\n        List<CmsResource> resourcesModifiedInProject = publishList.getAllResources();\r\n        return resourcesModifiedInProject.isEmpty();\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Implementation of the 'publish' workflow action.<p>\r\n     * \r\n     * @param userCms the user's current CMS context \r\n     * @param resources the resources to be processed \r\n     * \r\n     * @return the workflow response for this action \r\n     * \r\n     * @throws CmsException if something goes wrong \r\n     */\r\n    protected CmsWorkflowResponse actionPublish(CmsObject userCms, List<CmsResource> resources) throws CmsException {\r\n\r\n        CmsPublish publish = new CmsPublish(userCms);\r\n        List<CmsPublishResource> brokenLinkBeans = publish.getBrokenResources(resources);\r\n        if (brokenLinkBeans.size() == 0) {\r\n            publish.publishResources(resources);\r\n            return getSuccessResponse();\r\n        }\r\n        return getPublishBrokenRelationsResponse(brokenLinkBeans);\r\n    }","id":35963,"modified_method":"/**\r\n     * Implementation of the 'publish' workflow action.<p>\r\n     * \r\n     * @param userCms the user's current CMS context \r\n     * @param resources the resources to be processed \r\n     * \r\n     * @return the workflow response for this action \r\n     * \r\n     * @throws CmsException if something goes wrong \r\n     */\r\n    protected CmsWorkflowResponse actionPublish(CmsObject userCms, List<CmsResource> resources) throws CmsException {\r\n\r\n        CmsPublish publish = new CmsPublish(userCms);\r\n        List<CmsPublishResource> brokenLinkBeans = publish.getBrokenResources(resources);\r\n        if (brokenLinkBeans.size() == 0) {\r\n            publish.publishResources(resources);\r\n            return getSuccessResponse();\r\n        }\r\n        return getPublishBrokenRelationsResponse(userCms, brokenLinkBeans);\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public CmsWorkflowNotification(CmsUser user, CmsProject workflowProject, List<CmsResource> resources)\r\n    throws EmailException {\r\n\r\n        super();\r\n        String htmlStart = \"<html><head><\/head><body>\";\r\n        String htmlEnd = \"<\/body><\/html>\";\r\n\r\n        StringBuffer mainContent = new StringBuffer();\r\n        mainContent.append(\"<ul>\");\r\n        for (CmsResource resource : resources) {\r\n            mainContent.append(\"<li>\" + resource.getRootPath() + \"<\/li>\");\r\n        }\r\n        mainContent.append(\"<\/ul>\");\r\n\r\n        String htmlMain = \"<div>\" + mainContent.toString() + \"<\/div>\";\r\n        setHtmlMsg(htmlStart + htmlMain + htmlEnd);\r\n        addTo(user.getEmail());\r\n        setSubject(\"Workflow notification!\");\r\n        send();\r\n    }","id":35964,"modified_method":"public CmsWorkflowNotification(\r\n        CmsUser recipient,\r\n        CmsUser user,\r\n        CmsProject workflowProject,\r\n        List<CmsResource> resources)\r\n    throws EmailException {\r\n\r\n        super();\r\n        String htmlStart = \"<html><head><\/head><body>\";\r\n        String htmlEnd = \"<\/body><\/html>\";\r\n\r\n        StringBuffer mainContent = new StringBuffer();\r\n        mainContent.append(\"<ul>\");\r\n        for (CmsResource resource : resources) {\r\n            mainContent.append(\"<li>\" + resource.getRootPath() + \"<\/li>\");\r\n        }\r\n        mainContent.append(\"<\/ul>\");\r\n        mainContent.append(\"<div>\" + workflowProject.getName() + \"<\/div>\");\r\n        String htmlMain = \"<div>\" + mainContent.toString() + \"<\/div>\";\r\n        setHtmlMsg(htmlStart + htmlMain + htmlEnd);\r\n        addTo(recipient.getEmail());\r\n        setSubject(\"Workflow notification (\" + user.getName() + \")\");\r\n        send();\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void testFailReleaseOnline() throws CmsException {\r\n\r\n        CmsWorkflowManager wfm = OpenCms.getWorkflowManager();\r\n        CmsObject cms = OpenCms.initCmsObject(getCmsObject());\r\n        List<CmsResource> resources = new ArrayList<CmsResource>();\r\n        CmsResource r = cms.createResource(\"/system/r4\", 1);\r\n        resources.add(r);\r\n        cms.getRequestContext().setCurrentProject(cms.readProject(CmsProject.ONLINE_PROJECT_NAME));\r\n        try {\r\n            CmsWorkflowResponse response = wfm.executeAction(cms, CmsWorkflowManager.ACTION_RELEASE, resources);\r\n        } catch (CmsException e) {\r\n            return;\r\n        }\r\n        assertTrue(\"Should have failed\", false);\r\n    }","id":35965,"modified_method":"/**\r\n     * Tests that the release action fails in the online project.<p>\r\n     * \r\n     * @throws CmsException\r\n     */\r\n    public void testFailReleaseOnline() throws CmsException {\r\n\r\n        CmsWorkflowManager wfm = OpenCms.getWorkflowManager();\r\n        CmsObject cms = OpenCms.initCmsObject(getCmsObject());\r\n        List<CmsResource> resources = new ArrayList<CmsResource>();\r\n        CmsResource r = cms.createResource(\"/system/r4\", 1);\r\n        resources.add(r);\r\n        cms.getRequestContext().setCurrentProject(cms.readProject(CmsProject.ONLINE_PROJECT_NAME));\r\n        try {\r\n            wfm.executeAction(cms, CmsWorkflowManager.ACTION_RELEASE, resources);\r\n        } catch (CmsException e) {\r\n            return;\r\n        }\r\n        assertTrue(\"Should have failed\", false);\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void testWorkflowPublish() throws CmsException {\r\n\r\n        CmsWorkflowManager wfm = OpenCms.getWorkflowManager();\r\n        CmsObject cms = getCmsObject();\r\n        List<CmsResource> resources = new ArrayList<CmsResource>();\r\n        CmsResource r = cms.createResource(\"/system/r1\", 1);\r\n        resources.add(r);\r\n        wfm.executeAction(getCmsObject(), CmsWorkflowManager.ACTION_PUBLISH, resources);\r\n        OpenCms.getPublishManager().waitWhileRunning();\r\n        CmsResource rRead = cms.readResource(\"/system/r1\");\r\n        assertTrue(rRead.getState().isUnchanged());\r\n    }","id":35966,"modified_method":"/**\r\n     * Tests the 'publish' workflow action.<p>\r\n     * \r\n     * @throws CmsException\r\n     */\r\n    public void testWorkflowPublish() throws CmsException {\r\n\r\n        CmsWorkflowManager wfm = OpenCms.getWorkflowManager();\r\n        CmsObject cms = getCmsObject();\r\n        List<CmsResource> resources = new ArrayList<CmsResource>();\r\n        CmsResource r = cms.createResource(\"/system/r1\", 1);\r\n        resources.add(r);\r\n        wfm.executeAction(getCmsObject(), CmsWorkflowManager.ACTION_PUBLISH, resources);\r\n        OpenCms.getPublishManager().waitWhileRunning();\r\n        CmsResource rRead = cms.readResource(\"/system/r1\");\r\n        assertTrue(rRead.getState().isUnchanged());\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void testWorkflowForcePublish() throws CmsException {\r\n\r\n        CmsWorkflowManager wfm = OpenCms.getWorkflowManager();\r\n        CmsObject cms = getCmsObject();\r\n        List<CmsResource> resources = new ArrayList<CmsResource>();\r\n        CmsResource r = cms.createResource(\"/system/r2\", 1);\r\n        resources.add(r);\r\n        wfm.executeAction(getCmsObject(), CmsWorkflowManager.ACTION_FORCE_PUBLISH, resources);\r\n        OpenCms.getPublishManager().waitWhileRunning();\r\n        CmsResource rRead = cms.readResource(\"/system/r2\");\r\n        assertTrue(rRead.getState().isUnchanged());\r\n    }","id":35967,"modified_method":"/**\r\n     * Tests the 'publish' workflow action.<p>\r\n     * \r\n     * @throws CmsException\r\n     */\r\n    public void testWorkflowForcePublish() throws CmsException {\r\n\r\n        CmsWorkflowManager wfm = OpenCms.getWorkflowManager();\r\n        CmsObject cms = getCmsObject();\r\n        List<CmsResource> resources = new ArrayList<CmsResource>();\r\n        CmsResource r = cms.createResource(\"/system/r2\", 1);\r\n        resources.add(r);\r\n        wfm.executeAction(getCmsObject(), CmsWorkflowManager.ACTION_FORCE_PUBLISH, resources);\r\n        OpenCms.getPublishManager().waitWhileRunning();\r\n        CmsResource rRead = cms.readResource(\"/system/r2\");\r\n        assertTrue(rRead.getState().isUnchanged());\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public static Test suite() {\r\n\r\n        OpenCmsTestProperties.initialize(org.opencms.test.AllTests.TEST_PROPERTIES_PATH);\r\n        return generateSetupTestWrapper(TestWorkflow.class, \"systemtest\", \"/\");\r\n    }","id":35968,"modified_method":"/**\r\n     * Creates a test suite instance for this test case.<p>\r\n     * \r\n     * @return the test suite \r\n     */\r\n    public static Test suite() {\r\n\r\n        OpenCmsTestProperties.initialize(org.opencms.test.AllTests.TEST_PROPERTIES_PATH);\r\n        return generateSetupTestWrapper(TestWorkflow.class, \"systemtest\", \"/\");\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public TestWorkflow(String name) {\r\n\r\n        super(name);\r\n\r\n    }","id":35969,"modified_method":"/**\r\n     * Standard test constructor.<p>\r\n     * \r\n     * @param name the test name \r\n     */\r\n    public TestWorkflow(String name) {\r\n\r\n        super(name);\r\n\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public void testWorkflowRelease() throws CmsException {\r\n\r\n        CmsWorkflowManager wfm = OpenCms.getWorkflowManager();\r\n        CmsObject cms = getCmsObject();\r\n        List<CmsResource> resources = new ArrayList<CmsResource>();\r\n        CmsResource r = cms.createResource(\"/system/r3\", 1);\r\n        resources.add(r);\r\n        CmsWorkflowResponse response = wfm.executeAction(getCmsObject(), CmsWorkflowManager.ACTION_RELEASE, resources);\r\n        assertTrue(response.isSuccess());\r\n        CmsUUID workflowId = response.getWorkflowId();\r\n        CmsProject project = cms.readProject(workflowId);\r\n        assertEquals(CmsProject.PROJECT_TYPE_WORKFLOW.getMode(), project.getType().getMode());\r\n        System.out.println(\"PROJECTNAME>>>\" + project.getName());\r\n        CmsResource rRead = cms.readResource(\"/system/r3\");\r\n        assertEquals(workflowId, rRead.getProjectLastModified());\r\n        assertFalse(workflowId.equals(cms.getRequestContext().getCurrentProject().getUuid()));\r\n    }","id":35970,"modified_method":"/**\r\n     * Tests the 'release' workflow action.<p>\r\n     * \r\n     * @throws CmsException \r\n     */\r\n    public void testWorkflowRelease() throws CmsException {\r\n\r\n        try {\r\n            OpenCmsTestLogAppender.setBreakOnError(false);\r\n\r\n            CmsWorkflowManager wfm = OpenCms.getWorkflowManager();\r\n            CmsObject cms = getCmsObject();\r\n            List<CmsResource> resources = new ArrayList<CmsResource>();\r\n            CmsResource r = cms.createResource(\"/system/r3\", 1);\r\n            resources.add(r);\r\n            CmsWorkflowResponse response = wfm.executeAction(\r\n                getCmsObject(),\r\n                CmsWorkflowManager.ACTION_RELEASE,\r\n                resources);\r\n            assertTrue(response.isSuccess());\r\n            CmsUUID workflowId = response.getWorkflowId();\r\n            CmsProject project = cms.readProject(workflowId);\r\n            assertEquals(CmsProject.PROJECT_TYPE_WORKFLOW.getMode(), project.getType().getMode());\r\n            CmsResource rRead = cms.readResource(\"/system/r3\");\r\n            assertEquals(workflowId, rRead.getProjectLastModified());\r\n            assertFalse(workflowId.equals(cms.getRequestContext().getCurrentProject().getUuid()));\r\n        } finally {\r\n            OpenCmsTestLogAppender.setBreakOnError(true);\r\n\r\n        }\r\n    }","commit_id":"c61b966e1834f7dd328d29dec7cd91b42ca02f3c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"@Override\n\tpublic CalendarBooking restoreCalendarBookingFromTrash(\n\t\t\tlong userId, long calendarBookingId)\n\t\tthrows PortalException {\n\n\t\tCalendarBooking calendarBooking = getCalendarBooking(calendarBookingId);\n\n\t\tif (!calendarBooking.isMasterBooking()) {\n\t\t\treturn calendarBooking;\n\t\t}\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tCalendarBooking.class.getName(), calendarBookingId);\n\n\t\tcalendarBookingLocalService.updateStatus(\n\t\t\tuserId, calendarBookingId, trashEntry.getStatus(),\n\t\t\tnew ServiceContext());\n\n\t\tsocialActivityCounterLocalService.enableActivityCounters(\n\t\t\tCalendarBooking.class.getName(), calendarBookingId);\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\tgetExtraDataJSON(calendarBooking), 0);\n\n\t\treturn calendarBooking;\n\t}","id":35971,"modified_method":"@Override\n\tpublic CalendarBooking restoreCalendarBookingFromTrash(\n\t\t\tlong userId, long calendarBookingId)\n\t\tthrows PortalException {\n\n\t\tCalendarBooking calendarBooking = getCalendarBooking(calendarBookingId);\n\n\t\tif (!calendarBooking.isMasterBooking()) {\n\t\t\treturn calendarBooking;\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setUserId(userId);\n\n\t\tTrashEntry trashEntry = trashEntryLocalService.getEntry(\n\t\t\tCalendarBooking.class.getName(), calendarBookingId);\n\n\t\tcalendarBookingLocalService.updateStatus(\n\t\t\tuserId, calendarBookingId, trashEntry.getStatus(), serviceContext);\n\n\t\tsocialActivityCounterLocalService.enableActivityCounters(\n\t\t\tCalendarBooking.class.getName(), calendarBookingId);\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\tCalendarBooking.class.getName(), calendarBookingId,\n\t\t\tSocialActivityConstants.TYPE_RESTORE_FROM_TRASH,\n\t\t\tgetExtraDataJSON(calendarBooking), 0);\n\n\t\treturn calendarBooking;\n\t}","commit_id":"0534e486caa4a9995432c7dbd20dd6342a2ef0b2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic CalendarBooking updateStatus(\n\t\t\tlong userId, CalendarBooking calendarBooking, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tint oldStatus = calendarBooking.getStatus();\n\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarBooking.setStatus(status);\n\t\tcalendarBooking.setStatusByUserId(user.getUserId());\n\t\tcalendarBooking.setStatusByUserName(user.getFullName());\n\t\tcalendarBooking.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\t// Child calendar bookings\n\n\t\tif (status == CalendarBookingWorkflowConstants.STATUS_IN_TRASH) {\n\t\t\tList<CalendarBooking> childCalendarBookings =\n\t\t\t\tcalendarBooking.getChildCalendarBookings();\n\n\t\t\tfor (CalendarBooking childCalendarBooking : childCalendarBookings) {\n\t\t\t\tif (childCalendarBooking.equals(calendarBooking)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tupdateStatus(\n\t\t\t\t\tuserId, childCalendarBooking,\n\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_IN_TRASH,\n\t\t\t\t\tserviceContext);\n\n\t\t\t\tsendNotification(\n\t\t\t\t\tchildCalendarBooking,\n\t\t\t\t\tNotificationTemplateType.MOVED_TO_TRASH, serviceContext);\n\t\t\t}\n\t\t}\n\t\telse if (oldStatus ==\n\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_IN_TRASH) {\n\n\t\t\tList<CalendarBooking> childCalendarBookings =\n\t\t\t\tcalendarBooking.getChildCalendarBookings();\n\n\t\t\tfor (CalendarBooking childCalendarBooking : childCalendarBookings) {\n\t\t\t\tif (childCalendarBooking.equals(calendarBooking)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tupdateStatus(\n\t\t\t\t\tuserId, childCalendarBooking,\n\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_PENDING,\n\t\t\t\t\tserviceContext);\n\n\t\t\t\tsendNotification(\n\t\t\t\t\tchildCalendarBooking, NotificationTemplateType.INVITE,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tif (status == CalendarBookingWorkflowConstants.STATUS_APPROVED) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\tcalendarBooking.getCalendarBookingId(), true);\n\t\t}\n\t\telse if (status == CalendarBookingWorkflowConstants.STATUS_IN_TRASH) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\tcalendarBooking.getCalendarBookingId(), false);\n\t\t}\n\n\t\t// Trash\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.deleteEntry(\n\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\tcalendarBooking.getCalendarBookingId());\n\t\t}\n\n\t\tif (status == CalendarBookingWorkflowConstants.STATUS_IN_TRASH) {\n\t\t\tif (calendarBooking.isMasterBooking()) {\n\t\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\t\t\tcalendarBooking.getUuid(), null, oldStatus, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\t\t\tcalendarBooking.getUuid(), null,\n\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_PENDING, null,\n\t\t\t\t\tnull);\n\t\t\t}\n\t\t}\n\n\t\treturn calendarBooking;\n\t}","id":35972,"modified_method":"@Indexable(type = IndexableType.REINDEX)\n\t@Override\n\tpublic CalendarBooking updateStatus(\n\t\t\tlong userId, CalendarBooking calendarBooking, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException {\n\n\t\t// Calendar booking\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tint oldStatus = calendarBooking.getStatus();\n\n\t\tcalendarBooking.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tcalendarBooking.setStatus(status);\n\t\tcalendarBooking.setStatusByUserId(user.getUserId());\n\t\tcalendarBooking.setStatusByUserName(user.getFullName());\n\t\tcalendarBooking.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tcalendarBookingPersistence.update(calendarBooking);\n\n\t\t// Child calendar bookings\n\n\t\tif (status == CalendarBookingWorkflowConstants.STATUS_IN_TRASH) {\n\t\t\tList<CalendarBooking> childCalendarBookings =\n\t\t\t\tcalendarBooking.getChildCalendarBookings();\n\n\t\t\tfor (CalendarBooking childCalendarBooking : childCalendarBookings) {\n\t\t\t\tif (childCalendarBooking.equals(calendarBooking)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tupdateStatus(\n\t\t\t\t\tuserId, childCalendarBooking,\n\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_IN_TRASH,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\t\telse if (oldStatus ==\n\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_IN_TRASH) {\n\n\t\t\tList<CalendarBooking> childCalendarBookings =\n\t\t\t\tcalendarBooking.getChildCalendarBookings();\n\n\t\t\tfor (CalendarBooking childCalendarBooking : childCalendarBookings) {\n\t\t\t\tif (childCalendarBooking.equals(calendarBooking)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tupdateStatus(\n\t\t\t\t\tuserId, childCalendarBooking,\n\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_PENDING,\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\n\t\t// Asset\n\n\t\tif (status == CalendarBookingWorkflowConstants.STATUS_APPROVED) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\tcalendarBooking.getCalendarBookingId(), true);\n\t\t}\n\t\telse if (status == CalendarBookingWorkflowConstants.STATUS_IN_TRASH) {\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\tcalendarBooking.getCalendarBookingId(), false);\n\t\t}\n\n\t\t// Trash\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\ttrashEntryLocalService.deleteEntry(\n\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\tcalendarBooking.getCalendarBookingId());\n\t\t}\n\n\t\tif (status == CalendarBookingWorkflowConstants.STATUS_IN_TRASH) {\n\t\t\tif (calendarBooking.isMasterBooking()) {\n\t\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\t\t\tcalendarBooking.getUuid(), null, oldStatus, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttrashEntryLocalService.addTrashEntry(\n\t\t\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\t\t\tCalendarBooking.class.getName(),\n\t\t\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\t\t\tcalendarBooking.getUuid(), null,\n\t\t\t\t\tCalendarBookingWorkflowConstants.STATUS_PENDING, null,\n\t\t\t\t\tnull);\n\t\t\t}\n\n\t\t\tsendNotification(\n\t\t\t\tcalendarBooking, NotificationTemplateType.MOVED_TO_TRASH,\n\t\t\t\tserviceContext);\n\t\t}\n\n\t\treturn calendarBooking;\n\t}","commit_id":"0534e486caa4a9995432c7dbd20dd6342a2ef0b2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic CalendarBooking moveCalendarBookingToTrash(\n\t\t\tlong userId, CalendarBooking calendarBooking)\n\t\tthrows PortalException {\n\n\t\tif (!calendarBooking.isMasterBooking()) {\n\t\t\treturn calendarBooking;\n\t\t}\n\n\t\tcalendarBookingLocalService.updateStatus(\n\t\t\tuserId, calendarBooking,\n\t\t\tCalendarBookingWorkflowConstants.STATUS_IN_TRASH,\n\t\t\tnew ServiceContext());\n\n\t\tsocialActivityCounterLocalService.disableActivityCounters(\n\t\t\tCalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\tCalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\tSocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\tgetExtraDataJSON(calendarBooking), 0);\n\n\t\treturn calendarBooking;\n\t}","id":35973,"modified_method":"@Override\n\tpublic CalendarBooking moveCalendarBookingToTrash(\n\t\t\tlong userId, CalendarBooking calendarBooking)\n\t\tthrows PortalException {\n\n\t\tif (!calendarBooking.isMasterBooking()) {\n\t\t\treturn calendarBooking;\n\t\t}\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tserviceContext.setUserId(userId);\n\n\t\tcalendarBookingLocalService.updateStatus(\n\t\t\tuserId, calendarBooking,\n\t\t\tCalendarBookingWorkflowConstants.STATUS_IN_TRASH, serviceContext);\n\n\t\tsocialActivityCounterLocalService.disableActivityCounters(\n\t\t\tCalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId());\n\n\t\tsocialActivityLocalService.addActivity(\n\t\t\tuserId, calendarBooking.getGroupId(),\n\t\t\tCalendarBooking.class.getName(),\n\t\t\tcalendarBooking.getCalendarBookingId(),\n\t\t\tSocialActivityConstants.TYPE_MOVE_TO_TRASH,\n\t\t\tgetExtraDataJSON(calendarBooking), 0);\n\n\t\treturn calendarBooking;\n\t}","commit_id":"0534e486caa4a9995432c7dbd20dd6342a2ef0b2","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"/**\n     * Improved toString method for an Event.\n     * This method prints out the event topic and all of the properties.\n     */\n    public static String toString(final Event e) {\n        if ( e == null ) {\n            return \"<null>\";\n        }\n        final StringBuilder buffer = new StringBuilder(e.getClass().getName());\n        buffer.append(\" [topic=\");\n        buffer.append(e.getTopic());\n        buffer.append(\", properties=\");\n        final String[] names = e.getPropertyNames();\n        if ( names != null ) {\n            for(int i=0;i<names.length;i++) {\n                if ( i>0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(names[i]);\n                buffer.append('=');\n                buffer.append(e.getProperty(names[i]));\n            }\n        }\n        buffer.append(\"]\");\n        return buffer.toString();\n    }","id":35974,"modified_method":"/**\n     * Improved toString method for an Event.\n     * This method prints out the event topic and all of the properties.\n     */\n    public static String toString(final Event e) {\n        if ( e == null ) {\n            return \"<null>\";\n        }\n        final StringBuilder buffer = new StringBuilder(e.getClass().getName());\n        buffer.append('(');\n        buffer.append(e.hashCode());\n        buffer.append(\") [topic=\");\n        buffer.append(e.getTopic());\n        buffer.append(\", properties=\");\n        final String[] names = e.getPropertyNames();\n        if ( names != null ) {\n            for(int i=0;i<names.length;i++) {\n                if ( i>0) {\n                    buffer.append(\",\");\n                }\n                buffer.append(names[i]);\n                buffer.append('=');\n                buffer.append(e.getProperty(names[i]));\n            }\n        }\n        buffer.append(\"]\");\n        return buffer.toString();\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This method is invoked periodically.\n     * @see java.lang.Runnable#run()\n     */\n    public void run() {\n        if ( this.running ) {\n            // check for jobs that were started but never got an aknowledge\n            final long tooOld = System.currentTimeMillis() - this.waitForAckMs;\n            // to keep the synchronized block as fast as possible we just store the\n            // jobs to be removed in a new list and process this list afterwards\n            final List<StartedJobInfo> restartJobs = new ArrayList<StartedJobInfo>();\n            synchronized ( this.processingEventsList ) {\n                final Iterator<Map.Entry<String, StartedJobInfo>> i = this.processingEventsList.entrySet().iterator();\n                while ( i.hasNext() ) {\n                    final Map.Entry<String, StartedJobInfo> entry = i.next();\n                    if ( entry.getValue().started <= tooOld ) {\n                        restartJobs.add(entry.getValue());\n                    }\n                }\n            }\n            // remove obsolete jobs from the repository\n            if ( this.cleanupPeriod > 0 ) {\n                this.logger.debug(\"Cleaning up repository, removing all finished jobs older than {} minutes.\", this.cleanupPeriod);\n\n                final String queryString = this.getCleanUpQueryString();\n                // we create an own session for concurrency issues\n                Session s = null;\n                try {\n                    s = this.createSession();\n                    final Node parentNode = (Node)s.getItem(this.repositoryPath);\n                    logger.debug(\"Executing query {}\", queryString);\n                    final Query q = s.getWorkspace().getQueryManager().createQuery(queryString, Query.XPATH);\n                    final NodeIterator iter = q.execute().getNodes();\n                    int count = 0;\n                    while ( iter.hasNext() ) {\n                        final Node eventNode = iter.nextNode();\n                        eventNode.remove();\n                        count++;\n                    }\n                    parentNode.save();\n                    logger.debug(\"Removed {} entries from the repository.\", count);\n\n                } catch (RepositoryException e) {\n                    // in the case of an error, we just log this as a warning\n                    this.logger.warn(\"Exception during repository cleanup.\", e);\n                } finally {\n                    if ( s != null ) {\n                        s.logout();\n                    }\n                }\n            }\n            // restart jobs is now a list of potential candidates, we now have to check\n            // each candidate separately again!\n            if ( restartJobs.size() > 0 ) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    // we just ignore this\n                    this.ignoreException(e);\n                }\n            }\n            final Iterator<StartedJobInfo> jobIter = restartJobs.iterator();\n            while ( jobIter.hasNext() ) {\n                final StartedJobInfo info = jobIter.next();\n                boolean process = false;\n                synchronized ( this.processingEventsList ) {\n                    process = this.processingEventsList.remove(info.nodePath) != null;\n                }\n                if ( process ) {\n                    this.logger.info(\"No acknowledge received for job {} stored at {}. Requeueing job.\", info.event, info.nodePath);\n                    this.finishedJob(info.event, info.nodePath, true);\n                }\n            }\n\n            // check for idle threads\n            synchronized ( this.jobQueues ) {\n                final Iterator<Map.Entry<String, JobBlockingQueue>> i = this.jobQueues.entrySet().iterator();\n                while ( i.hasNext() ) {\n                    final Map.Entry<String, JobBlockingQueue> current = i.next();\n                    final JobBlockingQueue jbq = current.getValue();\n                    if ( jbq.size() == 0 ) {\n                        if ( jbq.isMarkedForCleanUp() ) {\n                            // set to finished\n                            jbq.setFinished(true);\n                            // wake up\n                            try {\n                                jbq.put(new EventInfo());\n                            } catch (InterruptedException e) {\n                                this.ignoreException(e);\n                            }\n                            // remove\n                            i.remove();\n                        } else {\n                            // mark to be removed during next cycle\n                            jbq.markForCleanUp();\n                        }\n                    }\n                }\n            }\n        }\n    }","id":35975,"modified_method":"/**\n     * This method is invoked periodically.\n     * @see java.lang.Runnable#run()\n     */\n    public void run() {\n        if ( this.running ) {\n            // check for jobs that were started but never got an aknowledge\n            final long tooOld = System.currentTimeMillis() - this.waitForAckMs;\n            // to keep the synchronized block as fast as possible we just store the\n            // jobs to be removed in a new list and process this list afterwards\n            final List<StartedJobInfo> restartJobs = new ArrayList<StartedJobInfo>();\n            synchronized ( this.processingEventsList ) {\n                final Iterator<Map.Entry<String, StartedJobInfo>> i = this.processingEventsList.entrySet().iterator();\n                while ( i.hasNext() ) {\n                    final Map.Entry<String, StartedJobInfo> entry = i.next();\n                    if ( entry.getValue().started <= tooOld ) {\n                        restartJobs.add(entry.getValue());\n                    }\n                }\n            }\n            // remove obsolete jobs from the repository\n            if ( this.cleanupPeriod > 0 ) {\n                this.logger.debug(\"Cleaning up repository, removing all finished jobs older than {} minutes.\", this.cleanupPeriod);\n\n                final String queryString = this.getCleanUpQueryString();\n                // we create an own session for concurrency issues\n                Session s = null;\n                try {\n                    s = this.createSession();\n                    final Node parentNode = (Node)s.getItem(this.repositoryPath);\n                    logger.debug(\"Executing query {}\", queryString);\n                    final Query q = s.getWorkspace().getQueryManager().createQuery(queryString, Query.XPATH);\n                    final NodeIterator iter = q.execute().getNodes();\n                    int count = 0;\n                    while ( iter.hasNext() ) {\n                        final Node eventNode = iter.nextNode();\n                        eventNode.remove();\n                        count++;\n                    }\n                    parentNode.save();\n                    logger.debug(\"Removed {} entries from the repository.\", count);\n\n                } catch (RepositoryException e) {\n                    // in the case of an error, we just log this as a warning\n                    this.logger.warn(\"Exception during repository cleanup.\", e);\n                } finally {\n                    if ( s != null ) {\n                        s.logout();\n                    }\n                }\n            }\n            // restart jobs is now a list of potential candidates, we now have to check\n            // each candidate separately again!\n            if ( restartJobs.size() > 0 ) {\n                try {\n                    Thread.sleep(500);\n                } catch (InterruptedException e) {\n                    // we just ignore this\n                    this.ignoreException(e);\n                }\n            }\n            final Iterator<StartedJobInfo> jobIter = restartJobs.iterator();\n            while ( jobIter.hasNext() ) {\n                final StartedJobInfo info = jobIter.next();\n                boolean process = false;\n                synchronized ( this.processingEventsList ) {\n                    process = this.processingEventsList.remove(info.nodePath) != null;\n                }\n                if ( process ) {\n                    this.logger.info(\"No acknowledge received for job {} stored at {}. Requeueing job.\", EventUtil.toString(info.event), info.nodePath);\n                    this.finishedJob(info.event, info.nodePath, true);\n                }\n            }\n\n            // check for idle threads\n            synchronized ( this.jobQueues ) {\n                final Iterator<Map.Entry<String, JobBlockingQueue>> i = this.jobQueues.entrySet().iterator();\n                while ( i.hasNext() ) {\n                    final Map.Entry<String, JobBlockingQueue> current = i.next();\n                    final JobBlockingQueue jbq = current.getValue();\n                    if ( jbq.size() == 0 ) {\n                        if ( jbq.isMarkedForCleanUp() ) {\n                            // set to finished\n                            jbq.setFinished(true);\n                            // wake up\n                            try {\n                                jbq.put(new EventInfo());\n                            } catch (InterruptedException e) {\n                                this.ignoreException(e);\n                            }\n                            // remove\n                            i.remove();\n                        } else {\n                            // mark to be removed during next cycle\n                            jbq.markForCleanUp();\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Process a job\n     */\n    private Status executeJob(final EventInfo info, final BlockingQueue<EventInfo> jobQueue) {\n        boolean putback = false;\n        boolean wait = false;\n        synchronized (this.backgroundLock) {\n            logger.debug(\"Executing job {}.\", info.event);\n            try {\n                this.backgroundSession.refresh(false);\n                // check if the node still exists\n                if ( this.backgroundSession.itemExists(info.nodePath)\n                     && !this.backgroundSession.itemExists(info.nodePath + \"/\" + EventHelper.NODE_PROPERTY_FINISHED)) {\n                    final Event event = info.event;\n                    final String jobTopic = (String)event.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n                    final ParallelInfo parInfo = ParallelInfo.getParallelInfo(event);\n\n                    // check how we can process this job:\n                    // if the job should not be processed in parallel, we have to check\n                    //     if another job with the same topic is currently running\n                    // if parallel processing is allowed, we have to check for the number\n                    //     of max allowed parallel jobs for this topic\n                    boolean process = parInfo.processParallel;\n                    if ( !parInfo.processParallel ) {\n                        synchronized ( this.processingMap ) {\n                            final Boolean value = this.processingMap.get(jobTopic);\n                            if ( value == null || !value.booleanValue() ) {\n                                this.processingMap.put(jobTopic, Boolean.TRUE);\n                                process = true;\n                            }\n                        }\n                    } else {\n                        if ( parInfo.maxParallelJob > 1 ) {\n                            synchronized ( this.parallelProcessingMap ) {\n                                final Integer value = this.parallelProcessingMap.get(jobTopic);\n                                final int currentValue = (value == null ? 0 : value.intValue());\n                                if ( currentValue < parInfo.maxParallelJob ) {\n                                    this.parallelProcessingMap.put(jobTopic, currentValue + 1);\n                                } else {\n                                    process = false;\n                                }\n                            }\n                        }\n                    }\n                    // check number of parallel jobs for main queue\n                    if ( process && jobQueue == null && this.parallelJobCount >= this.maximumParallelJobs ) {\n                        logger.debug(\"Rescheduling job {} - maximum parallel job count of {} reached!\", info.event, this.maximumParallelJobs);\n                        process = false;\n                        wait = true;\n                    }\n                    if ( process ) {\n                        boolean unlock = true;\n                        try {\n                            final Node eventNode = (Node) this.backgroundSession.getItem(info.nodePath);\n                            if ( !eventNode.isLocked() ) {\n                                // lock node\n                                try {\n                                    eventNode.lock(false, true);\n                                } catch (RepositoryException re) {\n                                    // lock failed which means that the node is locked by someone else, so we don't have to requeue\n                                    process = false;\n                                }\n                                if ( process ) {\n                                    unlock = false;\n                                    this.processJob(info.event, eventNode, jobQueue == null);\n                                    return Status.SUCCESS;\n                                }\n                            }\n                        } catch (RepositoryException e) {\n                            // ignore\n                            this.ignoreException(e);\n                        } finally {\n                            if ( unlock ) {\n                                if ( !parInfo.processParallel ) {\n                                    synchronized ( this.processingMap ) {\n                                        this.processingMap.put(jobTopic, Boolean.FALSE);\n                                    }\n                                } else {\n                                    if ( parInfo.maxParallelJob > 1 ) {\n                                        synchronized ( this.parallelProcessingMap ) {\n                                            final Integer value = this.parallelProcessingMap.get(jobTopic);\n                                            this.parallelProcessingMap.put(jobTopic, value.intValue() - 1);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        try {\n                            // check if the node is in processing or already finished\n                            final Node eventNode = (Node) this.backgroundSession.getItem(info.nodePath);\n                            if ( !eventNode.isLocked() && !eventNode.hasProperty(EventHelper.NODE_PROPERTY_FINISHED)) {\n                                putback = true;\n                            }\n                        } catch (RepositoryException e) {\n                            // ignore\n                            this.ignoreException(e);\n                        }\n                    }\n                }\n            } catch (RepositoryException re) {\n                this.ignoreException(re);\n            }\n\n        }\n        // if this is the main queue and we have reached the max number of parallel jobs\n        // we wait a little bit before continuing\n        if ( wait ) {\n            logger.debug(\"Sleeping for {} seconds as the maximum number of parallel threads is reached.\", sleepTime);\n            try {\n                Thread.sleep(sleepTime * 1000);\n            } catch (InterruptedException ie) {\n                // ignore\n                ignoreException(ie);\n            }\n        }\n        // if we have to put back the job, we return this status\n        if ( putback ) {\n            return Status.RESCHEDULE;\n        }\n        return Status.FAILED;\n    }","id":35976,"modified_method":"/**\n     * Process a job\n     */\n    private Status executeJob(final EventInfo info, final BlockingQueue<EventInfo> jobQueue) {\n        boolean putback = false;\n        boolean wait = false;\n        synchronized (this.backgroundLock) {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug(\"Executing job {}.\", EventUtil.toString(info.event));\n            }\n            try {\n                this.backgroundSession.refresh(false);\n                // check if the node still exists\n                if ( this.backgroundSession.itemExists(info.nodePath)\n                     && !this.backgroundSession.itemExists(info.nodePath + \"/\" + EventHelper.NODE_PROPERTY_FINISHED)) {\n                    final Event event = info.event;\n                    final String jobTopic = (String)event.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n                    final ParallelInfo parInfo = ParallelInfo.getParallelInfo(event);\n\n                    // check how we can process this job:\n                    // if the job should not be processed in parallel, we have to check\n                    //     if another job with the same topic is currently running\n                    // if parallel processing is allowed, we have to check for the number\n                    //     of max allowed parallel jobs for this topic\n                    boolean process = parInfo.processParallel;\n                    if ( !parInfo.processParallel ) {\n                        synchronized ( this.processingMap ) {\n                            final Boolean value = this.processingMap.get(jobTopic);\n                            if ( value == null || !value.booleanValue() ) {\n                                this.processingMap.put(jobTopic, Boolean.TRUE);\n                                process = true;\n                            }\n                        }\n                    } else {\n                        if ( parInfo.maxParallelJob > 1 ) {\n                            synchronized ( this.parallelProcessingMap ) {\n                                final Integer value = this.parallelProcessingMap.get(jobTopic);\n                                final int currentValue = (value == null ? 0 : value.intValue());\n                                if ( currentValue < parInfo.maxParallelJob ) {\n                                    this.parallelProcessingMap.put(jobTopic, currentValue + 1);\n                                } else {\n                                    process = false;\n                                }\n                            }\n                        }\n                    }\n                    // check number of parallel jobs for main queue\n                    if ( process && jobQueue == null && this.parallelJobCount >= this.maximumParallelJobs ) {\n                        if ( logger.isDebugEnabled() ) {\n                            logger.debug(\"Rescheduling job {} - maximum parallel job count of {} reached!\", EventUtil.toString(info.event), this.maximumParallelJobs);\n                        }\n                        process = false;\n                        wait = true;\n                    }\n                    if ( process ) {\n                        boolean unlock = true;\n                        try {\n                            final Node eventNode = (Node) this.backgroundSession.getItem(info.nodePath);\n                            if ( !eventNode.isLocked() ) {\n                                // lock node\n                                try {\n                                    eventNode.lock(false, true);\n                                } catch (RepositoryException re) {\n                                    // lock failed which means that the node is locked by someone else, so we don't have to requeue\n                                    process = false;\n                                }\n                                if ( process ) {\n                                    unlock = false;\n                                    this.processJob(info.event, eventNode, jobQueue == null);\n                                    return Status.SUCCESS;\n                                }\n                            }\n                        } catch (RepositoryException e) {\n                            // ignore\n                            this.ignoreException(e);\n                        } finally {\n                            if ( unlock ) {\n                                if ( !parInfo.processParallel ) {\n                                    synchronized ( this.processingMap ) {\n                                        this.processingMap.put(jobTopic, Boolean.FALSE);\n                                    }\n                                } else {\n                                    if ( parInfo.maxParallelJob > 1 ) {\n                                        synchronized ( this.parallelProcessingMap ) {\n                                            final Integer value = this.parallelProcessingMap.get(jobTopic);\n                                            this.parallelProcessingMap.put(jobTopic, value.intValue() - 1);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    } else {\n                        try {\n                            // check if the node is in processing or already finished\n                            final Node eventNode = (Node) this.backgroundSession.getItem(info.nodePath);\n                            if ( !eventNode.isLocked() && !eventNode.hasProperty(EventHelper.NODE_PROPERTY_FINISHED)) {\n                                putback = true;\n                            }\n                        } catch (RepositoryException e) {\n                            // ignore\n                            this.ignoreException(e);\n                        }\n                    }\n                }\n            } catch (RepositoryException re) {\n                this.ignoreException(re);\n            }\n\n        }\n        // if this is the main queue and we have reached the max number of parallel jobs\n        // we wait a little bit before continuing\n        if ( wait ) {\n            logger.debug(\"Sleeping for {} seconds as the maximum number of parallel threads is reached.\", sleepTime);\n            try {\n                Thread.sleep(sleepTime * 1000);\n            } catch (InterruptedException ie) {\n                // ignore\n                ignoreException(ie);\n            }\n        }\n        // if we have to put back the job, we return this status\n        if ( putback ) {\n            return Status.RESCHEDULE;\n        }\n        return Status.FAILED;\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Process a job and unlock the node in the repository.\n     * @param event The original event.\n     * @param eventNode The node in the repository where the job is stored.\n     * @param isMainQueue Is this the main queue?\n     */\n    private void processJob(Event event, Node eventNode, boolean isMainQueue)  {\n        final ParallelInfo parInfo = ParallelInfo.getParallelInfo(event);\n        final boolean parallelProcessing = parInfo.processParallel;\n        final String jobTopic = (String)event.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n        logger.debug(\"Starting job {}\", event);\n        boolean unlock = true;\n        try {\n            if ( isMainQueue ) {\n                this.parallelJobCount++;\n            }\n            final String nodePath = eventNode.getPath();\n            final Event jobEvent = this.getJobEvent(event, nodePath);\n            eventNode.setProperty(EventHelper.NODE_PROPERTY_PROCESSOR, this.applicationId);\n            eventNode.save();\n            final EventAdmin localEA = this.eventAdmin;\n            if ( localEA != null ) {\n                final StartedJobInfo jobInfo = new StartedJobInfo(jobEvent, nodePath, System.currentTimeMillis());\n                // let's add the event to our processing list\n                synchronized ( this.processingEventsList ) {\n                    this.processingEventsList.put(nodePath, jobInfo);\n                }\n\n                // we need async delivery, otherwise we might create a deadlock\n                // as this method runs inside a synchronized block and the finishedJob\n                // method as well!\n                localEA.postEvent(jobEvent);\n                // do not unlock if sending was successful\n                unlock = false;\n            } else {\n                this.logger.error(\"Job event can't be sent as no event admin is available.\");\n            }\n        } catch (RepositoryException re) {\n            // if an exception occurs, we just log\n            this.logger.error(\"Exception during job processing.\", re);\n        } finally {\n            if ( unlock ) {\n                if ( isMainQueue ) {\n                    this.parallelJobCount--;\n                }\n                if ( !parallelProcessing ) {\n                    synchronized ( this.processingMap ) {\n                        this.processingMap.put(jobTopic, Boolean.FALSE);\n                    }\n                } else {\n                    if ( parInfo.maxParallelJob > 1 ) {\n                        synchronized ( this.parallelProcessingMap ) {\n                            final Integer value = this.parallelProcessingMap.get(jobTopic);\n                            this.parallelProcessingMap.put(jobTopic, value.intValue() - 1);\n                        }\n                    }\n                }\n\n                // unlock node\n                try {\n                    eventNode.unlock();\n                } catch (RepositoryException e) {\n                    // if unlock fails, we silently ignore this\n                    this.ignoreException(e);\n                }\n            }\n        }\n    }","id":35977,"modified_method":"/**\n     * Process a job and unlock the node in the repository.\n     * @param event The original event.\n     * @param eventNode The node in the repository where the job is stored.\n     * @param isMainQueue Is this the main queue?\n     */\n    private void processJob(Event event, Node eventNode, boolean isMainQueue)  {\n        final ParallelInfo parInfo = ParallelInfo.getParallelInfo(event);\n        final boolean parallelProcessing = parInfo.processParallel;\n        final String jobTopic = (String)event.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"Starting job {}\", EventUtil.toString(event));\n        }\n        boolean unlock = true;\n        try {\n            if ( isMainQueue ) {\n                this.parallelJobCount++;\n            }\n            final String nodePath = eventNode.getPath();\n            final Event jobEvent = this.getJobEvent(event, nodePath);\n            eventNode.setProperty(EventHelper.NODE_PROPERTY_PROCESSOR, this.applicationId);\n            eventNode.save();\n            final EventAdmin localEA = this.eventAdmin;\n            if ( localEA != null ) {\n                final StartedJobInfo jobInfo = new StartedJobInfo(jobEvent, nodePath, System.currentTimeMillis());\n                // let's add the event to our processing list\n                synchronized ( this.processingEventsList ) {\n                    this.processingEventsList.put(nodePath, jobInfo);\n                }\n\n                // we need async delivery, otherwise we might create a deadlock\n                // as this method runs inside a synchronized block and the finishedJob\n                // method as well!\n                localEA.postEvent(jobEvent);\n                // do not unlock if sending was successful\n                unlock = false;\n            } else {\n                this.logger.error(\"Job event can't be sent as no event admin is available.\");\n            }\n        } catch (RepositoryException re) {\n            // if an exception occurs, we just log\n            this.logger.error(\"Exception during job processing.\", re);\n        } finally {\n            if ( unlock ) {\n                if ( isMainQueue ) {\n                    this.parallelJobCount--;\n                }\n                if ( !parallelProcessing ) {\n                    synchronized ( this.processingMap ) {\n                        this.processingMap.put(jobTopic, Boolean.FALSE);\n                    }\n                } else {\n                    if ( parInfo.maxParallelJob > 1 ) {\n                        synchronized ( this.parallelProcessingMap ) {\n                            final Integer value = this.parallelProcessingMap.get(jobTopic);\n                            this.parallelProcessingMap.put(jobTopic, value.intValue() - 1);\n                        }\n                    }\n                }\n\n                // unlock node\n                try {\n                    eventNode.unlock();\n                } catch (RepositoryException e) {\n                    // if unlock fails, we silently ignore this\n                    this.ignoreException(e);\n                }\n            }\n        }\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.event.impl.AbstractRepositoryEventHandler#processWriteQueue()\n     */\n    protected void processWriteQueue() {\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            Event event = null;\n            try {\n                event = this.writeQueue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n            if ( event != null && this.running ) {\n                logger.debug(\"Persisting job {}\", event);\n                final EventInfo info = new EventInfo();\n                info.event = event;\n                final String jobId = (String)event.getProperty(EventUtil.PROPERTY_JOB_ID);\n                final String jobTopic = (String)event.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n                final String nodePath = this.getNodePath(jobTopic, jobId);\n\n                // if the job has no job id, we can just write the job to the repo and don't\n                // need locking\n                if ( jobId == null ) {\n                    try {\n                        synchronized ( this.writeLock ) {\n                            final Node eventNode = this.writeEvent(event, nodePath);\n                            info.nodePath = eventNode.getPath();\n                        }\n                    } catch (RepositoryException re ) {\n                        // something went wrong, so let's log it\n                        this.logger.error(\"Exception during writing new job '\" + EventUtil.toString(event) + \"' to repository at \" + nodePath, re);\n                    }\n                } else {\n                    synchronized ( this.writeLock ) {\n                        try {\n                            this.writerSession.refresh(false);\n                        } catch (RepositoryException re) {\n                            // we just ignore this\n                            this.ignoreException(re);\n                        }\n                        try {\n                            // let's first search for an existing node with the same id\n                            final Node parentNode = this.getWriterRootNode();\n                            Node foundNode = null;\n                            if ( parentNode.hasNode(nodePath) ) {\n                                foundNode = parentNode.getNode(nodePath);\n                            }\n                            if ( foundNode != null ) {\n                                // if the node is locked, someone else was quicker\n                                // and we don't have to process this job\n                                if ( !foundNode.isLocked() ) {\n                                    // node is already in repository, so if not finished we just use it\n                                    // otherwise it has already been processed\n                                    try {\n                                        if ( !foundNode.hasProperty(EventHelper.NODE_PROPERTY_FINISHED) ) {\n                                            info.nodePath = foundNode.getPath();\n                                        }\n                                    } catch (RepositoryException re) {\n                                        // if anything goes wrong, it means that (hopefully) someone\n                                        // else is processing this node\n                                    }\n                                }\n                            } else {\n                                // We now write the event into the repository\n                                try {\n                                    final Node eventNode = this.writeEvent(event, nodePath);\n                                    info.nodePath = eventNode.getPath();\n                                } catch (ItemExistsException iee) {\n                                    // someone else did already write this node in the meantime\n                                    // nothing to do for us\n                                }\n                            }\n                        } catch (RepositoryException re ) {\n                            // something went wrong, so let's log it\n                            this.logger.error(\"Exception during writing new job '\" + event + \"' to repository at \" + nodePath, re);\n                        }\n                    }\n                }\n                // if we were able to write the event into the repository\n                // we will queue it for processing\n                if ( info.nodePath != null ) {\n                    try {\n                        this.queue.put(info);\n                    } catch (InterruptedException e) {\n                        // this should never happen\n                        this.ignoreException(e);\n                    }\n                }\n            }\n        }\n    }","id":35978,"modified_method":"/**\n     * @see org.apache.sling.event.impl.AbstractRepositoryEventHandler#processWriteQueue()\n     */\n    protected void processWriteQueue() {\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            Event event = null;\n            try {\n                event = this.writeQueue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n            if ( event != null && this.running ) {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug(\"Persisting job {}\", EventUtil.toString(event));\n                }\n                final EventInfo info = new EventInfo();\n                info.event = event;\n                final String jobId = (String)event.getProperty(EventUtil.PROPERTY_JOB_ID);\n                final String jobTopic = (String)event.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n                final String nodePath = this.getNodePath(jobTopic, jobId);\n\n                // if the job has no job id, we can just write the job to the repo and don't\n                // need locking\n                if ( jobId == null ) {\n                    try {\n                        synchronized ( this.writeLock ) {\n                            final Node eventNode = this.writeEvent(event, nodePath);\n                            info.nodePath = eventNode.getPath();\n                        }\n                    } catch (RepositoryException re ) {\n                        // something went wrong, so let's log it\n                        this.logger.error(\"Exception during writing new job '\" + EventUtil.toString(event) + \"' to repository at \" + nodePath, re);\n                    }\n                } else {\n                    synchronized ( this.writeLock ) {\n                        try {\n                            this.writerSession.refresh(false);\n                        } catch (RepositoryException re) {\n                            // we just ignore this\n                            this.ignoreException(re);\n                        }\n                        try {\n                            // let's first search for an existing node with the same id\n                            final Node parentNode = this.getWriterRootNode();\n                            Node foundNode = null;\n                            if ( parentNode.hasNode(nodePath) ) {\n                                foundNode = parentNode.getNode(nodePath);\n                            }\n                            if ( foundNode != null ) {\n                                // if the node is locked, someone else was quicker\n                                // and we don't have to process this job\n                                if ( !foundNode.isLocked() ) {\n                                    // node is already in repository, so if not finished we just use it\n                                    // otherwise it has already been processed\n                                    try {\n                                        if ( !foundNode.hasProperty(EventHelper.NODE_PROPERTY_FINISHED) ) {\n                                            info.nodePath = foundNode.getPath();\n                                        }\n                                    } catch (RepositoryException re) {\n                                        // if anything goes wrong, it means that (hopefully) someone\n                                        // else is processing this node\n                                    }\n                                }\n                            } else {\n                                // We now write the event into the repository\n                                try {\n                                    final Node eventNode = this.writeEvent(event, nodePath);\n                                    info.nodePath = eventNode.getPath();\n                                } catch (ItemExistsException iee) {\n                                    // someone else did already write this node in the meantime\n                                    // nothing to do for us\n                                }\n                            }\n                        } catch (RepositoryException re ) {\n                            // something went wrong, so let's log it\n                            this.logger.error(\"Exception during writing new job '\" + EventUtil.toString(event) + \"' to repository at \" + nodePath, re);\n                        }\n                    }\n                }\n                // if we were able to write the event into the repository\n                // we will queue it for processing\n                if ( info.nodePath != null ) {\n                    try {\n                        this.queue.put(info);\n                    } catch (InterruptedException e) {\n                        // this should never happen\n                        this.ignoreException(e);\n                    }\n                }\n            }\n        }\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This method runs in the background and processes the local queue.\n     */\n    protected void runInBackground() throws RepositoryException {\n        this.backgroundSession = this.createSession();\n        this.backgroundSession.getWorkspace().getObservationManager()\n                .addEventListener(this,\n                                  javax.jcr.observation.Event.PROPERTY_REMOVED\n                                    |javax.jcr.observation.Event.NODE_REMOVED,\n                                  this.repositoryPath,\n                                  true,\n                                  null,\n                                  new String[] {this.getEventNodeType()},\n                                  true);\n        // load unprocessed jobs from repository\n        if ( this.running ) {\n            logger.info(\"Apache Sling Job Event Handler started.\");\n            logger.debug(\"Job Handler Configuration: (sleepTime={} secs, maxJobRetries={}, waitForAck={} ms, maximumParallelJobs={}, cleanupPeriod={} min)\",\n                    new Object[] {sleepTime, maxJobRetries,waitForAckMs,maximumParallelJobs,cleanupPeriod});\n        } else {\n            final ComponentContext ctx = this.componentContext;\n            // deactivate\n            if ( ctx != null ) {\n                logger.info(\"Deactivating component {} due to errors during startup.\", ctx.getProperties().get(Constants.SERVICE_ID));\n                final String name = (String) componentContext.getProperties().get(\n                    ComponentConstants.COMPONENT_NAME);\n                ctx.disableComponent(name);\n            }\n        }\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n\n            if ( info != null && this.running ) {\n                logger.debug(\"Processing new job {}\", info.event);\n                // check for local only jobs and remove them from the queue if they're meant\n                // for another application node\n                final String appId = (String)info.event.getProperty(EventUtil.PROPERTY_APPLICATION);\n                if ( info.event.getProperty(EventUtil.PROPERTY_JOB_RUN_LOCAL) != null\n                    && appId != null && !this.applicationId.equals(appId) ) {\n                    logger.debug(\"Discarding job {} : local job for a different application node.\", info.event);\n                    info = null;\n                }\n\n                // check if we should put this into a separate queue\n                if ( info != null && info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                    final String queueName = (String)info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME);\n                    synchronized ( this.jobQueues ) {\n                        logger.debug(\"Queuing job {} into queue {}.\", info.event, queueName);\n                        BlockingQueue<EventInfo> jobQueue = this.jobQueues.get(queueName);\n                        if ( jobQueue == null ) {\n                            final boolean orderedQueue = info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_ORDERED) != null;\n                            final JobBlockingQueue jq = new JobBlockingQueue(queueName, orderedQueue, this.logger);\n                            jobQueue = jq;\n                            this.jobQueues.put(queueName, jq);\n                            // Start background thread\n                            this.threadPool.execute(new Runnable() {\n\n                                /**\n                                 * @see java.lang.Runnable#run()\n                                 */\n                                public void run() {\n                                    while ( running && !jq.isFinished() ) {\n                                        logger.info(\"Starting {}job queue {}\", (orderedQueue ? \"ordered \" : \"\"), queueName);\n                                        try {\n                                            runJobQueue(queueName, jq);\n                                        } catch (Throwable t) {\n                                            logger.error(\"Job queue stopped with exception: \" + t.getMessage() + \". Restarting.\", t);\n                                        }\n                                    }\n                                }\n\n                            });\n                        }\n                        try {\n                            jobQueue.put(info);\n                        } catch (InterruptedException e) {\n                            // this should never happen\n                            this.ignoreException(e);\n                        }\n                    }\n                    // don't process this here\n                    info = null;\n                }\n\n                // if we still have a job, process it\n                if ( info != null ) {\n                    if ( this.executeJob(info, null) == Status.RESCHEDULE ) {\n                        this.putBackIntoMainQueue(info, true);\n                    }\n                }\n            }\n        }\n    }","id":35979,"modified_method":"/**\n     * This method runs in the background and processes the local queue.\n     */\n    protected void runInBackground() throws RepositoryException {\n        this.backgroundSession = this.createSession();\n        this.backgroundSession.getWorkspace().getObservationManager()\n                .addEventListener(this,\n                                  javax.jcr.observation.Event.PROPERTY_REMOVED\n                                    |javax.jcr.observation.Event.NODE_REMOVED,\n                                  this.repositoryPath,\n                                  true,\n                                  null,\n                                  new String[] {this.getEventNodeType()},\n                                  true);\n        // load unprocessed jobs from repository\n        if ( this.running ) {\n            logger.info(\"Apache Sling Job Event Handler started.\");\n            logger.debug(\"Job Handler Configuration: (sleepTime={} secs, maxJobRetries={}, waitForAck={} ms, maximumParallelJobs={}, cleanupPeriod={} min)\",\n                    new Object[] {sleepTime, maxJobRetries,waitForAckMs,maximumParallelJobs,cleanupPeriod});\n        } else {\n            final ComponentContext ctx = this.componentContext;\n            // deactivate\n            if ( ctx != null ) {\n                logger.info(\"Deactivating component {} due to errors during startup.\", ctx.getProperties().get(Constants.SERVICE_ID));\n                final String name = (String) componentContext.getProperties().get(\n                    ComponentConstants.COMPONENT_NAME);\n                ctx.disableComponent(name);\n            }\n        }\n        while ( this.running ) {\n            // so let's wait/get the next job from the queue\n            EventInfo info = null;\n            try {\n                info = this.queue.take();\n            } catch (InterruptedException e) {\n                // we ignore this\n                this.ignoreException(e);\n            }\n\n            if ( info != null && this.running ) {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug(\"Received new job {}\", EventUtil.toString(info.event));\n                }\n                // check for local only jobs and remove them from the queue if they're meant\n                // for another application node\n                final String appId = (String)info.event.getProperty(EventUtil.PROPERTY_APPLICATION);\n                if ( info.event.getProperty(EventUtil.PROPERTY_JOB_RUN_LOCAL) != null\n                    && appId != null && !this.applicationId.equals(appId) ) {\n                    if ( logger.isDebugEnabled() ) {\n                         logger.debug(\"Discarding job {} : local job for a different application node.\", EventUtil.toString(info.event));\n                    }\n                    info = null;\n                }\n\n                // check if we should put this into a separate queue\n                if ( info != null && info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                    final String queueName = (String)info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME);\n                    synchronized ( this.jobQueues ) {\n                        if ( logger.isDebugEnabled() ) {\n                            logger.debug(\"Queuing job {} into queue {}.\", EventUtil.toString(info.event), queueName);\n                        }\n                        BlockingQueue<EventInfo> jobQueue = this.jobQueues.get(queueName);\n                        if ( jobQueue == null ) {\n                            final boolean orderedQueue = info.event.getProperty(EventUtil.PROPERTY_JOB_QUEUE_ORDERED) != null;\n                            final JobBlockingQueue jq = new JobBlockingQueue(queueName, orderedQueue, this.logger);\n                            jobQueue = jq;\n                            this.jobQueues.put(queueName, jq);\n                            // Start background thread\n                            this.threadPool.execute(new Runnable() {\n\n                                /**\n                                 * @see java.lang.Runnable#run()\n                                 */\n                                public void run() {\n                                    while ( running && !jq.isFinished() ) {\n                                        logger.info(\"Starting {}job queue {}\", (orderedQueue ? \"ordered \" : \"\"), queueName);\n                                        try {\n                                            runJobQueue(queueName, jq);\n                                        } catch (Throwable t) {\n                                            logger.error(\"Job queue stopped with exception: \" + t.getMessage() + \". Restarting.\", t);\n                                        }\n                                    }\n                                }\n\n                            });\n                        }\n                        try {\n                            jobQueue.put(info);\n                        } catch (InterruptedException e) {\n                            // this should never happen\n                            this.ignoreException(e);\n                        }\n                    }\n                    // don't process this here\n                    info = null;\n                }\n\n                // if we still have a job, process it\n                if ( info != null ) {\n                    if ( this.executeJob(info, null) == Status.RESCHEDULE ) {\n                        this.putBackIntoMainQueue(info, true);\n                    }\n                }\n            }\n        }\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"private void putBackIntoMainQueue(final EventInfo info, final boolean useSleepTime) {\n        logger.debug(\"Putting job {} back into the queue.\", info.event);\n        final Date fireDate = new Date();\n        if ( useSleepTime ) {\n            fireDate.setTime(System.currentTimeMillis() + this.sleepTime * 1000);\n        } else {\n            final long delay = (Long)info.event.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY);\n            fireDate.setTime(System.currentTimeMillis() + delay);\n        }\n\n        final Runnable t = new Runnable() {\n            public void run() {\n                try {\n                    queue.put(info);\n                } catch (InterruptedException e) {\n                    // this should never happen\n                    ignoreException(e);\n                }\n            }\n        };\n        try {\n            this.scheduler.fireJobAt(null, t, null, fireDate);\n        } catch (Exception e) {\n            // we ignore the exception and just put back the job in the queue\n            ignoreException(e);\n            if ( useSleepTime ) {\n                // then wait for the time and readd the job\n                try {\n                    Thread.sleep(sleepTime * 1000);\n                } catch (InterruptedException ie) {\n                    // ignore\n                    ignoreException(ie);\n                }\n            }\n            t.run();\n        }\n    }","id":35980,"modified_method":"private void putBackIntoMainQueue(final EventInfo info, final boolean useSleepTime) {\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"Putting job {} back into the queue.\", EventUtil.toString(info.event));\n        }\n        final Date fireDate = new Date();\n        if ( useSleepTime ) {\n            fireDate.setTime(System.currentTimeMillis() + this.sleepTime * 1000);\n        } else {\n            final long delay = (Long)info.event.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY);\n            fireDate.setTime(System.currentTimeMillis() + delay);\n        }\n\n        final Runnable t = new Runnable() {\n            public void run() {\n                try {\n                    queue.put(info);\n                } catch (InterruptedException e) {\n                    // this should never happen\n                    ignoreException(e);\n                }\n            }\n        };\n        try {\n            this.scheduler.fireJobAt(null, t, null, fireDate);\n        } catch (Exception e) {\n            // we ignore the exception and just put back the job in the queue\n            ignoreException(e);\n            if ( useSleepTime ) {\n                // then wait for the time and readd the job\n                try {\n                    Thread.sleep(sleepTime * 1000);\n                } catch (InterruptedException ie) {\n                    // ignore\n                    ignoreException(ie);\n                }\n            }\n            t.run();\n        }\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * This is a notification from the component which processed the job.\n     *\n     * @see org.apache.sling.event.EventUtil.JobStatusNotifier#finishedJob(org.osgi.service.event.Event, String, boolean)\n     */\n    public boolean finishedJob(Event job, String eventNodePath, boolean shouldReschedule) {\n        // let's remove the event from our processing list\n        // this is just a sanity check, as usually the job should have been\n        // removed during sendAcknowledge.\n        synchronized ( this.processingEventsList ) {\n            this.processingEventsList.remove(eventNodePath);\n        }\n\n        boolean reschedule = shouldReschedule;\n        if ( shouldReschedule ) {\n            // check if we exceeded the number of retries\n            int retries = this.maxJobRetries;\n            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRIES) != null ) {\n                retries = (Integer) job.getProperty(EventUtil.PROPERTY_JOB_RETRIES);\n            }\n            int retryCount = 0;\n            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                retryCount = (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT);\n            }\n            retryCount++;\n            if ( retries != -1 && retryCount > retries ) {\n                reschedule = false;\n            }\n            if ( reschedule ) {\n                // update event with retry count and retries\n                final Dictionary<String, Object> newProperties = new EventPropertiesMap(job);\n                newProperties.put(EventUtil.PROPERTY_JOB_RETRY_COUNT, retryCount);\n                newProperties.put(EventUtil.PROPERTY_JOB_RETRIES, retries);\n                job = new Event(job.getTopic(), newProperties);\n                this.sendNotification(EventUtil.TOPIC_JOB_CANCELLED, job);\n            } else {\n                this.sendNotification(EventUtil.TOPIC_JOB_FAILED, job);\n            }\n        } else {\n            this.sendNotification(EventUtil.TOPIC_JOB_FINISHED, job);\n        }\n        final ParallelInfo parInfo = ParallelInfo.getParallelInfo(job);\n        final boolean parallelProcessing = parInfo.processParallel;\n        EventInfo putback = null;\n        // we have to use the same session for unlocking that we used for locking!\n        synchronized ( this.backgroundLock ) {\n            // we might get here asnyc while this service has already been shutdown!\n            if ( this.backgroundSession == null ) {\n                checkForNotify(job, null);\n                // we can only return false here\n                return false;\n            }\n            try {\n                this.backgroundSession.refresh(false);\n                // check if the job has been cancelled\n                if ( !this.backgroundSession.itemExists(eventNodePath) ) {\n                    checkForNotify(job, null);\n                    return true;\n                }\n                final Node eventNode = (Node) this.backgroundSession.getItem(eventNodePath);\n                boolean unlock = true;\n                try {\n                    if ( !reschedule ) {\n                        synchronized ( this.deletedJobs ) {\n                            this.deletedJobs.add(eventNodePath);\n                        }\n                        // unlock node\n                        try {\n                            eventNode.unlock();\n                        } catch (RepositoryException e) {\n                            // if unlock fails, we silently ignore this\n                            this.ignoreException(e);\n                        }\n                        unlock = false;\n                        final String jobId = (String)job.getProperty(EventUtil.PROPERTY_JOB_ID);\n                        if ( jobId == null ) {\n                            // remove node from repository if no job is set\n                            final Node parentNode = eventNode.getParent();\n                            eventNode.remove();\n                            parentNode.save();\n                        } else {\n                            eventNode.setProperty(EventHelper.NODE_PROPERTY_FINISHED, Calendar.getInstance());\n                            eventNode.save();\n                        }\n                    }\n                } catch (RepositoryException re) {\n                    // if an exception occurs, we just log\n                    this.logger.error(\"Exception during job finishing.\", re);\n                } finally {\n                    final String jobTopic = (String)job.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n                    if ( !parallelProcessing) {\n                        synchronized ( this.processingMap ) {\n                            this.processingMap.put(jobTopic, Boolean.FALSE);\n                        }\n                    } else {\n                        if ( parInfo.maxParallelJob > 1 ) {\n                            synchronized ( this.parallelProcessingMap ) {\n                                final Integer value = this.parallelProcessingMap.get(jobTopic);\n                                this.parallelProcessingMap.put(jobTopic, value.intValue() - 1);\n                            }\n                        }\n                    }\n                    if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) == null ) {\n                        this.parallelJobCount--;\n                    }\n\n                    if ( unlock ) {\n                        synchronized ( this.deletedJobs ) {\n                            this.deletedJobs.add(eventNodePath);\n                        }\n                        // unlock node\n                        try {\n                            eventNode.unlock();\n                        } catch (RepositoryException e) {\n                            // if unlock fails, we silently ignore this\n                            this.ignoreException(e);\n                        }\n                    }\n                }\n                if ( reschedule ) {\n                    // update retry count and retries in the repository\n                    try {\n                        eventNode.setProperty(EventUtil.PROPERTY_JOB_RETRIES, (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRIES));\n                        eventNode.setProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT, (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT));\n                        eventNode.save();\n                    } catch (RepositoryException re) {\n                        // if an exception occurs, we just log\n                        this.logger.error(\"Exception during job updating job rescheduling information.\", re);\n                    }\n                    final EventInfo info = new EventInfo();\n                    try {\n                        info.event = job;\n                        info.nodePath = eventNode.getPath();\n                    } catch (RepositoryException e) {\n                        // this should never happen\n                        this.ignoreException(e);\n                    }\n                    // if this is an own job queue, we simply signal the queue to continue\n                    // it will pick up the event and either reschedule or wait\n                    if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                        checkForNotify(job, info);\n                    } else {\n\n                        // delay rescheduling?\n                        if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY) != null ) {\n                            putback = info;\n                        } else {\n                            // put directly into queue\n                            try {\n                                queue.put(info);\n                            } catch (InterruptedException e) {\n                                // this should never happen\n                                this.ignoreException(e);\n                            }\n                        }\n                    }\n                } else {\n                    // if this is an own job queue, we simply signal the queue to continue\n                    // it will pick up the event and continue with the next event\n                    checkForNotify(job, null);\n                }\n            } catch (RepositoryException re) {\n                this.logger.error(\"Unable to create new session.\", re);\n                return false;\n            }\n        }\n        if ( putback != null ) {\n            this.putBackIntoMainQueue(putback, false);\n        }\n        if ( !shouldReschedule ) {\n            return true;\n        }\n        return reschedule;\n    }","id":35981,"modified_method":"/**\n     * This is a notification from the component which processed the job.\n     *\n     * @see org.apache.sling.event.EventUtil.JobStatusNotifier#finishedJob(org.osgi.service.event.Event, String, boolean)\n     */\n    public boolean finishedJob(Event job, String eventNodePath, boolean shouldReschedule) {\n        if ( this.logger.isDebugEnabled() ) {\n            this.logger.debug(\"Received finish for job {}, shouldReschedule={}\", EventUtil.toString(job), shouldReschedule);\n        }\n        // let's remove the event from our processing list\n        // this is just a sanity check, as usually the job should have been\n        // removed during sendAcknowledge.\n        synchronized ( this.processingEventsList ) {\n            this.processingEventsList.remove(eventNodePath);\n        }\n\n        boolean reschedule = shouldReschedule;\n        if ( shouldReschedule ) {\n            // check if we exceeded the number of retries\n            int retries = this.maxJobRetries;\n            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRIES) != null ) {\n                retries = (Integer) job.getProperty(EventUtil.PROPERTY_JOB_RETRIES);\n            }\n            int retryCount = 0;\n            if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT) != null ) {\n                retryCount = (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT);\n            }\n            retryCount++;\n            if ( retries != -1 && retryCount > retries ) {\n                reschedule = false;\n            }\n            if ( reschedule ) {\n                // update event with retry count and retries\n                final Dictionary<String, Object> newProperties = new EventPropertiesMap(job);\n                newProperties.put(EventUtil.PROPERTY_JOB_RETRY_COUNT, retryCount);\n                newProperties.put(EventUtil.PROPERTY_JOB_RETRIES, retries);\n                job = new Event(job.getTopic(), newProperties);\n                if ( this.logger.isDebugEnabled() ) {\n                    this.logger.debug(\"Failed job {}\", EventUtil.toString(job));\n                }\n                this.sendNotification(EventUtil.TOPIC_JOB_FAILED, job);\n            } else {\n                if ( this.logger.isDebugEnabled() ) {\n                    this.logger.debug(\"Cancelled job {}\", EventUtil.toString(job));\n                }\n                this.sendNotification(EventUtil.TOPIC_JOB_CANCELLED, job);\n            }\n        } else {\n            if ( this.logger.isDebugEnabled() ) {\n                this.logger.debug(\"Finished job {}\", EventUtil.toString(job));\n            }\n            this.sendNotification(EventUtil.TOPIC_JOB_FINISHED, job);\n        }\n        final ParallelInfo parInfo = ParallelInfo.getParallelInfo(job);\n        final boolean parallelProcessing = parInfo.processParallel;\n        EventInfo putback = null;\n        // we have to use the same session for unlocking that we used for locking!\n        synchronized ( this.backgroundLock ) {\n            // we might get here asnyc while this service has already been shutdown!\n            if ( this.backgroundSession == null ) {\n                checkForNotify(job, null);\n                // we can only return false here\n                return false;\n            }\n            try {\n                this.backgroundSession.refresh(false);\n                // check if the job has been cancelled\n                if ( !this.backgroundSession.itemExists(eventNodePath) ) {\n                    checkForNotify(job, null);\n                    return true;\n                }\n                final Node eventNode = (Node) this.backgroundSession.getItem(eventNodePath);\n                boolean unlock = true;\n                try {\n                    if ( !reschedule ) {\n                        synchronized ( this.deletedJobs ) {\n                            this.deletedJobs.add(eventNodePath);\n                        }\n                        // unlock node\n                        try {\n                            eventNode.unlock();\n                        } catch (RepositoryException e) {\n                            // if unlock fails, we silently ignore this\n                            this.ignoreException(e);\n                        }\n                        unlock = false;\n                        final String jobId = (String)job.getProperty(EventUtil.PROPERTY_JOB_ID);\n                        if ( jobId == null ) {\n                            // remove node from repository if no job is set\n                            final Node parentNode = eventNode.getParent();\n                            eventNode.remove();\n                            parentNode.save();\n                        } else {\n                            eventNode.setProperty(EventHelper.NODE_PROPERTY_FINISHED, Calendar.getInstance());\n                            eventNode.save();\n                        }\n                    }\n                } catch (RepositoryException re) {\n                    // if an exception occurs, we just log\n                    this.logger.error(\"Exception during job finishing.\", re);\n                } finally {\n                    final String jobTopic = (String)job.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n                    if ( !parallelProcessing) {\n                        synchronized ( this.processingMap ) {\n                            this.processingMap.put(jobTopic, Boolean.FALSE);\n                        }\n                    } else {\n                        if ( parInfo.maxParallelJob > 1 ) {\n                            synchronized ( this.parallelProcessingMap ) {\n                                final Integer value = this.parallelProcessingMap.get(jobTopic);\n                                this.parallelProcessingMap.put(jobTopic, value.intValue() - 1);\n                            }\n                        }\n                    }\n                    if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) == null ) {\n                        this.parallelJobCount--;\n                    }\n\n                    if ( unlock ) {\n                        synchronized ( this.deletedJobs ) {\n                            this.deletedJobs.add(eventNodePath);\n                        }\n                        // unlock node\n                        try {\n                            eventNode.unlock();\n                        } catch (RepositoryException e) {\n                            // if unlock fails, we silently ignore this\n                            this.ignoreException(e);\n                        }\n                    }\n                }\n                if ( reschedule ) {\n                    // update retry count and retries in the repository\n                    try {\n                        eventNode.setProperty(EventUtil.PROPERTY_JOB_RETRIES, (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRIES));\n                        eventNode.setProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT, (Integer)job.getProperty(EventUtil.PROPERTY_JOB_RETRY_COUNT));\n                        eventNode.save();\n                    } catch (RepositoryException re) {\n                        // if an exception occurs, we just log\n                        this.logger.error(\"Exception during job updating job rescheduling information.\", re);\n                    }\n                    final EventInfo info = new EventInfo();\n                    try {\n                        info.event = job;\n                        info.nodePath = eventNode.getPath();\n                    } catch (RepositoryException e) {\n                        // this should never happen\n                        this.ignoreException(e);\n                    }\n                    // if this is an own job queue, we simply signal the queue to continue\n                    // it will pick up the event and either reschedule or wait\n                    if ( job.getProperty(EventUtil.PROPERTY_JOB_QUEUE_NAME) != null ) {\n                        checkForNotify(job, info);\n                    } else {\n\n                        // delay rescheduling?\n                        if ( job.getProperty(EventUtil.PROPERTY_JOB_RETRY_DELAY) != null ) {\n                            putback = info;\n                        } else {\n                            // put directly into queue\n                            try {\n                                queue.put(info);\n                            } catch (InterruptedException e) {\n                                // this should never happen\n                                this.ignoreException(e);\n                            }\n                        }\n                    }\n                } else {\n                    // if this is an own job queue, we simply signal the queue to continue\n                    // it will pick up the event and continue with the next event\n                    checkForNotify(job, null);\n                }\n            } catch (RepositoryException re) {\n                this.logger.error(\"Unable to create new session.\", re);\n                return false;\n            }\n        }\n        if ( putback != null ) {\n            this.putBackIntoMainQueue(putback, false);\n        }\n        if ( !shouldReschedule ) {\n            return true;\n        }\n        return reschedule;\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.osgi.service.event.EventHandler#handleEvent(org.osgi.service.event.Event)\n     */\n    public void handleEvent(final Event event) {\n        logger.debug(\"Receiving event {}\", event);\n        // we ignore remote job events\n        if ( EventUtil.isLocal(event) ) {\n            // check for bundle event\n            if ( event.getTopic().equals(EventUtil.TOPIC_JOB)) {\n                logger.debug(\"Handling local job {}\", event);\n                // job event\n                final String jobTopic = (String)event.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n\n                //  job topic must be set, otherwise we ignore this event!\n                if ( jobTopic != null ) {\n                    // queue the event in order to respond quickly\n                    try {\n                        this.writeQueue.put(event);\n                    } catch (InterruptedException e) {\n                        // this should never happen\n                        this.ignoreException(e);\n                    }\n                } else {\n                    this.logger.warn(\"Event does not contain job topic: {}\", event);\n                }\n\n            } else {\n                // bundle event started or updated\n                boolean doIt = false;\n                synchronized ( this.unloadedJobs ) {\n                    if ( this.unloadedJobs.size() > 0 ) {\n                        doIt = true;\n                    }\n                }\n                if ( doIt ) {\n                    final Runnable t = new Runnable() {\n\n                        public void run() {\n                            synchronized (unloadedJobs) {\n                                Session s = null;\n                                final Set<String> newUnloadedJobs = new HashSet<String>();\n                                newUnloadedJobs.addAll(unloadedJobs);\n                                try {\n                                    s = createSession();\n                                    for(String path : unloadedJobs ) {\n                                        newUnloadedJobs.remove(path);\n                                        try {\n                                            if ( s.itemExists(path) ) {\n                                                final Node eventNode = (Node) s.getItem(path);\n                                                if ( !eventNode.isLocked() ) {\n                                                    try {\n                                                        final EventInfo info = new EventInfo();\n                                                        info.event = readEvent(eventNode);\n                                                        info.nodePath = path;\n                                                        try {\n                                                            queue.put(info);\n                                                        } catch (InterruptedException e) {\n                                                            // we ignore this exception as this should never occur\n                                                            ignoreException(e);\n                                                        }\n                                                    } catch (ClassNotFoundException cnfe) {\n                                                        newUnloadedJobs.add(path);\n                                                        ignoreException(cnfe);\n                                                    }\n                                                }\n                                            }\n                                        } catch (RepositoryException re) {\n                                            // we ignore this and readd\n                                            newUnloadedJobs.add(path);\n                                            ignoreException(re);\n                                        }\n                                    }\n                                } catch (RepositoryException re) {\n                                    // unable to create session, so we try it again next time\n                                    ignoreException(re);\n                                } finally {\n                                    if ( s != null ) {\n                                        s.logout();\n                                    }\n                                    unloadedJobs.clear();\n                                    unloadedJobs.addAll(newUnloadedJobs);\n                                }\n                            }\n                        }\n\n                    };\n                    this.threadPool.execute(t);\n                }\n            }\n        }\n    }","id":35982,"modified_method":"/**\n     * @see org.osgi.service.event.EventHandler#handleEvent(org.osgi.service.event.Event)\n     */\n    public void handleEvent(final Event event) {\n        if ( logger.isDebugEnabled() ) {\n            logger.debug(\"Receiving event {}\", EventUtil.toString(event));\n        }\n        // we ignore remote job events\n        if ( EventUtil.isLocal(event) ) {\n            // check for bundle event\n            if ( event.getTopic().equals(EventUtil.TOPIC_JOB)) {\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug(\"Handling local job {}\", EventUtil.toString(event));\n                }\n                // job event\n                final String jobTopic = (String)event.getProperty(EventUtil.PROPERTY_JOB_TOPIC);\n\n                //  job topic must be set, otherwise we ignore this event!\n                if ( jobTopic != null ) {\n                    // queue the event in order to respond quickly\n                    try {\n                        this.writeQueue.put(event);\n                    } catch (InterruptedException e) {\n                        // this should never happen\n                        this.ignoreException(e);\n                    }\n                } else {\n                    this.logger.warn(\"Event does not contain job topic: {}\", event);\n                }\n\n            } else {\n                // bundle event started or updated\n                boolean doIt = false;\n                synchronized ( this.unloadedJobs ) {\n                    if ( this.unloadedJobs.size() > 0 ) {\n                        doIt = true;\n                    }\n                }\n                if ( doIt ) {\n                    final Runnable t = new Runnable() {\n\n                        public void run() {\n                            synchronized (unloadedJobs) {\n                                Session s = null;\n                                final Set<String> newUnloadedJobs = new HashSet<String>();\n                                newUnloadedJobs.addAll(unloadedJobs);\n                                try {\n                                    s = createSession();\n                                    for(String path : unloadedJobs ) {\n                                        newUnloadedJobs.remove(path);\n                                        try {\n                                            if ( s.itemExists(path) ) {\n                                                final Node eventNode = (Node) s.getItem(path);\n                                                if ( !eventNode.isLocked() ) {\n                                                    try {\n                                                        final EventInfo info = new EventInfo();\n                                                        info.event = readEvent(eventNode);\n                                                        info.nodePath = path;\n                                                        try {\n                                                            queue.put(info);\n                                                        } catch (InterruptedException e) {\n                                                            // we ignore this exception as this should never occur\n                                                            ignoreException(e);\n                                                        }\n                                                    } catch (ClassNotFoundException cnfe) {\n                                                        newUnloadedJobs.add(path);\n                                                        ignoreException(cnfe);\n                                                    }\n                                                }\n                                            }\n                                        } catch (RepositoryException re) {\n                                            // we ignore this and readd\n                                            newUnloadedJobs.add(path);\n                                            ignoreException(re);\n                                        }\n                                    }\n                                } catch (RepositoryException re) {\n                                    // unable to create session, so we try it again next time\n                                    ignoreException(re);\n                                } finally {\n                                    if ( s != null ) {\n                                        s.logout();\n                                    }\n                                    unloadedJobs.clear();\n                                    unloadedJobs.addAll(newUnloadedJobs);\n                                }\n                            }\n                        }\n\n                    };\n                    this.threadPool.execute(t);\n                }\n            }\n        }\n    }","commit_id":"64d78377e22056b63b6b711d0ee59d8b0b25a930","url":"https://github.com/apache/sling"},{"original_method":"protected void notifyRuntimeSubscriber(InternetAddress to, Locale locale)\n\t\tthrows Exception {\n\n\t\tString emailAddress = to.getAddress();\n\n\t\tUser user = UserLocalServiceUtil.getUserByEmailAddress(\n\t\t\tcompanyId, emailAddress);\n\n\t\tsendNotification(user);\n\t}","id":35983,"modified_method":"protected void notifyRuntimeSubscriber(InternetAddress to, Locale locale)\n\t\tthrows Exception {\n\n\t\tString emailAddress = to.getAddress();\n\n\t\tUser user = UserLocalServiceUtil.fetchUserByEmailAddress(\n\t\t\tcompanyId, emailAddress);\n\n\t\tif (user == null) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"User with verified e-mail address \" + emailAddress +\n\t\t\t\t\t\t\" does not exist\");\n\t\t\t}\n\n\t\t\tsendEmail(to, locale);\n\t\t}\n\t\telse {\n\t\t\tsendNotification(user);\n\t\t}\n\t}","commit_id":"cd71fd9c558f7583d67cc5c1d2ba25f746411dc7","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void notifyPersistedSubscriber(\n\t\t\tSubscription subscription, String className, long classPK)\n\t\tthrows Exception {\n\n\t\tUser user = UserLocalServiceUtil.fetchUserById(\n\t\t\tsubscription.getUserId());\n\n\t\tif (user == null) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Subscription \" + subscription.getSubscriptionId() +\n\t\t\t\t\t\t\" is stale and will be deleted\");\n\t\t\t}\n\n\t\t\tdeleteSubscription(subscription);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString emailAddress = user.getEmailAddress();\n\n\t\tif (_sentEmailAddresses.contains(emailAddress)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Do not send a duplicate email to \" + emailAddress);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Add \" + emailAddress +\n\t\t\t\t\t\t\" to the list of users who have received an email\");\n\t\t\t}\n\n\t\t\t_sentEmailAddresses.add(emailAddress);\n\t\t}\n\n\t\tif (!user.isActive()) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Skip inactive user \" + user.getUserId());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (!hasPermission(subscription, className, classPK, user)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Skip unauthorized user \" + user.getUserId());\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (bulk) {\n\t\t\tInternetAddress bulkAddress = new InternetAddress(\n\t\t\t\tuser.getEmailAddress(), user.getFullName());\n\n\t\t\tif (_bulkAddresses == null) {\n\t\t\t\t_bulkAddresses = new ArrayList<InternetAddress>();\n\t\t\t}\n\n\t\t\t_bulkAddresses.add(bulkAddress);\n\n\t\t\tsendNotification(user);\n\t\t}\n\t\telse {\n\t\t\tsendNotification(user);\n\t\t}\n\t}","id":35984,"modified_method":"protected void notifyPersistedSubscriber(\n\t\t\tSubscription subscription, String className, long classPK)\n\t\tthrows Exception {\n\n\t\tUser user = UserLocalServiceUtil.fetchUserById(\n\t\t\tsubscription.getUserId());\n\n\t\tif (user == null) {\n\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t_log.info(\n\t\t\t\t\t\"Subscription \" + subscription.getSubscriptionId() +\n\t\t\t\t\t\t\" is stale and will be deleted\");\n\t\t\t}\n\n\t\t\tdeleteSubscription(subscription);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString emailAddress = user.getEmailAddress();\n\n\t\tif (_sentEmailAddresses.contains(emailAddress)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Do not send a duplicate email to \" + emailAddress);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Add \" + emailAddress +\n\t\t\t\t\t\t\" to the list of users who have received an email\");\n\t\t\t}\n\n\t\t\t_sentEmailAddresses.add(emailAddress);\n\t\t}\n\n\t\tif (!user.isActive()) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Skip inactive user \" + user.getUserId());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\tif (!hasPermission(subscription, className, classPK, user)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"Skip unauthorized user \" + user.getUserId());\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (bulk) {\n\t\t\tif (UserNotificationManagerUtil.isDeliver(\n\t\t\t\t\tuser.getUserId(), portletId, _notificationClassNameId,\n\t\t\t\t\t_notificationType,\n\t\t\t\t\tUserNotificationDeliveryConstants.TYPE_EMAIL)) {\n\n\t\t\t\tInternetAddress bulkAddress = new InternetAddress(\n\t\t\t\t\tuser.getEmailAddress(), user.getFullName());\n\n\t\t\t\tif (_bulkAddresses == null) {\n\t\t\t\t\t_bulkAddresses = new ArrayList<InternetAddress>();\n\t\t\t\t}\n\n\t\t\t\t_bulkAddresses.add(bulkAddress);\n\t\t\t}\n\n\t\t\tsendNotification(user);\n\t\t}\n\t\telse {\n\t\t\tsendNotification(user);\n\t\t}\n\t}","commit_id":"2b05c0b133b3764ab0a602b1cfbfaac0b1daa964","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public AttachmentMapper(Names names, ContentPath.Type pathType, int defaultIndexedChars, Boolean ignoreErrors,\n                            Boolean defaultLangDetect, FieldMapper contentMapper,\n                            FieldMapper dateMapper, FieldMapper titleMapper, FieldMapper nameMapper, FieldMapper authorMapper,\n                            FieldMapper keywordsMapper, FieldMapper contentTypeMapper, FieldMapper contentLengthMapper,\n                            FieldMapper languageMapper, Settings indexSettings, MultiFields multiFields, CopyTo copyTo) {\n        super(names, 1.0f, AbstractFieldMapper.Defaults.FIELD_TYPE, false, null, null, null, null, null,\n                indexSettings, multiFields, copyTo);\n        this.pathType = pathType;\n        this.defaultIndexedChars = defaultIndexedChars;\n        this.ignoreErrors = ignoreErrors;\n        this.defaultLangDetect = defaultLangDetect;\n        this.contentMapper = contentMapper;\n        this.dateMapper = dateMapper;\n        this.titleMapper = titleMapper;\n        this.nameMapper = nameMapper;\n        this.authorMapper = authorMapper;\n        this.keywordsMapper = keywordsMapper;\n        this.contentTypeMapper = contentTypeMapper;\n        this.contentLengthMapper = contentLengthMapper;\n        this.languageMapper = languageMapper;\n    }","id":35985,"modified_method":"public AttachmentMapper(MappedFieldType type, ContentPath.Type pathType, int defaultIndexedChars, Boolean ignoreErrors,\n                            Boolean defaultLangDetect, FieldMapper contentMapper,\n                            FieldMapper dateMapper, FieldMapper titleMapper, FieldMapper nameMapper, FieldMapper authorMapper,\n                            FieldMapper keywordsMapper, FieldMapper contentTypeMapper, FieldMapper contentLengthMapper,\n                            FieldMapper languageMapper, @Nullable Settings fieldDataSettings, Settings indexSettings, MultiFields multiFields, CopyTo copyTo) {\n        super(type, false, fieldDataSettings, indexSettings, multiFields, copyTo);\n        this.pathType = pathType;\n        this.defaultIndexedChars = defaultIndexedChars;\n        this.ignoreErrors = ignoreErrors;\n        this.defaultLangDetect = defaultLangDetect;\n        this.contentMapper = contentMapper;\n        this.dateMapper = dateMapper;\n        this.titleMapper = titleMapper;\n        this.nameMapper = nameMapper;\n        this.authorMapper = authorMapper;\n        this.keywordsMapper = keywordsMapper;\n        this.contentTypeMapper = contentTypeMapper;\n        this.contentLengthMapper = contentLengthMapper;\n        this.languageMapper = languageMapper;\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Iterator<Mapper> iterator() {\n        List<FieldMapper> extras = Lists.newArrayList(\n            contentMapper,\n            dateMapper,\n            titleMapper,\n            nameMapper,\n            authorMapper,\n            keywordsMapper,\n            contentTypeMapper,\n            contentLengthMapper,\n            languageMapper);\n        return Iterators.concat(super.iterator(), extras.iterator());\n    }","id":35986,"modified_method":"@Override\n    public Iterator<Mapper> iterator() {\n        List<FieldMapper> extras = Arrays.asList(\n                contentMapper,\n                dateMapper,\n                titleMapper,\n                nameMapper,\n                authorMapper,\n                keywordsMapper,\n                contentTypeMapper,\n                contentLengthMapper,\n                languageMapper);\n        return CollectionUtils.concat(super.iterator(), extras.iterator());\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public Builder(String name) {\n            super(name, new FieldType(AbstractFieldMapper.Defaults.FIELD_TYPE));\n            this.builder = this;\n            this.contentBuilder = stringField(FieldNames.CONTENT);\n        }","id":35987,"modified_method":"public Builder(String name) {\n            super(name, new AttachmentFieldType());\n            this.builder = this;\n            this.contentBuilder = stringField(FieldNames.CONTENT);\n        }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public AttachmentMapper build(BuilderContext context) {\n            ContentPath.Type origPathType = context.path().pathType();\n            context.path().pathType(pathType);\n\n            FieldMapper contentMapper;\n            if (context.indexCreatedVersion().before(Version.V_2_0_0)) {\n                // old behavior, we need the content to be indexed under the attachment field name\n                if (contentBuilder instanceof AbstractFieldMapper.Builder == false) {\n                    throw new IllegalStateException(\"content field for attachment must be a field mapper\");\n                }\n                ((AbstractFieldMapper.Builder)contentBuilder).indexName(name);\n                contentBuilder.name = name + \".\" + FieldNames.CONTENT;\n                contentMapper = (FieldMapper) contentBuilder.build(context);\n                context.path().add(name);\n            } else {\n                context.path().add(name);\n                contentMapper = (FieldMapper) contentBuilder.build(context);\n            }\n\n            FieldMapper dateMapper = (FieldMapper) dateBuilder.build(context);\n            FieldMapper authorMapper = (FieldMapper) authorBuilder.build(context);\n            FieldMapper titleMapper = (FieldMapper) titleBuilder.build(context);\n            FieldMapper nameMapper = (FieldMapper) nameBuilder.build(context);\n            FieldMapper keywordsMapper = (FieldMapper) keywordsBuilder.build(context);\n            FieldMapper contentTypeMapper = (FieldMapper) contentTypeBuilder.build(context);\n            FieldMapper contentLength = (FieldMapper) contentLengthBuilder.build(context);\n            FieldMapper language = (FieldMapper) languageBuilder.build(context);\n            context.path().remove();\n\n            context.path().pathType(origPathType);\n\n            if (defaultIndexedChars == null && context.indexSettings() != null) {\n                defaultIndexedChars = context.indexSettings().getAsInt(\"index.mapping.attachment.indexed_chars\", 100000);\n            }\n            if (defaultIndexedChars == null) {\n                defaultIndexedChars = 100000;\n            }\n\n            if (ignoreErrors == null && context.indexSettings() != null) {\n                ignoreErrors = context.indexSettings().getAsBoolean(\"index.mapping.attachment.ignore_errors\", Boolean.TRUE);\n            }\n            if (ignoreErrors == null) {\n                ignoreErrors = Boolean.TRUE;\n            }\n\n            if (langDetect == null && context.indexSettings() != null) {\n                langDetect = context.indexSettings().getAsBoolean(\"index.mapping.attachment.detect_language\", Boolean.FALSE);\n            }\n            if (langDetect == null) {\n                langDetect = Boolean.FALSE;\n            }\n\n            return new AttachmentMapper(buildNames(context), pathType, defaultIndexedChars, ignoreErrors, langDetect, contentMapper,\n                    dateMapper, titleMapper, nameMapper, authorMapper, keywordsMapper, contentTypeMapper, contentLength,\n                    language, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo);\n        }","id":35988,"modified_method":"@Override\n        public AttachmentMapper build(BuilderContext context) {\n            ContentPath.Type origPathType = context.path().pathType();\n            context.path().pathType(pathType);\n\n            FieldMapper contentMapper;\n            if (context.indexCreatedVersion().before(Version.V_2_0_0)) {\n                // old behavior, we need the content to be indexed under the attachment field name\n                if (contentBuilder instanceof AbstractFieldMapper.Builder == false) {\n                    throw new IllegalStateException(\"content field for attachment must be a field mapper\");\n                }\n                ((AbstractFieldMapper.Builder)contentBuilder).indexName(name);\n                contentBuilder.name = name + \".\" + FieldNames.CONTENT;\n                contentMapper = (FieldMapper) contentBuilder.build(context);\n                context.path().add(name);\n            } else {\n                context.path().add(name);\n                contentMapper = (FieldMapper) contentBuilder.build(context);\n            }\n\n            FieldMapper dateMapper = (FieldMapper) dateBuilder.build(context);\n            FieldMapper authorMapper = (FieldMapper) authorBuilder.build(context);\n            FieldMapper titleMapper = (FieldMapper) titleBuilder.build(context);\n            FieldMapper nameMapper = (FieldMapper) nameBuilder.build(context);\n            FieldMapper keywordsMapper = (FieldMapper) keywordsBuilder.build(context);\n            FieldMapper contentTypeMapper = (FieldMapper) contentTypeBuilder.build(context);\n            FieldMapper contentLength = (FieldMapper) contentLengthBuilder.build(context);\n            FieldMapper language = (FieldMapper) languageBuilder.build(context);\n            context.path().remove();\n\n            context.path().pathType(origPathType);\n\n            if (defaultIndexedChars == null && context.indexSettings() != null) {\n                defaultIndexedChars = context.indexSettings().getAsInt(\"index.mapping.attachment.indexed_chars\", 100000);\n            }\n            if (defaultIndexedChars == null) {\n                defaultIndexedChars = 100000;\n            }\n\n            if (ignoreErrors == null && context.indexSettings() != null) {\n                ignoreErrors = context.indexSettings().getAsBoolean(\"index.mapping.attachment.ignore_errors\", Boolean.TRUE);\n            }\n            if (ignoreErrors == null) {\n                ignoreErrors = Boolean.TRUE;\n            }\n\n            if (langDetect == null && context.indexSettings() != null) {\n                langDetect = context.indexSettings().getAsBoolean(\"index.mapping.attachment.detect_language\", Boolean.FALSE);\n            }\n            if (langDetect == null) {\n                langDetect = Boolean.FALSE;\n            }\n            MappedFieldType defaultFieldType = AbstractFieldMapper.Defaults.FIELD_TYPE.clone();\n            if(this.fieldType.indexOptions() != IndexOptions.NONE && !this.fieldType.tokenized()) {\n                defaultFieldType.setOmitNorms(true);\n                defaultFieldType.setIndexOptions(IndexOptions.DOCS);\n                if(!this.omitNormsSet && this.fieldType.boost() == 1.0F) {\n                    this.fieldType.setOmitNorms(true);\n                }\n\n                if(!this.indexOptionsSet) {\n                    this.fieldType.setIndexOptions(IndexOptions.DOCS);\n                }\n            }\n\n            defaultFieldType.freeze();\n            this.setupFieldType(context);\n            return new AttachmentMapper(this.fieldType, pathType, defaultIndexedChars, ignoreErrors, langDetect, contentMapper,\n                    dateMapper, titleMapper, nameMapper, authorMapper, keywordsMapper, contentTypeMapper, contentLength,\n                    language, this.fieldDataSettings, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo);\n        }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public FieldType defaultFieldType() {\n        return AbstractFieldMapper.Defaults.FIELD_TYPE;\n    }","id":35989,"modified_method":"@Override\n    public MappedFieldType defaultFieldType() {\n        return AbstractFieldMapper.Defaults.FIELD_TYPE;\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testMultipleDocsEncryptedFirst() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content\").names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").names().indexName()).numericValue().longValue(), is(344L));\n    }","id":35990,"modified_method":"@Test\n    public void testMultipleDocsEncryptedFirst() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").fieldType().names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(344L));\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test(expected = MapperParsingException.class)\n    public void testMultipleDocsEncryptedNotIgnoringErrors() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(\n            Settings.builder()\n                             .put(\"path.home\", createTempDir())\n                             .put(\"index.mapping.attachment.ignore_errors\", false)\n                             .build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").names().indexName()).numericValue().longValue(), is(344L));\n    }","id":35991,"modified_method":"@Test(expected = MapperParsingException.class)\n    public void testMultipleDocsEncryptedNotIgnoringErrors() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(\n            Settings.builder()\n                             .put(\"path.home\", createTempDir())\n                             .put(\"index.mapping.attachment.ignore_errors\", false)\n                             .build());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                .field(\"file1\", pdf)\n                .field(\"file2\", html)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").fieldType().names().indexName()), nullValue());\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(344L));\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testMultipleDocsEncryptedLast() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"file1\", html)\n                    .field(\"file2\", pdf)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content\").names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").names().indexName()).numericValue().longValue(), is(344L));\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").names().indexName()), nullValue());\n    }","id":35992,"modified_method":"@Test\n    public void testMultipleDocsEncryptedLast() throws IOException {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/encrypted/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/htmlWithValidDateMeta.html\");\n        byte[] pdf = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/encrypted.pdf\");\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .field(\"file1\", html)\n                    .field(\"file2\", pdf)\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file1.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file1.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(344L));\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.title\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.author\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.keywords\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file2.content_type\").fieldType().names().indexName()), nullValue());\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file2.content_length\").fieldType().names().indexName()), nullValue());\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void testLanguage(String filename, String expected, String... forcedLanguage) throws IOException {\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        XContentBuilder xcb = jsonBuilder()\n                .startObject()\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html);\n\n        if (forcedLanguage.length > 0) {\n            xcb.field(\"_language\", forcedLanguage[0]);\n        }\n\n        xcb.endObject().endObject();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", xcb.bytes()).rootDoc();\n\n        // Our mapping should be kept as a String\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.language\").names().indexName()), equalTo(expected));\n    }","id":35993,"modified_method":"private void testLanguage(String filename, String expected, String... forcedLanguage) throws IOException {\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        XContentBuilder xcb = jsonBuilder()\n                .startObject()\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html);\n\n        if (forcedLanguage.length > 0) {\n            xcb.field(\"_language\", forcedLanguage[0]);\n        }\n\n        xcb.endObject().endObject();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", xcb.bytes()).rootDoc();\n\n        // Our mapping should be kept as a String\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.language\").fieldType().names().indexName()), equalTo(expected));\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLangDetectDocumentEnabled() throws Exception {\n        // We replace the mapper with another one which have index.mapping.attachment.detect_language = false\n        setupMapperParser(false);\n\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/text-in-english.txt\");\n\n        XContentBuilder xcb = jsonBuilder()\n                .startObject()\n                .startObject(\"file\")\n                    .field(\"_name\", \"text-in-english.txt\")\n                    .field(\"_content\", html)\n                    .field(\"_detect_language\", true)\n                .endObject().endObject();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", xcb.bytes()).rootDoc();\n\n        // Our mapping should be kept as a String\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.language\").names().indexName()), equalTo(\"en\"));\n    }","id":35994,"modified_method":"@Test\n    public void testLangDetectDocumentEnabled() throws Exception {\n        // We replace the mapper with another one which have index.mapping.attachment.detect_language = false\n        setupMapperParser(false);\n\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/text-in-english.txt\");\n\n        XContentBuilder xcb = jsonBuilder()\n                .startObject()\n                .startObject(\"file\")\n                    .field(\"_name\", \"text-in-english.txt\")\n                    .field(\"_content\", html)\n                    .field(\"_detect_language\", true)\n                .endObject().endObject();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", xcb.bytes()).rootDoc();\n\n        // Our mapping should be kept as a String\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.language\").fieldType().names().indexName()), equalTo(\"en\"));\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    public Collection<Class<? extends Module>> indexModules() {\n        Collection<Class<? extends Module>> modules = newArrayList();\n        modules.add(AttachmentsIndexModule.class);\n        return modules;\n    }","id":35995,"modified_method":"@Override\n    public Collection<Class<? extends Module>> indexModules() {\n        Collection<Class<? extends Module>> modules = new ArrayList<>();\n        modules.add(AttachmentsIndexModule.class);\n        return modules;\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"protected void checkMeta(String filename, Settings otherSettings, Long expectedDate, Long expectedLength) throws IOException {\n        Settings settings = Settings.builder()\n                                             .put(this.testSettings)\n                                             .put(otherSettings)\n                                             .build();\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(settings);\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/metadata/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html)\n                    .endObject()\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.name\").names().indexName()), equalTo(filename));\n        if (expectedDate == null) {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").names().indexName()), nullValue());\n        } else {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").names().indexName()).numericValue().longValue(), is(expectedDate));\n        }\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.author\").names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.keywords\").names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file.content_length\").names().indexName()).numericValue().longValue(), is(expectedLength));\n    }","id":35996,"modified_method":"protected void checkMeta(String filename, Settings otherSettings, Long expectedDate, Long expectedLength) throws IOException {\n        Settings settings = Settings.builder()\n                                             .put(this.testSettings)\n                                             .put(otherSettings)\n                                             .build();\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(settings);\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/metadata/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/\" + filename);\n\n        BytesReference json = jsonBuilder()\n                .startObject()\n                    .startObject(\"file\")\n                        .field(\"_name\", filename)\n                        .field(\"_content\", html)\n                    .endObject()\n                .endObject().bytes();\n\n        ParseContext.Document doc =  docMapper.parse(\"person\", \"1\", json).rootDoc();\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"World\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.name\").fieldType().names().indexName()), equalTo(filename));\n        if (expectedDate == null) {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").fieldType().names().indexName()), nullValue());\n        } else {\n            assertThat(doc.getField(docMapper.mappers().getMapper(\"file.date\").fieldType().names().indexName()).numericValue().longValue(), is(expectedDate));\n        }\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"Hello\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.author\").fieldType().names().indexName()), equalTo(\"kimchy\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.keywords\").fieldType().names().indexName()), equalTo(\"elasticsearch,cool,bonsai\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), equalTo(\"text/html; charset=ISO-8859-1\"));\n        assertThat(doc.getField(docMapper.mappers().getMapper(\"file.content_length\").fieldType().names().indexName()).numericValue().longValue(), is(expectedLength));\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSimpleMappings() throws Exception {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        ParseContext.Document doc = docMapper.parse(\"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n\n        // re-parse it\n        String builtMapping = docMapper.mappingSource().string();\n        docMapper = mapperParser.parse(builtMapping);\n\n        json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        doc = docMapper.parse(\"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","id":35997,"modified_method":"@Test\n    public void testSimpleMappings() throws Exception {\n        DocumentMapperParser mapperParser = MapperTestUtils.newMapperParser(createTempDir());\n        mapperParser.putTypeParser(AttachmentMapper.CONTENT_TYPE, new AttachmentMapper.TypeParser());\n        String mapping = copyToStringFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/unit/simple/test-mapping.json\");\n        DocumentMapper docMapper = mapperParser.parse(mapping);\n        byte[] html = copyToBytesFromClasspath(\"/org/elasticsearch/index/mapper/attachment/test/sample-files/testXHTML.html\");\n\n        BytesReference json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        ParseContext.Document doc = docMapper.parse(\"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n\n        // re-parse it\n        String builtMapping = docMapper.mappingSource().string();\n        docMapper = mapperParser.parse(builtMapping);\n\n        json = jsonBuilder().startObject().field(\"file\", html).endObject().bytes();\n\n        doc = docMapper.parse(\"person\", \"1\", json).rootDoc();\n\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content_type\").fieldType().names().indexName()), startsWith(\"application/xhtml+xml\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.title\").fieldType().names().indexName()), equalTo(\"XHTML test document\"));\n        assertThat(doc.get(docMapper.mappers().getMapper(\"file.content\").fieldType().names().indexName()), containsString(\"This document tests the ability of Apache Tika to extract content\"));\n    }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public ExitStatus execute(Settings settings, Environment env) throws Exception {\n            XContentBuilder builder = jsonBuilder().startObject().field(\"file\").startObject();\n\n            if (base64text != null) {\n                // If base64 is provided\n                builder.field(\"_content\", base64text);\n            } else {\n                // A file is provided\n                byte[] bytes = copyToBytes(PathUtils.get(url));\n                builder.field(\"_content\", bytes);\n            }\n\n            if (size >= 0) {\n                builder.field(\"_indexed_chars\", size);\n            }\n\n            BytesReference json = builder.endObject().endObject().bytes();\n\n            ParseContext.Document doc = docMapper.parse(\"person\", \"1\", json).rootDoc();\n\n            terminal.println(\"## Extracted text\");\n            terminal.println(\"--------------------- BEGIN -----------------------\");\n            terminal.println(\"%s\", doc.get(docMapper.mappers().getMapper(\"file\").names().indexName()));\n            terminal.println(\"---------------------- END ------------------------\");\n            terminal.println(\"## Metadata\");\n            printMetadataContent(doc, AttachmentMapper.FieldNames.AUTHOR);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.CONTENT_LENGTH);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.CONTENT_TYPE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.DATE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.KEYWORDS);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.LANGUAGE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.NAME);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.TITLE);\n\n            return ExitStatus.OK;\n        }","id":35998,"modified_method":"@Override\n        public ExitStatus execute(Settings settings, Environment env) throws Exception {\n            XContentBuilder builder = jsonBuilder().startObject().field(\"file\").startObject();\n\n            if (base64text != null) {\n                // If base64 is provided\n                builder.field(\"_content\", base64text);\n            } else {\n                // A file is provided\n                byte[] bytes = copyToBytes(PathUtils.get(url));\n                builder.field(\"_content\", bytes);\n            }\n\n            if (size >= 0) {\n                builder.field(\"_indexed_chars\", size);\n            }\n\n            BytesReference json = builder.endObject().endObject().bytes();\n\n            ParseContext.Document doc = docMapper.parse(\"person\", \"1\", json).rootDoc();\n\n            terminal.println(\"## Extracted text\");\n            terminal.println(\"--------------------- BEGIN -----------------------\");\n            terminal.println(\"%s\", doc.get(docMapper.mappers().getMapper(\"file\").fieldType().names().indexName()));\n            terminal.println(\"---------------------- END ------------------------\");\n            terminal.println(\"## Metadata\");\n            printMetadataContent(doc, AttachmentMapper.FieldNames.AUTHOR);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.CONTENT_LENGTH);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.CONTENT_TYPE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.DATE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.KEYWORDS);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.LANGUAGE);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.NAME);\n            printMetadataContent(doc, AttachmentMapper.FieldNames.TITLE);\n\n            return ExitStatus.OK;\n        }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private void printMetadataContent(ParseContext.Document doc, String field) {\n            terminal.println(\"- %s: %s\", field, doc.get(docMapper.mappers().getMapper(\"file.\" + field).names().indexName()));\n        }","id":35999,"modified_method":"private void printMetadataContent(ParseContext.Document doc, String field) {\n            terminal.println(\"- %s: %s\", field, doc.get(docMapper.mappers().getMapper(\"file.\" + field).fieldType().names().indexName()));\n        }","commit_id":"f743ebb87f3a9685d6358b69c2e9227fa7d45bc9","url":"https://github.com/elastic/elasticsearch"}]