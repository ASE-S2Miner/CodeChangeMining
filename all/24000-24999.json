[{"original_method":"public static File getMetaInfDirectory(Class clazz)\n    {\n        URL classUrl = clazz.getResource(clazz.getSimpleName() + \".class\");\n        if (classUrl.toString().startsWith(\"jar\"))\n        {\n            //we are dealing with a jar file, no need to modify test-classes resources\n            return null;\n        }\n        String classPath = classUrl.getPath();\n        return new File(String.format(\"%starget/test-classes/META-INF\", classPath.substring(0, classPath.indexOf(\"target\"))));\n    }","id":24000,"modified_method":"public static File getMetaInfDirectory(Class clazz)\n    {\n        URL classUrl = clazz.getResource(clazz.getSimpleName() + \".class\");\n        String classPath = classUrl.getPath();\n        return new File(String.format(\"%starget/test-classes/META-INF\", classPath.substring(0, classPath.indexOf(\"target\"))));\n    }","commit_id":"0e5b6c68be2d56370645e4fa9c4a573c8c85cf18","url":"https://github.com/mulesoft/mule"},{"original_method":"private String fallback()\n    {\n        //look for the location of this class\n        String packageName = extensionType.getPackage().getName();\n        String classFileName = extensionType.getName().substring(packageName.length() + 1) + \".class\";\n        String classFilePath = extensionType.getResource(classFileName).toString();\n        //get rid of the package part of the path to avoid conflicts with user-defined directories\n        String packagePath = packageName.replace(\".\", \"/\");\n        classFilePath = classFilePath.substring(0, classFilePath.lastIndexOf(packagePath));\n        //get the target index since the class could be in /classes too\n        int pathIndex = classFilePath.lastIndexOf(\"/target/\");\n        //find and load manifest\n        String manifestUrl = String.format(\"%s/target/test-classes/META-INF/MANIFEST.MF\", classFilePath.substring(0, pathIndex + 1));\n        try (InputStream manifestInputStream = new URL(manifestUrl).openStream())\n        {\n            Manifest manifest = new Manifest(manifestInputStream);\n            return manifest.getMainAttributes().getValue(new Attributes.Name(\"Implementation-Version\"));\n        }\n        catch (IOException e)\n        {\n            return null;\n        }\n    }","id":24001,"modified_method":"private String fallback()\n    {\n        //look for the location of this class\n        String packageName = extensionType.getPackage().getName();\n        String classFileName = extensionType.getName().substring(packageName.length() + 1) + \".class\";\n        String classFilePath = extensionType.getResource(classFileName).toString();\n        //get rid of the package part of the path to avoid conflicts with user-defined directories\n        String packagePath = packageName.replace(\".\", \"/\");\n        classFilePath = classFilePath.substring(0, classFilePath.lastIndexOf(packagePath));\n        //get the target index since the class could be in /classes too\n        int pathIndex = classFilePath.lastIndexOf(\"/target/\");\n        //find and load manifest\n        String manifestUrl = String.format(\"%s/target/test-classes/META-INF/MANIFEST.MF\", classFilePath.substring(0, pathIndex + 1));\n        try (InputStream manifestInputStream = new URL(manifestUrl).openStream())\n        {\n            Manifest manifest = new Manifest(manifestInputStream);\n            return manifest.getMainAttributes().getValue(new Attributes.Name(\"Implementation-Version\"));\n        }\n        catch (IOException e)\n        {\n            LOGGER.debug(\"Could not find MANIFEST.MF under target/test-classes. Using mule-core MANIFEST.MF.\");\n            return MuleManifest.getProductVersion();\n        }\n    }","commit_id":"0e5b6c68be2d56370645e4fa9c4a573c8c85cf18","url":"https://github.com/mulesoft/mule"},{"original_method":"@Override\n    public String resolveVersion(Extension extension)\n    {\n        String version = extensionType.getPackage().getImplementationVersion();\n        if (version == null)\n        {\n            version = fallback();\n        }\n        if (version == null)\n        {\n            throw new MuleRuntimeException(createStaticMessage(String.format(\"Cannot resolve version for extension %s: MANIFEST.MF could not be found.\", extension.name())));\n        }\n        return version;\n    }","id":24002,"modified_method":"@Override\n    public String resolveVersion(Extension extension)\n    {\n        String version = extensionType.getPackage().getImplementationVersion();\n        if (version == null)\n        {\n            LOGGER.debug(\"Could not resolve version from JAR's MANIFEST.MF. Searching for file under target/test-classes.\");\n            version = fallback();\n        }\n        return version;\n    }","commit_id":"0e5b6c68be2d56370645e4fa9c4a573c8c85cf18","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void worksWithManifest() throws Exception\n    {\n        File metaInfDirectory = getMetaInfDirectory(getClass());\n        File manifest = createManifestFileIfNecessary(metaInfDirectory);\n        try\n        {\n            assertThat(testResolution(), is(MuleManifest.getProductVersion()));\n        }\n        finally\n        {\n            if (manifest.exists())\n            {\n                FileUtils.deleteQuietly(manifest);\n            }\n        }\n\n    }","id":24003,"modified_method":"@Test\n    public void worksWithManifest() throws Exception\n    {\n        File metaInfDirectory = getMetaInfDirectory(getClass());\n        InputStream testManifestInputStream = getResourceAsStream(\"test-manifest.mf\", getClass());\n        File manifest = createManifestFileIfNecessary(metaInfDirectory, new Manifest(testManifestInputStream));\n        try\n        {\n            assertThat(testResolution(), is(TEST_MANIFEST_VERSION));\n        }\n        finally\n        {\n            if (manifest.exists())\n            {\n                deleteQuietly(manifest);\n            }\n            closeQuietly(testManifestInputStream);\n        }\n\n    }","commit_id":"0e5b6c68be2d56370645e4fa9c4a573c8c85cf18","url":"https://github.com/mulesoft/mule"},{"original_method":"@Test\n    public void failsWithOutManifest()\n    {\n        thrown.expectMessage(is(\"Cannot resolve version for extension heisenberg: MANIFEST.MF could not be found.\"));\n        testResolution();\n    }","id":24004,"modified_method":"@Test\n    public void worksWithoutManifest()\n    {\n        assertThat(testResolution(), is(getProductVersion()));\n    }","commit_id":"0e5b6c68be2d56370645e4fa9c4a573c8c85cf18","url":"https://github.com/mulesoft/mule"},{"original_method":"private Element validate(XMLStreamReader input) throws XMLStreamException, IOException {\n        DOMSource ds = read(input);\n        Element rootElement = null;\n        if (ds.getNode() instanceof Document) {\n            rootElement = ((Document)ds.getNode()).getDocumentElement();\n        } else {\n            rootElement = (Element)ds.getNode();\n        }\n\n        WoodstoxValidationImpl impl = new WoodstoxValidationImpl();\n        if (impl.canValidate()) {\n            //Can use the MSV libs and woodstox to handle the schema validation during \n            //parsing and processing.   Much faster and single traversal\n            //filter xop node\n            XMLStreamReader reader = StaxUtils.createXMLStreamReader(ds);\n            XMLStreamReader filteredReader = \n                StaxUtils.createFilteredReader(reader, \n                                               new StaxStreamFilter(new QName[] {XOP}));\n            \n            XMLStreamWriter nullWriter = StaxUtils.createXMLStreamWriter(new NUllOutputStream());\n            \n            impl.setupValidation(nullWriter, message.getExchange().getService().getServiceInfos().get(0));\n            StaxUtils.copy(filteredReader, nullWriter);\n        } else {\n            //MSV not available, use a slower method of cloning the data, replace the xop's, validate\n            LOG.fine(\"NO_MSV_AVAILABLE\");\n            if (DOMUtils.hasElementWithName(rootElement, \"http://www.w3.org/2004/08/xop/include\", \"Include\")) {\n                Element newElement = (Element)rootElement.cloneNode(true);\n                List<Element> elems = DOMUtils.findAllElementsByTagNameNS(newElement, \n                                                                          \"http://www.w3.org/2004/08/xop/include\",\n                                                                          \"Include\");\n                for (Element include : elems) {\n                    Node parentNode = include.getParentNode();\n                    parentNode.removeChild(include);\n                    String cid = DOMUtils.getAttribute(include, \"href\");\n                    //set the fake base64Binary to validate instead of reading the attachment from message\n                    parentNode.setTextContent(javax.xml.bind.DatatypeConverter.printBase64Binary(cid.getBytes()));\n                }\n                try {\n                    schema.newValidator().validate(new DOMSource(newElement));\n                } catch (SAXException e) {\n                    throw new XMLStreamException(e);\n                }\n            }\n        }\n        return rootElement;        \n    }","id":24005,"modified_method":"private Element validate(XMLStreamReader input) throws XMLStreamException, IOException {\n        DOMSource ds = read(input);\n        Element rootElement = null;\n        if (ds.getNode() instanceof Document) {\n            rootElement = ((Document)ds.getNode()).getDocumentElement();\n        } else {\n            rootElement = (Element)ds.getNode();\n        }\n\n        WoodstoxValidationImpl impl = new WoodstoxValidationImpl();\n        XMLStreamWriter nullWriter = null;\n        boolean canValidate = impl.canValidate();\n        if (canValidate) {\n            nullWriter = StaxUtils.createXMLStreamWriter(new NUllOutputStream());\n            try {\n                impl.setupValidation(nullWriter, message.getExchange().getService().getServiceInfos().get(0));\n            } catch (Throwable t) {\n                LOG.log(Level.FINE, \"Trouble setting up validation.\", t);\n                canValidate = false;\n            }\n        }\n        if (canValidate) {\n            //Can use the MSV libs and woodstox to handle the schema validation during \n            //parsing and processing.   Much faster and single traversal\n            //filter xop node\n            XMLStreamReader reader = StaxUtils.createXMLStreamReader(ds);\n            XMLStreamReader filteredReader = \n                StaxUtils.createFilteredReader(reader, \n                                               new StaxStreamFilter(new QName[] {XOP}));\n            \n            StaxUtils.copy(filteredReader, nullWriter);\n        } else {\n            //MSV not available, use a slower method of cloning the data, replace the xop's, validate\n            LOG.fine(\"NO_MSV_AVAILABLE\");\n            Element newElement = rootElement;\n            if (DOMUtils.hasElementWithName(rootElement, \"http://www.w3.org/2004/08/xop/include\", \"Include\")) {\n                newElement = (Element)rootElement.cloneNode(true);\n                List<Element> elems = DOMUtils.findAllElementsByTagNameNS(newElement, \n                                                                          \"http://www.w3.org/2004/08/xop/include\",\n                                                                          \"Include\");\n                for (Element include : elems) {\n                    Node parentNode = include.getParentNode();\n                    parentNode.removeChild(include);\n                    String cid = DOMUtils.getAttribute(include, \"href\");\n                    //set the fake base64Binary to validate instead of reading the attachment from message\n                    parentNode.setTextContent(javax.xml.bind.DatatypeConverter.printBase64Binary(cid.getBytes()));\n                }\n            }\n            try {\n                schema.newValidator().validate(new DOMSource(newElement));\n            } catch (SAXException e) {\n                throw new XMLStreamException(e);\n            }\n        }\n        return rootElement;        \n    }","commit_id":"79f8fca14a252eb9688693b4b4a06de59dccab3d","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches )  {\n        ArgumentDefinition bamArgumentDefinition = createBAMArgumentDefinition(source);\n        String writerFileName = getArgumentValue( bamArgumentDefinition, matches );\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(writerFileName == null && !source.isRequired())\n            throw new MissingArgumentValueException(bamArgumentDefinition);\n\n        SAMFileWriterStub stub = new SAMFileWriterStub(engine, new File(writerFileName));\n\n        String compressionLevelText = getArgumentValue( createBAMCompressionArgumentDefinition(source), matches );\n        Integer compressionLevel = compressionLevelText != null ? Integer.valueOf(compressionLevelText) : null;\n        if( compressionLevel != null )\n            stub.setCompressionLevel(compressionLevel);\n\n        stub.setIndexOnTheFly(!argumentIsPresent(disableWriteIndexArgumentDefinition(source),matches));\n        stub.setSimplifyBAM(argumentIsPresent(createSimplifyBAMArgumentDefinition(source),matches));\n\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(stub,getArgumentTags(matches));\n        engine.addOutput(stub);\n\n        return stub;\n    }","id":24006,"modified_method":"@Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Class type, ArgumentMatches matches )  {\n        // Extract all possible parameters that could be passed to a BAM file writer?\n        ArgumentDefinition bamArgumentDefinition = createBAMArgumentDefinition(source);\n        String writerFileName = getArgumentValue( bamArgumentDefinition, matches );\n\n        String compressionLevelText = getArgumentValue( createBAMCompressionArgumentDefinition(source), matches );\n        Integer compressionLevel = compressionLevelText != null ? Integer.valueOf(compressionLevelText) : null;\n\n        Boolean indexOnTheFly = !argumentIsPresent(disableWriteIndexArgumentDefinition(source),matches) ? true : null;\n        Boolean generateMD5 = argumentIsPresent(this.enableMD5GenerationArgumentDefinition(source),matches) ? true : null;\n        Boolean simplifyBAM = argumentIsPresent(createSimplifyBAMArgumentDefinition(source),matches);\n\n        // Validate the combination of parameters passed in.\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(writerFileName == null) {\n            if(!source.isRequired())\n                throw new MissingArgumentValueException(bamArgumentDefinition);\n            if(generateMD5)\n                throw new ArgumentException(\"MD5 generation specified, but no output file specified.  If md5 generation is desired, please specify a BAM output file and an md5 file will be written alongside.\");\n        }\n\n        // Create the stub and set parameters.\n        SAMFileWriterStub stub = new SAMFileWriterStub(engine, new File(writerFileName));\n\n        if( compressionLevel != null )\n            stub.setCompressionLevel(compressionLevel);\n        if(indexOnTheFly != null)\n            stub.setIndexOnTheFly(indexOnTheFly);\n        if(generateMD5 != null)\n            stub.setGenerateMD5(generateMD5);\n        if(simplifyBAM != null)\n            stub.setSimplifyBAM(simplifyBAM);\n\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(stub,getArgumentTags(matches));\n        engine.addOutput(stub);\n\n        return stub;\n    }","commit_id":"ca48ea78df9ddcd7cbebd1487bf0a3d3ed5c9211","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public List<ArgumentDefinition> createArgumentDefinitions( ArgumentSource source ) {\n        return Arrays.asList( createBAMArgumentDefinition(source),\n                              createBAMCompressionArgumentDefinition(source),\n                              disableWriteIndexArgumentDefinition(source),\n                              createSimplifyBAMArgumentDefinition(source));\n    }","id":24007,"modified_method":"@Override\n    public List<ArgumentDefinition> createArgumentDefinitions( ArgumentSource source ) {\n        return Arrays.asList( createBAMArgumentDefinition(source),\n                              createBAMCompressionArgumentDefinition(source),\n                              disableWriteIndexArgumentDefinition(source),\n                              enableMD5GenerationArgumentDefinition(source),\n                              createSimplifyBAMArgumentDefinition(source));\n    }","commit_id":"ca48ea78df9ddcd7cbebd1487bf0a3d3ed5c9211","url":"https://github.com/broadgsa/gatk"},{"original_method":"public SAMFileWriterStorage( SAMFileWriterStub stub, File file ) {\n        this.file = file;\n        SAMFileWriterFactory factory = new SAMFileWriterFactory();\n        // Enable automatic index creation for pre-sorted BAMs.\n        if (stub.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.coordinate) && stub.getIndexOnTheFly())\n            factory.setCreateIndex(true);\n        // Adjust max records in RAM.\n        if(stub.getMaxRecordsInRam() != null)\n            factory.setMaxRecordsInRam(stub.getMaxRecordsInRam());\n\n        if(stub.getSAMFile() != null) {\n            // HACK: Turn setCreateIndex off if the SAM file is null.  Picard has pledged to fix this\n            //       during the week of 14 Sept 2010.  Eliminate this check when they do.\n            if(stub.getSAMFile().getPath().equals(\"/dev/null\"))\n                factory.setCreateIndex(false);\n\n            try {\n                this.writer = createBAMWriter(factory,stub.getFileHeader(),stub.isPresorted(),file,stub.getCompressionLevel());\n            }\n            catch(RuntimeIOException ex) {\n                throw new UserException.CouldNotCreateOutputFile(file,\"file could not be created\",ex);\n            }\n        }\n        else if(stub.getSAMOutputStream() != null){\n            this.writer = factory.makeSAMWriter( stub.getFileHeader(), stub.isPresorted(), stub.getSAMOutputStream());\n        }\n        else\n            throw new UserException(\"Unable to write to SAM file; neither a target file nor a stream has been specified\");\n\n        // if we want to send the BAM file through the simplifying writer, wrap it here\n        if ( stub.simplifyBAM() ) {\n            this.writer = new SimplifyingSAMFileWriter(this.writer);\n        }\n    }","id":24008,"modified_method":"public SAMFileWriterStorage( SAMFileWriterStub stub, File file ) {\n        this.file = file;\n        SAMFileWriterFactory factory = new SAMFileWriterFactory();\n        // Enable automatic index creation for pre-sorted BAMs.\n        if (stub.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.coordinate) && stub.getIndexOnTheFly())\n            factory.setCreateIndex(true);\n        if (stub.getGenerateMD5())\n            factory.setCreateMd5File(true);\n        // Adjust max records in RAM.\n        if(stub.getMaxRecordsInRam() != null)\n            factory.setMaxRecordsInRam(stub.getMaxRecordsInRam());\n\n        if(stub.getSAMFile() != null) {\n            try {\n                this.writer = createBAMWriter(factory,stub.getFileHeader(),stub.isPresorted(),file,stub.getCompressionLevel());\n            }\n            catch(RuntimeIOException ex) {\n                throw new UserException.CouldNotCreateOutputFile(file,\"file could not be created\",ex);\n            }\n        }\n        else if(stub.getSAMOutputStream() != null){\n            this.writer = factory.makeSAMWriter( stub.getFileHeader(), stub.isPresorted(), stub.getSAMOutputStream());\n        }\n        else\n            throw new UserException(\"Unable to write to SAM file; neither a target file nor a stream has been specified\");\n\n        // if we want to send the BAM file through the simplifying writer, wrap it here\n        if ( stub.simplifyBAM() ) {\n            this.writer = new SimplifyingSAMFileWriter(this.writer);\n        }\n    }","commit_id":"ca48ea78df9ddcd7cbebd1487bf0a3d3ed5c9211","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Object createTypeDefault(ParsingEngine parsingEngine,ArgumentSource source, Type type) {\n        if(!source.isRequired())\n            throw new ReviewedStingException(\"BUG: tried to create type default for argument type descriptor that can't support a type default.\");        \n        VariantContextWriterStub stub = new VariantContextWriterStub(engine, defaultOutputStream, false, argumentSources, false, false);\n        engine.addOutput(stub);\n        return stub;\n    }","id":24009,"modified_method":"@Override\n    public Object createTypeDefault(ParsingEngine parsingEngine,ArgumentSource source, Type type) {\n        if(!source.isRequired())\n            throw new ReviewedStingException(\"BUG: tried to create type default for argument type descriptor that can't support a type default.\");        \n        VariantContextWriterStub stub = new VariantContextWriterStub(engine, defaultOutputStream, argumentSources);\n        engine.addOutput(stub);\n        return stub;\n    }","commit_id":"d5dee0b52ec12f70b9d77c0ae69b9396e7067ec0","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Convert the given argument matches into a single object suitable for feeding into the ArgumentSource.\n     * @param source Source for this argument.\n     * @param type not used\n     * @param matches Matches that match with this argument.\n     * @return Transform from the matches into the associated argument.\n     */\n    @Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches )  {\n        ArgumentDefinition defaultArgumentDefinition = createDefaultArgumentDefinition(source);\n        // Get the filename for the genotype file, if it exists.  If not, we'll need to send output to out.\n        String writerFileName = getArgumentValue(defaultArgumentDefinition,matches);\n        File writerFile = writerFileName != null ? new File(writerFileName) : null;\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(writerFile == null && !source.isRequired())\n            throw new MissingArgumentValueException(defaultArgumentDefinition);\n\n        // Should we compress the output stream?\n        boolean compress = isCompressed(writerFileName);\n\n        boolean skipWritingCmdLineHeader = argumentIsPresent(createNoCommandLineHeaderArgumentDefinition(),matches);\n        boolean doNotWriteGenotypes = argumentIsPresent(createSitesOnlyArgumentDefinition(),matches);\n\n        // Create a stub for the given object.\n        VariantContextWriterStub stub = (writerFile != null) ? new VariantContextWriterStub(engine, writerFile, compress, argumentSources, skipWritingCmdLineHeader, doNotWriteGenotypes)\n                                                  : new VariantContextWriterStub(engine, defaultOutputStream, compress, argumentSources, skipWritingCmdLineHeader, doNotWriteGenotypes);\n\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(stub,getArgumentTags(matches));\n        engine.addOutput(stub);\n\n        return stub;\n    }","id":24010,"modified_method":"/**\n     * Convert the given argument matches into a single object suitable for feeding into the ArgumentSource.\n     * @param source Source for this argument.\n     * @param type not used\n     * @param matches Matches that match with this argument.\n     * @return Transform from the matches into the associated argument.\n     */\n    @Override\n    public Object parse( ParsingEngine parsingEngine, ArgumentSource source, Type type, ArgumentMatches matches )  {\n        ArgumentDefinition defaultArgumentDefinition = createDefaultArgumentDefinition(source);\n        // Get the filename for the genotype file, if it exists.  If not, we'll need to send output to out.\n        String writerFileName = getArgumentValue(defaultArgumentDefinition,matches);\n        File writerFile = writerFileName != null ? new File(writerFileName) : null;\n\n        // This parser has been passed a null filename and the GATK is not responsible for creating a type default for the object;\n        // therefore, the user must have failed to specify a type default\n        if(writerFile == null && !source.isRequired())\n            throw new MissingArgumentValueException(defaultArgumentDefinition);\n\n        // Create a stub for the given object.\n        final VariantContextWriterStub stub = (writerFile != null)\n                ? new VariantContextWriterStub(engine, writerFile, argumentSources)\n                : new VariantContextWriterStub(engine, defaultOutputStream, argumentSources);\n\n        stub.setCompressed(isCompressed(writerFileName));\n        stub.setDoNotWriteGenotypes(argumentIsPresent(createSitesOnlyArgumentDefinition(),matches));\n        stub.setSkipWritingCommandLineHeader(argumentIsPresent(createNoCommandLineHeaderArgumentDefinition(),matches));\n        stub.setForceBCF(argumentIsPresent(createBCFArgumentDefinition(),matches));\n\n        // WARNING: Side effects required by engine!\n        parsingEngine.addTags(stub,getArgumentTags(matches));\n        engine.addOutput(stub);\n\n        return stub;\n    }","commit_id":"d5dee0b52ec12f70b9d77c0ae69b9396e7067ec0","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public List<ArgumentDefinition> createArgumentDefinitions( ArgumentSource source ) {\n        return Arrays.asList( createDefaultArgumentDefinition(source), createNoCommandLineHeaderArgumentDefinition(),createSitesOnlyArgumentDefinition());\n    }","id":24011,"modified_method":"@Override\n    public List<ArgumentDefinition> createArgumentDefinitions( ArgumentSource source ) {\n        return Arrays.asList(\n                createDefaultArgumentDefinition(source),\n                createNoCommandLineHeaderArgumentDefinition(),\n                createSitesOnlyArgumentDefinition(),\n                createBCFArgumentDefinition() );\n    }","commit_id":"d5dee0b52ec12f70b9d77c0ae69b9396e7067ec0","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new stub given the requested file.\n     *\n     * @param engine engine.\n     * @param genotypeStream  stream to (ultimately) write.\n     * @param isCompressed  should we compress the output stream?\n     * @param argumentSources sources.\n     * @param skipWritingCommandLineHeader skip writing header.\n     * @param doNotWriteGenotypes do not write genotypes.\n     */\n    public VariantContextWriterStub(GenomeAnalysisEngine engine, OutputStream genotypeStream, boolean isCompressed, Collection<Object> argumentSources, boolean skipWritingCommandLineHeader, boolean doNotWriteGenotypes) {\n        this.engine = engine;\n        this.genotypeFile = null;\n        this.genotypeStream = new PrintStream(genotypeStream);\n        this.isCompressed = isCompressed;\n        this.argumentSources = argumentSources;\n        this.skipWritingCommandLineHeader = skipWritingCommandLineHeader;\n        this.doNotWriteGenotypes = doNotWriteGenotypes;\n    }","id":24012,"modified_method":"/**\n     * Create a new stub given the requested file.\n     *\n     * @param engine engine.\n     * @param genotypeStream  stream to (ultimately) write.\n     * @param argumentSources sources.\n     */\n    public VariantContextWriterStub(GenomeAnalysisEngine engine, OutputStream genotypeStream, Collection<Object> argumentSources) {\n        this.engine = engine;\n        this.genotypeFile = null;\n        this.genotypeStream = new PrintStream(genotypeStream);\n        this.argumentSources = argumentSources;\n    }","commit_id":"d5dee0b52ec12f70b9d77c0ae69b9396e7067ec0","url":"https://github.com/broadgsa/gatk"},{"original_method":"public EnumSet<Options> getWriterOptions(boolean indexOnTheFly) {\n        List<Options> options = new ArrayList<Options>();\n\n        if ( doNotWriteGenotypes ) options.add(Options.DO_NOT_WRITE_GENOTYPES);\n        if ( engine.lenientVCFProcessing() ) options.add(Options.ALLOW_MISSING_FIELDS_IN_HEADER);\n        if ( indexOnTheFly && ! isCompressed() ) options.add(Options.INDEX_ON_THE_FLY);\n\n        if ( getFile() != null && VariantContextWriterFactory.isBCFOutput(getFile()) )\n            options.add(Options.FORCE_BCF);\n\n        return options.isEmpty() ? EnumSet.noneOf(Options.class) : EnumSet.copyOf(options);\n    }","id":24013,"modified_method":"public EnumSet<Options> getWriterOptions(boolean indexOnTheFly) {\n        List<Options> options = new ArrayList<Options>();\n\n        if ( doNotWriteGenotypes ) options.add(Options.DO_NOT_WRITE_GENOTYPES);\n        if ( engine.lenientVCFProcessing() ) options.add(Options.ALLOW_MISSING_FIELDS_IN_HEADER);\n        if ( indexOnTheFly && ! isCompressed() ) options.add(Options.INDEX_ON_THE_FLY);\n\n        if ( forceBCF || (getFile() != null && VariantContextWriterFactory.isBCFOutput(getFile())) )\n            options.add(Options.FORCE_BCF);\n\n        return options.isEmpty() ? EnumSet.noneOf(Options.class) : EnumSet.copyOf(options);\n    }","commit_id":"d5dee0b52ec12f70b9d77c0ae69b9396e7067ec0","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new stub given the requested file.\n     *\n     * @param engine engine.\n     * @param genotypeFile  file to (ultimately) create.\n     * @param isCompressed  should we compress the output stream?\n     * @param argumentSources sources.\n     * @param skipWritingCommandLineHeader skip writing header.\n     * @param doNotWriteGenotypes do not write genotypes.\n     */\n    public VariantContextWriterStub(GenomeAnalysisEngine engine, File genotypeFile, boolean isCompressed, Collection<Object> argumentSources, boolean skipWritingCommandLineHeader, boolean doNotWriteGenotypes) {\n        this.engine = engine;\n        this.genotypeFile = genotypeFile;\n        this.genotypeStream = null;\n        this.isCompressed = isCompressed;\n        this.argumentSources = argumentSources;\n        this.skipWritingCommandLineHeader = skipWritingCommandLineHeader;\n        this.doNotWriteGenotypes = doNotWriteGenotypes;\n    }","id":24014,"modified_method":"/**\n     * Create a new stub given the requested file.\n     *\n     * @param engine engine.\n     * @param genotypeFile  file to (ultimately) create.\n     * @param argumentSources sources.\n     */\n    public VariantContextWriterStub(GenomeAnalysisEngine engine, File genotypeFile, Collection<Object> argumentSources) {\n        this.engine = engine;\n        this.genotypeFile = genotypeFile;\n        this.genotypeStream = null;\n        this.argumentSources = argumentSources;\n    }","commit_id":"d5dee0b52ec12f70b9d77c0ae69b9396e7067ec0","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Object processInvocation(final InterceptorContext context) throws Exception {\n        switch (interceptionType) {\n            case AROUND_INVOKE:\n                return doMethodInterception(context.getInvocationContext(), InterceptionType.AROUND_INVOKE);\n            case AROUND_TIMEOUT:\n                return doMethodInterception(context.getInvocationContext(), InterceptionType.AROUND_TIMEOUT);\n            case PRE_DESTROY:\n                try {\n                    return doLifecycleInterception(context);\n                } finally {\n                    creationalContext.release();\n                }\n            case POST_CONSTRUCT:\n                return doLifecycleInterception(context);\n            default:\n                //should never happen\n                return context.proceed();\n        }\n    }","id":24015,"modified_method":"@Override\n    public Object processInvocation(final InterceptorContext context) throws Exception {\n        switch (interceptionType) {\n            case AROUND_INVOKE:\n                return doMethodInterception(context.getInvocationContext(), InterceptionType.AROUND_INVOKE);\n            case AROUND_TIMEOUT:\n                return doMethodInterception(context.getInvocationContext(), InterceptionType.AROUND_TIMEOUT);\n            case PRE_DESTROY:\n                try {\n                    return doLifecycleInterception(context);\n                } finally {\n                    creationalContext.release();\n                }\n            case POST_CONSTRUCT:\n                return doLifecycleInterception(context);\n            case AROUND_CONSTRUCT:\n                return doLifecycleInterception(context);\n            default:\n                //should never happen\n                return context.proceed();\n        }\n    }","commit_id":"9210a5058bfc318f81163f8ea31b060a6c047c91","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * As the weld based instantiator needs access to the bean manager it is installed as a service.\n     */\n    private void addWeldIntegration(final ServiceTarget target, final ComponentConfiguration configuration, final ComponentDescription description, final Class<?> componentClass, final String beanName, final ServiceName weldServiceName, final ServiceName weldStartService, final Set<Class<?>> interceptorClasses, final ClassLoader classLoader, final String beanDeploymentArchiveId) {\n\n        final ServiceName serviceName = configuration.getComponentDescription().getServiceName().append(\"WeldInstantiator\");\n\n        final WeldComponentService weldComponentService = new WeldComponentService(componentClass, beanName, interceptorClasses, classLoader, beanDeploymentArchiveId, description.isCDIInterceptorEnabled(), description);\n                ServiceBuilder<WeldComponentService> builder = target.addService(serviceName, weldComponentService)\n                        .addDependency(weldServiceName, WeldBootstrapService.class, weldComponentService.getWeldContainer())\n                         .addDependency(weldStartService);\n\n        configuration.setInstanceFactory(WeldManagedReferenceFactory.INSTANCE);\n        configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>() {\n            @Override\n            public void configureDependency(final ServiceBuilder<?> serviceBuilder, ComponentStartService service) throws DeploymentUnitProcessingException {\n                serviceBuilder.addDependency(serviceName);\n            }\n        });\n\n        //if this is an ejb add the EJB interceptors\n        if (description instanceof EJBComponentDescription) {\n\n            //add interceptor to activate the request scope if required\n            final EjbRequestScopeActivationInterceptor.Factory requestFactory = new EjbRequestScopeActivationInterceptor.Factory(weldServiceName);\n            configuration.addComponentInterceptor(requestFactory, InterceptorOrder.Component.CDI_REQUEST_SCOPE, false);\n\n            final Jsr299BindingsInterceptor.Factory aroundInvokeFactory = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_INVOKE, classLoader);\n            final Jsr299BindingsInterceptor.Factory aroundTimeoutFactory = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_TIMEOUT, classLoader);\n\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, aroundTimeoutFactory.getWeldContainer());\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, aroundInvokeFactory.getWeldContainer());\n\n            configuration.addComponentInterceptor(new UserInterceptorFactory(aroundInvokeFactory, aroundTimeoutFactory), InterceptorOrder.Component.CDI_INTERCEPTORS, false);\n\n            final Jsr299BindingsInterceptor.Factory preDestroyInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.PRE_DESTROY, classLoader);\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, preDestroyInterceptor.getWeldContainer());\n            configuration.addPreDestroyInterceptor(preDestroyInterceptor, InterceptorOrder.ComponentPreDestroy.CDI_INTERCEPTORS);\n\n            if (description.isPassivationApplicable()) {\n                final Jsr299BindingsInterceptor.Factory prePassivateInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.PRE_PASSIVATE, classLoader);\n                builder.addDependency(weldServiceName, WeldBootstrapService.class, prePassivateInterceptor.getWeldContainer());\n                configuration.addPrePassivateInterceptor(prePassivateInterceptor, InterceptorOrder.ComponentPassivation.CDI_INTERCEPTORS);\n                final Jsr299BindingsInterceptor.Factory postActivateInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.POST_ACTIVATE, classLoader);\n                builder.addDependency(weldServiceName, WeldBootstrapService.class, postActivateInterceptor.getWeldContainer());\n                configuration.addPostActivateInterceptor(postActivateInterceptor, InterceptorOrder.ComponentPassivation.CDI_INTERCEPTORS);\n            }\n\n            final Jsr299BindingsInterceptor.Factory postConstruct = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.POST_CONSTRUCT, classLoader);\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, postConstruct.getWeldContainer());\n            configuration.addPostConstructInterceptor(postConstruct, InterceptorOrder.ComponentPostConstruct.CDI_INTERCEPTORS);\n\n            /*\n             * Add interceptor to activate the request scope for the @PostConstruct callback.\n             * See https://issues.jboss.org/browse/CDI-219 for details\n             */\n            final EjbRequestScopeActivationInterceptor.Factory postConstructRequestContextActivationFactory = new EjbRequestScopeActivationInterceptor.Factory(weldServiceName);\n            configuration.addPostConstructInterceptor(postConstructRequestContextActivationFactory, InterceptorOrder.ComponentPostConstruct.REQUEST_SCOPE_ACTIVATING_INTERCEPTOR);\n\n        }\n\n        builder.install();\n\n        configuration.addPostConstructInterceptor(new ImmediateInterceptorFactory(new WeldInjectionContextInterceptor(weldComponentService)), InterceptorOrder.ComponentPostConstruct.WELD_INJECTION_CONTEXT_INTERCEPTOR);\n        configuration.addPostConstructInterceptor(new WeldInterceptorInjectionInterceptor.Factory(configuration, interceptorClasses), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_WELD_INJECTION);\n        configuration.addPostConstructInterceptor(new WeldInjectionInterceptor.Factory(configuration), InterceptorOrder.ComponentPostConstruct.COMPONENT_WELD_INJECTION);\n\n    }","id":24016,"modified_method":"/**\n     * As the weld based instantiator needs access to the bean manager it is installed as a service.\n     */\n    private void addWeldIntegration(final ServiceTarget target, final ComponentConfiguration configuration, final ComponentDescription description, final Class<?> componentClass, final String beanName, final ServiceName weldServiceName, final ServiceName weldStartService, final Set<Class<?>> interceptorClasses, final ClassLoader classLoader, final String beanDeploymentArchiveId) {\n\n        final ServiceName serviceName = configuration.getComponentDescription().getServiceName().append(\"WeldInstantiator\");\n\n        final WeldComponentService weldComponentService = new WeldComponentService(componentClass, beanName, interceptorClasses, classLoader, beanDeploymentArchiveId, description.isCDIInterceptorEnabled(), description);\n                ServiceBuilder<WeldComponentService> builder = target.addService(serviceName, weldComponentService)\n                        .addDependency(weldServiceName, WeldBootstrapService.class, weldComponentService.getWeldContainer())\n                         .addDependency(weldStartService);\n\n        configuration.setInstanceFactory(WeldManagedReferenceFactory.INSTANCE);\n        configuration.getStartDependencies().add(new DependencyConfigurator<ComponentStartService>() {\n            @Override\n            public void configureDependency(final ServiceBuilder<?> serviceBuilder, ComponentStartService service) throws DeploymentUnitProcessingException {\n                serviceBuilder.addDependency(serviceName);\n            }\n        });\n\n        //if this is an ejb add the EJB interceptors\n        if (description instanceof EJBComponentDescription) {\n\n            //add interceptor to activate the request scope if required\n            final EjbRequestScopeActivationInterceptor.Factory requestFactory = new EjbRequestScopeActivationInterceptor.Factory(weldServiceName);\n            configuration.addComponentInterceptor(requestFactory, InterceptorOrder.Component.CDI_REQUEST_SCOPE, false);\n\n            final Jsr299BindingsInterceptor.Factory aroundInvokeFactory = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_INVOKE, classLoader);\n            final Jsr299BindingsInterceptor.Factory aroundTimeoutFactory = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_TIMEOUT, classLoader);\n\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, aroundTimeoutFactory.getWeldContainer());\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, aroundInvokeFactory.getWeldContainer());\n\n            configuration.addComponentInterceptor(new UserInterceptorFactory(aroundInvokeFactory, aroundTimeoutFactory), InterceptorOrder.Component.CDI_INTERCEPTORS, false);\n\n            final Jsr299BindingsInterceptor.Factory preDestroyInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.PRE_DESTROY, classLoader);\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, preDestroyInterceptor.getWeldContainer());\n            configuration.addPreDestroyInterceptor(preDestroyInterceptor, InterceptorOrder.ComponentPreDestroy.CDI_INTERCEPTORS);\n\n            if (description.isPassivationApplicable()) {\n                final Jsr299BindingsInterceptor.Factory prePassivateInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.PRE_PASSIVATE, classLoader);\n                builder.addDependency(weldServiceName, WeldBootstrapService.class, prePassivateInterceptor.getWeldContainer());\n                configuration.addPrePassivateInterceptor(prePassivateInterceptor, InterceptorOrder.ComponentPassivation.CDI_INTERCEPTORS);\n                final Jsr299BindingsInterceptor.Factory postActivateInterceptor = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.POST_ACTIVATE, classLoader);\n                builder.addDependency(weldServiceName, WeldBootstrapService.class, postActivateInterceptor.getWeldContainer());\n                configuration.addPostActivateInterceptor(postActivateInterceptor, InterceptorOrder.ComponentPassivation.CDI_INTERCEPTORS);\n            }\n\n            final Jsr299BindingsInterceptor.Factory postConstruct = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.POST_CONSTRUCT, classLoader);\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, postConstruct.getWeldContainer());\n            configuration.addPostConstructInterceptor(postConstruct, InterceptorOrder.ComponentPostConstruct.CDI_INTERCEPTORS);\n\n            final Jsr299BindingsInterceptor.Factory aroundConstruct = new Jsr299BindingsInterceptor.Factory(description.getBeanDeploymentArchiveId(), beanName, InterceptionType.AROUND_CONSTRUCT, classLoader);\n            builder.addDependency(weldServiceName, WeldBootstrapService.class, aroundConstruct.getWeldContainer());\n            configuration.addAroundConstructInterceptor(aroundConstruct, InterceptorOrder.AroundConstruct.WELD_AROUND_CONSTRUCT_INTERCEPTORS);\n\n            /*\n             * Add interceptor to activate the request scope for the @PostConstruct callback.\n             * See https://issues.jboss.org/browse/CDI-219 for details\n             */\n            final EjbRequestScopeActivationInterceptor.Factory postConstructRequestContextActivationFactory = new EjbRequestScopeActivationInterceptor.Factory(weldServiceName);\n            configuration.addPostConstructInterceptor(postConstructRequestContextActivationFactory, InterceptorOrder.ComponentPostConstruct.REQUEST_SCOPE_ACTIVATING_INTERCEPTOR);\n\n        }\n\n        builder.install();\n\n        configuration.addAroundConstructInterceptor(new ImmediateInterceptorFactory(WeldConstructionStartInterceptor.INSTANCE), InterceptorOrder.AroundConstruct.CONSTRUCTION_START_INTERCEPTOR);\n\n        configuration.addPostConstructInterceptor(new ImmediateInterceptorFactory(new WeldInjectionContextInterceptor(weldComponentService)), InterceptorOrder.ComponentPostConstruct.WELD_INJECTION_CONTEXT_INTERCEPTOR);\n        configuration.addPostConstructInterceptor(new WeldInterceptorInjectionInterceptor.Factory(configuration, interceptorClasses), InterceptorOrder.ComponentPostConstruct.INTERCEPTOR_WELD_INJECTION);\n        configuration.addPostConstructInterceptor(new WeldInjectionInterceptor.Factory(configuration), InterceptorOrder.ComponentPostConstruct.COMPONENT_WELD_INJECTION);\n\n    }","commit_id":"9210a5058bfc318f81163f8ea31b060a6c047c91","url":"https://github.com/wildfly/wildfly"},{"original_method":"public WeldManagedReference produce() {\n        if (delegateProduce && bean instanceof ManagedBean) {\n            final Object instance = ((ManagedBean) bean).getInjectionTarget().produce(context);\n            return new WeldManagedReference(context, instance);\n        } else {\n            final Object instance = injectionTarget.produce(context);\n            return new WeldManagedReference(context, instance);\n        }\n    }","id":24017,"modified_method":"public Object produce() {\n        if (delegateProduce && bean instanceof ManagedBean) {\n            return ((ManagedBean) bean).getInjectionTarget().produce(context);\n        } else {\n            return injectionTarget.produce(context);\n        }\n    }","commit_id":"9210a5058bfc318f81163f8ea31b060a6c047c91","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ManagedReference create(final InterceptorContext context) {\n        WeldInjectionContext injectionContext = context.getPrivateData(WeldInjectionContext.class);\n        return injectionContext.produce();\n    }","id":24018,"modified_method":"@Override\n    public ManagedReference create(final InterceptorContext context) {\n        ConstructionHandle<?> ctx = context.getPrivateData(ConstructionHandle.class);\n        CreationalContext<?> injectionCtx = context.getPrivateData(WeldInjectionContext.class).getContext();\n        Object instance = ctx.proceed(context.getParameters(), context.getContextData()); // let Weld create the instance now\n        return new WeldManagedReference(injectionCtx, instance);\n    }","commit_id":"9210a5058bfc318f81163f8ea31b060a6c047c91","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Nullable\n    @Override\n    public T get(String name) {\n        // TODO - lock this down\n        MutableModelNode link = modelNode.getLink(name);\n        return link == null ? null : link.getPrivateData(ModelType.of(elementType));\n    }","id":24019,"modified_method":"@Nullable\n    @Override\n    public T get(String name) {\n        // TODO - lock this down\n        MutableModelNode link = modelNode.getLink(name);\n        if (link == null) {\n            return null;\n        }\n        link.ensureCreated();\n        return link.getPrivateData(ModelType.of(elementType));\n    }","commit_id":"0582e30f049f8fe7408a4a56567e7bb02a7bab3d","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public MutableModelNode addLink(ModelCreator creator) {\n            // Disabled before 2.3 release due to not wanting to validate task names (which may contain invalid chars), at least not yet\n            // ModelPath.validateName(name);\n\n            // TODO - bust out path from creation action\n            ModelNode node = this.node.addLink(creator.getPath().getName(), creator.getDescriptor(), creator.getPromise(), creator.getAdapter());\n            modelGraph.add(node);\n            notifyCreationListeners(node);\n            // TODO - don't create eagerly\n//            bind(creator);\n            NodeWrapper child = new NodeWrapper(node);\n            creator.create(child, null);\n            node.setState(ModelNode.State.Created);\n            return child;\n        }","id":24020,"modified_method":"@Override\n        public MutableModelNode addLink(ModelCreator creator) {\n            // Disabled before 2.3 release due to not wanting to validate task names (which may contain invalid chars), at least not yet\n            // ModelPath.validateName(name);\n\n            // TODO - bust out path from creation action\n            ModelNode node = this.node.addLink(creator.getPath().getName(), creator.getDescriptor(), creator.getPromise(), creator.getAdapter());\n            modelGraph.add(node);\n            notifyCreationListeners(node);\n            bind(creator);\n            return new NodeWrapper(node);\n        }","commit_id":"0582e30f049f8fe7408a4a56567e7bb02a7bab3d","url":"https://github.com/gradle/gradle"},{"original_method":"private void close(ModelNode node) {\n        if (node.getState() == ModelNode.State.GraphClosed) {\n            return;\n        }\n\n        ModelPath path = node.getPath();\n        LOGGER.debug(\"Closing {}\", path);\n\n        if (node.getState() == ModelNode.State.Known) {\n            BoundModelCreator creator = creators.remove(path);\n            if (creator == null) {\n                // Unbound creator - should give better error message here\n                throw new IllegalStateException(\"Don't know how to create model element at '\" + path + \"'\");\n            }\n            doCreate(node, creator);\n            node.setState(ModelNode.State.Created);\n        }\n        if (node.getState() == ModelNode.State.Created) {\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Defaults)), usedMutators);\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Initialize)), usedMutators);\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Mutate)), usedMutators);\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Finalize)), usedMutators);\n            node.setState(ModelNode.State.SelfClosed);\n        }\n        if (node.getState() == ModelNode.State.SelfClosed) {\n            for (ModelNode child : node.getLinks().values()) {\n                close(child);\n            }\n            node.setState(ModelNode.State.GraphClosed);\n        }\n        LOGGER.debug(\"Finished closing {}\", path);\n    }","id":24021,"modified_method":"private void close(ModelNode node) {\n        if (node.getState() == ModelNode.State.GraphClosed) {\n            return;\n        }\n\n        ModelPath path = node.getPath();\n        LOGGER.debug(\"Closing {}\", path);\n\n        maybeCreate(node);\n        maybeMutate(node);\n        maybeCloseLinked(node);\n\n        LOGGER.debug(\"Finished closing {}\", path);\n    }","commit_id":"0582e30f049f8fe7408a4a56567e7bb02a7bab3d","url":"https://github.com/gradle/gradle"},{"original_method":"protected TransactionAttributeType getCurrentTransactionAttribute() {\n        final InterceptorContext currentInvocationContext = CurrentInvocationContext.get();\n\n        if (currentInvocationContext == null) {\n            return null;\n        }\n        final Method invokedMethod = currentInvocationContext.getMethod();\n        // if method is null, then it's a lifecycle invocation\n        if (invokedMethod == null) {\n            return null;\n        }\n\n        final ComponentView componentView = currentInvocationContext.getPrivateData(ComponentView.class);\n        final MethodIntf methodIntf = componentView.getPrivateData(MethodIntf.class);\n        // get the tx attribute of the invoked method\n        return this.getTransactionAttributeType(methodIntf, invokedMethod);\n    }","id":24022,"modified_method":"protected TransactionAttributeType getCurrentTransactionAttribute() {\n\n        final InterceptorContext invocation = CurrentInvocationContext.get();\n        //for timer invocations there is no view, so the methodInf is attached directly\n        //to the context. Otherwise we retrive it from the invoked view\n        MethodIntf methodIntf = invocation.getPrivateData(MethodIntf.class);\n        if (methodIntf == null) {\n            final ComponentView componentView = invocation.getPrivateData(ComponentView.class);\n            if (componentView != null) {\n                methodIntf = componentView.getPrivateData(MethodIntf.class);\n            } else {\n                methodIntf = MethodIntf.BEAN;\n            }\n        }\n\n        return getTransactionAttributeType(methodIntf, invocation.getMethod());\n    }","commit_id":"0d685f89bc36688f12ac4ca859b65a327ef5082d","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Map<String, Object> collect() {\n        Map<String, Object> info = Maps.newHashMap();\n        \n        info.put(\"version\", Core.GRAYLOG2_VERSION);\n        info.put(\"number_of_loaded_modules\", numberOfLoadedModules());\n        info.put(\"number_of_elasticsearch_nodes\", server.getIndexer().getNumberOfNodesInCluster());\n        info.put(\"number_of_graylog2_server_nodes\", Node.allActive(server).size());\n        info.put(\"number_of_total_messages\", server.getIndexer().getTotalNumberOfMessagesInIndices());\n        info.put(\"number_of_indices\", server.getDeflector().getAllDeflectorIndices().size());\n        info.put(\"number_of_streams\", StreamImpl.loadAllEnabled(server).size());\n        info.put(\"number_of_stream_rules\", numberOfStreamRules());\n        info.put(\"number_of_blacklist_rules\", Blacklist.fetchAll().size());\n        info.put(\"total_index_size\", server.getIndexer().getTotalIndexSize());\n        \n        return info;\n    }","id":24023,"modified_method":"public Map<String, Object> collect() {\n        Map<String, Object> info = Maps.newHashMap();\n        \n        info.put(\"version\", Core.GRAYLOG2_VERSION);\n        info.put(\"number_of_loaded_modules\", numberOfLoadedModules());\n        info.put(\"number_of_elasticsearch_nodes\", server.getIndexer().cluster().getNumberOfNodes());\n        info.put(\"number_of_graylog2_server_nodes\", Node.allActive(server).size());\n        info.put(\"number_of_total_messages\", server.getIndexer().indices().getTotalNumberOfMessages());\n        info.put(\"number_of_indices\", server.getDeflector().getAllDeflectorIndices().size());\n        info.put(\"number_of_streams\", StreamImpl.loadAllEnabled(server).size());\n        info.put(\"number_of_stream_rules\", numberOfStreamRules());\n        info.put(\"number_of_blacklist_rules\", Blacklist.fetchAll().size());\n        info.put(\"total_index_size\", server.getIndexer().indices().getTotalSize());\n        \n        return info;\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void cycle() {\n        LOG.info(\"Cycling deflector to next index now.\");\n        int oldTargetNumber;\n        \n        try {\n            oldTargetNumber = getCurrentTargetNumber();\n        } catch (NoTargetIndexException ex) {\n            oldTargetNumber = -1;\n        }\n        \n        int newTargetNumber = oldTargetNumber+1;\n        \n        String newTarget = buildIndexName(server.getConfiguration().getElasticSearchIndexPrefix(), newTargetNumber);\n        String oldTarget = buildIndexName(server.getConfiguration().getElasticSearchIndexPrefix(), oldTargetNumber);\n        \n        if (oldTargetNumber == -1) {\n            LOG.info(\"Cycling from <none> to <{}>\", newTarget);\n        } else {\n            LOG.info(\"Cycling from <{}> to <{}>\", oldTarget, newTarget);\n        }\n        \n        // Create new index.\n        LOG.info(\"Creating index target <{}>...\", newTarget);\n        server.getIndexer().createIndex(newTarget);\n        updateIndexRanges(newTarget);\n\n        LOG.info(\"Done!\");\n        \n        // Point deflector to new index.\n        LOG.info(\"Pointing deflector to new target index....\");\n\n        Activity activity = new Activity(Deflector.class);\n        if (oldTargetNumber == -1) {\n            // Only pointing, not cycling.\n            pointTo(newTarget);\n            activity.setMessage(\"Cycled deflector from <none> to <\" + newTarget + \">\");\n        } else {\n            // Re-pointing from existing old index to the new one.\n            pointTo(newTarget, oldTarget);\n            activity.setMessage(\"Cycled deflector from <\" + oldTarget + \"> to <\" + newTarget + \">\");\n        }\n        LOG.info(\"Done!\");\n\n        server.getActivityWriter().write(activity);\n    }","id":24024,"modified_method":"public void cycle() {\n        LOG.info(\"Cycling deflector to next index now.\");\n        int oldTargetNumber;\n        \n        try {\n            oldTargetNumber = getCurrentTargetNumber();\n        } catch (NoTargetIndexException ex) {\n            oldTargetNumber = -1;\n        }\n        \n        int newTargetNumber = oldTargetNumber+1;\n        \n        String newTarget = buildIndexName(server.getConfiguration().getElasticSearchIndexPrefix(), newTargetNumber);\n        String oldTarget = buildIndexName(server.getConfiguration().getElasticSearchIndexPrefix(), oldTargetNumber);\n        \n        if (oldTargetNumber == -1) {\n            LOG.info(\"Cycling from <none> to <{}>\", newTarget);\n        } else {\n            LOG.info(\"Cycling from <{}> to <{}>\", oldTarget, newTarget);\n        }\n        \n        // Create new index.\n        LOG.info(\"Creating index target <{}>...\", newTarget);\n        server.getIndexer().indices().create(newTarget);\n        updateIndexRanges(newTarget);\n\n        LOG.info(\"Done!\");\n        \n        // Point deflector to new index.\n        LOG.info(\"Pointing deflector to new target index....\");\n\n        Activity activity = new Activity(Deflector.class);\n        if (oldTargetNumber == -1) {\n            // Only pointing, not cycling.\n            pointTo(newTarget);\n            activity.setMessage(\"Cycled deflector from <none> to <\" + newTarget + \">\");\n        } else {\n            // Re-pointing from existing old index to the new one.\n            pointTo(newTarget, oldTarget);\n            activity.setMessage(\"Cycled deflector from <\" + oldTarget + \"> to <\" + newTarget + \">\");\n        }\n        LOG.info(\"Done!\");\n\n        server.getActivityWriter().write(activity);\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public String[] getAllDeflectorIndexNames() {\n        List<String> indices = Lists.newArrayList();\n        \n        for(Map.Entry<String, IndexStats> e : server.getIndexer().getIndices().entrySet()) {\n            String name = e.getKey();\n            \n            if (ourIndex(name)) {\n                indices.add(name);\n            }\n        }\n        \n        return indices.toArray(new String[0]);\n    }","id":24025,"modified_method":"public String[] getAllDeflectorIndexNames() {\n        List<String> indices = Lists.newArrayList();\n        \n        for(Map.Entry<String, IndexStats> e : server.getIndexer().indices().getAll().entrySet()) {\n            String name = e.getKey();\n            \n            if (ourIndex(name)) {\n                indices.add(name);\n            }\n        }\n        \n        return indices.toArray(new String[0]);\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Map<String, IndexStats> getAllDeflectorIndices() {\n        Map<String, IndexStats> result = Maps.newHashMap();\n        for(Map.Entry<String, IndexStats> e : server.getIndexer().getIndices().entrySet()) {\n            String name = e.getKey();\n            \n            if (ourIndex(name)) {\n                result.put(name, e.getValue());\n            }\n        }\n        \n        return result;\n    }","id":24026,"modified_method":"public Map<String, IndexStats> getAllDeflectorIndices() {\n        Map<String, IndexStats> result = Maps.newHashMap();\n        for(Map.Entry<String, IndexStats> e : server.getIndexer().indices().getAll().entrySet()) {\n            String name = e.getKey();\n            \n            if (ourIndex(name)) {\n                result.put(name, e.getValue());\n            }\n        }\n        \n        return result;\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public int getCurrentTargetNumber() throws NoTargetIndexException {\n        Map<String, IndexStats> indexes = this.server.getIndexer().getIndices();\n        if (indexes.isEmpty()) {\n            throw new NoTargetIndexException();\n        }\n \n        List<Integer> indexNumbers = new ArrayList<Integer>();\n        \n        for(Map.Entry<String, IndexStats> e : indexes.entrySet()) {\n            if (!ourIndex(e.getKey())) {\n                continue;\n            }\n            \n            try {\n                indexNumbers.add(extractIndexNumber(e.getKey()));\n            } catch (NumberFormatException ex) {\n                continue;\n            }\n        }\n\n        if (indexNumbers.isEmpty()) {\n            throw new NoTargetIndexException();\n        }\n        \n        return Collections.max(indexNumbers);\n    }","id":24027,"modified_method":"public int getCurrentTargetNumber() throws NoTargetIndexException {\n        Map<String, IndexStats> indexes = this.server.getIndexer().indices().getAll();\n        if (indexes.isEmpty()) {\n            throw new NoTargetIndexException();\n        }\n \n        List<Integer> indexNumbers = new ArrayList<Integer>();\n        \n        for(Map.Entry<String, IndexStats> e : indexes.entrySet()) {\n            if (!ourIndex(e.getKey())) {\n                continue;\n            }\n            \n            try {\n                indexNumbers.add(extractIndexNumber(e.getKey()));\n            } catch (NumberFormatException ex) {\n                continue;\n            }\n        }\n\n        if (indexNumbers.isEmpty()) {\n            throw new NoTargetIndexException();\n        }\n        \n        return Collections.max(indexNumbers);\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public boolean isUp() {\n        return this.server.getIndexer().aliasExists(DEFLECTOR_NAME);\n    }","id":24028,"modified_method":"public boolean isUp() {\n        return this.server.getIndexer().indices().aliasExists(DEFLECTOR_NAME);\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void point() {\n        // Check if message limit of current target is hit. Point to new target if so.\n        String currentTarget;\n        long messageCountInTarget = 0;\n        \n        try {\n            currentTarget = this.graylogServer.getDeflector().getCurrentTargetName();\n            messageCountInTarget = this.graylogServer.getIndexer().numberOfMessages(currentTarget);\n        } catch(Exception e) {\n            LOG.error(\"Tried to check for number of messages in current deflector target but did not find index. Aborting.\", e);\n            return;\n        }\n        \n        if (messageCountInTarget > graylogServer.getConfiguration().getElasticSearchMaxDocsPerIndex()) {\n            LOG.info(\"Number of messages in <{}> ({}) is higher than the limit ({}). Pointing deflector to new index now!\",\n                    new Object[] {\n                            currentTarget, messageCountInTarget,\n                            graylogServer.getConfiguration().getElasticSearchMaxDocsPerIndex()\n                    });\n            graylogServer.getDeflector().cycle();\n        } else {\n            LOG.debug(\"Number of messages in <{}> ({}) is lower than the limit ({}). Not doing anything.\",\n                    new Object[] {\n                            currentTarget,messageCountInTarget,\n                            graylogServer.getConfiguration().getElasticSearchMaxDocsPerIndex()\n                    });\n        }\n    }","id":24029,"modified_method":"private void point() {\n        // Check if message limit of current target is hit. Point to new target if so.\n        String currentTarget;\n        long messageCountInTarget = 0;\n        \n        try {\n            currentTarget = this.graylogServer.getDeflector().getCurrentTargetName();\n            messageCountInTarget = this.graylogServer.getIndexer().indices().numberOfMessages(currentTarget);\n        } catch(Exception e) {\n            LOG.error(\"Tried to check for number of messages in current deflector target but did not find index. Aborting.\", e);\n            return;\n        }\n        \n        if (messageCountInTarget > graylogServer.getConfiguration().getElasticSearchMaxDocsPerIndex()) {\n            LOG.info(\"Number of messages in <{}> ({}) is higher than the limit ({}). Pointing deflector to new index now!\",\n                    new Object[] {\n                            currentTarget, messageCountInTarget,\n                            graylogServer.getConfiguration().getElasticSearchMaxDocsPerIndex()\n                    });\n            graylogServer.getDeflector().cycle();\n        } else {\n            LOG.debug(\"Number of messages in <{}> ({}) is lower than the limit ({}). Not doing anything.\",\n                    new Object[] {\n                            currentTarget,messageCountInTarget,\n                            graylogServer.getConfiguration().getElasticSearchMaxDocsPerIndex()\n                    });\n        }\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void checkAndRepair() {\n        if (!graylogServer.getDeflector().isUp()) {\n            if (graylogServer.getIndexer().indexExists(Deflector.DEFLECTOR_NAME)) {\n                // Publish a notification if there is an *index* called graylog2_deflector\n                if (Notification.isFirst(graylogServer, Notification.Type.DEFLECTOR_EXISTS_AS_INDEX)) {\n                    Notification.publish(graylogServer, Notification.Type.DEFLECTOR_EXISTS_AS_INDEX, Notification.Severity.URGENT);\n                    LOG.warn(\"There is an index called [\" + Deflector.DEFLECTOR_NAME + \"]. Cannot fix this automatically and published a notification.\");\n                }\n            } else {\n                graylogServer.getDeflector().setUp();\n            }\n        }\n\n\n    }","id":24030,"modified_method":"private void checkAndRepair() {\n        if (!graylogServer.getDeflector().isUp()) {\n            if (graylogServer.getIndexer().indices().exists(Deflector.DEFLECTOR_NAME)) {\n                // Publish a notification if there is an *index* called graylog2_deflector\n                if (Notification.isFirst(graylogServer, Notification.Type.DEFLECTOR_EXISTS_AS_INDEX)) {\n                    Notification.publish(graylogServer, Notification.Type.DEFLECTOR_EXISTS_AS_INDEX, Notification.Severity.URGENT);\n                    LOG.warn(\"There is an index called [\" + Deflector.DEFLECTOR_NAME + \"]. Cannot fix this automatically and published a notification.\");\n                }\n            } else {\n                graylogServer.getDeflector().setUp();\n            }\n        }\n\n\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public boolean isCancelable() {\n        return true;\n    }","id":24031,"modified_method":"@Override\n    public boolean isCancelable() {\n        return false;\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void requestCancel() {\n        this.cancelRequested = true;\n    }","id":24032,"modified_method":"@Override\n    public void requestCancel() {\n        // Cannot be canceled.\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void execute() {\n        LOG.info(\"Attempting to fix deflector with delete strategy.\");\n\n        // Pause message processing and lock the pause.\n        core.pauseMessageProcessing(true);\n\n        // Clear all caches. They would be written to the deflector index anyway and this is the delete strategy.\n        core.getInputCache().clear();\n        core.getOutputCache().clear();\n\n        // Wait until the buffers are empty. Messages that where already started to be processed must be fully processed.\n        while(true) {\n            if(core.getProcessBuffer().isEmpty() && core.getOutputBuffer().isEmpty()) {\n                break;\n            }\n\n            try {\n                LOG.info(\"Not all buffers are empty. Waiting another second.\");\n                Thread.sleep(1000);\n            } catch (InterruptedException e) { /* */ }\n        }\n\n        LOG.info(\"All buffers and caches are empty. Continuing.\");\n\n        progress = 25;\n\n        // Delete deflector index.\n        LOG.info(\"Deleting <{}> index.\", Deflector.DEFLECTOR_NAME);\n        core.getIndexer().deleteIndex(Deflector.DEFLECTOR_NAME);\n        progress = 50;\n\n        // Set up deflector.\n        progress = 75;\n\n        // Start message processing again.\n        try {\n            core.unlockProcessingPause();\n            core.resumeMessageProcessing();\n        } catch (ProcessingPauseLockedException e) {\n            // lol checked exceptions\n            throw new RuntimeException(\"Could not unlock processing pause.\", e);\n        }\n\n        progress = 100;\n        LOG.info(\"Finished.\");\n    }","id":24033,"modified_method":"@Override\n    public void execute() {\n        if (core.getDeflector().isUp() || !core.getIndexer().indices().exists(Deflector.DEFLECTOR_NAME)) {\n            LOG.error(\"There is no index <{}>. No need to run this job. Aborting.\", Deflector.DEFLECTOR_NAME);\n            return;\n        }\n\n        LOG.info(\"Attempting to fix deflector with delete strategy.\");\n\n        // Pause message processing and lock the pause.\n        core.pauseMessageProcessing(true);\n        progress = 10;\n\n        Buffers.waitForEmptyBuffers(core);\n        progress = 25;\n\n        // Delete deflector index.\n        LOG.info(\"Deleting <{}> index.\", Deflector.DEFLECTOR_NAME);\n        core.getIndexer().indices().delete(Deflector.DEFLECTOR_NAME);\n        progress = 70;\n\n        // Set up deflector.\n        core.getDeflector().setUp();\n        progress = 80;\n\n        // Start message processing again.\n        try {\n            core.unlockProcessingPause();\n            core.resumeMessageProcessing();\n        } catch (ProcessingPauseLockedException e) {\n            // lol checked exceptions\n            throw new RuntimeException(\"Could not unlock processing pause.\", e);\n        }\n\n        progress = 100;\n        LOG.info(\"Finished.\");\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public void execute() {\n\n        // wait until all buffered and cached messages are written\n    }","id":24034,"modified_method":"@Override\n    public void execute() {\n        if (core.getDeflector().isUp() || !core.getIndexer().indices().exists(Deflector.DEFLECTOR_NAME)) {\n            LOG.error(\"There is no index <{}>. No need to run this job. Aborting.\", Deflector.DEFLECTOR_NAME);\n            return;\n        }\n\n        LOG.info(\"Attempting to fix deflector with delete strategy.\");\n\n        // Pause message processing and lock the pause.\n        core.pauseMessageProcessing(true);\n        progress = 10;\n\n        Buffers.waitForEmptyBuffers(core);\n        progress = 25;\n\n        // Copy messages to new index.\n        core.getIndexer().indices().move(Deflector.DEFLECTOR_NAME, \"LOL_TEST_9001\");\n\n        progress = 85;\n\n        // Delete deflector index.\n        LOG.info(\"Deleting <{}> index.\", Deflector.DEFLECTOR_NAME);\n        core.getIndexer().indices().delete(Deflector.DEFLECTOR_NAME);\n        progress = 90;\n\n        // Set up deflector.\n        core.getDeflector().setUp();\n        progress = 95;\n\n        // Start message processing again.\n        try {\n            core.unlockProcessingPause();\n            core.resumeMessageProcessing();\n        } catch (ProcessingPauseLockedException e) {\n            // lol checked exceptions\n            throw new RuntimeException(\"Could not unlock processing pause.\", e);\n        }\n\n        progress = 100;\n        LOG.info(\"Finished.\");\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public int getProgress() {\n        return 0;\n    }","id":24035,"modified_method":"@Override\n    public int getProgress() {\n        return progress;\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Override\n    public boolean providesProgress() {\n        return false;\n    }","id":24036,"modified_method":"@Override\n    public boolean providesProgress() {\n        return true;\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Map<String, IndexStats> getIndices() {\n        ActionFuture<IndicesStatsResponse> isr = client.admin().indices().stats(new IndicesStatsRequest().all());\n        \n        return isr.actionGet().getIndices();\n    }","id":24037,"modified_method":"public Indices indices() {\n        return indices;\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public Indexer(Core graylogServer) {\n        server = graylogServer;\n\n        final NodeBuilder builder = nodeBuilder().client(true);\n        String esSettings;\n        Map<String, String> settings = null;\n        try {\n            esSettings = FileUtils.readFileToString(new File(graylogServer.getConfiguration().getElasticSearchConfigFile()));\n            settings = new YamlSettingsLoader().load(esSettings);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Cannot read elasticsearch configuration.\", e);\n        }\n        builder.settings().put(settings);\n        final Node node = builder.node();\n        client = node.client();\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                node.close();\n            }\n        });\n        \n        messageGateway = new MessageGatewayImpl(graylogServer);\n        searches = new Searches(client, graylogServer);\n        counts = new Counts(client, graylogServer);\n        messages = new Messages(client, graylogServer);\n        cluster = new Cluster(client, graylogServer);\n    }","id":24038,"modified_method":"public Indexer(Core graylogServer) {\n        server = graylogServer;\n\n        final NodeBuilder builder = nodeBuilder().client(true);\n        String esSettings;\n        Map<String, String> settings = null;\n        try {\n            esSettings = FileUtils.readFileToString(new File(graylogServer.getConfiguration().getElasticSearchConfigFile()));\n            settings = new YamlSettingsLoader().load(esSettings);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Cannot read elasticsearch configuration.\", e);\n        }\n        builder.settings().put(settings);\n        final Node node = builder.node();\n        client = node.client();\n\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                node.close();\n            }\n        });\n        \n        messageGateway = new MessageGatewayImpl(graylogServer);\n        searches = new Searches(client, graylogServer);\n        counts = new Counts(client, graylogServer);\n        messages = new Messages(client, graylogServer);\n        cluster = new Cluster(client, graylogServer);\n        indices = new Indices(client, graylogServer);\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void runIndexRetention() throws NoTargetIndexException {\n        Map<String, IndexStats> indices = server.getDeflector().getAllDeflectorIndices();\n        int indexCount = indices.size();\n        int maxIndices = server.getConfiguration().getMaxNumberOfIndices();\n        \n        // Do we have more indices than the configured maximum?\n        if (indexCount <= maxIndices) {\n            LOG.debug(\"Number of indices ({}) lower than limit ({}). Not performing any retention actions.\",\n                    indexCount, maxIndices);\n            return;\n        }\n        \n        // We have more indices than the configured maximum! Remove as many as needed.\n        int remove = indexCount-maxIndices;\n        String msg = \"Number of indices (\" + indexCount + \") higher than limit (\" + maxIndices + \"). Deleting \" + remove + \" indices.\";\n        LOG.info(msg);\n        server.getActivityWriter().write(new Activity(msg, Indexer.class));\n        \n        for (String indexName : IndexHelper.getOldestIndices(indices.keySet(), remove)) {\n            // Never delete the current deflector target.\n            if (server.getDeflector().getCurrentTargetName().equals(indexName)) {\n                LOG.info(\"Not deleting current deflector target <{}>.\", indexName);\n                continue;\n            }\n            \n            msg = \"Retention cleaning: Deleting index <\" + indexName + \">\";\n            LOG.info(msg);\n            server.getActivityWriter().write(new Activity(msg, Indexer.class));\n            \n            // Sorry if this should ever go mad. Delete the index!\n            deleteIndex(indexName);\n            IndexRange.destroy(server, indexName);\n        }\n    }","id":24039,"modified_method":"public void runIndexRetention() throws NoTargetIndexException {\n        Map<String, IndexStats> indices = server.getDeflector().getAllDeflectorIndices();\n        int indexCount = indices.size();\n        int maxIndices = server.getConfiguration().getMaxNumberOfIndices();\n        \n        // Do we have more indices than the configured maximum?\n        if (indexCount <= maxIndices) {\n            LOG.debug(\"Number of indices ({}) lower than limit ({}). Not performing any retention actions.\",\n                    indexCount, maxIndices);\n            return;\n        }\n        \n        // We have more indices than the configured maximum! Remove as many as needed.\n        int remove = indexCount-maxIndices;\n        String msg = \"Number of indices (\" + indexCount + \") higher than limit (\" + maxIndices + \"). Deleting \" + remove + \" indices.\";\n        LOG.info(msg);\n        server.getActivityWriter().write(new Activity(msg, Indexer.class));\n        \n        for (String indexName : IndexHelper.getOldestIndices(indices.keySet(), remove)) {\n            // Never delete the current deflector target.\n            if (server.getDeflector().getCurrentTargetName().equals(indexName)) {\n                LOG.info(\"Not deleting current deflector target <{}>.\", indexName);\n                continue;\n            }\n            \n            msg = \"Retention cleaning: Deleting index <\" + indexName + \">\";\n            LOG.info(msg);\n            server.getActivityWriter().write(new Activity(msg, Indexer.class));\n            \n            // Sorry if this should ever go mad. Delete the index!\n            indices().delete(indexName);\n            IndexRange.destroy(server, indexName);\n        }\n    }","commit_id":"6706eabec36449c2d7619b4a794681eeb485467b","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@GET @Timed\n    @ApiOperation(value = \"Get list of all message fields that exist\",\n                  notes = \"This operation is comparably fast because it reads directly from the indexer mapping.\")\n    @Path(\"/fields\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public String fields() {\n        Map<String, Object> result = Maps.newHashMap();\n        result.put(\"fields\", core.getIndexer().getAllMessageFields());\n\n        return json(result);\n    }","id":24040,"modified_method":"@GET @Timed\n    @ApiOperation(value = \"Get list of all message fields that exist\",\n                  notes = \"This operation is comparably fast because it reads directly from the indexer mapping.\")\n    @Path(\"/fields\")\n    @Produces(MediaType.APPLICATION_JSON)\n    public String fields() {\n        Map<String, Object> result = Maps.newHashMap();\n        result.put(\"fields\", core.getIndexer().indices().getAllMessageFields());\n\n        return json(result);\n    }","commit_id":"2d96f0bec3974f54c070783bc101c4c63be34b30","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Populates and returns a ChannelInfo object based on the input stream\n     * containing XML data structured according to the channel-definition dtd.\n     *  \n     * @param is\n     * @return\n     * @throws Exception\n     */\n    private ChannelInfo getChannelInfo(InputStream is) throws Exception {\n        ChannelInfo ci = new ChannelInfo();\n        Document doc = null;\n\n        // Build a DOM tree out of Channel_To_Publish.xml\n        doc = domParser.parse(is);\n\n        Element chanDefE = doc.getDocumentElement();\n        String fname = getFname(chanDefE);\n\n        // Use existing channel definition if it exists,\n        // otherwise make a new one with a new ID\n        ci.chanDef = crs.getChannelDefinition(fname);\n\n        if (ci.chanDef != null && !mOverrideExisting)\n        {\n            log.error(\n                \"chanDef with fname \"\n                    + fname\n                    + \" already exists \"\n                    + \"and override is false. Terminating publication.\");\n            return null;\n        }\n\n        if (ci.chanDef == null) {\n            ci.chanDef = crs.newChannelDefinition();\n        }\n\n        for (Node param = chanDefE.getFirstChild(); param != null; param = param.getNextSibling()) {\n            if (!(param instanceof Element))\n                continue; // whitespace (typically \\n) between tags\n            Element pele = (Element) param;\n            String tagname = pele.getTagName();\n            String value = XML.getElementText(pele);\n\n            // each tagname corresponds to an object data field\n            if (tagname.equals(\"title\"))\n                ci.chanDef.setTitle(value);\n            else if (tagname.equals(\"name\"))\n                ci.chanDef.setName(value);\n            else if (tagname.equals(\"makeFNameAccessibleOnly\"))\n                ci.fNameAccessibleOnly = true;\n            else if (tagname.equals(\"fname\"))\n                ci.chanDef.setFName(value);\n            else if (tagname.equals(\"desc\"))\n                ci.chanDef.setDescription(value);\n            else if (tagname.equals(\"type\"))\n                getType(ci, value);\n            else if (tagname.equals(\"class\"))\n                ci.chanDef.setJavaClass(value);\n            else if (tagname.equals(\"timeout\"))\n                ci.chanDef.setTimeout(Integer.parseInt(value));\n            else if (tagname.equals(\"hasedit\"))\n                ci.chanDef.setEditable((value != null && value.equals(\"Y\")) ? true : false);\n            else if (tagname.equals(\"hashelp\"))\n                ci.chanDef.setHasHelp((value != null && value.equals(\"Y\")) ? true : false);\n            else if (tagname.equals(\"hasabout\"))\n                ci.chanDef.setHasAbout((value != null && value.equals(\"Y\")) ? true : false);\n                else if (tagname.equals(\"secure\"))\n                  ci.chanDef.setIsSecure((value != null && value.equals(\"Y\")) ? true : false);                \n            else if (mOnCommandLine && tagname.equals(\"categories\"))\n                getCategories(ci, pele);\n            else if (mOnCommandLine && tagname.equals(\"groups\"))\n                getGroups(ci, pele);\n            else if (mOnCommandLine && tagname.equals(\"users\"))\n                getUsers(ci, pele);\n            else if (tagname.equals(\"parameters\"))\n                getParameters(ci, pele);\n\n            ci.chanDef.setPublisherId(0); // system user\n            ci.chanDef.setPublishDate(new Date());\n        }\n        if (ci.groups == null && ! mOnCommandLine)\n            ci.groups = getAdminGroup();\n        if (ci.categories == null && ! mOnCommandLine)\n            ci.categories = getDefaultCategory(ci.fNameAccessibleOnly);\n        return ci;\n    }","id":24041,"modified_method":"/**\n     * Populates and returns a ChannelInfo object based on the input stream\n     * containing XML data structured according to the channel-definition dtd.\n     *\n     * @param is\n     * @return\n     * @throws Exception\n     */\n    private ChannelInfo getChannelInfo(InputStream is) throws Exception {\n        ChannelInfo ci = new ChannelInfo();\n        Document doc = null;\n\n        // Build a DOM tree out of Channel_To_Publish.xml\n        doc = domParser.parse(is);\n\n        Element chanDefE = doc.getDocumentElement();\n        final String id = getId(chanDefE);\n        if (id != null) {\n            ci.chanDef = crs.newChannelDefinition(Integer.parseInt(id));\n        } else {\n            String fname = getFname(chanDefE);\n\n            // Use existing channel definition if it exists,\n            // otherwise make a new one with a new ID\n            ci.chanDef = crs.getChannelDefinition(fname);\n\n            if (ci.chanDef != null && !mOverrideExisting)\n            {\n                log.error(\n                        \"chanDef with fname \"\n                        + fname\n                        + \" already exists \"\n                        + \"and override is false. Terminating publication.\");\n                return null;\n            }\n\n            if (ci.chanDef == null) {\n                ci.chanDef = crs.newChannelDefinition();\n            }\n        }\n\n        for (Node param = chanDefE.getFirstChild(); param != null; param = param.getNextSibling()) {\n            if (!(param instanceof Element))\n                continue; // whitespace (typically \\n) between tags\n            Element pele = (Element) param;\n            String tagname = pele.getTagName();\n            String value = XML.getElementText(pele).trim();\n\n            // each tagname corresponds to an object data field\n            if (tagname.equals(\"title\"))\n                ci.chanDef.setTitle(value);\n            else if (tagname.equals(\"name\"))\n                ci.chanDef.setName(value);\n            else if (tagname.equals(\"makeFNameAccessibleOnly\"))\n                ci.fNameAccessibleOnly = true;\n            else if (tagname.equals(\"fname\"))\n                ci.chanDef.setFName(value);\n            else if (tagname.equals(\"desc\"))\n                ci.chanDef.setDescription(value);\n            else if (tagname.equals(\"type\"))\n                getType(ci, value);\n            else if (tagname.equals(\"class\"))\n                ci.chanDef.setJavaClass(value);\n            else if (tagname.equals(\"timeout\"))\n                ci.chanDef.setTimeout(Integer.parseInt(value));\n            else if (tagname.equals(\"hasedit\"))\n                ci.chanDef.setEditable((value != null && value.equals(\"Y\")) ? true : false);\n            else if (tagname.equals(\"hashelp\"))\n                ci.chanDef.setHasHelp((value != null && value.equals(\"Y\")) ? true : false);\n            else if (tagname.equals(\"hasabout\"))\n                ci.chanDef.setHasAbout((value != null && value.equals(\"Y\")) ? true : false);\n                else if (tagname.equals(\"secure\"))\n                  ci.chanDef.setIsSecure((value != null && value.equals(\"Y\")) ? true : false);\n            else if (mOnCommandLine && tagname.equals(\"categories\"))\n                getCategories(ci, pele);\n            else if (mOnCommandLine && tagname.equals(\"groups\"))\n                getGroups(ci, pele);\n            else if (mOnCommandLine && tagname.equals(\"users\"))\n                getUsers(ci, pele);\n            else if (tagname.equals(\"parameters\"))\n                getParameters(ci, pele);\n\n            ci.chanDef.setPublisherId(0); // system user\n            ci.chanDef.setPublishDate(new Date());\n        }\n        if (ci.groups == null && ! mOnCommandLine)\n            ci.groups = getAdminGroup();\n        if (ci.categories == null && ! mOnCommandLine)\n            ci.categories = getDefaultCategory(ci.fNameAccessibleOnly);\n        return ci;\n    }","commit_id":"6684c75f9340bdef03abb5a4cd92ae90facb2e21","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Find the channel id.\n     *\n     * @param chanDefE\n     * @return possible channel id\n     * @throws Exception\n     */\n    private String getId(Element chanDefE) throws Exception\n    {\n        String id = null;\n        for (Node n = chanDefE.getFirstChild();\n            n != null;\n            n = n.getNextSibling())\n        {\n            if (n.getNodeType() == Node.ELEMENT_NODE)\n            {\n                if (n.getNodeName().equals(\"channelId\"))\n                {\n                    id = XML.getElementText((Element) n);\n                }\n            }\n        }\n        return id;\n    }","id":24042,"modified_method":"/**\n     * Find the channel id.\n     *\n     * @param chanDefE\n     * @return possible channel id\n     * @throws Exception\n     */\n    private String getId(Element chanDefE) throws Exception\n    {\n        String id = null;\n        for (Node n = chanDefE.getFirstChild();\n            n != null;\n            n = n.getNextSibling())\n        {\n            if (n.getNodeType() == Node.ELEMENT_NODE)\n            {\n                if (n.getNodeName().equals(\"channelId\"))\n                {\n                    id = XML.getElementText((Element) n).trim();\n                }\n            }\n        }\n        return id;\n    }","commit_id":"6ae786f6f3ce9257056ae274628474ec0cbda357","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Determines the functional name of the channel.\n     *\n     * @param chanDefE\n     * @return\n     * @throws Exception\n     */\n    private String getFname(Element chanDefE) throws Exception\n    {\n        String fname = null;\n        for (Node n = chanDefE.getFirstChild();\n            n != null;\n            n = n.getNextSibling())\n        {\n            if (n.getNodeType() == Node.ELEMENT_NODE)\n            {\n                if (n.getNodeName().equals(\"fname\"))\n                {\n                    fname = XML.getElementText((Element) n);\n                }\n            }\n        }\n\n        // Complain if we don't find an fname\n        if (fname == null)\n            throw new Exception(\"Missing required fname element\");\n        return fname;\n    }","id":24043,"modified_method":"/**\n     * Determines the functional name of the channel.\n     *\n     * @param chanDefE\n     * @return\n     * @throws Exception\n     */\n    private String getFname(Element chanDefE) throws Exception\n    {\n        String fname = null;\n        for (Node n = chanDefE.getFirstChild();\n            n != null;\n            n = n.getNextSibling())\n        {\n            if (n.getNodeType() == Node.ELEMENT_NODE)\n            {\n                if (n.getNodeName().equals(\"fname\"))\n                {\n                    fname = XML.getElementText((Element) n).trim();\n                }\n            }\n        }\n\n        // Complain if we don't find an fname\n        if (fname == null)\n            throw new Exception(\"Missing required fname element\");\n        return fname;\n    }","commit_id":"6ae786f6f3ce9257056ae274628474ec0cbda357","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Load the declared parameters.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the parameter elements.\n     */\n    private void getParameters(ChannelInfo ci, Element pele)\n    {\n        NodeList anodes = pele.getElementsByTagName(\"parameter\");\n        if (anodes.getLength() > 0)\n        {\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                String pname = null;\n                String pvalue = null;\n                String povrd = null;\n                String pdescr = null;\n                Element anode = (Element) anodes.item(j);\n                NodeList namenodes = anode.getElementsByTagName(\"name\");\n                if (namenodes.getLength() > 0)\n                {\n                    pname = XML.getElementText((Element) namenodes.item(0));\n                }\n                NodeList valuenodes = anode.getElementsByTagName(\"value\");\n                if (valuenodes.getLength() > 0)\n                {\n                    pvalue = XML.getElementText((Element) valuenodes.item(0)).trim();\n                }\n                NodeList descnodes = anode.getElementsByTagName(\"description\");\n                if (descnodes.getLength() > 0)\n                {\n                    pdescr = XML.getElementText((Element) descnodes.item(0)).trim();\n                }\n                NodeList ovrdnodes = anode.getElementsByTagName(\"ovrd\");\n                if (ovrdnodes.getLength() > 0)\n                {\n                    povrd = XML.getElementText((Element) ovrdnodes.item(0));\n                }\n                ChannelParameter chanParam =\n                    new ChannelParameter(pname, pvalue, RDBMServices.dbFlag(povrd));\n                chanParam.setDescription(pdescr);\n                ci.chanDef.addParameter(chanParam);\n            }\n        }\n    }","id":24044,"modified_method":"/**\n     * Load the declared parameters.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the parameter elements.\n     */\n    private void getParameters(ChannelInfo ci, Element pele)\n    {\n        NodeList anodes = pele.getElementsByTagName(\"parameter\");\n        if (anodes.getLength() > 0)\n        {\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                String pname = null;\n                String pvalue = null;\n                String povrd = null;\n                String pdescr = null;\n                Element anode = (Element) anodes.item(j);\n                NodeList namenodes = anode.getElementsByTagName(\"name\");\n                if (namenodes.getLength() > 0)\n                {\n                    pname = XML.getElementText((Element) namenodes.item(0)).trim();\n                }\n                NodeList valuenodes = anode.getElementsByTagName(\"value\");\n                if (valuenodes.getLength() > 0)\n                {\n                    pvalue = XML.getElementText((Element) valuenodes.item(0)).trim();\n                }\n                NodeList descnodes = anode.getElementsByTagName(\"description\");\n                if (descnodes.getLength() > 0)\n                {\n                    pdescr = XML.getElementText((Element) descnodes.item(0)).trim();\n                }\n                NodeList ovrdnodes = anode.getElementsByTagName(\"ovrd\");\n                if (ovrdnodes.getLength() > 0)\n                {\n                    povrd = XML.getElementText((Element) ovrdnodes.item(0)).trim();\n                }\n                ChannelParameter chanParam =\n                    new ChannelParameter(pname, pvalue, RDBMServices.dbFlag(povrd));\n                chanParam.setDescription(pdescr);\n                ci.chanDef.addParameter(chanParam);\n            }\n        }\n    }","commit_id":"6ae786f6f3ce9257056ae274628474ec0cbda357","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Translate access group names into group ids.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the group elements.\n     * @throws Exception\n     */\n    private void getGroups(ChannelInfo ci, Element pele) throws Exception\n    {\n        NodeList anodes = pele.getElementsByTagName(\"group\");\n        if (anodes.getLength() != 0)\n        {\n            ci.groups = new IEntityGroup[anodes.getLength()];\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                Element anode = (Element) anodes.item(j);\n                String groupStr = XML.getElementText(anode);\n                // need to look up corresponding group id\n                // ie: Everyone = local.0\n                //     Developers = local.4\n                IEntityGroup group = getGroup(groupStr, IPerson.class);\n\n                if (group != null)\n                    ci.groups[j] = group;\n                else\n                    throw new Exception(\n                        \"Invalid entry '\" + groupStr + \"' for group.\");\n            }\n        }\n    }","id":24045,"modified_method":"/**\n     * Translate access group names into group ids.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the group elements.\n     * @throws Exception\n     */\n    private void getGroups(ChannelInfo ci, Element pele) throws Exception\n    {\n        NodeList anodes = pele.getElementsByTagName(\"group\");\n        if (anodes.getLength() != 0)\n        {\n            ci.groups = new IEntityGroup[anodes.getLength()];\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                Element anode = (Element) anodes.item(j);\n                String groupStr = XML.getElementText(anode).trim();\n                // need to look up corresponding group id\n                // ie: Everyone = local.0\n                //     Developers = local.4\n                IEntityGroup group = getGroup(groupStr, IPerson.class);\n\n                if (group != null)\n                    ci.groups[j] = group;\n                else\n                    throw new Exception(\n                        \"Invalid entry '\" + groupStr + \"' for group.\");\n            }\n        }\n    }","commit_id":"6ae786f6f3ce9257056ae274628474ec0cbda357","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Translate channel category names into category ids.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the category elements.\n     * @throws Exception\n     */\n    private void getCategories(ChannelInfo ci, Element pele) throws Exception\n    {\n        NodeList anodes = pele.getElementsByTagName(\"category\");\n        if (anodes.getLength() != 0)\n        {\n            ci.categories = new ChannelCategory[anodes.getLength()];\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                Element anode = (Element) anodes.item(j);\n                String catString = XML.getElementText(anode);\n                // need to look up corresponding category id\n                // ie: Applications = local.50\n                //     Entertainment = local.51\n                IEntityGroup cat = getGroup(catString, ChannelDefinition.class);\n\n                if (cat != null)\n                    ci.categories[j] = crs.getChannelCategory(cat.getKey());\n                else\n                    throw new Exception(\n                        \"Invalid entry '\" + catString + \"' for category.\");\n            }\n        }\n    }","id":24046,"modified_method":"/**\n     * Translate channel category names into category ids.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the category elements.\n     * @throws Exception\n     */\n    private void getCategories(ChannelInfo ci, Element pele) throws Exception\n    {\n        NodeList anodes = pele.getElementsByTagName(\"category\");\n        if (anodes.getLength() != 0)\n        {\n            ci.categories = new ChannelCategory[anodes.getLength()];\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                Element anode = (Element) anodes.item(j);\n                String catString = XML.getElementText(anode).trim();\n                // need to look up corresponding category id\n                // ie: Applications = local.50\n                //     Entertainment = local.51\n                IEntityGroup cat = getGroup(catString, ChannelDefinition.class);\n\n                if (cat != null)\n                    ci.categories[j] = crs.getChannelCategory(cat.getKey());\n                else\n                    throw new Exception(\n                        \"Invalid entry '\" + catString + \"' for category.\");\n            }\n        }\n    }","commit_id":"6ae786f6f3ce9257056ae274628474ec0cbda357","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Translate access user ids into the user entity objects.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the user elements.\n     * @throws Exception\n     */\n    private void getUsers(ChannelInfo ci, Element pele) throws Exception\n    {\n        NodeList anodes = pele.getElementsByTagName(\"user\");\n        if (anodes.getLength() != 0)\n        {\n            ci.users = new IEntity[anodes.getLength()];\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                Element anode = (Element) anodes.item(j);\n                String userStr = XML.getElementText(anode);\n                // need to look up corresponding user\n                IEntity user = GroupService.getEntity(userStr, IPerson.class);\n\n                if (user != null)\n                    ci.users[j] = user;\n                else\n                    throw new Exception(\n                        \"Invalid entry '\" + userStr + \"' for user.\");\n            }\n        }\n    }","id":24047,"modified_method":"/**\n     * Translate access user ids into the user entity objects.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the user elements.\n     * @throws Exception\n     */\n    private void getUsers(ChannelInfo ci, Element pele) throws Exception\n    {\n        NodeList anodes = pele.getElementsByTagName(\"user\");\n        if (anodes.getLength() != 0)\n        {\n            ci.users = new IEntity[anodes.getLength()];\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                Element anode = (Element) anodes.item(j);\n                String userStr = XML.getElementText(anode).trim();\n                // need to look up corresponding user\n                IEntity user = GroupService.getEntity(userStr, IPerson.class);\n\n                if (user != null)\n                    ci.users[j] = user;\n                else\n                    throw new Exception(\n                        \"Invalid entry '\" + userStr + \"' for user.\");\n            }\n        }\n    }","commit_id":"6ae786f6f3ce9257056ae274628474ec0cbda357","url":"https://github.com/Jasig/uPortal"},{"original_method":"/**\n     * Load the declared parameters.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the parameter elements.\n     */\n    private void getParameters(ChannelInfo ci, Element pele)\n    {\n        NodeList anodes = pele.getElementsByTagName(\"parameter\");\n        if (anodes.getLength() > 0)\n        {\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                String pname = null;\n                String pvalue = null;\n                String povrd = null;\n                String pdescr = null;\n                Element anode = (Element) anodes.item(j);\n                NodeList namenodes = anode.getElementsByTagName(\"name\");\n                if (namenodes.getLength() > 0)\n                {\n                    pname = XML.getElementText((Element) namenodes.item(0));\n                }\n                NodeList valuenodes = anode.getElementsByTagName(\"value\");\n                if (valuenodes.getLength() > 0)\n                {\n                    pvalue = XML.getElementText((Element) valuenodes.item(0));\n                }\n                NodeList descnodes = anode.getElementsByTagName(\"description\");\n                if (descnodes.getLength() > 0)\n                {\n                    pdescr = XML.getElementText((Element) descnodes.item(0));\n                }\n                NodeList ovrdnodes = anode.getElementsByTagName(\"ovrd\");\n                if (ovrdnodes.getLength() > 0)\n                {\n                    povrd = XML.getElementText((Element) ovrdnodes.item(0));\n                }\n                ChannelParameter chanParam =\n                    new ChannelParameter(pname, pvalue, RDBMServices.dbFlag(povrd));\n                chanParam.setDescription(pdescr);\n                ci.chanDef.addParameter(chanParam);\n            }\n        }\n    }","id":24048,"modified_method":"/**\n     * Load the declared parameters.\n     *\n     * @param ci The ChannelInfo object being populated.\n     * @param pele The Element containing the parameter elements.\n     */\n    private void getParameters(ChannelInfo ci, Element pele)\n    {\n        NodeList anodes = pele.getElementsByTagName(\"parameter\");\n        if (anodes.getLength() > 0)\n        {\n            for (int j = 0; j < anodes.getLength(); j++)\n            {\n                String pname = null;\n                String pvalue = null;\n                String povrd = null;\n                String pdescr = null;\n                Element anode = (Element) anodes.item(j);\n                NodeList namenodes = anode.getElementsByTagName(\"name\");\n                if (namenodes.getLength() > 0)\n                {\n                    pname = XML.getElementText((Element) namenodes.item(0));\n                }\n                NodeList valuenodes = anode.getElementsByTagName(\"value\");\n                if (valuenodes.getLength() > 0)\n                {\n                    pvalue = XML.getElementText((Element) valuenodes.item(0)).trim();\n                }\n                NodeList descnodes = anode.getElementsByTagName(\"description\");\n                if (descnodes.getLength() > 0)\n                {\n                    pdescr = XML.getElementText((Element) descnodes.item(0)).trim();\n                }\n                NodeList ovrdnodes = anode.getElementsByTagName(\"ovrd\");\n                if (ovrdnodes.getLength() > 0)\n                {\n                    povrd = XML.getElementText((Element) ovrdnodes.item(0));\n                }\n                ChannelParameter chanParam =\n                    new ChannelParameter(pname, pvalue, RDBMServices.dbFlag(povrd));\n                chanParam.setDescription(pdescr);\n                ci.chanDef.addParameter(chanParam);\n            }\n        }\n    }","commit_id":"e00496d65522cfe7e140c6f7fe5e0004b2f90fd6","url":"https://github.com/Jasig/uPortal"},{"original_method":"@Override\n    public synchronized void close() {\n        try {\n            super.close();\n\n            journalFile.close();\n\n            for (TarFile file : bulkFiles) {\n                file.close();\n            }\n            bulkFiles.clear();\n            for (TarFile file : dataFiles) {\n                file.close();\n            }\n            dataFiles.clear();\n\n            System.gc(); // for any memory-mappings that are no longer used\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","id":24049,"modified_method":"@Override\n    public synchronized void close() {\n        try {\n            super.close();\n\n            alive = false;\n            synchronized (flushThread) {\n                flushThread.notify();\n            }\n            flushThread.join();\n            flush();\n\n            journalFile.close();\n\n            for (TarFile file : bulkFiles) {\n                file.close();\n            }\n            bulkFiles.clear();\n            for (TarFile file : dataFiles) {\n                file.close();\n            }\n            dataFiles.clear();\n\n            System.gc(); // for any memory-mappings that are no longer used\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public FileStore(File directory, NodeState initial, int maxFileSizeMB,\n            int cacheSizeMB, boolean memoryMapping) throws IOException {\n        super(cacheSizeMB);\n        checkNotNull(directory).mkdirs();\n        this.directory = directory;\n        this.maxFileSize = maxFileSizeMB * MB;\n        this.memoryMapping = memoryMapping;\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"bulk\", i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                bulkFiles.add(new TarFile(file, maxFileSizeMB, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"data\", i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                dataFiles.add(new TarFile(file, maxFileSizeMB, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        journalFile = new RandomAccessFile(\n                new File(directory, JOURNAL_FILE_NAME), \"rw\");\n        String line = journalFile.readLine();\n        while (line != null) {\n            int space = line.indexOf(' ');\n            if (space != -1) {\n                String name = line.substring(space + 1);\n                RecordId id = RecordId.fromString(line.substring(0, space));\n                journals.put(name, id);\n            }\n            line = journalFile.readLine();\n        }\n\n        if (!journals.containsKey(\"root\")) {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", initial);\n            SegmentNodeState root =\n                    getWriter().writeNode(builder.getNodeState());\n            journals.put(\"root\", root.getRecordId());\n            journalFile.writeBytes(root.getRecordId() + \" root\\n\");\n        }\n    }","id":24050,"modified_method":"public FileStore(File directory, NodeState initial, int maxFileSizeMB,\n            int cacheSizeMB, boolean memoryMapping) throws IOException {\n        super(cacheSizeMB);\n        checkNotNull(directory).mkdirs();\n        this.directory = directory;\n        this.maxFileSize = maxFileSizeMB * MB;\n        this.memoryMapping = memoryMapping;\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"bulk\", i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                bulkFiles.add(new TarFile(file, maxFileSizeMB, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        for (int i = 0; true; i++) {\n            String name = String.format(FILE_NAME_FORMAT, \"data\", i);\n            File file = new File(directory, name);\n            if (file.isFile()) {\n                dataFiles.add(new TarFile(file, maxFileSizeMB, memoryMapping));\n            } else {\n                break;\n            }\n        }\n\n        head = null;\n        journalFile = new RandomAccessFile(\n                new File(directory, JOURNAL_FILE_NAME), \"rw\");\n        String line = journalFile.readLine();\n        while (line != null) {\n            int space = line.indexOf(' ');\n            if (space != -1) {\n                head = RecordId.fromString(line.substring(0, space));\n            }\n            line = journalFile.readLine();\n        }\n\n        if (head == null) {\n            NodeBuilder builder = EMPTY_NODE.builder();\n            builder.setChildNode(\"root\", initial);\n            SegmentNodeState root =\n                    getWriter().writeNode(builder.getNodeState());\n            head = root.getRecordId();\n            updated = true;\n        }\n\n        this.flushThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    synchronized (flushThread) {\n                        flushThread.wait(1000);\n                        while (alive) {\n                            flush();\n                            flushThread.wait(5000);\n                        }\n                    }\n                } catch (InterruptedException e) {\n                    // stop flushing\n                }\n            }\n        });\n        flushThread.setName(\"TarMK flush thread \" + directory);\n        flushThread.setDaemon(true);\n        flushThread.setPriority(Thread.MIN_PRIORITY);\n        flushThread.start();\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Journal getJournal(String name) {\n        synchronized (journals) {\n            if (journals.containsKey(name)) {\n                journals.put(name, journals.get(\"root\"));\n            }\n        }\n        return new FileJournal(this, name);\n    }","id":24051,"modified_method":"@Override\n    public Journal getJournal(String name) {\n        checkArgument(\"root\".equals(name)); // only root supported for now\n        return new Journal() {\n            @Override\n            public RecordId getHead() {\n                return head;\n            }\n            @Override\n            public boolean setHead(RecordId base, RecordId head) {\n                synchronized (FileStore.this) {\n                    if (base.equals(FileStore.this.head)) {\n                        FileStore.this.head = head;\n                        updated = true;\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            }\n            @Override\n            public void merge() {\n                throw new UnsupportedOperationException();\n            }\n        };\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void write(int position, byte[] b, int offset, int length)\n            throws IOException {\n        ByteBuffer entry = buffer.duplicate();\n        entry.position(position);\n        entry.put(b, offset, length);\n    }","id":24052,"modified_method":"@Override\n    public synchronized void write(\n            int position, byte[] b, int offset, int length)\n            throws IOException {\n        ByteBuffer entry = buffer.duplicate();\n        entry.position(position);\n        entry.put(b, offset, length);\n        updated = true;\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"MappedAccess(File file, int length) throws IOException {\n        RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n        try {\n            long l = f.length();\n            if (l == 0) { // it's a new file\n                l = length;\n            }\n            buffer = f.getChannel().map(READ_WRITE, 0, l);\n        } finally {\n            f.close();\n        }\n    }","id":24053,"modified_method":"MappedAccess(File file, int length) throws IOException {\n        RandomAccessFile f = new RandomAccessFile(file, \"rw\");\n        try {\n            long l = f.length();\n            if (l == 0) { // it's a new file\n                l = length;\n                updated = true;\n            }\n            buffer = f.getChannel().map(READ_WRITE, 0, l);\n        } finally {\n            f.close();\n        }\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void flush() {\n        buffer.force();\n    }","id":24054,"modified_method":"@Override\n    public synchronized void flush() {\n        if (updated) {\n            buffer.force();\n            updated = false;\n        }\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Segment(SegmentStore store, UUID uuid, ByteBuffer data) {\r\n        this.store = checkNotNull(store);\r\n        this.uuid = checkNotNull(uuid);\r\n        this.data = checkNotNull(data);\r\n\r\n        int refpos = data.position();\r\n        if (isDataSegmentId(uuid)) {\r\n            int roots = data.getShort(refpos + 1) & 0xffff;\r\n            refpos += align(3 + roots * 3);\r\n        }\r\n        this.refposition = refpos;\r\n    }","id":24055,"modified_method":"public Segment(SegmentStore store, UUID uuid, ByteBuffer data) {\r\n        this.store = checkNotNull(store);\r\n        this.uuid = checkNotNull(uuid);\r\n        this.data = checkNotNull(data);\r\n\r\n        int refpos = data.position();\r\n        if (isDataSegmentId(uuid)) {\r\n            int refs = data.get(refpos) & 0xff;\r\n            int roots = data.getShort(refpos + 1) & 0xffff;\r\n            refpos += align(3 + roots * 3);\r\n            refids = new UUID[refs];\r\n            for (int i = 0; i < refs; i++) {\r\n                refids[i] = new UUID(\r\n                        data.getLong(refpos + i * 16),\r\n                        data.getLong(refpos + i * 16 + 8));\r\n            }\r\n        } else {\r\n            refids = NO_REFS;\r\n        }\r\n\r\n        this.current = false;\r\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public List<UUID> getReferencedIds() {\r\n        if (isDataSegmentId(uuid)) {\r\n            int refcount = data.get(data.position()) & 0xff;\r\n            List<UUID> refs = newArrayListWithCapacity(refcount);\r\n            for (int i = 0; i < refcount; i++) {\r\n                refs.add(new UUID(\r\n                        data.getLong(refposition + i * 16),\r\n                        data.getLong(refposition + i * 16 + 8)));\r\n            }\r\n            return refs;\r\n        } else {\r\n            return emptyList();\r\n        }\r\n    }","id":24056,"modified_method":"public List<UUID> getReferencedIds() {\r\n        return Arrays.asList(refids);\r\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\r\n    public String toString() {\r\n        StringWriter string = new StringWriter();\r\n        PrintWriter writer = new PrintWriter(string);\r\n\r\n        int pos = refposition;\r\n        int refcount = data.get(data.position()) & 0xff;\r\n        int rootcount = data.getShort(data.position() + 1) &0xffff;\r\n        int length =\r\n                data.capacity() - (align(3 + rootcount * 3) + refcount * 16);\r\n\r\n        writer.format(\r\n                \"Segment %s (%d bytes, %d ref%s, %d root%s)%n\",\r\n                uuid, length,\r\n                refcount, (refcount != 1 ? \"s\" : \"\"),\r\n                rootcount, (rootcount != 1 ? \"s\" : \"\"));\r\n        writer.println(\"--------------------------------------------------------------------------\");\r\n        if (refcount > 0) {\r\n            for (int i = 0; i < refcount; i++) {\r\n                UUID id = new UUID(data.getLong(pos), data.getLong(pos + 8));\r\n                writer.format(\"reference %02x: %s%n\", i, id);\r\n                pos += 16;\r\n            }\r\n            writer.println(\"--------------------------------------------------------------------------\");\r\n        }\r\n        pos = data.limit() - ((length + 15) & ~15);\r\n        while (pos < data.limit()) {\r\n            writer.format(\"%04x: \", (MAX_SEGMENT_SIZE - data.limit() + pos) >> RECORD_ALIGN_BITS);\r\n            for (int i = 0; i < 16; i++) {\r\n                if (i > 0 && i % 4 == 0) {\r\n                    writer.append(' ');\r\n                }\r\n                if (pos + i >= data.position()) {\r\n                    byte b = data.get(pos + i);\r\n                    writer.format(\"%02x \", b & 0xff);\r\n                } else {\r\n                    writer.append(\"   \");\r\n                }\r\n            }\r\n            writer.append(' ');\r\n            for (int i = 0; i < 16; i++) {\r\n                if (pos + i >= data.position()) {\r\n                    byte b = data.get(pos + i);\r\n                    if (b >= ' ' && b < 127) {\r\n                        writer.append((char) b);\r\n                    } else {\r\n                        writer.append('.');\r\n                    }\r\n                } else {\r\n                    writer.append(' ');\r\n                }\r\n            }\r\n            writer.println();\r\n            pos += 16;\r\n        }\r\n        writer.println(\"--------------------------------------------------------------------------\");\r\n\r\n        writer.close();\r\n        return string.toString();\r\n    }","id":24057,"modified_method":"@Override\r\n    public String toString() {\r\n        StringWriter string = new StringWriter();\r\n        PrintWriter writer = new PrintWriter(string);\r\n\r\n        int rootcount = 0;\r\n        int length = data.remaining();\r\n        if (!current) {\r\n            rootcount = data.getShort(data.position() + 1) &0xffff;\r\n            length -= (align(3 + rootcount * 3) + refids.length * 16);\r\n        }\r\n\r\n        writer.format(\r\n                \"Segment %s (%d bytes, %d ref%s, %d root%s)%n\",\r\n                uuid, length,\r\n                refids.length, (refids.length != 1 ? \"s\" : \"\"),\r\n                rootcount, (rootcount != 1 ? \"s\" : \"\"));\r\n        writer.println(\"--------------------------------------------------------------------------\");\r\n        if (refids.length > 0) {\r\n            for (int i = 0; i < refids.length; i++) {\r\n                writer.format(\"reference %02x: %s%n\", i, refids[i]);\r\n            }\r\n            writer.println(\"--------------------------------------------------------------------------\");\r\n        }\r\n        int pos = data.limit() - ((length + 15) & ~15);\r\n        while (pos < data.limit()) {\r\n            writer.format(\"%04x: \", (MAX_SEGMENT_SIZE - data.limit() + pos) >> RECORD_ALIGN_BITS);\r\n            for (int i = 0; i < 16; i++) {\r\n                if (i > 0 && i % 4 == 0) {\r\n                    writer.append(' ');\r\n                }\r\n                if (pos + i >= data.position()) {\r\n                    byte b = data.get(pos + i);\r\n                    writer.format(\"%02x \", b & 0xff);\r\n                } else {\r\n                    writer.append(\"   \");\r\n                }\r\n            }\r\n            writer.append(' ');\r\n            for (int i = 0; i < 16; i++) {\r\n                if (pos + i >= data.position()) {\r\n                    byte b = data.get(pos + i);\r\n                    if (b >= ' ' && b < 127) {\r\n                        writer.append((char) b);\r\n                    } else {\r\n                        writer.append('.');\r\n                    }\r\n                } else {\r\n                    writer.append(' ');\r\n                }\r\n            }\r\n            writer.println();\r\n            pos += 16;\r\n        }\r\n        writer.println(\"--------------------------------------------------------------------------\");\r\n\r\n        writer.close();\r\n        return string.toString();\r\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private RecordId internalReadRecordId(int pos) {\r\n        UUID refid;\r\n        int refpos = data.get(pos) & 0xff;\r\n        if (refpos != 0xff) {\r\n            refpos = refposition + refpos * 16;\r\n            refid = new UUID(data.getLong(refpos), data.getLong(refpos + 8));\r\n        } else {\r\n            refid = uuid;\r\n        }\r\n\r\n        int offset =\r\n                (((data.get(pos + 1) & 0xff) << 8) | (data.get(pos + 2) & 0xff))\r\n                << RECORD_ALIGN_BITS;\r\n\r\n        return new RecordId(refid, offset);\r\n    }","id":24058,"modified_method":"private RecordId internalReadRecordId(int pos) {\r\n        UUID refid;\r\n        int refpos = data.get(pos) & 0xff;\r\n        if (refpos != 0xff) {\r\n            refid = refids[refpos];\r\n        } else {\r\n            refid = uuid;\r\n        }\r\n\r\n        int offset =\r\n                (((data.get(pos + 1) & 0xff) << 8) | (data.get(pos + 2) & 0xff))\r\n                << RECORD_ALIGN_BITS;\r\n\r\n        return new RecordId(refid, offset);\r\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testFlatNodeUpdate() {\n        SegmentStore store = new MemoryStore();\n        SegmentWriter writer = store.getWriter();\n\n        NodeBuilder builder = EMPTY_NODE.builder();\n        for (int i = 0; i < 1000; i++) {\n            builder.child(\"child\" + i);\n        }\n\n        SegmentNodeState state = writer.writeNode(builder.getNodeState());\n        Segment segment = store.readSegment(state.getRecordId().getSegmentId());\n        assertEquals(26752, Segment.WEIGHER.weigh(null, segment));\n\n        writer.flush(); // force flushing of the previous segment\n\n        builder = state.builder();\n        builder.child(\"child1000\");\n        state = writer.writeNode(builder.getNodeState());\n        segment = store.readSegment(state.getRecordId().getSegmentId());\n        assertEquals(136, Segment.WEIGHER.weigh(null, segment));\n    }","id":24059,"modified_method":"@Test\n    public void testFlatNodeUpdate() {\n        SegmentStore store = new MemoryStore();\n        SegmentWriter writer = store.getWriter();\n\n        NodeBuilder builder = EMPTY_NODE.builder();\n        for (int i = 0; i < 1000; i++) {\n            builder.child(\"child\" + i);\n        }\n\n        SegmentNodeState state = writer.writeNode(builder.getNodeState());\n        writer.flush();\n        Segment segment = store.readSegment(state.getRecordId().getSegmentId());\n        assertEquals(26752, Segment.WEIGHER.weigh(null, segment));\n\n        writer.flush(); // force flushing of the previous segment\n\n        builder = state.builder();\n        builder.child(\"child1000\");\n        state = writer.writeNode(builder.getNodeState());\n        writer.flush();\n        segment = store.readSegment(state.getRecordId().getSegmentId());\n        assertEquals(136, Segment.WEIGHER.weigh(null, segment));\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private int getSize(NodeBuilder builder) {\n        SegmentStore store = new MemoryStore();\n        SegmentWriter writer = store.getWriter();\n        RecordId id = writer.writeNode(builder.getNodeState()).getRecordId();\n        Segment segment = store.readSegment(id.getSegmentId());\n        return Segment.WEIGHER.weigh(null, segment);\n    }","id":24060,"modified_method":"private int getSize(NodeBuilder builder) {\n        SegmentStore store = new MemoryStore();\n        SegmentWriter writer = store.getWriter();\n        RecordId id = writer.writeNode(builder.getNodeState()).getRecordId();\n        writer.flush();\n        Segment segment = store.readSegment(id.getSegmentId());\n        return Segment.WEIGHER.weigh(null, segment);\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private int getAmortizedSize(NodeBuilder builder) {\n        SegmentStore store = new MemoryStore();\n        SegmentWriter writer = store.getWriter();\n        NodeState state = builder.getNodeState();\n        RecordId id = writer.writeNode(state).getRecordId();\n        Segment segment = store.readSegment(id.getSegmentId());\n        int base = Segment.WEIGHER.weigh(null, segment);\n\n        store = new MemoryStore(); // avoid cross-segment caching\n        writer = store.getWriter();\n        writer.writeNode(state);\n        id = writer.writeNode(state).getRecordId();\n        segment = store.readSegment(id.getSegmentId());\n        return Segment.WEIGHER.weigh(null, segment) - base - 4;\n    }","id":24061,"modified_method":"private int getAmortizedSize(NodeBuilder builder) {\n        SegmentStore store = new MemoryStore();\n        SegmentWriter writer = store.getWriter();\n        NodeState state = builder.getNodeState();\n        RecordId id = writer.writeNode(state).getRecordId();\n        writer.flush();\n        Segment segment = store.readSegment(id.getSegmentId());\n        int base = Segment.WEIGHER.weigh(null, segment);\n\n        store = new MemoryStore(); // avoid cross-segment caching\n        writer = store.getWriter();\n        writer.writeNode(state);\n        id = writer.writeNode(state).getRecordId();\n        writer.flush();\n        segment = store.readSegment(id.getSegmentId());\n        return Segment.WEIGHER.weigh(null, segment) - base - 4;\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public synchronized void flush() {\n        if (length > 0) {\n            length += align(3 + roots.size() * 3) + refids.size() * 16;\n\n            ByteBuffer b = ByteBuffer.wrap(\n                    buffer, buffer.length - length, length);\n            writeSegmentHeader(b);\n\n            store.writeSegment(uuid, buffer, buffer.length - length, length);\n\n            uuid = newDataSegmentId();\n            refids.clear();\n            roots.clear();\n            length = 0;\n            position = buffer.length;\n            currentSegment = null;\n        }\n    }","id":24062,"modified_method":"public synchronized void flush() {\n        if (length > 0) {\n            length += align(3 + roots.size() * 3) + refids.size() * 16;\n\n            ByteBuffer b = ByteBuffer.wrap(\n                    buffer, buffer.length - length, length);\n            writeSegmentHeader(b);\n\n            store.writeSegment(uuid, buffer, buffer.length - length, length);\n\n            uuid = newDataSegmentId();\n            buffer = new byte[MAX_SEGMENT_SIZE];\n            refids.clear();\n            roots.clear();\n            length = 0;\n            position = buffer.length;\n            currentSegment = null;\n        }\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public synchronized Segment getCurrentSegment(UUID id) {\n        if (equal(id, uuid)) {\n            if (currentSegment == null) {\n                int header = align(3 + roots.size() * 3) + 16 * refids.size();\n                ByteBuffer b = ByteBuffer.allocate(header + length);\n                writeSegmentHeader(b);\n                b.put(buffer, buffer.length - length, length);\n                b.rewind();\n                currentSegment = new Segment(store, uuid, b);\n            }\n            return currentSegment;\n        } else {\n            return null;\n        }\n    }","id":24063,"modified_method":"public synchronized Segment getCurrentSegment(UUID id) {\n        if (equal(id, uuid)) {\n            if (currentSegment == null) {\n                ByteBuffer b = ByteBuffer.wrap(buffer);\n                b.position(buffer.length - length);\n                currentSegment = new Segment(\n                        store, uuid,\n                        refids.keySet().toArray(new UUID[refids.size()]),\n                        b);\n            }\n            return currentSegment;\n        } else {\n            return null;\n        }\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private RecordId prepare(\n            RecordType type, int size, Collection<RecordId> ids) {\n        checkArgument(size >= 0);\n        checkNotNull(ids);\n\n        Set<UUID> segmentIds = newHashSet();\n        for (RecordId id : ids) {\n            UUID segmentId = id.getSegmentId();\n            if (!equal(uuid, segmentId) && !refids.containsKey(segmentId)) {\n                segmentIds.add(segmentId);\n            }\n        }\n        int refCount = refids.size() + segmentIds.size();\n\n        Set<RecordId> rootIds = newHashSet(roots.keySet());\n        rootIds.removeAll(ids);\n        int rootCount = rootIds.size() + 1;\n\n        int recordSize = Segment.align(size + ids.size() * Segment.RECORD_ID_BYTES);\n        int headerSize = Segment.align(3 + rootCount * 3);\n        int segmentSize = headerSize + refCount * 16 + recordSize + length;\n        if (segmentSize > buffer.length - 1\n                || rootCount > 0xffff\n                || refCount >= Segment.SEGMENT_REFERENCE_LIMIT) {\n            flush();\n        }\n\n        length += recordSize;\n        position = buffer.length - length;\n        checkState(position >= 0);\n\n        currentSegment = null;\n\n        RecordId id = new RecordId(uuid, position);\n        roots.put(id, type);\n        return id;\n    }","id":24064,"modified_method":"private RecordId prepare(\n            RecordType type, int size, Collection<RecordId> ids) {\n        checkArgument(size >= 0);\n        checkNotNull(ids);\n\n        Set<UUID> segmentIds = newHashSet();\n        for (RecordId id : ids) {\n            UUID segmentId = id.getSegmentId();\n            if (!equal(uuid, segmentId) && !refids.containsKey(segmentId)) {\n                segmentIds.add(segmentId);\n            }\n        }\n        int refCount = refids.size() + segmentIds.size();\n        int rootCount = roots.size() + 1;\n\n        int recordSize = Segment.align(size + ids.size() * Segment.RECORD_ID_BYTES);\n        int headerSize = Segment.align(3 + rootCount * 3);\n        int segmentSize = headerSize + refCount * 16 + recordSize + length;\n        if (segmentSize > buffer.length - 1\n                || rootCount > 0xffff\n                || refCount >= Segment.SEGMENT_REFERENCE_LIMIT) {\n            flush();\n        }\n\n        length += recordSize;\n        position = buffer.length - length;\n        checkState(position >= 0);\n\n        currentSegment = null;\n\n        RecordId id = new RecordId(uuid, position);\n        roots.put(id, type);\n        return id;\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"void close() throws IOException {\n        access.flush();\n        access.close();\n    }","id":24065,"modified_method":"void close() throws IOException {\n        flush();\n        access.close();\n    }","commit_id":"ef9a408d460ff10b5e34d176bba78b7343f2057c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void compact() {\n        StringBuilder sb = new StringBuilder();\n\n        long s = System.currentTimeMillis();\n        store.compact();\n        try {\n            store.flush();\n        } catch (IOException e) {\n            sb.append(\"IOException \" + e.getMessage());\n            e.printStackTrace();\n        }\n        s = System.currentTimeMillis() - s;\n\n        sb.append(\"Compacted tar segments in \" + s + \" ms.\");\n        sb.append(newline);\n\n        sb.append(\"File Index\");\n        sb.append(newline);\n\n        List<String> files = new ArrayList<String>(store.getTarReaderIndex()\n                .keySet());\n        Collections.sort(files);\n\n        for (String path : files) {\n            sb.append(path);\n            sb.append(newline);\n        }\n        sb.append(\"----------\");\n        log.setText(sb.toString());\n    }","id":24066,"modified_method":"public void compact() {\n        sizeCache = new HashMap<RecordIdKey, Long[]>();\n        treeModel = null;\n\n        StringBuilder sb = new StringBuilder();\n\n        long s = System.currentTimeMillis();\n        store.compact();\n        try {\n            store.flush();\n        } catch (IOException e) {\n            sb.append(\"IOException \" + e.getMessage());\n            e.printStackTrace();\n        }\n        s = System.currentTimeMillis() - s;\n\n        sb.append(\"Compacted tar segments in \" + s + \" ms.\");\n        sb.append(newline);\n\n        sb.append(\"File Index\");\n        sb.append(newline);\n\n        List<String> files = new ArrayList<String>(store.getTarReaderIndex()\n                .keySet());\n        Collections.sort(files);\n\n        for (String path : files) {\n            sb.append(path);\n            sb.append(newline);\n        }\n        sb.append(\"----------\");\n        log.setText(sb.toString());\n\n        refreshModel();\n    }","commit_id":"8661ddc0bf55e2967eb054f928022fc9d36d4489","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NodeStoreTree(FileStore store, JTextArea log) {\n        super(new GridLayout(1, 0));\n        this.store = store;\n        this.log = log;\n\n        index = store.getTarReaderIndex();\n        sizeCache = new HashMap<RecordId, Long[]>();\n\n        DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(\n                new NamePathModel(\"/\", \"/\", store.getHead(), sizeCache), true);\n        treeModel = new DefaultTreeModel(rootNode);\n        addChildren(rootNode);\n\n        tree = new JTree(treeModel);\n        tree.getSelectionModel().setSelectionMode(\n                TreeSelectionModel.SINGLE_TREE_SELECTION);\n        tree.setShowsRootHandles(true);\n        tree.addTreeSelectionListener(this);\n        tree.setExpandsSelectedPaths(true);\n\n        JScrollPane scrollPane = new JScrollPane(tree);\n        add(scrollPane);\n    }","id":24067,"modified_method":"public NodeStoreTree(FileStore store, JTextArea log) {\n        super(new GridLayout(1, 0));\n        this.store = store;\n        this.log = log;\n\n        index = store.getTarReaderIndex();\n        sizeCache = new HashMap<RecordIdKey, Long[]>();\n\n        DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(\n                new NamePathModel(\"/\", \"/\", store.getHead(), sizeCache), true);\n        treeModel = new DefaultTreeModel(rootNode);\n        addChildren(rootNode);\n\n        tree = new JTree(treeModel);\n        tree.getSelectionModel().setSelectionMode(\n                TreeSelectionModel.SINGLE_TREE_SELECTION);\n        tree.setShowsRootHandles(true);\n        tree.addTreeSelectionListener(this);\n        tree.setExpandsSelectedPaths(true);\n\n        JScrollPane scrollPane = new JScrollPane(tree);\n        add(scrollPane);\n    }","commit_id":"8661ddc0bf55e2967eb054f928022fc9d36d4489","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public NamePathModel(String name, String path, NodeState state,\n                Map<RecordId, Long[]> sizeCache) {\n            this.name = name;\n            this.path = path;\n            this.state = state;\n            if (state instanceof SegmentNodeState) {\n                this.size = exploreSize((SegmentNodeState) state, sizeCache);\n            }\n        }","id":24068,"modified_method":"public NamePathModel(String name, String path, NodeState state,\n                Map<RecordIdKey, Long[]> sizeCache) {\n            this.name = name;\n            this.path = path;\n            this.state = state;\n            if (state instanceof SegmentNodeState) {\n                this.size = exploreSize((SegmentNodeState) state, sizeCache);\n            }\n        }","commit_id":"8661ddc0bf55e2967eb054f928022fc9d36d4489","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static Long[] exploreSize(SegmentNodeState ns,\n            Map<RecordId, Long[]> sizeCache) {\n        if (sizeCache.containsKey(ns.getRecordId())) {\n            return sizeCache.get(ns.getRecordId());\n        }\n        Long[] s = { 0l, 0l };\n\n        List<String> names = Lists.newArrayList(ns.getChildNodeNames());\n\n        if (names.contains(\"root\")) {\n            List<String> temp = Lists.newArrayList();\n            int poz = 0;\n            // push 'root' to the beginning\n            Iterator<String> iterator = names.iterator();\n            while (iterator.hasNext()) {\n                String n = iterator.next();\n                if (n.equals(\"root\")) {\n                    temp.add(poz, n);\n                    poz++;\n                } else {\n                    temp.add(n);\n                }\n            }\n            names = temp;\n        }\n\n        for (String n : names) {\n            SegmentNodeState k = (SegmentNodeState) ns.getChildNode(n);\n            if (sizeCache.containsKey(k.getRecordId())) {\n                // already been here, record size under 'link'\n                Long[] ks = sizeCache.get(k.getRecordId());\n                s[1] = s[1] + ks[0] + ks[1];\n            } else {\n                Long[] ks = exploreSize(k, sizeCache);\n                s[0] = s[0] + ks[0];\n                s[1] = s[1] + ks[1];\n            }\n        }\n        for (PropertyState ps : ns.getProperties()) {\n            for (int j = 0; j < ps.count(); j++) {\n                s[0] = s[0] + ps.size(j);\n            }\n        }\n        sizeCache.put(ns.getRecordId(), s);\n        return s;\n    }","id":24069,"modified_method":"private static Long[] exploreSize(SegmentNodeState ns,\n            Map<RecordIdKey, Long[]> sizeCache) {\n        RecordIdKey key = new RecordIdKey(ns.getRecordId());\n        if (sizeCache.containsKey(key)) {\n            return sizeCache.get(key);\n        }\n        Long[] s = { 0l, 0l };\n\n        List<String> names = Lists.newArrayList(ns.getChildNodeNames());\n\n        if (names.contains(\"root\")) {\n            List<String> temp = Lists.newArrayList();\n            int poz = 0;\n            // push 'root' to the beginning\n            Iterator<String> iterator = names.iterator();\n            while (iterator.hasNext()) {\n                String n = iterator.next();\n                if (n.equals(\"root\")) {\n                    temp.add(poz, n);\n                    poz++;\n                } else {\n                    temp.add(n);\n                }\n            }\n            names = temp;\n        }\n\n        for (String n : names) {\n            SegmentNodeState k = (SegmentNodeState) ns.getChildNode(n);\n            RecordIdKey ckey = new RecordIdKey(k.getRecordId());\n            if (sizeCache.containsKey(ckey)) {\n                // already been here, record size under 'link'\n                Long[] ks = sizeCache.get(ckey);\n                s[1] = s[1] + ks[0] + ks[1];\n            } else {\n                Long[] ks = exploreSize(k, sizeCache);\n                s[0] = s[0] + ks[0];\n                s[1] = s[1] + ks[1];\n            }\n        }\n        for (PropertyState ps : ns.getProperties()) {\n            for (int j = 0; j < ps.count(); j++) {\n                s[0] = s[0] + ps.size(j);\n            }\n        }\n        sizeCache.put(key, s);\n        return s;\n    }","commit_id":"8661ddc0bf55e2967eb054f928022fc9d36d4489","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public DDLFormViewRecordsDisplayContext(\n\t\tLiferayPortletRequest liferayPortletRequest,\n\t\tLiferayPortletResponse liferayPortletResponse,\n\t\tDDMStructure ddmStructure, DDLRecordSet recordSet) {\n\n\t\t_liferayPortletRequest = liferayPortletRequest;\n\t\t_liferayPortletResponse = liferayPortletResponse;\n\t\t_recordSet = recordSet;\n\t\t_ddmFormFields = new ArrayList<>();\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)_liferayPortletRequest.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tportletDisplay.setShowBackIcon(true);\n\t\tportletDisplay.setURLBack(\n\t\t\tParamUtil.getString(_liferayPortletRequest, \"redirect\"));\n\n\t\tcreateRecordSearchContainer(ddmStructure);\n\t}","id":24070,"modified_method":"public DDLFormViewRecordsDisplayContext(\n\t\t\tLiferayPortletRequest liferayPortletRequest,\n\t\t\tLiferayPortletResponse liferayPortletResponse,\n\t\t\tDDLRecordSet recordSet)\n\t\tthrows PortalException {\n\n\t\t_liferayPortletRequest = liferayPortletRequest;\n\t\t_liferayPortletResponse = liferayPortletResponse;\n\t\t_recordSet = recordSet;\n\t\t_ddmFormFields = new ArrayList<>();\n\n\t\tThemeDisplay themeDisplay =\n\t\t\t(ThemeDisplay)_liferayPortletRequest.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletDisplay portletDisplay = themeDisplay.getPortletDisplay();\n\n\t\tportletDisplay.setShowBackIcon(true);\n\t\tportletDisplay.setURLBack(\n\t\t\tParamUtil.getString(_liferayPortletRequest, \"redirect\"));\n\n\t\tcreateRecordSearchContainer(recordSet.getDDMStructure());\n\t}","commit_id":"2cd8f8e884bc31d315b0ce45f5242496a328bd29","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getColumnValue(int index, DDMFormValues ddmFormValues) {\n\t\tDDMFormField ddmFormField = _ddmFormFields.get(index);\n\n\t\tMap<String, List<DDMFormFieldValue>> ddmFormFieldValuesMap =\n\t\t\tddmFormValues.getDDMFormFieldValuesMap();\n\n\t\tDDMFormFieldValueRenderer ddmFormFieldValueRenderer =\n\t\t\tDDMFormFieldValueRendererRegistryUtil.getDDMFormFieldValueRenderer(\n\t\t\t\tddmFormField.getType());\n\n\t\treturn ddmFormFieldValueRenderer.render(\n\t\t\tddmFormFieldValuesMap.get(ddmFormField.getName()),\n\t\t\t_liferayPortletRequest.getLocale());\n\t}","id":24071,"modified_method":"public String getColumnValue(int index, DDMFormValues ddmFormValues) {\n\t\tDDMFormField ddmFormField = _ddmFormFields.get(index);\n\n\t\tMap<String, List<DDMFormFieldValue>> ddmFormFieldValuesMap =\n\t\t\tddmFormValues.getDDMFormFieldValuesMap();\n\n\t\tfinal DDMFormFieldValueRenderer ddmFieldValueRenderer =\n\t\t\tDDMFormFieldTypeServicesTrackerUtil.getDDMFormFieldValueRenderer(\n\t\t\t\tddmFormField.getType());\n\n\t\tList<String> renderedDDMFormFielValues = ListUtil.toList(\n\t\t\tddmFormFieldValuesMap.get(ddmFormField.getName()),\n\t\t\tnew Function<DDMFormFieldValue, String>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic String apply(DDMFormFieldValue ddmFormFieldValue) {\n\t\t\t\t\treturn ddmFieldValueRenderer.render(\n\t\t\t\t\t\tddmFormFieldValue, _liferayPortletRequest.getLocale());\n\t\t\t\t}\n\n\t\t\t});\n\n\t\treturn StringUtil.merge(\n\t\t\trenderedDDMFormFielValues, StringPool.COMMA_AND_SPACE);\n\t}","commit_id":"2cd8f8e884bc31d315b0ce45f5242496a328bd29","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void createRecordSearchContainer(DDMStructure ddmStructure) {\n\t\tList<String> headerNames = new ArrayList<>();\n\n\t\tList<DDMFormField> ddmFormfields = ddmStructure.getDDMFormFields(false);\n\n\t\tint totalColumns = _COLUMS_TO_SHOW_ON_LIST;\n\n\t\tif (ddmFormfields.size() < totalColumns) {\n\t\t\ttotalColumns = ddmFormfields.size();\n\t\t}\n\n\t\tfor (int i = 0; i < totalColumns; i++) {\n\t\t\tDDMFormField ddmFormField = ddmFormfields.get(i);\n\n\t\t\t_ddmFormFields.add(ddmFormField);\n\n\t\t\tLocalizedValue label = ddmFormField.getLabel();\n\n\t\t\theaderNames.add(\n\t\t\t\tlabel.getString(_liferayPortletRequest.getLocale()));\n\t\t}\n\n\t\tPortletURL currentURLObj = PortletURLUtil.getCurrent(\n\t\t\t_liferayPortletRequest, _liferayPortletResponse);\n\n\t\t_recordSearchContainer = new RecordSearch(\n\t\t\t_liferayPortletRequest, currentURLObj, headerNames);\n\n\t\tRowChecker rowChecker = new RowChecker(_liferayPortletResponse);\n\n\t\trowChecker.setCssClass(\"entry-selector\");\n\n\t\t_recordSearchContainer.setRowChecker(rowChecker);\n\n\t\tString orderByCol = ParamUtil.getString(\n\t\t\t_liferayPortletRequest, \"orderByCol\");\n\t\tString orderByType = ParamUtil.getString(\n\t\t\t_liferayPortletRequest, \"orderByType\");\n\n\t\tPortalPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t_liferayPortletRequest);\n\n\t\tif (Validator.isNull(orderByCol)) {\n\t\t\torderByCol = preferences.getValue(\n\t\t\t\tDDLFormPortletKeys.DYNAMIC_DATA_LISTS_FORM_ADMIN,\n\t\t\t\t\"view-entries-order-by-col\", \"modified-date\");\n\t\t\torderByType = preferences.getValue(\n\t\t\t\tDDLFormPortletKeys.DYNAMIC_DATA_LISTS_FORM_ADMIN,\n\t\t\t\t\"view-entries-order-by-type\", \"asc\");\n\t\t}\n\t\telse {\n\t\t\tpreferences.setValue(\n\t\t\t\tDDLFormPortletKeys.DYNAMIC_DATA_LISTS_FORM_ADMIN,\n\t\t\t\t\"view-entries-order-by-col\", orderByCol);\n\t\t\tpreferences.setValue(\n\t\t\t\tDDLFormPortletKeys.DYNAMIC_DATA_LISTS_FORM_ADMIN,\n\t\t\t\t\"view-entries-order-by-type\", orderByType);\n\t\t}\n\n\t\tOrderByComparator<DDLRecord> orderByComparator =\n\t\t\tDDLFormAdminPortletUtil.getRecordOrderByComparator(\n\t\t\t\torderByCol, orderByType);\n\n\t\t_recordSearchContainer.setOrderByCol(orderByCol);\n\t\t_recordSearchContainer.setOrderByComparator(orderByComparator);\n\t\t_recordSearchContainer.setOrderByType(orderByType);\n\n\t\tloadRecordSearchContainer();\n\t}","id":24072,"modified_method":"protected void createRecordSearchContainer(DDMStructure ddmStructure) {\n\t\tList<String> headerNames = new ArrayList<>();\n\n\t\tList<DDMFormField> ddmFormfields = ddmStructure.getDDMFormFields(false);\n\n\t\tint totalColumns = _MAX_COLUMNS_SIZE;\n\n\t\tif (ddmFormfields.size() < totalColumns) {\n\t\t\ttotalColumns = ddmFormfields.size();\n\t\t}\n\n\t\tfor (int i = 0; i < totalColumns; i++) {\n\t\t\tDDMFormField ddmFormField = ddmFormfields.get(i);\n\n\t\t\t_ddmFormFields.add(ddmFormField);\n\n\t\t\tLocalizedValue label = ddmFormField.getLabel();\n\n\t\t\theaderNames.add(\n\t\t\t\tlabel.getString(_liferayPortletRequest.getLocale()));\n\t\t}\n\n\t\tPortletURL currentURLObj = PortletURLUtil.getCurrent(\n\t\t\t_liferayPortletRequest, _liferayPortletResponse);\n\n\t\t_recordSearchContainer = new RecordSearch(\n\t\t\t_liferayPortletRequest, currentURLObj, headerNames);\n\n\t\tString orderByCol = ParamUtil.getString(\n\t\t\t_liferayPortletRequest, \"orderByCol\");\n\t\tString orderByType = ParamUtil.getString(\n\t\t\t_liferayPortletRequest, \"orderByType\");\n\n\t\tPortalPreferences preferences =\n\t\t\tPortletPreferencesFactoryUtil.getPortalPreferences(\n\t\t\t\t_liferayPortletRequest);\n\n\t\tif (Validator.isNull(orderByCol)) {\n\t\t\torderByCol = preferences.getValue(\n\t\t\t\tDDLFormPortletKeys.DYNAMIC_DATA_LISTS_FORM_ADMIN,\n\t\t\t\t\"view-entries-order-by-col\", \"modified-date\");\n\t\t\torderByType = preferences.getValue(\n\t\t\t\tDDLFormPortletKeys.DYNAMIC_DATA_LISTS_FORM_ADMIN,\n\t\t\t\t\"view-entries-order-by-type\", \"asc\");\n\t\t}\n\t\telse {\n\t\t\tpreferences.setValue(\n\t\t\t\tDDLFormPortletKeys.DYNAMIC_DATA_LISTS_FORM_ADMIN,\n\t\t\t\t\"view-entries-order-by-col\", orderByCol);\n\t\t\tpreferences.setValue(\n\t\t\t\tDDLFormPortletKeys.DYNAMIC_DATA_LISTS_FORM_ADMIN,\n\t\t\t\t\"view-entries-order-by-type\", orderByType);\n\t\t}\n\n\t\tOrderByComparator<DDLRecord> orderByComparator =\n\t\t\tDDLFormAdminPortletUtil.getRecordOrderByComparator(\n\t\t\t\torderByCol, orderByType);\n\n\t\t_recordSearchContainer.setOrderByCol(orderByCol);\n\t\t_recordSearchContainer.setOrderByComparator(orderByComparator);\n\t\t_recordSearchContainer.setOrderByType(orderByType);\n\n\t\tupdateSearchContainerResults();\n\t}","commit_id":"2cd8f8e884bc31d315b0ce45f5242496a328bd29","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int compare(DDLRecord record1, DDLRecord record2) {\n\t\tif (record1.getRecordId() > record2.getRecordId()) {\n\t\t\treturn 1;\n\t\t}\n\t\telse if(record1.getRecordId() < record2.getRecordId()) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn 0;\n\t}","id":24073,"modified_method":"@Override\n\tpublic int compare(DDLRecord record1, DDLRecord record2) {\n\t\tint value = Long.compare(record1.getRecordId(), record2.getRecordId());\n\n\t\tif (_ascending) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","commit_id":"2cd8f8e884bc31d315b0ce45f5242496a328bd29","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic DDMFormFieldValueRenderer getDDMFormFieldValueRenderer(String name) {\n\t\treturn _ddmFormFieldValueRendererServiceTrackerMap.getService(name);\n\t}","id":24074,"modified_method":"@Override\n\tpublic DDMFormFieldValueRenderer getDDMFormFieldValueRenderer(String name) {\n\t\tDDMFormFieldValueRenderer ddmFormFieldValueRenderer =\n\t\t\t_ddmFormFieldValueRendererServiceTrackerMap.getService(name);\n\n\t\tif (ddmFormFieldValueRenderer != null) {\n\t\t\treturn ddmFormFieldValueRenderer;\n\t\t}\n\n\t\treturn _defaultDDMFormFieldValueRenderer;\n\t}","commit_id":"2cd8f8e884bc31d315b0ce45f5242496a328bd29","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Indexable(type = IndexableType.DELETE)\n\t@Override\n\t@SystemEvent(\n\t\taction = SystemEventConstants.ACTION_SKIP,\n\t\ttype = SystemEventConstants.TYPE_DELETE\n\t)\n\tpublic DDLRecord deleteRecord(DDLRecord record) throws PortalException {\n\t\tDDLRecordSet recordSet = record.getRecordSet();\n\n\t\tString workflowAssetClassName = getWorkflowAssetClassName(recordSet);\n\n\t\t// Record\n\n\t\tddlRecordPersistence.remove(record);\n\n\t\t// Record Versions\n\n\t\tList<DDLRecordVersion> recordVersions =\n\t\t\tddlRecordVersionPersistence.findByRecordId(record.getRecordId());\n\n\t\tfor (DDLRecordVersion recordVersion : recordVersions) {\n\t\t\tddlRecordVersionPersistence.remove(recordVersion);\n\n\t\t\t// Dynamic data mapping storage\n\n\t\t\tStorageEngineUtil.deleteByClass(recordVersion.getDDMStorageId());\n\n\t\t\t// Workflow\n\n\t\t\tworkflowInstanceLinkLocalService.deleteWorkflowInstanceLinks(\n\t\t\t\trecord.getCompanyId(), record.getGroupId(),\n\t\t\t\tworkflowAssetClassName, recordVersion.getPrimaryKey());\n\t\t}\n\n\t\t// Asset\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tworkflowAssetClassName, record.getRecordId());\n\n\t\t// Ratings\n\n\t\tratingsStatsLocalService.deleteStats(\n\t\t\tworkflowAssetClassName, record.getRecordId());\n\n\t\treturn record;\n\t}","id":24075,"modified_method":"@Indexable(type = IndexableType.DELETE)\n\t@Override\n\t@SystemEvent(\n\t\taction = SystemEventConstants.ACTION_SKIP,\n\t\ttype = SystemEventConstants.TYPE_DELETE\n\t)\n\tpublic DDLRecord deleteRecord(DDLRecord record) throws PortalException {\n\n\t\t// Record\n\n\t\tddlRecordPersistence.remove(record);\n\n\t\t// Record Versions\n\n\t\tList<DDLRecordVersion> recordVersions =\n\t\t\tddlRecordVersionPersistence.findByRecordId(record.getRecordId());\n\n\t\tfor (DDLRecordVersion recordVersion : recordVersions) {\n\t\t\tddlRecordVersionPersistence.remove(recordVersion);\n\n\t\t\t// Dynamic data mapping storage\n\n\t\t\tStorageEngineUtil.deleteByClass(recordVersion.getDDMStorageId());\n\n\t\t\t// Workflow\n\n\t\t\tdeleteWorkflowInstanceLink(\n\t\t\t\trecord.getCompanyId(), record.getGroupId(),\n\t\t\t\trecordVersion.getPrimaryKey());\n\t\t}\n\n\t\t// Asset\n\n\t\tdeleteAssetEntry(record.getRecordId());\n\n\t\t// Ratings\n\n\t\tdeleteRatingsStats(record.getRecordId());\n\n\t\treturn record;\n\t}","commit_id":"51477e0e4e0174bb89120649237922a7990357fa","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n    @Ignore(\"OAK-3348\")  // FIXME OAK-3348\n    public void testMixedSegments() throws Exception {\n        FileStore store = new FileStore(directory, 2, false);\n        final SegmentNodeStore nodeStore = new SegmentNodeStore(store);\n        store.setCompactionStrategy(new CompactionStrategy(true, false, CLEAN_NONE, 0, (byte) 5) {\n            @Override\n            public boolean compacted(Callable<Boolean> setHead) throws Exception {\n                return nodeStore.locked(setHead);\n            }\n        });\n\n        NodeBuilder root = nodeStore.getRoot().builder();\n        createNodes(root.setChildNode(\"test\"), 10, 3);\n        nodeStore.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n        final Set<UUID> beforeSegments = new HashSet<UUID>();\n        collectSegments(store.getHead(), beforeSegments);\n\n        final AtomicReference<Boolean> run = new AtomicReference<Boolean>(true);\n        final List<Integer> failedCommits = newArrayList();\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                for (int k = 0; run.get(); k++) {\n                    try {\n                        NodeBuilder root = nodeStore.getRoot().builder();\n                        root.setChildNode(\"b\" + k);\n                        nodeStore.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n                        Thread.sleep(5);\n                    } catch (CommitFailedException e) {\n                        failedCommits.add(k);\n                    } catch (InterruptedException e) {\n                        Thread.interrupted();\n                        break;\n                    }\n                }\n            }\n        });\n        t.start();\n\n        store.compact();\n        run.set(false);\n        t.join();\n\n        assertTrue(failedCommits.isEmpty());\n\n        Set<UUID> afterSegments = new HashSet<UUID>();\n        collectSegments(store.getHead(), afterSegments);\n        try {\n            for (UUID u : beforeSegments) {\n                assertFalse(\"Mixed segments found: \" + u, afterSegments.contains(u));\n            }\n        } finally {\n            store.close();\n        }\n    }","id":24076,"modified_method":"/**\n     * Regression test for OAK-2192 testing for mixed segments. This test does not\n     * cover OAK-3348. I.e. it does not assert the segment graph is free of cross\n     * gc generation references.\n     */\n    @Test\n    public void testMixedSegments() throws Exception {\n        FileStore store = new FileStore(directory, 2, false);\n        final SegmentNodeStore nodeStore = new SegmentNodeStore(store);\n        final AtomicBoolean compactionSuccess = new AtomicBoolean(true);\n        CompactionStrategy strategy = new CompactionStrategy(true, false, CLEAN_NONE, 0, (byte) 5) {\n            @Override\n            public boolean compacted(Callable<Boolean> setHead) throws Exception {\n                compactionSuccess.set(nodeStore.locked(setHead, 1, MINUTES));\n                return compactionSuccess.get();\n            }\n        };\n        strategy.setForceAfterFail(true);\n        store.setCompactionStrategy(strategy);\n\n        NodeBuilder root = nodeStore.getRoot().builder();\n        createNodes(root.setChildNode(\"test\"), 10, 3);\n        nodeStore.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n\n        final Set<UUID> beforeSegments = new HashSet<UUID>();\n        collectSegments(store.getHead(), beforeSegments);\n\n        final AtomicReference<Boolean> run = new AtomicReference<Boolean>(true);\n        final List<String> failedCommits = newArrayList();\n        Thread[] threads = new Thread[10];\n        for (int k = 0; k < threads.length; k++) {\n            final int threadId = k;\n            threads[k] = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int j = 0; run.get(); j++) {\n                        String nodeName = \"b-\" + threadId + \",\" + j;\n                        try {\n                            NodeBuilder root = nodeStore.getRoot().builder();\n                            root.setChildNode(nodeName);\n                            nodeStore.merge(root, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n                            Thread.sleep(5);\n                        } catch (CommitFailedException e) {\n                            failedCommits.add(nodeName);\n                        } catch (InterruptedException e) {\n                            Thread.interrupted();\n                            break;\n                        }\n                    }\n                }\n            });\n            threads[k].start();\n        }\n        store.compact();\n        run.set(false);\n        for (Thread t : threads) {\n            t.join();\n        }\n        store.flush();\n\n        assumeTrue(\"Failed to acquire compaction lock\", compactionSuccess.get());\n        assertTrue(\"Failed commits: \" + failedCommits, failedCommits.isEmpty());\n\n        Set<UUID> afterSegments = new HashSet<UUID>();\n        collectSegments(store.getHead(), afterSegments);\n        try {\n            for (UUID u : beforeSegments) {\n                assertFalse(\"Mixed segments found: \" + u, afterSegments.contains(u));\n            }\n        } finally {\n            store.close();\n        }\n    }","commit_id":"a8e2ea879bdf7972aa7f7dccb0f1e4b9a2a557f1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static void collectSegments(SegmentNodeState s, Set<UUID> segmentIds) {\n        SegmentId sid = s.getRecordId().getSegmentId();\n        UUID id = new UUID(sid.getMostSignificantBits(),\n                sid.getLeastSignificantBits());\n        segmentIds.add(id);\n        for (ChildNodeEntry cne : s.getChildNodeEntries()) {\n            collectSegments((SegmentNodeState) cne.getNodeState(), segmentIds);\n        }\n        for (PropertyState propertyState : s.getProperties()) {\n            sid = ((SegmentPropertyState) propertyState).getRecordId().getSegmentId();\n            id = new UUID(sid.getMostSignificantBits(),\n                    sid.getLeastSignificantBits());\n            segmentIds.add(id);\n        }\n    }","id":24077,"modified_method":"private static void collectSegments(SegmentNodeState s, final Set<UUID> segmentIds) {\n        new SegmentParser() {\n            @Override\n            protected void onNode(RecordId parentId, RecordId nodeId) {\n                super.onNode(parentId, nodeId);\n                segmentIds.add(nodeId.asUUID());\n            }\n\n            @Override\n            protected void onTemplate(RecordId parentId, RecordId templateId) {\n                super.onTemplate(parentId, templateId);\n                segmentIds.add(templateId.asUUID());\n            }\n\n            @Override\n            protected void onMap(RecordId parentId, RecordId mapId, MapRecord map) {\n                super.onMap(parentId, mapId, map);\n                segmentIds.add(mapId.asUUID());\n            }\n\n            @Override\n            protected void onMapDiff(RecordId parentId, RecordId mapId, MapRecord map) {\n                super.onMapDiff(parentId, mapId, map);\n                segmentIds.add(mapId.asUUID());\n            }\n\n            @Override\n            protected void onMapLeaf(RecordId parentId, RecordId mapId, MapRecord map) {\n                super.onMapLeaf(parentId, mapId, map);\n                segmentIds.add(mapId.asUUID());\n            }\n\n            @Override\n            protected void onMapBranch(RecordId parentId, RecordId mapId, MapRecord map) {\n                super.onMapBranch(parentId, mapId, map);\n                segmentIds.add(mapId.asUUID());\n            }\n\n            @Override\n            protected void onProperty(RecordId parentId, RecordId propertyId, PropertyTemplate template) {\n                super.onProperty(parentId, propertyId, template);\n                segmentIds.add(propertyId.asUUID());\n            }\n\n            @Override\n            protected void onValue(RecordId parentId, RecordId valueId, Type<?> type) {\n                super.onValue(parentId, valueId, type);\n                segmentIds.add(valueId.asUUID());\n            }\n\n            @Override\n            protected void onBlob(RecordId parentId, RecordId blobId) {\n                super.onBlob(parentId, blobId);\n                segmentIds.add(blobId.asUUID());\n            }\n\n            @Override\n            protected void onString(RecordId parentId, RecordId stringId) {\n                super.onString(parentId, stringId);\n                segmentIds.add(stringId.asUUID());\n            }\n\n            @Override\n            protected void onList(RecordId parentId, RecordId listId, int count) {\n                super.onList(parentId, listId, count);\n                segmentIds.add(listId.asUUID());\n            }\n\n            @Override\n            protected void onListBucket(RecordId parentId, RecordId listId, int index, int count, int capacity) {\n                super.onListBucket(parentId, listId, index, count, capacity);\n                segmentIds.add(listId.asUUID());\n            }\n        }.parseNode(s.getRecordId());\n    }","commit_id":"a8e2ea879bdf7972aa7f7dccb0f1e4b9a2a557f1","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void handleAuthentication(HttpServletResponse resp, HttpExchange httpExchange, Authenticator auth) throws IOException\r\n    {\r\n        Result result = auth.authenticate(httpExchange);\r\n        if (result instanceof Authenticator.Failure)\r\n        {\r\n            int rc = ((Authenticator.Failure)result).getResponseCode();\r\n            resp.sendError(rc);\r\n        }\r\n        else if (result instanceof Authenticator.Retry)\r\n        {\r\n            int rc = ((Authenticator.Retry)result).getResponseCode();\r\n            resp.sendError(rc);\r\n        }\r\n        else if (result instanceof Authenticator.Success)\r\n        {\r\n            HttpPrincipal principal = ((Authenticator.Success)result).getPrincipal();\r\n            ((JettyExchange)httpExchange).setPrincipal(principal);\r\n            _httpHandler.handle(httpExchange);\r\n        }\r\n    }","id":24078,"modified_method":"private void handleAuthentication(HttpServletResponse resp, HttpExchange httpExchange, Authenticator auth) throws IOException\r\n    {\r\n        Result result = auth.authenticate(httpExchange);\r\n        if (result instanceof Authenticator.Failure)\r\n        {\r\n            int rc = ((Authenticator.Failure)result).getResponseCode();\r\n            for (Map.Entry<String,List<String>> header : httpExchange.getResponseHeaders().entrySet())\r\n            {\r\n                for (String value : header.getValue())\r\n                    resp.addHeader(header.getKey(),value);\r\n            }\r\n            resp.sendError(rc);\r\n        }\r\n        else if (result instanceof Authenticator.Retry)\r\n        {\r\n            int rc = ((Authenticator.Retry)result).getResponseCode();\r\n            for (Map.Entry<String,List<String>> header : httpExchange.getResponseHeaders().entrySet())\r\n            {\r\n                for (String value : header.getValue())\r\n                    resp.addHeader(header.getKey(),value);\r\n            }\r\n            resp.setStatus(rc);\r\n            resp.flushBuffer();\r\n        }\r\n        else if (result instanceof Authenticator.Success)\r\n        {\r\n            HttpPrincipal principal = ((Authenticator.Success)result).getPrincipal();\r\n            ((JettyExchange)httpExchange).setPrincipal(principal);\r\n            _httpHandler.handle(httpExchange);\r\n        }\r\n    }","commit_id":"f8cd2e9a0c8a62cb6ed2d9202560725385f16a97","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Sends status <code>401<\/code> (Unauthorized) with a\n     * <code>WWW-Authenticate<\/code> requesting standard HTTP header\n     * authentication with the <code>Basic<\/code> scheme and the configured\n     * realm name.\n     *\n     * @param response The response object to which to send the request\n     * @return <code>true<\/code> if the 401/UNAUTHORIZED method has successfully\n     *         been sent.\n     */\n    private boolean sendUnauthorized(HttpServletResponse response) {\n\n        if (response.isCommitted()) {\n\n            log.error(\"sendUnauthorized: Cannot send 401/UNAUTHORIZED; response is already committed\");\n\n        } else {\n\n            response.setHeader(HEADER_WWW_AUTHENTICATE,\n                AUTHENTICATION_SCHEME_BASIC + \" realm=\\\"\" + this.realm + \"\\\"\");\n\n            try {\n                response.sendError(HttpServletResponse.SC_UNAUTHORIZED);\n                response.flushBuffer();\n                return true;\n            } catch (IOException ioe) {\n                log.error(\"sendUnauthorized: Failed requesting authentication\",\n                    ioe);\n            }\n        }\n\n        return false;\n    }","id":24079,"modified_method":"/**\n     * Sends status <code>401<\/code> (Unauthorized) with a\n     * <code>WWW-Authenticate<\/code> requesting standard HTTP header\n     * authentication with the <code>Basic<\/code> scheme and the configured\n     * realm name.\n     *\n     * @param response The response object to which to send the request\n     * @return <code>true<\/code> if the 401/UNAUTHORIZED method has successfully\n     *         been sent.\n     */\n    private boolean sendUnauthorized(HttpServletResponse response) {\n\n        if (response.isCommitted()) {\n\n            log.error(\"sendUnauthorized: Cannot send 401/UNAUTHORIZED; response is already committed\");\n\n        } else {\n\n            response.resetBuffer();\n\n            // just set the status because this may be called as part of an\n            // error handler in which case sendError would result in an error\n            // handler loop and thus be ignored.\n            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            response.setHeader(HEADER_WWW_AUTHENTICATE,\n                AUTHENTICATION_SCHEME_BASIC + \" realm=\\\"\" + this.realm + \"\\\"\");\n\n            try {\n                response.flushBuffer();\n                return true;\n            } catch (IOException ioe) {\n                log.error(\"sendUnauthorized: Failed requesting authentication\",\n                    ioe);\n            }\n        }\n\n        return false;\n    }","commit_id":"84cd878e7fd523988e11235ce0e973257453de90","url":"https://github.com/apache/sling"},{"original_method":"private void service( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        // check whether we are not at .../{webManagerRoot}\n        final String pathInfo = request.getPathInfo();\n        if ( pathInfo == null || pathInfo.equals( \"/\" ) )\n        {\n            String path = request.getRequestURI();\n            if ( !path.endsWith( \"/\" ) )\n            {\n                path = path.concat( \"/\" );\n            }\n            path = path.concat( holder.getDefaultPluginLabel() );\n            response.sendRedirect( path );\n            return;\n        }\n\n        int slash = pathInfo.indexOf( \"/\", 1 );\n        if ( slash < 2 )\n        {\n            slash = pathInfo.length();\n        }\n\n        final Locale locale = getConfiguredLocale( request );\n        final String label = pathInfo.substring( 1, slash );\n        AbstractWebConsolePlugin plugin = holder.getPlugin( label );\n\n        if ( plugin == null )\n        {\n            if ( \"install\".equals( label ) )\n            {\n                plugin = holder.getPlugin( BundlesServlet.NAME );\n            }\n        }\n\n        if ( plugin != null )\n        {\n            final Map labelMap = holder.getLocalizedLabelMap( resourceBundleManager, locale );\n\n            // the official request attributes\n            request.setAttribute( WebConsoleConstants.ATTR_LABEL_MAP, labelMap );\n            request.setAttribute( WebConsoleConstants.ATTR_APP_ROOT, request.getContextPath() + request.getServletPath() );\n            request.setAttribute( WebConsoleConstants.ATTR_PLUGIN_ROOT, request.getContextPath() + request.getServletPath()\n                + '/' + label );\n\n            // deprecated request attributes\n            request.setAttribute( ATTR_LABEL_MAP_OLD, labelMap );\n            request.setAttribute( ATTR_APP_ROOT_OLD, request.getContextPath() + request.getServletPath() );\n\n            // wrap the response for localization and template variable replacement\n            request = wrapRequest( request, locale );\n            response = wrapResponse( request, response, plugin );\n\n            plugin.service( request, response );\n        }\n        else\n        {\n            response.sendError( HttpServletResponse.SC_NOT_FOUND );\n        }\n    }","id":24080,"modified_method":"private void service( HttpServletRequest request, HttpServletResponse response ) throws ServletException,\n        IOException\n    {\n        // check whether we are not at .../{webManagerRoot}\n        final String pathInfo = request.getPathInfo();\n        if ( pathInfo == null || pathInfo.equals( \"/\" ) )\n        {\n            String path = request.getRequestURI();\n            if ( !path.endsWith( \"/\" ) )\n            {\n                path = path.concat( \"/\" );\n            }\n            path = path.concat( holder.getDefaultPluginLabel() );\n            response.sendRedirect( path );\n            return;\n        }\n\n        int slash = pathInfo.indexOf( \"/\", 1 );\n        if ( slash < 2 )\n        {\n            slash = pathInfo.length();\n        }\n\n        final Locale locale = getConfiguredLocale( request );\n        final String label = pathInfo.substring( 1, slash );\n        AbstractWebConsolePlugin plugin = holder.getPlugin( label );\n\n        if ( plugin == null )\n        {\n            if ( \"install\".equals( label ) )\n            {\n                plugin = holder.getPlugin( BundlesServlet.NAME );\n            }\n        }\n\n        if ( plugin != null )\n        {\n            final Map labelMap = holder.getLocalizedLabelMap( resourceBundleManager, locale );\n\n            // the official request attributes\n            request.setAttribute( WebConsoleConstants.ATTR_LABEL_MAP, labelMap );\n            request.setAttribute( WebConsoleConstants.ATTR_APP_ROOT, request.getContextPath() + request.getServletPath() );\n            request.setAttribute( WebConsoleConstants.ATTR_PLUGIN_ROOT, request.getContextPath() + request.getServletPath()\n                + '/' + label );\n\n            // deprecated request attributes\n            request.setAttribute( ATTR_LABEL_MAP_OLD, labelMap );\n            request.setAttribute( ATTR_APP_ROOT_OLD, request.getContextPath() + request.getServletPath() );\n\n            // wrap the response for localization and template variable replacement\n            request = wrapRequest( request, locale );\n            response = wrapResponse( request, response, plugin );\n\n            plugin.service( request, response );\n        }\n        else\n        {\n            final String body404 = MessageFormat.format(\n                resourceBundleManager.getResourceBundle(bundleContext.getBundle(), locale).getString(\n                    \"404\"), new Object[] {\n                    request.getContextPath() + request.getServletPath() + '/' + BundlesServlet.NAME\n                });\n            response.setCharacterEncoding( \"utf-8\" );\n            response.setContentType( \"text/html\" );\n            response.setStatus( HttpServletResponse.SC_NOT_FOUND );\n            response.getWriter().println( body404 );\n        }\n    }","commit_id":"99c4c8ddad644cc1e7db4e2536e28749a3de6407","url":"https://github.com/apache/felix"},{"original_method":"public WorkerTask getTask() throws Exception{\n    final ImagingTask nextTask = this.getNext();\n    if(nextTask==null)\n      return null;\n    \n    WorkerTask newTask = null;\n    try{\n      if(nextTask instanceof VolumeImagingTask){\n        final VolumeImagingTask volumeTask = (VolumeImagingTask) nextTask;\n        String manifestLocation = null;\n        if(volumeTask.getDownloadManifestUrl().size() == 0){\n          try{\n            manifestLocation = DownloadManifestFactory.generateDownloadManifest(\n                new ImageManifestFile(volumeTask.getImportManifestUrl(),\n                    ImportImageManifest.INSTANCE ),\n                    null, volumeTask.getDisplayName(), 1);\n          }catch(final InvalidBaseManifestException ex){\n            ImagingTasks.setState(volumeTask, ImportTaskState.FAILED, \"Failed to generate download manifest\");\n            throw new Exception(\"Failed to generate download manifest\", ex);\n          }\n\n          ImagingTasks.addDownloadManifestUrl(volumeTask, volumeTask.getImportManifestUrl(), manifestLocation);\n        }else\n          manifestLocation = volumeTask.getDownloadManifestUrl().get(0).getDownloadManifestUrl();\n        newTask = new WorkerTask(volumeTask.getDisplayName(), WorkerTaskType.import_volume);\n        final VolumeTask vt = new VolumeTask();\n        final ImageManifest im = new ImageManifest();\n        im.setManifestUrl(manifestLocation);\n        im.setFormat(volumeTask.getFormat());\n        vt.setImageManifestSet(Lists.newArrayList(im));\n        vt.setVolumeId(volumeTask.getVolumeId());\n        newTask.setVoumeTask(vt);\n      }else if (nextTask instanceof InstanceStoreImagingTask){\n        final InstanceStoreImagingTask isTask = (InstanceStoreImagingTask) nextTask;\n        newTask = new WorkerTask(isTask.getDisplayName(), WorkerTaskType.convert_image);\n        \n        final List<ImageManifest> manifests = Lists.newArrayList();\n        for(final ImportInstanceVolumeDetail volume : isTask.getVolumes()){\n          final String manifestUrl = volume.getImage().getImportManifestUrl();\n          final String format = volume.getImage().getFormat();\n          final ImageManifest im = new ImageManifest();\n          im.setManifestUrl(manifestUrl);\n          im.setFormat(format);\n          manifests.add(im);\n        }\n        final InstanceStoreTask ist = new InstanceStoreTask();\n        ist.setImageManifestSet((ArrayList<ImageManifest>) manifests);\n        ist.setBucket(isTask.getDestinationBucket());\n        ist.setPrefix(isTask.getDestinationPrefix());\n        newTask.setInstanceStoreTask(ist);\n      }else if (nextTask instanceof InstanceImagingTask){\n        final InstanceImagingTask instanceTask = (InstanceImagingTask) nextTask;\n        for(final ImportInstanceVolumeDetail volume : instanceTask.getVolumes()){\n          final String importManifestUrl = volume.getImage().getImportManifestUrl();\n          if(! instanceTask.hasDownloadManifestUrl(importManifestUrl)){\n            // meaning that this task has not been fully processed by worker\n            String manifestLocation = null;\n            manifestLocation = instanceTask.getDownloadManifestUrl(importManifestUrl);\n            if(manifestLocation == null){\n              try{\n                manifestLocation = DownloadManifestFactory.generateDownloadManifest(\n                    new ImageManifestFile(importManifestUrl,\n                        ImportImageManifest.INSTANCE ),\n                        null, nextTask.getDisplayName(), 1);\n                ImagingTasks.addDownloadManifestUrl(instanceTask, importManifestUrl, manifestLocation);\n              }catch(final InvalidBaseManifestException ex){\n                ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to generate download manifest\");\n                throw new Exception(\"Failed to generate download manifest\", ex);\n              }       \n            }\n            newTask = new WorkerTask(instanceTask.getDisplayName(), WorkerTaskType.import_volume);\n            final VolumeTask vt = new VolumeTask();\n            final ImageManifest im = new ImageManifest();\n            im.setManifestUrl(manifestLocation);\n            im.setFormat(volume.getImage().getFormat());\n            vt.setImageManifestSet(Lists.newArrayList(im));\n            vt.setVolumeId(volume.getVolume().getId());\n            newTask.setVoumeTask(vt);\n            break;\n          }\n        }\n      }\n    }catch(final Exception ex){\n      ImagingTasks.setState(nextTask, ImportTaskState.FAILED, \"Internal error\");\n      throw new Exception(\"failed to prepare worker task\", ex);\n    }\n    try{\n      ImagingTasks.transitState(nextTask, ImportTaskState.PENDING, ImportTaskState.CONVERTING, null);\n    }catch(final Exception ex){\n      ;\n    }\n    \n    return newTask;\n  }","id":24081,"modified_method":"public WorkerTask getTask() throws Exception{\n    final ImagingTask nextTask = this.getNext();\n    if(nextTask==null)\n      return null;\n    \n    WorkerTask newTask = null;\n    try{\n      if (nextTask instanceof DiskImagingTask){\n        final DiskImagingTask imagingTask = (DiskImagingTask) nextTask;\n        final DiskImageConversionTask conversionTask = (DiskImageConversionTask) imagingTask.getTask();\n        newTask = new WorkerTask(imagingTask.getDisplayName(), WorkerTaskType.convert_image);\n        \n        final InstanceStoreTask ist = new InstanceStoreTask();\n        ist.setAccountId(imagingTask.getOwnerAccountNumber());\n        //ist.setAccessKey(imagingTask.getOwn); /// how to obtain an access key?\n        ist.setConvertedImage(conversionTask.getImportDisk().getConvertedImage());\n        ist.setImportImageSet(conversionTask.getImportDisk().getDiskImageSet());\n        ist.setUploadPolicy(conversionTask.getImportDisk().getUploadPolicy());\n        final ServiceConfiguration osg = Topology.lookup( ObjectStorage.class );\n        final URI osgUri = osg.getUri();\n        ist.setS3Url(String.format(\"%s://%s:%d%s\", osgUri.getScheme(), osgUri.getHost(), osgUri.getPort(), osgUri.getPath()));\n        newTask.setInstanceStoreTask(ist);\n      }else if(nextTask instanceof ImportVolumeImagingTask){\n        final ImportVolumeImagingTask volumeTask = (ImportVolumeImagingTask) nextTask;\n        String manifestLocation = null;\n        if(volumeTask.getDownloadManifestUrl().size() == 0){\n          try{\n            manifestLocation = DownloadManifestFactory.generateDownloadManifest(\n                new ImageManifestFile(volumeTask.getImportManifestUrl(),\n                    ImportImageManifest.INSTANCE ),\n                    null, volumeTask.getDisplayName(), 1);\n          }catch(final InvalidBaseManifestException ex){\n            ImagingTasks.setState(volumeTask, ImportTaskState.FAILED, \"Failed to generate download manifest\");\n            throw new Exception(\"Failed to generate download manifest\", ex);\n          }\n\n          ImagingTasks.addDownloadManifestUrl(volumeTask, volumeTask.getImportManifestUrl(), manifestLocation);\n        }else\n          manifestLocation = volumeTask.getDownloadManifestUrl().get(0).getDownloadManifestUrl();\n        newTask = new WorkerTask(volumeTask.getDisplayName(), WorkerTaskType.import_volume);\n        final VolumeTask vt = new VolumeTask();\n        final ImageManifest im = new ImageManifest();\n        im.setManifestUrl(manifestLocation);\n        im.setFormat(volumeTask.getFormat());\n        vt.setImageManifestSet(Lists.newArrayList(im));\n        vt.setVolumeId(volumeTask.getVolumeId());\n        newTask.setVoumeTask(vt);\n      }else if (nextTask instanceof ImportInstanceImagingTask){\n        final ImportInstanceImagingTask instanceTask = (ImportInstanceImagingTask) nextTask;\n        for(final ImportInstanceVolumeDetail volume : instanceTask.getVolumes()){\n          final String importManifestUrl = volume.getImage().getImportManifestUrl();\n          if(! instanceTask.hasDownloadManifestUrl(importManifestUrl)){\n            // meaning that this task has not been fully processed by worker\n            String manifestLocation = null;\n            manifestLocation = instanceTask.getDownloadManifestUrl(importManifestUrl);\n            if(manifestLocation == null){\n              try{\n                manifestLocation = DownloadManifestFactory.generateDownloadManifest(\n                    new ImageManifestFile(importManifestUrl,\n                        ImportImageManifest.INSTANCE ),\n                        null, nextTask.getDisplayName(), 1);\n                ImagingTasks.addDownloadManifestUrl(instanceTask, importManifestUrl, manifestLocation);\n              }catch(final InvalidBaseManifestException ex){\n                ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to generate download manifest\");\n                throw new Exception(\"Failed to generate download manifest\", ex);\n              }       \n            }\n            newTask = new WorkerTask(instanceTask.getDisplayName(), WorkerTaskType.import_volume);\n            final VolumeTask vt = new VolumeTask();\n            final ImageManifest im = new ImageManifest();\n            im.setManifestUrl(manifestLocation);\n            im.setFormat(volume.getImage().getFormat());\n            vt.setImageManifestSet(Lists.newArrayList(im));\n            vt.setVolumeId(volume.getVolume().getId());\n            newTask.setVoumeTask(vt);\n            break;\n          }\n        }\n      }\n    }catch(final Exception ex){\n      ImagingTasks.setState(nextTask, ImportTaskState.FAILED, \"Internal error\");\n      throw new Exception(\"failed to prepare worker task\", ex);\n    }\n    try{\n      ImagingTasks.transitState(nextTask, ImportTaskState.PENDING, ImportTaskState.CONVERTING, null);\n    }catch(final Exception ex){\n      ;\n    }\n    \n    return newTask;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public PutInstanceImportTaskStatusResponseType PutInstanceImportTaskStatus( PutInstanceImportTaskStatusType request ) throws EucalyptusCloudException {\n    LOG.debug(request);\n    final PutInstanceImportTaskStatusResponseType reply = request.getReply( );\n    reply.setCancelled(false);\n\n    try{\n      final String taskId = request.getImportTaskId();\n      final String volumeId = request.getVolumeId();\n      if(taskId==null || volumeId==null)\n        throw new Exception(\"Task or volume id is null\");\n      \n      ImagingTask imagingTask = null;\n\n      try{\n        imagingTask= ImagingTasks.lookup(taskId);\n      }catch(final Exception ex){\n        reply.setCancelled(true);\n        throw new Exception(\"imaging task with \"+taskId+\" is not found\");\n      }\n      \n      if(ImportTaskState.CONVERTING.equals(imagingTask.getState())){\n        //EXTANT, FAILED, DONE\n        final WorkerTaskState workerState = WorkerTaskState.fromString(request.getStatus());\n        if(WorkerTaskState.EXTANT.equals(workerState) || WorkerTaskState.DONE.equals(workerState)){\n          try{\n            final long bytesConverted= request.getBytesConverted();\n            if(bytesConverted>0)\n              ImagingTasks.updateBytesConverted(taskId, volumeId, bytesConverted);\n          }catch(final Exception ex){\n            LOG.warn(\"Failed to update bytes converted(\"+taskId+\")\");\n          }\n        }\n        \n        switch(workerState){\n        case EXTANT:\n            ;\n          break;\n\n        case DONE:\n          try{\n              ImagingTasks.updateVolumeStatus(imagingTask, volumeId, ImportTaskState.COMPLETED, null);\n          }catch(final Exception ex){\n            ImagingTasks.transitState(imagingTask, ImportTaskState.CONVERTING, \n                ImportTaskState.FAILED, \"Failed to update volume's state\");\n            LOG.error(\"Failed to update volume's state\", ex);\n            break;\n          }\n          try{\n            if(ImagingTasks.isConversionDone(imagingTask)){\n             if(imagingTask instanceof InstanceImagingTask){\n                ImagingTasks.transitState(imagingTask, ImportTaskState.CONVERTING, \n                    ImportTaskState.INSTANTIATING, null);\n              }else{\n                ImagingTasks.transitState(imagingTask, ImportTaskState.CONVERTING, \n                  ImportTaskState.COMPLETED, null);\n              }\n            }\n          }catch(final Exception ex){\n            LOG.error(\"Failed to update imaging task's state to completed\", ex);\n          }\n          break;\n\n        case FAILED:\n          ImagingTasks.setState(imagingTask, ImportTaskState.FAILED, request.getStatusMessage());\n          break;\n        }\n      }else{\n        reply.setCancelled(true);\n      }\n    }catch(final Exception ex){\n      LOG.warn(\"Failed to update the task's state\", ex);\n    }\n    LOG.debug(reply);\n    return reply;\n  }","id":24082,"modified_method":"public PutInstanceImportTaskStatusResponseType PutInstanceImportTaskStatus( PutInstanceImportTaskStatusType request ) throws EucalyptusCloudException {\n    LOG.debug(request);\n    final PutInstanceImportTaskStatusResponseType reply = request.getReply( );\n    reply.setCancelled(false);\n\n    try{\n      final String taskId = request.getImportTaskId();\n      final String volumeId = request.getVolumeId();\n      if(taskId==null)\n        throw new Exception(\"Task id is null\");\n      \n      ImagingTask imagingTask = null;\n      try{\n        imagingTask= ImagingTasks.lookup(taskId);\n      }catch(final Exception ex){\n        reply.setCancelled(true);\n        throw new Exception(\"imaging task with \"+taskId+\" is not found\");\n      }\n      \n      if(ImportTaskState.CONVERTING.equals(imagingTask.getState())){\n        //EXTANT, FAILED, DONE\n        final WorkerTaskState workerState = WorkerTaskState.fromString(request.getStatus());\n        if(WorkerTaskState.EXTANT.equals(workerState) || WorkerTaskState.DONE.equals(workerState)){\n          if(imagingTask instanceof VolumeImagingTask){\n            try{\n              final long bytesConverted= request.getBytesConverted();\n              if(bytesConverted>0)\n                ImagingTasks.updateBytesConverted(taskId, volumeId, bytesConverted);\n            }catch(final Exception ex){\n              LOG.warn(\"Failed to update bytes converted(\"+taskId+\")\");\n            }\n          }\n        }\n        \n        switch(workerState){\n        case EXTANT:\n            ;\n          break;\n\n        case DONE:\n          if(imagingTask instanceof VolumeImagingTask){\n            try{\n              ImagingTasks.updateVolumeStatus((VolumeImagingTask)imagingTask, volumeId, ImportTaskState.COMPLETED, null);\n            }catch(final Exception ex){\n              ImagingTasks.transitState(imagingTask, ImportTaskState.CONVERTING, \n                  ImportTaskState.FAILED, \"Failed to update volume's state\");\n              LOG.error(\"Failed to update volume's state\", ex);\n              break;\n            }\n            try{\n              if(ImagingTasks.isConversionDone((VolumeImagingTask)imagingTask)){\n                if(imagingTask instanceof ImportInstanceImagingTask){\n                  ImagingTasks.transitState(imagingTask, ImportTaskState.CONVERTING, \n                      ImportTaskState.INSTANTIATING, null);\n                }else{\n                  ImagingTasks.transitState(imagingTask, ImportTaskState.CONVERTING, \n                      ImportTaskState.COMPLETED, null);\n                }\n              }\n            }catch(final Exception ex){\n              LOG.error(\"Failed to update imaging task's state to completed\", ex);\n            }\n          }else if(imagingTask instanceof DiskImagingTask){\n            ImagingTasks.transitState(imagingTask, ImportTaskState.CONVERTING, \n                ImportTaskState.COMPLETED, null);\n          }\n          break;\n\n        case FAILED:\n          ImagingTasks.setState(imagingTask, ImportTaskState.FAILED, request.getStatusMessage());\n          break;\n        }\n      }else{\n        reply.setCancelled(true);\n      }\n    }catch(final Exception ex){\n      LOG.warn(\"Failed to update the task's state\", ex);\n    }\n    LOG.debug(reply);\n    return reply;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@PostLoad\n  protected void onLoad(){\n    if(this.view==null)\n      this.view = new ImagingTaskRelationView(this);\n    createTaskFromJSON();\n  }","id":24083,"modified_method":"protected void onLoad(){\n    createTaskFromJSON();\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public ConversionTask getTask( ) {\n    return task;\n  }","id":24084,"modified_method":"public AbstractConversionTask getTask() {\n    throw new UnsupportedOperationException();\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"ImagingTask( OwnerFullName owner, String displayName ) {\n    super( owner, displayName );\n    this.bytesProcessed = null;\n  }","id":24085,"modified_method":"ImagingTask( OwnerFullName owner, String displayName ) {\n    super( owner, displayName );\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void createTaskFromJSON( ) {\n    // recreate task from JSON string\n    if ( this.taskInJSON != null ) {\n      JsonSlurper jsonSlurper = new JsonSlurper( );\n      JSONObject taskObject = ( JSONObject ) jsonSlurper.parseText( this.taskInJSON );\n      this.task = new ConversionTask( taskObject );\n    }\n  }","id":24086,"modified_method":"protected void createTaskFromJSON( ){\n    throw new UnsupportedOperationException();\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected ImagingTask( ) {\n    this(null,null);\n    task = null;\n  }","id":24087,"modified_method":"protected ImagingTask( ) {\n    this(null,null);\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@PrePersist\n  /* package */void serializeTaskToJSON( ) {\n    if ( this.task != null ) {\n      taskInJSON = ( JSONSerializer.toJSON( task.toJSON( ) ) ).toString( );\n    }\n  }","id":24088,"modified_method":"@PrePersist\n  protected void serializeTaskToJSON( ) {\n    if ( this.getTask() != null ) {\n      taskInJSON = ( JSONSerializer.toJSON( this.getTask().toJSON( ) ) ).toString( );\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void processNewInstanceImagingTask(final InstanceImagingTask instanceTask) throws Exception{\n    // for each disk image, create a volume and set its state accordingly\n    final ImportInstanceTaskDetails taskDetail=\n        instanceTask.getTask().getImportInstance();\n    final List<ImportInstanceVolumeDetail> volumes = taskDetail.getVolumes();\n    if(volumes==null)\n      return;\n    \n    try{\n      int numVolumeCreated = 0;\n      for(final ImportInstanceVolumeDetail volume : volumes){\n        if(volume.getVolume()==null || volume.getVolume().getId() == null ||  \n            volume.getVolume().getId().length()<=0){\n          final String zone = volume.getAvailabilityZone();\n          final Integer size = volume.getVolume().getSize();\n          if(zone==null)\n            throw new Exception(\"Availability zone is missing from the volume detail\");\n          if(size==null || size <=0 )\n            throw new Exception(\"Volume size is missing from the volume detail\");\n          try{\n            final String volumeId = \n                EucalyptusActivityTasks.getInstance().createVolumeAsUser(instanceTask.getOwnerUserId(), zone, size);\n            volume.getVolume().setId(volumeId);\n          }catch(final Exception ex){\n            throw new Exception(\"Failed to create the volume\", ex);\n          }\n        }else{\n          String volumeStatus= null;\n          try{\n            final List<Volume> eucaVolumes = \n                EucalyptusActivityTasks.getInstance().describeVolumesAsUser(instanceTask.getOwnerUserId(), Lists.newArrayList(volume.getVolume().getId()));\n            final Volume eucaVolume = eucaVolumes.get(0);\n            volumeStatus = eucaVolume.getStatus();\n          }catch(final Exception ex){\n            throw new Exception(\"Failed to check the state of the volume \"+volume.getVolume().getId());\n          }\n          if(\"available\".equals(volumeStatus)){\n            volume.setStatus(\"active\");\n            numVolumeCreated++;\n          }else if (\"creating\".equals(volumeStatus)){\n            volume.setStatus(\"active\");\n          }else{\n            volume.setStatus(\"cancelled\");\n            volume.setStatusMessage(\"Failed to create the volume\");\n            throw new Exception(\"Volume \"+volume.getVolume().getId()+\" is in \"+volumeStatus);\n          }\n        } \n      }\n      if(numVolumeCreated == volumes.size()){\n        try{\n          ImagingTasks.transitState(instanceTask, ImportTaskState.NEW, ImportTaskState.PENDING, null);\n        }catch(final Exception ex){\n          ;\n        }\n      }\n    }catch(Exception ex){\n      throw ex;\n    }finally{\n      ImagingTasks.updateTaskInJson(instanceTask); \n    }\n  }","id":24089,"modified_method":"private void processNewImportInstanceImagingTask(final ImportInstanceImagingTask instanceTask) throws Exception{\n    // for each disk image, create a volume and set its state accordingly\n    final ImportInstanceTaskDetails taskDetail=\n        ((ConversionTask)instanceTask.getTask()).getImportInstance();\n    final List<ImportInstanceVolumeDetail> volumes = taskDetail.getVolumes();\n    if(volumes==null)\n      return;\n    \n    try{\n      int numVolumeCreated = 0;\n      for(final ImportInstanceVolumeDetail volume : volumes){\n        if(volume.getVolume()==null || volume.getVolume().getId() == null ||  \n            volume.getVolume().getId().length()<=0){\n          final String zone = volume.getAvailabilityZone();\n          final Integer size = volume.getVolume().getSize();\n          if(zone==null)\n            throw new Exception(\"Availability zone is missing from the volume detail\");\n          if(size==null || size <=0 )\n            throw new Exception(\"Volume size is missing from the volume detail\");\n          try{\n            final String volumeId = \n                EucalyptusActivityTasks.getInstance().createVolumeAsUser(instanceTask.getOwnerUserId(), zone, size);\n            volume.getVolume().setId(volumeId);\n          }catch(final Exception ex){\n            throw new Exception(\"Failed to create the volume\", ex);\n          }\n        }else{\n          String volumeStatus= null;\n          try{\n            final List<Volume> eucaVolumes = \n                EucalyptusActivityTasks.getInstance().describeVolumesAsUser(instanceTask.getOwnerUserId(), Lists.newArrayList(volume.getVolume().getId()));\n            final Volume eucaVolume = eucaVolumes.get(0);\n            volumeStatus = eucaVolume.getStatus();\n          }catch(final Exception ex){\n            throw new Exception(\"Failed to check the state of the volume \"+volume.getVolume().getId());\n          }\n          if(\"available\".equals(volumeStatus)){\n            volume.setStatus(\"active\");\n            numVolumeCreated++;\n          }else if (\"creating\".equals(volumeStatus)){\n            volume.setStatus(\"active\");\n          }else{\n            volume.setStatus(\"cancelled\");\n            volume.setStatusMessage(\"Failed to create the volume\");\n            throw new Exception(\"Volume \"+volume.getVolume().getId()+\" is in \"+volumeStatus);\n          }\n        } \n      }\n      if(numVolumeCreated == volumes.size()){\n        try{\n          ImagingTasks.transitState(instanceTask, ImportTaskState.NEW, ImportTaskState.PENDING, null);\n        }catch(final Exception ex){\n          ;\n        }\n      }\n    }catch(Exception ex){\n      throw ex;\n    }finally{\n      ImagingTasks.updateTaskInJson(instanceTask); \n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void processNewVolumeImagingTask(final VolumeImagingTask volumeTask) throws Exception{\n    if(volumeTask.getVolumeId()==null || volumeTask.getVolumeId().length()<=0){\n      final String zone = volumeTask.getAvailabilityZone();\n      final int size = volumeTask.getVolumeSize();\n      //create volume (already sanitized)\n      try{\n        final String volumeId = EucalyptusActivityTasks.getInstance().createVolumeAsUser(volumeTask.getOwnerUserId(), zone, size);\n        ImagingTasks.setVolumeId(volumeTask, volumeId);\n      }catch(final Exception ex){\n        throw new Exception(\"Failed to create the volume\", ex);\n      }\n    } else { /// check status\n      final List<Volume> volumes = \n          EucalyptusActivityTasks.getInstance().describeVolumesAsUser(volumeTask.getOwnerUserId(), Lists.newArrayList(volumeTask.getVolumeId()));\n      final Volume volume = volumes.get(0);\n      final String volumeStatus = volume.getStatus();\n      if(\"available\".equals(volumeStatus)){\n        final ConversionTask conversionTask = volumeTask.getTask();\n        if(conversionTask.getImportVolume() != null){\n          try{\n            ImagingTasks.transitState(volumeTask, ImportTaskState.NEW, ImportTaskState.PENDING, null);\n          }catch(final Exception ex){\n            ;\n          }\n        }else{\n          throw new Exception(\"No importVolume detail is found in the conversion task\");\n        }\n      }else if (\"creating\".equals(volumeStatus)){\n        ; // continue to poll\n      }else{\n        throw new Exception(\"The volume \"+volume.getVolumeId()+\"'s state is \"+volumeStatus);\n      }\n    }  \n  }","id":24090,"modified_method":"private void processNewImportVolumeImagingTask(final ImportVolumeImagingTask volumeTask) throws Exception{\n    if(volumeTask.getVolumeId()==null || volumeTask.getVolumeId().length()<=0){\n      final String zone = volumeTask.getAvailabilityZone();\n      final int size = volumeTask.getVolumeSize();\n      //create volume (already sanitized)\n      try{\n        final String volumeId = EucalyptusActivityTasks.getInstance().createVolumeAsUser(volumeTask.getOwnerUserId(), zone, size);\n        ImagingTasks.setVolumeId(volumeTask, volumeId);\n      }catch(final Exception ex){\n        throw new Exception(\"Failed to create the volume\", ex);\n      }\n    } else { /// check status\n      final List<Volume> volumes = \n          EucalyptusActivityTasks.getInstance().describeVolumesAsUser(volumeTask.getOwnerUserId(), Lists.newArrayList(volumeTask.getVolumeId()));\n      final Volume volume = volumes.get(0);\n      final String volumeStatus = volume.getStatus();\n      if(\"available\".equals(volumeStatus)){\n        final ConversionTask conversionTask = (ConversionTask) volumeTask.getTask();\n        if(conversionTask.getImportVolume() != null){\n          try{\n            ImagingTasks.transitState(volumeTask, ImportTaskState.NEW, ImportTaskState.PENDING, null);\n          }catch(final Exception ex){\n            ;\n          }\n        }else{\n          throw new Exception(\"No importVolume detail is found in the conversion task\");\n        }\n      }else if (\"creating\".equals(volumeStatus)){\n        ; // continue to poll\n      }else{\n        throw new Exception(\"The volume \"+volume.getVolumeId()+\"'s state is \"+volumeStatus);\n      }\n    }  \n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void processNewTasks(final List<ImagingTask> tasks){\n    for(final ImagingTask task : tasks){\n      try{\n        // create a volume and update the database\n       if(task instanceof VolumeImagingTask)\n         processNewVolumeImagingTask((VolumeImagingTask) task);\n       else if(task instanceof InstanceStoreImagingTask) // no need to create volumes\n         ImagingTasks.transitState(task, ImportTaskState.NEW, ImportTaskState.PENDING, \"\");\n       else if(task instanceof InstanceImagingTask)\n         processNewInstanceImagingTask((InstanceImagingTask)task);\n       else\n         throw new Exception(\"Invalid ImagingTask\");\n      }catch(final Exception ex){\n        try{\n          ImagingTasks.transitState(task, ImportTaskState.NEW, ImportTaskState.FAILED, \"Failed to create the volume\");\n        }catch(final Exception ex2){\n          ;\n        }\n        LOG.error(\"Failed to process new task\", ex);\n      }\n    }\n  }","id":24091,"modified_method":"private void processNewTasks(final List<ImagingTask> tasks){\n    for(final ImagingTask task : tasks){\n      try{\n        // create a volume and update the database\n       if(task instanceof ImportVolumeImagingTask)\n         processNewImportVolumeImagingTask((ImportVolumeImagingTask) task); \n       else if(task instanceof ImportInstanceImagingTask)\n         processNewImportInstanceImagingTask((ImportInstanceImagingTask)task);\n       else if(task instanceof DiskImagingTask) // no need to create volumes\n         ImagingTasks.transitState(task, ImportTaskState.NEW, ImportTaskState.PENDING, \"\");\n       else\n         throw new Exception(\"Invalid ImagingTask\");\n      }catch(final Exception ex){\n        try{\n          ImagingTasks.transitState(task, ImportTaskState.NEW, ImportTaskState.FAILED, \"Failed to create the volume\");\n        }catch(final Exception ex2){\n          ;\n        }\n        LOG.error(\"Failed to process new task\", ex);\n      }\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void processInstantiatingTasks(final List<ImagingTask> tasks){\n    for(final ImagingTask task : tasks){\n      if(! (task instanceof InstanceImagingTask))\n        continue;\n\n      if(task instanceof InstanceStoreImagingTask){\n        // for now, we will not create emi or launch instances out of ImportImage task\n        try{\n          ImagingTasks.transitState(task, ImportTaskState.INSTANTIATING, ImportTaskState.COMPLETED, \"\");\n        }catch(final Exception ex){\n          LOG.error(\"Failed to update task's state to completed\", ex);\n        }\n        continue;\n      }\n      \n      final InstanceImagingTask instanceTask = (InstanceImagingTask) task;\n      final ConversionTask conversionTask = instanceTask.getTask();\n      if(conversionTask.getImportInstance()==null){\n        LOG.warn(\"Import instance task should contain ImportInstanceTaskDetail\");\n        continue;\n      }\n        \n      String instanceId = conversionTask.getImportInstance().getInstanceId();\n      if(instanceId!=null && instanceId.length() > 0){\n        try{\n          ImagingTasks.transitState(task, ImportTaskState.INSTANTIATING , ImportTaskState.COMPLETED, \"\");\n        }catch(final Exception ex){\n          LOG.error(\"Failed to update task's state to completed\", ex);\n        }\n        continue;\n      }\n      \n      String imageId = instanceTask.getImageId();\n      if(imageId!=null && imageId.length() > 0){\n        try{\n          // launch the image with the launch spec\n          String groupName = null;\n          if(instanceTask.getLaunchSpecGroupNames()!=null &&\n              instanceTask.getLaunchSpecGroupNames().size()>0){\n            groupName = instanceTask.getLaunchSpecGroupNames().get(0);\n          }\n          String userData = null;\n          if(instanceTask.getLaunchSpecUserData()!=null &&\n              instanceTask.getLaunchSpecUserData().length()>0){\n            userData = instanceTask.getLaunchSpecUserData();\n          }\n          String instanceType = null;\n          if(instanceTask.getLaunchSpecInstanceType()!=null &&\n              instanceTask.getLaunchSpecInstanceType().length()>0){\n            instanceType = instanceTask.getLaunchSpecInstanceType();\n          }\n          String availabilityZone = null;\n          if(instanceTask.getLaunchSpecAvailabilityZone()!=null &&\n              instanceTask.getLaunchSpecAvailabilityZone().length()>0){\n            availabilityZone = instanceTask.getLaunchSpecAvailabilityZone();\n          }\n          boolean monitoring = instanceTask.getLaunchSpecMonitoringEnabled();\n          instanceId = \n              EucalyptusActivityTasks.getInstance().runInstancesAsUser(instanceTask.getOwnerUserId(),\n              imageId, groupName, userData, instanceType, availabilityZone, monitoring);\n          conversionTask.getImportInstance().setInstanceId(instanceId);\n          ImagingTasks.updateTaskInJson(instanceTask);\n        }catch(final Exception ex){\n          LOG.warn(\"Failed to run instances after conversion task\");\n          try{\n            ImagingTasks.transitState(instanceTask, ImportTaskState.INSTANTIATING , \n                ImportTaskState.COMPLETED, String.format(\"Image registered: %s, but failed to run instance\", imageId));\n            // this will set the task state to completed in the next timer run\n          }catch(final Exception ex1){\n            ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to run instances\");\n          }\n        }\n        continue;\n      }\n      \n      final List<String> snapshotIds = instanceTask.getSnapshotIds();\n      if(snapshotIds!=null && snapshotIds.size()>0){\n        try{\n         // see if the snapshots are ready and register them as images\n          final List<Snapshot> snapshots = \n              EucalyptusActivityTasks.getInstance().describeSnapshotsAsUser(instanceTask.getOwnerUserId(), snapshotIds);\n          int numCompleted = 0;\n          int numError = 0;\n          for(final Snapshot snapshot: snapshots){\n            if(\"completed\".equals(snapshot.getStatus()))\n              numCompleted++;\n            else if(\"error\".equals(snapshot.getStatus()))\n              numError++;\n          }\n          if(numError>0){\n           ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to create a snapshot\");\n          }else if(numCompleted == snapshotIds.size()){\n            // TODO : multiple snapshots (i.e., multiple images from import-instance). what to do?\n            // register the image\n            String snapshotId = null;\n            if(snapshots.size()>1){\n              LOG.warn(\"More than one snapshots found for import-instance task \"+instanceTask.getDisplayName());\n            }\n            snapshotId = snapshotIds.get(0);\n            final String imageName = String.format(\"image-%s\", instanceTask.getDisplayName());\n            final String description = conversionTask.getImportInstance().getDescription();\n            final String architecture = instanceTask.getLaunchSpecArchitecture();\n            String platform = null;\n            if(conversionTask.getImportInstance().getPlatform()!=null && conversionTask.getImportInstance().getPlatform().length()>0)\n              platform = conversionTask.getImportInstance().getPlatform().toLowerCase();\n            try{\n              imageId = \n                  EucalyptusActivityTasks.getInstance().registerEBSImageAsUser(instanceTask.getOwnerUserId(), \n                      snapshotId, imageName, architecture, platform, description);\n              if(imageId==null)\n                throw new Exception(\"Null image id\");\n              ImagingTasks.setImageId(instanceTask, imageId);\n            }catch(final Exception ex){\n              ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to register the image for \"+snapshotId);\n            }\n          }\n        }catch(final Exception ex){\n          ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to register the image\");\n        }\n        continue;\n      }\n      \n      /// snapshot volumes\n      final List<ImportInstanceVolumeDetail> volumes = conversionTask.getImportInstance().getVolumes();\n      if(volumes==null || volumes.size()<=0){\n        ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"No volume is found\");\n      }\n      final List<String> volumeIds = Lists.newArrayList();\n      for(final ImportInstanceVolumeDetail volume : volumes){\n        if(volume.getVolume()==null || volume.getVolume().getId()==null)\n          continue;\n        volumeIds.add(volume.getVolume().getId());\n      }\n      if(volumeIds.size()<=0){\n        ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"No volume is found\");\n      }\n      for(final String volumeId : volumeIds){\n        try{\n          final String snapshotId = \n              EucalyptusActivityTasks.getInstance().createSnapshotAsUser(instanceTask.getOwnerUserId(), volumeId);\n          ImagingTasks.addSnapshotId(instanceTask, snapshotId);\n        }catch(final Exception ex){\n          ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to create a snapshot\");\n          break;\n        }\n      }\n    } /// end of for\n  }","id":24092,"modified_method":"private void processInstantiatingTasks(final List<ImagingTask> tasks){\n    for(final ImagingTask task : tasks){\n      if(! (task instanceof ImportInstanceImagingTask))\n        continue;\n     \n      final ImportInstanceImagingTask instanceTask = (ImportInstanceImagingTask) task;\n      final ConversionTask conversionTask = (ConversionTask) instanceTask.getTask();\n      if(conversionTask.getImportInstance()==null){\n        LOG.warn(\"Import instance task should contain ImportInstanceTaskDetail\");\n        continue;\n      }\n        \n      String instanceId = conversionTask.getImportInstance().getInstanceId();\n      if(instanceId!=null && instanceId.length() > 0){\n        try{\n          ImagingTasks.transitState(task, ImportTaskState.INSTANTIATING , ImportTaskState.COMPLETED, \"\");\n        }catch(final Exception ex){\n          LOG.error(\"Failed to update task's state to completed\", ex);\n        }\n        continue;\n      }\n      \n      String imageId = instanceTask.getImageId();\n      if(imageId!=null && imageId.length() > 0){\n        try{\n          // launch the image with the launch spec\n          String groupName = null;\n          if(instanceTask.getLaunchSpecGroupNames()!=null &&\n              instanceTask.getLaunchSpecGroupNames().size()>0){\n            groupName = instanceTask.getLaunchSpecGroupNames().get(0);\n          }\n          String userData = null;\n          if(instanceTask.getLaunchSpecUserData()!=null &&\n              instanceTask.getLaunchSpecUserData().length()>0){\n            userData = instanceTask.getLaunchSpecUserData();\n          }\n          String instanceType = null;\n          if(instanceTask.getLaunchSpecInstanceType()!=null &&\n              instanceTask.getLaunchSpecInstanceType().length()>0){\n            instanceType = instanceTask.getLaunchSpecInstanceType();\n          }\n          String availabilityZone = null;\n          if(instanceTask.getLaunchSpecAvailabilityZone()!=null &&\n              instanceTask.getLaunchSpecAvailabilityZone().length()>0){\n            availabilityZone = instanceTask.getLaunchSpecAvailabilityZone();\n          }\n          boolean monitoring = instanceTask.getLaunchSpecMonitoringEnabled();\n          instanceId = \n              EucalyptusActivityTasks.getInstance().runInstancesAsUser(instanceTask.getOwnerUserId(),\n              imageId, groupName, userData, instanceType, availabilityZone, monitoring);\n          conversionTask.getImportInstance().setInstanceId(instanceId);\n          ImagingTasks.updateTaskInJson(instanceTask);\n        }catch(final Exception ex){\n          LOG.warn(\"Failed to run instances after conversion task\");\n          try{\n            ImagingTasks.transitState(instanceTask, ImportTaskState.INSTANTIATING , \n                ImportTaskState.COMPLETED, String.format(\"Image registered: %s, but failed to run instance\", imageId));\n            // this will set the task state to completed in the next timer run\n          }catch(final Exception ex1){\n            ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to run instances\");\n          }\n        }\n        continue;\n      }\n      \n      final List<String> snapshotIds = instanceTask.getSnapshotIds();\n      if(snapshotIds!=null && snapshotIds.size()>0){\n        try{\n         // see if the snapshots are ready and register them as images\n          final List<Snapshot> snapshots = \n              EucalyptusActivityTasks.getInstance().describeSnapshotsAsUser(instanceTask.getOwnerUserId(), snapshotIds);\n          int numCompleted = 0;\n          int numError = 0;\n          for(final Snapshot snapshot: snapshots){\n            if(\"completed\".equals(snapshot.getStatus()))\n              numCompleted++;\n            else if(\"error\".equals(snapshot.getStatus()))\n              numError++;\n          }\n          if(numError>0){\n           ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to create a snapshot\");\n          }else if(numCompleted == snapshotIds.size()){\n            // TODO : multiple snapshots (i.e., multiple images from import-instance). what to do?\n            // register the image\n            String snapshotId = null;\n            if(snapshots.size()>1){\n              LOG.warn(\"More than one snapshots found for import-instance task \"+instanceTask.getDisplayName());\n            }\n            snapshotId = snapshotIds.get(0);\n            final String imageName = String.format(\"image-%s\", instanceTask.getDisplayName());\n            final String description = conversionTask.getImportInstance().getDescription();\n            final String architecture = instanceTask.getLaunchSpecArchitecture();\n            String platform = null;\n            if(conversionTask.getImportInstance().getPlatform()!=null && conversionTask.getImportInstance().getPlatform().length()>0)\n              platform = conversionTask.getImportInstance().getPlatform().toLowerCase();\n            try{\n              imageId = \n                  EucalyptusActivityTasks.getInstance().registerEBSImageAsUser(instanceTask.getOwnerUserId(), \n                      snapshotId, imageName, architecture, platform, description);\n              if(imageId==null)\n                throw new Exception(\"Null image id\");\n              ImagingTasks.setImageId(instanceTask, imageId);\n            }catch(final Exception ex){\n              ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to register the image for \"+snapshotId);\n            }\n          }\n        }catch(final Exception ex){\n          ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to register the image\");\n        }\n        continue;\n      }\n      \n      /// snapshot volumes\n      final List<ImportInstanceVolumeDetail> volumes = conversionTask.getImportInstance().getVolumes();\n      if(volumes==null || volumes.size()<=0){\n        ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"No volume is found\");\n      }\n      final List<String> volumeIds = Lists.newArrayList();\n      for(final ImportInstanceVolumeDetail volume : volumes){\n        if(volume.getVolume()==null || volume.getVolume().getId()==null)\n          continue;\n        volumeIds.add(volume.getVolume().getId());\n      }\n      if(volumeIds.size()<=0){\n        ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"No volume is found\");\n      }\n      for(final String volumeId : volumeIds){\n        try{\n          final String snapshotId = \n              EucalyptusActivityTasks.getInstance().createSnapshotAsUser(instanceTask.getOwnerUserId(), volumeId);\n          ImagingTasks.addSnapshotId(instanceTask, snapshotId);\n        }catch(final Exception ex){\n          ImagingTasks.setState(instanceTask, ImportTaskState.FAILED, \"Failed to create a snapshot\");\n          break;\n        }\n      }\n    } /// end of for\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static VolumeImagingTask createImportVolumeTask(ImportVolumeType request) throws ImagingServiceException {\n    /// sanity check\n    /// availability zone\n    final String availabilityZone = request.getAvailabilityZone();\n    if(availabilityZone == null || availabilityZone.length()<=0)\n      throw new ImagingServiceException(\"Availability zone is required\");\n    else{\n      try{\n        final List<ClusterInfoType> clusters = \n            EucalyptusActivityTasks.getInstance().describeAvailabilityZones(false);\n        boolean zoneFound = false;\n        for(final ClusterInfoType cluster : clusters ){\n          if(availabilityZone.equals(cluster.getZoneName())){\n            zoneFound = true;\n            break;\n          }\n        }\n        if(!zoneFound)\n          throw new ImagingServiceException(String.format(\"The availability zone %s is not found\", availabilityZone));\n      }catch(final ImagingServiceException ex){\n        throw ex;\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to verify availability zone\");\n      }\n    }\n    \n    // Image format\n    final String format = request.getImage().getFormat();\n    if(format==null || format.length()<=0)\n      throw new ImagingServiceException(\"Image format is required\");\n    try{\n      final IMAGE_FORMAT imgFormat = IMAGE_FORMAT.valueOf(format.toUpperCase());\n    }catch(final Exception ex){\n      throw new ImagingServiceException(\"Unsupported image format\");\n    }\n    \n    // Image bytes\n    \n    // Image.ImportManifestUrl\n    final String manifestUrl = request.getImage().getImportManifestUrl();\n    if(manifestUrl == null || manifestUrl.length()<=0)\n      throw new ImagingServiceException(\"Import manifest url is required\");\n    /// TODO should check if the manifest url is present and accessible in S3\n\n    try{\n      /// TODO: should we assume the converted image is always larger than or equal to the uploaded image\n      final int volumeSize = request.getVolume().getSize();\n      final long imageBytes = request.getImage().getBytes();\n      final long volumeSizeInBytes = (volumeSize * (long) Math.pow(1024, 3));\n      if(imageBytes > volumeSizeInBytes)\n        throw new ImagingServiceException(\"Requested volume size is not enough to hold the image\");\n    }catch(final ImagingServiceException ex){\n      throw ex;\n    }catch(final Exception ex){\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n          \"Failed to verify the requested volume size\");\n    }\n    \n    final VolumeImagingTask transform = TypeMappers.transform( request, VolumeImagingTask.class );\n    try ( final TransactionResource db =\n        Entities.transactionFor( VolumeImagingTask.class ) ) {\n      try{\n        Entities.persist(transform);\n        db.commit( );\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to persist VolumeImagingTask\", ex);\n      }\n    }\n    return transform;\n  }","id":24093,"modified_method":"public static ImportVolumeImagingTask createImportVolumeTask(ImportVolumeType request) throws ImagingServiceException {\n    /// sanity check\n    /// availability zone\n    final String availabilityZone = request.getAvailabilityZone();\n    if(availabilityZone == null || availabilityZone.length()<=0)\n      throw new ImagingServiceException(\"Availability zone is required\");\n    else{\n      try{\n        final List<ClusterInfoType> clusters = \n            EucalyptusActivityTasks.getInstance().describeAvailabilityZones(false);\n        boolean zoneFound = false;\n        for(final ClusterInfoType cluster : clusters ){\n          if(availabilityZone.equals(cluster.getZoneName())){\n            zoneFound = true;\n            break;\n          }\n        }\n        if(!zoneFound)\n          throw new ImagingServiceException(String.format(\"The availability zone %s is not found\", availabilityZone));\n      }catch(final ImagingServiceException ex){\n        throw ex;\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to verify availability zone\");\n      }\n    }\n    \n    // Image format\n    final String format = request.getImage().getFormat();\n    if(format==null || format.length()<=0)\n      throw new ImagingServiceException(\"Image format is required\");\n    try{\n      final IMAGE_FORMAT imgFormat = IMAGE_FORMAT.valueOf(format.toUpperCase());\n    }catch(final Exception ex){\n      throw new ImagingServiceException(\"Unsupported image format\");\n    }\n    \n    // Image bytes\n    \n    // Image.ImportManifestUrl\n    final String manifestUrl = request.getImage().getImportManifestUrl();\n    if(manifestUrl == null || manifestUrl.length()<=0)\n      throw new ImagingServiceException(\"Import manifest url is required\");\n    /// TODO should check if the manifest url is present and accessible in S3\n\n    try{\n      /// TODO: should we assume the converted image is always larger than or equal to the uploaded image\n      final int volumeSize = request.getVolume().getSize();\n      final long imageBytes = request.getImage().getBytes();\n      final long volumeSizeInBytes = (volumeSize * (long) Math.pow(1024, 3));\n      if(imageBytes > volumeSizeInBytes)\n        throw new ImagingServiceException(\"Requested volume size is not enough to hold the image\");\n    }catch(final ImagingServiceException ex){\n      throw ex;\n    }catch(final Exception ex){\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n          \"Failed to verify the requested volume size\");\n    }\n    \n    final ImportVolumeImagingTask transform = TypeMappers.transform( request, ImportVolumeImagingTask.class );\n    try ( final TransactionResource db =\n        Entities.transactionFor( ImportVolumeImagingTask.class ) ) {\n      try{\n        Entities.persist(transform);\n        db.commit( );\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to persist VolumeImagingTask\", ex);\n      }\n    }\n    return transform;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void updateBytesConverted(final String taskId, final String volumeId, long bytesConverted ){\n    try ( final TransactionResource db =\n        Entities.transactionFor(ImagingTask.class ) ) {\n      try{\n        final ImagingTask entity = Entities.uniqueResult(ImagingTask.named(taskId));\n        final ConversionTask task = entity.getTask();\n        if(task.getImportVolume()!=null){\n          task.getImportVolume().setBytesConverted(bytesConverted);\n        }else if(task.getImportInstance()!=null && task.getImportInstance().getVolumes()!=null){\n          final List<ImportInstanceVolumeDetail> volumes = task.getImportInstance().getVolumes();\n          for(final ImportInstanceVolumeDetail volume : volumes){\n            if(volume.getVolume()!=null && volumeId.equals(volume.getVolume().getId())){\n              volume.setBytesConverted(bytesConverted);\n            }\n          }\n        }\n        entity.serializeTaskToJSON();\n        Entities.persist(entity);\n        db.commit();\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","id":24094,"modified_method":"public static void updateBytesConverted(final String taskId, final String volumeId, long bytesConverted ){\n    try ( final TransactionResource db =\n        Entities.transactionFor(VolumeImagingTask.class ) ) {\n      try{\n        final VolumeImagingTask entity = Entities.uniqueResult(VolumeImagingTask.named(taskId));\n        final ConversionTask task = (ConversionTask) entity.getTask();\n        if(task.getImportVolume()!=null){\n          task.getImportVolume().setBytesConverted(bytesConverted);\n        }else if(task.getImportInstance()!=null && task.getImportInstance().getVolumes()!=null){\n          final List<ImportInstanceVolumeDetail> volumes = task.getImportInstance().getVolumes();\n          for(final ImportInstanceVolumeDetail volume : volumes){\n            if(volume.getVolume()!=null && volumeId.equals(volume.getVolume().getId())){\n              volume.setBytesConverted(bytesConverted);\n            }\n          }\n        }\n        entity.serializeTaskToJSON();\n        Entities.persist(entity);\n        db.commit();\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static InstanceImagingTask createImportInstanceTask(final ImportInstanceType request) \n      throws ImagingServiceException {\n    // verify the input\n    final ImportInstanceLaunchSpecification launchSpec = request.getLaunchSpecification();\n    if(launchSpec==null)\n      throw new ImagingServiceException(\"Launch specification is required\");\n    if(launchSpec.getArchitecture()==null || \n        !(\"i386\".equals(launchSpec.getArchitecture()) || \"x86_64\".equals(launchSpec.getArchitecture())))\n        throw new ImagingServiceException(\"Architecture should be either i386 or x86_64\");\n    if(launchSpec.getInstanceType()==null)\n      throw new ImagingServiceException(\"Instance type is required\");\n    \n\n    List<ClusterInfoType> clusters = null;\n    try{\n        clusters=EucalyptusActivityTasks.getInstance().describeAvailabilityZones(false);\n    }catch(final Exception ex){\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n          \"Failed to verify availability zone\");    \n    }\n    String availabilityZone = null;\n    if(launchSpec.getPlacement()!=null)\n      availabilityZone = launchSpec.getPlacement().getAvailabilityZone();\n    if(availabilityZone != null){\n      boolean zoneFound = false;\n      for(final ClusterInfoType cluster : clusters ){\n        if(availabilityZone.equals(cluster.getZoneName())){\n          zoneFound = true;\n          break;\n        }\n      }\n      if(!zoneFound)\n        throw new ImagingServiceException(String.format(\"The availability zone %s is not found\", availabilityZone));\n    }else{\n      if (clusters.size()>0){\n        //Default: Amazon EC2 chooses a zone for you.\n        availabilityZone = clusters.get(0).getZoneName();\n        if(request.getLaunchSpecification().getPlacement()==null)\n          request.getLaunchSpecification().setPlacement(new InstancePlacement());\n        request.getLaunchSpecification().getPlacement().setAvailabilityZone(availabilityZone);\n      }else\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"No availability zone is found in the Cloud\");\n    }\n    \n    List<DiskImage> disks = request.getDiskImageSet();\n    if(disks==null || disks.size()<=0)\n      throw new ImagingServiceException(\"Disk images are required\");\n    \n    for(final DiskImage disk : disks){\n      final DiskImageDetail imageDetail = disk.getImage();\n      final String format = imageDetail.getFormat();\n      if(format==null || format.length()<=0)\n        throw new ImagingServiceException(\"Image format is required\");\n      try{\n        final IMAGE_FORMAT imgFormat = IMAGE_FORMAT.valueOf(format.toUpperCase());\n      }catch(final Exception ex){\n        throw new ImagingServiceException(\"Unsupported image format: \"+format);\n      }\n      if(imageDetail.getImportManifestUrl()==null)\n        throw new ImagingServiceException(\"Import manifest url is required\");\n      // TODO: manifest at S3\n      final DiskImageVolume volumeDetail = disk.getVolume();\n      if(volumeDetail==null)\n        throw new ImagingServiceException(\"Volume detail is required for disk image\");\n      \n      try{\n        /// TODO: should we assume the converted image is always larger than or equal to the uploaded image\n        final int volumeSize = volumeDetail.getSize();\n        final long imageBytes = imageDetail.getBytes();\n        final long volumeSizeInBytes = (volumeSize * (long) Math.pow(1024, 3));\n        if(imageBytes > volumeSizeInBytes)\n          throw new ImagingServiceException(\"Requested volume size is not enough to hold the image\");\n      }catch(final ImagingServiceException ex){\n        throw ex;\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to verify the requested volume size\");\n      }\n    }\n    final InstanceImagingTask transform = TypeMappers.transform( request, InstanceImagingTask.class );\n    try ( final TransactionResource db =\n        Entities.transactionFor( InstanceImagingTask.class ) ) {\n      try{\n        Entities.persist(transform);\n        db.commit( );\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to persist InstanceImagingTask\", ex);\n      }\n    }\n    return transform;\n  }","id":24095,"modified_method":"public static ImportInstanceImagingTask createImportInstanceTask(final ImportInstanceType request) \n      throws ImagingServiceException {\n    // verify the input\n    final ImportInstanceLaunchSpecification launchSpec = request.getLaunchSpecification();\n    if(launchSpec==null)\n      throw new ImagingServiceException(\"Launch specification is required\");\n    if(launchSpec.getArchitecture()==null || \n        !(\"i386\".equals(launchSpec.getArchitecture()) || \"x86_64\".equals(launchSpec.getArchitecture())))\n        throw new ImagingServiceException(\"Architecture should be either i386 or x86_64\");\n    if(launchSpec.getInstanceType()==null)\n      throw new ImagingServiceException(\"Instance type is required\");\n    \n\n    List<ClusterInfoType> clusters = null;\n    try{\n        clusters=EucalyptusActivityTasks.getInstance().describeAvailabilityZones(false);\n    }catch(final Exception ex){\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n          \"Failed to verify availability zone\");    \n    }\n    String availabilityZone = null;\n    if(launchSpec.getPlacement()!=null)\n      availabilityZone = launchSpec.getPlacement().getAvailabilityZone();\n    if(availabilityZone != null){\n      boolean zoneFound = false;\n      for(final ClusterInfoType cluster : clusters ){\n        if(availabilityZone.equals(cluster.getZoneName())){\n          zoneFound = true;\n          break;\n        }\n      }\n      if(!zoneFound)\n        throw new ImagingServiceException(String.format(\"The availability zone %s is not found\", availabilityZone));\n    }else{\n      if (clusters.size()>0){\n        //Default: Amazon EC2 chooses a zone for you.\n        availabilityZone = clusters.get(0).getZoneName();\n        if(request.getLaunchSpecification().getPlacement()==null)\n          request.getLaunchSpecification().setPlacement(new InstancePlacement());\n        request.getLaunchSpecification().getPlacement().setAvailabilityZone(availabilityZone);\n      }else\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"No availability zone is found in the Cloud\");\n    }\n    \n    List<DiskImage> disks = request.getDiskImageSet();\n    if(disks==null || disks.size()<=0)\n      throw new ImagingServiceException(\"Disk images are required\");\n    \n    for(final DiskImage disk : disks){\n      final DiskImageDetail imageDetail = disk.getImage();\n      final String format = imageDetail.getFormat();\n      if(format==null || format.length()<=0)\n        throw new ImagingServiceException(\"Image format is required\");\n      try{\n        final IMAGE_FORMAT imgFormat = IMAGE_FORMAT.valueOf(format.toUpperCase());\n      }catch(final Exception ex){\n        throw new ImagingServiceException(\"Unsupported image format: \"+format);\n      }\n      if(imageDetail.getImportManifestUrl()==null)\n        throw new ImagingServiceException(\"Import manifest url is required\");\n      // TODO: manifest at S3\n      final DiskImageVolume volumeDetail = disk.getVolume();\n      if(volumeDetail==null)\n        throw new ImagingServiceException(\"Volume detail is required for disk image\");\n      \n      try{\n        /// TODO: should we assume the converted image is always larger than or equal to the uploaded image\n        final int volumeSize = volumeDetail.getSize();\n        final long imageBytes = imageDetail.getBytes();\n        final long volumeSizeInBytes = (volumeSize * (long) Math.pow(1024, 3));\n        if(imageBytes > volumeSizeInBytes)\n          throw new ImagingServiceException(\"Requested volume size is not enough to hold the image\");\n      }catch(final ImagingServiceException ex){\n        throw ex;\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to verify the requested volume size\");\n      }\n    }\n    final ImportInstanceImagingTask transform = TypeMappers.transform( request, ImportInstanceImagingTask.class );\n    try ( final TransactionResource db =\n        Entities.transactionFor( ImportInstanceImagingTask.class ) ) {\n      try{\n        Entities.persist(transform);\n        db.commit( );\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to persist InstanceImagingTask\", ex);\n      }\n    }\n    return transform;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void setVolumeId(final VolumeImagingTask task, final String volumeId) \n      throws NoSuchElementException{\n    synchronized(lock){\n      try ( final TransactionResource db =\n          Entities.transactionFor( VolumeImagingTask.class ) ) {\n        try{\n          final VolumeImagingTask update = Entities.uniqueResult(task);\n          update.setVolumeId(volumeId);\n          Entities.persist(update);\n          db.commit();\n        }catch(final TransactionException ex){\n          throw Exceptions.toUndeclared(ex);\n        }\n      }\n    }\n  }","id":24096,"modified_method":"public static void setVolumeId(final ImportVolumeImagingTask task, final String volumeId) \n      throws NoSuchElementException{\n    synchronized(lock){\n      try ( final TransactionResource db =\n          Entities.transactionFor( ImportVolumeImagingTask.class ) ) {\n        try{\n          final ImportVolumeImagingTask update = Entities.uniqueResult(task);\n          update.setVolumeId(volumeId);\n          Entities.persist(update);\n          db.commit();\n        }catch(final TransactionException ex){\n          throw Exceptions.toUndeclared(ex);\n        }\n      }\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static List<ImagingTask> getImagingTasks(final OwnerFullName owner, final List<String> taskIdList){\n    synchronized(lock){\n      final List<ImagingTask> result = Lists.newArrayList();\n      try ( final TransactionResource db =\n          Entities.transactionFor( ImagingTask.class ) ) {\n        final ImagingTask sample = ImagingTask.named(owner);\n        final List<ImagingTask> tasks = Entities.query(sample, true);\n        if(taskIdList!=null && taskIdList.size()>0){\n          for(final ImagingTask candidate : tasks){\n            if(taskIdList.contains(candidate.getDisplayName()))\n              result.add(candidate);\n          }\n        }else\n          result.addAll(tasks);\n      }\n      return result;\n    }\n  }","id":24097,"modified_method":"/************************* Methods for disk imaging tasks ************************/\n  public static List<DiskImagingTask> getDiskImagingTasks(final OwnerFullName owner, final List<String> taskIdList){\n    synchronized(lock){\n      final List<DiskImagingTask> result = Lists.newArrayList();\n      try ( final TransactionResource db =\n          Entities.transactionFor( DiskImagingTask.class ) ) {\n        final DiskImagingTask sample = DiskImagingTask.named(owner);\n        final List<DiskImagingTask> tasks = Entities.query(sample, true);\n        if(taskIdList!=null && taskIdList.size()>0){\n          for(final DiskImagingTask candidate : tasks){\n            if(taskIdList.contains(candidate.getDisplayName()))\n              result.add(candidate);\n          }\n        }else\n          result.addAll(tasks);\n      }\n      return result;\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static InstanceStoreImagingTask createInstanceStoreImagingTask(final ImportImageType request) \n      throws ImagingServiceException{\n    /// sanity check\n    if(request.getImage().getDiskImageSet()==null || request.getImage().getDiskImageSet().size()<=0)\n      throw new ImagingServiceException(\"Image detail for imported image is required\");\n    if(request.getImage().getConvertedImage()==null)\n      throw new ImagingServiceException(\"Image detail for converted image is required\");\n    \n    for(final DiskImageDetail image : request.getImage().getDiskImageSet()){\n      final String format = image.getFormat();\n      final String manifestUrl = image.getImportManifestUrl();\n\n      if(format==null || format.length()<=0)\n        throw new ImagingServiceException(\"Image format is required\");\n      try{\n        final IMAGE_FORMAT imgFormat = IMAGE_FORMAT.valueOf(format.toUpperCase());\n      }catch(final Exception ex){\n        throw new ImagingServiceException(\"Unsupported image format\");\n      }\n      if(manifestUrl == null || manifestUrl.length()<=0)\n        throw new ImagingServiceException(\"Import manifest url is required\");\n    }\n    \n    InstanceStoreImagingTask transform = null;\n    try{\n      transform =TypeMappers.transform( request, InstanceStoreImagingTask.class );\n    }catch(final Exception ex){\n      if(ex.getCause() instanceof ImagingServiceException)\n        throw (ImagingServiceException) ex.getCause();\n      else\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"Failed to create InstanceStoreImagingTask\", ex);\n    }\n    try ( final TransactionResource db =\n        Entities.transactionFor( InstanceStoreImagingTask.class ) ) {\n      try{\n        Entities.persist(transform);\n        db.commit( );\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to persist EMIConversionImagingTask\", ex);\n      }\n    }\n    return transform;\n  }","id":24098,"modified_method":"public static DiskImagingTask createDiskImagingTask(final ImportImageType request) \n      throws ImagingServiceException{\n    /// sanity check\n    if(request.getImage().getDiskImageSet()==null || request.getImage().getDiskImageSet().size()<=0)\n      throw new ImagingServiceException(\"Image detail for imported image is required\");\n    if(request.getImage().getConvertedImage()==null)\n      throw new ImagingServiceException(\"Image detail for converted image is required\");\n    \n    for(final ImportDiskImageDetail image : request.getImage().getDiskImageSet()){\n      final String format = image.getFormat();\n      final String manifestUrl = image.getDownloadManifestUrl();\n      final String imageId = image.getId();\n\n      if(format==null || format.length()<=0)\n        throw new ImagingServiceException(\"Image format is required\");\n      try{\n        final IMAGE_FORMAT imgFormat = IMAGE_FORMAT.valueOf(format.toUpperCase());\n      }catch(final Exception ex){\n        throw new ImagingServiceException(\"Unsupported image format\");\n      }\n      if(manifestUrl == null || manifestUrl.length()<=0)\n        throw new ImagingServiceException(\"Import manifest url is required\");\n      if(imageId == null || imageId.length()<=0)\n        throw new ImagingServiceException(\"Import image's id is required\");\n    }\n    \n    final ConvertedImageDetail converted = request.getImage().getConvertedImage();\n    final String bucket = converted.getBucket();\n    final String prefix = converted.getPrefix();\n    final String arch = converted.getArchitecture();\n    \n    if(bucket==null || bucket.length()<=0)\n      throw new ImagingServiceException(\"bucket name must be specified\");\n    if(prefix==null || prefix.length()<=0)\n      throw new ImagingServiceException(\"prefix must be specified\");\n    if(arch==null || arch.length()<=0)\n      throw new ImagingServiceException(\"architecture must be specified\");\n    \n    DiskImagingTask transform = null;\n    try{\n      transform =TypeMappers.transform( request, DiskImagingTask.class );\n    }catch(final Exception ex){\n      if(ex.getCause() instanceof ImagingServiceException)\n        throw (ImagingServiceException) ex.getCause();\n      else\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"Failed to create DiskImagingTask\", ex);\n    }\n    try ( final TransactionResource db =\n        Entities.transactionFor( DiskImagingTask.class ) ) {\n      try{\n        Entities.persist(transform);\n        db.commit( );\n      }catch(final Exception ex){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \n            \"Failed to persist DiskImagingTask\", ex);\n      }\n    }\n    return transform;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void updateVolumeStatus(final ImagingTask imagingTask, \n      final String volumeId, ImportTaskState state, final String statusMessage){\n    try ( final TransactionResource db =\n        Entities.transactionFor(ImagingTask.class ) ) {\n      try{\n        final ImagingTask entity = Entities.uniqueResult(imagingTask);\n        final ConversionTask task = entity.getTask();\n        if(task.getImportInstance()!=null){\n          final List<ImportInstanceVolumeDetail> volumes = task.getImportInstance().getVolumes();\n          for(final ImportInstanceVolumeDetail volumeDetail : volumes){\n            if(volumeDetail.getVolume()!=null && volumeId.equals(volumeDetail.getVolume().getId())){\n              volumeDetail.setStatus(state.getExternalVolumeStateName());\n              if(statusMessage!=null)\n                volumeDetail.setStatusMessage(statusMessage);\n              else\n                volumeDetail.setStatusMessage(\"\");\n              break;\n            }else if (imagingTask instanceof InstanceStoreImagingTask){\n              volumeDetail.setStatus(state.getExternalVolumeStateName());\n              if(statusMessage!=null)\n                volumeDetail.setStatusMessage(statusMessage);\n              else\n                volumeDetail.setStatusMessage(\"\");\n            }\n          }\n          entity.serializeTaskToJSON();\n          Entities.persist(entity);\n          db.commit();\n        }\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","id":24099,"modified_method":"public static void updateVolumeStatus(final VolumeImagingTask imagingTask, \n      final String volumeId, ImportTaskState state, final String statusMessage){\n    try ( final TransactionResource db =\n        Entities.transactionFor(VolumeImagingTask.class ) ) {\n      try{\n        final VolumeImagingTask entity = Entities.uniqueResult(imagingTask);\n        final ConversionTask task = (ConversionTask) entity.getTask();\n        if(task.getImportInstance()!=null){\n          final List<ImportInstanceVolumeDetail> volumes = task.getImportInstance().getVolumes();\n          for(final ImportInstanceVolumeDetail volumeDetail : volumes){\n            if(volumeDetail.getVolume()!=null && volumeId.equals(volumeDetail.getVolume().getId())){\n              volumeDetail.setStatus(state.getExternalVolumeStateName());\n              if(statusMessage!=null)\n                volumeDetail.setStatusMessage(statusMessage);\n              else\n                volumeDetail.setStatusMessage(\"\");\n              break;\n            }\n          }\n          entity.serializeTaskToJSON();\n          Entities.persist(entity);\n          db.commit();\n        }\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void addSnapshotId(final InstanceImagingTask imagingTask, final String snapshotId){\n    try ( final TransactionResource db =\n        Entities.transactionFor(InstanceImagingTask.class ) ) {\n      try{\n        final InstanceImagingTask entity = Entities.uniqueResult(imagingTask);\n        entity.addSnapshotId(snapshotId);\n        Entities.persist(entity);\n        db.commit();\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","id":24100,"modified_method":"/************************* Methods for import-instance imaging tasks ************************/\n  public static void addSnapshotId(final ImportInstanceImagingTask imagingTask, final String snapshotId){\n    try ( final TransactionResource db =\n        Entities.transactionFor(ImportInstanceImagingTask.class ) ) {\n      try{\n        final ImportInstanceImagingTask entity = Entities.uniqueResult(imagingTask);\n        entity.addSnapshotId(snapshotId);\n        Entities.persist(entity);\n        db.commit();\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static boolean isConversionDone(final ImagingTask imagingTask){\n    try ( final TransactionResource db =\n        Entities.transactionFor(ImagingTask.class ) ) {\n      try{\n        final ImagingTask entity = Entities.uniqueResult(imagingTask);\n        final ConversionTask task = entity.getTask();\n        if(task.getImportVolume()!=null){\n          return  (ImportTaskState.COMPLETED.equals(entity.getState()) \n              || ImportTaskState.CANCELLED.equals(entity.getState())\n              || ImportTaskState.FAILED.equals(entity.getState()));\n        }else if (task.getImportInstance()!=null){\n          final List<ImportInstanceVolumeDetail> volumes = task.getImportInstance().getVolumes();\n          for(final ImportInstanceVolumeDetail volumeDetail : volumes){\n            if(\"active\".equals(volumeDetail.getStatus()))\n              return false;\n          }\n          return true;\n        }else\n          return true;\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","id":24101,"modified_method":"public static boolean isConversionDone(final VolumeImagingTask imagingTask){\n    try ( final TransactionResource db =\n        Entities.transactionFor(VolumeImagingTask.class ) ) {\n      try{\n        final VolumeImagingTask entity = Entities.uniqueResult(imagingTask);\n        final ConversionTask task = (ConversionTask) entity.getTask();\n        if(task.getImportVolume()!=null){\n          return  (ImportTaskState.COMPLETED.equals(entity.getState()) \n              || ImportTaskState.CANCELLED.equals(entity.getState())\n              || ImportTaskState.FAILED.equals(entity.getState()));\n        }else if (task.getImportInstance()!=null){\n          final List<ImportInstanceVolumeDetail> volumes = task.getImportInstance().getVolumes();\n          for(final ImportInstanceVolumeDetail volumeDetail : volumes){\n            if(\"active\".equals(volumeDetail.getStatus()))\n              return false;\n          }\n          return true;\n        }else\n          return true;\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void addDownloadManifestUrl(final ImagingTask task, \n      final String importManifestUrl, final String downloadManifestUrl){\n    synchronized(lock){\n      try ( final TransactionResource db =\n          Entities.transactionFor(ImagingTask.class ) ) {\n        try{\n          final ImagingTask entity = Entities.uniqueResult(task);\n          entity.addDownloadManifestUrl(importManifestUrl, downloadManifestUrl);\n          db.commit();\n        }catch(final TransactionException ex){\n          throw Exceptions.toUndeclared(ex);\n        }\n      }\n    }\n  }","id":24102,"modified_method":"public static void addDownloadManifestUrl(final VolumeImagingTask task, \n      final String importManifestUrl, final String downloadManifestUrl){\n    synchronized(lock){\n      try ( final TransactionResource db =\n          Entities.transactionFor(VolumeImagingTask.class ) ) {\n        try{\n          final VolumeImagingTask entity = Entities.uniqueResult(task);\n          entity.addDownloadManifestUrl(importManifestUrl, downloadManifestUrl);\n          db.commit();\n        }catch(final TransactionException ex){\n          throw Exceptions.toUndeclared(ex);\n        }\n      }\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static List<ImagingTask> getImagingTasks(){\n    synchronized(lock){\n      List<ImagingTask> result = Lists.newArrayList();\n      try ( final TransactionResource db =\n          Entities.transactionFor( ImagingTask.class ) ) {\n        result = Entities.query(ImagingTask.named(), true);\n      }\n      return result;\n    }\n  }","id":24103,"modified_method":"/************************* Methods for generic imaging tasks ************************/\n  public static List<ImagingTask> getImagingTasks(){\n    synchronized(lock){\n      List<ImagingTask> result = Lists.newArrayList();\n      try ( final TransactionResource db =\n          Entities.transactionFor( ImagingTask.class ) ) {\n        result = Entities.query(ImagingTask.named(), true);\n      }\n      return result;\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void setImageId(final InstanceImagingTask imagingTask, final String imageId){\n    try ( final TransactionResource db =\n        Entities.transactionFor(InstanceImagingTask.class ) ) {\n      try{\n        final InstanceImagingTask entity = Entities.uniqueResult(imagingTask);\n        entity.setImageId(imageId);\n        Entities.persist(entity);\n        db.commit();\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","id":24104,"modified_method":"public static void setImageId(final ImportInstanceImagingTask imagingTask, final String imageId){\n    try ( final TransactionResource db =\n        Entities.transactionFor(ImportInstanceImagingTask.class ) ) {\n      try{\n        final ImportInstanceImagingTask entity = Entities.uniqueResult(imagingTask);\n        entity.setImageId(imageId);\n        Entities.persist(entity);\n        db.commit();\n      }catch(final Exception ex){\n        throw Exceptions.toUndeclared(ex);\n      }\n    }\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * <ol>\n   * <li>Persist import instance request state\n   * <\/ol>\n   */\n  public ImportInstanceResponseType ImportInstance( final ImportInstanceType request ) throws Exception {\n    final ImportInstanceResponseType reply = request.getReply( );\n    try{\n      if (!Bootstrap.isFinished() ||\n           !Topology.isEnabled( Imaging.class )){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"For import, Imaging service should be enabled\");\n      }\n    }catch(final Exception ex){\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"For import, Imaging service should be enabled\");\n    }\n    \n    try{\n      if(ImagingServiceLaunchers.getInstance().shouldEnable())\n        ImagingServiceLaunchers.getInstance().enable();\n    }catch(Exception ex){\n      LOG.error(\"Failed to enable imaging service workers\");\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"Could not launch imaging service workers\");\n    }\n    \n    InstanceImagingTask task = null;\n    try{\n      task = ImagingTasks.createImportInstanceTask(request);\n    }catch(final ImagingServiceException ex){\n       throw ex;\n    }catch(final Exception ex){\n      LOG.error(\"Failed to import instance\", ex);\n      throw new ImagingServiceException(\"Failed to import instance\", ex);\n    }\n    reply.setConversionTask(task.getTask());\n    reply.set_return(true);  \n    return reply;\n  }","id":24105,"modified_method":"/**\n   * <ol>\n   * <li>Persist import instance request state\n   * <\/ol>\n   */\n  public ImportInstanceResponseType ImportInstance( final ImportInstanceType request ) throws Exception {\n    final ImportInstanceResponseType reply = request.getReply( );\n    try{\n      if (!Bootstrap.isFinished() ||\n           !Topology.isEnabled( Imaging.class )){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"For import, Imaging service should be enabled\");\n      }\n    }catch(final Exception ex){\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"For import, Imaging service should be enabled\");\n    }\n    \n    try{\n      if(ImagingServiceLaunchers.getInstance().shouldEnable())\n        ImagingServiceLaunchers.getInstance().enable();\n    }catch(Exception ex){\n      LOG.error(\"Failed to enable imaging service workers\");\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"Could not launch imaging service workers\");\n    }\n    \n    ImportInstanceImagingTask task = null;\n    try{\n      task = ImagingTasks.createImportInstanceTask(request);\n    }catch(final ImagingServiceException ex){\n       throw ex;\n    }catch(final Exception ex){\n      LOG.error(\"Failed to import instance\", ex);\n      throw new ImagingServiceException(\"Failed to import instance\", ex);\n    }\n    reply.setConversionTask((ConversionTask) task.getTask());\n    reply.set_return(true);  \n    return reply;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * <ol>\n   * <li>Describe import tasks from persisted state\n   * <\/ol>\n   */\n  public DescribeConversionTasksResponseType DescribeConversionTasks( DescribeConversionTasksType request ) throws Exception {\n    LOG.debug( request );\n    DescribeConversionTasksResponseType reply = request.getReply( );\n    Context ctx = Contexts.lookup( );\n    boolean verbose = request.getConversionTaskIdSet( ).remove( \"verbose\" );\n    Collection<String> ownerInfo = ( ctx.isAdministrator( ) && verbose )\n      ? Collections.<String> emptyList( )\n      : Collections.singleton( ctx.getAccount( ).getAccountNumber( ) );\n    //TODO: extends for volumes\n    final Predicate<? super ImagingTask> requestedAndAccessible = RestrictedTypes.filteringFor( ImagingTask.class )\n                                                                                 .byId( request.getConversionTaskIdSet( ) )\n                                                                                 .byOwningAccount( ownerInfo )\n                                                                                 .byPrivileges( )\n                                                                                 .buildPredicate( );\n    \n    Iterable<ImagingTask> tasksToList = ImagingTasks.getImagingTasks(ctx.getUserFullName(), request.getConversionTaskIdSet());\n    for ( ImagingTask task : Iterables.filter( tasksToList, requestedAndAccessible ) ) {\n      ConversionTask t = task.getTask( );\n      reply.getConversionTasks().add( t );\n    }\n    return reply;\n  }","id":24106,"modified_method":"/**\n   * <ol>\n   * <li>Describe import tasks from persisted state\n   * <\/ol>\n   */\n  public DescribeConversionTasksResponseType DescribeConversionTasks( DescribeConversionTasksType request ) throws Exception {\n    LOG.debug( request );\n    DescribeConversionTasksResponseType reply = request.getReply( );\n    Context ctx = Contexts.lookup( );\n    boolean verbose = request.getConversionTaskIdSet( ).remove( \"verbose\" );\n    Collection<String> ownerInfo = ( ctx.isAdministrator( ) && verbose )\n      ? Collections.<String> emptyList( )\n      : Collections.singleton( ctx.getAccount( ).getAccountNumber( ) );\n    //TODO: extends for volumes\n    final Predicate<? super VolumeImagingTask> requestedAndAccessible = RestrictedTypes.filteringFor( VolumeImagingTask.class )\n                                                                                 .byId( request.getConversionTaskIdSet( ) )\n                                                                                 .byOwningAccount( ownerInfo )\n                                                                                 .byPrivileges( )\n                                                                                 .buildPredicate( );\n    \n    Iterable<VolumeImagingTask> tasksToList = ImagingTasks.getVolumeImagingTasks(ctx.getUserFullName(), request.getConversionTaskIdSet());\n    for ( VolumeImagingTask task : Iterables.filter( tasksToList, requestedAndAccessible ) ) {\n      ConversionTask t = (ConversionTask) task.getTask( );\n      reply.getConversionTasks().add( t );\n    }\n    return reply;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * <ol>\n   * <li>Persist import volume request state\n   * <\/ol>\n   */\n  public static ImportVolumeResponseType ImportVolume( ImportVolumeType request ) throws Exception {\n    final ImportVolumeResponseType reply = request.getReply( );\n    try{\n      if (!Bootstrap.isFinished() ||\n           !Topology.isEnabled( Imaging.class )){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"For import, Imaging service should be enabled\");\n      }\n    }catch(final Exception ex){\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"For import, Imaging service should be enabled\");\n    }\n    \n    try{\n      if(ImagingServiceLaunchers.getInstance().shouldEnable())\n        ImagingServiceLaunchers.getInstance().enable();\n    }catch(Exception ex){\n      LOG.error(\"Failed to enable imaging service workers\");\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"Could not launch imaging service workers\");\n    }\n\n    VolumeImagingTask task = null;\n    try{\n      task = ImagingTasks.createImportVolumeTask(request);\n    }catch(final ImagingServiceException ex){\n       throw ex;\n    }catch(final Exception ex){\n      LOG.error(\"Failed to import volume\", ex);\n      throw new ImagingServiceException(\"Failed to import volume\", ex);\n    }\n    reply.setConversionTask(task.getTask());\n    reply.set_return(true);\n    return reply;\n  }","id":24107,"modified_method":"/**\n   * <ol>\n   * <li>Persist import volume request state\n   * <\/ol>\n   */\n  public static ImportVolumeResponseType ImportVolume( ImportVolumeType request ) throws Exception {\n    final ImportVolumeResponseType reply = request.getReply( );\n    try{\n      if (!Bootstrap.isFinished() ||\n           !Topology.isEnabled( Imaging.class )){\n        throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"For import, Imaging service should be enabled\");\n      }\n    }catch(final Exception ex){\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"For import, Imaging service should be enabled\");\n    }\n    \n    try{\n      if(ImagingServiceLaunchers.getInstance().shouldEnable())\n        ImagingServiceLaunchers.getInstance().enable();\n    }catch(Exception ex){\n      LOG.error(\"Failed to enable imaging service workers\");\n      throw new ImagingServiceException(ImagingServiceException.INTERNAL_SERVER_ERROR, \"Could not launch imaging service workers\");\n    }\n\n    ImportVolumeImagingTask task = null;\n    try{\n      task = ImagingTasks.createImportVolumeTask(request);\n    }catch(final ImagingServiceException ex){\n       throw ex;\n    }catch(final Exception ex){\n      LOG.error(\"Failed to import volume\", ex);\n      throw new ImagingServiceException(\"Failed to import volume\", ex);\n    }\n    reply.setConversionTask((ConversionTask) task.getTask());\n    reply.set_return(true);\n    return reply;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    protected ImagingTask getNext() {\n      List<ImagingTask> allTasks = null;\n      List<ImagingTask> imagePendingTasks = Lists.newArrayList();\n      List<ImagingTask> pendingTasks = Lists.newArrayList();\n      // pick a pending task whose timestamp is the oldest\n      try{\n        allTasks = ImagingTasks.getImagingTasks();\n        for(final ImagingTask t : allTasks){\n          if((t instanceof InstanceStoreImagingTask) && ImportTaskState.PENDING.equals(t.getState()))\n            imagePendingTasks.add(t);\n          \n          if(ImportTaskState.PENDING.equals(t.getState()))\n            pendingTasks.add(t);\n          else if (ImportTaskState.CONVERTING.equals(t.getState()) && \n              ((t instanceof InstanceImagingTask) && !(t instanceof InstanceStoreImagingTask)))\n            pendingTasks.add(t); // more than one volumes should be processed by worker\n        }\n\n        ImagingTask oldestTask = null;\n        Date oldest = new Date(Long.MAX_VALUE) ;\n        for(final ImagingTask task : imagePendingTasks){\n          if (oldest.after(task.getCreationTimestamp())){\n            oldest = task.getCreationTimestamp();\n            oldestTask = task;\n          }\n        }\n        if(oldestTask!=null)\n          return oldestTask;\n        \n        for(final ImagingTask task : pendingTasks){\n          if (oldest.after(task.getCreationTimestamp())){\n            oldest = task.getCreationTimestamp();\n            oldestTask = task;\n          }\n        }\n        return oldestTask;\n      }catch(final Exception ex){\n        LOG.error(\"failed to schedule the task to imaging worker\", ex);\n        return null;\n      }\n    }","id":24108,"modified_method":"@Override\n    protected ImagingTask getNext() {\n      List<ImagingTask> allTasks = null;\n      List<ImagingTask> imagePendingTasks = Lists.newArrayList();\n      List<ImagingTask> pendingTasks = Lists.newArrayList();\n      // pick a pending task whose timestamp is the oldest\n      try{\n        allTasks = ImagingTasks.getImagingTasks();\n        for(final ImagingTask t : allTasks){\n          if((t instanceof DiskImagingTask) && ImportTaskState.PENDING.equals(t.getState()))\n            imagePendingTasks.add(t);\n          \n          if(ImportTaskState.PENDING.equals(t.getState()))\n            pendingTasks.add(t);\n          else if (ImportTaskState.CONVERTING.equals(t.getState()) && \n              (t instanceof ImportInstanceImagingTask))\n            pendingTasks.add(t); // more than one volumes should be processed by worker\n        }\n\n        ImagingTask oldestTask = null;\n        Date oldest = new Date(Long.MAX_VALUE) ;\n        for(final ImagingTask task : imagePendingTasks){\n          if (oldest.after(task.getCreationTimestamp())){\n            oldest = task.getCreationTimestamp();\n            oldestTask = task;\n          }\n        }\n        if(oldestTask!=null)\n          return oldestTask;\n        \n        for(final ImagingTask task : pendingTasks){\n          if (oldest.after(task.getCreationTimestamp())){\n            oldest = task.getCreationTimestamp();\n            oldestTask = task;\n          }\n        }\n        return oldestTask;\n      }catch(final Exception ex){\n        LOG.error(\"failed to schedule the task to imaging worker\", ex);\n        return null;\n      }\n    }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public ImagingTask getNext() {\n      List<ImagingTask> allTasks = null;\n      List<ImagingTask> pendingTasks = Lists.newArrayList();\n      // pick a pending task whose timestamp is the oldest\n      try{\n        allTasks = ImagingTasks.getImagingTasks();\n        for(final ImagingTask t : allTasks){\n          if(ImportTaskState.PENDING.equals(t.getState()))\n            pendingTasks.add(t);\n          else if (ImportTaskState.CONVERTING.equals(t.getState()) && t instanceof InstanceImagingTask)\n            pendingTasks.add(t); // more than one volumes should be processed by worker\n        }\n\n        ImagingTask oldestTask = null;\n        Date oldest = new Date(Long.MAX_VALUE) ;\n        for(final ImagingTask task : pendingTasks){\n          if (oldest.after(task.getCreationTimestamp())){\n            oldest = task.getCreationTimestamp();\n            oldestTask = task;\n          }\n        }\n        return oldestTask;\n      }catch(final Exception ex){\n        LOG.error(\"failed to schedule the task to imaging worker\", ex);\n        return null;\n      }\n    }","id":24109,"modified_method":"@Override\n    public ImagingTask getNext() {\n      List<ImagingTask> allTasks = null;\n      List<ImagingTask> pendingTasks = Lists.newArrayList();\n      // pick a pending task whose timestamp is the oldest\n      try{\n        allTasks = ImagingTasks.getImagingTasks();\n        for(final ImagingTask t : allTasks){\n          if(ImportTaskState.PENDING.equals(t.getState()))\n            pendingTasks.add(t);\n          else if (ImportTaskState.CONVERTING.equals(t.getState()) && t instanceof ImportInstanceImagingTask)\n            pendingTasks.add(t); // more than one volumes should be processed by worker\n        }\n\n        ImagingTask oldestTask = null;\n        Date oldest = new Date(Long.MAX_VALUE) ;\n        for(final ImagingTask task : pendingTasks){\n          if (oldest.after(task.getCreationTimestamp())){\n            oldest = task.getCreationTimestamp();\n            oldestTask = task;\n          }\n        }\n        return oldestTask;\n      }catch(final Exception ex){\n        LOG.error(\"failed to schedule the task to imaging worker\", ex);\n        return null;\n      }\n    }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected VolumeImagingTask( ) {}","id":24110,"modified_method":"protected VolumeImagingTask( ) {\n    this(null,null);\n    task = null;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setVolumeId( String volumeId ) {\n    this.getTask( ).getImportVolume( ).getVolume( ).setId( volumeId );\n    this.serializeTaskToJSON();\n  }","id":24111,"modified_method":"static VolumeImagingTask named(final String taskId){\n    return new VolumeImagingTask(null, taskId);\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected VolumeImagingTask( OwnerFullName ownerFullName, ConversionTask conversionTask) {\n    super( ownerFullName, conversionTask, ImportTaskState.NEW, 0L );\n  }","id":24112,"modified_method":"protected VolumeImagingTask( OwnerFullName ownerFullName, ConversionTask task, ImportTaskState state, long bytesProcessed ) {\n    super( ownerFullName, task.getConversionTaskId() );\n    this.task = task;\n    this.setState( state );\n    this.bytesProcessed = bytesProcessed;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static VolumeImagingTask named(final OwnerFullName owner, final String taskId){\n    return new VolumeImagingTask(owner, taskId);\n  }","id":24113,"modified_method":"static VolumeImagingTask named(final OwnerFullName owner, final String taskId){\n    return new VolumeImagingTask(owner,  taskId);\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Long getBytes( ) {\n    try{\n      return this.getTask().getImportVolume().getBytesConverted();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24114,"modified_method":"public long getBytesProcessed( ) {\n    return bytesProcessed;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getImportManifestUrl( ) {\n    try{\n      return this.getTask().getImportVolume().getImage().getImportManifestUrl();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24115,"modified_method":"public List<ImportToDownloadManifestUrlCoreView> getDownloadManifestUrl(){\n    return this.view.getDownloadManifstUrls();\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected VolumeImagingTask(final OwnerFullName owner, final String taskId){\n    super(owner, taskId);\n  }","id":24116,"modified_method":"VolumeImagingTask( OwnerFullName owner, String displayName ) {\n    super( owner, displayName );\n    this.bytesProcessed = null;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setImportManifestUrl( String importManifestUrl ) {\n    this.getTask().getImportVolume().getImage().setImportManifestUrl(importManifestUrl);\n    this.serializeTaskToJSON();\n  }","id":24117,"modified_method":"public String getDownloadManifestUrl(final String importManifestUrl){\n    for(final ImportToDownloadManifestUrlCoreView mapping : this.view.getDownloadManifstUrls()){\n      if(importManifestUrl.equals(mapping.getImportManifestUrl()))\n        return mapping.getDownloadManifestUrl();\n    }\n    return null;\n  }","commit_id":"32da33a82543e815d77d5d2f083465a64d7b2623","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Date getExpirationTime(){\n    try{\n      return (new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\")).parse(this.task.getExpirationTime());\n    }catch(final Exception ex){\n      throw Exceptions.toUndeclared(ex);\n    }\n  }","id":24118,"modified_method":"public Date getExpirationTime(){\n    try{\n      return (new SimpleDateFormat(\"EEE MMM dd HH:mm:ss zzz yyyy\")).parse(this.getTask().getExpirationTime());\n    }catch(final Exception ex){\n      throw Exceptions.toUndeclared(ex);\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void cleanUp(){\n    final ImportInstanceTaskDetails instanceDetails = \n        this.getTask().getImportInstance();\n    if(instanceDetails.getVolumes()==null)\n      return;\n    for(final ImportInstanceVolumeDetail volumeDetail : instanceDetails.getVolumes()){\n      if(volumeDetail.getVolume()!=null && volumeDetail.getVolume().getId()!=null){\n        try{\n          EucalyptusActivityTasks.getInstance().deleteVolumeAsUser(this.getOwnerUserId(), volumeDetail.getVolume().getId());\n        }catch(final Exception ex){\n          LOG.warn(String.format(\"Failed to delete the volume %s for import task %s\", \n              volumeDetail.getVolume().getId(), this.getDisplayName()));\n        }\n      }\n    }\n  }","id":24119,"modified_method":"@Override\n  public void cleanUp(){\n    final ImportInstanceTaskDetails instanceDetails = \n        ((ConversionTask)this.getTask()).getImportInstance();\n    if(instanceDetails.getVolumes()==null)\n      return;\n    for(final ImportInstanceVolumeDetail volumeDetail : instanceDetails.getVolumes()){\n      if(volumeDetail.getVolume()!=null && volumeDetail.getVolume().getId()!=null){\n        try{\n          EucalyptusActivityTasks.getInstance().deleteVolumeAsUser(this.getOwnerUserId(), volumeDetail.getVolume().getId());\n        }catch(final Exception ex){\n          LOG.warn(String.format(\"Failed to delete the volume %s for import task %s\", \n              volumeDetail.getVolume().getId(), this.getDisplayName()));\n        }\n      }\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public List<ImportInstanceVolumeDetail> getVolumes(){\n    final ImportInstanceTaskDetails importTask = this.getTask().getImportInstance();\n    return importTask.getVolumes();\n  }","id":24120,"modified_method":"public List<ImportInstanceVolumeDetail> getVolumes(){\n    final ImportInstanceTaskDetails importTask = ((ConversionTask)this.getTask()).getImportInstance();\n    return importTask.getVolumes();\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getFormat( ) {\n    try{\n      return this.getTask().getImportVolume().getImage().getFormat();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24121,"modified_method":"public String getFormat( ) {\n    try{\n      return ((ConversionTask)this.getTask()).getImportVolume().getImage().getFormat();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setBytes( Long bytes ) {\n    this.getTask().getImportVolume().setBytesConverted(bytes);\n    this.serializeTaskToJSON();\n  }","id":24122,"modified_method":"public void setBytes( Long bytes ) {\n    ((ConversionTask)this.getTask()).getImportVolume().setBytesConverted(bytes);\n    this.serializeTaskToJSON();\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setFormat( String format ) {\n    this.getTask().getImportVolume().getImage().setFormat(format);\n    this.serializeTaskToJSON();\n  }","id":24123,"modified_method":"public void setFormat( String format ) {\n    ((ConversionTask)this.getTask()).getImportVolume().getImage().setFormat(format);\n    this.serializeTaskToJSON();\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getAvailabilityZone( ) {\n    try{\n      return this.getTask().getImportVolume().getAvailabilityZone();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24124,"modified_method":"public String getAvailabilityZone( ) {\n    try{\n      return ((ConversionTask)this.getTask()).getImportVolume().getAvailabilityZone();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void setVolumeSize( Integer volumeSize ) {\n    this.getTask().getImportVolume().getVolume().setSize(volumeSize);\n    this.serializeTaskToJSON();\n  }","id":24125,"modified_method":"private void setVolumeSize( Integer volumeSize ) {\n    ((ConversionTask)this.getTask()).getImportVolume().getVolume().setSize(volumeSize);\n    this.serializeTaskToJSON();\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setVolumeId( String volumeId ) {\n    this.getTask( ).getImportVolume( ).getVolume( ).setId( volumeId );\n    this.serializeTaskToJSON();\n  }","id":24126,"modified_method":"public void setVolumeId( String volumeId ) {\n    ((ConversionTask)this.getTask()).getImportVolume( ).getVolume( ).setId( volumeId );\n    this.serializeTaskToJSON();\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setDescription( String description ) {\n    this.getTask().getImportVolume().setDescription(description);\n    this.serializeTaskToJSON();\n  }","id":24127,"modified_method":"public void setDescription( String description ) {\n    ((ConversionTask)this.getTask()).getImportVolume().setDescription(description);\n    this.serializeTaskToJSON();\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void setImportManifestUrl( String importManifestUrl ) {\n    this.getTask().getImportVolume().getImage().setImportManifestUrl(importManifestUrl);\n    this.serializeTaskToJSON();\n  }","id":24128,"modified_method":"public void setImportManifestUrl( String importManifestUrl ) {\n    ((ConversionTask)this.getTask()).getImportVolume().getImage().setImportManifestUrl(importManifestUrl);\n    this.serializeTaskToJSON();\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public void cleanUp(){\n    final ImportVolumeTaskDetails volumeDetails = \n        this.getTask().getImportVolume();\n    if(volumeDetails.getVolume()!=null &&\n        volumeDetails.getVolume().getId()!=null){\n      try{\n        EucalyptusActivityTasks.getInstance().deleteVolumeAsUser(this.getOwnerUserId(), volumeDetails.getVolume().getId());\n      }catch(final Exception ex){\n        LOG.warn(String.format(\"Failed to delete the volume %s for import task %s\", volumeDetails.getVolume().getId(), this.getDisplayName()));\n      }\n    }\n  }","id":24129,"modified_method":"@Override\n  public void cleanUp(){\n    final ImportVolumeTaskDetails volumeDetails = \n        ((ConversionTask)this.getTask()).getImportVolume();\n    if(volumeDetails.getVolume()!=null &&\n        volumeDetails.getVolume().getId()!=null){\n      try{\n        EucalyptusActivityTasks.getInstance().deleteVolumeAsUser(this.getOwnerUserId(), volumeDetails.getVolume().getId());\n      }catch(final Exception ex){\n        LOG.warn(String.format(\"Failed to delete the volume %s for import task %s\", volumeDetails.getVolume().getId(), this.getDisplayName()));\n      }\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Long getBytes( ) {\n    try{\n      return this.getTask().getImportVolume().getBytesConverted();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24130,"modified_method":"public Long getBytes( ) {\n    try{\n      return ((ConversionTask)this.getTask()).getImportVolume().getBytesConverted();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getVolumeId( ) {\n    try{\n      return this.getTask().getImportVolume().getVolume().getId();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24131,"modified_method":"public String getVolumeId( ) {\n    try{\n      return ((ConversionTask)this.getTask()).getImportVolume().getVolume().getId();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getDescription( ) {\n    try{\n      return this.getTask().getImportVolume().getDescription();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24132,"modified_method":"public String getDescription( ) {\n    try{\n      return ((ConversionTask)this.getTask()).getImportVolume().getDescription();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void setAvailabilityZone( String availabilityZone ) {\n    this.getTask().getImportVolume().setAvailabilityZone(availabilityZone);\n    this.serializeTaskToJSON();\n  }","id":24133,"modified_method":"private void setAvailabilityZone( String availabilityZone ) {\n    ((ConversionTask)this.getTask()).getImportVolume().setAvailabilityZone(availabilityZone);\n    this.serializeTaskToJSON();\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public Integer getVolumeSize( ) {\n    try{\n      return this.getTask().getImportVolume().getVolume().getSize();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24134,"modified_method":"public Integer getVolumeSize( ) {\n    try{\n      return ((ConversionTask)this.getTask()).getImportVolume().getVolume().getSize();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getImportManifestUrl( ) {\n    try{\n      return this.getTask().getImportVolume().getImage().getImportManifestUrl();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","id":24135,"modified_method":"public String getImportManifestUrl( ) {\n    try{\n      return ((ConversionTask)this.getTask()).getImportVolume().getImage().getImportManifestUrl();\n    }catch(final Exception ex){\n      return null;\n    }\n  }","commit_id":"8db06af79f0ec7bb886b24e25f8b692ea2234119","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void merge(int min, int max, byte[] cryptoKey, boolean dontCompress, boolean definitive) {\n        if(this.definitive) {\n            Logger.warning(this, \"merge() after definitive\", new Exception(\"debug\"));\n            return;\n        }\n        assert(min != InsertContext.CompatibilityMode.COMPAT_CURRENT.ordinal());\n        assert(max != InsertContext.CompatibilityMode.COMPAT_CURRENT.ordinal());\n        if(definitive) this.definitive = true;\n        if(!dontCompress) this.dontCompress = false;\n        if(min > this.min) this.min = min;\n        if(max < this.max || this.max == InsertContext.CompatibilityMode.COMPAT_UNKNOWN.ordinal()) this.max = max;\n        if(this.cryptoKey == null) {\n            this.cryptoKey = cryptoKey;\n        } else if(cryptoKey != null && !Arrays.equals(this.cryptoKey, cryptoKey)) {\n            Logger.error(this, \"Two different crypto keys!\");\n            this.cryptoKey = null;\n        }\n    }","id":24136,"modified_method":"public void merge(short min, short max, byte[] cryptoKey, boolean dontCompress, boolean definitive) {\n        if(this.definitive) {\n            Logger.warning(this, \"merge() after definitive\", new Exception(\"debug\"));\n            return;\n        }\n        assert(min != InsertContext.CompatibilityMode.COMPAT_CURRENT.ordinal());\n        assert(max != InsertContext.CompatibilityMode.COMPAT_CURRENT.ordinal());\n        if(definitive) this.definitive = true;\n        if(!dontCompress) this.dontCompress = false;\n        if(min > this.min) this.min = min;\n        if(max < this.max || this.max == InsertContext.CompatibilityMode.COMPAT_UNKNOWN.ordinal()) this.max = max;\n        if(this.cryptoKey == null) {\n            this.cryptoKey = cryptoKey;\n        } else if(cryptoKey != null && !Arrays.equals(this.cryptoKey, cryptoKey)) {\n            Logger.error(this, \"Two different crypto keys!\");\n            this.cryptoKey = null;\n        }\n    }","commit_id":"4eaa9d0385d9b7818f4ae9a4fa4b1e288485319e","url":"https://github.com/freenet/fred"},{"original_method":"public CompatibilityMode max() {\n        return InsertContext.CompatibilityMode.values()[(int)max];\n    }","id":24137,"modified_method":"public CompatibilityMode max() {\n        return InsertContext.CompatibilityMode.byCode(max);\n    }","commit_id":"4eaa9d0385d9b7818f4ae9a4fa4b1e288485319e","url":"https://github.com/freenet/fred"},{"original_method":"public CompatibilityAnalyser(DataInputStream dis) throws IOException, StorageFormatException {\n        int ver = dis.readInt();\n        if(ver != VERSION) throw new StorageFormatException(\"Unknown version for CompatibilityAnalyser\");\n        min = dis.readInt();\n        if(min < 0 || min >= InsertContext.CompatibilityMode.values().length)\n            throw new StorageFormatException(\"Bad min value\");\n        max = dis.readInt();\n        if(max < 0 || max >= InsertContext.CompatibilityMode.values().length)\n            throw new StorageFormatException(\"Bad max value\");\n        if(dis.readBoolean()) {\n            cryptoKey = new byte[32];\n            dis.readFully(cryptoKey);\n        }\n        dontCompress = dis.readBoolean();\n        definitive = dis.readBoolean();\n    }","id":24138,"modified_method":"public CompatibilityAnalyser(DataInputStream dis) throws IOException, StorageFormatException {\n        int ver = dis.readInt();\n        if(ver != VERSION) throw new StorageFormatException(\"Unknown version for CompatibilityAnalyser\");\n        min = dis.readShort();\n        if(min < 0 || CompatibilityMode.hasCode(min))\n            throw new StorageFormatException(\"Bad min value\");\n        max = dis.readShort();\n        if(max < 0 || max >= InsertContext.CompatibilityMode.values().length)\n            throw new StorageFormatException(\"Bad max value\");\n        if(dis.readBoolean()) {\n            cryptoKey = new byte[32];\n            dis.readFully(cryptoKey);\n        }\n        dontCompress = dis.readBoolean();\n        definitive = dis.readBoolean();\n    }","commit_id":"4eaa9d0385d9b7818f4ae9a4fa4b1e288485319e","url":"https://github.com/freenet/fred"},{"original_method":"public void writeTo(DataOutputStream dos) throws IOException {\n        dos.writeInt(VERSION);\n        dos.writeInt(min);\n        dos.writeInt(max);\n        if(cryptoKey == null) {\n            dos.writeBoolean(false);\n        } else {\n            dos.writeBoolean(true);\n            assert(cryptoKey.length == 32);\n            dos.write(cryptoKey);\n        }\n        dos.writeBoolean(dontCompress);\n        dos.writeBoolean(definitive);\n    }","id":24139,"modified_method":"public void writeTo(DataOutputStream dos) throws IOException {\n        dos.writeInt(VERSION);\n        dos.writeShort(min);\n        dos.writeShort(max);\n        if(cryptoKey == null) {\n            dos.writeBoolean(false);\n        } else {\n            dos.writeBoolean(true);\n            assert(cryptoKey.length == 32);\n            dos.write(cryptoKey);\n        }\n        dos.writeBoolean(dontCompress);\n        dos.writeBoolean(definitive);\n    }","commit_id":"4eaa9d0385d9b7818f4ae9a4fa4b1e288485319e","url":"https://github.com/freenet/fred"},{"original_method":"public CompatibilityMode min() {\n        return InsertContext.CompatibilityMode.values()[(int)min];\n    }","id":24140,"modified_method":"public CompatibilityMode min() {\n        return InsertContext.CompatibilityMode.byCode(min);\n    }","commit_id":"4eaa9d0385d9b7818f4ae9a4fa4b1e288485319e","url":"https://github.com/freenet/fred"},{"original_method":"CompatibilityAnalyser(int min, int max, byte[] cryptoKey, boolean dontCompress, boolean definitive) {\n        this.min = min;\n        this.max = max;\n        this.cryptoKey = cryptoKey;\n        this.dontCompress = dontCompress;\n        this.definitive = definitive;\n    }","id":24141,"modified_method":"CompatibilityAnalyser(short min, short max, byte[] cryptoKey, boolean dontCompress, boolean definitive) {\n        this.min = min;\n        this.max = max;\n        this.cryptoKey = cryptoKey;\n        this.dontCompress = dontCompress;\n        this.definitive = definitive;\n    }","commit_id":"4eaa9d0385d9b7818f4ae9a4fa4b1e288485319e","url":"https://github.com/freenet/fred"},{"original_method":"public CompatibilityAnalyser() {\n        this.min = InsertContext.CompatibilityMode.COMPAT_UNKNOWN.ordinal();\n        this.max = InsertContext.CompatibilityMode.COMPAT_UNKNOWN.ordinal();\n    }","id":24142,"modified_method":"public CompatibilityAnalyser() {\n        this.min = InsertContext.CompatibilityMode.COMPAT_UNKNOWN.code;\n        this.max = InsertContext.CompatibilityMode.COMPAT_UNKNOWN.code;\n    }","commit_id":"4eaa9d0385d9b7818f4ae9a4fa4b1e288485319e","url":"https://github.com/freenet/fred"},{"original_method":"public SplitfileCompatibilityModeEvent(CompatibilityMode min, CompatibilityMode max, byte[] splitfileCryptoKey, boolean dontCompress, boolean bottomLayer) {\n\t\tthis.minCompatibilityMode = min.ordinal();\n\t\tthis.maxCompatibilityMode = max.ordinal();\n\t\tthis.splitfileCryptoKey = splitfileCryptoKey;\n\t\tthis.dontCompress = dontCompress;\n\t\tthis.bottomLayer = bottomLayer;\n\t}","id":24143,"modified_method":"public SplitfileCompatibilityModeEvent(CompatibilityMode min, CompatibilityMode max, byte[] splitfileCryptoKey, boolean dontCompress, boolean bottomLayer) {\n\t\tthis.minCompatibilityMode = min.code;\n\t\tthis.maxCompatibilityMode = max.code;\n\t\tthis.splitfileCryptoKey = splitfileCryptoKey;\n\t\tthis.dontCompress = dontCompress;\n\t\tthis.bottomLayer = bottomLayer;\n\t}","commit_id":"4eaa9d0385d9b7818f4ae9a4fa4b1e288485319e","url":"https://github.com/freenet/fred"},{"original_method":"/** Parse some metadata from a DataInputStream\n\t * @throws IOException If an I/O error occurs, or the data is incomplete. */\n\tpublic Metadata(DataInputStream dis, long length) throws IOException, MetadataParseException {\n\t\thashCode = super.hashCode();\n\t\tlong magic = dis.readLong();\n\t\tif(magic != FREENET_METADATA_MAGIC)\n\t\t\tthrow new MetadataParseException(\"Invalid magic \"+magic);\n\t\tshort version = dis.readShort();\n\t\tif(version < 0 || version > 1)\n\t\t\tthrow new MetadataParseException(\"Unsupported version \"+version);\n\t\tparsedVersion = version;\n\t\tdocumentType = dis.readByte();\n\t\tif((documentType < 0) || (documentType > 6))\n\t\t\tthrow new MetadataParseException(\"Unsupported document type: \"+documentType);\n\t\tif(logMINOR) Logger.minor(this, \"Document type: \"+documentType);\n\n\t\tboolean compressed = false;\n\t\tboolean hasTopBlocks = false;\n\t\tHashResult[] h = null;\n\t\tif(haveFlags()) {\n\t\t\tshort flags = dis.readShort();\n\t\t\tsplitfile = (flags & FLAGS_SPLITFILE) == FLAGS_SPLITFILE;\n\t\t\tdbr = (flags & FLAGS_DBR) == FLAGS_DBR;\n\t\t\tnoMIME = (flags & FLAGS_NO_MIME) == FLAGS_NO_MIME;\n\t\t\tcompressedMIME = (flags & FLAGS_COMPRESSED_MIME) == FLAGS_COMPRESSED_MIME;\n\t\t\textraMetadata = (flags & FLAGS_EXTRA_METADATA) == FLAGS_EXTRA_METADATA;\n\t\t\tfullKeys = (flags & FLAGS_FULL_KEYS) == FLAGS_FULL_KEYS;\n\t\t\tcompressed = (flags & FLAGS_COMPRESSED) == FLAGS_COMPRESSED;\n\t\t\tif((flags & FLAGS_HASHES) == FLAGS_HASHES) {\n\t\t\t\tif(version == 0)\n\t\t\t\t\tthrow new MetadataParseException(\"Version 0 does not support hashes\");\n\t\t\t\th = HashResult.readHashes(dis);\n\t\t\t}\n\t\t\thasTopBlocks = (flags & FLAGS_TOP_SIZE) == FLAGS_TOP_SIZE;\n\t\t\tif(hasTopBlocks && version == 0)\n\t\t\t\tthrow new MetadataParseException(\"Version 0 does not support top block data\");\n\t\t\tspecifySplitfileKey = (flags & FLAGS_SPECIFY_SPLITFILE_KEY) == FLAGS_SPECIFY_SPLITFILE_KEY;\n\t\t\tif((flags & FLAGS_HASH_THIS_LAYER) == FLAGS_HASH_THIS_LAYER) {\n\t\t\t\thashThisLayerOnly = new byte[32];\n\t\t\t\tdis.readFully(hashThisLayerOnly);\n\t\t\t}\n\t\t}\n\t\thashes = h;\n\t\t\n\t\tif(hasTopBlocks) {\n\t\t\tif(parsedVersion == 0)\n\t\t\t\tthrow new MetadataParseException(\"Top size data not supported in version 0\");\n\t\t\ttopSize = dis.readLong();\n\t\t\ttopCompressedSize = dis.readLong();\n\t\t\ttopBlocksRequired = dis.readInt();\n\t\t\ttopBlocksTotal = dis.readInt();\n\t\t\ttopDontCompress = dis.readBoolean();\n\t\t\ttopCompatibilityMode = dis.readShort();\n\t\t} else {\n\t\t\ttopSize = 0;\n\t\t\ttopCompressedSize = 0;\n\t\t\ttopBlocksRequired = 0;\n\t\t\ttopBlocksTotal = 0;\n\t\t\ttopDontCompress = false;\n\t\t\ttopCompatibilityMode = (short)InsertContext.CompatibilityMode.COMPAT_UNKNOWN.ordinal();\n\t\t}\n\n\t\tif(documentType == ARCHIVE_MANIFEST) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Archive manifest\");\n\t\t\tarchiveType = ARCHIVE_TYPE.getArchiveType(dis.readShort());\n\t\t\tif(archiveType == null)\n\t\t\t\tthrow new MetadataParseException(\"Unrecognized archive type \"+archiveType);\n\t\t}\n\n\t\tif(splitfile) {\n\t\t\tif(parsedVersion >= 1) {\n\t\t\t\t// Splitfile single crypto key.\n\t\t\t\tsplitfileSingleCryptoAlgorithm = dis.readByte();\n\t\t\t\tif(specifySplitfileKey || hashes == null || hashes.length == 0 || !HashResult.contains(hashes, HashType.SHA256)) {\n\t\t\t\t\tbyte[] key = new byte[32];\n\t\t\t\t\tdis.readFully(key);\n\t\t\t\t\tsplitfileSingleCryptoKey = key;\n\t\t\t\t} else {\n\t\t\t\t\tif(hashThisLayerOnly != null)\n\t\t\t\t\t\tsplitfileSingleCryptoKey = getCryptoKey(hashThisLayerOnly);\n\t\t\t\t\telse\n\t\t\t\t\t\tsplitfileSingleCryptoKey = getCryptoKey(hashes);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Pre-1010 isn't supported, so there is only one possibility.\n\t\t\t\tsplitfileSingleCryptoAlgorithm = Key.ALGO_AES_PCFB_256_SHA256;\n\t\t\t}\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Splitfile\");\n\t\t\tdataLength = dis.readLong();\n\t\t\tif(dataLength < -1)\n\t\t\t\tthrow new MetadataParseException(\"Invalid real content length \"+dataLength);\n\n\t\t\tif(dataLength == -1) {\n\t\t\t\tif(splitfile)\n\t\t\t\t\tthrow new MetadataParseException(\"Splitfile must have a real-length\");\n\t\t\t}\n\t\t}\n\n\t\tif(compressed) {\n\t\t\tcompressionCodec = COMPRESSOR_TYPE.getCompressorByMetadataID(dis.readShort());\n\t\t\tif(compressionCodec == null)\n\t\t\t\tthrow new MetadataParseException(\"Unrecognized splitfile compression codec \"+compressionCodec);\n\n\t\t\tdecompressedLength = dis.readLong();\n\t\t}\n\n\t\tif(noMIME) {\n\t\t\tmimeType = null;\n\t\t\tif(logMINOR) Logger.minor(this, \"noMIME enabled\");\n\t\t} else {\n\t\t\tif(compressedMIME) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Compressed MIME\");\n\t\t\t\tshort x = dis.readShort();\n\t\t\t\tcompressedMIMEValue = (short) (x & 32767); // chop off last bit\n\t\t\t\thasCompressedMIMEParams = (compressedMIMEValue & 32768) == 32768;\n\t\t\t\tif(hasCompressedMIMEParams) {\n\t\t\t\t\tcompressedMIMEParams = dis.readShort();\n\t\t\t\t\tif(compressedMIMEParams != 0) {\n\t\t\t\t\t\tthrow new MetadataParseException(\"Unrecognized MIME params ID (not yet implemented)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmimeType = DefaultMIMETypes.byNumber(x);\n\t\t\t} else {\n\t\t\t\t// Read an actual raw MIME type\n\t\t\t\tbyte l = dis.readByte();\n\t\t\t\tint len = l & 0xff; // positive\n\t\t\t\tbyte[] toRead = new byte[len];\n\t\t\t\tdis.readFully(toRead);\n\t\t\t\t// Use UTF-8 for everything, for simplicity\n\t\t\t\tmimeType = new String(toRead, \"UTF-8\");\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Raw MIME\");\n\t\t\t\tif(!DefaultMIMETypes.isPlausibleMIMEType(mimeType))\n\t\t\t\t\tthrow new MetadataParseException(\"Does not look like a MIME type: \\\"\"+mimeType+\"\\\"\");\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"MIME = \"+mimeType);\n\t\t}\n\n\t\tif(dbr) {\n\t\t\tthrow new MetadataParseException(\"Do not support DBRs pending decision on putting them in the key!\");\n\t\t}\n\n\t\tif(extraMetadata) {\n\t\t\tint numberOfExtraFields = (dis.readShort()) & 0xffff;\n\t\t\tfor(int i=0;i<numberOfExtraFields;i++) {\n\t\t\t\tshort type = dis.readShort();\n\t\t\t\tint len = (dis.readByte() & 0xff);\n\t\t\t\tbyte[] buf = new byte[len];\n\t\t\t\tdis.readFully(buf);\n\t\t\t\tLogger.normal(this, \"Ignoring type \"+type+\" extra-client-metadata field of \"+len+\" bytes\");\n\t\t\t}\n\t\t\textraMetadata = false; // can't parse, can't write\n\t\t}\n\n\t\tclientMetadata = new ClientMetadata(mimeType);\n\n\t\tif((!splitfile) && ((documentType == SIMPLE_REDIRECT) || (documentType == ARCHIVE_MANIFEST))) {\n\t\t\tsimpleRedirectKey = readKey(dis);\n\t\t\tif(simpleRedirectKey.isCHK()) {\n\t\t\t\tbyte algo = ClientCHK.getCryptoAlgorithmFromExtra(simpleRedirectKey.getExtra());\n\t\t\t\tif(algo == Key.ALGO_AES_CTR_256_SHA256) {\n\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1416;\n\t\t\t\t\tmaxCompatMode = CompatibilityMode.latest();\n\t\t\t\t} else {\n\t\t\t\t\t// Older.\n\t\t\t\t\tif (getParsedVersion() == 0) {\n\t\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\tmaxCompatMode = CompatibilityMode.COMPAT_1251;\n\t\t\t\t\t} else\n\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1255;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(splitfile) {\n\t\t\tsplitfileAlgorithm = dis.readShort();\n\t\t\tif(!((splitfileAlgorithm == SPLITFILE_NONREDUNDANT) ||\n\t\t\t\t\t(splitfileAlgorithm == SPLITFILE_ONION_STANDARD)))\n\t\t\t\tthrow new MetadataParseException(\"Unknown splitfile algorithm \"+splitfileAlgorithm);\n\n\t\t\tif(splitfileAlgorithm == SPLITFILE_NONREDUNDANT)\n\t\t\t\tthrow new MetadataParseException(\"Non-redundant splitfile invalid\");\n\n\t\t\tint paramsLength = dis.readInt();\n\t\t\tif(paramsLength > MAX_SPLITFILE_PARAMS_LENGTH)\n\t\t\t\tthrow new MetadataParseException(\"Too many bytes of splitfile parameters: \"+paramsLength);\n\n\t\t\tif(paramsLength > 0) {\n\t\t\t\tsplitfileParams = new byte[paramsLength];\n\t\t\t\tdis.readFully(splitfileParams);\n\t\t\t} else if(paramsLength < 0) {\n\t\t\t\tthrow new MetadataParseException(\"Invalid splitfile params length: \"+paramsLength);\n\t\t\t}\n\n\t\t\tsplitfileBlocks = dis.readInt(); // 64TB file size limit :)\n\t\t\tif(splitfileBlocks < 0)\n\t\t\t\tthrow new MetadataParseException(\"Invalid number of blocks: \"+splitfileBlocks);\n\t\t\tif(splitfileBlocks > MAX_SPLITFILE_BLOCKS)\n\t\t\t\tthrow new MetadataParseException(\"Too many splitfile blocks (soft limit to prevent memory DoS): \"+splitfileBlocks);\n\t\t\tsplitfileCheckBlocks = dis.readInt();\n\t\t\tif(splitfileCheckBlocks < 0)\n\t\t\t\tthrow new MetadataParseException(\"Invalid number of check blocks: \"+splitfileCheckBlocks);\n\t\t\tif(splitfileCheckBlocks > MAX_SPLITFILE_BLOCKS)\n\t\t\t\tthrow new MetadataParseException(\"Too many splitfile check-blocks (soft limit to prevent memory DoS): \"+splitfileCheckBlocks);\n\t\t\t\n\t\t\t// PARSE SPLITFILE PARAMETERS\n\t\t\t\n\t\t\t\n\t\t\tcrossCheckBlocks = 0;\n\t\t\t\n\t\t\tif(splitfileAlgorithm == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\t\t// Don't need to do much - just fetch everything and piece it together.\n\t\t\t\tblocksPerSegment = -1;\n\t\t\t\tcheckBlocksPerSegment = -1;\n\t\t\t\tsegmentCount = 1;\n\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t\tif(splitfileCheckBlocks > 0) {\n\t\t\t\t\tLogger.error(this, \"Splitfile type is SPLITFILE_NONREDUNDANT yet \"+splitfileCheckBlocks+\" check blocks found!! : \"+this);\n\t\t\t\t\tthrow new MetadataParseException(\"Splitfile type is non-redundant yet have \"+splitfileCheckBlocks+\" check blocks\");\n\t\t\t\t}\n\t\t\t} else if(splitfileAlgorithm == Metadata.SPLITFILE_ONION_STANDARD) {\n\t\t\t\tbyte[] params = splitfileParams();\n\t\t\t\tint checkBlocks;\n\t\t\t\tif(getParsedVersion() == 0) {\n\t\t\t\t\tif((params == null) || (params.length < 8))\n\t\t\t\t\t\tthrow new MetadataParseException(\"No splitfile params\");\n\t\t\t\t\tblocksPerSegment = Fields.bytesToInt(params, 0);\n\t\t\t\t\tcheckBlocks = Fields.bytesToInt(params, 4);\n\t\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t\t\tint countDataBlocks = splitfileBlocks;\n\t\t\t\t\tint countCheckBlocks = splitfileCheckBlocks;\n\t\t\t\t\tif(countDataBlocks == countCheckBlocks) {\n\t\t\t\t\t\t// No extra check blocks, so before 1251.\n\t\t\t\t\t\tif(blocksPerSegment == 128) {\n\t\t\t\t\t\t\t// Is the last segment small enough that we can't have used even splitting?\n\t\t\t\t\t\t\tint segs = (countDataBlocks + 127) / 128;\n\t\t\t\t\t\t\tint segSize = (countDataBlocks + segs - 1) / segs;\n\t\t\t\t\t\t\tif(segSize == 128) {\n\t\t\t\t\t\t\t\t// Could be either\n\t\t\t\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\t\t\tmaxCompatMode = CompatibilityMode.COMPAT_1250;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1250;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(checkBlocks == 64) {\n\t\t\t\t\t\t\t// Very old 128/64 redundancy.\n\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_UNKNOWN;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extra block per segment in 1251.\n\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1251;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Version 1 i.e. modern.\n\t\t\t\t\tif(splitfileSingleCryptoAlgorithm == Key.ALGO_AES_PCFB_256_SHA256)\n\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1255;\n\t\t\t\t\telse if(splitfileSingleCryptoAlgorithm == Key.ALGO_AES_CTR_256_SHA256) {\n\t\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1416;\n\t\t\t\t\t\tmaxCompatMode = CompatibilityMode.latest();\n\t\t\t\t\t}\n\t\t\t\t\tif(params.length < 10)\n\t\t\t\t\t\tthrow new MetadataParseException(\"Splitfile parameters too short for version 1\");\n\t\t\t\t\tshort paramsType = Fields.bytesToShort(params, 0);\n\t\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_SIMPLE_SEGMENT || paramsType == Metadata.SPLITFILE_PARAMS_SEGMENT_DEDUCT_BLOCKS || paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\t\tblocksPerSegment = Fields.bytesToInt(params, 2);\n\t\t\t\t\t\tcheckBlocks = Fields.bytesToInt(params, 6);\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new MetadataParseException(\"Unknown splitfile params type \"+paramsType);\n\t\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_SEGMENT_DEDUCT_BLOCKS || paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\t\tdeductBlocksFromSegments = Fields.bytesToInt(params, 10);\n\t\t\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\t\t\tcrossCheckBlocks = Fields.bytesToInt(params, 14);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(topCompatibilityMode != 0) {\n\t\t\t\t\t// If we have top compatibility mode, then we can give a definitive answer immediately, with the splitfile key, with dontcompress, etc etc.\n\t\t\t\t\tif(minCompatMode == CompatibilityMode.COMPAT_UNKNOWN ||\n\t\t\t\t\t\t\t!(minCompatMode.ordinal() > topCompatibilityMode || maxCompatMode.ordinal() < topCompatibilityMode)) {\n\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.values()[topCompatibilityMode];\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new MetadataParseException(\"Top compatibility mode is incompatible with detected compatibility mode: min=\"+minCompatMode+\" max=\"+maxCompatMode+\" top=\"+topCompatibilityMode);\n\t\t\t\t}\n\n\t\t\t\t// FIXME remove this eventually. Will break compat with a few files inserted between 1135 and 1136.\n\t\t\t\t// Work around a bug around build 1135.\n\t\t\t\t// We were splitting as (128,255), but we were then setting the checkBlocksPerSegment to 64.\n\t\t\t\t// Detect this.\n\t\t\t\tif(checkBlocks == 64 && blocksPerSegment == 128 &&\n\t\t\t\t\t\tsplitfileCheckBlocks == splitfileBlocks - (splitfileBlocks / 128)) {\n\t\t\t\t\tLogger.normal(this, \"Activating 1135 wrong check blocks per segment workaround for \"+this);\n\t\t\t\t\tcheckBlocks = 127;\n\t\t\t\t}\n\t\t\t\tcheckBlocksPerSegment = checkBlocks;\n\n\t\t\t\tsegmentCount = (splitfileBlocks + blocksPerSegment + crossCheckBlocks - 1) / (blocksPerSegment + crossCheckBlocks);\n\t\t\t\t\t\n\t\t\t\t// Onion, 128/192.\n\t\t\t\t// Will be segmented.\n\t\t\t} else throw new MetadataParseException(\"Unknown splitfile format: \"+splitfileAlgorithm);\n\t\t\t\n\t\t\tsegments = new SplitFileSegmentKeys[segmentCount];\n\t\t\t\n\t\t\tif(segmentCount == 1) {\n\t\t\t\t// splitfile* will be overwritten, this is bad\n\t\t\t\t// so copy them\n\t\t\t\tsegments[0] = new SplitFileSegmentKeys(splitfileBlocks, splitfileCheckBlocks, splitfileSingleCryptoKey, splitfileSingleCryptoAlgorithm);\n\t\t\t} else {\n\t\t\t\tint dataBlocksPtr = 0;\n\t\t\t\tint checkBlocksPtr = 0;\n\t\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\t\t// Create a segment. Give it its keys.\n\t\t\t\t\tint copyDataBlocks = blocksPerSegment + crossCheckBlocks;\n\t\t\t\t\tint copyCheckBlocks = checkBlocksPerSegment;\n\t\t\t\t\tif(i == segments.length - 1) {\n\t\t\t\t\t\t// Always accept the remainder as the last segment, but do basic sanity checking.\n\t\t\t\t\t\t// In practice this can be affected by various things: 1) On old splitfiles before full even \n\t\t\t\t\t\t// segment splitting with deductBlocksFromSegments (i.e. pre-1255), the last segment could be\n\t\t\t\t\t\t// significantly smaller than the rest; 2) On 1251-1253, with partial even segment splitting,\n\t\t\t\t\t\t// up to 131 data blocks per segment, cutting the check blocks if necessary, and with an extra\n\t\t\t\t\t\t// check block if possible, the last segment could have *more* check blocks than the rest. \n\t\t\t\t\t\tcopyDataBlocks = splitfileBlocks - dataBlocksPtr;\n\t\t\t\t\t\tcopyCheckBlocks = splitfileCheckBlocks - checkBlocksPtr;\n\t\t\t\t\t\tif(copyCheckBlocks <= 0 || copyDataBlocks <= 0)\n\t\t\t\t\t\t\tthrow new MetadataParseException(\"Last segment has bogus block count: total data blocks \"+splitfileBlocks+\" total check blocks \"+splitfileCheckBlocks+\" segment size \"+blocksPerSegment+\" data \"+checkBlocksPerSegment+\" check \"+crossCheckBlocks+\" cross check blocks, deduct \"+deductBlocksFromSegments+\", segments \"+segments.length);\n\t\t\t\t\t} else if(segments.length - i <= deductBlocksFromSegments) {\n\t\t\t\t\t\t// Deduct one data block from each of the last deductBlocksFromSegments segments.\n\t\t\t\t\t\t// This ensures no segment is more than 1 block larger than any other.\n\t\t\t\t\t\t// We do not shrink the check blocks.\n\t\t\t\t\t\tcopyDataBlocks--;\n\t\t\t\t\t}\n\t\t\t\t\tsegments[i] = new SplitFileSegmentKeys(copyDataBlocks, copyCheckBlocks, splitfileSingleCryptoKey, splitfileSingleCryptoAlgorithm);\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"REQUESTING: Segment \"+i+\" of \"+segments.length+\" : \"+copyDataBlocks+\" data blocks \"+copyCheckBlocks+\" check blocks\");\n\t\t\t\t\tdataBlocksPtr += copyDataBlocks;\n\t\t\t\t\tcheckBlocksPtr += copyCheckBlocks;\n\t\t\t\t}\n\t\t\t\tif(dataBlocksPtr != splitfileBlocks)\n\t\t\t\t\tthrow new MetadataParseException(\"Unable to allocate all data blocks to segments - buggy or malicious inserter\");\n\t\t\t\tif(checkBlocksPtr != splitfileCheckBlocks)\n\t\t\t\t\tthrow new MetadataParseException(\"Unable to allocate all check blocks to segments - buggy or malicious inserter\");\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<segmentCount;i++) {\n\t\t\t\tsegments[i].readKeys(dis, false);\n\t\t\t}\n\t\t\tfor(int i=0;i<segmentCount;i++) {\n\t\t\t\tsegments[i].readKeys(dis, true);\n\t\t\t}\n\t\t\n\t\t}\n\t\t\t\n\t\tif(documentType == SIMPLE_MANIFEST) {\n\t\t\tint manifestEntryCount = dis.readInt();\n\t\t\tif(manifestEntryCount < 0)\n\t\t\t\tthrow new MetadataParseException(\"Invalid manifest entry count: \"+manifestEntryCount);\n\n\t\t\tmanifestEntries = new HashMap<String, Metadata>();\n\n\t\t\t// Parse the sub-Manifest.\n\n\t\t\tif(logMINOR)Logger.minor(this, \"Simple manifest, \"+manifestEntryCount+\" entries\");\n\n\t\t\tfor(int i=0;i<manifestEntryCount;i++) {\n\t\t\t\tshort nameLength = dis.readShort();\n\t\t\t\tbyte[] buf = new byte[nameLength];\n\t\t\t\tdis.readFully(buf);\n\t\t\t\tString name = new String(buf, \"UTF-8\").intern();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Entry \"+i+\" name \"+name);\n\t\t\t\tshort len = dis.readShort();\n\t\t\t\tif(len < 0)\n\t\t\t\t\tthrow new MetadataParseException(\"Invalid manifest entry size: \"+len);\n\t\t\t\tif(len > length)\n\t\t\t\t\tthrow new MetadataParseException(\"Impossibly long manifest entry: \"+len+\" - metadata size \"+length);\n\t\t\t\tbyte[] data = new byte[len];\n\t\t\t\tdis.readFully(data);\n\t\t\t\tMetadata m = Metadata.construct(data);\n\t\t\t\tmanifestEntries.put(name, m);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"End of manifest\"); // Make it easy to search for it!\n\t\t}\n\n\t\tif((documentType == ARCHIVE_INTERNAL_REDIRECT) || (documentType == ARCHIVE_METADATA_REDIRECT) || (documentType == SYMBOLIC_SHORTLINK)) {\n\t\t\tint len = dis.readShort();\n\t\t\tif(logMINOR) Logger.minor(this, \"Reading archive internal redirect length \"+len);\n\t\t\tbyte[] buf = new byte[len];\n\t\t\tdis.readFully(buf);\n\t\t\ttargetName = new String(buf, \"UTF-8\");\n\t\t\twhile(true) {\n\t\t\t\tif(targetName.isEmpty()) throw new MetadataParseException(\"Invalid target name is empty: \\\"\"+new String(buf, \"UTF-8\")+\"\\\"\");\n\t\t\t\tif(targetName.charAt(0) == '/') {\n\t\t\t\t\ttargetName = targetName.substring(1);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Archive and/or internal redirect: \"+targetName+\" (\"+len+ ')');\n\t\t}\n\t}","id":24144,"modified_method":"/** Parse some metadata from a DataInputStream\n\t * @throws IOException If an I/O error occurs, or the data is incomplete. */\n\tpublic Metadata(DataInputStream dis, long length) throws IOException, MetadataParseException {\n\t\thashCode = super.hashCode();\n\t\tlong magic = dis.readLong();\n\t\tif(magic != FREENET_METADATA_MAGIC)\n\t\t\tthrow new MetadataParseException(\"Invalid magic \"+magic);\n\t\tshort version = dis.readShort();\n\t\tif(version < 0 || version > 1)\n\t\t\tthrow new MetadataParseException(\"Unsupported version \"+version);\n\t\tparsedVersion = version;\n\t\tdocumentType = dis.readByte();\n\t\tif((documentType < 0) || (documentType > 6))\n\t\t\tthrow new MetadataParseException(\"Unsupported document type: \"+documentType);\n\t\tif(logMINOR) Logger.minor(this, \"Document type: \"+documentType);\n\n\t\tboolean compressed = false;\n\t\tboolean hasTopBlocks = false;\n\t\tHashResult[] h = null;\n\t\tif(haveFlags()) {\n\t\t\tshort flags = dis.readShort();\n\t\t\tsplitfile = (flags & FLAGS_SPLITFILE) == FLAGS_SPLITFILE;\n\t\t\tdbr = (flags & FLAGS_DBR) == FLAGS_DBR;\n\t\t\tnoMIME = (flags & FLAGS_NO_MIME) == FLAGS_NO_MIME;\n\t\t\tcompressedMIME = (flags & FLAGS_COMPRESSED_MIME) == FLAGS_COMPRESSED_MIME;\n\t\t\textraMetadata = (flags & FLAGS_EXTRA_METADATA) == FLAGS_EXTRA_METADATA;\n\t\t\tfullKeys = (flags & FLAGS_FULL_KEYS) == FLAGS_FULL_KEYS;\n\t\t\tcompressed = (flags & FLAGS_COMPRESSED) == FLAGS_COMPRESSED;\n\t\t\tif((flags & FLAGS_HASHES) == FLAGS_HASHES) {\n\t\t\t\tif(version == 0)\n\t\t\t\t\tthrow new MetadataParseException(\"Version 0 does not support hashes\");\n\t\t\t\th = HashResult.readHashes(dis);\n\t\t\t}\n\t\t\thasTopBlocks = (flags & FLAGS_TOP_SIZE) == FLAGS_TOP_SIZE;\n\t\t\tif(hasTopBlocks && version == 0)\n\t\t\t\tthrow new MetadataParseException(\"Version 0 does not support top block data\");\n\t\t\tspecifySplitfileKey = (flags & FLAGS_SPECIFY_SPLITFILE_KEY) == FLAGS_SPECIFY_SPLITFILE_KEY;\n\t\t\tif((flags & FLAGS_HASH_THIS_LAYER) == FLAGS_HASH_THIS_LAYER) {\n\t\t\t\thashThisLayerOnly = new byte[32];\n\t\t\t\tdis.readFully(hashThisLayerOnly);\n\t\t\t}\n\t\t}\n\t\thashes = h;\n\t\t\n\t\tif(hasTopBlocks) {\n\t\t\tif(parsedVersion == 0)\n\t\t\t\tthrow new MetadataParseException(\"Top size data not supported in version 0\");\n\t\t\ttopSize = dis.readLong();\n\t\t\ttopCompressedSize = dis.readLong();\n\t\t\ttopBlocksRequired = dis.readInt();\n\t\t\ttopBlocksTotal = dis.readInt();\n\t\t\ttopDontCompress = dis.readBoolean();\n\t\t\ttopCompatibilityMode = dis.readShort();\n\t\t} else {\n\t\t\ttopSize = 0;\n\t\t\ttopCompressedSize = 0;\n\t\t\ttopBlocksRequired = 0;\n\t\t\ttopBlocksTotal = 0;\n\t\t\ttopDontCompress = false;\n\t\t\ttopCompatibilityMode = InsertContext.CompatibilityMode.COMPAT_UNKNOWN.code;\n\t\t}\n\n\t\tif(documentType == ARCHIVE_MANIFEST) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Archive manifest\");\n\t\t\tarchiveType = ARCHIVE_TYPE.getArchiveType(dis.readShort());\n\t\t\tif(archiveType == null)\n\t\t\t\tthrow new MetadataParseException(\"Unrecognized archive type \"+archiveType);\n\t\t}\n\n\t\tif(splitfile) {\n\t\t\tif(parsedVersion >= 1) {\n\t\t\t\t// Splitfile single crypto key.\n\t\t\t\tsplitfileSingleCryptoAlgorithm = dis.readByte();\n\t\t\t\tif(specifySplitfileKey || hashes == null || hashes.length == 0 || !HashResult.contains(hashes, HashType.SHA256)) {\n\t\t\t\t\tbyte[] key = new byte[32];\n\t\t\t\t\tdis.readFully(key);\n\t\t\t\t\tsplitfileSingleCryptoKey = key;\n\t\t\t\t} else {\n\t\t\t\t\tif(hashThisLayerOnly != null)\n\t\t\t\t\t\tsplitfileSingleCryptoKey = getCryptoKey(hashThisLayerOnly);\n\t\t\t\t\telse\n\t\t\t\t\t\tsplitfileSingleCryptoKey = getCryptoKey(hashes);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Pre-1010 isn't supported, so there is only one possibility.\n\t\t\t\tsplitfileSingleCryptoAlgorithm = Key.ALGO_AES_PCFB_256_SHA256;\n\t\t\t}\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Splitfile\");\n\t\t\tdataLength = dis.readLong();\n\t\t\tif(dataLength < -1)\n\t\t\t\tthrow new MetadataParseException(\"Invalid real content length \"+dataLength);\n\n\t\t\tif(dataLength == -1) {\n\t\t\t\tif(splitfile)\n\t\t\t\t\tthrow new MetadataParseException(\"Splitfile must have a real-length\");\n\t\t\t}\n\t\t}\n\n\t\tif(compressed) {\n\t\t\tcompressionCodec = COMPRESSOR_TYPE.getCompressorByMetadataID(dis.readShort());\n\t\t\tif(compressionCodec == null)\n\t\t\t\tthrow new MetadataParseException(\"Unrecognized splitfile compression codec \"+compressionCodec);\n\n\t\t\tdecompressedLength = dis.readLong();\n\t\t}\n\n\t\tif(noMIME) {\n\t\t\tmimeType = null;\n\t\t\tif(logMINOR) Logger.minor(this, \"noMIME enabled\");\n\t\t} else {\n\t\t\tif(compressedMIME) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Compressed MIME\");\n\t\t\t\tshort x = dis.readShort();\n\t\t\t\tcompressedMIMEValue = (short) (x & 32767); // chop off last bit\n\t\t\t\thasCompressedMIMEParams = (compressedMIMEValue & 32768) == 32768;\n\t\t\t\tif(hasCompressedMIMEParams) {\n\t\t\t\t\tcompressedMIMEParams = dis.readShort();\n\t\t\t\t\tif(compressedMIMEParams != 0) {\n\t\t\t\t\t\tthrow new MetadataParseException(\"Unrecognized MIME params ID (not yet implemented)\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmimeType = DefaultMIMETypes.byNumber(x);\n\t\t\t} else {\n\t\t\t\t// Read an actual raw MIME type\n\t\t\t\tbyte l = dis.readByte();\n\t\t\t\tint len = l & 0xff; // positive\n\t\t\t\tbyte[] toRead = new byte[len];\n\t\t\t\tdis.readFully(toRead);\n\t\t\t\t// Use UTF-8 for everything, for simplicity\n\t\t\t\tmimeType = new String(toRead, \"UTF-8\");\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Raw MIME\");\n\t\t\t\tif(!DefaultMIMETypes.isPlausibleMIMEType(mimeType))\n\t\t\t\t\tthrow new MetadataParseException(\"Does not look like a MIME type: \\\"\"+mimeType+\"\\\"\");\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"MIME = \"+mimeType);\n\t\t}\n\n\t\tif(dbr) {\n\t\t\tthrow new MetadataParseException(\"Do not support DBRs pending decision on putting them in the key!\");\n\t\t}\n\n\t\tif(extraMetadata) {\n\t\t\tint numberOfExtraFields = (dis.readShort()) & 0xffff;\n\t\t\tfor(int i=0;i<numberOfExtraFields;i++) {\n\t\t\t\tshort type = dis.readShort();\n\t\t\t\tint len = (dis.readByte() & 0xff);\n\t\t\t\tbyte[] buf = new byte[len];\n\t\t\t\tdis.readFully(buf);\n\t\t\t\tLogger.normal(this, \"Ignoring type \"+type+\" extra-client-metadata field of \"+len+\" bytes\");\n\t\t\t}\n\t\t\textraMetadata = false; // can't parse, can't write\n\t\t}\n\n\t\tclientMetadata = new ClientMetadata(mimeType);\n\n\t\tif((!splitfile) && ((documentType == SIMPLE_REDIRECT) || (documentType == ARCHIVE_MANIFEST))) {\n\t\t\tsimpleRedirectKey = readKey(dis);\n\t\t\tif(simpleRedirectKey.isCHK()) {\n\t\t\t\tbyte algo = ClientCHK.getCryptoAlgorithmFromExtra(simpleRedirectKey.getExtra());\n\t\t\t\tif(algo == Key.ALGO_AES_CTR_256_SHA256) {\n\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1416;\n\t\t\t\t\tmaxCompatMode = CompatibilityMode.latest();\n\t\t\t\t} else {\n\t\t\t\t\t// Older.\n\t\t\t\t\tif (getParsedVersion() == 0) {\n\t\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\tmaxCompatMode = CompatibilityMode.COMPAT_1251;\n\t\t\t\t\t} else\n\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1255;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if(splitfile) {\n\t\t\tsplitfileAlgorithm = dis.readShort();\n\t\t\tif(!((splitfileAlgorithm == SPLITFILE_NONREDUNDANT) ||\n\t\t\t\t\t(splitfileAlgorithm == SPLITFILE_ONION_STANDARD)))\n\t\t\t\tthrow new MetadataParseException(\"Unknown splitfile algorithm \"+splitfileAlgorithm);\n\n\t\t\tif(splitfileAlgorithm == SPLITFILE_NONREDUNDANT)\n\t\t\t\tthrow new MetadataParseException(\"Non-redundant splitfile invalid\");\n\n\t\t\tint paramsLength = dis.readInt();\n\t\t\tif(paramsLength > MAX_SPLITFILE_PARAMS_LENGTH)\n\t\t\t\tthrow new MetadataParseException(\"Too many bytes of splitfile parameters: \"+paramsLength);\n\n\t\t\tif(paramsLength > 0) {\n\t\t\t\tsplitfileParams = new byte[paramsLength];\n\t\t\t\tdis.readFully(splitfileParams);\n\t\t\t} else if(paramsLength < 0) {\n\t\t\t\tthrow new MetadataParseException(\"Invalid splitfile params length: \"+paramsLength);\n\t\t\t}\n\n\t\t\tsplitfileBlocks = dis.readInt(); // 64TB file size limit :)\n\t\t\tif(splitfileBlocks < 0)\n\t\t\t\tthrow new MetadataParseException(\"Invalid number of blocks: \"+splitfileBlocks);\n\t\t\tif(splitfileBlocks > MAX_SPLITFILE_BLOCKS)\n\t\t\t\tthrow new MetadataParseException(\"Too many splitfile blocks (soft limit to prevent memory DoS): \"+splitfileBlocks);\n\t\t\tsplitfileCheckBlocks = dis.readInt();\n\t\t\tif(splitfileCheckBlocks < 0)\n\t\t\t\tthrow new MetadataParseException(\"Invalid number of check blocks: \"+splitfileCheckBlocks);\n\t\t\tif(splitfileCheckBlocks > MAX_SPLITFILE_BLOCKS)\n\t\t\t\tthrow new MetadataParseException(\"Too many splitfile check-blocks (soft limit to prevent memory DoS): \"+splitfileCheckBlocks);\n\t\t\t\n\t\t\t// PARSE SPLITFILE PARAMETERS\n\t\t\t\n\t\t\t\n\t\t\tcrossCheckBlocks = 0;\n\t\t\t\n\t\t\tif(splitfileAlgorithm == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\t\t// Don't need to do much - just fetch everything and piece it together.\n\t\t\t\tblocksPerSegment = -1;\n\t\t\t\tcheckBlocksPerSegment = -1;\n\t\t\t\tsegmentCount = 1;\n\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t\tif(splitfileCheckBlocks > 0) {\n\t\t\t\t\tLogger.error(this, \"Splitfile type is SPLITFILE_NONREDUNDANT yet \"+splitfileCheckBlocks+\" check blocks found!! : \"+this);\n\t\t\t\t\tthrow new MetadataParseException(\"Splitfile type is non-redundant yet have \"+splitfileCheckBlocks+\" check blocks\");\n\t\t\t\t}\n\t\t\t} else if(splitfileAlgorithm == Metadata.SPLITFILE_ONION_STANDARD) {\n\t\t\t\tbyte[] params = splitfileParams();\n\t\t\t\tint checkBlocks;\n\t\t\t\tif(getParsedVersion() == 0) {\n\t\t\t\t\tif((params == null) || (params.length < 8))\n\t\t\t\t\t\tthrow new MetadataParseException(\"No splitfile params\");\n\t\t\t\t\tblocksPerSegment = Fields.bytesToInt(params, 0);\n\t\t\t\t\tcheckBlocks = Fields.bytesToInt(params, 4);\n\t\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t\t\tint countDataBlocks = splitfileBlocks;\n\t\t\t\t\tint countCheckBlocks = splitfileCheckBlocks;\n\t\t\t\t\tif(countDataBlocks == countCheckBlocks) {\n\t\t\t\t\t\t// No extra check blocks, so before 1251.\n\t\t\t\t\t\tif(blocksPerSegment == 128) {\n\t\t\t\t\t\t\t// Is the last segment small enough that we can't have used even splitting?\n\t\t\t\t\t\t\tint segs = (countDataBlocks + 127) / 128;\n\t\t\t\t\t\t\tint segSize = (countDataBlocks + segs - 1) / segs;\n\t\t\t\t\t\t\tif(segSize == 128) {\n\t\t\t\t\t\t\t\t// Could be either\n\t\t\t\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\t\t\tmaxCompatMode = CompatibilityMode.COMPAT_1250;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1250_EXACT;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1250;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif(checkBlocks == 64) {\n\t\t\t\t\t\t\t// Very old 128/64 redundancy.\n\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_UNKNOWN;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Extra block per segment in 1251.\n\t\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1251;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Version 1 i.e. modern.\n\t\t\t\t\tif(splitfileSingleCryptoAlgorithm == Key.ALGO_AES_PCFB_256_SHA256)\n\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.COMPAT_1255;\n\t\t\t\t\telse if(splitfileSingleCryptoAlgorithm == Key.ALGO_AES_CTR_256_SHA256) {\n\t\t\t\t\t\tminCompatMode = CompatibilityMode.COMPAT_1416;\n\t\t\t\t\t\tmaxCompatMode = CompatibilityMode.latest();\n\t\t\t\t\t}\n\t\t\t\t\tif(params.length < 10)\n\t\t\t\t\t\tthrow new MetadataParseException(\"Splitfile parameters too short for version 1\");\n\t\t\t\t\tshort paramsType = Fields.bytesToShort(params, 0);\n\t\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_SIMPLE_SEGMENT || paramsType == Metadata.SPLITFILE_PARAMS_SEGMENT_DEDUCT_BLOCKS || paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\t\tblocksPerSegment = Fields.bytesToInt(params, 2);\n\t\t\t\t\t\tcheckBlocks = Fields.bytesToInt(params, 6);\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new MetadataParseException(\"Unknown splitfile params type \"+paramsType);\n\t\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_SEGMENT_DEDUCT_BLOCKS || paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\t\tdeductBlocksFromSegments = Fields.bytesToInt(params, 10);\n\t\t\t\t\t\tif(paramsType == Metadata.SPLITFILE_PARAMS_CROSS_SEGMENT) {\n\t\t\t\t\t\t\tcrossCheckBlocks = Fields.bytesToInt(params, 14);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tdeductBlocksFromSegments = 0;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(topCompatibilityMode != 0) {\n\t\t\t\t\t// If we have top compatibility mode, then we can give a definitive answer immediately, with the splitfile key, with dontcompress, etc etc.\n\t\t\t\t\tif(minCompatMode == CompatibilityMode.COMPAT_UNKNOWN ||\n\t\t\t\t\t\t\t!(minCompatMode.ordinal() > topCompatibilityMode || maxCompatMode.ordinal() < topCompatibilityMode)) {\n\t\t\t\t\t\tminCompatMode = maxCompatMode = CompatibilityMode.byCode(topCompatibilityMode);\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new MetadataParseException(\"Top compatibility mode is incompatible with detected compatibility mode: min=\"+minCompatMode+\" max=\"+maxCompatMode+\" top=\"+topCompatibilityMode);\n\t\t\t\t}\n\n\t\t\t\t// FIXME remove this eventually. Will break compat with a few files inserted between 1135 and 1136.\n\t\t\t\t// Work around a bug around build 1135.\n\t\t\t\t// We were splitting as (128,255), but we were then setting the checkBlocksPerSegment to 64.\n\t\t\t\t// Detect this.\n\t\t\t\tif(checkBlocks == 64 && blocksPerSegment == 128 &&\n\t\t\t\t\t\tsplitfileCheckBlocks == splitfileBlocks - (splitfileBlocks / 128)) {\n\t\t\t\t\tLogger.normal(this, \"Activating 1135 wrong check blocks per segment workaround for \"+this);\n\t\t\t\t\tcheckBlocks = 127;\n\t\t\t\t}\n\t\t\t\tcheckBlocksPerSegment = checkBlocks;\n\n\t\t\t\tsegmentCount = (splitfileBlocks + blocksPerSegment + crossCheckBlocks - 1) / (blocksPerSegment + crossCheckBlocks);\n\t\t\t\t\t\n\t\t\t\t// Onion, 128/192.\n\t\t\t\t// Will be segmented.\n\t\t\t} else throw new MetadataParseException(\"Unknown splitfile format: \"+splitfileAlgorithm);\n\t\t\t\n\t\t\tsegments = new SplitFileSegmentKeys[segmentCount];\n\t\t\t\n\t\t\tif(segmentCount == 1) {\n\t\t\t\t// splitfile* will be overwritten, this is bad\n\t\t\t\t// so copy them\n\t\t\t\tsegments[0] = new SplitFileSegmentKeys(splitfileBlocks, splitfileCheckBlocks, splitfileSingleCryptoKey, splitfileSingleCryptoAlgorithm);\n\t\t\t} else {\n\t\t\t\tint dataBlocksPtr = 0;\n\t\t\t\tint checkBlocksPtr = 0;\n\t\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\t\t// Create a segment. Give it its keys.\n\t\t\t\t\tint copyDataBlocks = blocksPerSegment + crossCheckBlocks;\n\t\t\t\t\tint copyCheckBlocks = checkBlocksPerSegment;\n\t\t\t\t\tif(i == segments.length - 1) {\n\t\t\t\t\t\t// Always accept the remainder as the last segment, but do basic sanity checking.\n\t\t\t\t\t\t// In practice this can be affected by various things: 1) On old splitfiles before full even \n\t\t\t\t\t\t// segment splitting with deductBlocksFromSegments (i.e. pre-1255), the last segment could be\n\t\t\t\t\t\t// significantly smaller than the rest; 2) On 1251-1253, with partial even segment splitting,\n\t\t\t\t\t\t// up to 131 data blocks per segment, cutting the check blocks if necessary, and with an extra\n\t\t\t\t\t\t// check block if possible, the last segment could have *more* check blocks than the rest. \n\t\t\t\t\t\tcopyDataBlocks = splitfileBlocks - dataBlocksPtr;\n\t\t\t\t\t\tcopyCheckBlocks = splitfileCheckBlocks - checkBlocksPtr;\n\t\t\t\t\t\tif(copyCheckBlocks <= 0 || copyDataBlocks <= 0)\n\t\t\t\t\t\t\tthrow new MetadataParseException(\"Last segment has bogus block count: total data blocks \"+splitfileBlocks+\" total check blocks \"+splitfileCheckBlocks+\" segment size \"+blocksPerSegment+\" data \"+checkBlocksPerSegment+\" check \"+crossCheckBlocks+\" cross check blocks, deduct \"+deductBlocksFromSegments+\", segments \"+segments.length);\n\t\t\t\t\t} else if(segments.length - i <= deductBlocksFromSegments) {\n\t\t\t\t\t\t// Deduct one data block from each of the last deductBlocksFromSegments segments.\n\t\t\t\t\t\t// This ensures no segment is more than 1 block larger than any other.\n\t\t\t\t\t\t// We do not shrink the check blocks.\n\t\t\t\t\t\tcopyDataBlocks--;\n\t\t\t\t\t}\n\t\t\t\t\tsegments[i] = new SplitFileSegmentKeys(copyDataBlocks, copyCheckBlocks, splitfileSingleCryptoKey, splitfileSingleCryptoAlgorithm);\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"REQUESTING: Segment \"+i+\" of \"+segments.length+\" : \"+copyDataBlocks+\" data blocks \"+copyCheckBlocks+\" check blocks\");\n\t\t\t\t\tdataBlocksPtr += copyDataBlocks;\n\t\t\t\t\tcheckBlocksPtr += copyCheckBlocks;\n\t\t\t\t}\n\t\t\t\tif(dataBlocksPtr != splitfileBlocks)\n\t\t\t\t\tthrow new MetadataParseException(\"Unable to allocate all data blocks to segments - buggy or malicious inserter\");\n\t\t\t\tif(checkBlocksPtr != splitfileCheckBlocks)\n\t\t\t\t\tthrow new MetadataParseException(\"Unable to allocate all check blocks to segments - buggy or malicious inserter\");\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<segmentCount;i++) {\n\t\t\t\tsegments[i].readKeys(dis, false);\n\t\t\t}\n\t\t\tfor(int i=0;i<segmentCount;i++) {\n\t\t\t\tsegments[i].readKeys(dis, true);\n\t\t\t}\n\t\t\n\t\t}\n\t\t\t\n\t\tif(documentType == SIMPLE_MANIFEST) {\n\t\t\tint manifestEntryCount = dis.readInt();\n\t\t\tif(manifestEntryCount < 0)\n\t\t\t\tthrow new MetadataParseException(\"Invalid manifest entry count: \"+manifestEntryCount);\n\n\t\t\tmanifestEntries = new HashMap<String, Metadata>();\n\n\t\t\t// Parse the sub-Manifest.\n\n\t\t\tif(logMINOR)Logger.minor(this, \"Simple manifest, \"+manifestEntryCount+\" entries\");\n\n\t\t\tfor(int i=0;i<manifestEntryCount;i++) {\n\t\t\t\tshort nameLength = dis.readShort();\n\t\t\t\tbyte[] buf = new byte[nameLength];\n\t\t\t\tdis.readFully(buf);\n\t\t\t\tString name = new String(buf, \"UTF-8\").intern();\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Entry \"+i+\" name \"+name);\n\t\t\t\tshort len = dis.readShort();\n\t\t\t\tif(len < 0)\n\t\t\t\t\tthrow new MetadataParseException(\"Invalid manifest entry size: \"+len);\n\t\t\t\tif(len > length)\n\t\t\t\t\tthrow new MetadataParseException(\"Impossibly long manifest entry: \"+len+\" - metadata size \"+length);\n\t\t\t\tbyte[] data = new byte[len];\n\t\t\t\tdis.readFully(data);\n\t\t\t\tMetadata m = Metadata.construct(data);\n\t\t\t\tmanifestEntries.put(name, m);\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"End of manifest\"); // Make it easy to search for it!\n\t\t}\n\n\t\tif((documentType == ARCHIVE_INTERNAL_REDIRECT) || (documentType == ARCHIVE_METADATA_REDIRECT) || (documentType == SYMBOLIC_SHORTLINK)) {\n\t\t\tint len = dis.readShort();\n\t\t\tif(logMINOR) Logger.minor(this, \"Reading archive internal redirect length \"+len);\n\t\t\tbyte[] buf = new byte[len];\n\t\t\tdis.readFully(buf);\n\t\t\ttargetName = new String(buf, \"UTF-8\");\n\t\t\twhile(true) {\n\t\t\t\tif(targetName.isEmpty()) throw new MetadataParseException(\"Invalid target name is empty: \\\"\"+new String(buf, \"UTF-8\")+\"\\\"\");\n\t\t\t\tif(targetName.charAt(0) == '/') {\n\t\t\t\t\ttargetName = targetName.substring(1);\n\t\t\t\t\tcontinue;\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\tif(logMINOR) Logger.minor(this, \"Archive and/or internal redirect: \"+targetName+\" (\"+len+ ')');\n\t\t}\n\t}","commit_id":"b238a3a92c38be02a67f20b6a08d8477610eee02","url":"https://github.com/freenet/fred"},{"original_method":"public CompatibilityMode getTopCompatibilityMode() {\n\t\treturn InsertContext.CompatibilityMode.values()[this.topCompatibilityMode];\n\t}","id":24145,"modified_method":"public CompatibilityMode getTopCompatibilityMode() {\n\t\treturn InsertContext.CompatibilityMode.byCode(topCompatibilityMode);\n\t}","commit_id":"b238a3a92c38be02a67f20b6a08d8477610eee02","url":"https://github.com/freenet/fred"},{"original_method":"private FieldValidator field(IvyNormalizedPublication publication, String name, String value) {\n        return new FieldValidator(publication.getName(), name, value);\n    }","id":24146,"modified_method":"private IvyFieldValidator field(IvyNormalizedPublication publication, String name, String value) {\n        return new IvyFieldValidator(publication.getName(), name, value);\n    }","commit_id":"cabb2879802688a5f50d72ae7fd3fedca60ddc84","url":"https://github.com/gradle/gradle"},{"original_method":"public void validateArtifacts(IvyNormalizedPublication publication) {\n        for (IvyArtifact artifact : publication.getArtifacts()) {\n            field(publication, \"artifact name\", artifact.getName())\n                    .notEmpty();\n            field(publication, \"artifact type\", artifact.getType())\n                    .notEmpty();\n            field(publication, \"artifact extension\", artifact.getExtension())\n                    .notNull();\n            field(publication, \"artifact classifier\", artifact.getClassifier())\n                    .optionalNotEmpty();\n\n            checkCanPublish(publication.getName(), artifact);\n        }\n    }","id":24147,"modified_method":"public void validateArtifacts(IvyNormalizedPublication publication) {\n        for (IvyArtifact artifact : publication.getArtifacts()) {\n            field(publication, \"artifact name\", artifact.getName())\n                    .notEmpty().validInFileName();\n            field(publication, \"artifact type\", artifact.getType())\n                    .notEmpty().validInFileName();\n            field(publication, \"artifact extension\", artifact.getExtension())\n                    .notNull().validInFileName();\n            field(publication, \"artifact classifier\", artifact.getClassifier())\n                    .optionalNotEmpty().validInFileName();\n\n            checkCanPublish(publication.getName(), artifact);\n        }\n    }","commit_id":"cabb2879802688a5f50d72ae7fd3fedca60ddc84","url":"https://github.com/gradle/gradle"},{"original_method":"private void validateIdentity(IvyNormalizedPublication publication) {\n        IvyPublicationIdentity identity = publication.getProjectIdentity();\n        Node infoNode = getIvyFileInfoNode(publication.getDescriptorFile());\n\n        field(publication, \"organisation\", identity.getOrganisation())\n                .notEmpty()\n                .matches((String) infoNode.attribute(\"organisation\"));\n        field(publication, \"module name\", identity.getModule())\n                .notEmpty()\n                .matches((String) infoNode.attribute(\"module\"));\n        field(publication, \"revision\", identity.getRevision())\n                .notEmpty()\n                .matches((String) infoNode.attribute(\"revision\"));\n    }","id":24148,"modified_method":"private void validateIdentity(IvyNormalizedPublication publication) {\n        IvyPublicationIdentity identity = publication.getProjectIdentity();\n        Node infoNode = getIvyFileInfoNode(publication.getDescriptorFile());\n\n        field(publication, \"organisation\", identity.getOrganisation())\n                .notEmpty()\n                .validInFileName()\n                .matches((String) infoNode.attribute(\"organisation\"));\n        field(publication, \"module name\", identity.getModule())\n                .notEmpty()\n                .validInFileName()\n                .matches((String) infoNode.attribute(\"module\"));\n        field(publication, \"revision\", identity.getRevision())\n                .notEmpty()\n                .validInFileName()\n                .matches((String) infoNode.attribute(\"revision\"));\n    }","commit_id":"cabb2879802688a5f50d72ae7fd3fedca60ddc84","url":"https://github.com/gradle/gradle"},{"original_method":"private FieldValidator field(MavenNormalizedPublication publication, String name, String value) {\n        return new FieldValidator(publication.getName(), name, value);\n    }","id":24149,"modified_method":"private MavenFieldValidator field(MavenNormalizedPublication publication, String name, String value) {\n        return new MavenFieldValidator(publication.getName(), name, value);\n    }","commit_id":"cabb2879802688a5f50d72ae7fd3fedca60ddc84","url":"https://github.com/gradle/gradle"},{"original_method":"private void validateArtifacts(MavenNormalizedPublication publication) {\n        Set<MavenArtifactKey> keys = new HashSet<MavenArtifactKey>();\n        for (MavenArtifact artifact : publication.getArtifacts()) {\n            field(publication, \"artifact extension\", artifact.getExtension())\n                    .notNull();\n            field(publication, \"artifact classifier\", artifact.getClassifier())\n                    .optionalNotEmpty();\n\n            checkCanPublish(publication.getName(), artifact);\n\n            MavenArtifactKey key = new MavenArtifactKey(artifact);\n            if (keys.contains(key)) {\n                throw new InvalidMavenPublicationException(publication.getName(),\n                        String.format(\n                                \"multiple artifacts with the identical extension '%s' and classifier '%s'.\",\n                                artifact.getExtension(), artifact.getClassifier()\n                        ));\n            }\n            keys.add(key);\n        }\n    }","id":24150,"modified_method":"private void validateArtifacts(MavenNormalizedPublication publication) {\n        Set<MavenArtifactKey> keys = new HashSet<MavenArtifactKey>();\n        for (MavenArtifact artifact : publication.getArtifacts()) {\n            field(publication, \"artifact extension\", artifact.getExtension())\n                    .notNull()\n                    .validInFileName();\n            field(publication, \"artifact classifier\", artifact.getClassifier())\n                    .optionalNotEmpty()\n                    .validInFileName();\n\n            checkCanPublish(publication.getName(), artifact);\n\n            MavenArtifactKey key = new MavenArtifactKey(artifact);\n            if (keys.contains(key)) {\n                throw new InvalidMavenPublicationException(publication.getName(),\n                        String.format(\n                                \"multiple artifacts with the identical extension '%s' and classifier '%s'.\",\n                                artifact.getExtension(), artifact.getClassifier()\n                        ));\n            }\n            keys.add(key);\n        }\n    }","commit_id":"cabb2879802688a5f50d72ae7fd3fedca60ddc84","url":"https://github.com/gradle/gradle"},{"original_method":"private void validateIdentity(MavenNormalizedPublication publication) {\n        MavenProjectIdentity projectIdentity = publication.getProjectIdentity();\n        Model model = parsePomFileIntoMavenModel(publication);\n        field(publication, \"groupId\", projectIdentity.getGroupId())\n                .validMavenIdentifier()\n                .matches(model.getGroupId());\n        field(publication, \"artifactId\", projectIdentity.getArtifactId())\n                .validMavenIdentifier()\n                .matches(model.getArtifactId());\n        field(publication, \"version\", projectIdentity.getVersion())\n                .notEmpty()\n                .matches(model.getVersion());\n    }","id":24151,"modified_method":"private void validateIdentity(MavenNormalizedPublication publication) {\n        MavenProjectIdentity projectIdentity = publication.getProjectIdentity();\n        Model model = parsePomFileIntoMavenModel(publication);\n        field(publication, \"groupId\", projectIdentity.getGroupId())\n                .validMavenIdentifier()\n                .matches(model.getGroupId());\n        field(publication, \"artifactId\", projectIdentity.getArtifactId())\n                .validMavenIdentifier()\n                .matches(model.getArtifactId());\n        field(publication, \"version\", projectIdentity.getVersion())\n                .notEmpty()\n                .validInFileName()\n                .matches(model.getVersion());\n    }","commit_id":"cabb2879802688a5f50d72ae7fd3fedca60ddc84","url":"https://github.com/gradle/gradle"},{"original_method":"public void callFailure(final SendableInsert insert, final LowLevelPutException e, int prio, boolean persistent) {\n\t\tif(!persistent) {\n\t\t\tinsert.onFailure(e, null, null, clientContext);\n\t\t} else {\n\t\t\tjobRunner.queue(new DBJob() {\n\n\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\tinsert.onFailure(e, null, container, context);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}, prio, false);\n\t\t}\n\t}","id":24152,"modified_method":"public void callFailure(final SendableInsert insert, final LowLevelPutException e, int prio, boolean persistent) {\n\t\tif(!persistent) {\n\t\t\tinsert.onFailure(e, null, null, clientContext);\n\t\t} else {\n\t\t\tjobRunner.queue(new DBJob() {\n\n\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\tcontainer.activate(insert, 1);\n\t\t\t\t\tinsert.onFailure(e, null, container, context);\n\t\t\t\t\tcontainer.deactivate(insert, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}, prio, false);\n\t\t}\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"public void tripPendingKey(final KeyBlock block) {\n\t\tif(logMINOR) Logger.minor(this, \"tripPendingKey(\"+block.getKey()+\")\");\n\t\t\n\t\tif(offeredKeys != null) {\n\t\t\tfor(int i=0;i<offeredKeys.length;i++) {\n\t\t\t\tofferedKeys[i].remove(block.getKey());\n\t\t\t}\n\t\t}\n\t\tfinal Key key = block.getKey();\n\t\tschedTransient.tripPendingKey(key, block, null, clientContext);\n\t\tif(schedCore.anyProbablyWantKey(key, clientContext)) {\n\t\t\tjobRunner.queue(new DBJob() {\n\n\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"tripPendingKey for \"+key);\n\t\t\t\t\tschedCore.tripPendingKey(key, block, container, clientContext);\n\t\t\t\t}\n\t\t\t}, TRIP_PENDING_PRIORITY, false);\n\t\t}\n\t\t\n\t}","id":24153,"modified_method":"public void tripPendingKey(final KeyBlock block) {\n\t\tif(logMINOR) Logger.minor(this, \"tripPendingKey(\"+block.getKey()+\")\");\n\t\t\n\t\tif(offeredKeys != null) {\n\t\t\tfor(int i=0;i<offeredKeys.length;i++) {\n\t\t\t\tofferedKeys[i].remove(block.getKey());\n\t\t\t}\n\t\t}\n\t\tfinal Key key = block.getKey();\n\t\tschedTransient.tripPendingKey(key, block, null, clientContext);\n\t\tif(schedCore.anyProbablyWantKey(key, clientContext)) {\n\t\t\tjobRunner.queue(new DBJob() {\n\n\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"tripPendingKey for \"+key);\n\t\t\t\t\tschedCore.tripPendingKey(key, block, container, clientContext);\n\t\t\t\t}\n\t\t\t}, TRIP_PENDING_PRIORITY, false);\n\t\t} else schedCore.countNegative();\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"private boolean moveKeysFromCooldownQueue(CooldownQueue queue, boolean persistent, ObjectContainer container) {\n\t\tif(queue == null) return false;\n\t\tlong now = System.currentTimeMillis();\n\t\t/*\n\t\t * Only go around once. We will be called again. If there are keys to move, then RequestStarter will not\n\t\t * sleep, because it will start them. Then it will come back here. If we are off-thread i.e. on the database\n\t\t * thread, then we will wake it up if we find keys... and we'll be scheduled again.\n\t\t * \n\t\t * FIXME: I think we need to restore all the listeners for a single key \n\t\t * simultaneously to avoid some kind of race condition? Or could we just\n\t\t * restore the one request on the queue? Maybe it's just a misguided\n\t\t * optimisation? IIRC we had some severe problems when we didn't have \n\t\t * this, related to requests somehow being lost altogether... Is it \n\t\t * essential? We can save a query if it's not... Is this about requests\n\t\t * or about keys? Should we limit all requests across any \n\t\t * SendableRequest's to 3 every half hour for a specific key? Probably \n\t\t * yes...? In which case, can the cooldown queue be entirely in RAM,\n\t\t * and would it be useful for it to be? Less disk, more RAM... for fast\n\t\t * nodes with little RAM it would be bad...\n\t\t */\n\t\tfinal int MAX_KEYS = 20;\n\t\tKey[] keys = queue.removeKeyBefore(now, container, MAX_KEYS);\n\t\tif(keys == null) return false;\n\t\tfor(int j=0;j<keys.length;j++) {\n\t\t\tKey key = keys[j];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(key, 5);\n\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key: \"+key);\n\t\t\tSendableGet[] reqs = schedCore.requestsForKey(key, container, clientContext);\n\t\t\tSendableGet[] transientReqs = schedTransient.requestsForKey(key, container, clientContext);\n\t\t\tif(reqs == null && transientReqs == null) {\n\t\t\t\t// Not an error as this can happen due to race conditions etc.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key but no keys queued?? for \"+key);\n\t\t\t}\n\t\t\tif(reqs != null) {\n\t\t\t\tfor(int i=0;i<reqs.length;i++)\n\t\t\t\t\treqs[i].requeueAfterCooldown(key, now, container, clientContext);\n\t\t\t}\n\t\t\tif(transientReqs != null) {\n\t\t\t\tfor(int i=0;i<transientReqs.length;i++)\n\t\t\t\t\ttransientReqs[i].requeueAfterCooldown(key, now, container, clientContext);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(key, 5);\n\t\t}\n\t\treturn true;\n\t}","id":24154,"modified_method":"private boolean moveKeysFromCooldownQueue(CooldownQueue queue, boolean persistent, ObjectContainer container) {\n\t\tif(queue == null) return false;\n\t\tlong now = System.currentTimeMillis();\n\t\t/*\n\t\t * Only go around once. We will be called again. If there are keys to move, then RequestStarter will not\n\t\t * sleep, because it will start them. Then it will come back here. If we are off-thread i.e. on the database\n\t\t * thread, then we will wake it up if we find keys... and we'll be scheduled again.\n\t\t * \n\t\t * FIXME: I think we need to restore all the listeners for a single key \n\t\t * simultaneously to avoid some kind of race condition? Or could we just\n\t\t * restore the one request on the queue? Maybe it's just a misguided\n\t\t * optimisation? IIRC we had some severe problems when we didn't have \n\t\t * this, related to requests somehow being lost altogether... Is it \n\t\t * essential? We can save a query if it's not... Is this about requests\n\t\t * or about keys? Should we limit all requests across any \n\t\t * SendableRequest's to 3 every half hour for a specific key? Probably \n\t\t * yes...? In which case, can the cooldown queue be entirely in RAM,\n\t\t * and would it be useful for it to be? Less disk, more RAM... for fast\n\t\t * nodes with little RAM it would be bad...\n\t\t */\n\t\tfinal int MAX_KEYS = 20;\n\t\tKey[] keys = queue.removeKeyBefore(now, container, MAX_KEYS);\n\t\tif(keys == null) return false;\n\t\tfor(int j=0;j<keys.length;j++) {\n\t\t\tKey key = keys[j];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(key, 5);\n\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key: \"+key);\n\t\t\tSendableGet[] reqs = schedCore.requestsForKey(key, container, clientContext);\n\t\t\tSendableGet[] transientReqs = schedTransient.requestsForKey(key, container, clientContext);\n\t\t\tif(reqs == null && transientReqs == null) {\n\t\t\t\t// Not an error as this can happen due to race conditions etc.\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Restoring key but no keys queued?? for \"+key);\n\t\t\t}\n\t\t\tif(reqs != null) {\n\t\t\t\tfor(int i=0;i<reqs.length;i++) {\n\t\t\t\t\tcontainer.activate(reqs[i], 1);\n\t\t\t\t\treqs[i].requeueAfterCooldown(key, now, container, clientContext);\n\t\t\t\t\tcontainer.deactivate(reqs[i], 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(transientReqs != null) {\n\t\t\t\tfor(int i=0;i<transientReqs.length;i++)\n\t\t\t\t\ttransientReqs[i].requeueAfterCooldown(key, now, container, clientContext);\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.deactivate(key, 5);\n\t\t}\n\t\treturn true;\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"public void callFailure(final SendableGet get, final LowLevelGetException e, int prio, boolean persistent) {\n\t\tif(!persistent) {\n\t\t\tget.onFailure(e, null, null, clientContext);\n\t\t} else {\n\t\t\tjobRunner.queue(new DBJob() {\n\n\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\tget.onFailure(e, null, container, clientContext);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}, prio, false);\n\t\t}\n\t}","id":24155,"modified_method":"public void callFailure(final SendableGet get, final LowLevelGetException e, int prio, boolean persistent) {\n\t\tif(!persistent) {\n\t\t\tget.onFailure(e, null, null, clientContext);\n\t\t} else {\n\t\t\tjobRunner.queue(new DBJob() {\n\n\t\t\t\tpublic void run(ObjectContainer container, ClientContext context) {\n\t\t\t\t\tcontainer.activate(get, 1);\n\t\t\t\t\tget.onFailure(e, null, container, clientContext);\n\t\t\t\t\tcontainer.deactivate(get, 1);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}, prio, false);\n\t\t}\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"public SplitFileFetcher(Metadata metadata, GetCompletionCallback rcb, ClientRequester parent2,\n\t\t\tFetchContext newCtx, ArrayList decompressors2, ClientMetadata clientMetadata, \n\t\t\tArchiveContext actx, int recursionLevel, Bucket returnBucket, long token2, ObjectContainer container, ClientContext context) throws FetchException, MetadataParseException {\n\t\tthis.persistent = parent2.persistent();\n\t\tthis.hashCode = super.hashCode();\n\t\tthis.finished = false;\n\t\tthis.returnBucket = returnBucket;\n\t\tthis.fetchContext = newCtx;\n\t\tthis.archiveContext = actx;\n\t\tthis.decompressors = decompressors2;\n\t\tthis.clientMetadata = clientMetadata;\n\t\tthis.cb = rcb;\n\t\tthis.recursionLevel = recursionLevel + 1;\n\t\tthis.parent = parent2;\n\t\tlocalSalt = new byte[32];\n\t\tcontext.random.nextBytes(localSalt);\n\t\tif(parent2.isCancelled())\n\t\t\tthrow new FetchException(FetchException.CANCELLED);\n\t\toverrideLength = metadata.dataLength();\n\t\tthis.splitfileType = metadata.getSplitfileType();\n\t\tClientCHK[] splitfileDataBlocks = metadata.getSplitfileDataKeys();\n\t\tClientCHK[] splitfileCheckBlocks = metadata.getSplitfileCheckKeys();\n\t\tfor(int i=0;i<splitfileDataBlocks.length;i++)\n\t\t\tif(splitfileDataBlocks[i] == null) throw new MetadataParseException(\"Null: data block \"+i+\" of \"+splitfileDataBlocks.length);\n\t\tfor(int i=0;i<splitfileCheckBlocks.length;i++)\n\t\t\tif(splitfileCheckBlocks[i] == null) throw new MetadataParseException(\"Null: check block \"+i+\" of \"+splitfileCheckBlocks.length);\n\t\tlong finalLength = 1L * splitfileDataBlocks.length * CHKBlock.DATA_LENGTH;\n\t\tif(finalLength > overrideLength) {\n\t\t\tif(finalLength - overrideLength > CHKBlock.DATA_LENGTH)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile is \"+finalLength+\" but length is \"+finalLength);\n\t\t\tfinalLength = overrideLength;\n\t\t}\n\t\tlong eventualLength = Math.max(overrideLength, metadata.uncompressedDataLength());\n\t\tcb.onExpectedSize(eventualLength, container);\n\t\tString mimeType = metadata.getMIMEType();\n\t\tif(mimeType != null)\n\t\t\tcb.onExpectedMIME(mimeType, container);\n\t\tif(metadata.uncompressedDataLength() > 0)\n\t\t\tcb.onFinalizedMetadata(container);\n\t\tif(eventualLength > 0 && newCtx.maxOutputLength > 0 && eventualLength > newCtx.maxOutputLength)\n\t\t\tthrow new FetchException(FetchException.TOO_BIG, eventualLength, true, clientMetadata.getMIMEType());\n\t\t\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\t// Don't need to do much - just fetch everything and piece it together.\n\t\t\tblocksPerSegment = -1;\n\t\t\tcheckBlocksPerSegment = -1;\n\t\t\tsegmentCount = 1;\n\t\t\tif(splitfileCheckBlocks.length > 0) {\n\t\t\t\tLogger.error(this, \"Splitfile type is SPLITFILE_NONREDUNDANT yet \"+splitfileCheckBlocks.length+\" check blocks found!! : \"+this);\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile type is non-redundant yet have \"+splitfileCheckBlocks.length+\" check blocks\");\n\t\t\t}\n\t\t} else if(splitfileType == Metadata.SPLITFILE_ONION_STANDARD) {\n\t\t\tbyte[] params = metadata.splitfileParams();\n\t\t\tif((params == null) || (params.length < 8))\n\t\t\t\tthrow new MetadataParseException(\"No splitfile params\");\n\t\t\tblocksPerSegment = Fields.bytesToInt(params, 0);\n\t\t\tint checkBlocks = Fields.bytesToInt(params, 4);\n\t\t\t\n\t\t\t// FIXME remove this eventually. Will break compat with a few files inserted between 1135 and 1136.\n\t\t\t// Work around a bug around build 1135.\n\t\t\t// We were splitting as (128,255), but we were then setting the checkBlocksPerSegment to 64.\n\t\t\t// Detect this.\n\t\t\tif(checkBlocks == 64 && blocksPerSegment == 128 &&\n\t\t\t\t\tsplitfileCheckBlocks.length == splitfileDataBlocks.length - (splitfileDataBlocks.length / 128)) {\n\t\t\t\tLogger.normal(this, \"Activating 1135 wrong check blocks per segment workaround for \"+this);\n\t\t\t\tcheckBlocks = 127;\n\t\t\t}\n\t\t\tcheckBlocksPerSegment = checkBlocks;\n\t\t\t\n\t\t\tif((blocksPerSegment > fetchContext.maxDataBlocksPerSegment)\n\t\t\t\t\t|| (checkBlocksPerSegment > fetchContext.maxCheckBlocksPerSegment))\n\t\t\t\tthrow new FetchException(FetchException.TOO_MANY_BLOCKS_PER_SEGMENT, \"Too many blocks per segment: \"+blocksPerSegment+\" data, \"+checkBlocksPerSegment+\" check\");\n\t\t\tsegmentCount = (splitfileDataBlocks.length / blocksPerSegment) +\n\t\t\t\t(splitfileDataBlocks.length % blocksPerSegment == 0 ? 0 : 1);\n\t\t\t// Onion, 128/192.\n\t\t\t// Will be segmented.\n\t\t} else throw new MetadataParseException(\"Unknown splitfile format: \"+splitfileType);\n\t\tthis.maxTempLength = fetchContext.maxTempLength;\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Algorithm: \"+splitfileType+\", blocks per segment: \"+blocksPerSegment+\n\t\t\t\t\t\", check blocks per segment: \"+checkBlocksPerSegment+\", segments: \"+segmentCount+\n\t\t\t\t\t\", data blocks: \"+splitfileDataBlocks.length+\", check blocks: \"+splitfileCheckBlocks.length);\n\t\tsegments = new SplitFileFetcherSegment[segmentCount]; // initially null on all entries\n\t\tif(segmentCount == 1) {\n\t\t\t// splitfile* will be overwritten, this is bad\n\t\t\t// so copy them\n\t\t\tClientCHK[] newSplitfileDataBlocks = new ClientCHK[splitfileDataBlocks.length];\n\t\t\tClientCHK[] newSplitfileCheckBlocks = new ClientCHK[splitfileCheckBlocks.length];\n\t\t\tSystem.arraycopy(splitfileDataBlocks, 0, newSplitfileDataBlocks, 0, splitfileDataBlocks.length);\n\t\t\tif(splitfileCheckBlocks.length > 0)\n\t\t\t\tSystem.arraycopy(splitfileCheckBlocks, 0, newSplitfileCheckBlocks, 0, splitfileCheckBlocks.length);\n\t\t\tsegments[0] = new SplitFileFetcherSegment(splitfileType, newSplitfileDataBlocks, newSplitfileCheckBlocks, \n\t\t\t\t\tthis, archiveContext, fetchContext, maxTempLength, recursionLevel, parent, 0);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.set(segments[0]);\n\t\t\t}\n\t\t} else {\n\t\t\tint dataBlocksPtr = 0;\n\t\t\tint checkBlocksPtr = 0;\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\t// Create a segment. Give it its keys.\n\t\t\t\tint copyDataBlocks = Math.min(splitfileDataBlocks.length - dataBlocksPtr, blocksPerSegment);\n\t\t\t\tint copyCheckBlocks = Math.min(splitfileCheckBlocks.length - checkBlocksPtr, checkBlocksPerSegment);\n\t\t\t\tClientCHK[] dataBlocks = new ClientCHK[copyDataBlocks];\n\t\t\t\tClientCHK[] checkBlocks = new ClientCHK[copyCheckBlocks];\n\t\t\t\tif(copyDataBlocks > 0)\n\t\t\t\t\tSystem.arraycopy(splitfileDataBlocks, dataBlocksPtr, dataBlocks, 0, copyDataBlocks);\n\t\t\t\tif(copyCheckBlocks > 0)\n\t\t\t\t\tSystem.arraycopy(splitfileCheckBlocks, checkBlocksPtr, checkBlocks, 0, copyCheckBlocks);\n\t\t\t\tdataBlocksPtr += copyDataBlocks;\n\t\t\t\tcheckBlocksPtr += copyCheckBlocks;\n\t\t\t\tsegments[i] = new SplitFileFetcherSegment(splitfileType, dataBlocks, checkBlocks, this, archiveContext, \n\t\t\t\t\t\tfetchContext, maxTempLength, recursionLevel+1, parent, i);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.set(segments[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dataBlocksPtr != splitfileDataBlocks.length)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Unable to allocate all data blocks to segments - buggy or malicious inserter\");\n\t\t\tif(checkBlocksPtr != splitfileCheckBlocks.length)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Unable to allocate all check blocks to segments - buggy or malicious inserter\");\n\t\t}\n\t\tthis.token = token2;\n\t\tparent.addBlocks(splitfileDataBlocks.length + splitfileCheckBlocks.length, container);\n\t\tparent.addMustSucceedBlocks(splitfileDataBlocks.length, container);\n\t\tparent.notifyClients(container, context);\n\t\t\n\t\t// Setup bloom parameters.\n\t\tif(persistent) {\n\t\t\t// FIXME: Should this be encrypted? It's protected to some degree by the salt...\n\t\t\t// Since it isn't encrypted, it's likely to be very sparse; we should name\n\t\t\t// it appropriately...\n\t\t\ttry {\n\t\t\t\tmainBloomFile = context.fg.makeRandomFile();\n\t\t\t\taltBloomFile = context.fg.makeRandomFile();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to create Bloom filter files\", e);\n\t\t\t}\n\t\t} else {\n\t\t\t// Not persistent, keep purely in RAM.\n\t\t\tmainBloomFile = null;\n\t\t\taltBloomFile = null;\n\t\t}\n\t\tint mainElementsPerKey = DEFAULT_MAIN_BLOOM_ELEMENTS_PER_KEY;\n\t\tint origSize = splitfileDataBlocks.length + splitfileCheckBlocks.length;\n\t\tmainBloomK = (int) (mainElementsPerKey * 0.7);\n\t\tlong elementsLong = origSize * mainElementsPerKey;\n\t\t// REDFLAG: SIZE LIMIT: 3.36TB limit!\n\t\tif(elementsLong > Integer.MAX_VALUE)\n\t\t\tthrow new FetchException(FetchException.TOO_BIG, \"Cannot fetch splitfiles with more than \"+(Integer.MAX_VALUE/mainElementsPerKey)+\" keys! (approx 3.3TB)\");\n\t\tint mainSizeBits = (int)elementsLong; // counting filter\n\t\tif((mainSizeBits & 7) != 0)\n\t\t\tmainSizeBits += (8 - (mainSizeBits & 7));\n\t\tmainBloomFilterSizeBytes = mainSizeBits / 8 * 2; // counting filter\n\t\tdouble acceptableFalsePositives = ACCEPTABLE_BLOOM_FALSE_POSITIVES_ALL_SEGMENTS / segments.length;\n\t\tint perSegmentBitsPerKey = (int) Math.ceil(Math.log(acceptableFalsePositives) / Math.log(0.6185));\n\t\tint segBlocks = blocksPerSegment + checkBlocksPerSegment;\n\t\tif(segBlocks < origSize)\n\t\t\tsegBlocks = origSize;\n\t\tint perSegmentSize = perSegmentBitsPerKey * segBlocks;\n\t\tif((perSegmentSize & 7) != 0)\n\t\t\tperSegmentSize += (8 - (perSegmentSize & 7));\n\t\tperSegmentBloomFilterSizeBytes = perSegmentSize / 8;\n\t\tperSegmentK = BloomFilter.optimialK(perSegmentSize, blocksPerSegment + checkBlocksPerSegment);\n\t\tkeyCount = origSize;\n\t\t// Now create it.\n\t\tLogger.error(this, \"Creating block filter for \"+this+\": keys=\"+(splitfileDataBlocks.length+splitfileCheckBlocks.length)+\" main bloom size \"+mainBloomFilterSizeBytes+\" bytes, K=\"+mainBloomK+\", filename=\"+mainBloomFile+\" alt bloom filter: segments: \"+segments.length+\" each is \"+perSegmentBloomFilterSizeBytes+\" bytes k=\"+perSegmentK);\n\t\ttry {\n\t\t\ttempListener = new SplitFileFetcherKeyListener(this, keyCount, mainBloomFile, altBloomFile, mainBloomFilterSizeBytes, mainBloomK, !fetchContext.cacheLocalRequests, localSalt, segments.length, perSegmentBloomFilterSizeBytes, perSegmentK, persistent, true);\n\t\t\t\n\t\t\t// Now add the keys\n\t\t\tint dataKeysIndex = 0;\n\t\t\tint checkKeysIndex = 0;\n\t\t\tint segNo = 0;\n\t\t\twhile(dataKeysIndex < splitfileDataBlocks.length) {\n\t\t\t\tint dataKeysEnd = dataKeysIndex + blocksPerSegment;\n\t\t\t\tint checkKeysEnd = checkKeysIndex + checkBlocksPerSegment;\n\t\t\t\tdataKeysEnd = Math.min(dataKeysEnd, splitfileDataBlocks.length);\n\t\t\t\tcheckKeysEnd = Math.min(checkKeysEnd, splitfileCheckBlocks.length);\n\t\t\t\tfor(int j=dataKeysIndex;j<dataKeysEnd;j++)\n\t\t\t\t\ttempListener.addKey(splitfileDataBlocks[j].getNodeKey(), segNo, context);\n\t\t\t\tfor(int j=checkKeysIndex;j<checkKeysEnd;j++)\n\t\t\t\t\ttempListener.addKey(splitfileCheckBlocks[j].getNodeKey(), segNo, context);\n\t\t\t\tsegNo++;\n\t\t\t\tdataKeysIndex = dataKeysEnd;\n\t\t\t\tcheckKeysIndex = checkKeysEnd;\n\t\t\t}\n\t\t\ttempListener.writeFilters();\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to write Bloom filters for splitfile\");\n\t\t}\n\t\tif(persistent) {\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\tsegments[i].deactivateKeys(container);\n\t\t\t}\n\t\t}\n\t}","id":24156,"modified_method":"public SplitFileFetcher(Metadata metadata, GetCompletionCallback rcb, ClientRequester parent2,\n\t\t\tFetchContext newCtx, ArrayList decompressors2, ClientMetadata clientMetadata, \n\t\t\tArchiveContext actx, int recursionLevel, Bucket returnBucket, long token2, ObjectContainer container, ClientContext context) throws FetchException, MetadataParseException {\n\t\tthis.persistent = parent2.persistent();\n\t\tthis.hashCode = super.hashCode();\n\t\tthis.finished = false;\n\t\tthis.returnBucket = returnBucket;\n\t\tthis.fetchContext = newCtx;\n\t\tthis.archiveContext = actx;\n\t\tthis.decompressors = decompressors2;\n\t\tif(decompressors.size() > 1) {\n\t\t\tLogger.error(this, \"Multiple decompressors: \"+decompressors.size()+\" - this is almost certainly a bug\", new Exception(\"debug\"));\n\t\t}\n\t\tthis.clientMetadata = clientMetadata;\n\t\tthis.cb = rcb;\n\t\tthis.recursionLevel = recursionLevel + 1;\n\t\tthis.parent = parent2;\n\t\tlocalSalt = new byte[32];\n\t\tcontext.random.nextBytes(localSalt);\n\t\tif(parent2.isCancelled())\n\t\t\tthrow new FetchException(FetchException.CANCELLED);\n\t\toverrideLength = metadata.dataLength();\n\t\tthis.splitfileType = metadata.getSplitfileType();\n\t\tClientCHK[] splitfileDataBlocks = metadata.getSplitfileDataKeys();\n\t\tClientCHK[] splitfileCheckBlocks = metadata.getSplitfileCheckKeys();\n\t\tfor(int i=0;i<splitfileDataBlocks.length;i++)\n\t\t\tif(splitfileDataBlocks[i] == null) throw new MetadataParseException(\"Null: data block \"+i+\" of \"+splitfileDataBlocks.length);\n\t\tfor(int i=0;i<splitfileCheckBlocks.length;i++)\n\t\t\tif(splitfileCheckBlocks[i] == null) throw new MetadataParseException(\"Null: check block \"+i+\" of \"+splitfileCheckBlocks.length);\n\t\tlong finalLength = 1L * splitfileDataBlocks.length * CHKBlock.DATA_LENGTH;\n\t\tif(finalLength > overrideLength) {\n\t\t\tif(finalLength - overrideLength > CHKBlock.DATA_LENGTH)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile is \"+finalLength+\" but length is \"+finalLength);\n\t\t\tfinalLength = overrideLength;\n\t\t}\n\t\tlong eventualLength = Math.max(overrideLength, metadata.uncompressedDataLength());\n\t\tcb.onExpectedSize(eventualLength, container);\n\t\tString mimeType = metadata.getMIMEType();\n\t\tif(mimeType != null)\n\t\t\tcb.onExpectedMIME(mimeType, container);\n\t\tif(metadata.uncompressedDataLength() > 0)\n\t\t\tcb.onFinalizedMetadata(container);\n\t\tif(eventualLength > 0 && newCtx.maxOutputLength > 0 && eventualLength > newCtx.maxOutputLength)\n\t\t\tthrow new FetchException(FetchException.TOO_BIG, eventualLength, true, clientMetadata.getMIMEType());\n\t\t\n\t\tthis.token = token2;\n\t\t\n\t\tif(splitfileType == Metadata.SPLITFILE_NONREDUNDANT) {\n\t\t\t// Don't need to do much - just fetch everything and piece it together.\n\t\t\tblocksPerSegment = -1;\n\t\t\tcheckBlocksPerSegment = -1;\n\t\t\tsegmentCount = 1;\n\t\t\tif(splitfileCheckBlocks.length > 0) {\n\t\t\t\tLogger.error(this, \"Splitfile type is SPLITFILE_NONREDUNDANT yet \"+splitfileCheckBlocks.length+\" check blocks found!! : \"+this);\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Splitfile type is non-redundant yet have \"+splitfileCheckBlocks.length+\" check blocks\");\n\t\t\t}\n\t\t} else if(splitfileType == Metadata.SPLITFILE_ONION_STANDARD) {\n\t\t\tbyte[] params = metadata.splitfileParams();\n\t\t\tif((params == null) || (params.length < 8))\n\t\t\t\tthrow new MetadataParseException(\"No splitfile params\");\n\t\t\tblocksPerSegment = Fields.bytesToInt(params, 0);\n\t\t\tint checkBlocks = Fields.bytesToInt(params, 4);\n\t\t\t\n\t\t\t// FIXME remove this eventually. Will break compat with a few files inserted between 1135 and 1136.\n\t\t\t// Work around a bug around build 1135.\n\t\t\t// We were splitting as (128,255), but we were then setting the checkBlocksPerSegment to 64.\n\t\t\t// Detect this.\n\t\t\tif(checkBlocks == 64 && blocksPerSegment == 128 &&\n\t\t\t\t\tsplitfileCheckBlocks.length == splitfileDataBlocks.length - (splitfileDataBlocks.length / 128)) {\n\t\t\t\tLogger.normal(this, \"Activating 1135 wrong check blocks per segment workaround for \"+this);\n\t\t\t\tcheckBlocks = 127;\n\t\t\t}\n\t\t\tcheckBlocksPerSegment = checkBlocks;\n\t\t\t\n\t\t\tif((blocksPerSegment > fetchContext.maxDataBlocksPerSegment)\n\t\t\t\t\t|| (checkBlocksPerSegment > fetchContext.maxCheckBlocksPerSegment))\n\t\t\t\tthrow new FetchException(FetchException.TOO_MANY_BLOCKS_PER_SEGMENT, \"Too many blocks per segment: \"+blocksPerSegment+\" data, \"+checkBlocksPerSegment+\" check\");\n\t\t\tsegmentCount = (splitfileDataBlocks.length / blocksPerSegment) +\n\t\t\t\t(splitfileDataBlocks.length % blocksPerSegment == 0 ? 0 : 1);\n\t\t\t// Onion, 128/192.\n\t\t\t// Will be segmented.\n\t\t} else throw new MetadataParseException(\"Unknown splitfile format: \"+splitfileType);\n\t\tthis.maxTempLength = fetchContext.maxTempLength;\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Algorithm: \"+splitfileType+\", blocks per segment: \"+blocksPerSegment+\n\t\t\t\t\t\", check blocks per segment: \"+checkBlocksPerSegment+\", segments: \"+segmentCount+\n\t\t\t\t\t\", data blocks: \"+splitfileDataBlocks.length+\", check blocks: \"+splitfileCheckBlocks.length);\n\t\tsegments = new SplitFileFetcherSegment[segmentCount]; // initially null on all entries\n\t\t\n\t\t// Setup bloom parameters.\n\t\tif(persistent) {\n\t\t\t// FIXME: Should this be encrypted? It's protected to some degree by the salt...\n\t\t\t// Since it isn't encrypted, it's likely to be very sparse; we should name\n\t\t\t// it appropriately...\n\t\t\ttry {\n\t\t\t\tmainBloomFile = context.persistentFG.makeRandomFile();\n\t\t\t\taltBloomFile = context.persistentFG.makeRandomFile();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to create Bloom filter files\", e);\n\t\t\t}\n\t\t} else {\n\t\t\t// Not persistent, keep purely in RAM.\n\t\t\tmainBloomFile = null;\n\t\t\taltBloomFile = null;\n\t\t}\n\t\tint mainElementsPerKey = DEFAULT_MAIN_BLOOM_ELEMENTS_PER_KEY;\n\t\tint origSize = splitfileDataBlocks.length + splitfileCheckBlocks.length;\n\t\tmainBloomK = (int) (mainElementsPerKey * 0.7);\n\t\tlong elementsLong = origSize * mainElementsPerKey;\n\t\t// REDFLAG: SIZE LIMIT: 3.36TB limit!\n\t\tif(elementsLong > Integer.MAX_VALUE)\n\t\t\tthrow new FetchException(FetchException.TOO_BIG, \"Cannot fetch splitfiles with more than \"+(Integer.MAX_VALUE/mainElementsPerKey)+\" keys! (approx 3.3TB)\");\n\t\tint mainSizeBits = (int)elementsLong; // counting filter\n\t\tif((mainSizeBits & 7) != 0)\n\t\t\tmainSizeBits += (8 - (mainSizeBits & 7));\n\t\tmainBloomFilterSizeBytes = mainSizeBits / 8 * 2; // counting filter\n\t\tdouble acceptableFalsePositives = ACCEPTABLE_BLOOM_FALSE_POSITIVES_ALL_SEGMENTS / segments.length;\n\t\tint perSegmentBitsPerKey = (int) Math.ceil(Math.log(acceptableFalsePositives) / Math.log(0.6185));\n\t\tint segBlocks = blocksPerSegment + checkBlocksPerSegment;\n\t\tif(segBlocks > origSize)\n\t\t\tsegBlocks = origSize;\n\t\tint perSegmentSize = perSegmentBitsPerKey * segBlocks;\n\t\tif((perSegmentSize & 7) != 0)\n\t\t\tperSegmentSize += (8 - (perSegmentSize & 7));\n\t\tperSegmentBloomFilterSizeBytes = perSegmentSize / 8;\n\t\tperSegmentK = BloomFilter.optimialK(perSegmentSize, blocksPerSegment + checkBlocksPerSegment);\n\t\tkeyCount = origSize;\n\t\t// Now create it.\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Creating block filter for \"+this+\": keys=\"+(splitfileDataBlocks.length+splitfileCheckBlocks.length)+\" main bloom size \"+mainBloomFilterSizeBytes+\" bytes, K=\"+mainBloomK+\", filename=\"+mainBloomFile+\" alt bloom filter: filename=\"+altBloomFile+\" segments: \"+segments.length+\" each is \"+perSegmentBloomFilterSizeBytes+\" bytes k=\"+perSegmentK);\n\t\ttry {\n\t\t\ttempListener = new SplitFileFetcherKeyListener(this, keyCount, mainBloomFile, altBloomFile, mainBloomFilterSizeBytes, mainBloomK, !fetchContext.cacheLocalRequests, localSalt, segments.length, perSegmentBloomFilterSizeBytes, perSegmentK, persistent, true);\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to write Bloom filters for splitfile\");\n\t\t}\n\t\t\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\t\n\t\tif(segmentCount == 1) {\n\t\t\t// splitfile* will be overwritten, this is bad\n\t\t\t// so copy them\n\t\t\tClientCHK[] newSplitfileDataBlocks = new ClientCHK[splitfileDataBlocks.length];\n\t\t\tClientCHK[] newSplitfileCheckBlocks = new ClientCHK[splitfileCheckBlocks.length];\n\t\t\tSystem.arraycopy(splitfileDataBlocks, 0, newSplitfileDataBlocks, 0, splitfileDataBlocks.length);\n\t\t\tif(splitfileCheckBlocks.length > 0)\n\t\t\t\tSystem.arraycopy(splitfileCheckBlocks, 0, newSplitfileCheckBlocks, 0, splitfileCheckBlocks.length);\n\t\t\tsegments[0] = new SplitFileFetcherSegment(splitfileType, newSplitfileDataBlocks, newSplitfileCheckBlocks, \n\t\t\t\t\tthis, archiveContext, fetchContext, maxTempLength, recursionLevel, parent, 0);\n\t\t\tfor(int i=0;i<newSplitfileDataBlocks.length;i++)\n\t\t\t\ttempListener.addKey(newSplitfileDataBlocks[i].getNodeKey(), 0, context);\n\t\t\tfor(int i=0;i<newSplitfileCheckBlocks.length;i++)\n\t\t\t\ttempListener.addKey(newSplitfileCheckBlocks[i].getNodeKey(), 0, context);\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.set(segments[0]);\n\t\t\t\tsegments[0].deactivateKeys(container);\n\t\t\t}\n\t\t} else {\n\t\t\tint dataBlocksPtr = 0;\n\t\t\tint checkBlocksPtr = 0;\n\t\t\tfor(int i=0;i<segments.length;i++) {\n\t\t\t\t// Create a segment. Give it its keys.\n\t\t\t\tint copyDataBlocks = Math.min(splitfileDataBlocks.length - dataBlocksPtr, blocksPerSegment);\n\t\t\t\tint copyCheckBlocks = Math.min(splitfileCheckBlocks.length - checkBlocksPtr, checkBlocksPerSegment);\n\t\t\t\tClientCHK[] dataBlocks = new ClientCHK[copyDataBlocks];\n\t\t\t\tClientCHK[] checkBlocks = new ClientCHK[copyCheckBlocks];\n\t\t\t\tif(copyDataBlocks > 0)\n\t\t\t\t\tSystem.arraycopy(splitfileDataBlocks, dataBlocksPtr, dataBlocks, 0, copyDataBlocks);\n\t\t\t\tif(copyCheckBlocks > 0)\n\t\t\t\t\tSystem.arraycopy(splitfileCheckBlocks, checkBlocksPtr, checkBlocks, 0, copyCheckBlocks);\n\t\t\t\tdataBlocksPtr += copyDataBlocks;\n\t\t\t\tcheckBlocksPtr += copyCheckBlocks;\n\t\t\t\tsegments[i] = new SplitFileFetcherSegment(splitfileType, dataBlocks, checkBlocks, this, archiveContext, \n\t\t\t\t\t\tfetchContext, maxTempLength, recursionLevel+1, parent, i);\n\t\t\t\tfor(int j=0;j<dataBlocks.length;j++)\n\t\t\t\t\ttempListener.addKey(dataBlocks[j].getNodeKey(), i, context);\n\t\t\t\tfor(int j=0;j<checkBlocks.length;j++)\n\t\t\t\t\ttempListener.addKey(checkBlocks[j].getNodeKey(), i, context);\n\t\t\t\tif(persistent) {\n\t\t\t\t\tcontainer.set(segments[i]);\n\t\t\t\t\tsegments[i].deactivateKeys(container);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dataBlocksPtr != splitfileDataBlocks.length)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Unable to allocate all data blocks to segments - buggy or malicious inserter\");\n\t\t\tif(checkBlocksPtr != splitfileCheckBlocks.length)\n\t\t\t\tthrow new FetchException(FetchException.INVALID_METADATA, \"Unable to allocate all check blocks to segments - buggy or malicious inserter\");\n\t\t}\n\t\tparent.addBlocks(splitfileDataBlocks.length + splitfileCheckBlocks.length, container);\n\t\tparent.addMustSucceedBlocks(splitfileDataBlocks.length, container);\n\t\tparent.notifyClients(container, context);\n\t\t\n\t\ttry {\n\t\t\ttempListener.writeFilters();\n\t\t} catch (IOException e) {\n\t\t\tthrow new FetchException(FetchException.BUCKET_ERROR, \"Unable to write Bloom filters for splitfile\");\n\t\t}\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Make our SplitFileFetcherKeyListener. Returns the one we created in the\n\t * constructor if possible, otherwise makes a new one. We must have already\n\t * constructed one at some point, maybe before a restart.\n\t * @throws FetchException \n\t */\n\tpublic KeyListener makeKeyListener(ObjectContainer container, ClientContext context) throws KeyListenerConstructionException {\n\t\tsynchronized(this) {\n\t\t\tif(tempListener != null) {\n\t\t\t\t// Recently constructed\n\t\t\t\treturn tempListener;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\ttempListener =\n\t\t\t\t\tnew SplitFileFetcherKeyListener(this, keyCount, mainBloomFile, altBloomFile, mainBloomFilterSizeBytes, mainBloomK, !fetchContext.cacheLocalRequests, localSalt, segments.length, perSegmentBloomFilterSizeBytes, perSegmentK, persistent, false);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Unable to read Bloom filter for \"+this+\" attempting to reconstruct...\");\n\t\t\t\tmainBloomFile.delete();\n\t\t\t\taltBloomFile.delete();\n\t\t\t\ttry {\n\t\t\t\t\tmainBloomFile = context.fg.makeRandomFile();\n\t\t\t\t\taltBloomFile = context.fg.makeRandomFile();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tthrow new KeyListenerConstructionException(new FetchException(FetchException.BUCKET_ERROR, \"Unable to create Bloom filter files in reconstruction\", e1));\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\ttempListener = \n\t\t\t\t\t\tnew SplitFileFetcherKeyListener(this, keyCount, mainBloomFile, altBloomFile, mainBloomFilterSizeBytes, mainBloomK, !fetchContext.cacheLocalRequests, localSalt, segments.length, perSegmentBloomFilterSizeBytes, perSegmentK, persistent, true);\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tthrow new KeyListenerConstructionException(new FetchException(FetchException.BUCKET_ERROR, \"Unable to reconstruct Bloom filters: \"+e1, e1));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tempListener;\n\t\t}\n\t}","id":24157,"modified_method":"/**\n\t * Make our SplitFileFetcherKeyListener. Returns the one we created in the\n\t * constructor if possible, otherwise makes a new one. We must have already\n\t * constructed one at some point, maybe before a restart.\n\t * @throws FetchException \n\t */\n\tpublic KeyListener makeKeyListener(ObjectContainer container, ClientContext context) throws KeyListenerConstructionException {\n\t\tsynchronized(this) {\n\t\t\tif(finished) return null;\n\t\t\tif(tempListener != null) {\n\t\t\t\t// Recently constructed\n\t\t\t\treturn tempListener;\n\t\t\t}\n\t\t\tFile main;\n\t\t\tFile alt;\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.activate(mainBloomFile, 5);\n\t\t\t\tcontainer.activate(altBloomFile, 5);\n\t\t\t\tmain = new File(mainBloomFile.getPath());\n\t\t\t\talt = new File(altBloomFile.getPath());\n\t\t\t\tcontainer.deactivate(mainBloomFile, 1);\n\t\t\t\tcontainer.deactivate(altBloomFile, 1);\n\t\t\t} else {\n\t\t\t\tmain = null;\n\t\t\t\talt = null;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Attempting to read Bloom filter for \"+this+\" main file=\"+main+\" alt file=\"+alt);\n\t\t\t\ttempListener =\n\t\t\t\t\tnew SplitFileFetcherKeyListener(this, keyCount, main, alt, mainBloomFilterSizeBytes, mainBloomK, !fetchContext.cacheLocalRequests, localSalt, segments.length, perSegmentBloomFilterSizeBytes, perSegmentK, persistent, false);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLogger.error(this, \"Unable to read Bloom filter for \"+this+\" attempting to reconstruct...\", e);\n\t\t\t\tmainBloomFile.delete();\n\t\t\t\taltBloomFile.delete();\n\t\t\t\ttry {\n\t\t\t\t\tmainBloomFile = context.fg.makeRandomFile();\n\t\t\t\t\taltBloomFile = context.fg.makeRandomFile();\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tthrow new KeyListenerConstructionException(new FetchException(FetchException.BUCKET_ERROR, \"Unable to create Bloom filter files in reconstruction\", e1));\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\ttempListener = \n\t\t\t\t\t\tnew SplitFileFetcherKeyListener(this, keyCount, mainBloomFile, altBloomFile, mainBloomFilterSizeBytes, mainBloomK, !fetchContext.cacheLocalRequests, localSalt, segments.length, perSegmentBloomFilterSizeBytes, perSegmentK, persistent, true);\n\t\t\t\t} catch (IOException e1) {\n\t\t\t\t\tthrow new KeyListenerConstructionException(new FetchException(FetchException.BUCKET_ERROR, \"Unable to reconstruct Bloom filters: \"+e1, e1));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tempListener;\n\t\t}\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"private void finish(ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(cb, 1);\n\t\t}\n\t\tcontext.getChkFetchScheduler().removePendingKeys(this, true);\n\t\ttry {\n\t\t\tsynchronized(this) {\n\t\t\t\tif(otherFailure != null) throw otherFailure;\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Was already finished\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinished = true;\n\t\t\t}\n\t\t\tBucket data = finalStatus(container, context);\n\t\t\t// Decompress\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.set(this);\n\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\tcontainer.activate(cb, 1);\n\t\t\t\tcontainer.activate(fetchContext, 1);\n\t\t\t}\n\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\tCompressor c = (Compressor) decompressors.remove(decompressors.size()-1);\n\t\t\t\tlong maxLen = Math.max(fetchContext.maxTempLength, fetchContext.maxOutputLength);\n\t\t\t\ttry {\n\t\t\t\t\tBucket out = returnBucket;\n\t\t\t\t\tif(!decompressors.isEmpty()) out = null;\n\t\t\t\t\tdata = c.decompress(data, context.getBucketFactory(parent.persistent()), maxLen, maxLen * 4, out);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tcb.onFailure(new FetchException(FetchException.BUCKET_ERROR, e), this, container, context);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\t\tLogger.minor(this, \"Too big: maxSize = \"+fetchContext.maxOutputLength+\" maxTempSize = \"+fetchContext.maxTempLength);\n\t\t\t\t\tcb.onFailure(new FetchException(FetchException.TOO_BIG, e.estimatedSize, false /* FIXME */, clientMetadata.getMIMEType()), this, container, context);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb.onSuccess(new FetchResult(clientMetadata, data), this, container, context);\n\t\t} catch (FetchException e) {\n\t\t\tcb.onFailure(e, this, container, context);\n\t\t} catch (OutOfMemoryError e) {\n\t\t\tOOMHandler.handleOOM(e);\n\t\t\tSystem.err.println(\"Failing above attempted fetch...\");\n\t\t\tcb.onFailure(new FetchException(FetchException.INTERNAL_ERROR, e), this, container, context);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tcb.onFailure(new FetchException(FetchException.INTERNAL_ERROR, t), this, container, context);\n\t\t}\n\t}","id":24158,"modified_method":"private void finish(ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(cb, 1);\n\t\t}\n\t\tcontext.getChkFetchScheduler().removePendingKeys(this, true);\n\t\ttry {\n\t\t\tsynchronized(this) {\n\t\t\t\tif(otherFailure != null) throw otherFailure;\n\t\t\t\tif(finished) {\n\t\t\t\t\tLogger.error(this, \"Was already finished\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfinished = true;\n\t\t\t}\n\t\t\tBucket data = finalStatus(container, context);\n\t\t\t// Decompress\n\t\t\tif(persistent) {\n\t\t\t\tcontainer.set(this);\n\t\t\t\tcontainer.activate(decompressors, 5);\n\t\t\t\tcontainer.activate(returnBucket, 5);\n\t\t\t\tcontainer.activate(cb, 1);\n\t\t\t\tcontainer.activate(fetchContext, 1);\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\twhile(!decompressors.isEmpty()) {\n\t\t\t\tCompressor c = (Compressor) decompressors.remove(decompressors.size()-1);\n\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\tLogger.minor(this, \"Decompressing with \"+c);\n\t\t\t\tlong maxLen = Math.max(fetchContext.maxTempLength, fetchContext.maxOutputLength);\n\t\t\t\ttry {\n\t\t\t\t\tBucket out = returnBucket;\n\t\t\t\t\tif(!decompressors.isEmpty()) out = null;\n\t\t\t\t\tdata = c.decompress(data, context.getBucketFactory(parent.persistent()), maxLen, maxLen * 4, out);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tif(e.getMessage().equals(\"Not in GZIP format\") && count == 1) {\n\t\t\t\t\t\tLogger.error(this, \"Attempting to decompress twice, failed, returning first round data: \"+this);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcb.onFailure(new FetchException(FetchException.BUCKET_ERROR, e), this, container, context);\n\t\t\t\t\treturn;\n\t\t\t\t} catch (CompressionOutputSizeException e) {\n\t\t\t\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\t\t\t\tLogger.minor(this, \"Too big: maxSize = \"+fetchContext.maxOutputLength+\" maxTempSize = \"+fetchContext.maxTempLength);\n\t\t\t\t\tcb.onFailure(new FetchException(FetchException.TOO_BIG, e.estimatedSize, false /* FIXME */, clientMetadata.getMIMEType()), this, container, context);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tcb.onSuccess(new FetchResult(clientMetadata, data), this, container, context);\n\t\t} catch (FetchException e) {\n\t\t\tcb.onFailure(e, this, container, context);\n\t\t} catch (OutOfMemoryError e) {\n\t\t\tOOMHandler.handleOOM(e);\n\t\t\tSystem.err.println(\"Failing above attempted fetch...\");\n\t\t\tcb.onFailure(new FetchException(FetchException.INTERNAL_ERROR, e), this, container, context);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t, t);\n\t\t\tcb.onFailure(new FetchException(FetchException.INTERNAL_ERROR, t), this, container, context);\n\t\t}\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"public short definitelyWantKey(Key key, byte[] saltedKey, ObjectContainer container,\n\t\t\tClientContext context) {\n\t\t// Caller has already called probablyWantKey(), so don't do it again.\n\t\tbyte[] salted = localSaltKey(key);\n\t\tfor(int i=0;i<segmentFilters.length;i++) {\n\t\t\tif(segmentFilters[i].checkFilter(salted)) return prio;\n\t\t}\n\t\treturn -1;\n\t}","id":24159,"modified_method":"public short definitelyWantKey(Key key, byte[] saltedKey, ObjectContainer container,\n\t\t\tClientContext context) {\n\t\t// Caller has already called probablyWantKey(), so don't do it again.\n\t\tbyte[] salted = localSaltKey(key);\n\t\tfor(int i=0;i<segmentFilters.length;i++) {\n\t\t\tif(segmentFilters[i].checkFilter(salted)) {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(fetcher, 1);\n\t\t\t\tSplitFileFetcherSegment segment = fetcher.getSegment(i);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(fetcher, 1);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(segment, 1);\n\t\t\t\tboolean found = segment.getBlockNumber(key, container) >= 0;\n\t\t\t\tif(!found)\n\t\t\t\t\tLogger.error(this, \"Found block in primary and segment bloom filters but segment doesn't want it: \"+segment+\" on \"+this);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(segment, 1);\n\t\t\t\tif(found) return prio;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"public synchronized int killSegment(SplitFileFetcherSegment segment, ObjectContainer container, ClientContext context) {\n\t\tint segNo = segment.segNum;\n\t\tsegmentFilters[segNo].unsetAll();\n\t\tKey[] removeKeys = segment.listKeys(container);\n\t\tfor(int i=0;i<removeKeys.length;i++) {\n\t\t\tbyte[] salted = context.getChkFetchScheduler().saltKey(removeKeys[i]);\n\t\t\tif(filter.checkFilter(salted)) {\n\t\t\t\tfilter.removeKey(salted);\n\t\t\t} else\n\t\t\t\t// Huh??\n\t\t\t\tLogger.error(this, \"Removing key \"+removeKeys[i]+\" from \"+segment+\" : NOT IN BLOOM FILTER!\");\n\t\t}\n\t\tscheduleWriteFilters(context);\n\t\treturn keyCount -= removeKeys.length;\n\t}","id":24160,"modified_method":"public synchronized int killSegment(SplitFileFetcherSegment segment, ObjectContainer container, ClientContext context) {\n\t\tint segNo = segment.segNum;\n\t\tsegmentFilters[segNo].unsetAll();\n\t\tKey[] removeKeys = segment.listKeys(container);\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Removing segment from bloom filter: \"+segment+\" keys: \"+removeKeys.length);\n\t\tfor(int i=0;i<removeKeys.length;i++) {\n\t\t\tbyte[] salted = context.getChkFetchScheduler().saltKey(removeKeys[i]);\n\t\t\tif(filter.checkFilter(salted)) {\n\t\t\t\tfilter.removeKey(salted);\n\t\t\t} else\n\t\t\t\t// Huh??\n\t\t\t\tLogger.error(this, \"Removing key \"+removeKeys[i]+\" from \"+segment+\" : NOT IN BLOOM FILTER!\");\n\t\t}\n\t\tscheduleWriteFilters(context);\n\t\treturn keyCount -= removeKeys.length;\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Caller must create bloomFile, but it may be empty.\n\t * @param newFilter If true, the bloom file is empty, and the bloom filter\n\t * should be created from scratch.\n\t * @throws IOException \n\t */\n\tpublic SplitFileFetcherKeyListener(SplitFileFetcher parent, int keyCount, File bloomFile, File altBloomFile, int mainBloomSizeBytes, int mainBloomK, boolean dontCache, byte[] localSalt, int segments, int segmentFilterSizeBytes, int segmentBloomK, boolean persistent, boolean newFilter) throws IOException {\n\t\tfetcher = parent;\n\t\tthis.persistent = persistent;\n\t\tthis.keyCount = keyCount;\n\t\tthis.mainBloomFile = persistent ? new File(bloomFile.getPath()) : null;\n\t\tthis.altBloomFile = persistent ? new File(altBloomFile.getPath()) : null;\n\t\tthis.dontCache = dontCache;\n\t\tassert(localSalt.length == 32);\n\t\tif(persistent) {\n\t\t\tthis.localSalt = new byte[32];\n\t\t\tSystem.arraycopy(localSalt, 0, this.localSalt, 0, 32);\n\t\t} else {\n\t\t\tthis.localSalt = localSalt;\n\t\t}\n\t\tsegmentsFilterBuffer = new byte[segmentFilterSizeBytes * segments];\n\t\tByteBuffer baseBuffer = ByteBuffer.wrap(segmentsFilterBuffer);\n\t\tsegmentFilters = new BinaryBloomFilter[segments];\n\t\tint start = 0;\n\t\tint end = segmentFilterSizeBytes;\n\t\tfor(int i=0;i<segments;i++) {\n\t\t\tbaseBuffer.position(start);\n\t\t\tbaseBuffer.limit(end);\n\t\t\tByteBuffer slice = baseBuffer.slice();\n\t\t\tsegmentFilters[i] = new BinaryBloomFilter(slice, segmentFilterSizeBytes * 8, segmentBloomK);\n\t\t\tstart += segmentFilterSizeBytes;\n\t\t\tend += segmentFilterSizeBytes;\n\t\t}\n\t\t\n\t\tfilterBuffer = new byte[mainBloomSizeBytes];\n\t\tif(newFilter) {\n\t\t\tfilter = new CountingBloomFilter(mainBloomSizeBytes * 8 / 2, mainBloomK, filterBuffer);\n\t\t} else {\n\t\t\t// Read from file.\n\t\t\tFileInputStream fis = new FileInputStream(bloomFile);\n\t\t\tDataInputStream dis = new DataInputStream(fis);\n\t\t\tdis.readFully(filterBuffer);\n\t\t\tdis.close();\n\t\t\tfilter = new CountingBloomFilter(mainBloomSizeBytes * 8 / 2, mainBloomK, filterBuffer);\n\t\t\tfis = new FileInputStream(altBloomFile);\n\t\t\tdis = new DataInputStream(fis);\n\t\t\tdis.readFully(segmentsFilterBuffer);\n\t\t\tdis.close();\n\t\t}\n\t}","id":24161,"modified_method":"/**\n\t * Caller must create bloomFile, but it may be empty.\n\t * @param newFilter If true, the bloom file is empty, and the bloom filter\n\t * should be created from scratch.\n\t * @throws IOException \n\t */\n\tpublic SplitFileFetcherKeyListener(SplitFileFetcher parent, int keyCount, File bloomFile, File altBloomFile, int mainBloomSizeBytes, int mainBloomK, boolean dontCache, byte[] localSalt, int segments, int segmentFilterSizeBytes, int segmentBloomK, boolean persistent, boolean newFilter) throws IOException {\n\t\tSystem.err.println(\"Persistent = \"+persistent);\n\t\tfetcher = parent;\n\t\tthis.persistent = persistent;\n\t\tthis.keyCount = keyCount;\n\t\tthis.mainBloomFile = bloomFile;\n\t\tthis.altBloomFile = altBloomFile;\n\t\tthis.dontCache = dontCache;\n\t\tassert(localSalt.length == 32);\n\t\tif(persistent) {\n\t\t\tthis.localSalt = new byte[32];\n\t\t\tSystem.arraycopy(localSalt, 0, this.localSalt, 0, 32);\n\t\t} else {\n\t\t\tthis.localSalt = localSalt;\n\t\t}\n\t\tsegmentsFilterBuffer = new byte[segmentFilterSizeBytes * segments];\n\t\tByteBuffer baseBuffer = ByteBuffer.wrap(segmentsFilterBuffer);\n\t\tsegmentFilters = new BinaryBloomFilter[segments];\n\t\tint start = 0;\n\t\tint end = segmentFilterSizeBytes;\n\t\tfor(int i=0;i<segments;i++) {\n\t\t\tbaseBuffer.position(start);\n\t\t\tbaseBuffer.limit(end);\n\t\t\tByteBuffer slice = baseBuffer.slice();\n\t\t\tsegmentFilters[i] = new BinaryBloomFilter(slice, segmentFilterSizeBytes * 8, segmentBloomK);\n\t\t\tstart += segmentFilterSizeBytes;\n\t\t\tend += segmentFilterSizeBytes;\n\t\t}\n\t\t\n\t\tfilterBuffer = new byte[mainBloomSizeBytes];\n\t\tif(newFilter) {\n\t\t\tfilter = new CountingBloomFilter(mainBloomSizeBytes * 8 / 2, mainBloomK, filterBuffer);\n\t\t} else {\n\t\t\t// Read from file.\n\t\t\tFileInputStream fis = new FileInputStream(bloomFile);\n\t\t\tDataInputStream dis = new DataInputStream(fis);\n\t\t\tdis.readFully(filterBuffer);\n\t\t\tdis.close();\n\t\t\tfilter = new CountingBloomFilter(mainBloomSizeBytes * 8 / 2, mainBloomK, filterBuffer);\n\t\t\tfis = new FileInputStream(altBloomFile);\n\t\t\tdis = new DataInputStream(fis);\n\t\t\tdis.readFully(segmentsFilterBuffer);\n\t\t\tdis.close();\n\t\t}\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Created \"+this+\" for \"+fetcher);\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"public boolean handleBlock(Key key, byte[] saltedKey, KeyBlock block,\n\t\t\tObjectContainer container, ClientContext context) {\n\t\t// Caller has already called probablyWantKey(), so don't do it again.\n\t\tboolean found = false;\n\t\tbyte[] salted = localSaltKey(key);\n\t\tfor(int i=0;i<segmentFilters.length;i++) {\n\t\t\tif(segmentFilters[i].checkFilter(salted)) {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(fetcher, 1);\n\t\t\t\tSplitFileFetcherSegment segment = fetcher.getSegment(i);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(segment, 1);\n\t\t\t\tif(segment.onGotKey(key, block, container, context)) {\n\t\t\t\t\tkeyCount--;\n\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\tfilter.removeKey(saltedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// Update the persistent keyCount.\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.activate(fetcher, 1);\n\t\t\t\t\tfetcher.setKeyCount(keyCount, container);\n\t\t\t\t\tif(persistent)\n\t\t\t\t\t\tcontainer.deactivate(fetcher, 1);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(segment, 1);\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}","id":24162,"modified_method":"public boolean handleBlock(Key key, byte[] saltedKey, KeyBlock block,\n\t\t\tObjectContainer container, ClientContext context) {\n\t\t// Caller has already called probablyWantKey(), so don't do it again.\n\t\tboolean found = false;\n\t\tbyte[] salted = localSaltKey(key);\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"handleBlock(\"+key+\") on \"+this);\n\t\tfor(int i=0;i<segmentFilters.length;i++) {\n\t\t\tboolean match;\n\t\t\tsynchronized(this) {\n\t\t\t\tmatch = segmentFilters[i].checkFilter(salted);\n\t\t\t}\n\t\t\tif(match) {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(fetcher, 1);\n\t\t\t\tSplitFileFetcherSegment segment = fetcher.getSegment(i);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(segment, 1);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Key may be in segment \"+segment);\n\t\t\t\tif(segment.onGotKey(key, block, container, context)) {\n\t\t\t\t\tkeyCount--;\n\t\t\t\t\tsynchronized(this) {\n\t\t\t\t\t\tfilter.removeKey(saltedKey);\n\t\t\t\t\t}\n\t\t\t\t\t// Update the persistent keyCount.\n\t\t\t\t\tfetcher.setKeyCount(keyCount, container);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(segment, 1);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(fetcher, 1);\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * SplitFileFetcher adds keys in whatever blocks are convenient.\n\t * @param keys\n\t */\n\tvoid addKey(Key key, int segNo, ClientContext context) {\n\t\tbyte[] saltedKey = context.getChkFetchScheduler().saltKey(key);\n\t\tfilter.addKey(saltedKey);\n\t\tsegmentFilters[segNo].addKey(localSaltKey(key));\n\t}","id":24163,"modified_method":"/**\n\t * SplitFileFetcher adds keys in whatever blocks are convenient.\n\t * @param keys\n\t */\n\tvoid addKey(Key key, int segNo, ClientContext context) {\n\t\tbyte[] saltedKey = context.getChkFetchScheduler().saltKey(key);\n\t\tfilter.addKey(saltedKey);\n\t\tsegmentFilters[segNo].addKey(localSaltKey(key));\n\t\tif(!segmentFilters[segNo].checkFilter(localSaltKey(key)))\n\t\t\tLogger.error(this, \"Key added but not in filter: \"+key+\" on \"+this);\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"public SendableGet[] getRequestsForKey(Key key, byte[] saltedKey, \n\t\t\tObjectContainer container, ClientContext context) {\n\t\tArrayList<SendableGet> ret = new ArrayList<SendableGet>();\n\t\t// Caller has already called probablyWantKey(), so don't do it again.\n\t\tbyte[] salted = localSaltKey(key);\n\t\tfor(int i=0;i<segmentFilters.length;i++) {\n\t\t\tif(segmentFilters[i].checkFilter(salted)) {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(fetcher, 1);\n\t\t\t\tSplitFileFetcherSegment segment = fetcher.getSegment(i);\n\t\t\t\tint blockNum = segment.getBlockNumber(key, container);\n\t\t\t\tif(blockNum >= 0) {\n\t\t\t\t\tret.add(segment.getSubSegmentFor(blockNum, container));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret.toArray(new SendableGet[ret.size()]);\n\t}","id":24164,"modified_method":"public SendableGet[] getRequestsForKey(Key key, byte[] saltedKey, \n\t\t\tObjectContainer container, ClientContext context) {\n\t\tArrayList<SendableGet> ret = new ArrayList<SendableGet>();\n\t\t// Caller has already called probablyWantKey(), so don't do it again.\n\t\tbyte[] salted = localSaltKey(key);\n\t\tfor(int i=0;i<segmentFilters.length;i++) {\n\t\t\tif(segmentFilters[i].checkFilter(salted)) {\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(fetcher, 1);\n\t\t\t\tSplitFileFetcherSegment segment = fetcher.getSegment(i);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(fetcher, 1);\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(segment, 1);\n\t\t\t\tint blockNum = segment.getBlockNumber(key, container);\n\t\t\t\tif(blockNum >= 0) {\n\t\t\t\t\tret.add(segment.getSubSegmentFor(blockNum, container));\n\t\t\t\t}\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.deactivate(segment, 1);\n\t\t\t}\n\t\t}\n\t\treturn ret.toArray(new SendableGet[ret.size()]);\n\t}","commit_id":"53854519aa371f50fdc9785f52f54fc6d333cb80","url":"https://github.com/freenet/fred"},{"original_method":"public void schedule(ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tcontainer.activate(parentFetcher.parent, 1);\n\t\t}\n\t\ttry {\n\t\t\tSplitFileFetcherSubSegment seg = getSubSegment(0);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(seg, 1);\n\t\t\tfor(int i=0;i<dataRetries.length+checkRetries.length;i++)\n\t\t\t\tseg.add(i, true, container, context);\n\t\t\t\n\t\t\tseg.schedule(container, context);\n\t\t\tsynchronized(this) {\n\t\t\t\tscheduled = true;\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.set(this);\n\t\t\tparentFetcher.parent.notifyClients(container, context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"scheduling \"+seg+\" : \"+seg.blockNums);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t+\" scheduling \"+this, t);\n\t\t\tfail(new FetchException(FetchException.INTERNAL_ERROR, t), container, context);\n\t\t}\n\t}","id":24165,"modified_method":"public void schedule(ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(parentFetcher, 1);\n\t\t\tcontainer.activate(parentFetcher.parent, 1);\n\t\t}\n\t\ttry {\n\t\t\tSplitFileFetcherSubSegment seg = getSubSegment(0);\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(seg, 1);\n\t\t\tfor(int i=0;i<dataRetries.length+checkRetries.length;i++)\n\t\t\t\tseg.add(i, true, container, context, false);\n\t\t\t\n\t\t\tseg.schedule(container, context);\n\t\t\tsynchronized(this) {\n\t\t\t\tscheduled = true;\n\t\t\t}\n\t\t\tif(persistent)\n\t\t\t\tcontainer.set(this);\n\t\t\tparentFetcher.parent.notifyClients(container, context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"scheduling \"+seg+\" : \"+seg.blockNums);\n\t\t} catch (Throwable t) {\n\t\t\tLogger.error(this, \"Caught \"+t+\" scheduling \"+this, t);\n\t\t\tfail(new FetchException(FetchException.INTERNAL_ERROR, t), container, context);\n\t\t}\n\t}","commit_id":"1701f1453897c999226c3a53c6379ca7b53c9849","url":"https://github.com/freenet/fred"},{"original_method":"/** A request has failed non-fatally, so the block may be retried \n\t * @param container */\n\tpublic void onNonFatalFailure(FetchException e, int blockNo, SplitFileFetcherSubSegment seg, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tRequestScheduler sched = context.getFetchScheduler(false);\n\t\tint tries;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tboolean failed = false;\n\t\tboolean cooldown = false;\n\t\tClientCHK key;\n\t\tSplitFileFetcherSubSegment sub = null;\n\t\tsynchronized(this) {\n\t\t\tif(isFinished(container)) return;\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tkey = dataKeys[blockNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++dataRetries[blockNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(dataCooldownTimes[blockNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" data block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdataCooldownTimes[blockNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint checkNo = blockNo - dataKeys.length;\n\t\t\t\tkey = checkKeys[checkNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++checkRetries[checkNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(checkCooldownTimes[checkNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" check block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcheckCooldownTimes[checkNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tif(failed) {\n\t\t\tonFatalFailure(e, blockNo, seg, container, context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries);\n\t\t\treturn;\n\t\t}\n\t\tif(cooldown) {\n\t\t\t// Register to the next sub-segment before removing from the old one.\n\t\t\tsub.getScheduler(context).addPendingKey(key, sub);\n\t\t\tseg.unregisterKey(key.getNodeKey(), context, container);\n\t\t} else {\n\t\t\t// If we are here we are going to retry\n\t\t\t// Unregister from the old sub-segment before registering on the new.\n\t\t\tseg.unregisterKey(key.getNodeKey(), context, container);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\tsub.add(blockNo, false, container, context);\n\t\t}\n\t}","id":24166,"modified_method":"/** A request has failed non-fatally, so the block may be retried \n\t * @param container */\n\tpublic void onNonFatalFailure(FetchException e, int blockNo, SplitFileFetcherSubSegment seg, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tRequestScheduler sched = context.getFetchScheduler(false);\n\t\tint tries;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tboolean failed = false;\n\t\tboolean cooldown = false;\n\t\tClientCHK key;\n\t\tSplitFileFetcherSubSegment sub = null;\n\t\tsynchronized(this) {\n\t\t\tif(isFinished(container)) return;\n\t\t\tif(blockNo < dataKeys.length) {\n\t\t\t\tkey = dataKeys[blockNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++dataRetries[blockNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(dataCooldownTimes[blockNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" data block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tdataCooldownTimes[blockNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint checkNo = blockNo - dataKeys.length;\n\t\t\t\tkey = checkKeys[checkNo];\n\t\t\t\tif(persistent)\n\t\t\t\t\tcontainer.activate(key, 5);\n\t\t\t\ttries = ++checkRetries[checkNo];\n\t\t\t\tif(tries > maxTries && maxTries >= 0) failed = true;\n\t\t\t\telse {\n\t\t\t\t\tsub = getSubSegment(tries);\n\t\t\t\t\tif(tries % ClientRequestScheduler.COOLDOWN_RETRIES == 0) {\n\t\t\t\t\t\tlong now = System.currentTimeMillis();\n\t\t\t\t\t\tif(checkCooldownTimes[checkNo] > now)\n\t\t\t\t\t\t\tLogger.error(this, \"Already on the cooldown queue! for \"+this+\" check block no \"+blockNo, new Exception(\"error\"));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcheckCooldownTimes[checkNo] = sched.queueCooldown(key, sub);\n\t\t\t\t\t\tcooldown = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(this);\n\t\tif(failed) {\n\t\t\tonFatalFailure(e, blockNo, seg, container, context);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Not retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries);\n\t\t\treturn;\n\t\t}\n\t\tif(cooldown) {\n\t\t\t// Register to the next sub-segment before removing from the old one.\n\t\t\tsub.getScheduler(context).addPendingKey(key, sub);\n\t\t\tseg.unregisterKey(key.getNodeKey(), context, container);\n\t\t} else {\n\t\t\t// If we are here we are going to retry\n\t\t\t// Unregister from the old sub-segment before registering on the new.\n\t\t\tseg.unregisterKey(key.getNodeKey(), context, container);\n\t\t\tif(logMINOR)\n\t\t\t\tLogger.minor(this, \"Retrying block \"+blockNo+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\tsub.add(blockNo, false, container, context, false);\n\t\t}\n\t}","commit_id":"1701f1453897c999226c3a53c6379ca7b53c9849","url":"https://github.com/freenet/fred"},{"original_method":"public void requeueAfterCooldown(Key key, long time, ObjectContainer container, ClientContext context) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tVector v = null;\n\t\tboolean notFound = true;\n\t\tsynchronized(this) {\n\t\tif(isFinishing(container)) return;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tfor(int i=0;i<dataKeys.length;i++) {\n\t\t\tif(dataKeys[i] == null) continue;\n\t\t\tClientKey k = dataKeys[i];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(k, 5);\n\t\t\tif(k.getNodeKey().equals(key)) {\n\t\t\t\tif(dataCooldownTimes[i] > time) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not retrying after cooldown for data block \"+i+\"as deadline has not passed yet on \"+this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint tries = dataRetries[i];\n\t\t\t\tSplitFileFetcherSubSegment sub = getSubSegment(tries);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Retrying after cooldown on \"+this+\": data block \"+i+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\t\tif(v == null) v = new Vector();\n\t\t\t\tsub.add(i, true, container, context);\n\t\t\t\tif(!v.contains(sub)) v.add(sub);\n\t\t\t\tnotFound = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<checkKeys.length;i++) {\n\t\t\tif(checkKeys[i] == null) continue;\n\t\t\tClientKey k = checkKeys[i];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(k, 5);\n\t\t\tif(k.getNodeKey().equals(key)) {\n\t\t\t\tif(checkCooldownTimes[i] > time) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not retrying after cooldown for data block \"+i+\" as deadline has not passed yet on \"+this);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint tries = checkRetries[i];\n\t\t\t\tSplitFileFetcherSubSegment sub = getSubSegment(tries);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Retrying after cooldown on \"+this+\": check block \"+i+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\t\tif(v == null) v = new Vector();\n\t\t\t\tsub.add(i+dataKeys.length, true, container, context);\n\t\t\t\tif(!v.contains(sub)) v.add(sub);\n\t\t\t\tnotFound = false;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(notFound) {\n\t\t\tLogger.error(this, \"requeueAfterCooldown: Key not found!: \"+key+\" on \"+this);\n\t\t}\n\t\tif(v != null) {\n\t\t\tfor(int i=0;i<v.size();i++) {\n\t\t\t\t((SplitFileFetcherSubSegment) v.get(i)).schedule(container, context);\n\t\t\t}\n\t\t}\n\t}","id":24167,"modified_method":"/**\n\t * @return True if the key was wanted and the scheduled segment was the one that called, false otherwise. \n\t */\n\tpublic boolean requeueAfterCooldown(Key key, long time, ObjectContainer container, ClientContext context, SplitFileFetcherSubSegment segment) {\n\t\tif(persistent)\n\t\t\tcontainer.activate(this, 1);\n\t\tVector v = null;\n\t\tboolean notFound = true;\n\t\tsynchronized(this) {\n\t\tif(isFinishing(container)) return false;\n\t\tint maxTries = blockFetchContext.maxNonSplitfileRetries;\n\t\tfor(int i=0;i<dataKeys.length;i++) {\n\t\t\tif(dataKeys[i] == null) continue;\n\t\t\tClientKey k = dataKeys[i];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(k, 5);\n\t\t\tif(k.getNodeKey().equals(key)) {\n\t\t\t\tif(dataCooldownTimes[i] > time) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not retrying after cooldown for data block \"+i+\"as deadline has not passed yet on \"+this);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tint tries = dataRetries[i];\n\t\t\t\tSplitFileFetcherSubSegment sub = getSubSegment(tries);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Retrying after cooldown on \"+this+\": data block \"+i+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\t\tif(v == null) v = new Vector();\n\t\t\t\tsub.add(i, true, container, context, true);\n\t\t\t\tif(!v.contains(sub)) v.add(sub);\n\t\t\t\tnotFound = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<checkKeys.length;i++) {\n\t\t\tif(checkKeys[i] == null) continue;\n\t\t\tClientKey k = checkKeys[i];\n\t\t\tif(persistent)\n\t\t\t\tcontainer.activate(k, 5);\n\t\t\tif(k.getNodeKey().equals(key)) {\n\t\t\t\tif(checkCooldownTimes[i] > time) {\n\t\t\t\t\tif(logMINOR)\n\t\t\t\t\t\tLogger.minor(this, \"Not retrying after cooldown for data block \"+i+\" as deadline has not passed yet on \"+this);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tint tries = checkRetries[i];\n\t\t\t\tSplitFileFetcherSubSegment sub = getSubSegment(tries);\n\t\t\t\tif(logMINOR)\n\t\t\t\t\tLogger.minor(this, \"Retrying after cooldown on \"+this+\": check block \"+i+\" on \"+this+\" : tries=\"+tries+\"/\"+maxTries+\" : \"+sub);\n\t\t\t\tif(v == null) v = new Vector();\n\t\t\t\tsub.add(i+dataKeys.length, true, container, context, true);\n\t\t\t\tif(!v.contains(sub)) v.add(sub);\n\t\t\t\tnotFound = false;\n\t\t\t}\n\t\t}\n\t\t}\n\t\tif(notFound) {\n\t\t\tLogger.error(this, \"requeueAfterCooldown: Key not found!: \"+key+\" on \"+this);\n\t\t}\n\t\tboolean foundCaller = false;\n\t\tif(v != null) {\n\t\t\tfor(int i=0;i<v.size();i++) {\n\t\t\t\tif(v.get(i) == segment) foundCaller = true;\n\t\t\t\t((SplitFileFetcherSubSegment) v.get(i)).schedule(container, context);\n\t\t\t}\n\t\t}\n\t\treturn foundCaller;\n\t}","commit_id":"1701f1453897c999226c3a53c6379ca7b53c9849","url":"https://github.com/freenet/fred"},{"original_method":"public void add(int blockNo, boolean dontSchedule, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t\tcontainer.activate(blockNums, 1);\n\t\t}\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Adding block \"+blockNo+\" to \"+this+\" dontSchedule=\"+dontSchedule);\n\t\tif(blockNo < 0) throw new IllegalArgumentException();\n\t\tInteger i = new Integer(blockNo);\n\t\t\n\t\tboolean schedule = true;\n\t\tsynchronized(segment) {\n\t\t\tif(cancelled)\n\t\t\t\tthrow new IllegalStateException(\"Adding block \"+blockNo+\" to already cancelled \"+this);\n\t\t\tblockNums.add(i);\n\t\t\tif(dontSchedule) schedule = false;\n\t\t\t/**\n\t\t\t * Race condition:\n\t\t\t * \n\t\t\t * Starter thread sees there is only one block on us, so removes us.\n\t\t\t * Another thread adds a block. We don't schedule as we now have two blocks.\n\t\t\t * Starter thread removes us.\n\t\t\t * Other blocks may be added later, but we are never rescheduled.\n\t\t\t * \n\t\t\t * Fixing this by only removing the SendableRequest after we've removed the \n\t\t\t * block is nontrivial with the current code.\n\t\t\t * So what we do here is simply check whether we are registered, instead of \n\t\t\t * checking whether blockNums.size() > 1 as we used to.\n\t\t\t */\n\t\t\tif(schedule && getParentGrabArray() != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Already registered, not scheduling: \"+blockNums.size()+\" : \"+blockNums);\n\t\t\t\tschedule = false;\n\t\t\t}\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(blockNums);\n\t\tif(schedule) schedule(container, context);\n\t\telse if(!dontSchedule)\n\t\t\t// Already scheduled, however this key may not be registered.\n\t\t\tgetScheduler(context).addPendingKey(segment.getBlockKey(blockNo, container), this);\n\t}","id":24168,"modified_method":"public void add(int blockNo, boolean dontSchedule, ObjectContainer container, ClientContext context, boolean dontComplainOnDupes) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t\tcontainer.activate(blockNums, 1);\n\t\t}\n\t\tboolean logMINOR = Logger.shouldLog(Logger.MINOR, this);\n\t\tif(logMINOR) Logger.minor(this, \"Adding block \"+blockNo+\" to \"+this+\" dontSchedule=\"+dontSchedule);\n\t\tif(blockNo < 0) throw new IllegalArgumentException();\n\t\tInteger i = new Integer(blockNo);\n\t\t\n\t\tboolean schedule = true;\n\t\tsynchronized(segment) {\n\t\t\tif(cancelled)\n\t\t\t\tthrow new IllegalStateException(\"Adding block \"+blockNo+\" to already cancelled \"+this);\n\t\t\tif(blockNums.contains(i)) {\n\t\t\t\tif(!dontComplainOnDupes)\n\t\t\t\t\tLogger.error(this, \"Block numbers already contain block \"+blockNo);\n\t\t\t} else {\n\t\t\t\tblockNums.add(i);\n\t\t\t}\n\t\t\tif(dontSchedule) schedule = false;\n\t\t\t/**\n\t\t\t * Race condition:\n\t\t\t * \n\t\t\t * Starter thread sees there is only one block on us, so removes us.\n\t\t\t * Another thread adds a block. We don't schedule as we now have two blocks.\n\t\t\t * Starter thread removes us.\n\t\t\t * Other blocks may be added later, but we are never rescheduled.\n\t\t\t * \n\t\t\t * Fixing this by only removing the SendableRequest after we've removed the \n\t\t\t * block is nontrivial with the current code.\n\t\t\t * So what we do here is simply check whether we are registered, instead of \n\t\t\t * checking whether blockNums.size() > 1 as we used to.\n\t\t\t */\n\t\t\tif(schedule && getParentGrabArray() != null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Already registered, not scheduling: \"+blockNums.size()+\" : \"+blockNums);\n\t\t\t\tschedule = false;\n\t\t\t}\n\t\t}\n\t\tif(persistent)\n\t\t\tcontainer.set(blockNums);\n\t\tif(schedule) schedule(container, context);\n\t\telse if(!dontSchedule)\n\t\t\t// Already scheduled, however this key may not be registered.\n\t\t\tgetScheduler(context).addPendingKey(segment.getBlockKey(blockNo, container), this);\n\t}","commit_id":"1701f1453897c999226c3a53c6379ca7b53c9849","url":"https://github.com/freenet/fred"},{"original_method":"public void requeueAfterCooldown(Key key, long time, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Requeueing after cooldown \"+key+\" for \"+this);\n\t\tsegment.requeueAfterCooldown(key, time, container, context);\n\t}","id":24169,"modified_method":"public void requeueAfterCooldown(Key key, long time, ObjectContainer container, ClientContext context) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(segment, 1);\n\t\t}\n\t\tif(Logger.shouldLog(Logger.MINOR, this))\n\t\t\tLogger.minor(this, \"Requeueing after cooldown \"+key+\" for \"+this);\n\t\tif(!segment.requeueAfterCooldown(key, time, container, context, this)) {\n\t\t\tLogger.error(this, \"Removing key \"+key+\" for \"+this+\" in requeueAfterCooldown as is now registered to a different subsegment\");\n\t\t\tunregisterKey(key, context, container);\n\t\t}\n\t}","commit_id":"1701f1453897c999226c3a53c6379ca7b53c9849","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Just those keys which are eligible to be started now.\n\t */\n\tpublic Object[] sendableKeys(ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(blockNums, 1);\n\t\t}\n\t\treturn blockNums.toArray();\n\t}","id":24170,"modified_method":"/**\n\t * Just those keys which are eligible to be started now.\n\t */\n\tpublic Object[] sendableKeys(ObjectContainer container) {\n\t\tif(persistent) {\n\t\t\tcontainer.activate(this, 1);\n\t\t\tcontainer.activate(blockNums, 1);\n\t\t}\n\t\tcleanBlockNums();\n\t\treturn blockNums.toArray();\n\t}","commit_id":"1701f1453897c999226c3a53c6379ca7b53c9849","url":"https://github.com/freenet/fred"},{"original_method":"public List<InstanceReportLine> getReportLines(Period period,\n\t\t\tReportingCriterion criterion,\tUnits displayUnits)\n\t{\n\t\treturn getReportLines(period, null, criterion, displayUnits);\n\t}","id":24171,"modified_method":"public List<InstanceReportLine> getReportLines(Period period,\n\t\t\tReportingCriterion criterion, Units displayUnits,\n\t\t\tString accountId)\n\t{\n\t\treturn getReportLines(period, null, criterion, displayUnits, accountId);\n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public List<InstanceReportLine> getReportLines(Period period, ReportingCriterion groupByCrit,\n\t\t\tReportingCriterion crit, Units displayUnits)\n\t{\n\t\tif (period==null || crit==null || displayUnits==null) {\n\t\t\tthrow new IllegalArgumentException(\"Args can't be null\");\n\t\t}\n\t\t\n\t\tMap<InstanceReportLineKey, InstanceReportLine> reportLineMap =\n\t\t\tnew HashMap<InstanceReportLineKey, InstanceReportLine>();\n\t\t\n\t\tInstanceUsageLog usageLog = InstanceUsageLog.getInstanceUsageLog();\n\t\tMap<InstanceSummaryKey, InstanceUsageSummary> usageMap = \n\t\t\tusageLog.getUsageSummaryMap(period);\n\t\tfor (InstanceSummaryKey key: usageMap.keySet()) {\n\t\t\tString critVal = getAttributeValue(crit, key);\n\t\t\tString groupVal = (groupByCrit==null) ? null : getAttributeValue(groupByCrit, key);\n\t\t\tInstanceReportLineKey lineKey = new InstanceReportLineKey(critVal, groupVal);\n\t\t\tif (!reportLineMap.containsKey(lineKey)) {\n\t\t\t\treportLineMap.put(lineKey, new InstanceReportLine(lineKey,\n\t\t\t\t\t\tnew InstanceUsageSummary(), displayUnits));\n\t\t\t}\n\t\t\tInstanceReportLine reportLine = reportLineMap.get(lineKey);\n\t\t\tInstanceUsageSummary summary = usageMap.get(key);\n\t\t\treportLine.addUsage(summary);\n\t\t}\n\n\t\tfinal List<InstanceReportLine> results = new ArrayList<InstanceReportLine>();\n\t\tfor (InstanceReportLineKey lineKey: reportLineMap.keySet()) {\n\t\t\tresults.add(reportLineMap.get(lineKey));\n\t\t}\n\t\t\n\t\tCollections.sort(results);\n\t\treturn results;\n\t}","id":24172,"modified_method":"public List<InstanceReportLine> getReportLines(Period period, ReportingCriterion groupByCrit,\n\t\t\tReportingCriterion crit, Units displayUnits, String accountId)\n\t{\n\t\tif (period==null || crit==null || displayUnits==null) {\n\t\t\tthrow new IllegalArgumentException(\"Args can't be null\");\n\t\t}\n\t\t\n\t\tMap<InstanceReportLineKey, InstanceReportLine> reportLineMap =\n\t\t\tnew HashMap<InstanceReportLineKey, InstanceReportLine>();\n\t\t\n\t\tInstanceUsageLog usageLog = InstanceUsageLog.getInstanceUsageLog();\n\t\tMap<InstanceSummaryKey, InstanceUsageSummary> usageMap = \n\t\t\tusageLog.getUsageSummaryMap(period, accountId);\n\t\tfor (InstanceSummaryKey key: usageMap.keySet()) {\n\t\t\tString critVal = getAttributeValue(crit, key);\n\t\t\tString groupVal = (groupByCrit==null) ? null : getAttributeValue(groupByCrit, key);\n\t\t\tInstanceReportLineKey lineKey = new InstanceReportLineKey(critVal, groupVal);\n\t\t\tif (!reportLineMap.containsKey(lineKey)) {\n\t\t\t\treportLineMap.put(lineKey, new InstanceReportLine(lineKey,\n\t\t\t\t\t\tnew InstanceUsageSummary(), displayUnits));\n\t\t\t}\n\t\t\tInstanceReportLine reportLine = reportLineMap.get(lineKey);\n\t\t\tInstanceUsageSummary summary = usageMap.get(key);\n\t\t\treportLine.addUsage(summary);\n\t\t}\n\n\t\tfinal List<InstanceReportLine> results = new ArrayList<InstanceReportLine>();\n\t\tfor (InstanceReportLineKey lineKey: reportLineMap.keySet()) {\n\t\t\tresults.add(reportLineMap.get(lineKey));\n\t\t}\n\t\t\n\t\tCollections.sort(results);\n\t\treturn results;\n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n\t * <p>Gather a Map of all Instance resource usage for a period.\n\t */\n    public Map<InstanceSummaryKey, InstanceUsageSummary> getUsageSummaryMap(Period period)\n    {\n    \tlog.info(\"GetUsageSummaryMap period:\" + period);\n\n\t\tfinal Map<InstanceSummaryKey, InstanceUsageSummary> usageMap =\n    \t\tnew HashMap<InstanceSummaryKey, InstanceUsageSummary>();\n\n\t\tEntityWrapper<InstanceUsageSnapshot> entityWrapper =\n\t\t\tEntityWrapper.get(InstanceUsageSnapshot.class);\n\t\ttry {\n\n\t\t\t/* Start query from last snapshot before report beginning, and\n\t\t\t * iterate through the data until after the end. We'll truncate and\n\t\t\t * extrapolate.\n\t\t\t */\n\t\t\tlong latestSnapshotBeforeMs =\n\t\t\t\tfindLatestAllSnapshotBefore(period.getBeginningMs());\n\t\t\tlong afterEnd = period.getEndingMs() \n\t\t\t\t\t+ ((period.getBeginningMs()-latestSnapshotBeforeMs)*2);\n\n\t\t\t\n\t\t\t@SuppressWarnings(\"rawtypes\")\n\t\t\tList list = entityWrapper.createQuery(\n\t\t\t\t\t\"from InstanceAttributes as ia, InstanceUsageSnapshot as ius\"\n\t\t\t\t\t+ \" where ia.uuid = ius.uuid\"\n\t\t\t\t\t+ \" and ius.timestampMs > ?\"\n\t\t\t\t\t+ \" and ius.timestampMs < ?\")\n\t\t\t\t\t.setLong(0, latestSnapshotBeforeMs)\n\t\t\t\t\t.setLong(1, afterEnd)\n\t\t\t\t\t.list();\n\t\t\t\n\n\t\t\t\n\t\t\t/* Accumulate data over timeline, by instance, keyed by instance uuid.\n\t\t\t * Accumulated data consists of the instance running time, network\n\t\t\t * io megs, and disk io megs for each instance.\n\t\t\t */\n\t\t\tMap<String,InstanceDataAccumulator> dataAccumulatorMap =\n\t\t\t\tnew HashMap<String,InstanceDataAccumulator>();\n\t\t\t\n\t\t\tfor (Object obj: list) {\n\n\t\t\t\tObject[] row = (Object[]) obj;\n\t\t\t\tInstanceAttributes insAttrs = (InstanceAttributes) row[0];\n\t\t\t\tInstanceUsageSnapshot snapshot = (InstanceUsageSnapshot) row[1];\n\n\t\t\t\tlog.debug(\"Found row attrs:\" + insAttrs + \" snapshot:\" + snapshot);\n\t\t\t\t\n\t\t\t\tString uuid = insAttrs.getUuid();\n\t\t\t\tif ( !dataAccumulatorMap.containsKey( uuid ) ) {\n\t\t\t\t\tInstanceDataAccumulator accumulator =\n\t\t\t\t\t\tnew InstanceDataAccumulator( insAttrs, snapshot, period );\n\t\t\t\t\tdataAccumulatorMap.put( uuid, accumulator );\n\t\t\t\t} else {\n\t\t\t\t\tInstanceDataAccumulator accumulator =\n\t\t\t\t\t\tdataAccumulatorMap.get( uuid );\n\t\t\t\t\taccumulator.update( snapshot );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\t\t\t/* Summarize usage for each (zone,cluster,acct,user) key, by\n\t\t\t * summing all usage for all instances for each key. Populate\n\t\t\t * the usageMap, which is what we return.\n\t\t\t */\n\t\t\tfor (String uuid: dataAccumulatorMap.keySet()) {\n\t\t\t\t//log.info(\"Instance uuid:\" + uuid);\n\t\t\t\tInstanceDataAccumulator accumulator =\n\t\t\t\t\tdataAccumulatorMap.get(uuid);\n\t\t\t\tInstanceSummaryKey key =\n\t\t\t\t\tnew InstanceSummaryKey(accumulator.getInstanceAttributes());\n\t\t\t\tif (! usageMap.containsKey(key)) {\n\t\t\t\t\tusageMap.put(key, new InstanceUsageSummary());\n\t\t\t\t}\n\t\t\t\tInstanceUsageSummary ius = usageMap.get(key);\n\t\t\t\tius.addDiskIoMegs(accumulator.getDiskIoMegs());\n\t\t\t\tius.addNetworkIoMegs(accumulator.getNetIoMegs());\n\t\t\t\tius.sumFromPeriodType(accumulator.getDurationPeriod(),\n\t\t\t\t\t\taccumulator.getInstanceAttributes().getInstanceType());\n\t\t\t}\n\n\t\t\tentityWrapper.commit();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(ex);\n\t\t\tentityWrapper.rollback();\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\n\t\t\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"Printing usageMap\");\n\t\t\tfor (InstanceSummaryKey key: usageMap.keySet()) {\n\t\t\t\tlog.debug(\"key:\" + key + \" summary:\" + usageMap.get(key));\n\t\t\t}\n\t\t}\n\n        return usageMap;\n    }","id":24173,"modified_method":"/**\n\t * <p>Gather a Map of all Instance resource usage for a period.\n\t */\n    public Map<InstanceSummaryKey, InstanceUsageSummary> getUsageSummaryMap(\n    \t\tPeriod period, String accountId)\n    {\n    \tlog.info(\"GetUsageSummaryMap period:\" + period);\n\n\t\tfinal Map<InstanceSummaryKey, InstanceUsageSummary> usageMap =\n    \t\tnew HashMap<InstanceSummaryKey, InstanceUsageSummary>();\n\n\t\tEntityWrapper<InstanceUsageSnapshot> entityWrapper =\n\t\t\tEntityWrapper.get(InstanceUsageSnapshot.class);\n\t\ttry {\n\n\t\t\t/* Start query from last snapshot before report beginning, and\n\t\t\t * iterate through the data until after the end. We'll truncate and\n\t\t\t * extrapolate.\n\t\t\t */\n\t\t\tlong latestSnapshotBeforeMs =\n\t\t\t\tfindLatestAllSnapshotBefore(period.getBeginningMs());\n\t\t\tlong afterEnd = period.getEndingMs() \n\t\t\t\t\t+ ((period.getBeginningMs()-latestSnapshotBeforeMs)*2);\n\n\t\t\t\n\t\t\t@SuppressWarnings(\"rawtypes\")\n\t\t\tList list = null;\n\t\t\t\n\t\t\tif (accountId == null) {\n\t\t\t\tlist = entityWrapper.createQuery(\n\t\t\t\t\t\"from InstanceAttributes as ia, InstanceUsageSnapshot as ius\"\n\t\t\t\t\t+ \" where ia.uuid = ius.uuid\"\n\t\t\t\t\t+ \" and ius.timestampMs > ?\"\n\t\t\t\t\t+ \" and ius.timestampMs < ?\")\n\t\t\t\t\t.setLong(0, latestSnapshotBeforeMs)\n\t\t\t\t\t.setLong(1, afterEnd)\n\t\t\t\t\t.list();\n\t\t\t} else {\n\t\t\t\tlist = entityWrapper.createQuery(\n\t\t\t\t\t\t\"from InstanceAttributes as ia, InstanceUsageSnapshot as ius\"\n\t\t\t\t\t\t+ \" where ia.uuid = ius.uuid\"\n\t\t\t\t\t\t+ \" and ia.accountId = ?\"\n\t\t\t\t\t\t+ \" and ius.timestampMs > ?\"\n\t\t\t\t\t\t+ \" and ius.timestampMs < ?\")\n\t\t\t\t\t\t.setString(0, accountId)\n\t\t\t\t\t\t.setLong(1, latestSnapshotBeforeMs)\n\t\t\t\t\t\t.setLong(2, afterEnd)\n\t\t\t\t\t\t.list();\t\t\n\t\t\t}\n\t\t\t\n\n\t\t\t\n\t\t\t/* Accumulate data over timeline, by instance, keyed by instance uuid.\n\t\t\t * Accumulated data consists of the instance running time, network\n\t\t\t * io megs, and disk io megs for each instance.\n\t\t\t */\n\t\t\tMap<String,InstanceDataAccumulator> dataAccumulatorMap =\n\t\t\t\tnew HashMap<String,InstanceDataAccumulator>();\n\t\t\t\n\t\t\tfor (Object obj: list) {\n\n\t\t\t\tObject[] row = (Object[]) obj;\n\t\t\t\tInstanceAttributes insAttrs = (InstanceAttributes) row[0];\n\t\t\t\tInstanceUsageSnapshot snapshot = (InstanceUsageSnapshot) row[1];\n\n\t\t\t\tlog.debug(\"Found row attrs:\" + insAttrs + \" snapshot:\" + snapshot);\n\t\t\t\t\n\t\t\t\tString uuid = insAttrs.getUuid();\n\t\t\t\tif ( !dataAccumulatorMap.containsKey( uuid ) ) {\n\t\t\t\t\tInstanceDataAccumulator accumulator =\n\t\t\t\t\t\tnew InstanceDataAccumulator( insAttrs, snapshot, period );\n\t\t\t\t\tdataAccumulatorMap.put( uuid, accumulator );\n\t\t\t\t} else {\n\t\t\t\t\tInstanceDataAccumulator accumulator =\n\t\t\t\t\t\tdataAccumulatorMap.get( uuid );\n\t\t\t\t\taccumulator.update( snapshot );\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t\n\t\t\t/* Summarize usage for each (zone,cluster,acct,user) key, by\n\t\t\t * summing all usage for all instances for each key. Populate\n\t\t\t * the usageMap, which is what we return.\n\t\t\t */\n\t\t\tfor (String uuid: dataAccumulatorMap.keySet()) {\n\t\t\t\t//log.info(\"Instance uuid:\" + uuid);\n\t\t\t\tInstanceDataAccumulator accumulator =\n\t\t\t\t\tdataAccumulatorMap.get(uuid);\n\t\t\t\tInstanceSummaryKey key =\n\t\t\t\t\tnew InstanceSummaryKey(accumulator.getInstanceAttributes());\n\t\t\t\tif (! usageMap.containsKey(key)) {\n\t\t\t\t\tusageMap.put(key, new InstanceUsageSummary());\n\t\t\t\t}\n\t\t\t\tInstanceUsageSummary ius = usageMap.get(key);\n\t\t\t\tius.addDiskIoMegs(accumulator.getDiskIoMegs());\n\t\t\t\tius.addNetworkIoMegs(accumulator.getNetIoMegs());\n\t\t\t\tius.sumFromPeriodType(accumulator.getDurationPeriod(),\n\t\t\t\t\t\taccumulator.getInstanceAttributes().getInstanceType());\n\t\t\t}\n\n\t\t\tentityWrapper.commit();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(ex);\n\t\t\tentityWrapper.rollback();\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\n\t\t\n\t\tif (log.isDebugEnabled()) {\n\t\t\tlog.debug(\"Printing usageMap\");\n\t\t\tfor (InstanceSummaryKey key: usageMap.keySet()) {\n\t\t\t\tlog.debug(\"key:\" + key + \" summary:\" + usageMap.get(key));\n\t\t\t}\n\t\t}\n\n        return usageMap;\n    }","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n\t * <p>Generates a report and sends it to an OutputStream.\n\t * \n\t * @param groupByCriterion Can be null if none selected\n\t */\n\tpublic void generateReport(ReportType reportType, ReportFormat format,\n\t\t\tPeriod period, ReportingCriterion criterion,\n\t\t\tReportingCriterion groupByCriterion, Units displayUnits,\n\t\t\tOutputStream out)\n\t{\n\t\tif (reportType == null)\n\t\t\tthrow new IllegalArgumentException(\"ReportType can't be null\");\n\t\tif (criterion == null)\n\t\t\tthrow new IllegalArgumentException(\"Criterion can't be null\");\n\t\tif (displayUnits == null)\n\t\t\tdisplayUnits = Units.DEFAULT_DISPLAY_UNITS;\n\t\t\n\t\t\n\t\tfinal Map<String, String> params = new HashMap<String, String>();\n\t\tparams.put(\"criterion\", criterion.toString());\n\t\tparams.put(\"timeUnit\", displayUnits.getTimeUnit().toString());\n\t\tparams.put(\"sizeUnit\", displayUnits.getSizeUnit().toString());\n\t\tparams.put(\"sizeTimeTimeUnit\",\n\t\t\t\tdisplayUnits.getSizeTimeTimeUnit().toString());\n\t\tparams.put(\"sizeTimeSizeUnit\",\n\t\t\t\tdisplayUnits.getSizeTimeSizeUnit().toString());\n\t\tif (groupByCriterion != null) {\n\t\t\tparams.put(\"groupByCriterion\", groupByCriterion.toString());\t\t\t\n\t\t}\n\n\n\t\tfinal String jrxmlFilename = (groupByCriterion==null)\n\t\t\t\t\t\t\t\t? reportType.getJrxmlFilename()\n\t\t\t\t\t\t\t\t: reportType.getNestedJrxmlFilename();\n\t\tfinal File jrxmlFile = \tnew File(SubDirectory.REPORTS.toString()\n\t\t\t\t+ File.separator + jrxmlFilename);\n\n\t\t\t\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tReportLineGenerator generator = null;\n\t\tswitch (reportType) {\n\t\t\tcase INSTANCE:\n\t\t\t\tgenerator =\tInstanceReportLineGenerator.getInstance();\n\t\t\t\tbreak;\n\t\t\tcase STORAGE:\n\t\t\t\tgenerator =\tStorageReportLineGenerator.getInstance();\n\t\t\t\tbreak;\n\t\t\tcase S3:\n\t\t\t\tgenerator =\tS3ReportLineGenerator.getInstance();\n\t\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\t/* We maintain a small cache here of very recently-viewed reports. If\n\t\t * not found in cache then get report lines from {s3,storage,instance}\n\t\t * API\n\t\t */\n\t\tList<ReportLine> reportLines = null;\n\t\tReportKey key = new ReportKey(reportType, period, criterion,\n\t\t\t\tgroupByCriterion, displayUnits, System.currentTimeMillis());\n\t\tif (lineListMap.containsKey(key)) {\n\t\t\tlog.info(\"Gathered report data from cache:\" + key);\n\t\t\treportLines = lineListMap.get(key);\n\t\t} else {\n\t\t\twhile (lineListMap.size() >= DEFAULT_CACHE_SIZE) {\n\t\t\t\tReportKey oldestKey = null;\n\t\t\t\tfor (ReportKey oldKey: lineListMap.keySet()) {\n\t\t\t\t\tif (oldestKey==null || oldestKey.getTimestampMs() > oldKey.getTimestampMs()) {\n\t\t\t\t\t\toldestKey = oldKey;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (oldestKey != null) {\n\t\t\t\t\tlineListMap.remove(oldestKey);\n\t\t\t\t\tlog.info(\"Removed report data from cache:\" + oldestKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\treportLines = generator.getReportLines(period, groupByCriterion,\n\t\t\t\t\tcriterion, displayUnits);\n\t\t\tlog.info(\"Generated report data from db:\" + key);\n\t\t\tlineListMap.put(key, reportLines);\n\t\t\t\n\t\t}\n\t\tJRDataSource dataSource = new JRBeanCollectionDataSource(reportLines);\n\n\t\t\n\t\ttry {\n\t\t\tJasperReport report = JasperCompileManager.compileReport(jrxmlFile\n\t\t\t\t\t.getAbsolutePath());\n\t\t\tJasperPrint jasperPrint = JasperFillManager.fillReport(report,\n\t\t\t\t\tparams, dataSource);\n\n\t\t\tJRExporter exporter = format.getExporter();\n\t\t\texporter.setParameter(JRExporterParameter.OUTPUT_STREAM, out);\n\t\t\texporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);\n\t\t\texporter.exportReport();\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}","id":24174,"modified_method":"/**\n\t * <p>Generates a report and sends it to an OutputStream.\n\t * \n\t * @param groupByCriterion Can be null if none selected\n\t */\n\tpublic void generateReport(ReportType reportType, ReportFormat format,\n\t\t\tPeriod period, ReportingCriterion criterion,\n\t\t\tReportingCriterion groupByCriterion, Units displayUnits,\n\t\t\tOutputStream out, String accountId)\n\t{\n\t\tif (reportType == null)\n\t\t\tthrow new IllegalArgumentException(\"ReportType can't be null\");\n\t\tif (criterion == null)\n\t\t\tthrow new IllegalArgumentException(\"Criterion can't be null\");\n\t\tif (displayUnits == null)\n\t\t\tdisplayUnits = Units.DEFAULT_DISPLAY_UNITS;\n\t\t\n\t\t\n\t\tfinal Map<String, String> params = new HashMap<String, String>();\n\t\tparams.put(\"criterion\", criterion.toString());\n\t\tparams.put(\"timeUnit\", displayUnits.getTimeUnit().toString());\n\t\tparams.put(\"sizeUnit\", displayUnits.getSizeUnit().toString());\n\t\tparams.put(\"sizeTimeTimeUnit\",\n\t\t\t\tdisplayUnits.getSizeTimeTimeUnit().toString());\n\t\tparams.put(\"sizeTimeSizeUnit\",\n\t\t\t\tdisplayUnits.getSizeTimeSizeUnit().toString());\n\t\tif (groupByCriterion != null) {\n\t\t\tparams.put(\"groupByCriterion\", groupByCriterion.toString());\t\t\t\n\t\t}\n\n\n\t\tfinal String jrxmlFilename = (groupByCriterion==null)\n\t\t\t\t\t\t\t\t? reportType.getJrxmlFilename()\n\t\t\t\t\t\t\t\t: reportType.getNestedJrxmlFilename();\n\t\tfinal File jrxmlFile = \tnew File(SubDirectory.REPORTS.toString()\n\t\t\t\t+ File.separator + jrxmlFilename);\n\n\t\t\t\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tReportLineGenerator generator = null;\n\t\tswitch (reportType) {\n\t\t\tcase INSTANCE:\n\t\t\t\tgenerator =\tInstanceReportLineGenerator.getInstance();\n\t\t\t\tbreak;\n\t\t\tcase STORAGE:\n\t\t\t\tgenerator =\tStorageReportLineGenerator.getInstance();\n\t\t\t\tbreak;\n\t\t\tcase S3:\n\t\t\t\tgenerator =\tS3ReportLineGenerator.getInstance();\n\t\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\t/* We maintain a small cache here of very recently-viewed reports. If\n\t\t * not found in cache then get report lines from {s3,storage,instance}\n\t\t * API\n\t\t */\n\t\tList<ReportLine> reportLines = null;\n\t\tReportKey key = new ReportKey(reportType, period, criterion,\n\t\t\t\tgroupByCriterion, displayUnits, System.currentTimeMillis());\n\t\tif (lineListMap.containsKey(key)) {\n\t\t\tlog.info(\"Gathered report data from cache:\" + key);\n\t\t\treportLines = lineListMap.get(key);\n\t\t} else {\n\t\t\twhile (lineListMap.size() >= DEFAULT_CACHE_SIZE) {\n\t\t\t\tReportKey oldestKey = null;\n\t\t\t\tfor (ReportKey oldKey: lineListMap.keySet()) {\n\t\t\t\t\tif (oldestKey==null || oldestKey.getTimestampMs() > oldKey.getTimestampMs()) {\n\t\t\t\t\t\toldestKey = oldKey;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (oldestKey != null) {\n\t\t\t\t\tlineListMap.remove(oldestKey);\n\t\t\t\t\tlog.info(\"Removed report data from cache:\" + oldestKey);\n\t\t\t\t}\n\t\t\t}\n\t\t\treportLines = generator.getReportLines(period, groupByCriterion,\n\t\t\t\t\tcriterion, displayUnits, accountId);\n\t\t\tlog.info(\"Generated report data from db:\" + key);\n\t\t\tlineListMap.put(key, reportLines);\n\t\t\t\n\t\t}\n\t\tJRDataSource dataSource = new JRBeanCollectionDataSource(reportLines);\n\n\t\t\n\t\ttry {\n\t\t\tJasperReport report = JasperCompileManager.compileReport(jrxmlFile\n\t\t\t\t\t.getAbsolutePath());\n\t\t\tJasperPrint jasperPrint = JasperFillManager.fillReport(report,\n\t\t\t\t\tparams, dataSource);\n\n\t\t\tJRExporter exporter = format.getExporter();\n\t\t\texporter.setParameter(JRExporterParameter.OUTPUT_STREAM, out);\n\t\t\texporter.setParameter(JRExporterParameter.JASPER_PRINT, jasperPrint);\n\t\t\texporter.exportReport();\n\t\t} catch (Exception ex) {\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void verifySession( String sessionId )\n\t{\n\t    WebSession ws = WebSessionManager.getInstance( ).getSession( sessionId );\n\t    if ( ws == null ) {\n\t    \tthrow new RuntimeException(\"Session verification failed:\" + sessionId);\n\t    }\n\t    User user;\n\t\ttry {\n\t\t\tuser = EuareWebBackend.getUser( ws.getUserName( ), ws.getAccountName( ) );\n\t\t} catch ( EucalyptusServiceException ex ) {\n\t\t\tthrow new RuntimeException(\"Session verification failed\", ex);\n\t\t}\n\t    if ( user==null || !user.isSystemAdmin() ) {\n\t    \tthrow new RuntimeException(\"Only admins can generate reports\");\n\t    }\n\t}","id":24175,"modified_method":"private User getUserFromSession( String sessionId )\n\t{\n\t    WebSession ws = WebSessionManager.getInstance( ).getSession( sessionId );\n\t    if ( ws == null ) {\n\t    \tthrow new RuntimeException(\"Session verification failed:\" + sessionId);\n\t    }\n\t    User user;\n\t\ttry {\n\t\t\tuser = EuareWebBackend.getUser( ws.getUserName( ), ws.getAccountName( ) );\n\t\t} catch ( EucalyptusServiceException ex ) {\n\t\t\tthrow new RuntimeException(\"Session verification failed\", ex);\n\t\t}\n\t    return user;\n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n\t * <p>Expects the following servlet params:\n\t * type,format,session,start,end,criterion,groupByCriterion\n\t * \n\t * <p>Type, format, criterion, and groupByCriterion are taken from the\n\t * enums: ReportType, ReportFormat, and ReportingCriterion.\n\t * GroupByCriterion can also have the value \"None\". Start and\n\t * end are in milliseconds. Session is a session id string.\n\t */\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows ServletException, IOException\n\t{\n\t\tthis.verifySession(Param.session.getRaw(req));\n\n\t\t/* Parse all params\n\t\t */\n\t\tfinal ReportType reportType = ReportType.valueOf(Param.type.get(req));\n\t\tfinal ReportFormat format = ReportFormat.valueOf(Param.format.get(req));\n\t\tfinal long start = Long.parseLong(Param.start.get(req));\n\t\tfinal long end = Long.parseLong(Param.end.get(req));\n\t\tfinal Period period = new Period(start, end);\n\t\tfinal ReportingCriterion criterion =\n\t\t\tReportingCriterion.valueOf(Param.criterion.get(req));\n\t\t// TODO: configurable\n\t\tfinal Units displayUnits = Units.DEFAULT_DISPLAY_UNITS;\n\t\t\n\t\tReportingCriterion groupByCriterion = null;\n\t\t//GroupByCriterion can optionally have value \"None\"; check for it\n\t\tString groupByParam = req.getParameter(Param.groupByCriterion.name());\n\t\tif (groupByParam!=null && !groupByParam.equalsIgnoreCase(\"NONE\")) {\n\t\t\tgroupByCriterion =\n\t\t\t\tReportingCriterion.valueOf(Param.groupByCriterion.get(req));\n\t\t}\n\t\tLOG.info(String.format(\"Params: type:%s format:%s period:%s\"\n\t\t\t\t+ \"criterion:%s groupBy:%s\", reportType, format, period,\n\t\t\t\tcriterion, groupByCriterion));\n\n\t\t\n\t\t\n\t\t/* Set servlet response content type, etc, based upon report format.\n\t\t */\n\t\tsetContentTypeHeader(res, format, Param.type.get(req));\n\t\t\n\t\t\n\t\t/* Generate the report and send it thru the OutputStream\n\t\t */\n\t\tReportGenerator.getInstance().generateReport(reportType, format,\n\t\t\t\tperiod, criterion, groupByCriterion, displayUnits,\n\t\t\t\tres.getOutputStream());\n\t  \n\t}","id":24176,"modified_method":"/**\n\t * <p>Expects the following servlet params:\n\t * type,format,session,start,end,criterion,groupByCriterion\n\t * \n\t * <p>Type, format, criterion, and groupByCriterion are taken from the\n\t * enums: ReportType, ReportFormat, and ReportingCriterion.\n\t * GroupByCriterion can also have the value \"None\". Start and\n\t * end are in milliseconds. Session is a session id string.\n\t */\n\t@Override\n\tprotected void doGet(HttpServletRequest req, HttpServletResponse res)\n\t\tthrows ServletException, IOException\n\t{\n\t\tUser user = this.getUserFromSession(Param.session.getRaw(req));\n\t    if ( user==null ) {\n\t    \tthrow new RuntimeException(\"User was null\");\n\t    }\n\n\t\t/* Parse all params\n\t\t */\n\t\tfinal ReportType reportType = ReportType.valueOf(Param.type.get(req));\n\t\tfinal ReportFormat format = ReportFormat.valueOf(Param.format.get(req));\n\t\tfinal long start = Long.parseLong(Param.start.get(req));\n\t\tfinal long end = Long.parseLong(Param.end.get(req));\n\t\tfinal Period period = new Period(start, end);\n\t\tfinal ReportingCriterion criterion =\n\t\t\tReportingCriterion.valueOf(Param.criterion.get(req));\n\t\t// TODO: configurable\n\t\tfinal Units displayUnits = Units.DEFAULT_DISPLAY_UNITS;\n\t\t\n\t\tReportingCriterion groupByCriterion = null;\n\t\t//GroupByCriterion can optionally have value \"None\"; check for it\n\t\tString groupByParam = req.getParameter(Param.groupByCriterion.name());\n\t\tif (groupByParam!=null && !groupByParam.equalsIgnoreCase(\"NONE\")) {\n\t\t\tgroupByCriterion =\n\t\t\t\tReportingCriterion.valueOf(Param.groupByCriterion.get(req));\n\t\t}\n\t\tLOG.info(String.format(\"Params: type:%s format:%s period:%s\"\n\t\t\t\t+ \"criterion:%s groupBy:%s\", reportType, format, period,\n\t\t\t\tcriterion, groupByCriterion));\n\n\t\t\n\t\t\n\t\t/* Set servlet response content type, etc, based upon report format.\n\t\t */\n\t\tsetContentTypeHeader(res, format, Param.type.get(req));\n\t\t\n\t\t\n\t\t/* Generate the report and send it thru the OutputStream\n\t\t */\n\t\tif (user.isSystemAdmin()) {\n\t\t\t//Generate report of all accounts\n\t\t\tReportGenerator.getInstance().generateReport(reportType, format,\n\t\t\t\tperiod, criterion, groupByCriterion, displayUnits,\n\t\t\t\tres.getOutputStream(), null);\n\t\t} else if (user.isAccountAdmin()) {\n\t\t\tString accountId;\n\t\t\ttry {\n\t\t\t\taccountId = user.getAccount().getAccountNumber();\n\t\t\t} catch (AuthException aex) {\n\t\t\t\tthrow new RuntimeException(\"Auth failed\");\n\t\t\t}\n\t\t\t//Generate report of this account only\n\t\t\tReportGenerator.getInstance().generateReport(reportType, format,\n\t\t\t\t\tperiod, criterion, groupByCriterion, displayUnits,\n\t\t\t\t\tres.getOutputStream(), accountId);\t\t\t\n\t\t} else {\n\t\t\tthrow new RuntimeException(\"Only admins can generate reports\");\n\t\t}\n\t  \n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public List<S3ReportLine> getReportLines(Period period, ReportingCriterion groupByCrit,\n\t\t\tReportingCriterion crit, Units displayUnits)\n\t{\n\t\tMap<S3ReportLineKey, S3ReportLine> reportLineMap =\n\t\t\tnew HashMap<S3ReportLineKey, S3ReportLine>();\n\t\t\n\t\tS3UsageLog usageLog = S3UsageLog.getS3UsageLog();\n\t\tMap<S3SummaryKey, S3UsageSummary> usageMap = \n\t\t\tusageLog.getUsageSummaryMap(period);\n\t\tfor (S3SummaryKey key: usageMap.keySet()) {\n\t\t\tLog.info(\"Adding key:\" + key + \" data:\" + usageMap.get(key));\n\t\t\tString critVal = getAttributeValue(crit, key);\n\t\t\tString groupVal = (groupByCrit==null) ? null : getAttributeValue(groupByCrit, key);\n\t\t\tS3ReportLineKey lineKey = new S3ReportLineKey(critVal, groupVal);\n\t\t\tif (!reportLineMap.containsKey(lineKey)) {\n\t\t\t\treportLineMap.put(lineKey, new S3ReportLine(lineKey,\n\t\t\t\t\t\tnew S3UsageSummary(), displayUnits));\n\t\t\t}\n\t\t\tS3ReportLine reportLine = reportLineMap.get(lineKey);\n\t\t\tS3UsageSummary summary = usageMap.get(key);\n\t\t\treportLine.addUsage(summary);\n\t\t}\n\n\t\tfinal List<S3ReportLine> results = new ArrayList<S3ReportLine>();\n\t\tfor (S3ReportLineKey lineKey: reportLineMap.keySet()) {\n\t\t\tresults.add(reportLineMap.get(lineKey));\n\t\t}\n\t\t\n\t\tCollections.sort(results);\n\t\treturn results;\n\t}","id":24177,"modified_method":"public List<S3ReportLine> getReportLines(Period period, ReportingCriterion groupByCrit,\n\t\t\tReportingCriterion crit, Units displayUnits, String accountId)\n\t{\n\t\tMap<S3ReportLineKey, S3ReportLine> reportLineMap =\n\t\t\tnew HashMap<S3ReportLineKey, S3ReportLine>();\n\t\t\n\t\tS3UsageLog usageLog = S3UsageLog.getS3UsageLog();\n\t\tMap<S3SummaryKey, S3UsageSummary> usageMap = \n\t\t\tusageLog.getUsageSummaryMap(period, accountId);\n\t\tfor (S3SummaryKey key: usageMap.keySet()) {\n\t\t\tLog.info(\"Adding key:\" + key + \" data:\" + usageMap.get(key));\n\t\t\tString critVal = getAttributeValue(crit, key);\n\t\t\tString groupVal = (groupByCrit==null) ? null : getAttributeValue(groupByCrit, key);\n\t\t\tS3ReportLineKey lineKey = new S3ReportLineKey(critVal, groupVal);\n\t\t\tif (!reportLineMap.containsKey(lineKey)) {\n\t\t\t\treportLineMap.put(lineKey, new S3ReportLine(lineKey,\n\t\t\t\t\t\tnew S3UsageSummary(), displayUnits));\n\t\t\t}\n\t\t\tS3ReportLine reportLine = reportLineMap.get(lineKey);\n\t\t\tS3UsageSummary summary = usageMap.get(key);\n\t\t\treportLine.addUsage(summary);\n\t\t}\n\n\t\tfinal List<S3ReportLine> results = new ArrayList<S3ReportLine>();\n\t\tfor (S3ReportLineKey lineKey: reportLineMap.keySet()) {\n\t\t\tresults.add(reportLineMap.get(lineKey));\n\t\t}\n\t\t\n\t\tCollections.sort(results);\n\t\treturn results;\n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public List<S3ReportLine> getReportLines(Period period,\n\t\t\tReportingCriterion criterion,\tUnits displayUnits)\n\t{\n\t\treturn getReportLines(period, null, criterion, displayUnits);\n\t}","id":24178,"modified_method":"public List<S3ReportLine> getReportLines(Period period,\n\t\t\tReportingCriterion criterion, Units displayUnits,\n\t\t\tString accountId)\n\t{\n\t\treturn getReportLines(period, null, criterion, displayUnits, accountId);\n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n\t * <p>Gather a Map of all S3 resource usage for a period.\n\t */\n    public Map<S3SummaryKey, S3UsageSummary> getUsageSummaryMap(Period period)\n    {\n    \tlog.info(\"GetUsageSummaryMap period:\" + period);\n    \tfinal Map<S3SummaryKey, S3UsageSummary> usageMap =\n    \t\tnew HashMap<S3SummaryKey, S3UsageSummary>();\n\n    \tEntityWrapper<S3UsageSnapshot> entityWrapper =\n\t\t\tEntityWrapper.get(S3UsageSnapshot.class);\n\t\ttry {\n\n\n\t\t\t/* Start query from last snapshot before report beginning, iterate\n\t\t\t * through the data, and accumulate all reporting info through the\n\t\t\t * report end. We will accumulate a fraction of a snapshot at the\n\t\t\t * beginning and end, since report boundaries will not likely\n\t\t\t * coincide with sampling period boundaries.\n\t\t\t */\n\t\t\tMap<S3SummaryKey,S3DataAccumulator> dataAccumulatorMap =\n\t\t\t\tnew HashMap<S3SummaryKey,S3DataAccumulator>();\n\t\t\t\n\t\t\tlong latestSnapshotBeforeMs =\n\t\t\t\tfindLatestAllSnapshotBefore(period.getBeginningMs());\n\n\t\t\t@SuppressWarnings(\"rawtypes\")\n\t\t\tList list = entityWrapper.createQuery(\n\t\t\t\t\t\"from S3UsageSnapshot as sus\"\n\t\t\t\t\t+ \" WHERE sus.key.timestampMs > ?\"\n\t\t\t\t\t+ \" AND sus.key.timestampMs < ?\")\n\t\t\t\t\t.setLong(0, new Long(latestSnapshotBeforeMs))\n\t\t\t\t\t.setLong(1, new Long(period.getEndingMs()))\n\t\t\t\t\t.list();\n\t\t\t\n\t\t\tfor (Object obj: list) {\n\t\t\t\t\n\t\t\t\tS3UsageSnapshot snapshot = (S3UsageSnapshot) obj;\n\t\t\t\tS3SnapshotKey snapshotKey = snapshot.getSnapshotKey();\n\t\t\t\tS3SummaryKey summaryKey = new S3SummaryKey(snapshotKey);\n\n\t\t\t\tif ( snapshotKey.getTimestampMs() < period.getBeginningMs()\n\t\t\t\t\t || !dataAccumulatorMap.containsKey(summaryKey) ) {\n\n\t\t\t\t\t//new accumulator, discard earlier accumulators from before report beginning\n\t\t\t\t\tS3DataAccumulator accumulator =\n\t\t\t\t\t\tnew S3DataAccumulator(snapshotKey.getTimestampMs(),\n\t\t\t\t\t\t\t\tsnapshot.getUsageData(), new S3UsageSummary());\n\t\t\t\t\tdataAccumulatorMap.put(summaryKey, accumulator);\n\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t/* Within interval; accumulate resource usage by adding\n\t\t\t\t\t * to accumulator, for this key.\n\t\t\t\t\t */\n\t\t\t\t\tS3DataAccumulator accumulator =\tdataAccumulatorMap.get( summaryKey );\n\n\t\t\t\t\t/* Extrapolate fractional usage for snapshots which occurred\n\t\t\t\t\t * before report beginning.\n\t\t\t\t\t */\n\t\t\t\t\tlong beginningMs = Math.max( period.getBeginningMs(),\n\t\t\t\t\t\t\taccumulator.getLastTimestamp() );\n\t\t\t\t\t//query above specifies timestamp is before report end\n\t\t\t\t\tlong endingMs = snapshotKey.getTimestampMs()-1;\n\t\t\t\t\tlong durationSecs = (endingMs - beginningMs) / 1000;\n\n\t\t\t\t\taccumulator.accumulateUsage( durationSecs );\t\t\n\t\t\t\t\taccumulator.setLastTimestamp(snapshotKey.getTimestampMs());\n\t\t\t\t\taccumulator.setLastUsageData(snapshot.getUsageData());\n\t\t\t\t\tlog.info(String.format(\"Accumulate usage, %d-%d, key:%s\",\n\t\t\t\t\t\t\tbeginningMs, endingMs, summaryKey));\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Accumulate fractional data usage at end of reporting period.\n\t\t\t */\n\t\t\tfor ( S3SummaryKey key: dataAccumulatorMap.keySet() ) {\n\t\t\t\t\n\t\t\t\tS3DataAccumulator accumulator =\tdataAccumulatorMap.get( key );\n\t\t\t\tlong beginningMs = Math.max( period.getBeginningMs(),\n\t\t\t\t\t\taccumulator.getLastTimestamp() );\n\t\t\t\tlong endingMs = period.getEndingMs() - 1;\n\t\t\t\tlong durationSecs = ( endingMs-beginningMs ) / 1000;\n\t\t\t\taccumulator.accumulateUsage( durationSecs );\n\t\t\t\tlog.info(String.format(\"Accumulate endUsage, %d-%d, key:%s\",\n\t\t\t\t\t\tbeginningMs, endingMs, key));\n\n\t\t\t\t//add to results\n\t\t\t\tusageMap.put( key, accumulator.getCurrentSummary() );\n\t\t\t}\n\n\t\t\tentityWrapper.commit();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(ex);\n\t\t\tentityWrapper.rollback();\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\n        return usageMap;\n    }","id":24179,"modified_method":"/**\n\t * <p>Gather a Map of all S3 resource usage for a period.\n\t */\n    public Map<S3SummaryKey, S3UsageSummary> getUsageSummaryMap(Period period,\n    \t\tString accountId)\n    {\n    \tlog.info(\"GetUsageSummaryMap period:\" + period);\n    \tfinal Map<S3SummaryKey, S3UsageSummary> usageMap =\n    \t\tnew HashMap<S3SummaryKey, S3UsageSummary>();\n\n    \tEntityWrapper<S3UsageSnapshot> entityWrapper =\n\t\t\tEntityWrapper.get(S3UsageSnapshot.class);\n\t\ttry {\n\n\n\t\t\t/* Start query from last snapshot before report beginning, iterate\n\t\t\t * through the data, and accumulate all reporting info through the\n\t\t\t * report end. We will accumulate a fraction of a snapshot at the\n\t\t\t * beginning and end, since report boundaries will not likely\n\t\t\t * coincide with sampling period boundaries.\n\t\t\t */\n\t\t\tMap<S3SummaryKey,S3DataAccumulator> dataAccumulatorMap =\n\t\t\t\tnew HashMap<S3SummaryKey,S3DataAccumulator>();\n\t\t\t\n\t\t\tlong latestSnapshotBeforeMs =\n\t\t\t\tfindLatestAllSnapshotBefore(period.getBeginningMs());\n\n\t\t\t@SuppressWarnings(\"rawtypes\")\n\t\t\tList list = null;\n\t\t\t\n\t\t\tif (accountId == null) {\n\t\t\t\tlist = entityWrapper.createQuery(\n\t\t\t\t\t\"from S3UsageSnapshot as sus\"\n\t\t\t\t\t+ \" WHERE sus.key.timestampMs > ?\"\n\t\t\t\t\t+ \" AND sus.key.timestampMs < ?\")\n\t\t\t\t\t.setLong(0, new Long(latestSnapshotBeforeMs))\n\t\t\t\t\t.setLong(1, new Long(period.getEndingMs()))\n\t\t\t\t\t.list();\n\t\t\t} else {\n\t\t\t\tlist = entityWrapper.createQuery(\n\t\t\t\t\t\t\"from S3UsageSnapshot as sus\"\n\t\t\t\t\t\t+ \" WHERE sus.key.timestampMs > ?\"\n\t\t\t\t\t\t+ \" AND sus.key.timestampMs < ?\"\n\t\t\t\t\t\t+ \" AND sus.key.accountId = ?\")\n\t\t\t\t\t\t.setLong(0, new Long(latestSnapshotBeforeMs))\n\t\t\t\t\t\t.setLong(1, new Long(period.getEndingMs()))\n\t\t\t\t\t\t.setString(2, accountId)\n\t\t\t\t\t\t.list();\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tfor (Object obj: list) {\n\t\t\t\t\n\t\t\t\tS3UsageSnapshot snapshot = (S3UsageSnapshot) obj;\n\t\t\t\tS3SnapshotKey snapshotKey = snapshot.getSnapshotKey();\n\t\t\t\tS3SummaryKey summaryKey = new S3SummaryKey(snapshotKey);\n\n\t\t\t\tif ( snapshotKey.getTimestampMs() < period.getBeginningMs()\n\t\t\t\t\t || !dataAccumulatorMap.containsKey(summaryKey) ) {\n\n\t\t\t\t\t//new accumulator, discard earlier accumulators from before report beginning\n\t\t\t\t\tS3DataAccumulator accumulator =\n\t\t\t\t\t\tnew S3DataAccumulator(snapshotKey.getTimestampMs(),\n\t\t\t\t\t\t\t\tsnapshot.getUsageData(), new S3UsageSummary());\n\t\t\t\t\tdataAccumulatorMap.put(summaryKey, accumulator);\n\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t/* Within interval; accumulate resource usage by adding\n\t\t\t\t\t * to accumulator, for this key.\n\t\t\t\t\t */\n\t\t\t\t\tS3DataAccumulator accumulator =\tdataAccumulatorMap.get( summaryKey );\n\n\t\t\t\t\t/* Extrapolate fractional usage for snapshots which occurred\n\t\t\t\t\t * before report beginning.\n\t\t\t\t\t */\n\t\t\t\t\tlong beginningMs = Math.max( period.getBeginningMs(),\n\t\t\t\t\t\t\taccumulator.getLastTimestamp() );\n\t\t\t\t\t//query above specifies timestamp is before report end\n\t\t\t\t\tlong endingMs = snapshotKey.getTimestampMs()-1;\n\t\t\t\t\tlong durationSecs = (endingMs - beginningMs) / 1000;\n\n\t\t\t\t\taccumulator.accumulateUsage( durationSecs );\t\t\n\t\t\t\t\taccumulator.setLastTimestamp(snapshotKey.getTimestampMs());\n\t\t\t\t\taccumulator.setLastUsageData(snapshot.getUsageData());\n\t\t\t\t\tlog.info(String.format(\"Accumulate usage, %d-%d, key:%s\",\n\t\t\t\t\t\t\tbeginningMs, endingMs, summaryKey));\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Accumulate fractional data usage at end of reporting period.\n\t\t\t */\n\t\t\tfor ( S3SummaryKey key: dataAccumulatorMap.keySet() ) {\n\t\t\t\t\n\t\t\t\tS3DataAccumulator accumulator =\tdataAccumulatorMap.get( key );\n\t\t\t\tlong beginningMs = Math.max( period.getBeginningMs(),\n\t\t\t\t\t\taccumulator.getLastTimestamp() );\n\t\t\t\tlong endingMs = period.getEndingMs() - 1;\n\t\t\t\tlong durationSecs = ( endingMs-beginningMs ) / 1000;\n\t\t\t\taccumulator.accumulateUsage( durationSecs );\n\t\t\t\tlog.info(String.format(\"Accumulate endUsage, %d-%d, key:%s\",\n\t\t\t\t\t\tbeginningMs, endingMs, key));\n\n\t\t\t\t//add to results\n\t\t\t\tusageMap.put( key, accumulator.getCurrentSummary() );\n\t\t\t}\n\n\t\t\tentityWrapper.commit();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(ex);\n\t\t\tentityWrapper.rollback();\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\n        return usageMap;\n    }","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public List<StorageReportLine> getReportLines(Period period, ReportingCriterion groupByCrit,\n\t\t\tReportingCriterion crit, Units displayUnits)\n\t{\n\t\tMap<StorageReportLineKey, StorageReportLine> reportLineMap =\n\t\t\tnew HashMap<StorageReportLineKey, StorageReportLine>();\n\t\t\n\t\tStorageUsageLog usageLog = StorageUsageLog.getStorageUsageLog();\n\t\tMap<StorageSummaryKey, StorageUsageSummary> usageMap = \n\t\t\tusageLog.getUsageSummaryMap(period);\n\t\tfor (StorageSummaryKey key: usageMap.keySet()) {\n\t\t\tString critVal = getAttributeValue(crit, key);\n\t\t\tString groupVal = (groupByCrit==null) ? null : getAttributeValue(groupByCrit, key);\n\t\t\tStorageReportLineKey lineKey = new StorageReportLineKey(critVal, groupVal);\n\t\t\tif (!reportLineMap.containsKey(lineKey)) {\n\t\t\t\treportLineMap.put(lineKey, new StorageReportLine(lineKey,\n\t\t\t\t\t\tnew StorageUsageSummary(), displayUnits));\n\t\t\t}\n\t\t\tStorageReportLine reportLine = reportLineMap.get(lineKey);\n\t\t\tStorageUsageSummary summary = usageMap.get(key);\n\t\t\treportLine.addUsage(summary);\n\t\t}\n\n\t\tfinal List<StorageReportLine> results = new ArrayList<StorageReportLine>();\n\t\tfor (StorageReportLineKey lineKey: reportLineMap.keySet()) {\n\t\t\tresults.add(reportLineMap.get(lineKey));\n\t\t}\n\n\t\tCollections.sort(results);\n\n\t\treturn results;\n\t}","id":24180,"modified_method":"public List<StorageReportLine> getReportLines(Period period, ReportingCriterion groupByCrit,\n\t\t\tReportingCriterion crit, Units displayUnits, String accountId)\n\t{\n\t\tMap<StorageReportLineKey, StorageReportLine> reportLineMap =\n\t\t\tnew HashMap<StorageReportLineKey, StorageReportLine>();\n\t\t\n\t\tStorageUsageLog usageLog = StorageUsageLog.getStorageUsageLog();\n\t\tMap<StorageSummaryKey, StorageUsageSummary> usageMap = \n\t\t\tusageLog.getUsageSummaryMap(period, accountId);\n\t\tfor (StorageSummaryKey key: usageMap.keySet()) {\n\t\t\tString critVal = getAttributeValue(crit, key);\n\t\t\tString groupVal = (groupByCrit==null) ? null : getAttributeValue(groupByCrit, key);\n\t\t\tStorageReportLineKey lineKey = new StorageReportLineKey(critVal, groupVal);\n\t\t\tif (!reportLineMap.containsKey(lineKey)) {\n\t\t\t\treportLineMap.put(lineKey, new StorageReportLine(lineKey,\n\t\t\t\t\t\tnew StorageUsageSummary(), displayUnits));\n\t\t\t}\n\t\t\tStorageReportLine reportLine = reportLineMap.get(lineKey);\n\t\t\tStorageUsageSummary summary = usageMap.get(key);\n\t\t\treportLine.addUsage(summary);\n\t\t}\n\n\t\tfinal List<StorageReportLine> results = new ArrayList<StorageReportLine>();\n\t\tfor (StorageReportLineKey lineKey: reportLineMap.keySet()) {\n\t\t\tresults.add(reportLineMap.get(lineKey));\n\t\t}\n\n\t\tCollections.sort(results);\n\n\t\treturn results;\n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public List<StorageReportLine> getReportLines(Period period,\n\t\t\tReportingCriterion criterion,\tUnits displayUnits)\n\t{\n\t\treturn getReportLines(period, null, criterion, displayUnits);\n\t}","id":24181,"modified_method":"public List<StorageReportLine> getReportLines(Period period,\n\t\t\tReportingCriterion criterion, Units displayUnits,\n\t\t\tString accountId)\n\t{\n\t\treturn getReportLines(period, null, criterion, displayUnits, accountId);\n\t}","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n\t * <p>Gather a Map of all Storage resource usage for a period.\n\t */\n    public Map<StorageSummaryKey, StorageUsageSummary> getUsageSummaryMap(Period period)\n    {\n    \tlog.info(\"GetUsageSummaryMap period:\" + period);\n    \tfinal Map<StorageSummaryKey, StorageUsageSummary> usageMap =\n    \t\tnew HashMap<StorageSummaryKey, StorageUsageSummary>();\n\n    \tEntityWrapper<StorageUsageSnapshot> entityWrapper =\n\t\t\tEntityWrapper.get(StorageUsageSnapshot.class);\n\t\ttry {\n\n\n\t\t\t/* Start query from last snapshot before report beginning, iterate\n\t\t\t * through the data, and accumulate all reporting info through the\n\t\t\t * report end. We will accumulate a fraction of a snapshot at the\n\t\t\t * beginning and end, since report boundaries will not likely\n\t\t\t * coincide with sampling period boundaries.\n\t\t\t */\n\t\t\tMap<StorageSummaryKey,StorageDataAccumulator> dataAccumulatorMap =\n\t\t\t\tnew HashMap<StorageSummaryKey,StorageDataAccumulator>();\n\t\t\t\n\t\t\tLong latestSnapshotBeforeMs =\n\t\t\t\tfindLatestAllSnapshotBefore(period.getBeginningMs());\n\n\t\t\t@SuppressWarnings(\"rawtypes\")\n\t\t\tList list = entityWrapper.createQuery(\n\t\t\t\t\t\"from StorageUsageSnapshot as sus\"\n\t\t\t\t\t+ \" WHERE sus.key.timestampMs > ?\"\n\t\t\t\t\t+ \" AND sus.key.timestampMs < ?\")\n\t\t\t\t\t.setLong(0, (latestSnapshotBeforeMs!=null ? latestSnapshotBeforeMs : 0l))\n\t\t\t\t\t.setLong(1, new Long(period.getEndingMs()))\n\t\t\t\t\t.list();\n\t\t\t\n\t\t\tfor (Object obj: list) {\n\t\t\t\t\n\t\t\t\tStorageUsageSnapshot snapshot = (StorageUsageSnapshot) obj;\n\t\t\t\tStorageSnapshotKey snapshotKey = snapshot.getSnapshotKey();\n\t\t\t\tStorageSummaryKey summaryKey = new StorageSummaryKey(snapshotKey);\n\n\t\t\t\tif ( snapshotKey.getTimestampMs() < period.getBeginningMs()\n\t\t\t\t\t || !dataAccumulatorMap.containsKey(summaryKey) ) {\n\n\t\t\t\t\t//new accumulator, discard earlier accumulators from before report beginning\n\t\t\t\t\tStorageDataAccumulator accumulator =\n\t\t\t\t\t\tnew StorageDataAccumulator(snapshotKey.getTimestampMs(),\n\t\t\t\t\t\t\t\tsnapshot.getUsageData(), new StorageUsageSummary());\n\t\t\t\t\tdataAccumulatorMap.put(summaryKey, accumulator);\n\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t/* Within interval; accumulate resource usage by adding\n\t\t\t\t\t * to accumulator, for this key.\n\t\t\t\t\t */\n\t\t\t\t\tStorageDataAccumulator accumulator =\tdataAccumulatorMap.get( summaryKey );\n\n\t\t\t\t\t/* Extrapolate fractional usage for snapshots which occurred\n\t\t\t\t\t * before report beginning.\n\t\t\t\t\t */\n\t\t\t\t\tlong beginningMs = Math.max( period.getBeginningMs(),\n\t\t\t\t\t\t\taccumulator.getLastTimestamp() );\n\t\t\t\t\t//query above specifies timestamp is before report end\n\t\t\t\t\tlong endingMs = snapshotKey.getTimestampMs()-1;\n\t\t\t\t\tlong durationSecs = (endingMs - beginningMs) / 1000;\n\n\t\t\t\t\taccumulator.accumulateUsage( durationSecs );\t\t\n\t\t\t\t\taccumulator.setLastTimestamp(snapshotKey.getTimestampMs());\n\t\t\t\t\taccumulator.setLastUsageData(snapshot.getUsageData());\n\t\t\t\t\tlog.info(String.format(\"Accumulate usage, %d-%d, key:%s\",\n\t\t\t\t\t\t\tbeginningMs, endingMs, summaryKey));\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Accumulate fractional data usage at end of reporting period.\n\t\t\t */\n\t\t\tfor ( StorageSummaryKey key: dataAccumulatorMap.keySet() ) {\n\t\t\t\t\n\t\t\t\tStorageDataAccumulator accumulator =\tdataAccumulatorMap.get( key );\n\t\t\t\tlong beginningMs = Math.max( period.getBeginningMs(),\n\t\t\t\t\t\taccumulator.getLastTimestamp() );\n\t\t\t\tlong endingMs = period.getEndingMs() - 1;\n\t\t\t\tlong durationSecs = ( endingMs-beginningMs ) / 1000;\n\t\t\t\taccumulator.accumulateUsage( durationSecs );\n\t\t\t\tlog.info(String.format(\"Accumulate endUsage, %d-%d, key:%s\",\n\t\t\t\t\t\tbeginningMs, endingMs, key));\n\n\t\t\t\t//add to results\n\t\t\t\tusageMap.put( key, accumulator.getCurrentSummary() );\n\t\t\t}\n\n\t\t\tentityWrapper.commit();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(ex);\n\t\t\tentityWrapper.rollback();\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\n        return usageMap;\n    }","id":24182,"modified_method":"/**\n\t * <p>Gather a Map of all Storage resource usage for a period.\n\t */\n    public Map<StorageSummaryKey, StorageUsageSummary> getUsageSummaryMap(\n    \t\tPeriod period, String accountId)\n    {\n    \tlog.info(\"GetUsageSummaryMap period:\" + period);\n    \tfinal Map<StorageSummaryKey, StorageUsageSummary> usageMap =\n    \t\tnew HashMap<StorageSummaryKey, StorageUsageSummary>();\n\n    \tEntityWrapper<StorageUsageSnapshot> entityWrapper =\n\t\t\tEntityWrapper.get(StorageUsageSnapshot.class);\n\t\ttry {\n\n\n\t\t\t/* Start query from last snapshot before report beginning, iterate\n\t\t\t * through the data, and accumulate all reporting info through the\n\t\t\t * report end. We will accumulate a fraction of a snapshot at the\n\t\t\t * beginning and end, since report boundaries will not likely\n\t\t\t * coincide with sampling period boundaries.\n\t\t\t */\n\t\t\tMap<StorageSummaryKey,StorageDataAccumulator> dataAccumulatorMap =\n\t\t\t\tnew HashMap<StorageSummaryKey,StorageDataAccumulator>();\n\t\t\t\n\t\t\tLong latestSnapshotBeforeMs =\n\t\t\t\tfindLatestAllSnapshotBefore(period.getBeginningMs());\n\n\t\t\t@SuppressWarnings(\"rawtypes\")\n\t\t\tList list = null;\n\n\t\t\tif (accountId == null) {\n\t\t\t\tlist = entityWrapper.createQuery(\n\t\t\t\t\t\"from StorageUsageSnapshot as sus\"\n\t\t\t\t\t+ \" WHERE sus.key.timestampMs > ?\"\n\t\t\t\t\t+ \" AND sus.key.timestampMs < ?\")\n\t\t\t\t\t.setLong(0, (latestSnapshotBeforeMs!=null ? latestSnapshotBeforeMs : 0l))\n\t\t\t\t\t.setLong(1, new Long(period.getEndingMs()))\n\t\t\t\t\t.list();\n\t\t\t} else {\n\t\t\t\tlist = entityWrapper.createQuery(\n\t\t\t\t\t\t\"from StorageUsageSnapshot as sus\"\n\t\t\t\t\t\t+ \" WHERE sus.key.timestampMs > ?\"\n\t\t\t\t\t\t+ \" AND sus.key.timestampMs < ?\"\n\t\t\t\t\t\t+ \" AND sus.key.accountId = ?\")\n\t\t\t\t\t\t.setLong(0, (latestSnapshotBeforeMs!=null ? latestSnapshotBeforeMs : 0l))\n\t\t\t\t\t\t.setLong(1, new Long(period.getEndingMs()))\n\t\t\t\t\t\t.setString(2, accountId)\n\t\t\t\t\t\t.list();\n\t\t\t}\n\t\t\t\n\t\t\tfor (Object obj: list) {\n\t\t\t\t\n\t\t\t\tStorageUsageSnapshot snapshot = (StorageUsageSnapshot) obj;\n\t\t\t\tStorageSnapshotKey snapshotKey = snapshot.getSnapshotKey();\n\t\t\t\tStorageSummaryKey summaryKey = new StorageSummaryKey(snapshotKey);\n\n\t\t\t\tif ( snapshotKey.getTimestampMs() < period.getBeginningMs()\n\t\t\t\t\t || !dataAccumulatorMap.containsKey(summaryKey) ) {\n\n\t\t\t\t\t//new accumulator, discard earlier accumulators from before report beginning\n\t\t\t\t\tStorageDataAccumulator accumulator =\n\t\t\t\t\t\tnew StorageDataAccumulator(snapshotKey.getTimestampMs(),\n\t\t\t\t\t\t\t\tsnapshot.getUsageData(), new StorageUsageSummary());\n\t\t\t\t\tdataAccumulatorMap.put(summaryKey, accumulator);\n\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t/* Within interval; accumulate resource usage by adding\n\t\t\t\t\t * to accumulator, for this key.\n\t\t\t\t\t */\n\t\t\t\t\tStorageDataAccumulator accumulator =\tdataAccumulatorMap.get( summaryKey );\n\n\t\t\t\t\t/* Extrapolate fractional usage for snapshots which occurred\n\t\t\t\t\t * before report beginning.\n\t\t\t\t\t */\n\t\t\t\t\tlong beginningMs = Math.max( period.getBeginningMs(),\n\t\t\t\t\t\t\taccumulator.getLastTimestamp() );\n\t\t\t\t\t//query above specifies timestamp is before report end\n\t\t\t\t\tlong endingMs = snapshotKey.getTimestampMs()-1;\n\t\t\t\t\tlong durationSecs = (endingMs - beginningMs) / 1000;\n\n\t\t\t\t\taccumulator.accumulateUsage( durationSecs );\t\t\n\t\t\t\t\taccumulator.setLastTimestamp(snapshotKey.getTimestampMs());\n\t\t\t\t\taccumulator.setLastUsageData(snapshot.getUsageData());\n\t\t\t\t\tlog.info(String.format(\"Accumulate usage, %d-%d, key:%s\",\n\t\t\t\t\t\t\tbeginningMs, endingMs, summaryKey));\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t/* Accumulate fractional data usage at end of reporting period.\n\t\t\t */\n\t\t\tfor ( StorageSummaryKey key: dataAccumulatorMap.keySet() ) {\n\t\t\t\t\n\t\t\t\tStorageDataAccumulator accumulator =\tdataAccumulatorMap.get( key );\n\t\t\t\tlong beginningMs = Math.max( period.getBeginningMs(),\n\t\t\t\t\t\taccumulator.getLastTimestamp() );\n\t\t\t\tlong endingMs = period.getEndingMs() - 1;\n\t\t\t\tlong durationSecs = ( endingMs-beginningMs ) / 1000;\n\t\t\t\taccumulator.accumulateUsage( durationSecs );\n\t\t\t\tlog.info(String.format(\"Accumulate endUsage, %d-%d, key:%s\",\n\t\t\t\t\t\tbeginningMs, endingMs, key));\n\n\t\t\t\t//add to results\n\t\t\t\tusageMap.put( key, accumulator.getCurrentSummary() );\n\t\t\t}\n\n\t\t\tentityWrapper.commit();\n\t\t} catch (Exception ex) {\n\t\t\tlog.error(ex);\n\t\t\tentityWrapper.rollback();\n\t\t\tthrow new RuntimeException(ex);\n\t\t}\n\n        return usageMap;\n    }","commit_id":"3101babc4e5e55073fadbb2d89e6b674869c2815","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    final CoverageSuiteImpl currentSuite = (CoverageSuiteImpl)CoverageDataManager.getInstance(project).getCurrentSuite();\n\n    final ExportToHTMLDialog dialog = new ExportToHTMLDialog(project, true);\n    dialog.setTitle(\"Generate coverage report for: \\'\" + currentSuite.getPresentableName() + \"\\'\");\n    dialog.reset();\n    dialog.show();\n    if (!dialog.isOK()) return;\n    dialog.apply();\n\n    final ExportToHTMLSettings settings = ExportToHTMLSettings.getInstance(project);\n    currentSuite.getRunner().generateReport(project, currentSuite.isTrackTestFolders(), currentSuite.getCoverageDataFileName(), settings.OUTPUT_DIRECTORY, settings.OPEN_IN_BROWSER);\n  }","id":24183,"modified_method":"public void actionPerformed(final AnActionEvent e) {\n    final DataContext dataContext = e.getDataContext();\n    final Project project = PlatformDataKeys.PROJECT.getData(dataContext);\n    final CoverageDataManager coverageDataManager = CoverageDataManager.getInstance(project);\n    final CoverageSuiteImpl currentSuite = (CoverageSuiteImpl)coverageDataManager.getCurrentSuite();\n\n    final ExportToHTMLDialog dialog = new ExportToHTMLDialog(project, true);\n    dialog.setTitle(\"Generate coverage report for: \\'\" + currentSuite.getPresentableName() + \"\\'\");\n    dialog.reset();\n    dialog.show();\n    if (!dialog.isOK()) return;\n    dialog.apply();\n    try {\n      final File tempFile = File.createTempFile(\"temp\", \"\");\n      tempFile.deleteOnExit();\n      final ProjectData projectData = currentSuite.getCoverageData(coverageDataManager);\n      new SaveHook(tempFile, true, new IdeaClassFinder(project, currentSuite)).save(projectData);\n      final ExportToHTMLSettings settings = ExportToHTMLSettings.getInstance(project);\n      currentSuite.getRunner().generateReport(project, currentSuite.isTrackTestFolders(), tempFile.getCanonicalPath(), settings.OUTPUT_DIRECTORY, settings.OPEN_IN_BROWSER);\n    }\n    catch (IOException e1) {\n      LOG.error(e1);\n    }\n  }","commit_id":"36815872aff9dc9665aa817197c822a388703c40","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int getFailures(List<ITestResult> results) {\n        int retval=0;\n        for(ITestResult result:results) {\n            if(result != null && result.getStatus() == ITestResult.FAILURE)\n                retval++;\n        }\n        return retval;\n    }","id":24184,"modified_method":"private static int getFailures(Collection<ITestResult> results) {\n        int retval=0;\n        for(ITestResult result:results) {\n            if(result != null && result.getStatus() == ITestResult.FAILURE)\n                retval++;\n        }\n        return retval;\n    }","commit_id":"43aae7a72b563135624d36a1bea85fcfa562fc1a","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Invoked before any method (configuration or test) is invoked */\n    public void beforeInvocation(IInvokedMethod method, ITestResult tr) {\n        Class<?> real_class=tr.getTestClass().getRealClass();\n\n        local.set(real_class);\n\n        List<ITestResult> results=classes.get(real_class);\n        if(results == null) {\n            results=new LinkedList<ITestResult>();\n            classes.putIfAbsent(real_class, results);\n        }\n\n        outputs.putIfAbsent(real_class, new Tuple<StringBuffer,StringBuffer>(new StringBuffer(), new StringBuffer())) ;\n    }","id":24185,"modified_method":"/** Invoked before any method (configuration or test) is invoked */\n    public void beforeInvocation(IInvokedMethod method, ITestResult tr) {\n        Class<?> real_class=tr.getTestClass().getRealClass();\n\n        local.set(real_class);\n\n        Collection<ITestResult> results=classes.get(real_class);\n        if(results == null) {\n            results=new LinkedList<ITestResult>();\n            classes.putIfAbsent(real_class,results);\n        }\n\n        outputs.putIfAbsent(real_class, new Tuple<StringBuffer,StringBuffer>(new StringBuffer(), new StringBuffer())) ;\n    }","commit_id":"43aae7a72b563135624d36a1bea85fcfa562fc1a","url":"https://github.com/belaban/JGroups"},{"original_method":"private static long getTotalTime(List<ITestResult> results) {\n        long start=0, stop=0;\n        for(ITestResult result:results) {\n            if(result == null)\n                continue;\n            long tmp_start=result.getStartMillis(), tmp_stop=result.getEndMillis();\n            if(start == 0)\n                start=tmp_start;\n            else {\n                start=Math.min(start, tmp_start);\n            }\n\n            if(stop == 0)\n                stop=tmp_stop;\n            else {\n                stop=Math.max(stop, tmp_stop);\n            }\n        }\n        return stop - start;\n    }","id":24186,"modified_method":"private static long getTotalTime(Collection<ITestResult> results) {\n        long start=0, stop=0;\n        for(ITestResult result:results) {\n            if(result == null)\n                continue;\n            long tmp_start=result.getStartMillis(), tmp_stop=result.getEndMillis();\n            if(start == 0)\n                start=tmp_start;\n            else {\n                start=Math.min(start, tmp_start);\n            }\n\n            if(stop == 0)\n                stop=tmp_stop;\n            else {\n                stop=Math.max(stop, tmp_stop);\n            }\n        }\n        return stop - start;\n    }","commit_id":"43aae7a72b563135624d36a1bea85fcfa562fc1a","url":"https://github.com/belaban/JGroups"},{"original_method":"private static int getErrors(List<ITestResult> results) {\n        int retval=0;\n        for(ITestResult result:results) {\n            if(result != null && result.getStatus() != ITestResult.SUCCESS\n               && result.getStatus() != ITestResult.SUCCESS_PERCENTAGE_FAILURE\n               && result.getStatus() != ITestResult.FAILURE)\n                retval++;\n        }\n        return retval;\n    }","id":24187,"modified_method":"private static int getErrors(Collection<ITestResult> results) {\n        int retval=0;\n        for(ITestResult result:results) {\n            if(result != null && result.getStatus() != ITestResult.SUCCESS\n               && result.getStatus() != ITestResult.SUCCESS_PERCENTAGE_FAILURE\n               && result.getStatus() != ITestResult.FAILURE)\n                retval++;\n        }\n        return retval;\n    }","commit_id":"43aae7a72b563135624d36a1bea85fcfa562fc1a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * generate the XML report given what we know from all the test results\n     */\n    protected void generateReport(Class<?> clazz, List<ITestResult> results) throws IOException {\n\n        int num_failures=getFailures(results);\n        int num_skips=getSkips(results);\n        int num_errors=getErrors(results);\n        long total_time=getTotalTime(results);\n\n        String file_name=output_dir + File.separator + \"TEST-\" + clazz.getName();\n        if(suffix != null)\n            file_name=file_name + \"-\" + suffix;\n        file_name=file_name + \".xml\";\n        FileWriter out=new FileWriter(file_name, false); // don't append, overwrite\n        try {\n            out.write(XML_DEF + \"\\n\");\n\n            out.write(\"\\n<testsuite \" + \" failures=\\\"\"\n                      + num_failures\n                      + \"\\\" errors=\\\"\"\n                      + num_errors\n                      + \"\\\" skips=\\\"\"\n                      + num_skips\n                      + \"\\\" name=\\\"\"\n                      + clazz.getName());\n            if(suffix != null)\n                out.write(\" (\" + suffix + \")\");\n            out.write(\"\\\" tests=\\\"\" + results.size() + \"\\\" time=\\\"\" + (total_time / 1000.0) + \"\\\">\");\n\n            out.write(\"\\n<properties>\");\n            Properties props=System.getProperties();\n\n            for(Map.Entry<Object,Object> tmp:props.entrySet()) {\n                out.write(\"\\n    <property name=\\\"\" + tmp.getKey()\n                          + \"\\\"\"\n                          + \" value=\\\"\"\n                          + tmp.getValue()\n                          + \"\\\"/>\");\n            }\n            out.write(\"\\n<\/properties>\\n\");\n\n            for(ITestResult result:results) {\n                if(result == null)\n                    continue;\n                long time=result.getEndMillis() - result.getStartMillis();\n                out.write(\"\\n    <testcase classname=\\\"\" + clazz.getName());\n                if(suffix != null)\n                    out.write(\" (\" + suffix + \")\");\n                out.write(\"\\\" name=\\\"\" + result.getMethod().getMethodName()\n                          + \"\\\" time=\\\"\"\n                          + (time / 1000.0)\n                          + \"\\\">\");\n\n                Throwable ex=result.getThrowable();\n\n                switch(result.getStatus()) {\n                    case ITestResult.SUCCESS:\n                    case ITestResult.SUCCESS_PERCENTAGE_FAILURE:\n                        break;\n                    case ITestResult.FAILURE:\n                        writeFailure(\"failure\",\n                                     result.getMethod().getMethod(),\n                                     ex,\n                                     \"exception\",\n                                     out);\n                        break;\n                    case ITestResult.SKIP:\n                        writeFailure(\"error\", result.getMethod().getMethod(), ex, \"SKIPPED\", out);\n                        break;\n                    default:\n                        writeFailure(\"error\", result.getMethod().getMethod(), ex, \"exception\", out);\n                }\n\n                out.write(\"\\n<\/testcase>\");\n            }\n\n            Tuple<StringBuffer,StringBuffer> stdout=outputs.get(clazz);\n            if(stdout != null) {\n                StringBuffer system_out=stdout.getVal1();\n                StringBuffer system_err=stdout.getVal2();\n                writeOutput(out, system_out.toString(), 1);\n                out.write(\"\\n\");\n                writeOutput(out, system_err.toString(), 2);\n            }\n\n            out.write(\"\\n<\/testsuite>\\n\");\n        }\n        finally {\n            out.close();\n        }\n    }","id":24188,"modified_method":"/**\n     * generate the XML report given what we know from all the test results\n     */\n    protected void generateReport(Class<?> clazz, Collection<ITestResult> results) throws IOException {\n\n        int num_failures=getFailures(results);\n        int num_skips=getSkips(results);\n        int num_errors=getErrors(results);\n        long total_time=getTotalTime(results);\n\n        String file_name=output_dir + File.separator + \"TEST-\" + clazz.getName();\n        if(suffix != null)\n            file_name=file_name + \"-\" + suffix;\n        file_name=file_name + \".xml\";\n        FileWriter out=new FileWriter(file_name, false); // don't append, overwrite\n        try {\n            out.write(XML_DEF + \"\\n\");\n\n            out.write(\"\\n<testsuite \" + \" failures=\\\"\"\n                      + num_failures\n                      + \"\\\" errors=\\\"\"\n                      + num_errors\n                      + \"\\\" skips=\\\"\"\n                      + num_skips\n                      + \"\\\" name=\\\"\"\n                      + clazz.getName());\n            if(suffix != null)\n                out.write(\" (\" + suffix + \")\");\n            out.write(\"\\\" tests=\\\"\" + results.size() + \"\\\" time=\\\"\" + (total_time / 1000.0) + \"\\\">\");\n\n            out.write(\"\\n<properties>\");\n            Properties props=System.getProperties();\n\n            for(Map.Entry<Object,Object> tmp:props.entrySet()) {\n                out.write(\"\\n    <property name=\\\"\" + tmp.getKey()\n                          + \"\\\"\"\n                          + \" value=\\\"\"\n                          + tmp.getValue()\n                          + \"\\\"/>\");\n            }\n            out.write(\"\\n<\/properties>\\n\");\n\n            for(ITestResult result: results) {\n                if(result == null)\n                    continue;\n                long time=result.getEndMillis() - result.getStartMillis();\n                out.write(\"\\n    <testcase classname=\\\"\" + clazz.getName());\n                if(suffix != null)\n                    out.write(\" (\" + suffix + \")\");\n                out.write(\"\\\" name=\\\"\" + result.getMethod().getMethodName()\n                          + \"\\\" time=\\\"\"\n                          + (time / 1000.0)\n                          + \"\\\">\");\n\n                Throwable ex=result.getThrowable();\n\n                switch(result.getStatus()) {\n                    case ITestResult.SUCCESS:\n                    case ITestResult.SUCCESS_PERCENTAGE_FAILURE:\n                        break;\n                    case ITestResult.FAILURE:\n                        writeFailure(\"failure\",\n                                     result.getMethod().getMethod(),\n                                     ex,\n                                     \"exception\",\n                                     out);\n                        break;\n                    case ITestResult.SKIP:\n                        writeFailure(\"error\", result.getMethod().getMethod(), ex, \"SKIPPED\", out);\n                        break;\n                    default:\n                        writeFailure(\"error\", result.getMethod().getMethod(), ex, \"exception\", out);\n                }\n\n                out.write(\"\\n<\/testcase>\");\n            }\n\n            Tuple<StringBuffer,StringBuffer> stdout=outputs.get(clazz);\n            if(stdout != null) {\n                StringBuffer system_out=stdout.getVal1();\n                StringBuffer system_err=stdout.getVal2();\n                writeOutput(out, system_out.toString(), 1);\n                out.write(\"\\n\");\n                writeOutput(out, system_err.toString(), 2);\n            }\n\n            out.write(\"\\n<\/testsuite>\\n\");\n        }\n        finally {\n            out.close();\n        }\n    }","commit_id":"43aae7a72b563135624d36a1bea85fcfa562fc1a","url":"https://github.com/belaban/JGroups"},{"original_method":"private void addTest(Class<?> clazz, ITestResult result) {\n        List<ITestResult> results=classes.get(clazz);\n        if(results == null) {\n            results=new LinkedList<ITestResult>();\n            classes.putIfAbsent(clazz, results);\n        }\n\n        results=classes.get(clazz);\n        results.add(result);\n        \n        ITestNGMethod[] testMethods=result.getMethod().getTestClass().getTestMethods();\n        int enabledCount = enabledMethods(testMethods);\n        boolean allTestsInClassCompleted = results.size() >= enabledCount;\n        if(allTestsInClassCompleted){\n            try {\n                generateReport(clazz, results);\n            }\n            catch(IOException e) {\n                print(old_stderr, \"Failed generating report: \", clazz.getName(), \"\");\n            }\n        }                   \n    }","id":24189,"modified_method":"private void addTest(Class<?> clazz, ITestResult result) {\n        Collection<ITestResult> results=classes.get(clazz);\n        if(results == null) {\n            results=new ConcurrentLinkedQueue<ITestResult>();\n            Collection<ITestResult> tmp=classes.putIfAbsent(clazz,results);\n            if(tmp != null)\n                results=tmp;\n        }\n        results.add(result);\n        \n        ITestNGMethod[] testMethods=result.getMethod().getTestClass().getTestMethods();\n        int enabledCount = enabledMethods(testMethods);\n        boolean allTestsInClassCompleted = results.size() >= enabledCount;\n        if(allTestsInClassCompleted) {\n            boolean do_generate=false;\n            synchronized(generated_reports) {\n                do_generate=generated_reports.add(clazz);\n            }\n            try {\n                if(do_generate)\n                    generateReport(clazz, results);\n            }\n            catch(IOException e) {\n                print(old_stderr, \"Failed generating report: \", clazz.getName(), \"\");\n            }\n        }                   \n    }","commit_id":"43aae7a72b563135624d36a1bea85fcfa562fc1a","url":"https://github.com/belaban/JGroups"},{"original_method":"private static int getSkips(List<ITestResult> results) {\n        int retval=0;\n        for(ITestResult result:results) {\n            if(result != null && result.getStatus() == ITestResult.SKIP)\n                retval++;\n        }\n        return retval;\n    }","id":24190,"modified_method":"private static int getSkips(Collection<ITestResult> results) {\n        int retval=0;\n        for(ITestResult result:results) {\n            if(result != null && result.getStatus() == ITestResult.SKIP)\n                retval++;\n        }\n        return retval;\n    }","commit_id":"43aae7a72b563135624d36a1bea85fcfa562fc1a","url":"https://github.com/belaban/JGroups"},{"original_method":"public void keyPressed(final KeyEvent keyEvent) {\n    if (!(keyEvent.isAltDown() && (\n      (!SystemInfo.isMac && keyEvent.getKeyCode() == KeyEvent.VK_INSERT) ||\n        (SystemInfo.isMac && keyEvent.getKeyCode() == KeyEvent.VK_HELP)))) return;\n\n    final DataContext dataContext = DataManager.getInstance().getDataContext(this.getTree());\n    ListPopup popup = ModelAccess.instance().runReadAction(new Computable<ListPopup>() {\n      public ListPopup compute() {\n        ActionGroup group = getQuickCreateGroup(keyEvent.isControlDown());\n        if (group == null) return null;\n        Presentation presentation = new Presentation();\n        AnActionEvent event = new AnActionEvent(keyEvent, dataContext, ActionPlaces.UNKNOWN, presentation, ActionManager.getInstance(), 0);\n        ActionUtils.updateGroup(group, event);\n        return JBPopupFactory.getInstance()\n          .createActionGroupPopup(\"New\",\n            group,\n            dataContext,\n            JBPopupFactory.ActionSelectionAid.SPEEDSEARCH,\n            false);\n\n      }\n    });\n    if (popup == null) return;\n    popup.showInBestPositionFor(dataContext);\n  }","id":24191,"modified_method":"public void keyPressed(final KeyEvent keyEvent) {\n    boolean altDown = keyEvent.isAltDown();\n    boolean ctrlDown = keyEvent.isControlDown();\n    boolean insert = keyEvent.getKeyCode() == KeyEvent.VK_INSERT;\n    boolean n = keyEvent.getKeyCode() == KeyEvent.VK_N;\n    boolean rightKey = ((!SystemInfo.isMac) & altDown && insert) ||\n      (SystemInfo.isMac & ctrlDown && n);\n\n    if (!rightKey) return;\n\n    final DataContext dataContext = DataManager.getInstance().getDataContext(this.getTree());\n    ListPopup popup = ModelAccess.instance().runReadAction(new Computable<ListPopup>() {\n      public ListPopup compute() {\n        ActionGroup group = getQuickCreateGroup(keyEvent.isControlDown());\n        if (group == null) return null;\n        Presentation presentation = new Presentation();\n        AnActionEvent event = new AnActionEvent(keyEvent, dataContext, ActionPlaces.UNKNOWN, presentation, ActionManager.getInstance(), 0);\n        ActionUtils.updateGroup(group, event);\n        return JBPopupFactory.getInstance()\n          .createActionGroupPopup(\"New\",\n            group,\n            dataContext,\n            JBPopupFactory.ActionSelectionAid.SPEEDSEARCH,\n            false);\n\n      }\n    });\n    if (popup == null) return;\n    popup.showInBestPositionFor(dataContext);\n  }","commit_id":"c3477d45cf97c6806e0c0ce2d95524eb85a2bb5a","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void mouseReleased(MouseEvent e) {\n      if (UIUtil.isCloseClick(e, MouseEvent.MOUSE_RELEASED)) {\n        final TabInfo info = myTabs.findInfo(e);\n        if (info != null) {\n          IdeEventQueue.getInstance().blockNextEvents(e);\n          if (e.isAltDown()) {//close others\n            List<TabInfo> allTabInfos = myTabs.getTabs();\n            for (TabInfo tabInfo : allTabInfos) {\n              if (tabInfo == info) continue;\n              FileEditorManagerEx.getInstanceEx(myProject).closeFile((VirtualFile)tabInfo.getObject(), myWindow);\n            }\n          } else {\n            FileEditorManagerEx.getInstanceEx(myProject).closeFile((VirtualFile)info.getObject(), myWindow);\n          }\n        }\n      }\n    }","id":24192,"modified_method":"@Override\n    public void mouseReleased(MouseEvent e) {\n      if (UIUtil.isCloseClick(e, MouseEvent.MOUSE_RELEASED)) {\n        final TabInfo info = myTabs.findInfo(e);\n        if (info != null) {\n          IdeEventQueue.getInstance().blockNextEvents(e);\n          if (e.isAltDown() && e.getButton() == MouseEvent.BUTTON1) {//close others\n            List<TabInfo> allTabInfos = myTabs.getTabs();\n            for (TabInfo tabInfo : allTabInfos) {\n              if (tabInfo == info) continue;\n              FileEditorManagerEx.getInstanceEx(myProject).closeFile((VirtualFile)tabInfo.getObject(), myWindow);\n            }\n          } else {\n            FileEditorManagerEx.getInstanceEx(myProject).closeFile((VirtualFile)info.getObject(), myWindow);\n          }\n        }\n      }\n    }","commit_id":"bce0c4b9685ece61c9f36e4770738e1b586d3c82","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processMouseEvent(MouseEvent me) {\n      if (me.isAltDown() && me.isControlDown()) {\n        switch (me.getID()) {\n          case MouseEvent.MOUSE_CLICKED:\n            if (me.getClickCount() == 1 && !me.isPopupTrigger()) {\n              Object source = me.getSource();\n              if (source instanceof Component) {\n                showInspector((Component)source);\n              }\n              else {\n                Component owner = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();\n                if (owner != null) {\n                  showInspector(owner);\n                }\n              }\n              me.consume();\n            }\n\n            break;\n          default:\n            break;\n        }\n      }\n    }","id":24193,"modified_method":"private void processMouseEvent(MouseEvent me) {\n      if (!me.isAltDown() || !me.isControlDown()) return;\n      if (me.getClickCount() != 1 || me.isPopupTrigger()) return;\n      me.consume();\n      if (me.getID() != MouseEvent.MOUSE_RELEASED) return;\n      Component component = me.getComponent();\n\n      if (component instanceof Container) {\n        component = ((Container)component).findComponentAt(me.getPoint());\n      }\n      else if (component == null) {\n        component = KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();\n      }\n      if (component != null) {\n        showInspector(component);\n      }\n    }","commit_id":"58f4787e0bd2aa896580df5ddf8a97c2a7ae17b8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillCompletionVariants(final CompletionParameters parameters, final CompletionResultSet result) {\n    final boolean empty = JavaNoVariantsDelegator.containsOnlyPackages(result.runRemainingContributors(parameters, true)) ||\n                          suggestMetaAnnotations(parameters);\n\n    if (!empty && parameters.getInvocationCount() == 0) {\n      result.restartCompletionWhenNothingMatches();\n    }\n\n    if (empty) {\n      delegate(parameters, result);\n    } else if (Registry.is(\"ide.completion.show.all.classes\")) {\n      if (parameters.getInvocationCount() <= 1 &&\n          JavaCompletionContributor.mayStartClassName(result) &&\n          GroovyCompletionContributor.isClassNamePossible(parameters.getPosition()) &&\n          !MapArgumentCompletionProvider.isMapKeyCompletion(parameters)) {\n        suggestNonImportedClasses(parameters, result);\n      }\n    }\n  }","id":24194,"modified_method":"@Override\n  public void fillCompletionVariants(final CompletionParameters parameters, CompletionResultSet result) {\n    LinkedHashSet<CompletionResult> plainResults = result.runRemainingContributors(parameters, true);\n    final boolean empty = JavaNoVariantsDelegator.containsOnlyPackages(plainResults) || suggestMetaAnnotations(parameters);\n\n    if (!empty && parameters.getInvocationCount() == 0) {\n      result.restartCompletionWhenNothingMatches();\n    }\n\n    if (empty) {\n      delegate(parameters, result);\n    } else if (Registry.is(\"ide.completion.show.all.classes\") || Registry.is(\"ide.completion.show.better.matching.classes\")) {\n      if (parameters.getInvocationCount() <= 1 &&\n          JavaCompletionContributor.mayStartClassName(result) &&\n          GroovyCompletionContributor.isClassNamePossible(parameters.getPosition()) &&\n          !MapArgumentCompletionProvider.isMapKeyCompletion(parameters)) {\n        if (Registry.is(\"ide.completion.show.better.matching.classes\")) {\n          result = result.withPrefixMatcher(new BetterPrefixMatcher(result.getPrefixMatcher(), BetterPrefixMatcher.getBestMatchingDegree(plainResults)));\n        }\n\n        suggestNonImportedClasses(parameters, result);\n      }\n    }\n  }","commit_id":"880e6dbe092294b62cd584f54024625c852292b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillCompletionVariants(final CompletionParameters parameters, final CompletionResultSet result) {\n    final boolean empty = containsOnlyPackages(result.runRemainingContributors(parameters, true)) ||\n                          suggestMetaAnnotations(parameters);\n\n    if (!empty && parameters.getInvocationCount() == 0) {\n      result.restartCompletionWhenNothingMatches();\n    }\n\n    if (empty) {\n      delegate(parameters, JavaCompletionSorting.addJavaSorting(parameters, result));\n    } else if (Registry.is(\"ide.completion.show.all.classes\")) {\n      if (parameters.getInvocationCount() <= 1 &&\n          JavaCompletionContributor.mayStartClassName(result) &&\n          JavaCompletionContributor.isClassNamePossible(parameters)) {\n        suggestNonImportedClasses(parameters, result);\n      }\n    }\n  }","id":24195,"modified_method":"@Override\n  public void fillCompletionVariants(final CompletionParameters parameters, CompletionResultSet result) {\n    LinkedHashSet<CompletionResult> plainResults = result.runRemainingContributors(parameters, true);\n    final boolean empty = containsOnlyPackages(plainResults) || suggestMetaAnnotations(parameters);\n\n    if (!empty && parameters.getInvocationCount() == 0) {\n      result.restartCompletionWhenNothingMatches();\n    }\n\n    if (empty) {\n      delegate(parameters, JavaCompletionSorting.addJavaSorting(parameters, result));\n    } else if (Registry.is(\"ide.completion.show.all.classes\") || Registry.is(\"ide.completion.show.better.matching.classes\")) {\n      if (parameters.getInvocationCount() <= 1 &&\n          JavaCompletionContributor.mayStartClassName(result) &&\n          JavaCompletionContributor.isClassNamePossible(parameters)) {\n        if (Registry.is(\"ide.completion.show.better.matching.classes\")) {\n          result = result.withPrefixMatcher(new BetterPrefixMatcher(result.getPrefixMatcher(), BetterPrefixMatcher.getBestMatchingDegree(plainResults))); \n        }\n        suggestNonImportedClasses(parameters, result);\n      }\n    }\n  }","commit_id":"880e6dbe092294b62cd584f54024625c852292b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Comparable weigh(@NotNull LookupElement element) {\n    final PrefixMatcher matcher = CompletionServiceImpl.getItemMatcher(element, myLocation.getCompletionParameters().getLookup());\n\n    int max = Integer.MIN_VALUE;\n    for (String lookupString : element.getAllLookupStrings()) {\n      max = Math.max(max, matcher.matchingDegree(lookupString));\n    }\n    return -max;\n  }","id":24196,"modified_method":"@Override\n  public Comparable weigh(@NotNull LookupElement element) {\n    return getBestMatchingDegree(element, CompletionServiceImpl.getItemMatcher(element, myLocation.getCompletionParameters().getLookup()));\n  }","commit_id":"880e6dbe092294b62cd584f54024625c852292b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillCompletionVariants(@NotNull final CompletionParameters parameters, @NotNull CompletionResultSet result) {\n    LinkedHashSet<CompletionResult> plainResults = result.runRemainingContributors(parameters, true);\n    final boolean empty = JavaNoVariantsDelegator.containsOnlyPackages(plainResults) || suggestMetaAnnotations(parameters);\n\n    if (!empty && parameters.getInvocationCount() == 0) {\n      result.restartCompletionWhenNothingMatches();\n    }\n\n    if (empty) {\n      delegate(parameters, result);\n    } else if (Registry.is(\"ide.completion.show.better.matching.classes\")) {\n      if (parameters.getCompletionType() == CompletionType.BASIC &&\n          parameters.getInvocationCount() <= 1 &&\n          JavaCompletionContributor.mayStartClassName(result) &&\n          GrMainCompletionProvider.isClassNamePossible(parameters.getPosition()) &&\n          !MapArgumentCompletionProvider.isMapKeyCompletion(parameters) &&\n          !GroovySmartCompletionContributor.AFTER_NEW.accepts(parameters.getPosition())) {\n        result = result.withPrefixMatcher(new BetterPrefixMatcher(result.getPrefixMatcher(), BetterPrefixMatcher.getBestMatchingDegree(plainResults)));\n        suggestNonImportedClasses(parameters, result);\n      }\n    }\n  }","id":24197,"modified_method":"@Override\n  public void fillCompletionVariants(@NotNull final CompletionParameters parameters, @NotNull CompletionResultSet result) {\n    JavaNoVariantsDelegator.ResultTracker tracker = new JavaNoVariantsDelegator.ResultTracker(result);\n    result.runRemainingContributors(parameters, tracker);\n    final boolean empty = tracker.containsOnlyPackages || suggestMetaAnnotations(parameters);\n\n    if (!empty && parameters.getInvocationCount() == 0) {\n      result.restartCompletionWhenNothingMatches();\n    }\n\n    if (empty) {\n      delegate(parameters, result);\n    } else if (Registry.is(\"ide.completion.show.better.matching.classes\")) {\n      if (parameters.getCompletionType() == CompletionType.BASIC &&\n          parameters.getInvocationCount() <= 1 &&\n          JavaCompletionContributor.mayStartClassName(result) &&\n          GrMainCompletionProvider.isClassNamePossible(parameters.getPosition()) &&\n          !MapArgumentCompletionProvider.isMapKeyCompletion(parameters) &&\n          !GroovySmartCompletionContributor.AFTER_NEW.accepts(parameters.getPosition())) {\n        result = result.withPrefixMatcher(tracker.betterMatcher);\n        suggestNonImportedClasses(parameters, result);\n      }\n    }\n  }","commit_id":"493606487a7a0ab74082ba82023d6eae41fb351f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void fillCompletionVariants(@NotNull final CompletionParameters parameters, @NotNull CompletionResultSet result) {\n    LinkedHashSet<CompletionResult> plainResults = result.runRemainingContributors(parameters, true);\n    final boolean empty = containsOnlyPackages(plainResults) || suggestMetaAnnotations(parameters);\n\n    if (!empty && parameters.getInvocationCount() == 0) {\n      result.restartCompletionWhenNothingMatches();\n    }\n\n    InheritorsHolder holder = new InheritorsHolder(parameters.getPosition(), result);\n    for (CompletionResult plainResult : plainResults) {\n      Object o = plainResult.getLookupElement().getObject();\n      if (o instanceof PsiClass) {\n        holder.registerClass((PsiClass)o);\n      }\n    }\n\n    if (empty) {\n      delegate(parameters, JavaCompletionSorting.addJavaSorting(parameters, result), holder);\n    } else if (Registry.is(\"ide.completion.show.better.matching.classes\")) {\n      if (parameters.getCompletionType() == CompletionType.BASIC &&\n          parameters.getInvocationCount() <= 1 &&\n          JavaCompletionContributor.mayStartClassName(result) &&\n          JavaCompletionContributor.isClassNamePossible(parameters) &&\n          !JavaSmartCompletionContributor.AFTER_NEW.accepts(parameters.getPosition())) {\n        result = result.withPrefixMatcher(new BetterPrefixMatcher(result.getPrefixMatcher(), BetterPrefixMatcher.getBestMatchingDegree(plainResults)));\n        for (CompletionResult plainResult : plainResults) {\n          LookupElement element = plainResult.getLookupElement();\n          if (element instanceof TypeArgumentCompletionProvider.TypeArgsLookupElement) {\n            ((TypeArgumentCompletionProvider.TypeArgsLookupElement)element).registerSingleClass(holder);\n          }\n        }\n        suggestNonImportedClasses(parameters, JavaCompletionSorting.addJavaSorting(parameters, result), holder);\n      }\n    }\n  }","id":24198,"modified_method":"@Override\n  public void fillCompletionVariants(@NotNull final CompletionParameters parameters, @NotNull final CompletionResultSet result) {\n    final InheritorsHolder holder = new InheritorsHolder(parameters.getPosition(), result);\n    ResultTracker tracker = new ResultTracker(result) {\n      @Override\n      public void consume(CompletionResult plainResult) {\n        super.consume(plainResult);\n\n        LookupElement element = plainResult.getLookupElement();\n        Object o = element.getObject();\n        if (o instanceof PsiClass) {\n          holder.registerClass((PsiClass)o);\n        }\n        if (element instanceof TypeArgumentCompletionProvider.TypeArgsLookupElement) {\n          ((TypeArgumentCompletionProvider.TypeArgsLookupElement)element).registerSingleClass(holder);\n        }\n      }\n    };\n    result.runRemainingContributors(parameters, tracker);\n    final boolean empty = tracker.containsOnlyPackages || suggestMetaAnnotations(parameters);\n\n    if (!empty && parameters.getInvocationCount() == 0) {\n      result.restartCompletionWhenNothingMatches();\n    }\n\n    if (empty) {\n      delegate(parameters, JavaCompletionSorting.addJavaSorting(parameters, result), holder);\n    } else if (Registry.is(\"ide.completion.show.better.matching.classes\")) {\n      if (parameters.getCompletionType() == CompletionType.BASIC &&\n          parameters.getInvocationCount() <= 1 &&\n          JavaCompletionContributor.mayStartClassName(result) &&\n          JavaCompletionContributor.isClassNamePossible(parameters) &&\n          !JavaSmartCompletionContributor.AFTER_NEW.accepts(parameters.getPosition())) {\n        suggestNonImportedClasses(parameters, JavaCompletionSorting.addJavaSorting(parameters, result.withPrefixMatcher(tracker.betterMatcher)), holder);\n      }\n    }\n  }","commit_id":"493606487a7a0ab74082ba82023d6eae41fb351f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Moves a channel from one position in the layout to another.\n   * @param sourceChannelId the channel to move\n   * @param method either <code>insertBefore<\/code> or <code>appendAfter<\/code>\n   * @param destinationChannelId the ID of the channel to insert the new channel before or append after\n   * @throws Exception\n   */\n  private final void moveChannel(String sourceChannelId, String method, String destinationChannelId) throws Exception\n  {\n    Element layout = userLayout.getDocumentElement();\n\n    Element sourceChannel = userLayout.getElementById(sourceChannelId);\n    Element destinationChannel = userLayout.getElementById(destinationChannelId);\n\n    // Move the source channel before the destination channel or at the end\n    Node targetColumn = destinationChannel.getParentNode();\n    Node siblingChannel = method.equals(\"insertBefore\") ? destinationChannel : null;\n    context.getUserLayoutManager().moveNode(sourceChannel, targetColumn, siblingChannel);\n\n    saveLayout();\n  }","id":24199,"modified_method":"/**\n   * Moves a channel from one position in the layout to another.\n   * @param sourceChannelId the channel to move\n   * @param method either <code>insertBefore<\/code> or <code>appendAfter<\/code>\n   * @param destinationChannelId the ID of the channel to insert the new channel before or append after\n   * @throws Exception\n   */\n  private final void moveChannel(String sourceChannelId, String method, String destinationElementId) throws Exception\n  {\n    Element layout = userLayout.getDocumentElement();\n\n    Element sourceChannel = userLayout.getElementById(sourceChannelId);\n    Element destinationElement = userLayout.getElementById(destinationElementId);\n\n    // The destination element might be an empty tab or a column\n    if (isTab(destinationElement))\n    {\n      // Create a new column in this tab and move the source channel there\n      Element newColumn = createFolder(\"\");\n      Node destinationTab = userLayout.getElementById(destinationElementId);\n      context.getUserLayoutManager().moveNode(newColumn, destinationTab, null);\n      context.getUserLayoutManager().moveNode(sourceChannel, newColumn, null);\n    }\n    else if (isColumn(destinationElement))\n    {\n      // Move the source channel into the destination column\n      context.getUserLayoutManager().moveNode(sourceChannel, destinationElement, null);\n    }\n    else\n    {\n      // Move the source channel before the destination channel or at the end\n      Node targetColumn = destinationElement.getParentNode();\n      Node siblingChannel = method.equals(\"insertBefore\") ? destinationElement : null;\n      context.getUserLayoutManager().moveNode(sourceChannel, targetColumn, siblingChannel);\n    }\n\n    saveLayout();\n  }","commit_id":"d8498f8a41b27b734536a3185386a790969aafc5","url":"https://github.com/Jasig/uPortal"},{"original_method":"public void setRuntimeData (ChannelRuntimeData rd) throws PortalException\n    {\n      runtimeData = rd;\n\n      // If the user hasn't clicked on a tab, get persisted active tab\n      if (activeTab.equals(\"none\"))\n        activeTab = getActiveTab();\n\n      action = runtimeData.getParameter(\"action\");\n\n      if (action != null)\n      {\n        // Select tab\n        if (action.equals(\"selectTab\"))\n          activeTab = runtimeData.getParameter(\"activeTab\");\n        // Set active tab\n        else if (action.equals(\"setActiveTab\"))\n        {\n          try\n          {\n            setActiveTab(activeTab);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageSetActiveTab;\n          }\n        }\n        // Rename tab\n        else if (action.equals(\"renameTab\"))\n        {\n          String tabId = runtimeData.getParameter(\"elementID\");\n          String tabName = runtimeData.getParameter(\"tabName\");\n\n          try\n          {\n            renameTab(tabId, tabName);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageRenameTab;\n          }\n        }\n        // Move tab\n        else if (action.equals(\"moveTab\"))\n        {\n          String methodAndID = runtimeData.getParameter(\"method_ID\");\n          String sourceTabId = runtimeData.getParameter(\"elementID\");\n          int indexOf_ = methodAndID.indexOf(\"_\");\n          String method = methodAndID.substring(0, indexOf_); // insertBefore or appendAfter\n          String destinationTabId = methodAndID.substring(indexOf_ + 1);\n\n          try\n          {\n            moveTab(sourceTabId, method, destinationTabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveTab;\n          }\n        }\n        // Add tab\n        else if (action.equals(\"addTab\"))\n        {\n          String tabName = runtimeData.getParameter(\"tabName\");\n          String methodAndID = runtimeData.getParameter(\"method_ID\");\n          int indexOf_ = methodAndID.indexOf(\"_\");\n          String method = methodAndID.substring(0, indexOf_); // insertBefore or appendAfter\n          String destinationTabId = methodAndID.substring(indexOf_ + 1);\n\n          try\n          {\n            addFolder(tabName, method, destinationTabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageAddTab;\n          }\n        }\n        // Delete tab\n        else if (action.equals(\"deleteTab\"))\n        {\n          String tabId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            deleteElement(tabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteTab;\n          }\n        }\n        // Select column\n        else if (action.equals(\"selectColumn\"))\n          elementID = runtimeData.getParameter(\"elementID\");\n        // Change column width(s)\n        else if (action.equals(\"columnWidth\"))\n        {\n          HashMap columnWidths = new HashMap();\n          Enumeration eParams = runtimeData.getParameterNames();\n          while (eParams.hasMoreElements())\n          {\n            String param = (String)eParams.nextElement();\n            String prefix = \"columnWidth_\";\n\n            if (param.startsWith(prefix))\n            {\n              String folderId = param.substring(prefix.length());\n              String newWidth = runtimeData.getParameter(prefix + folderId);\n              columnWidths.put(folderId, newWidth);\n            }\n          }\n\n          try\n          {\n            changeColumnWidths(columnWidths);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageChangeColumnWidths;\n          }\n        }\n        // Move column\n        else if (action.equals(\"moveColumn\"))\n        {\n          String activeTabParam = runtimeData.getParameter(\"activeTab\");\n          if (activeTabParam != null)\n            activeTab = activeTabParam;\n        }\n        // Move column here\n        else if (action.equals(\"moveColumnHere\"))\n        {\n          String method = runtimeData.getParameter(\"method\");\n          String destinationId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            moveColumn(elementID, method, destinationId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveColumn;\n          }\n        }\n        // New column\n        else if (action.equals(\"newColumn\"))\n        {\n          String columnName = \"\";\n          String method = runtimeData.getParameter(\"method\");\n          elementID = runtimeData.getParameter(\"elementID\");\n          String destinationColumnId = elementID;\n\n          try\n          {\n            addFolder(columnName, method, destinationColumnId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageNewColumn;\n          }\n        }\n        // Add column\n        else if (action.equals(\"addColumn\"))\n        {\n          // Currently not implemented...\n          // We need to assign widths to columns.\n          // The action addColumn isn't in the stylesheet yet.\n        }\n        // Delete column\n        else if (action.equals(\"deleteColumn\"))\n        {\n          String columnId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            deleteElement(columnId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteColumn;\n          }\n        }\n        // Select channel\n        else if (action.equals(\"selectChannel\"))\n        {\n          elementID = runtimeData.getParameter(\"elementID\");\n        }\n        // Move channel\n        else if (action.equals(\"moveChannel\"))\n        {\n          String activeTabParam = runtimeData.getParameter(\"activeTab\");\n          if (activeTabParam != null)\n            activeTab = activeTabParam;\n        }\n        // Move channel here\n        else if (action.equals(\"moveChannelHere\"))\n        {\n          String method = runtimeData.getParameter(\"method\");\n          String destinationId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            moveChannel(elementID, method, destinationId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveChannel;\n          }\n        }\n        // Delete channel\n        else if (action.equals(\"deleteChannel\"))\n        {\n          String channelId = runtimeData.getParameter(\"elementID\");\n\n          try\n          {\n            deleteElement(channelId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteChannel;\n          }\n        }\n       }\n      else\n        action = \"none\";\n    }","id":24200,"modified_method":"public void setRuntimeData (ChannelRuntimeData rd) throws PortalException\n    {\n      runtimeData = rd;\n\n      // If the user hasn't clicked on a tab, get persisted active tab\n      if (activeTab.equals(\"none\"))\n        activeTab = getActiveTab();\n\n      action = runtimeData.getParameter(\"action\");\n\n      if (action != null)\n      {\n        // Select tab\n        if (action.equals(\"selectTab\"))\n          activeTab = runtimeData.getParameter(\"activeTab\");\n        // Set active tab\n        else if (action.equals(\"setActiveTab\"))\n        {\n          try\n          {\n            setActiveTab(activeTab);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageSetActiveTab;\n          }\n        }\n        // Rename tab\n        else if (action.equals(\"renameTab\"))\n        {\n          try\n          {\n            String tabId = runtimeData.getParameter(\"elementID\");\n            String tabName = runtimeData.getParameter(\"tabName\");\n\n            renameTab(tabId, tabName);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageRenameTab;\n          }\n        }\n        // Move tab\n        else if (action.equals(\"moveTab\"))\n        {\n          try\n          {\n            String methodAndID = runtimeData.getParameter(\"method_ID\");\n            String sourceTabId = runtimeData.getParameter(\"elementID\");\n            int indexOf_ = methodAndID.indexOf(\"_\");\n            String method = methodAndID.substring(0, indexOf_); // insertBefore or appendAfter\n            String destinationTabId = methodAndID.substring(indexOf_ + 1);\n\n            moveTab(sourceTabId, method, destinationTabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveTab;\n          }\n        }\n        // Add tab\n        else if (action.equals(\"addTab\"))\n        {\n          try\n          {\n            String tabName = runtimeData.getParameter(\"tabName\");\n            String methodAndID = runtimeData.getParameter(\"method_ID\");\n            int indexOf_ = methodAndID.indexOf(\"_\");\n            String method = methodAndID.substring(0, indexOf_); // insertBefore or appendAfter\n            String destinationTabId = methodAndID.substring(indexOf_ + 1);\n\n            addFolder(tabName, method, destinationTabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageAddTab;\n          }\n        }\n        // Delete tab\n        else if (action.equals(\"deleteTab\"))\n        {\n          try\n          {\n            String tabId = runtimeData.getParameter(\"elementID\");\n\n            deleteElement(tabId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteTab;\n          }\n        }\n        // Select column\n        else if (action.equals(\"selectColumn\"))\n          elementID = runtimeData.getParameter(\"elementID\");\n        // Change column width(s)\n        else if (action.equals(\"columnWidth\"))\n        {\n          try\n          {\n            HashMap columnWidths = new HashMap();\n            Enumeration eParams = runtimeData.getParameterNames();\n            while (eParams.hasMoreElements())\n            {\n              String param = (String)eParams.nextElement();\n              String prefix = \"columnWidth_\";\n\n              if (param.startsWith(prefix))\n              {\n                String folderId = param.substring(prefix.length());\n                String newWidth = runtimeData.getParameter(prefix + folderId);\n                columnWidths.put(folderId, newWidth);\n              }\n            }\n\n            changeColumnWidths(columnWidths);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageChangeColumnWidths;\n          }\n        }\n        // Move column\n        else if (action.equals(\"moveColumn\"))\n        {\n          String activeTabParam = runtimeData.getParameter(\"activeTab\");\n          if (activeTabParam != null)\n            activeTab = activeTabParam;\n        }\n        // Move column here\n        else if (action.equals(\"moveColumnHere\"))\n        {\n          try\n          {\n            String method = runtimeData.getParameter(\"method\");\n            String destinationId = runtimeData.getParameter(\"elementID\");\n\n            moveColumn(elementID, method, destinationId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveColumn;\n          }\n        }\n        // New column\n        else if (action.equals(\"newColumn\"))\n        {\n          try\n          {\n            String columnName = \"\";\n            String method = runtimeData.getParameter(\"method\");\n            elementID = runtimeData.getParameter(\"elementID\");\n            String destinationColumnId = elementID;\n\n            addFolder(columnName, method, destinationColumnId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageNewColumn;\n          }\n        }\n        // Add column\n        else if (action.equals(\"addColumn\"))\n        {\n          // Currently not implemented...\n          // We need to assign widths to columns.\n          // The action addColumn isn't in the stylesheet yet.\n        }\n        // Delete column\n        else if (action.equals(\"deleteColumn\"))\n        {\n          try\n          {\n            String columnId = runtimeData.getParameter(\"elementID\");\n\n            deleteElement(columnId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteColumn;\n          }\n        }\n        // Select channel\n        else if (action.equals(\"selectChannel\"))\n        {\n          elementID = runtimeData.getParameter(\"elementID\");\n        }\n        // Move channel\n        else if (action.equals(\"moveChannel\"))\n        {\n          String activeTabParam = runtimeData.getParameter(\"activeTab\");\n          if (activeTabParam != null)\n            activeTab = activeTabParam;\n        }\n        // Move channel here\n        else if (action.equals(\"moveChannelHere\"))\n        {\n          try\n          {\n            String method = runtimeData.getParameter(\"method\");\n            String destinationId = runtimeData.getParameter(\"elementID\");\n\n            moveChannel(elementID, method, destinationId);\n\n            // Clear out elementId so the channel doesn't stay highlighted\n            elementID = null;\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageMoveChannel;\n          }\n        }\n        // Delete channel\n        else if (action.equals(\"deleteChannel\"))\n        {\n          try\n          {\n            String channelId = runtimeData.getParameter(\"elementID\");\n\n            deleteElement(channelId);\n          }\n          catch (Exception e)\n          {\n            Logger.log(Logger.ERROR, e);\n            action = \"error\";\n            errorMessage = errorMessageDeleteChannel;\n          }\n        }\n       }\n      else\n        action = \"none\";\n    }","commit_id":"d8498f8a41b27b734536a3185386a790969aafc5","url":"https://github.com/Jasig/uPortal"},{"original_method":"protected void writeHeaders(HttpServletResponse response, Resource resource, long count) {\r\n        if (response.getContentType() == null) {\r\n            final String extensionmime;\r\n            if ((extensionmime = _mimeTypes.getMimeByExtension(resource.getName())) != null) {\r\n                response.setContentType(extensionmime);\r\n            }\r\n        }\r\n\r\n        long lml = resource.lastModified();\r\n        if (lml >= 0) {\r\n            response.setDateHeader(HeaderFramework.LAST_MODIFIED, lml);\r\n        }\r\n\r\n        if (count != -1) {\r\n            if (count < Integer.MAX_VALUE) {\r\n                response.setContentLength((int) count);\r\n            } else {\r\n                response.setHeader(HeaderFramework.CONTENT_LENGTH, Long.toString(count));\r\n            }\r\n        }\r\n\r\n        if (_acceptRanges) {\r\n            response.setHeader(HeaderFramework.ACCEPT_RANGES, \"bytes\");\r\n        }\r\n    }","id":24201,"modified_method":"protected void writeHeaders(HttpServletResponse response, Resource resource, long count) {\r\n        if (response.getContentType() == null) {\r\n            final String extensionmime;\r\n            if ((extensionmime = _mimeTypes.getMimeByExtension(resource.getName())) != null) {\r\n                response.setContentType(extensionmime);\r\n            }\r\n        }\r\n        /*\r\n         * DO NOT enable this again, removal of the LAST_MODIFIED field enables caching\r\n        long lml = resource.lastModified();\r\n        if (lml >= 0) {\r\n            response.setDateHeader(HeaderFramework.LAST_MODIFIED, lml);\r\n        }\r\n        */\r\n        \r\n        if (count != -1) {\r\n            if (count < Integer.MAX_VALUE) {\r\n                response.setContentLength((int) count);\r\n            } else {\r\n                response.setHeader(HeaderFramework.CONTENT_LENGTH, Long.toString(count));\r\n            }\r\n        }\r\n\r\n        if (_acceptRanges) {\r\n            response.setHeader(HeaderFramework.ACCEPT_RANGES, \"bytes\");\r\n        }\r\n    }","commit_id":"d8504418b63382aa722aa8dc3cc1e164ee482aed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected void handleTemplate(String target,  HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\r\n        Switchboard sb = Switchboard.getSwitchboard();\r\n\r\n        String localeSelection = sb.getConfig(\"locale.language\", \"default\");\r\n        File targetFile = getLocalizedFile(target, localeSelection);\r\n        File targetClass = rewriteClassFile(_resourceBase.addPath(target).getFile());\r\n        String targetExt = target.substring(target.lastIndexOf('.') + 1);\r\n\r\n        long now = System.currentTimeMillis();\r\n        response.setDateHeader(HeaderFramework.LAST_MODIFIED, now);\r\n        if (target.endsWith(\".css\")) {\r\n            response.setDateHeader(HeaderFramework.EXPIRES, now + 3600000); // expires in 1 hour (which is still often, others use 1 week, month or year)\r\n        } else if (target.endsWith(\".png\")) {\r\n            response.setDateHeader(HeaderFramework.EXPIRES, now + 60000); // expires in 1 minute (reduce heavy image creation load)\r\n        } else {\r\n            response.setDateHeader(HeaderFramework.EXPIRES, now); // expires now\r\n        }\r\n        \r\n        if ((targetClass != null)) {\r\n            serverObjects args = new serverObjects();\r\n            Enumeration<String> argNames = request.getParameterNames();\r\n            while (argNames.hasMoreElements()) {\r\n                String argName = argNames.nextElement();\r\n                // standard attributes are just pushed as string\r\n                args.put(argName, request.getParameter(argName));\r\n            }\r\n            //TODO: for SSI request, local parameters are added as attributes, put them back as parameter for the legacy request\r\n            //      likely this should be implemented via httpservletrequestwrapper to supply complete parameters  \r\n            Enumeration<String> attNames = request.getAttributeNames();\r\n            while (attNames.hasMoreElements()) {\r\n                String argName = attNames.nextElement();\r\n                args.put(argName, request.getAttribute(argName).toString());\r\n            }\r\n            RequestHeader legacyRequestHeader = generateLegacyRequestHeader(request, target, targetExt);\r\n            // add multipart-form fields to parameter\r\n            if (ServletFileUpload.isMultipartContent(request)) {\r\n                final String bodyEncoding = request.getHeader(HeaderFramework.CONTENT_ENCODING);\r\n                if (HeaderFramework.CONTENT_ENCODING_GZIP.equalsIgnoreCase(bodyEncoding)) {\r\n                    parseMultipart(new GZIPRequestWrapper(request),args);\r\n                } else {\r\n                    parseMultipart(request, args);\r\n                }\r\n            }\r\n            // eof modification to read attribute\r\n            Object tmp;\r\n            try {\r\n                if (args.isEmpty()) {\r\n                    // yacy servlets typically test for args != null (but not for args .isEmpty())\r\n                    tmp = invokeServlet(targetClass, legacyRequestHeader, null); \r\n                } else {\r\n                    tmp = invokeServlet(targetClass, legacyRequestHeader, args);\r\n                }\r\n            } catch (InvocationTargetException | IllegalArgumentException | IllegalAccessException e) {\r\n                ConcurrentLog.logException(e);\r\n                throw new ServletException(targetFile.getAbsolutePath());\r\n            }\r\n\r\n            if (tmp instanceof RasterPlotter || tmp instanceof EncodedImage || tmp instanceof Image) {\r\n\r\n                net.yacy.cora.util.ByteBuffer result = null;\r\n\r\n                if (tmp instanceof RasterPlotter) {\r\n                    final RasterPlotter yp = (RasterPlotter) tmp;\r\n                    // send an image to client\r\n                    result = RasterPlotter.exportImage(yp.getImage(), \"png\");\r\n                } else if (tmp instanceof EncodedImage) {\r\n                    final EncodedImage yp = (EncodedImage) tmp;\r\n                    result = yp.getImage();\r\n                    /** When encodedImage is empty, return a code 500 rather than only an empty response \r\n                     * as it is better handled across different browsers */\r\n                    if(result == null || result.length() == 0) {\r\n                    \tresponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\r\n                    \tresult.close();\r\n                    \treturn;\r\n                    }\r\n                    if (yp.isStatic()) { // static image never expires\r\n                        response.setDateHeader(HeaderFramework.EXPIRES, now + 3600000); // expires in 1 hour\r\n                    }\r\n                } else if (tmp instanceof Image) {\r\n                    final Image i = (Image) tmp;\r\n\r\n                    // generate an byte array from the generated image\r\n                    int width = i.getWidth(null);\r\n                    if (width < 0) {\r\n                        width = 96; // bad hack\r\n                    }\r\n                    int height = i.getHeight(null);\r\n                    if (height < 0) {\r\n                        height = 96; // bad hack\r\n                    }\r\n                    final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\r\n                    bi.createGraphics().drawImage(i, 0, 0, width, height, null);\r\n                    result = RasterPlotter.exportImage(bi, targetExt);\r\n                }\r\n\r\n                final String mimeType = Classification.ext2mime(targetExt, MimeTypes.Type.TEXT_HTML.asString());\r\n                response.setContentType(mimeType);\r\n                response.setContentLength(result.length());\r\n                response.setStatus(HttpServletResponse.SC_OK);\r\n\r\n                result.writeTo(response.getOutputStream());\r\n                result.close();\r\n                return;\r\n            }\r\n\r\n            if (tmp instanceof InputStream) {\r\n                writeInputStream(response, targetExt, (InputStream)tmp);\r\n                return;\r\n            }\r\n\r\n            servletProperties templatePatterns;\r\n            if (tmp == null) {\r\n                // if no args given, then tp will be an empty Hashtable object (not null)\r\n                templatePatterns = new servletProperties();\r\n            } else if (tmp instanceof servletProperties) {\r\n                templatePatterns = (servletProperties) tmp;\r\n            } else {\r\n                templatePatterns = new servletProperties((serverObjects) tmp);\r\n            }\r\n     \r\n            // handle YaCy http commands\r\n            // handle action auth: check if the servlets requests authentication\r\n            if (templatePatterns.containsKey(serverObjects.ACTION_AUTHENTICATE)) {\r\n                if (!request.authenticate(response)) {\r\n                    return;\r\n                }\r\n            //handle action forward\r\n            } else if (templatePatterns.containsKey(serverObjects.ACTION_LOCATION)) {\r\n                String location = templatePatterns.get(serverObjects.ACTION_LOCATION, \"\");\r\n\r\n                if (location.isEmpty()) {\r\n                    location = request.getPathInfo();\r\n                }\r\n                //TODO: handle equivalent of this from httpdfilehandler\r\n                // final ResponseHeader headers = getDefaultHeaders(request.getPathInfo());\r\n                // headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\r\n\r\n                response.setHeader(HeaderFramework.LOCATION, location);\r\n                response.setStatus(HttpServletResponse.SC_FOUND);\r\n                return;\r\n            }\r\n\r\n            if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\r\n                \r\n                sb.setConfig(\"server.servlets.called\", appendPath(sb.getConfig(\"server.servlets.called\", \"\"), target));\r\n                if (args != null && !args.isEmpty()) {\r\n                    sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), target));\r\n                }\r\n\r\n                // add the application version, the uptime and the client name to every rewrite table\r\n                templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\r\n                templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() - sb.startupTime) / 1000) / 60); // uptime in minutes\r\n                templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\r\n                templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, sb.peers.myID());\r\n                templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\r\n                Seed myPeer = sb.peers.mySeed();\r\n                templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\r\n                templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\r\n                boolean authorized = sb.adminAuthenticated(legacyRequestHeader) >= 2;\r\n                templatePatterns.put(\"authorized\", authorized ? 1 : 0);\r\n\r\n                templatePatterns.put(\"simpleheadernavbar\", sb.getConfig(\"decoration.simpleheadernavbar\", \"navbar-default\"));\r\n                \r\n                // add navigation keys to enable or disable menu items\r\n                templatePatterns.put(\"navigation-p2p\", sb.getConfigBool(SwitchboardConstants.DHT_ENABLED, true) || !sb.isRobinsonMode() ? 1 : 0);\r\n                templatePatterns.put(\"navigation-p2p_authorized\", authorized ? 1 : 0);\r\n                String submitted = sb.getConfig(\"server.servlets.submitted\", \"\");\r\n                boolean crawler_enabled = true; /*\r\n                        submitted.contains(\"Crawler_p\") ||\r\n                        submitted.contains(\"ConfigBasic\") ||\r\n                        submitted.contains(\"Load_RSS_p\");*/\r\n                boolean advanced_enabled =\r\n                        crawler_enabled ||\r\n                        submitted.contains(\"IndexImportMediawiki_p\") ||\r\n                        submitted.contains(\"CrawlStart\");\r\n                templatePatterns.put(\"navigation-crawlmonitor\", crawler_enabled);\r\n                templatePatterns.put(\"navigation-crawlmonitor_authorized\", authorized ? 1 : 0);\r\n                templatePatterns.put(\"navigation-advanced\", advanced_enabled);\r\n                templatePatterns.put(\"navigation-advanced_authorized\", authorized ? 1 : 0);\r\n                templatePatterns.put(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n                templatePatterns.put(SwitchboardConstants.GREETING_SMALL_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n                \r\n                String mimeType = Classification.ext2mime(targetExt, MimeTypes.Type.TEXT_HTML.asString());\r\n\r\n                InputStream fis;\r\n                long fileSize = targetFile.length();\r\n\r\n                if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\r\n                    // read file completely into ram, avoid that too many files are open at the same time\r\n                    fis = new ByteArrayInputStream(FileUtils.read(targetFile));\r\n                } else {\r\n                    fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                }\r\n\r\n                // set response header\r\n                response.setContentType(mimeType);\r\n                response.setStatus(HttpServletResponse.SC_OK);\r\n                ByteArrayOutputStream bas = new ByteArrayOutputStream(4096);\r\n                // apply templates\r\n                TemplateEngine.writeTemplate(targetFile.getName(), fis, bas, templatePatterns);                \r\n                fis.close();\r\n                // handle SSI\r\n                parseSSI (bas.toByteArray(),request,response);\r\n            }\r\n        }\r\n    }","id":24202,"modified_method":"protected void handleTemplate(String target,  HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\r\n        Switchboard sb = Switchboard.getSwitchboard();\r\n\r\n        String localeSelection = sb.getConfig(\"locale.language\", \"default\");\r\n        File targetFile = getLocalizedFile(target, localeSelection);\r\n        File targetClass = rewriteClassFile(_resourceBase.addPath(target).getFile());\r\n        String targetExt = target.substring(target.lastIndexOf('.') + 1);\r\n\r\n        long now = System.currentTimeMillis();\r\n        if (target.endsWith(\".css\")) {\r\n            response.setDateHeader(HeaderFramework.LAST_MODIFIED, now);\r\n            response.setDateHeader(HeaderFramework.EXPIRES, now + 3600000); // expires in 1 hour (which is still often, others use 1 week, month or year)\r\n        } else if (target.endsWith(\".png\")) {\r\n            // expires in 1 minute (reduce heavy image creation load)\r\n            if (response.containsHeader(HeaderFramework.LAST_MODIFIED)) {\r\n                response.getHeaders(HeaderFramework.LAST_MODIFIED).clear();\r\n            }\r\n            response.setHeader(HeaderFramework.CACHE_CONTROL, \"public, max-age=\" + Integer.toString(60));\r\n        } else {\r\n            response.setDateHeader(HeaderFramework.LAST_MODIFIED, now);\r\n            response.setDateHeader(HeaderFramework.EXPIRES, now); // expires now\r\n        }\r\n        \r\n        if ((targetClass != null)) {\r\n            serverObjects args = new serverObjects();\r\n            Enumeration<String> argNames = request.getParameterNames();\r\n            while (argNames.hasMoreElements()) {\r\n                String argName = argNames.nextElement();\r\n                // standard attributes are just pushed as string\r\n                args.put(argName, request.getParameter(argName));\r\n            }\r\n            //TODO: for SSI request, local parameters are added as attributes, put them back as parameter for the legacy request\r\n            //      likely this should be implemented via httpservletrequestwrapper to supply complete parameters  \r\n            Enumeration<String> attNames = request.getAttributeNames();\r\n            while (attNames.hasMoreElements()) {\r\n                String argName = attNames.nextElement();\r\n                args.put(argName, request.getAttribute(argName).toString());\r\n            }\r\n            RequestHeader legacyRequestHeader = generateLegacyRequestHeader(request, target, targetExt);\r\n            // add multipart-form fields to parameter\r\n            if (ServletFileUpload.isMultipartContent(request)) {\r\n                final String bodyEncoding = request.getHeader(HeaderFramework.CONTENT_ENCODING);\r\n                if (HeaderFramework.CONTENT_ENCODING_GZIP.equalsIgnoreCase(bodyEncoding)) {\r\n                    parseMultipart(new GZIPRequestWrapper(request),args);\r\n                } else {\r\n                    parseMultipart(request, args);\r\n                }\r\n            }\r\n            // eof modification to read attribute\r\n            Object tmp;\r\n            try {\r\n                if (args.isEmpty()) {\r\n                    // yacy servlets typically test for args != null (but not for args .isEmpty())\r\n                    tmp = invokeServlet(targetClass, legacyRequestHeader, null); \r\n                } else {\r\n                    tmp = invokeServlet(targetClass, legacyRequestHeader, args);\r\n                }\r\n            } catch (InvocationTargetException | IllegalArgumentException | IllegalAccessException e) {\r\n                ConcurrentLog.logException(e);\r\n                throw new ServletException(targetFile.getAbsolutePath());\r\n            }\r\n\r\n            if (tmp instanceof RasterPlotter || tmp instanceof EncodedImage || tmp instanceof Image) {\r\n\r\n                net.yacy.cora.util.ByteBuffer result = null;\r\n\r\n                if (tmp instanceof RasterPlotter) {\r\n                    final RasterPlotter yp = (RasterPlotter) tmp;\r\n                    // send an image to client\r\n                    result = RasterPlotter.exportImage(yp.getImage(), \"png\");\r\n                } else if (tmp instanceof EncodedImage) {\r\n                    final EncodedImage yp = (EncodedImage) tmp;\r\n                    result = yp.getImage();\r\n                    /** When encodedImage is empty, return a code 500 rather than only an empty response \r\n                     * as it is better handled across different browsers */\r\n                    if(result == null || result.length() == 0) {\r\n                    \tresponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\r\n                    \tresult.close();\r\n                    \treturn;\r\n                    }\r\n                    if (yp.isStatic()) { // static image never expires\r\n                        response.setDateHeader(HeaderFramework.EXPIRES, now + 3600000); // expires in 1 hour\r\n                    }\r\n                } else if (tmp instanceof Image) {\r\n                    final Image i = (Image) tmp;\r\n\r\n                    // generate an byte array from the generated image\r\n                    int width = i.getWidth(null);\r\n                    if (width < 0) {\r\n                        width = 96; // bad hack\r\n                    }\r\n                    int height = i.getHeight(null);\r\n                    if (height < 0) {\r\n                        height = 96; // bad hack\r\n                    }\r\n                    final BufferedImage bi = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\r\n                    bi.createGraphics().drawImage(i, 0, 0, width, height, null);\r\n                    result = RasterPlotter.exportImage(bi, targetExt);\r\n                }\r\n\r\n                final String mimeType = Classification.ext2mime(targetExt, MimeTypes.Type.TEXT_HTML.asString());\r\n                response.setContentType(mimeType);\r\n                response.setContentLength(result.length());\r\n                response.setStatus(HttpServletResponse.SC_OK);\r\n\r\n                result.writeTo(response.getOutputStream());\r\n                result.close();\r\n                return;\r\n            }\r\n\r\n            if (tmp instanceof InputStream) {\r\n                writeInputStream(response, targetExt, (InputStream)tmp);\r\n                return;\r\n            }\r\n\r\n            servletProperties templatePatterns;\r\n            if (tmp == null) {\r\n                // if no args given, then tp will be an empty Hashtable object (not null)\r\n                templatePatterns = new servletProperties();\r\n            } else if (tmp instanceof servletProperties) {\r\n                templatePatterns = (servletProperties) tmp;\r\n            } else {\r\n                templatePatterns = new servletProperties((serverObjects) tmp);\r\n            }\r\n     \r\n            // handle YaCy http commands\r\n            // handle action auth: check if the servlets requests authentication\r\n            if (templatePatterns.containsKey(serverObjects.ACTION_AUTHENTICATE)) {\r\n                if (!request.authenticate(response)) {\r\n                    return;\r\n                }\r\n            //handle action forward\r\n            } else if (templatePatterns.containsKey(serverObjects.ACTION_LOCATION)) {\r\n                String location = templatePatterns.get(serverObjects.ACTION_LOCATION, \"\");\r\n\r\n                if (location.isEmpty()) {\r\n                    location = request.getPathInfo();\r\n                }\r\n                //TODO: handle equivalent of this from httpdfilehandler\r\n                // final ResponseHeader headers = getDefaultHeaders(request.getPathInfo());\r\n                // headers.setAdditionalHeaderProperties(templatePatterns.getOutgoingHeader().getAdditionalHeaderProperties()); //put the cookies into the new header TODO: can we put all headerlines, without trouble?\r\n\r\n                response.setHeader(HeaderFramework.LOCATION, location);\r\n                response.setStatus(HttpServletResponse.SC_FOUND);\r\n                return;\r\n            }\r\n\r\n            if (targetFile.exists() && targetFile.isFile() && targetFile.canRead()) {\r\n                \r\n                sb.setConfig(\"server.servlets.called\", appendPath(sb.getConfig(\"server.servlets.called\", \"\"), target));\r\n                if (args != null && !args.isEmpty()) {\r\n                    sb.setConfig(\"server.servlets.submitted\", appendPath(sb.getConfig(\"server.servlets.submitted\", \"\"), target));\r\n                }\r\n\r\n                // add the application version, the uptime and the client name to every rewrite table\r\n                templatePatterns.put(servletProperties.PEER_STAT_VERSION, yacyBuildProperties.getVersion());\r\n                templatePatterns.put(servletProperties.PEER_STAT_UPTIME, ((System.currentTimeMillis() - sb.startupTime) / 1000) / 60); // uptime in minutes\r\n                templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTNAME, sb.peers.mySeed().getName());\r\n                templatePatterns.putHTML(servletProperties.PEER_STAT_CLIENTID, sb.peers.myID());\r\n                templatePatterns.put(servletProperties.PEER_STAT_MYTIME, GenericFormatter.SHORT_SECOND_FORMATTER.format());\r\n                Seed myPeer = sb.peers.mySeed();\r\n                templatePatterns.put(\"newpeer\", myPeer.getAge() >= 1 ? 0 : 1);\r\n                templatePatterns.putHTML(\"newpeer_peerhash\", myPeer.hash);\r\n                boolean authorized = sb.adminAuthenticated(legacyRequestHeader) >= 2;\r\n                templatePatterns.put(\"authorized\", authorized ? 1 : 0);\r\n\r\n                templatePatterns.put(\"simpleheadernavbar\", sb.getConfig(\"decoration.simpleheadernavbar\", \"navbar-default\"));\r\n                \r\n                // add navigation keys to enable or disable menu items\r\n                templatePatterns.put(\"navigation-p2p\", sb.getConfigBool(SwitchboardConstants.DHT_ENABLED, true) || !sb.isRobinsonMode() ? 1 : 0);\r\n                templatePatterns.put(\"navigation-p2p_authorized\", authorized ? 1 : 0);\r\n                String submitted = sb.getConfig(\"server.servlets.submitted\", \"\");\r\n                boolean crawler_enabled = true; /*\r\n                        submitted.contains(\"Crawler_p\") ||\r\n                        submitted.contains(\"ConfigBasic\") ||\r\n                        submitted.contains(\"Load_RSS_p\");*/\r\n                boolean advanced_enabled =\r\n                        crawler_enabled ||\r\n                        submitted.contains(\"IndexImportMediawiki_p\") ||\r\n                        submitted.contains(\"CrawlStart\");\r\n                templatePatterns.put(\"navigation-crawlmonitor\", crawler_enabled);\r\n                templatePatterns.put(\"navigation-crawlmonitor_authorized\", authorized ? 1 : 0);\r\n                templatePatterns.put(\"navigation-advanced\", advanced_enabled);\r\n                templatePatterns.put(\"navigation-advanced_authorized\", authorized ? 1 : 0);\r\n                templatePatterns.put(SwitchboardConstants.GREETING_HOMEPAGE, sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n                templatePatterns.put(SwitchboardConstants.GREETING_SMALL_IMAGE, sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n                \r\n                String mimeType = Classification.ext2mime(targetExt, MimeTypes.Type.TEXT_HTML.asString());\r\n\r\n                InputStream fis;\r\n                long fileSize = targetFile.length();\r\n\r\n                if (fileSize <= Math.min(4 * 1024 * 1204, MemoryControl.available() / 100)) {\r\n                    // read file completely into ram, avoid that too many files are open at the same time\r\n                    fis = new ByteArrayInputStream(FileUtils.read(targetFile));\r\n                } else {\r\n                    fis = new BufferedInputStream(new FileInputStream(targetFile));\r\n                }\r\n\r\n                // set response header\r\n                response.setContentType(mimeType);\r\n                response.setStatus(HttpServletResponse.SC_OK);\r\n                ByteArrayOutputStream bas = new ByteArrayOutputStream(4096);\r\n                // apply templates\r\n                TemplateEngine.writeTemplate(targetFile.getName(), fis, bas, templatePatterns);                \r\n                fis.close();\r\n                // handle SSI\r\n                parseSSI (bas.toByteArray(),request,response);\r\n            }\r\n        }\r\n    }","commit_id":"d8504418b63382aa722aa8dc3cc1e164ee482aed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n     * send static content\r\n     * \r\n     * @param request\r\n     * @param response\r\n     * @param include  is a include file (send without changing/adding headers)\r\n     * @param resource the static content\r\n     * @param reqRanges\r\n     * @throws IOException \r\n     */\r\n    protected void sendData(HttpServletRequest request,\r\n            HttpServletResponse response,\r\n            boolean include,\r\n            Resource resource,\r\n            Enumeration<String> reqRanges)\r\n            throws IOException {\r\n\r\n        final long content_length = resource.length();\r\n\r\n        // Get the output stream (or writer)\r\n        OutputStream out;\r\n        try {\r\n            out = response.getOutputStream();\r\n        } catch (IllegalStateException e) {\r\n            out = new WriterOutputStream(response.getWriter());\r\n        }\r\n\r\n        response.setDateHeader(HeaderFramework.EXPIRES, System.currentTimeMillis() + 600000); // expires ten minutes in the future\r\n        response.setDateHeader(HeaderFramework.LAST_MODIFIED, resource.lastModified());\r\n        \r\n        if (reqRanges == null || !reqRanges.hasMoreElements() || content_length < 0) {\r\n            //  if there were no ranges, send entire entity\r\n            if (include) {\r\n                resource.writeTo(out, 0, content_length);\r\n            } else {\r\n                writeHeaders(response, resource, content_length);\r\n                resource.writeTo(out, 0, content_length);\r\n            }\r\n        } else {\r\n            // Parse the satisfiable ranges\r\n            List<?> ranges = InclusiveByteRange.satisfiableRanges(reqRanges, content_length);\r\n\r\n            //  if there are no satisfiable ranges, send 416 response\r\n            if (ranges == null || ranges.isEmpty()) {\r\n                writeHeaders(response, resource, content_length);\r\n                response.setStatus(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\r\n                response.setHeader(HttpHeader.CONTENT_RANGE.asString(),\r\n                        InclusiveByteRange.to416HeaderRangeString(content_length));\r\n                resource.writeTo(out, 0, content_length);\r\n                out.close();\r\n                return;\r\n            }\r\n\r\n            //  if there is only a single valid range (must be satisfiable\r\n            //  since were here now), send that range with a 216 response\r\n            if (ranges.size() == 1) {\r\n                InclusiveByteRange singleSatisfiableRange =\r\n                        (InclusiveByteRange) ranges.get(0);\r\n                long singleLength = singleSatisfiableRange.getSize(content_length);\r\n                writeHeaders(response, resource, singleLength);\r\n                response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\r\n                response.setHeader(HttpHeader.CONTENT_RANGE.asString(),\r\n                        singleSatisfiableRange.toHeaderRangeString(content_length));\r\n                resource.writeTo(out, singleSatisfiableRange.getFirst(content_length), singleLength);\r\n                out.close();\r\n                return;\r\n            }\r\n\r\n            //  multiple non-overlapping valid ranges cause a multipart\r\n            //  216 response which does not require an overall\r\n            //  content-length header\r\n            //\r\n            writeHeaders(response, resource, -1);\r\n            String mimetype = response.getContentType();\r\n            if (mimetype == null) {\r\n                ConcurrentLog.warn(\"FILEHANDLER\",\"YaCyDefaultServlet: Unknown mimetype for \" + request.getRequestURI());\r\n            }\r\n            MultiPartOutputStream multi = new MultiPartOutputStream(out);\r\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\r\n\r\n            // If the request has a \"Request-Range\" header then we need to\r\n            // send an old style multipart/x-byteranges Content-Type. This\r\n            // keeps Netscape and acrobat happy. This is what Apache does.\r\n            String ctp;\r\n            if (request.getHeader(HttpHeader.REQUEST_RANGE.asString()) != null) {\r\n                ctp = \"multipart/x-byteranges; boundary=\";\r\n            } else {\r\n                ctp = \"multipart/byteranges; boundary=\";\r\n            }\r\n            response.setContentType(ctp + multi.getBoundary());\r\n\r\n            InputStream in = resource.getInputStream();\r\n            long pos = 0;\r\n\r\n            // calculate the content-length\r\n            int length = 0;\r\n            String[] header = new String[ranges.size()];\r\n            for (int i = 0; i < ranges.size(); i++) {\r\n                InclusiveByteRange ibr = (InclusiveByteRange) ranges.get(i);\r\n                header[i] = ibr.toHeaderRangeString(content_length);\r\n                length +=\r\n                        ((i > 0) ? 2 : 0)\r\n                        + 2 + multi.getBoundary().length() + 2\r\n                        + (mimetype == null ? 0 : HeaderFramework.CONTENT_TYPE.length() + 2 + mimetype.length()) + 2\r\n                        + HeaderFramework.CONTENT_RANGE.length() + 2 + header[i].length() + 2\r\n                        + 2\r\n                        + (ibr.getLast(content_length) - ibr.getFirst(content_length)) + 1;\r\n            }\r\n            length += 2 + 2 + multi.getBoundary().length() + 2 + 2;\r\n            response.setContentLength(length);\r\n\r\n            for (int i = 0; i < ranges.size(); i++) {\r\n                InclusiveByteRange ibr = (InclusiveByteRange) ranges.get(i);\r\n                multi.startPart(mimetype, new String[]{HeaderFramework.CONTENT_RANGE + \": \" + header[i]});\r\n\r\n                long start = ibr.getFirst(content_length);\r\n                long size = ibr.getSize(content_length);\r\n                if (in != null) {\r\n                    // Handle non cached resource\r\n                    if (start < pos) {\r\n                        in.close();\r\n                        in = resource.getInputStream();\r\n                        pos = 0;\r\n                    }\r\n                    if (pos < start) {\r\n                        in.skip(start - pos);\r\n                        pos = start;\r\n                    }\r\n\r\n                    FileUtils.copy(in, multi, size);\r\n                    pos += size;\r\n                } else // Handle cached resource\r\n                {\r\n                    (resource).writeTo(multi, start, size);\r\n                }\r\n\r\n            }\r\n            if (in != null) in.close();\r\n            multi.close();\r\n        }\r\n    }","id":24203,"modified_method":"/**\r\n     * send static content\r\n     * \r\n     * @param request\r\n     * @param response\r\n     * @param include  is a include file (send without changing/adding headers)\r\n     * @param resource the static content\r\n     * @param reqRanges\r\n     * @throws IOException \r\n     */\r\n    protected void sendData(HttpServletRequest request,\r\n            HttpServletResponse response,\r\n            boolean include,\r\n            Resource resource,\r\n            Enumeration<String> reqRanges)\r\n            throws IOException {\r\n\r\n        final long content_length = resource.length();\r\n\r\n        // Get the output stream (or writer)\r\n        OutputStream out;\r\n        try {\r\n            out = response.getOutputStream();\r\n        } catch (IllegalStateException e) {\r\n            out = new WriterOutputStream(response.getWriter());\r\n        }\r\n\r\n        // remove the last-modified field since caching otherwise does not work\r\n        /*\r\n           https://www.ietf.org/rfc/rfc2616.txt\r\n           \"if the response does have a Last-Modified time, the heuristic\r\n           expiration value SHOULD be no more than some fraction of the interval\r\n           since that time. A typical setting of this fraction might be 10%.\"\r\n        */\r\n        if (response.containsHeader(HeaderFramework.LAST_MODIFIED)) {\r\n            response.getHeaders(HeaderFramework.LAST_MODIFIED).clear(); // if this field is present, the reload-time is a 10% fraction of ttl and other caching headers do not work\r\n        }\r\n\r\n        // cache-control: allow shared caching (i.e. proxies) and set expires age for cache\r\n        response.setHeader(HeaderFramework.CACHE_CONTROL, \"public, max-age=\" + Integer.toString(600)); // seconds; ten minutes\r\n        \r\n        if (reqRanges == null || !reqRanges.hasMoreElements() || content_length < 0) {\r\n            //  if there were no ranges, send entire entity\r\n            if (include) {\r\n                resource.writeTo(out, 0, content_length);\r\n            } else {\r\n                writeHeaders(response, resource, content_length);\r\n                resource.writeTo(out, 0, content_length);\r\n            }\r\n        } else {\r\n            // Parse the satisfiable ranges\r\n            List<?> ranges = InclusiveByteRange.satisfiableRanges(reqRanges, content_length);\r\n\r\n            //  if there are no satisfiable ranges, send 416 response\r\n            if (ranges == null || ranges.isEmpty()) {\r\n                writeHeaders(response, resource, content_length);\r\n                response.setStatus(HttpServletResponse.SC_REQUESTED_RANGE_NOT_SATISFIABLE);\r\n                response.setHeader(HttpHeader.CONTENT_RANGE.asString(),\r\n                        InclusiveByteRange.to416HeaderRangeString(content_length));\r\n                resource.writeTo(out, 0, content_length);\r\n                out.close();\r\n                return;\r\n            }\r\n\r\n            //  if there is only a single valid range (must be satisfiable\r\n            //  since were here now), send that range with a 216 response\r\n            if (ranges.size() == 1) {\r\n                InclusiveByteRange singleSatisfiableRange =\r\n                        (InclusiveByteRange) ranges.get(0);\r\n                long singleLength = singleSatisfiableRange.getSize(content_length);\r\n                writeHeaders(response, resource, singleLength);\r\n                response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\r\n                response.setHeader(HttpHeader.CONTENT_RANGE.asString(),\r\n                        singleSatisfiableRange.toHeaderRangeString(content_length));\r\n                resource.writeTo(out, singleSatisfiableRange.getFirst(content_length), singleLength);\r\n                out.close();\r\n                return;\r\n            }\r\n\r\n            //  multiple non-overlapping valid ranges cause a multipart\r\n            //  216 response which does not require an overall\r\n            //  content-length header\r\n            //\r\n            writeHeaders(response, resource, -1);\r\n            String mimetype = response.getContentType();\r\n            if (mimetype == null) {\r\n                ConcurrentLog.warn(\"FILEHANDLER\",\"YaCyDefaultServlet: Unknown mimetype for \" + request.getRequestURI());\r\n            }\r\n            MultiPartOutputStream multi = new MultiPartOutputStream(out);\r\n            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\r\n\r\n            // If the request has a \"Request-Range\" header then we need to\r\n            // send an old style multipart/x-byteranges Content-Type. This\r\n            // keeps Netscape and acrobat happy. This is what Apache does.\r\n            String ctp;\r\n            if (request.getHeader(HttpHeader.REQUEST_RANGE.asString()) != null) {\r\n                ctp = \"multipart/x-byteranges; boundary=\";\r\n            } else {\r\n                ctp = \"multipart/byteranges; boundary=\";\r\n            }\r\n            response.setContentType(ctp + multi.getBoundary());\r\n\r\n            InputStream in = resource.getInputStream();\r\n            long pos = 0;\r\n\r\n            // calculate the content-length\r\n            int length = 0;\r\n            String[] header = new String[ranges.size()];\r\n            for (int i = 0; i < ranges.size(); i++) {\r\n                InclusiveByteRange ibr = (InclusiveByteRange) ranges.get(i);\r\n                header[i] = ibr.toHeaderRangeString(content_length);\r\n                length +=\r\n                        ((i > 0) ? 2 : 0)\r\n                        + 2 + multi.getBoundary().length() + 2\r\n                        + (mimetype == null ? 0 : HeaderFramework.CONTENT_TYPE.length() + 2 + mimetype.length()) + 2\r\n                        + HeaderFramework.CONTENT_RANGE.length() + 2 + header[i].length() + 2\r\n                        + 2\r\n                        + (ibr.getLast(content_length) - ibr.getFirst(content_length)) + 1;\r\n            }\r\n            length += 2 + 2 + multi.getBoundary().length() + 2 + 2;\r\n            response.setContentLength(length);\r\n\r\n            for (int i = 0; i < ranges.size(); i++) {\r\n                InclusiveByteRange ibr = (InclusiveByteRange) ranges.get(i);\r\n                multi.startPart(mimetype, new String[]{HeaderFramework.CONTENT_RANGE + \": \" + header[i]});\r\n\r\n                long start = ibr.getFirst(content_length);\r\n                long size = ibr.getSize(content_length);\r\n                if (in != null) {\r\n                    // Handle non cached resource\r\n                    if (start < pos) {\r\n                        in.close();\r\n                        in = resource.getInputStream();\r\n                        pos = 0;\r\n                    }\r\n                    if (pos < start) {\r\n                        in.skip(start - pos);\r\n                        pos = start;\r\n                    }\r\n\r\n                    FileUtils.copy(in, multi, size);\r\n                    pos += size;\r\n                } else // Handle cached resource\r\n                {\r\n                    (resource).writeTo(multi, start, size);\r\n                }\r\n\r\n            }\r\n            if (in != null) in.close();\r\n            multi.close();\r\n        }\r\n    }","commit_id":"d8504418b63382aa722aa8dc3cc1e164ee482aed","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private boolean shouldBrowserUseCachedContent(ResourceReference reference)\n    {\n        // If the request contains a \"If-Modified-Since\" and the referenced resource is not supposed to be evaluated\n        // (i.e. no Velocity code) then return a 304 so to tell the browser to use its cached version.\n        Request request = this.container.getRequest();\n        if (request instanceof ServletRequest && !shouldEvaluateResource(reference)) {\n            HttpServletRequest httpRequest = ((ServletRequest) request).getHttpServletRequest();\n            if (httpRequest.getHeader(\"If-Modified-Since\") != null) {\n                // Return the 304\n                Response response = this.container.getResponse();\n                if (response instanceof ServletResponse) {\n                    HttpServletResponse httpResponse = ((ServletResponse) response).getHttpServletResponse();\n                    httpResponse.setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }","id":24204,"modified_method":"/**\n     * @param resourceReference a reference to a WebJar resource\n     * @return {@code true} if the referenced resource is static and is cached by the browser, {@code false} if the\n     *         browser should discard the cached version and use the new version from this response\n     */\n    private boolean shouldBrowserUseCachedContent(ResourceReference resourceReference)\n    {\n        // If the request contains an \"If-Modified-Since\" header and the referenced resource is not supposed to be\n        // evaluated (i.e. no Velocity code) then return a 304 so to tell the browser to use its cached version.\n        Request request = this.container.getRequest();\n        if (request instanceof ServletRequest && !shouldEvaluateResource(resourceReference)) {\n            // This is a request for a static resource from a WebJar.\n            if (((ServletRequest) request).getHttpServletRequest().getHeader(\"If-Modified-Since\") != null) {\n                // The user probably used F5 to reload the page and the browser checks if there are changes.\n                Response response = this.container.getResponse();\n                if (response instanceof ServletResponse) {\n                    // Return the 304 Not Modified. Static WebJar resources don't change if their path doesn't change\n                    // (and the WebJar version is included in the path).\n                    ((ServletResponse) response).getHttpServletResponse()\n                        .setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }","commit_id":"867eaa7fd94894cb31db97be581d288249aa0b84","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private void setResponseHeaders(Response response, ResourceReference reference)\n    {\n        // If the resource contains Velocity code then this code must be evaluated on each request and so the resource\n        // must not be cached. Otherwise, if the resource is static we need to send back the \"Last-Modified\" header in\n        // the response so that the browser will send us an \"If-Modified-Since\" request for any subsequent call for this\n        // static resource. When this happens we return a 304 to tell the browser to use its cached version.\n        if (response instanceof ServletResponse && !shouldEvaluateResource(reference)) {\n            HttpServletResponse httpResponse = ((ServletResponse) response).getHttpServletResponse();\n            httpResponse.setDateHeader(\"Last-Modified\", new Date().getTime() / 1000 * 1000);\n        }\n    }","id":24205,"modified_method":"/**\n     * Sets the response headers needed to cache the resource permanently, if the resource is static.\n     * \n     * @param response the response\n     * @param reference the resource that is being served\n     */\n    private void setResponseHeaders(Response response, ResourceReference reference)\n    {\n        // If the resource contains Velocity code then this code must be evaluated on each request and so the resource\n        // must not be cached. Otherwise, if the resource is static we can cache it permanently because the resource\n        // version is included in the URL.\n        if (response instanceof ServletResponse && !shouldEvaluateResource(reference)) {\n            HttpServletResponse httpResponse = ((ServletResponse) response).getHttpServletResponse();\n            httpResponse.setHeader(HttpHeaders.CACHE_CONTROL, \"public\");\n            httpResponse.setDateHeader(HttpHeaders.EXPIRES, new Date().getTime() + CACHE_DURATION);\n            // Even if the resource is cached permanently, most browsers are still sending a request if the user reloads\n            // the page using F5. We send back the \"Last-Modified\" header in the response so that the browser will send\n            // us an \"If-Modified-Since\" request for any subsequent call for this static resource. When this happens we\n            // return a 304 to tell the browser to use its cached version.\n            httpResponse.setDateHeader(HttpHeaders.LAST_MODIFIED, new Date().getTime());\n        }\n    }","commit_id":"867eaa7fd94894cb31db97be581d288249aa0b84","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"private InputStream evaluate(String resourceName, InputStream resourceStream)\n        throws ResourceReferenceHandlerException\n    {\n        try {\n            StringWriter writer = new StringWriter();\n            this.velocityManager.getVelocityEngine().evaluate(this.velocityManager.getVelocityContext(), writer,\n                resourceName, new InputStreamReader(resourceStream, UTF8));\n            return new ByteArrayInputStream(writer.toString().getBytes(UTF8));\n        } catch (Exception e) {\n            throw new ResourceReferenceHandlerException(\"Faild to evaluate the Velocity code from WebJar resource [\"\n                + resourceName + \"]\", e);\n        }\n    }","id":24206,"modified_method":"/**\n     * Evaluates the given resource using Velocity.\n     * \n     * @param resourceName the resource name, useful for debugging in case the evaluation fails\n     * @param resourceStream the resource stream used to read the resource from the WebJar\n     * @return the result of the evaluation\n     * @throws ResourceReferenceHandlerException if the evaluation fails\n     */\n    private InputStream evaluate(String resourceName, InputStream resourceStream)\n        throws ResourceReferenceHandlerException\n    {\n        try {\n            StringWriter writer = new StringWriter();\n            this.velocityManager.getVelocityEngine().evaluate(this.velocityManager.getVelocityContext(), writer,\n                resourceName, new InputStreamReader(resourceStream, UTF8));\n            return new ByteArrayInputStream(writer.toString().getBytes(UTF8));\n        } catch (Exception e) {\n            throw new ResourceReferenceHandlerException(\"Faild to evaluate the Velocity code from WebJar resource [\"\n                + resourceName + \"]\", e);\n        }\n    }","commit_id":"867eaa7fd94894cb31db97be581d288249aa0b84","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void handle(ResourceReference reference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        if (!shouldBrowserUseCachedContent(reference)) {\n            String resourceName = reference.getParameterValue(\"value\");\n            String resourcePath = String.format(\"%s%s\", WEBJARS_RESOURCE_PREFIX, resourceName);\n\n            InputStream resourceStream = getClassLoader().getResourceAsStream(resourcePath);\n\n            if (resourceStream != null) {\n                if (shouldEvaluateResource(reference)) {\n                    resourceStream = evaluate(resourceName, resourceStream);\n                }\n                \n                // Make sure the resource stream supports mark & reset which is needed in order be able to detect the\n                // content type without affecting the stream (Tika may need to read a few bytes from the start of the\n                // stream, in which case it will mark & reset the stream).\n                if (!resourceStream.markSupported()) {\n                    resourceStream = new BufferedInputStream(resourceStream);\n                }\n\n                try {\n                    Response response = this.container.getResponse();\n                    setResponseHeaders(response, reference);\n                    response.setContentType(tika.detect(resourceStream, resourceName));\n                    IOUtils.copy(resourceStream, this.container.getResponse().getOutputStream());\n                } catch (Exception e) {\n                    throw new ResourceReferenceHandlerException(\n                        String.format(\"Failed to read resource [%s]\", resourceName), e);\n                } finally {\n                    IOUtils.closeQuietly(resourceStream);\n                }\n            }\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority Handler has something to do for this\n        // Resource Reference.\n        chain.handleNext(reference);\n    }","id":24207,"modified_method":"@Override\n    public void handle(ResourceReference resourceReference, ResourceReferenceHandlerChain chain)\n        throws ResourceReferenceHandlerException\n    {\n        if (!shouldBrowserUseCachedContent(resourceReference)) {\n            // If we get here then either the resource is not cached by the browser or the resource is dynamic.\n            InputStream resourceStream = getResourceStream(resourceReference);\n\n            if (resourceStream != null) {\n                try {\n                    serveResource(resourceReference, resourceStream);\n                } catch (ResourceReferenceHandlerException e) {\n                    this.logger.error(e.getMessage(), e);\n                    sendError(HttpStatus.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n                }\n            } else {\n                sendError(HttpStatus.SC_NOT_FOUND, \"Resource not found [%s].\", getResourceName(resourceReference));\n            }\n        }\n\n        // Be a good citizen, continue the chain, in case some lower-priority Handler has something to do for this\n        // Resource Reference.\n        chain.handleNext(resourceReference);\n    }","commit_id":"867eaa7fd94894cb31db97be581d288249aa0b84","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void executeWhenResourceExists() throws Exception\n    {\n        EntityResourceReference reference = new EntityResourceReference(new DocumentReference(\"wiki\", \"space\", \"page\"),\n            EntityResourceAction.VIEW);\n        reference.addParameter(\"value\", \"angular/2.1.11/angular.js\");\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        TestableWebJarsResourceReferenceHandler handler = this.componentManager.getComponentUnderTest();\n\n        ClassLoader classLoader = mock(ClassLoader.class);\n        ByteArrayInputStream bais = new ByteArrayInputStream(\"content\".getBytes());\n        when(classLoader.getResourceAsStream(\"META-INF/resources/webjars/angular/2.1.11/angular.js\")).thenReturn(\n            bais);\n\n        Container container = this.componentManager.getInstance(Container.class);\n        ServletResponse response = mock(ServletResponse.class);\n        HttpServletResponse httpResponse = mock(HttpServletResponse.class);\n        when(response.getHttpServletResponse()).thenReturn(httpResponse);\n        when(container.getResponse()).thenReturn(response);\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        when(response.getOutputStream()).thenReturn(baos);\n        handler.setClassLoader(classLoader);\n\n        handler.handle(reference, chain);\n\n        // Verify that the resource content has been copied to the Response output stream.\n        assertEquals(\"content\", baos.toString());\n        // Verify that the correct Content Type has been set.\n        verify(response).setContentType(\"application/javascript\");\n\n        // Also verify that the \"Last-Modified\" header has been set in the response so that the browser will send\n        // an If-Modified-Since header for the next request and we can tell it to use its cache.\n        verify(httpResponse).setDateHeader(eq(\"Last-Modified\"), anyLong());\n    }","id":24208,"modified_method":"@Test\n    public void executeWhenResourceExists() throws Exception\n    {\n        this.reference.addParameter(\"value\", \"angular/2.1.11/angular.js\");\n\n        ByteArrayInputStream resourceStream = new ByteArrayInputStream(\"content\".getBytes());\n        when(this.classLoader.getResourceAsStream(\"META-INF/resources/webjars/angular/2.1.11/angular.js\")).thenReturn(\n            resourceStream);\n\n        Long now = new Date().getTime();\n        this.handler.handle(this.reference, this.chain);\n\n        // Verify that the resource content has been copied to the Response output stream.\n        assertEquals(\"content\", this.response.getOutputStream().toString());\n        // Verify that the correct Content Type has been set.\n        verify(this.response).setContentType(\"application/javascript\");\n\n        // Verify that the static resource is cached permanently.\n        verify(this.response.getHttpServletResponse()).setHeader(\"Cache-Control\", \"public\");\n        ArgumentCaptor<Long> expireDate = ArgumentCaptor.forClass(Long.class);\n        verify(this.response.getHttpServletResponse()).setDateHeader(eq(\"Expires\"), expireDate.capture());\n        // The expiration date should be in one year from now.\n        assertTrue(expireDate.getValue() >= (now + 365 * 24 * 3600 * 1000L));\n\n        // Also verify that the \"Last-Modified\" header has been set in the response so that the browser will send\n        // an If-Modified-Since header for the next request and we can tell it to use its cache.\n        verify(this.response.getHttpServletResponse()).setDateHeader(eq(\"Last-Modified\"), anyLong());\n\n        verify(this.chain).handleNext(this.reference);\n    }","commit_id":"867eaa7fd94894cb31db97be581d288249aa0b84","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void return304WhenIfModifiedSinceHeader() throws Exception\n    {\n        EntityResourceReference reference = new EntityResourceReference(new DocumentReference(\"wiki\", \"space\", \"page\"),\n            EntityResourceAction.VIEW);\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        TestableWebJarsResourceReferenceHandler handler = this.componentManager.getComponentUnderTest();\n\n        Container container = this.componentManager.getInstance(Container.class);\n\n        ServletResponse response = mock(ServletResponse.class);\n        HttpServletResponse httpResponse = mock(HttpServletResponse.class);\n        when(response.getHttpServletResponse()).thenReturn(httpResponse);\n        when(container.getResponse()).thenReturn(response);\n\n        ServletRequest request = mock(ServletRequest.class);\n        HttpServletRequest httpRequest = mock(HttpServletRequest.class);\n        when(httpRequest.getHeader(\"If-Modified-Since\")).thenReturn(\"some value\");\n        when(request.getHttpServletRequest()).thenReturn(httpRequest);\n        when(container.getRequest()).thenReturn(request);\n\n        handler.handle(reference, chain);\n\n        // This the test: we verify that 304 is returned when the \"If-Modified-Since\" header is found in the request\n        verify(httpResponse).setStatus(HttpServletResponse.SC_NOT_MODIFIED);\n    }","id":24209,"modified_method":"@Test\n    public void return304WhenIfModifiedSinceHeader() throws Exception\n    {\n        when(this.request.getHttpServletRequest().getHeader(\"If-Modified-Since\")).thenReturn(\"some value\");\n\n        this.handler.handle(this.reference, this.chain);\n\n        // This the test: we verify that 304 is returned when the \"If-Modified-Since\" header is found in the request\n        verify(this.response.getHttpServletResponse()).setStatus(304);\n\n        verify(this.chain).handleNext(this.reference);\n    }","commit_id":"867eaa7fd94894cb31db97be581d288249aa0b84","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void evaluateResource() throws Exception\n    {\n        EntityResourceReference reference =\n            new EntityResourceReference(new DocumentReference(\"wiki\", \"Space\", \"Page\"), EntityResourceAction.VIEW);\n        reference.addParameter(\"value\", \"angular/2.1.11/angular.js\");\n        reference.addParameter(\"evaluate\", \"true\");\n\n        TestableWebJarsResourceReferenceHandler handler = this.componentManager.getComponentUnderTest();\n\n        ClassLoader classLoader = mock(ClassLoader.class);\n        handler.setClassLoader(classLoader);\n\n        ByteArrayInputStream resourceStream = new ByteArrayInputStream(\"content\".getBytes());\n        when(classLoader.getResourceAsStream(\"META-INF/resources/webjars/angular/2.1.11/angular.js\")).thenReturn(\n            resourceStream);\n\n        Container container = this.componentManager.getInstance(Container.class);\n        ServletResponse response = mock(ServletResponse.class);\n        HttpServletResponse httpResponse = mock(HttpServletResponse.class);\n        when(response.getHttpServletResponse()).thenReturn(httpResponse);\n        when(container.getResponse()).thenReturn(response);\n        ByteArrayOutputStream responseOutputStream = new ByteArrayOutputStream();\n        when(response.getOutputStream()).thenReturn(responseOutputStream);\n\n        VelocityManager velocityManager = this.componentManager.getInstance(VelocityManager.class);\n        VelocityEngine velocityEngine = mock(VelocityEngine.class);\n        when(velocityManager.getVelocityEngine()).thenReturn(velocityEngine);\n\n        doAnswer(new Answer<Void>()\n        {\n            public Void answer(InvocationOnMock invocation)\n            {\n                ((StringWriter) invocation.getArguments()[1]).write(\"evaluated content\");\n                return null;\n            }\n        }).when(velocityEngine).evaluate(any(VelocityContext.class), any(StringWriter.class),\n            eq(\"angular/2.1.11/angular.js\"), any(Reader.class));\n\n        handler.handle(reference, mock(ResourceReferenceHandlerChain.class));\n\n        // Verify that the resource content has been evaluated and copied to the Response output stream.\n        assertEquals(\"evaluated content\", responseOutputStream.toString());\n\n        // Verify that the correct Content Type has been set.\n        verify(response).setContentType(\"application/javascript\");\n\n        // Also verify that the \"Last-Modified\" header has not been set in the response because the resource is dynamic\n        // (has Velocity code that is evaluated on each request).\n        verify(httpResponse, never()).setDateHeader(eq(\"Last-Modified\"), anyLong());\n    }","id":24210,"modified_method":"@Test\n    public void evaluateResource() throws Exception\n    {\n        this.reference.addParameter(\"value\", \"angular/2.1.11/angular.js\");\n        this.reference.addParameter(\"evaluate\", \"true\");\n\n        ByteArrayInputStream resourceStream = new ByteArrayInputStream(\"content\".getBytes());\n        when(this.classLoader.getResourceAsStream(\"META-INF/resources/webjars/angular/2.1.11/angular.js\")).thenReturn(\n            resourceStream);\n\n        VelocityManager velocityManager = this.componentManager.getInstance(VelocityManager.class);\n        VelocityEngine velocityEngine = mock(VelocityEngine.class);\n        when(velocityManager.getVelocityEngine()).thenReturn(velocityEngine);\n\n        doAnswer(new Answer<Void>()\n        {\n            public Void answer(InvocationOnMock invocation)\n            {\n                ((StringWriter) invocation.getArguments()[1]).write(\"evaluated content\");\n                return null;\n            }\n        }).when(velocityEngine).evaluate(any(VelocityContext.class), any(StringWriter.class),\n            eq(\"angular/2.1.11/angular.js\"), any(Reader.class));\n\n        this.handler.handle(this.reference, this.chain);\n\n        // Verify that the resource content has been evaluated and copied to the Response output stream.\n        assertEquals(\"evaluated content\", this.response.getOutputStream().toString());\n\n        // Verify that the correct Content Type has been set.\n        verify(this.response).setContentType(\"application/javascript\");\n\n        // Verify that the dynamic resource is not cached.\n        verify(this.response.getHttpServletResponse(), never()).setHeader(any(String.class), any(String.class));\n        verify(this.response.getHttpServletResponse(), never()).setDateHeader(any(String.class), any(Long.class));\n    }","commit_id":"867eaa7fd94894cb31db97be581d288249aa0b84","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Test\n    public void executeWhenResourceDoesntExist() throws Exception\n    {\n        EntityResourceReference reference = new EntityResourceReference(new DocumentReference(\"wiki\", \"space\", \"page\"),\n            EntityResourceAction.VIEW);\n        reference.addParameter(\"value\", \"angular/2.1.11/angular.js\");\n        ResourceReferenceHandlerChain chain = mock(ResourceReferenceHandlerChain.class);\n        TestableWebJarsResourceReferenceHandler handler = this.componentManager.getComponentUnderTest();\n\n        ClassLoader classLoader = mock(ClassLoader.class);\n\n        handler.setClassLoader(classLoader);\n\n        handler.handle(reference, chain);\n\n        verify(classLoader).getResourceAsStream(\"META-INF/resources/webjars/angular/2.1.11/angular.js\");\n    }","id":24211,"modified_method":"@Test\n    public void executeWhenResourceDoesntExist() throws Exception\n    {\n        this.reference.addParameter(\"value\", \"angular/2.1.11/angular.js\");\n\n        this.handler.handle(this.reference, this.chain);\n\n        verify(this.classLoader).getResourceAsStream(\"META-INF/resources/webjars/angular/2.1.11/angular.js\");\n        verify(this.response.getHttpServletResponse())\n            .sendError(404, \"Resource not found [angular/2.1.11/angular.js].\");\n        verify(this.chain).handleNext(this.reference);\n    }","commit_id":"867eaa7fd94894cb31db97be581d288249aa0b84","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public void testStrictForm()\n            throws Exception\n    {\n        _security.setAuthenticator(new SessionCachingAuthenticator(\n                new FormAuthenticator(\"/testLoginPage\",\"/testErrorPage\")));\n        \n        _server.start();\n\n        String response;\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/noauth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/forbid/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403 Forbidden\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n//        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n//        assertTrue(response.indexOf(\"testLoginPage\") > 0);\n        String session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 31\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=wrong\\r\\n\");\n        //TODO we are forwarded to the error page now.  Is there any way to verify the contents?\n        assertTrue(response.startsWith(\"HTTP/1.1 200 \"));\n//        assertTrue(response.indexOf(\"Location\") > 0);\n//        assertTrue(response.indexOf(\"testErrorPage\") > 0);\n\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 35\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"User not in required role\") > 0);\n        \n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"User not in required role\") > 0);\n        \n        \n        \n        // log in again as user2\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n//        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n//        assertTrue(response.indexOf(\"testLoginPage\") > 0);\n        session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 36\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user2&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n        \n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        \n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"User not in required role\") > 0);\n        \n\n        \n        // log in again as admin\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n//        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n//        assertTrue(response.indexOf(\"testLoginPage\") > 0);\n        session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 36\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=admin&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n        \n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        \n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        \n        \n    }","id":24212,"modified_method":"public void testStrictForm()\n            throws Exception\n    {\n        _security.setAuthenticator(new SessionCachingAuthenticator(\n                new FormAuthenticator(\"/testLoginPage\",\"/testErrorPage\")));\n        \n        _server.start();\n\n        String response;\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/noauth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/forbid/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403 Forbidden\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.indexOf(\" 302 Found\") > 0);\n        assertTrue(response.indexOf(\"/ctx/testLoginPage\") > 0);\n        \n        String session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 31\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=wrong\\r\\n\");\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"testErrorPage\") > 0);\n\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 35\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"User not in required role\") > 0);\n        \n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"User not in required role\") > 0);\n        \n        \n        \n        // log in again as user2\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n//        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n//        assertTrue(response.indexOf(\"testLoginPage\") > 0);\n        session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 36\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user2&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n        \n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        \n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"User not in required role\") > 0);\n        \n\n        \n        // log in again as admin\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n//        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n//        assertTrue(response.indexOf(\"testLoginPage\") > 0);\n        session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 36\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=admin&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n        \n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        \n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        \n        \n    }","commit_id":"a71d893d58da037a183b26c6863c986aff7158cf","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void testForm()\n            throws Exception\n    {\n        _security.setAuthenticator(new SessionCachingAuthenticator(\n                new FormAuthenticator(\"/testLoginPage\",\"/testErrorPage\")));\n        _security.setStrict(false);\n        _server.start();\n\n        String response;\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/noauth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/forbid/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403 Forbidden\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.indexOf(\"Cache-Control: no-cache\") > 0);\n        assertTrue(response.indexOf(\"Expires\") > 0);\n        assertTrue(response.indexOf(\"URI=/ctx/testLoginPage\") > 0);\n\n        String session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 31\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=wrong\\r\\n\");\n        //TODO we are forwarded to the error page now.  Is there any way to verify the contents?\n        assertTrue(response.startsWith(\"HTTP/1.1 200 \"));\n//        assertTrue(response.indexOf(\"Location\") > 0);\n//        assertTrue(response.indexOf(\"testErrorPage\") > 0);\n\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 35\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        \n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"User not in required role\") > 0);\n        \n    }","id":24213,"modified_method":"public void testForm()\n            throws Exception\n    {\n        _security.setAuthenticator(new SessionCachingAuthenticator(\n                new FormAuthenticator(\"/testLoginPage\",\"/testErrorPage\")));\n        _security.setStrict(false);\n        _server.start();\n\n        String response;\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/noauth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/forbid/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403 Forbidden\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\\r\\n\");\n        assertTrue(response.indexOf(\" 302 Found\") > 0);\n        assertTrue(response.indexOf(\"/ctx/testLoginPage\") > 0);\n        /* if dispatch\n        assertTrue(response.indexOf(\"Cache-Control: no-cache\") > 0);\n        assertTrue(response.indexOf(\"Expires\") > 0);\n        assertTrue(response.indexOf(\"URI=/ctx/testLoginPage\") > 0);\n        */\n\n        String session = response.substring(response.indexOf(\"JSESSIONID=\") + 11, response.indexOf(\";Path=/ctx\"));\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 31\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=wrong\\r\\n\");\n          assertTrue(response.indexOf(\"Location\") > 0);\n          assertTrue(response.indexOf(\"testErrorPage\") > 0);\n\n\n        _connector.reopen();\n        response = _connector.getResponses(\"POST /ctx/j_security_check HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"Content-Type: application/x-www-form-urlencoded\\r\\n\" +\n                \"Content-Length: 35\\r\\n\" +\n                \"\\r\\n\" +\n                \"j_username=user&j_password=password\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 302 \"));\n        assertTrue(response.indexOf(\"Location\") > 0);\n        assertTrue(response.indexOf(\"/ctx/auth/info\") > 0);\n\n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/auth/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 200 OK\"));\n        \n        _connector.reopen();\n        response = _connector.getResponses(\"GET /ctx/admin/info HTTP/1.0\\r\\n\" +\n                \"Cookie: JSESSIONID=\" + session + \"\\r\\n\" +\n                \"\\r\\n\");\n        assertTrue(response.startsWith(\"HTTP/1.1 403\"));\n        assertTrue(response.indexOf(\"User not in required role\") > 0);\n        \n    }","commit_id":"a71d893d58da037a183b26c6863c986aff7158cf","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server(8080);\n        \n        WebAppContext context = new WebAppContext();\n        context.setWar(\"./target/jetty-test-webapp-7.0.0.M0-SNAPSHOT\"); // TODO YUCK!\n        context.setDefaultsDescriptor(\"../jetty-webapp/src/main/config/etc/webdefault.xml\");\n        server.setHandler(context);\n        \n        HashLoginService login = new HashLoginService();\n        login.putUser(\"jetty\",new Password(\"password\"),new String[]{\"user\"});\n        login.putUser(\"admin\",new Password(\"password\"),new String[]{\"user\",\"admin\"});\n        server.addBean(login);\n        \n        server.start();\n        server.join();\n    }","id":24214,"modified_method":"public static void main(String[] args)\n        throws Exception\n    {\n        Server server = new Server(8080);\n        \n        WebAppContext context = new WebAppContext();\n        context.setWar(\"./target/jetty-test-webapp-7.0.0.M1-SNAPSHOT\"); // TODO YUCK!\n        context.setDefaultsDescriptor(\"../jetty-webapp/src/main/config/etc/webdefault.xml\");\n        server.setHandler(context);\n        \n        HashLoginService login = new HashLoginService();\n        login.putUser(\"jetty\",new Password(\"password\"),new String[]{\"user\"});\n        login.putUser(\"admin\",new Password(\"password\"),new String[]{\"user\",\"admin\"});\n        server.addBean(login);\n        \n        server.start();\n        server.join();\n    }","commit_id":"a71d893d58da037a183b26c6863c986aff7158cf","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Authentication validateRequest(ServletRequest req, ServletResponse res, boolean mandatory) throws ServerAuthException\n    {\n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        HttpSession session = request.getSession(mandatory);\n        String uri = request.getPathInfo();\n        // not mandatory and not authenticated\n        if (session == null || isLoginOrErrorPage(uri)) \n        {\n            return DefaultAuthentication.SUCCESS_UNAUTH_RESULTS;\n        }\n            \n\n        try\n        {\n            // Handle a request for authentication.\n            // TODO perhaps j_securitycheck can be uri suffix?\n            if (uri.endsWith(__J_SECURITY_CHECK))\n            {\n                final String username = request.getParameter(__J_USERNAME);\n                final char[] password = request.getParameter(__J_PASSWORD).toCharArray();\n                \n                UserIdentity user = _loginService.login(username,password);\n                if (user!=null)\n                {\n                    // Redirect to original request\n                    String nuri = (String) session.getAttribute(__J_URI);\n                    if (nuri == null || nuri.length() == 0)\n                    {\n                        nuri = request.getContextPath();\n                        if (nuri.length() == 0) nuri = URIUtil.SLASH;\n                    }\n                    // TODO shouldn't we forward to original URI instead?\n                    session.removeAttribute(__J_URI); // Remove popped return URI.\n                    response.setContentLength(0);   \n                    response.sendRedirect(response.encodeRedirectURL(nuri));\n                    return new DefaultAuthentication(Authentication.Status.SEND_SUCCESS,Constraint.__FORM_AUTH,user);\n                }\n                \n                // not authenticated\n                if (Log.isDebugEnabled()) Log.debug(\"Form authentication FAILED for \" + StringUtil.printable(username));\n                if (_formErrorPage == null)\n                {\n                    if (response != null) \n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                }\n                else\n                {\n                    RequestDispatcher dispatcher = request.getRequestDispatcher(_formErrorPage);\n                    response.setHeader(HttpHeaders.CACHE_CONTROL,\"No-cache\");\n                    response.setDateHeader(HttpHeaders.EXPIRES,1);\n                    dispatcher.forward(request, response);\n                }\n                // TODO is this correct response if isMandatory false??? Can\n                // that occur?\n                return DefaultAuthentication.SEND_FAILURE_RESULTS;\n            }\n            // Check if the session is already authenticated.\n\n            // Don't authenticate authform or errorpage\n            if (!mandatory)\n            // TODO verify this is correct action\n                return DefaultAuthentication.SUCCESS_UNAUTH_RESULTS;\n\n            // redirect to login page\n            if (request.getQueryString() != null)\n                uri += \"?\" + request.getQueryString();\n            //TODO is this safe if the client is sending several requests concurrently in the same session to secured resources?\n            session.setAttribute(__J_URI, request.getScheme() + \"://\"\n                                          + request.getServerName()\n                                          + \":\"\n                                          + request.getServerPort()\n                                          + URIUtil.addPaths(request.getContextPath(), uri));\n            RequestDispatcher dispatcher = request.getRequestDispatcher(_formLoginPage);\n            response.setHeader(HttpHeaders.CACHE_CONTROL,\"No-cache\");\n            response.setDateHeader(HttpHeaders.EXPIRES,1);\n            dispatcher.forward(request, response);\n            return DefaultAuthentication.SEND_CONTINUE_RESULTS;\n        }\n        catch (IOException e)\n        {\n            throw new ServerAuthException(e);\n        }\n        catch (ServletException e)\n        {\n            throw new ServerAuthException(e);\n        }\n    }","id":24215,"modified_method":"public Authentication validateRequest(ServletRequest req, ServletResponse res, boolean mandatory) throws ServerAuthException\n    {\n        HttpServletRequest request = (HttpServletRequest)req;\n        HttpServletResponse response = (HttpServletResponse)res;\n        HttpSession session = request.getSession(mandatory);\n        String uri = request.getPathInfo();\n        // not mandatory and not authenticated\n        if (session == null || isLoginOrErrorPage(uri)) \n        {\n            return DefaultAuthentication.SUCCESS_UNAUTH_RESULTS;\n        }\n            \n\n        try\n        {\n            // Handle a request for authentication.\n            // TODO perhaps j_securitycheck can be uri suffix?\n            if (uri.endsWith(__J_SECURITY_CHECK))\n            {\n                final String username = request.getParameter(__J_USERNAME);\n                final char[] password = request.getParameter(__J_PASSWORD).toCharArray();\n                \n                UserIdentity user = _loginService.login(username,password);\n                if (user!=null)\n                {\n                    // Redirect to original request\n                    String nuri = (String) session.getAttribute(__J_URI);\n                    if (nuri == null || nuri.length() == 0)\n                    {\n                        nuri = request.getContextPath();\n                        if (nuri.length() == 0) nuri = URIUtil.SLASH;\n                    }\n                    // TODO shouldn't we forward to original URI instead?\n                    session.removeAttribute(__J_URI); // Remove popped return URI.\n                    response.setContentLength(0);   \n                    response.sendRedirect(response.encodeRedirectURL(nuri));\n                    return new DefaultAuthentication(Authentication.Status.SEND_SUCCESS,Constraint.__FORM_AUTH,user);\n                }\n                \n                // not authenticated\n                if (Log.isDebugEnabled()) Log.debug(\"Form authentication FAILED for \" + StringUtil.printable(username));\n                if (_formErrorPage == null)\n                {\n                    if (response != null) \n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                }\n                else if (_dispatch)\n                {\n                    RequestDispatcher dispatcher = request.getRequestDispatcher(_formErrorPage);\n                    response.setHeader(HttpHeaders.CACHE_CONTROL,\"No-cache\");\n                    response.setDateHeader(HttpHeaders.EXPIRES,1);\n                    dispatcher.forward(request, response);\n                }\n                else\n                {\n                    response.sendRedirect(URIUtil.addPaths(request.getContextPath(),_formErrorPage));\n                }\n                \n                // TODO is this correct response if isMandatory false??? Can\n                // that occur?\n                return DefaultAuthentication.SEND_FAILURE_RESULTS;\n            }\n            // Check if the session is already authenticated.\n\n            // Don't authenticate authform or errorpage\n            if (!mandatory)\n            // TODO verify this is correct action\n                return DefaultAuthentication.SUCCESS_UNAUTH_RESULTS;\n\n            // redirect to login page\n            if (request.getQueryString() != null)\n                uri += \"?\" + request.getQueryString();\n            //TODO is this safe if the client is sending several requests concurrently in the same session to secured resources?\n            session.setAttribute(__J_URI, request.getScheme() + \"://\"\n                                          + request.getServerName()\n                                          + \":\"\n                                          + request.getServerPort()\n                                          + URIUtil.addPaths(request.getContextPath(), uri));\n            \n            if (_dispatch)\n            {\n                RequestDispatcher dispatcher = request.getRequestDispatcher(_formLoginPage);\n                response.setHeader(HttpHeaders.CACHE_CONTROL,\"No-cache\");\n                response.setDateHeader(HttpHeaders.EXPIRES,1);\n                dispatcher.forward(request, response);\n            }\n            else\n            {\n                response.sendRedirect(URIUtil.addPaths(request.getContextPath(),_formLoginPage));\n            }\n            \n            return DefaultAuthentication.SEND_CONTINUE_RESULTS;\n        }\n        catch (IOException e)\n        {\n            throw new ServerAuthException(e);\n        }\n        catch (ServletException e)\n        {\n            throw new ServerAuthException(e);\n        }\n    }","commit_id":"a71d893d58da037a183b26c6863c986aff7158cf","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @see org.eclipse.jetty.security.authentication.LoginAuthenticator#setConfiguration(org.eclipse.jetty.security.Authenticator.Configuration)\n     */\n    @Override\n    public void setConfiguration(Configuration configuration)\n    {\n        super.setConfiguration(configuration);\n        String login=configuration.getInitParameter(FormAuthenticator.__FORM_LOGIN_PAGE);\n        if (login!=null)\n            setLoginPage(login);\n        String error=configuration.getInitParameter(FormAuthenticator.__FORM_ERROR_PAGE);\n        if (error!=null)\n            setErrorPage(error);\n    }","id":24216,"modified_method":"/**\n     * @see org.eclipse.jetty.security.authentication.LoginAuthenticator#setConfiguration(org.eclipse.jetty.security.Authenticator.Configuration)\n     */\n    @Override\n    public void setConfiguration(Configuration configuration)\n    {\n        super.setConfiguration(configuration);\n        String login=configuration.getInitParameter(FormAuthenticator.__FORM_LOGIN_PAGE);\n        if (login!=null)\n            setLoginPage(login);\n        String error=configuration.getInitParameter(FormAuthenticator.__FORM_ERROR_PAGE);\n        if (error!=null)\n            setErrorPage(error);\n        String dispatch=configuration.getInitParameter(FormAuthenticator.__FORM_DISPATCH);\n        _dispatch=dispatch!=null && Boolean.getBoolean(dispatch);\n    }","commit_id":"a71d893d58da037a183b26c6863c986aff7158cf","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void addCommunityPermissions(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tResource resource, boolean portletActions)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\tlong resourceId = resource.getResourceId();\n\t\tString primKey = resource.getPrimKey();\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 1);\n\n\t\tList<String> actions = null;\n\n\t\tif (portletActions) {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getPortletResourceCommunityDefaultActions(\n\t\t\t\t\tname);\n\t\t}\n\t\telse {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getModelResourceCommunityDefaultActions(\n\t\t\t\t\tname);\n\t\t}\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 2);\n\n\t\tString[] actionIds = actions.toArray(new String[actions.size()]);\n\n\t\tList<Permission> communityPermissionsList =\n\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\tgroup.getCompanyId(), actionIds, resourceId);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 3);\n\n\t\tPermissionsListFilter permissionsListFilter =\n\t\t\tPermissionsListFilterFactory.getInstance();\n\n\t\tcommunityPermissionsList =\n\t\t\tpermissionsListFilter.filterCommunityPermissions(\n\t\t\t\tcompanyId, groupId, userId, name, primKey, portletActions,\n\t\t\t\tcommunityPermissionsList);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 4);\n\n\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\tRole role = null;\n\n\t\t\tif (group.isCommunity()) {\n\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tcompanyId, RoleNames.COMMUNITY_MEMBER);\n\t\t\t}\n\t\t\telse if (group.isOrganization()) {\n\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tcompanyId, RoleNames.ORGANIZATION_MEMBER);\n\t\t\t}\n\t\t\telse if (group.isUser()) {\n\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tcompanyId, RoleNames.POWER_USER);\n\t\t\t}\n\n\t\t\trolePersistence.addPermissions(\n\t\t\t\trole.getRoleId(), communityPermissionsList);\n\t\t}\n\t\telse {\n\t\t\tgroupPersistence.addPermissions(groupId, communityPermissionsList);\n\t\t}\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 5);\n\t}","id":24217,"modified_method":"protected void addCommunityPermissions(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tResource resource, boolean portletActions)\n\t\tthrows PortalException, SystemException {\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\tlong resourceId = resource.getResourceId();\n\t\tString primKey = resource.getPrimKey();\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 1);\n\n\t\tList<String> actions = null;\n\n\t\tif (portletActions) {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getPortletResourceCommunityDefaultActions(\n\t\t\t\t\tname);\n\t\t}\n\t\telse {\n\t\t\tactions =\n\t\t\t\tResourceActionsUtil.getModelResourceCommunityDefaultActions(\n\t\t\t\t\tname);\n\t\t}\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 2);\n\n\t\tString[] actionIds = actions.toArray(new String[actions.size()]);\n\n\t\tList<Permission> communityPermissionsList =\n\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\tgroup.getCompanyId(), actionIds, resourceId);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 3);\n\n\t\tPermissionsListFilter permissionsListFilter =\n\t\t\tPermissionsListFilterFactory.getInstance();\n\n\t\tcommunityPermissionsList =\n\t\t\tpermissionsListFilter.filterCommunityPermissions(\n\t\t\t\tcompanyId, groupId, userId, name, primKey, portletActions,\n\t\t\t\tcommunityPermissionsList);\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 4);\n\n\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\tRole role = null;\n\n\t\t\tif (group.isCommunity() || group.isUserGroup()) {\n\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tcompanyId, RoleNames.COMMUNITY_MEMBER);\n\t\t\t}\n\t\t\telse if (group.isOrganization()) {\n\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tcompanyId, RoleNames.ORGANIZATION_MEMBER);\n\t\t\t}\n\t\t\telse if (group.isUser()) {\n\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tcompanyId, RoleNames.POWER_USER);\n\t\t\t}\n\n\t\t\trolePersistence.addPermissions(\n\t\t\t\trole.getRoleId(), communityPermissionsList);\n\t\t}\n\t\telse {\n\t\t\tgroupPersistence.addPermissions(groupId, communityPermissionsList);\n\t\t}\n\n\t\tlogAddCommunityPermissions(groupId, name, resourceId, stopWatch, 5);\n\t}","commit_id":"ca50e86c5ff5e1922216909e501a96280b36f093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addModelResources(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tString primKey, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(companyId, name, false);\n\n\t\t// Company\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceConstants.SCOPE_COMPANY,\n\t\t\tString.valueOf(companyId));\n\n\t\t// Guest\n\n\t\tGroup guestGroup = groupLocalService.getGroup(\n\t\t\tcompanyId, GroupImpl.GUEST);\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceConstants.SCOPE_GROUP,\n\t\t\tString.valueOf(guestGroup.getGroupId()));\n\n\t\t// Group\n\n\t\tif ((groupId > 0) && (guestGroup.getGroupId() != groupId)) {\n\t\t\taddResource(\n\t\t\t\tcompanyId, name, ResourceConstants.SCOPE_GROUP,\n\t\t\t\tString.valueOf(groupId));\n\t\t}\n\n\t\tif (primKey != null) {\n\n\t\t\t// Individual\n\n\t\t\tResource resource = addResource(\n\t\t\t\tcompanyId, name, ResourceConstants.SCOPE_INDIVIDUAL, primKey);\n\n\t\t\tlong defaultUserId = userLocalService.getDefaultUserId(\n\t\t\t\tcompanyId);\n\n\t\t\tPermissionsListFilter permissionsListFilter =\n\t\t\t\tPermissionsListFilterFactory.getInstance();\n\n\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM != 5) {\n\n\t\t\t\t// Permissions\n\n\t\t\t\tList<Permission> permissionsList =\n\t\t\t\t\tpermissionLocalService.addPermissions(\n\t\t\t\t\t\tcompanyId, name, resource.getResourceId(), false);\n\n\t\t\t\t// User permissions\n\n\t\t\t\tif ((userId > 0) && (userId != defaultUserId)) {\n\t\t\t\t\tList<Permission> userPermissionsList =\n\t\t\t\t\t\tpermissionsListFilter.filterUserPermissions(\n\t\t\t\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\t\t\t\tpermissionsList);\n\n\t\t\t\t\tuserPersistence.addPermissions(userId, userPermissionsList);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Community permissions\n\n\t\t\tif (groupId > 0) {\n\t\t\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\t\t\tif (communityPermissions == null) {\n\t\t\t\t\tcommunityPermissions = new String[0];\n\t\t\t\t}\n\n\t\t\t\tList<Permission> communityPermissionsList =\n\t\t\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\t\t\tcompanyId, communityPermissions,\n\t\t\t\t\t\tresource.getResourceId());\n\n\t\t\t\tcommunityPermissionsList =\n\t\t\t\t\tpermissionsListFilter.filterCommunityPermissions(\n\t\t\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\t\t\tcommunityPermissionsList);\n\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\tRole role = null;\n\n\t\t\t\t\tif (group.isCommunity()) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleNames.COMMUNITY_MEMBER);\n\t\t\t\t\t}\n\t\t\t\t\telse if (group.isOrganization()) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleNames.ORGANIZATION_MEMBER);\n\t\t\t\t\t}\n\t\t\t\t\telse if (group.isUser()) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleNames.POWER_USER);\n\t\t\t\t\t}\n\n\t\t\t\t\trolePersistence.addPermissions(\n\t\t\t\t\t\trole.getRoleId(), communityPermissionsList);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgroupPersistence.addPermissions(\n\t\t\t\t\t\tgroupId, communityPermissionsList);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest permissions\n\n\t\t\tif (guestPermissions == null) {\n\t\t\t\tguestPermissions = new String[0];\n\t\t\t}\n\n\t\t\tList<Permission> guestPermissionsList =\n\t\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\t\tcompanyId, guestPermissions, resource.getResourceId());\n\n\t\t\tguestPermissionsList = permissionsListFilter.filterGuestPermissions(\n\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\tguestPermissionsList);\n\n\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\tRole guestRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tcompanyId, RoleImpl.GUEST);\n\n\t\t\t\trolePersistence.addPermissions(\n\t\t\t\t\tguestRole.getRoleId(), guestPermissionsList);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuserPersistence.addPermissions(\n\t\t\t\t\tdefaultUserId, guestPermissionsList);\n\t\t\t}\n\t\t}\n\t}","id":24218,"modified_method":"public void addModelResources(\n\t\t\tlong companyId, long groupId, long userId, String name,\n\t\t\tString primKey, String[] communityPermissions,\n\t\t\tString[] guestPermissions)\n\t\tthrows PortalException, SystemException {\n\n\t\tvalidate(companyId, name, false);\n\n\t\t// Company\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceConstants.SCOPE_COMPANY,\n\t\t\tString.valueOf(companyId));\n\n\t\t// Guest\n\n\t\tGroup guestGroup = groupLocalService.getGroup(\n\t\t\tcompanyId, GroupImpl.GUEST);\n\n\t\taddResource(\n\t\t\tcompanyId, name, ResourceConstants.SCOPE_GROUP,\n\t\t\tString.valueOf(guestGroup.getGroupId()));\n\n\t\t// Group\n\n\t\tif ((groupId > 0) && (guestGroup.getGroupId() != groupId)) {\n\t\t\taddResource(\n\t\t\t\tcompanyId, name, ResourceConstants.SCOPE_GROUP,\n\t\t\t\tString.valueOf(groupId));\n\t\t}\n\n\t\tif (primKey != null) {\n\n\t\t\t// Individual\n\n\t\t\tResource resource = addResource(\n\t\t\t\tcompanyId, name, ResourceConstants.SCOPE_INDIVIDUAL, primKey);\n\n\t\t\tlong defaultUserId = userLocalService.getDefaultUserId(\n\t\t\t\tcompanyId);\n\n\t\t\tPermissionsListFilter permissionsListFilter =\n\t\t\t\tPermissionsListFilterFactory.getInstance();\n\n\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM != 5) {\n\n\t\t\t\t// Permissions\n\n\t\t\t\tList<Permission> permissionsList =\n\t\t\t\t\tpermissionLocalService.addPermissions(\n\t\t\t\t\t\tcompanyId, name, resource.getResourceId(), false);\n\n\t\t\t\t// User permissions\n\n\t\t\t\tif ((userId > 0) && (userId != defaultUserId)) {\n\t\t\t\t\tList<Permission> userPermissionsList =\n\t\t\t\t\t\tpermissionsListFilter.filterUserPermissions(\n\t\t\t\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\t\t\t\tpermissionsList);\n\n\t\t\t\t\tuserPersistence.addPermissions(userId, userPermissionsList);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Community permissions\n\n\t\t\tif (groupId > 0) {\n\t\t\t\tGroup group = groupPersistence.findByPrimaryKey(groupId);\n\n\t\t\t\tif (communityPermissions == null) {\n\t\t\t\t\tcommunityPermissions = new String[0];\n\t\t\t\t}\n\n\t\t\t\tList<Permission> communityPermissionsList =\n\t\t\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\t\t\tcompanyId, communityPermissions,\n\t\t\t\t\t\tresource.getResourceId());\n\n\t\t\t\tcommunityPermissionsList =\n\t\t\t\t\tpermissionsListFilter.filterCommunityPermissions(\n\t\t\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\t\t\tcommunityPermissionsList);\n\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\tRole role = null;\n\n\t\t\t\t\tif (group.isCommunity() || group.isUserGroup()) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleNames.COMMUNITY_MEMBER);\n\t\t\t\t\t}\n\t\t\t\t\telse if (group.isOrganization()) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleNames.ORGANIZATION_MEMBER);\n\t\t\t\t\t}\n\t\t\t\t\telse if (group.isUser()) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\t\t\tcompanyId, RoleNames.POWER_USER);\n\t\t\t\t\t}\n\n\t\t\t\t\trolePersistence.addPermissions(\n\t\t\t\t\t\trole.getRoleId(), communityPermissionsList);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tgroupPersistence.addPermissions(\n\t\t\t\t\t\tgroupId, communityPermissionsList);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Guest permissions\n\n\t\t\tif (guestPermissions == null) {\n\t\t\t\tguestPermissions = new String[0];\n\t\t\t}\n\n\t\t\tList<Permission> guestPermissionsList =\n\t\t\t\tpermissionLocalService.getPermissions(\n\t\t\t\t\tcompanyId, guestPermissions, resource.getResourceId());\n\n\t\t\tguestPermissionsList = permissionsListFilter.filterGuestPermissions(\n\t\t\t\tcompanyId, groupId, userId, name, primKey, false,\n\t\t\t\tguestPermissionsList);\n\n\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\tRole guestRole = RoleLocalServiceUtil.getRole(\n\t\t\t\t\tcompanyId, RoleImpl.GUEST);\n\n\t\t\t\trolePersistence.addPermissions(\n\t\t\t\t\tguestRole.getRoleId(), guestPermissionsList);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuserPersistence.addPermissions(\n\t\t\t\t\tdefaultUserId, guestPermissionsList);\n\t\t\t}\n\t\t}\n\t}","commit_id":"ca50e86c5ff5e1922216909e501a96280b36f093","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void getRole(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong roleId = ParamUtil.getLong(request, \"roleId\");\n\n\t\tRole role = null;\n\n\t\tGroup group = (Group)request.getAttribute(WebKeys.GROUP);\n\n\t\tif (group.isCommunity()) {\n\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tthemeDisplay.getUserId(), group.getGroupId(),\n\t\t\t\t\tRoleConstants.COMMUNITY_ADMINISTRATOR, true) ||\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tthemeDisplay.getUserId(), group.getGroupId(),\n\t\t\t\t\tRoleConstants.COMMUNITY_OWNER, true)) {\n\n\t\t\t\tif (roleId > 0) {\n\t\t\t\t\trole = RoleLocalServiceUtil.getRole(roleId);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (roleId > 0) {\n\t\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (group.isOrganization()) {\n\t\t\tlong organizationId = group.getOrganizationId();\n\n\t\t\twhile (organizationId !=\n\t\t\t\t\t\tOrganizationConstants.DEFAULT_PARENT_ORGANIZATION_ID) {\n\n\t\t\t\tOrganization organization =\n\t\t\t\t\tOrganizationLocalServiceUtil.getOrganization(\n\t\t\t\t\t\torganizationId);\n\n\t\t\t\tGroup organizationGroup = organization.getGroup();\n\n\t\t\t\tlong organizationGroupId = organizationGroup.getGroupId();\n\n\t\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\tthemeDisplay.getUserId(), organizationGroupId,\n\t\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR, true) ||\n\t\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\tthemeDisplay.getUserId(), organizationGroupId,\n\t\t\t\t\t\tRoleConstants.ORGANIZATION_OWNER, true)) {\n\n\t\t\t\t\tif (roleId > 0) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(roleId);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\torganizationId = organization.getParentOrganizationId();\n\t\t\t}\n\n\t\t\tif (roleId > 0 && (role == null)) {\n\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (roleId > 0) {\n\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t}\n\t\t}\n\n\t\trequest.setAttribute(WebKeys.ROLE, role);\n\t}","id":24219,"modified_method":"public static void getRole(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong roleId = ParamUtil.getLong(request, \"roleId\");\n\n\t\tRole role = null;\n\n\t\tGroup group = (Group)request.getAttribute(WebKeys.GROUP);\n\n\t\tif ((group != null) && group.isCommunity()) {\n\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tthemeDisplay.getUserId(), group.getGroupId(),\n\t\t\t\t\tRoleConstants.COMMUNITY_ADMINISTRATOR, true) ||\n\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\tthemeDisplay.getUserId(), group.getGroupId(),\n\t\t\t\t\tRoleConstants.COMMUNITY_OWNER, true)) {\n\n\t\t\t\tif (roleId > 0) {\n\t\t\t\t\trole = RoleLocalServiceUtil.getRole(roleId);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (roleId > 0) {\n\t\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((group != null) && group.isOrganization()) {\n\t\t\tlong organizationId = group.getOrganizationId();\n\n\t\t\twhile (organizationId !=\n\t\t\t\t\t\tOrganizationConstants.DEFAULT_PARENT_ORGANIZATION_ID) {\n\n\t\t\t\tOrganization organization =\n\t\t\t\t\tOrganizationLocalServiceUtil.getOrganization(\n\t\t\t\t\t\torganizationId);\n\n\t\t\t\tGroup organizationGroup = organization.getGroup();\n\n\t\t\t\tlong organizationGroupId = organizationGroup.getGroupId();\n\n\t\t\t\tif (UserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\tthemeDisplay.getUserId(), organizationGroupId,\n\t\t\t\t\t\tRoleConstants.ORGANIZATION_ADMINISTRATOR, true) ||\n\t\t\t\t\tUserGroupRoleLocalServiceUtil.hasUserGroupRole(\n\t\t\t\t\t\tthemeDisplay.getUserId(), organizationGroupId,\n\t\t\t\t\t\tRoleConstants.ORGANIZATION_OWNER, true)) {\n\n\t\t\t\t\tif (roleId > 0) {\n\t\t\t\t\t\trole = RoleLocalServiceUtil.getRole(roleId);\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\torganizationId = organization.getParentOrganizationId();\n\t\t\t}\n\n\t\t\tif (roleId > 0 && (role == null)) {\n\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (roleId > 0) {\n\t\t\t\trole = RoleServiceUtil.getRole(roleId);\n\t\t\t}\n\t\t}\n\n\t\trequest.setAttribute(WebKeys.ROLE, role);\n\t}","commit_id":"0581db2d5f091ded3200f7ab965a9dc6a2237658","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ByteContent(byte[] bytes) {\n    super(null, 0);\n    myData = bytes;\n  }","id":24220,"modified_method":"public ByteContent(byte[] bytes) {\n    myData = bytes;\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testEquality() {\n    ByteContent bc = new ByteContent(\"abc\".getBytes());\n\n    assertTrue(bc.equals(new ByteContent(\"abc\".getBytes())));\n    assertFalse(bc.equals(new ByteContent(\"123\".getBytes())));\n\n    Content c = new Content(null, -1) {\n      @Override\n      public byte[] getBytes() {\n        return \"abc\".getBytes();\n      }\n    };\n\n    assertTrue(bc.equals(c));\n  }","id":24221,"modified_method":"@Test\n  public void testEquality() {\n    ByteContent bc = new ByteContent(\"abc\".getBytes());\n\n    assertTrue(bc.equals(new ByteContent(\"abc\".getBytes())));\n    assertFalse(bc.equals(new ByteContent(\"123\".getBytes())));\n\n    Content c = new StoredContent(null, -1) {\n      @Override\n      public byte[] getBytes() {\n        return \"abc\".getBytes();\n      }\n    };\n\n    assertTrue(bc.equals(c));\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable() {\n    try {\n      getBytesUnsafe();\n      return true;\n    }\n    catch (IOException e) {\n      return false;\n    }\n  }","id":24222,"modified_method":"public abstract boolean isAvailable();","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void write(Stream s) throws IOException {\n    s.writeInteger(myId);\n  }","id":24223,"modified_method":"public void write(Stream s) throws IOException {\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public byte[] getBytes() {\n    try {\n      return getBytesUnsafe();\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":24224,"modified_method":"public abstract byte[] getBytes();","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void purge() {\n    myStorage.purgeContent(this);\n  }","id":24225,"modified_method":"public abstract void purge();","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (o == null || !getClass().equals(o.getClass())) return false;\n    return myId == ((Content)o).myId;\n  }","id":24226,"modified_method":"@Override\n  public boolean equals(Object o) {\n    return o != null && getClass().equals(o.getClass());\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void purgeContent(Content c) {\n      purgedContent.add(c);\n    }","id":24227,"modified_method":"@Override\n    public void purgeContent(StoredContent c) {\n      purgedContent.add(c);\n    }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isContentPurged(Content c) {\n    return myContentStorage.isRemoved(c.getId());\n  }","id":24228,"modified_method":"public boolean isContentPurged(StoredContent c) {\n    return myContentStorage.isRemoved(c.getId());\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Content storeContent(byte[] bytes) {\n    if (isBroken) return new UnavailableContent();\n\n    try {\n      int id = myContentStorage.store(bytes);\n      return new Content(this, id);\n    }\n    catch (IOException e) {\n      markAsBroken();\n      return new UnavailableContent();\n    }\n  }","id":24229,"modified_method":"public Content storeContent(byte[] bytes) {\n    if (isBroken) return new UnavailableContent();\n\n    try {\n      int id = myContentStorage.store(bytes);\n      return new StoredContent(this, id);\n    }\n    catch (IOException e) {\n      markAsBroken();\n      return new UnavailableContent();\n    }\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void purgeContent(Content c) {\n    myContentStorage.remove(c.getId());\n  }","id":24230,"modified_method":"protected void purgeContent(StoredContent c) {\n    myContentStorage.remove(c.getId());\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testRecreationOfStorageOnContentLoadingError() {\n    Content c = s.storeContent(b(\"abc\"));\n    m.myEntryCounter = 10;\n    s.store(m);\n    s.close();\n\n    corruptFile(\"contents\");\n    initStorage();\n    try {\n      s.loadContentData(c.getId());\n      fail();\n    }\n    catch (IOException e) {\n    }\n\n    initStorage();\n    m = s.load();\n\n    assertEquals(0, m.myEntryCounter);\n  }","id":24231,"modified_method":"@Test\n  public void testRecreationOfStorageOnContentLoadingError() {\n    StoredContent c = (StoredContent)s.storeContent(b(\"abc\"));\n    m.myEntryCounter = 10;\n    s.store(m);\n    s.close();\n\n    corruptFile(\"contents\");\n    initStorage();\n    try {\n      s.loadContentData(c.getId());\n      fail();\n    }\n    catch (IOException e) {\n    }\n\n    initStorage();\n    m = s.load();\n\n    assertEquals(0, m.myEntryCounter);\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testThrowingExceptionForGoodContentWhenContentStorageIsBroken() {\n    Content c = s.storeContent(b(\"abc\"));\n    try {\n      s.loadContentData(123);\n    }\n    catch (IOException e) {\n    }\n\n    try {\n      s.loadContentData(c.getId());\n      fail();\n    }\n    catch (IOException e) {\n    }\n  }","id":24232,"modified_method":"@Test\n  public void testThrowingExceptionForGoodContentWhenContentStorageIsBroken() {\n    StoredContent c = (StoredContent)s.storeContent(b(\"abc\"));\n    try {\n      s.loadContentData(123);\n    }\n    catch (IOException e) {\n    }\n\n    try {\n      s.loadContentData(c.getId());\n      fail();\n    }\n    catch (IOException e) {\n    }\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testPurgingContents() {\n    Content c1 = s.storeContent(b(\"1\"));\n    Content c2 = s.storeContent(b(\"2\"));\n    Content c3 = s.storeContent(b(\"3\"));\n    s.purgeContents(Arrays.asList(c1, c3));\n\n    assertTrue(s.isContentPurged(c1));\n    assertFalse(s.isContentPurged(c2));\n    assertTrue(s.isContentPurged(c3));\n  }","id":24233,"modified_method":"@Test\n  public void testPurgingContents() {\n    Content c1 = s.storeContent(b(\"1\"));\n    Content c2 = s.storeContent(b(\"2\"));\n    Content c3 = s.storeContent(b(\"3\"));\n    s.purgeContents(Arrays.asList(c1, c3));\n\n    assertTrue(s.isContentPurged((StoredContent)c1));\n    assertFalse(s.isContentPurged((StoredContent)c2));\n    assertTrue(s.isContentPurged((StoredContent)c3));\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testRecreationOfStorageOnLoadingError() {\n    Content c = s.storeContent(b(\"abc\"));\n    m.myEntryCounter = 10;\n    s.store(m);\n    s.close();\n\n    corruptFile(\"storage\");\n\n    initStorage();\n    m = s.load();\n    assertEquals(0, m.myEntryCounter);\n\n    assertEquals(c.getId(), s.storeContent(b(\"abc\")).getId());\n  }","id":24234,"modified_method":"@Test\n  public void testRecreationOfStorageOnLoadingError() {\n    StoredContent oldContent = (StoredContent)s.storeContent(b(\"abc\"));\n    m.myEntryCounter = 10;\n    s.store(m);\n    s.close();\n\n    corruptFile(\"storage\");\n\n    initStorage();\n    m = s.load();\n    assertEquals(0, m.myEntryCounter);\n\n    StoredContent newContent = (StoredContent)s.storeContent(b(\"abc\"));\n    assertEquals(oldContent.getId(), newContent.getId());\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Content readContent() throws IOException {\n    switch (myIs.readInt()) {\n      case 0:\n        return new Content(this);\n      case 1:\n        return new UnavailableContent(this);\n    }\n    throw new IOException();\n  }","id":24235,"modified_method":"public Content readContent() throws IOException {\n    switch (myIs.readInt()) {\n      case 0:\n        return new StoredContent(this);\n      case 1:\n        return new UnavailableContent();\n    }\n    throw new IOException();\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void writeContent(Content content) throws IOException {\n    int id = -1;\n\n    Class c = content.getClass();\n    if (c.equals(Content.class)) id = 0;\n    if (c.equals(UnavailableContent.class)) id = 1;\n\n    myOs.writeInt(id);\n    content.write(this);\n  }","id":24236,"modified_method":"public void writeContent(Content content) throws IOException {\n    int id = -1;\n\n    Class c = content.getClass();\n    if (c.equals(StoredContent.class)) id = 0;\n    if (c.equals(UnavailableContent.class)) id = 1;\n\n    myOs.writeInt(id);\n    content.write(this);\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Content storeContent(byte[] bytes) {\n    int id = myContents.size();\n    myContents.put(id, bytes);\n    return new Content(this, id);\n  }","id":24237,"modified_method":"@Override\n  public Content storeContent(byte[] bytes) {\n    int id = myContents.size();\n    myContents.put(id, bytes);\n    return new StoredContent(this, id);\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testDoesNotEqualToAnyOtherContent() {\n    final UnavailableContent u = new UnavailableContent();\n    ByteContent b = new ByteContent(new byte[]{1, 2, 3});\n\n    assertFalse(u.equals(b));\n    assertFalse(b.equals(u));\n\n    assertFalse(u.equals(new Content(null, -1) {\n      @Override\n      public byte[] getBytes() {\n        return u.getBytes();\n      }\n    }));\n  }","id":24238,"modified_method":"@Test\n  public void testDoesNotEqualToAnyOtherContent() {\n    final UnavailableContent u = new UnavailableContent();\n    ByteContent b = new ByteContent(new byte[]{1, 2, 3});\n\n    assertFalse(u.equals(b));\n    assertFalse(b.equals(u));\n\n    assertFalse(u.equals(new StoredContent(null, -1) {\n      @Override\n      public byte[] getBytes() {\n        return u.getBytes();\n      }\n    }));\n  }","commit_id":"405f7b05c27ba9fd8a088d64864d9821e083d573","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Answer migrateVolumeToPool(DataObject srcData, DataObject destData) {\n        VolumeInfo volume = (VolumeInfo)srcData;\n        StoragePool destPool = (StoragePool)dataStoreMgr.getDataStore(destData.getDataStore().getId(), DataStoreRole.Primary);\n        MigrateVolumeCommand command = new MigrateVolumeCommand(volume.getId(), volume.getPath(), destPool, volume.getAttachedVmName());\n        EndPoint ep = selector.select(srcData, StorageAction.MIGRATEVOLUME);\n        Answer answer = null;\n        if (ep == null) {\n            String errMsg = \"No remote endpoint to send command, check if host or ssvm is down?\";\n            s_logger.error(errMsg);\n            answer = new Answer(command, false, errMsg);\n        } else {\n            answer = ep.sendMessage(command);\n        }\n\n        if (answer == null || !answer.getResult()) {\n            throw new CloudRuntimeException(\"Failed to migrate volume \" + volume + \" to storage pool \" + destPool);\n        } else {\n            // Update the volume details after migration.\n            VolumeVO volumeVo = volDao.findById(volume.getId());\n            Long oldPoolId = volume.getPoolId();\n            volumeVo.setPath(((MigrateVolumeAnswer)answer).getVolumePath());\n            volumeVo.setFolder(destPool.getPath());\n            volumeVo.setPodId(destPool.getPodId());\n            volumeVo.setPoolId(destPool.getId());\n            volumeVo.setLastPoolId(oldPoolId);\n            volDao.update(volume.getId(), volumeVo);\n        }\n\n        return answer;\n    }","id":24239,"modified_method":"protected Answer migrateVolumeToPool(DataObject srcData, DataObject destData) {\n        VolumeInfo volume = (VolumeInfo)srcData;\n        StoragePool destPool = (StoragePool)dataStoreMgr.getDataStore(destData.getDataStore().getId(), DataStoreRole.Primary);\n        MigrateVolumeCommand command = new MigrateVolumeCommand(volume.getId(), volume.getPath(), destPool, volume.getAttachedVmName());\n        EndPoint ep = selector.select(srcData, StorageAction.MIGRATEVOLUME);\n        Answer answer = null;\n        if (ep == null) {\n            String errMsg = \"No remote endpoint to send command, check if host or ssvm is down?\";\n            s_logger.error(errMsg);\n            answer = new Answer(command, false, errMsg);\n        } else {\n            answer = ep.sendMessage(command);\n        }\n\n        if (answer == null || !answer.getResult()) {\n            throw new CloudRuntimeException(\"Failed to migrate volume \" + volume + \" to storage pool \" + destPool);\n        } else {\n            // Update the volume details after migration.\n            VolumeVO volumeVo = volDao.findById(volume.getId());\n            Long oldPoolId = volume.getPoolId();\n            volumeVo.setPath(((MigrateVolumeAnswer)answer).getVolumePath());\n            volumeVo.setPodId(destPool.getPodId());\n            volumeVo.setPoolId(destPool.getId());\n            volumeVo.setLastPoolId(oldPoolId);\n            // For SMB, pool credentials are also stored in the uri query string.  We trim the query string\n            // part  here to make sure the credentials do not get stored in the db unencrypted.\n            String folder = destPool.getPath();\n            if (destPool.getPoolType() == StoragePoolType.SMB && folder != null && folder.contains(\"?\")) {\n                folder = folder.substring(0, folder.indexOf(\"?\"));\n            }\n            volumeVo.setFolder(folder);\n            volDao.update(volume.getId(), volumeVo);\n        }\n\n        return answer;\n    }","commit_id":"5ba5da3696ece250decdb38590f00f8bd4d4b4f9","url":"https://github.com/apache/cloudstack"},{"original_method":"private void updateVolumePathsAfterMigration(Map<VolumeInfo, DataStore> volumeToPool, List<VolumeObjectTO> volumeTos) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeToPool.entrySet()) {\n            boolean updated = false;\n            VolumeInfo volume = entry.getKey();\n            StoragePool pool = (StoragePool)entry.getValue();\n            for (VolumeObjectTO volumeTo : volumeTos) {\n                if (volume.getId() == volumeTo.getId()) {\n                    VolumeVO volumeVO = volDao.findById(volume.getId());\n                    Long oldPoolId = volumeVO.getPoolId();\n                    volumeVO.setPath(volumeTo.getPath());\n                    volumeVO.setFolder(pool.getPath());\n                    volumeVO.setPodId(pool.getPodId());\n                    volumeVO.setPoolId(pool.getId());\n                    volumeVO.setLastPoolId(oldPoolId);\n                    volDao.update(volume.getId(), volumeVO);\n                    updated = true;\n                    break;\n                }\n            }\n\n            if (!updated) {\n                s_logger.error(\"Volume path wasn't updated for volume \" + volume + \" after it was migrated.\");\n            }\n        }\n    }","id":24240,"modified_method":"private void updateVolumePathsAfterMigration(Map<VolumeInfo, DataStore> volumeToPool, List<VolumeObjectTO> volumeTos) {\n        for (Map.Entry<VolumeInfo, DataStore> entry : volumeToPool.entrySet()) {\n            boolean updated = false;\n            VolumeInfo volume = entry.getKey();\n            StoragePool pool = (StoragePool)entry.getValue();\n            for (VolumeObjectTO volumeTo : volumeTos) {\n                if (volume.getId() == volumeTo.getId()) {\n                    VolumeVO volumeVO = volDao.findById(volume.getId());\n                    Long oldPoolId = volumeVO.getPoolId();\n                    volumeVO.setPath(volumeTo.getPath());\n                    volumeVO.setPodId(pool.getPodId());\n                    volumeVO.setPoolId(pool.getId());\n                    volumeVO.setLastPoolId(oldPoolId);\n                    // For SMB, pool credentials are also stored in the uri query string.  We trim the query string\n                    // part  here to make sure the credentials do not get stored in the db unencrypted.\n                    String folder = pool.getPath();\n                    if (pool.getPoolType() == StoragePoolType.SMB && folder != null && folder.contains(\"?\")) {\n                        folder = folder.substring(0, folder.indexOf(\"?\"));\n                    }\n                    volumeVO.setFolder(folder);\n\n                    volDao.update(volume.getId(), volumeVO);\n                    updated = true;\n                    break;\n                }\n            }\n\n            if (!updated) {\n                s_logger.error(\"Volume path wasn't updated for volume \" + volume + \" after it was migrated.\");\n            }\n        }\n    }","commit_id":"5ba5da3696ece250decdb38590f00f8bd4d4b4f9","url":"https://github.com/apache/cloudstack"},{"original_method":"public String getJSON(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(\"deleteMessages\")) {\n\t\t\t\tdeleteMessages(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"emptyFolder\")) {\n\t\t\t\treturn emptyFolder(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"getFolders\")) {\n\t\t\t\treturn getFolders(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"getMessage\")) {\n\t\t\t\treturn getMessage(req, res);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"getPreview\")) {\n\t\t\t\treturn getPreview(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"moveMessages\")) {\n\t\t\t\tmoveMessages(req);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(StackTraceUtil.getStackTrace(e));\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","id":24241,"modified_method":"public String getJSON(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest req,\n\t\t\tHttpServletResponse res)\n\t\tthrows Exception {\n\n\t\tString cmd = ParamUtil.getString(req, Constants.CMD);\n\n\t\ttry {\n\t\t\tif (cmd.equals(\"deleteMessages\")) {\n\t\t\t\tdeleteMessages(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"emptyFolder\")) {\n\t\t\t\treturn emptyFolder(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"folderAdd\")) {\n\t\t\t\tfolderAdd(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"folderDelete\")) {\n\t\t\t\tfolderDelete(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"folderEdit\")) {\n\t\t\t\tfolderEdit(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"getFolders\")) {\n\t\t\t\treturn getFolders(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"getMessage\")) {\n\t\t\t\treturn getMessage(req, res);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"getPreview\")) {\n\t\t\t\treturn getPreview(req);\n\t\t\t}\n\t\t\telse if (cmd.equals(\"moveMessages\")) {\n\t\t\t\tmoveMessages(req);\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(StackTraceUtil.getStackTrace(e));\n\t\t}\n\n\t\treturn StringPool.BLANK;\n\t}","commit_id":"22b57a517642638d128e2ed17f8aa8e0fad3e630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void removeFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\ttry {\n\t\t\tfolderName = _getResolvedFolderName(folderName);\n\n\t\t\tfor (int i = 0; i < DEFAULT_FOLDERS.length; i++) {\n\t\t\t\tif (DEFAULT_FOLDERS[i].equals(folderName)) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Folder \" + folderName +\n\t\t\t\t\t\t\t\t\" is a system folder and cannot be changed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStore store = _getStore(ses);\n\n\t\t\tFolder folder = store.getFolder(folderName);\n\n\t\t\tif (!folder.exists()) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(\"Folder \" + folderName + \" does not exist\");\n\t\t\t\t}\n\n\t\t\t\tthrow new FolderException();\n\t\t\t}\n\n\t\t\tfolder.delete(true);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t}","id":24242,"modified_method":"public static void removeFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\ttry {\n\t\t\tfolderName = _getResolvedFolderName(folderName);\n\n\t\t\tfor (int i = 0; i < DEFAULT_FOLDERS.length; i++) {\n\t\t\t\tif (DEFAULT_FOLDERS[i].equals(folderName)) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Folder \" + folderName +\n\t\t\t\t\t\t\t\t\" is a system folder and cannot be changed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMailSessionLock.lock(ses.getId());\n\n\t\t\t\tsetFolder(ses, MAIL_INBOX_NAME);\n\n\t\t\t\tStore store = _getStore(ses);\n\n\t\t\t\tFolder folder = store.getFolder(folderName);\n\n\t\t\t\tif (!folder.exists()) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\"Folder \" + folderName + \" does not exist\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\n\t\t\t\tfolder.delete(true);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tMailSessionLock.unlock(ses.getId());\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t}","commit_id":"22b57a517642638d128e2ed17f8aa8e0fad3e630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void renameFolder(\n\t\t\tHttpSession ses, String oldFolderName, String newFolderName)\n\t\tthrows FolderException, StoreException {\n\n\t\ttry {\n\t\t\toldFolderName = _getResolvedFolderName(oldFolderName);\n\t\t\tnewFolderName = _getResolvedFolderName(newFolderName);\n\n\t\t\tfor (int i = 0; i < DEFAULT_FOLDERS.length; i++) {\n\t\t\t\tif (DEFAULT_FOLDERS[i].equals(oldFolderName)) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Folder \" + oldFolderName +\n\t\t\t\t\t\t\t\t\" is a system folder and cannot be changed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t\telse if (DEFAULT_FOLDERS[i].equals(newFolderName)) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Folder \" + newFolderName +\n\t\t\t\t\t\t\t\t\" is a system folder and cannot be changed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStore store = _getStore(ses);\n\n\t\t\tFolder oldFolder = store.getFolder(oldFolderName);\n\t\t\tFolder newFolder = store.getFolder(newFolderName);\n\n\t\t\tif (!oldFolder.exists()) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(\"Folder \" + oldFolderName + \" does not exist\");\n\t\t\t\t}\n\n\t\t\t\tthrow new FolderException();\n\t\t\t}\n\t\t\telse if (newFolder.exists()) {\n\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t_log.error(\"Folder \" + newFolderName + \" already exists\");\n\t\t\t\t}\n\n\t\t\t\tthrow new FolderException();\n\t\t\t}\n\n\t\t\tif (!oldFolder.isOpen()) {\n\t\t\t\toldFolder.open(Folder.READ_WRITE);\n\t\t\t}\n\n\t\t\toldFolder.renameTo(newFolder);\n\n\t\t\ttry {\n\t\t\t\tMailSessionLock.lock(ses.getId());\n\n\t\t\t\tFolder curFolder = _getFolder(ses);\n\n\t\t\t\tString folderName = _getResolvedFolderName(curFolder.getName());\n\n\t\t\t\tif (folderName.equals(oldFolderName)) {\n\t\t\t\t\tsetFolder(ses, newFolderName);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tMailSessionLock.unlock(ses.getId());\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t}","id":24243,"modified_method":"public static void renameFolder(\n\t\t\tHttpSession ses, String oldFolderName, String newFolderName)\n\t\tthrows FolderException, StoreException {\n\n\t\ttry {\n\t\t\toldFolderName = _getResolvedFolderName(oldFolderName);\n\t\t\tnewFolderName = _getResolvedFolderName(newFolderName);\n\n\t\t\tfor (int i = 0; i < DEFAULT_FOLDERS.length; i++) {\n\t\t\t\tif (DEFAULT_FOLDERS[i].equals(oldFolderName)) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Folder \" + oldFolderName +\n\t\t\t\t\t\t\t\t\" is a system folder and cannot be changed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t\telse if (DEFAULT_FOLDERS[i].equals(newFolderName)) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\n\t\t\t\t\t\t\t\"Folder \" + newFolderName +\n\t\t\t\t\t\t\t\t\" is a system folder and cannot be changed\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tMailSessionLock.lock(ses.getId());\n\n\t\t\t\tsetFolder(ses, MAIL_INBOX_NAME);\n\n\t\t\t\tStore store = _getStore(ses);\n\n\t\t\t\tFolder oldFolder = store.getFolder(oldFolderName);\n\t\t\t\tFolder newFolder = store.getFolder(newFolderName);\n\n\t\t\t\tif (!oldFolder.exists()) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\"Folder \" + oldFolderName + \" does not exist\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\t\t\t\telse if (newFolder.exists()) {\n\t\t\t\t\tif (_log.isErrorEnabled()) {\n\t\t\t\t\t\t_log.error(\"Folder \" + newFolderName + \" already exists\");\n\t\t\t\t\t}\n\n\t\t\t\t\tthrow new FolderException();\n\t\t\t\t}\n\n\t\t\t\toldFolder.renameTo(newFolder);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tMailSessionLock.unlock(ses.getId());\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t}","commit_id":"22b57a517642638d128e2ed17f8aa8e0fad3e630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List getFolders(HttpSession ses)\n\t\tthrows FolderException, StoreException {\n\n\t\tList list = new ArrayList();\n\n\t\tIMAPFolder root = null;\n\n\t\ttry {\n\t\t\tStore store = _getStore(ses);\n\n\t\t\troot = (IMAPFolder)store.getDefaultFolder();\n\n\t\t\tFolder[] folders = root.list();\n\n\t\t\t_getFolders(list, folders);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ((root != null) && root.isOpen()) {\n\t\t\t\t\troot.close(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","id":24244,"modified_method":"public static List getFolders(HttpSession ses)\n\t\tthrows FolderException, StoreException {\n\n\t\tList list = new ArrayList();\n\n\t\tIMAPFolder root = null;\n\n\t\ttry {\n\t\t\tList l = new ArrayList();\n\n\t\t\tStore store = _getStore(ses);\n\n\t\t\troot = (IMAPFolder)store.getDefaultFolder();\n\n\t\t\tFolder[] folders = root.list();\n\n\t\t\t_getFolders(l, folders);\n\n\t\t\tfor (int i = 0; i < DEFAULT_FOLDERS.length; i++) {\n\t\t\t\tfor (ListIterator itr = l.listIterator(); itr.hasNext(); ) {\n\t\t\t\t\tMailFolder mf = (MailFolder)itr.next();\n\n\t\t\t\t\tif (DEFAULT_FOLDERS[i].equals(\n\t\t\t\t\t\t_getResolvedFolderName(mf.getName()))) {\n\n\t\t\t\t\t\tlist.add(mf);\n\n\t\t\t\t\t\titr.remove();\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlist.addAll(l);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ((root != null) && root.isOpen()) {\n\t\t\t\t\troot.close(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t}\n\t\t}\n\n\t\treturn list;\n\t}","commit_id":"22b57a517642638d128e2ed17f8aa8e0fad3e630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void createFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\tFolder folder = null;\n\n\t\ttry {\n\t\t\tIterator itr = getFolders(ses).iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tMailFolder mailFolder = (MailFolder)itr.next();\n\n\t\t\t\tif (mailFolder.getName().equals(folderName)) {\n\t\t\t\t\tthrow new FolderException(\n\t\t\t\t\t\t\"Folder \" + folderName + \" already exists\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStore store = _getStore(ses);\n\n\t\t\tfolderName = _getResolvedFolderName(folderName);\n\n\t\t\tfolder = store.getFolder(folderName);\n\n\t\t\tfolder.create(Folder.HOLDS_MESSAGES);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ((folder != null) && folder.isOpen()) {\n\t\t\t\t\tfolder.close(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\t\t}\n\t}","id":24245,"modified_method":"public static void createFolder(HttpSession ses, String folderName)\n\t\tthrows FolderException, StoreException {\n\n\t\tFolder folder = null;\n\n\t\ttry {\n\t\t\tMailSessionLock.lock(ses.getId());\n\n\t\t\tIterator itr = getFolders(ses).iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tMailFolder mailFolder = (MailFolder)itr.next();\n\n\t\t\t\tif (mailFolder.getName().equals(folderName)) {\n\t\t\t\t\tthrow new FolderException(\n\t\t\t\t\t\t\"Folder \" + folderName + \" already exists\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tStore store = _getStore(ses);\n\n\t\t\tfolderName = _getResolvedFolderName(folderName);\n\n\t\t\tfolder = store.getFolder(folderName);\n\n\t\t\tfolder.create(Folder.HOLDS_MESSAGES);\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tthrow new FolderException(me);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif ((folder != null) && folder.isOpen()) {\n\t\t\t\t\tfolder.close(false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t}\n\n\t\t\tMailSessionLock.unlock(ses.getId());\n\t\t}\n\t}","commit_id":"22b57a517642638d128e2ed17f8aa8e0fad3e630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ApiValidatorHandler(ValidatorInfo defaultValidator, List<ValidatorInfo> validators) {\n        this.validators = new ArrayList<ValidatorInfo>(validators.size());\n        if (validators != null) {\n            this.validators.addAll(validators);\n        }\n        this.defaultValidator = defaultValidator;\n\n    }","id":24246,"modified_method":"public ApiValidatorHandler(ValidatorInfo defaultValidator, List<ValidatorInfo> validators, boolean  multiRoleMatch) {\n        this.validators = new ArrayList<ValidatorInfo>(validators.size());\n        if (validators != null) {\n            this.validators.addAll(validators);\n        }\n        this.multiRoleMatch=multiRoleMatch;\n        this.defaultValidator = defaultValidator;\n       \n    }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public FilterDirector handleRequest(HttpServletRequest request, ReadableHttpServletResponse response) {\n        final FilterDirector myDirector = new FilterDirectorImpl();\n        myDirector.setFilterAction(FilterAction.PASS);\n        MutableHttpServletRequest mutableRequest = MutableHttpServletRequest.wrap(request);\n\n        List<HeaderValue> roles = mutableRequest.getPreferredHeaderValues(OpenStackServiceHeader.ROLES.toString(), new HeaderValueImpl(\"\"));\n        ValidatorInfo validatorInfo = getValidatorForRole(roles);\n\n        if (validatorInfo != null) {\n            myDirector.setFilterAction(FilterAction.RETURN);\n\n            Validator validator = validatorInfo.getValidator();\n            if (validator == null) {\n                LOG.warn(\"Validator not available for request:\", validatorInfo.getUri());\n                myDirector.setResponseStatus(HttpStatusCode.BAD_GATEWAY);\n            } else {\n                try {\n                    validator.validate(request, response, chain);\n                    myDirector.setResponseStatusCode(response.getStatus());\n                } catch (Throwable t) {\n                    LOG.error(\"Some error\", t);\n                    myDirector.setResponseStatus(HttpStatusCode.BAD_GATEWAY);\n                }\n            }\n        }\n\n        return myDirector;\n    }","id":24247,"modified_method":"@Override\n    public FilterDirector handleRequest(HttpServletRequest request, ReadableHttpServletResponse response) {\n        final FilterDirector myDirector = new FilterDirectorImpl();\n        myDirector.setFilterAction(FilterAction.PASS);\n        MutableHttpServletRequest mutableRequest = MutableHttpServletRequest.wrap(request);\n        boolean isValid=false;\n        List<HeaderValue> listRoles = mutableRequest.getPreferredHeaderValues(OpenStackServiceHeader.ROLES.toString(), new HeaderValueImpl(\"\"));\n  \n        \n        \n       Result lastValidatorResult=null;\n               \n       \n       if (validators != null) {\n           List<ValidatorInfo> matchedValidators=getValidatorsForRole(listRoles);\n         \n            for (ValidatorInfo validatorInfo : matchedValidators) {\n                                    \n                    Validator validator= validatorInfo.getValidator();\n                    if(validator ==null){\n                         LOG.warn(\"Validator not available for request:\", validatorInfo.getUri());\n                         myDirector.setResponseStatus(HttpStatusCode.BAD_GATEWAY);\n                         \n                    } else{\n                          try {                                \n                                 myDirector.setFilterAction(FilterAction.RETURN);\n\n                                 lastValidatorResult= validator.validate(request, response, chain);\n                                 isValid= lastValidatorResult.valid();\n                                 myDirector.setResponseStatusCode(response.getStatus());\n                                 \n                                 if(isValid){\n                                     \n                                     break;\n                                 }\n                              \n                             } catch (Throwable t) {\n\n                                 LOG.error(\"Some error\", t);\n                                 myDirector.setResponseStatus(HttpStatusCode.BAD_GATEWAY);\n                            }\n                        \n                    }\n            \n            }\n      \n     \n       if(!isValid && multiRoleMatch){\n\n            try{ \n                 if(lastValidatorResult!=null && lastValidatorResult instanceof MultiFailResult){\n\n                      ErrorResult validatorMultiErrors= (ErrorResult)((MultiFailResult)lastValidatorResult).reduce().get();\n                      myDirector.setResponseStatusCode(validatorMultiErrors.code());\n                      response.sendError(validatorMultiErrors.code(), validatorMultiErrors.message());\n\n                    }else if(lastValidatorResult!=null && lastValidatorResult instanceof ErrorResult) {\n\n                      myDirector.setResponseStatusCode(((ErrorResult)lastValidatorResult).code());\n                      response.sendError(((ErrorResult)lastValidatorResult).code(), ((ErrorResult)lastValidatorResult).message());\n\n                  }\n               }catch (Throwable t) {\n\n                     LOG.error(\"Some error\", t);\n                     myDirector.setResponseStatus(HttpStatusCode.BAD_GATEWAY);\n               }\n           }\n           \n       \n \n       }\n        return myDirector;\n    }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"protected ValidatorInfo getValidatorForRole(List<? extends HeaderValue> roles) {\n\n        if (validators != null) {\n            for (ValidatorInfo validator : validators) {\n                for (HeaderValue role : roles) {\n                   if (validator.getRole().equals(role.getValue())) {\n                      return validator;\n                    }\n                }\n            }\n        }\n\n        return defaultValidator;\n    }","id":24248,"modified_method":"protected List<ValidatorInfo> getValidatorsForRole(List<? extends HeaderValue> listRoles) {\n\n       Set<String> roles=new HashSet();\n       List<ValidatorInfo> matchedValidators=new ArrayList<ValidatorInfo>();\n        \n       Iterator it = listRoles.iterator();\n        while (it.hasNext()) {\n            roles.add(((HeaderValue)it.next()).getValue());\n        \n        }\n        \n        if (validators != null) {\n            for (ValidatorInfo validator : validators) {\n                 if(roles.contains(validator.getRole())){\n                 \n                           matchedValidators.add(validator);\n                            if(!multiRoleMatch){\n                                break;\n              \n                  \n                   }\n                }\n            }\n        }\n        \n        if(!multiRoleMatch && matchedValidators.isEmpty() && defaultValidator!=null){\n            matchedValidators.add(defaultValidator);\n        }\n        if(multiRoleMatch && defaultValidator!=null && !matchedValidators.contains(defaultValidator)){\n            matchedValidators.add(defaultValidator);\n        }\n        \n        return matchedValidators;\n    }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    protected ApiValidatorHandler buildHandler() {\n        initialize();\n        if (!initialized) {\n            return null;\n        }\n        return new ApiValidatorHandler(defaultValidator, validators);\n    }","id":24249,"modified_method":"@Override\n    protected ApiValidatorHandler buildHandler() {\n        initialize();\n        if (!initialized) {\n            return null;\n        }\n        return new ApiValidatorHandler(defaultValidator, validators, multiRoleMatch);\n    }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"void initialize() {\n        synchronized (lock) {\n            if (initialized || validatorConfiguration == null) {\n                return;\n            }\n\n            validators = new ArrayList<ValidatorInfo>(validatorConfiguration.getValidator().size());\n            defaultValidator = null;\n\n            for (ValidatorItem validatorItem : validatorConfiguration.getValidator()) {\n                Config config = new Config();\n                config.setResultHandler(getHandlers(validatorItem));\n                config.setUseSaxonEEValidation(validatorItem.isUseSaxon());\n                config.setCheckWellFormed(validatorItem.isCheckWellFormed());\n                config.setCheckXSDGrammar(validatorItem.isCheckXsdGrammar());\n                config.setCheckElements(validatorItem.isCheckElements());\n                config.setXPathVersion(validatorItem.getXpathVersion());\n\n                config.setCheckPlainParams(validatorItem.isCheckPlainParams());\n                config.setDoXSDGrammarTransform(validatorItem.isDoXsdGrammarTransform());\n                config.setEnablePreProcessExtension(validatorItem.isEnablePreProcessExtension());\n                config.setRemoveDups(validatorItem.isRemoveDups());\n                config.setValidateChecker(validatorItem.isValidateChecker());\n                config.setXSLEngine(validatorItem.getXslEngine().value());\n                config.setJoinXPathChecks(validatorItem.isJoinXpathChecks());\n\n                ValidatorInfo validator = new ValidatorInfo(validatorItem.getRole(), getWadlPath(validatorItem.getWadl()), config);\n                validators.add (validator);\n                if (validatorItem.isDefault() && defaultValidator == null) {\n                    defaultValidator = validator;\n                }\n            }\n\n            for (ValidatorInfo validator : validators) {\n                addListener(validator.getUri());\n            }\n\n            initialized = true;\n        }\n    }","id":24250,"modified_method":"void initialize() {\n        synchronized (lock) {\n            if (initialized || validatorConfiguration == null) {\n                return;\n            }\n\n            validators = new ArrayList<ValidatorInfo>(validatorConfiguration.getValidator().size());\n            defaultValidator = null;\n            multiRoleMatch=validatorConfiguration.isMultiRoleMatch();\n\n            for (ValidatorItem validatorItem : validatorConfiguration.getValidator()) {\n                Config config = new Config();\n                config.setResultHandler(getHandlers(validatorItem));\n                config.setUseSaxonEEValidation(validatorItem.isUseSaxon());\n                config.setCheckWellFormed(validatorItem.isCheckWellFormed());\n                config.setCheckXSDGrammar(validatorItem.isCheckXsdGrammar());\n                config.setCheckElements(validatorItem.isCheckElements());\n                config.setXPathVersion(validatorItem.getXpathVersion());\n\n                config.setCheckPlainParams(validatorItem.isCheckPlainParams());\n                config.setDoXSDGrammarTransform(validatorItem.isDoXsdGrammarTransform());\n                config.setEnablePreProcessExtension(validatorItem.isEnablePreProcessExtension());\n                config.setRemoveDups(validatorItem.isRemoveDups());\n                config.setValidateChecker(validatorItem.isValidateChecker());\n                config.setXSLEngine(validatorItem.getXslEngine().value());\n                config.setJoinXPathChecks(validatorItem.isJoinXpathChecks());\n\n                ValidatorInfo validator = new ValidatorInfo(validatorItem.getRole(), getWadlPath(validatorItem.getWadl()), config);\n                validators.add (validator);\n                if (validatorItem.isDefault() && defaultValidator == null) {\n                    defaultValidator = validator;\n                }\n            }\n\n            for (ValidatorInfo validator : validators) {\n                addListener(validator.getUri());\n            }\n\n            initialized = true;\n        }\n    }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"private DispatchHandler getHandlers(ValidatorItem validatorItem) {\n        List<ResultHandler> handlers = new ArrayList<ResultHandler>();\n        handlers.add(new ServletResultHandler());\n\n        if (StringUtilities.isNotBlank(validatorItem.getDotOutput())) {\n            final String dotPath = StringUriUtilities.formatUri(getPath(validatorItem.getDotOutput()));\n            File out = new File(dotPath);\n            try {\n                if (out.exists() && out.canWrite() || !out.exists() && out.createNewFile()) {\n                    handlers.add(new SaveDotHandler(out, true, true));\n                } else {\n                    LOG.warn(\"Cannot write to DOT file: \" + dotPath);\n                }\n            } catch (IOException ex) {\n                LOG.warn(\"Cannot write to DOT file: \" + dotPath, ex);\n            }\n        }\n        return new DispatchHandler(handlers.toArray(new ResultHandler[handlers.size()]));\n    }","id":24251,"modified_method":"private DispatchHandler getHandlers(ValidatorItem validatorItem) {\n        List<ResultHandler> handlers = new ArrayList<ResultHandler>();\n        \n        if(!multiRoleMatch){\n            handlers.add(new ServletResultHandler());\n        }\n        \n\n        if (StringUtilities.isNotBlank(validatorItem.getDotOutput())) {\n            final String dotPath = StringUriUtilities.formatUri(getPath(validatorItem.getDotOutput()));\n            File out = new File(dotPath);\n            try {\n                if (out.exists() && out.canWrite() || !out.exists() && out.createNewFile()) {\n                    handlers.add(new SaveDotHandler(out, true, true));\n                } else {\n                    LOG.warn(\"Cannot write to DOT file: \" + dotPath);\n                }\n            } catch (IOException ex) {\n                LOG.warn(\"Cannot write to DOT file: \" + dotPath, ex);\n            }\n        }\n        return new DispatchHandler(handlers.toArray(new ResultHandler[handlers.size()]));\n    }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Test\n        public void shouldSetDefaultValidator() {\n            ApiValidatorHandler handler = instance.buildHandler();\n            assertNotNull(\"Should build handler\", handler);\n            ValidatorInfo validatorForRole = handler.getValidatorForRole(new ArrayList<HeaderValue>());\n            assertNotNull(validatorForRole);\n            assertEquals(\"Should get validator for default role\", defaultRole, validatorForRole.getRole());\n        }","id":24252,"modified_method":"@Test\n        public void shouldSetDefaultValidator() {\n            ApiValidatorHandler handler = instance.buildHandler();\n            assertNotNull(\"Should build handler\", handler);\n            List<ValidatorInfo> validatorsForRole = handler.getValidatorsForRole(new ArrayList<HeaderValue>());\n            assertNotNull(validatorsForRole);\n            assertEquals(\"Should get validator for default role\", defaultRole, validatorsForRole.get(0).getRole());\n        }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Test\n        public void shouldBuildValidatorListAndSubscribeToWadl() {\n            ApiValidatorHandler handler = instance.buildHandler();\n            assertNotNull(\"Should build handler\", handler);\n            ValidatorInfo validatorForRole = handler.getValidatorForRole(roles);\n            assertNotNull(validatorForRole);\n            assertEquals(\"Should get validator for role\", role, validatorForRole.getRole());\n            verify(configService, times(2)).subscribeTo(eq(instance.getWadlPath(wadl)), any(ApiValidatorHandlerFactory.ApiValidatorWadlListener.class), any(GenericResourceConfigurationParser.class));\n        }","id":24253,"modified_method":"@Test\n        public void shouldBuildValidatorListAndSubscribeToWadl() {\n            ApiValidatorHandler handler = instance.buildHandler();\n            assertNotNull(\"Should build handler\", handler);\n            List<ValidatorInfo> validatorsForRole = handler.getValidatorsForRole(roles);\n            assertNotNull(validatorsForRole);\n            \n            for(ValidatorInfo validatorForRole : validatorsForRole){\n             assertEquals(\"Should get validator for role\", role, validatorForRole.getRole());\n            }\n            verify(configService, times(2)).subscribeTo(eq(instance.getWadlPath(wadl)), any(ApiValidatorHandlerFactory.ApiValidatorWadlListener.class), any(GenericResourceConfigurationParser.class));\n        }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Before\n        public void setup() {\n            chain = mock(FilterChain.class);\n            request = mock(MutableHttpServletRequest.class);\n            response = mock(MutableHttpServletResponse.class);\n\n            defaultValidator = mock(Validator.class);\n            defaultValidatorInfo = new ValidatorInfo(\"defaultrole\", \"defaultwadl\", null);\n            defaultValidatorInfo.setValidator(defaultValidator);\n            \n            role1Validator = mock(Validator.class);\n            role1ValidatorInfo = new ValidatorInfo(\"role1\", \"role1wadl\", null);\n            role1ValidatorInfo.setValidator(role1Validator);\n            \n            role2Validator = mock(Validator.class);\n            role2ValidatorInfo = new ValidatorInfo(\"role2\", \"role2wadl\", null);\n            role2ValidatorInfo.setValidator(role2Validator);\n            \n            nullValidatorInfo = mock(ValidatorInfo.class);\n            when(nullValidatorInfo.getRole()).thenReturn(\"nullValidator\");\n            when(nullValidatorInfo.getValidator()).thenReturn(null);\n            \n            blowupValidator = mock(Validator.class);\n            when(blowupValidator.validate(request, response, chain)).thenThrow(new RuntimeException(\"Test\"));\n            blowupValidatorInfo = new ValidatorInfo(\"blowupValidator\", \"blowupWadl\", null);\n            blowupValidatorInfo.setValidator(blowupValidator);\n\n            List<ValidatorInfo> validators = new ArrayList<ValidatorInfo>();\n            validators.add(defaultValidatorInfo);\n            validators.add(role1ValidatorInfo);\n            validators.add(role2ValidatorInfo);\n            validators.add(nullValidatorInfo);\n            validators.add(blowupValidatorInfo);\n            \n            instance = new ApiValidatorHandler(defaultValidatorInfo, validators);\n            instance.setFilterChain(chain);\n\n        }","id":24254,"modified_method":"@Before\n        public void setup() {\n            chain = mock(FilterChain.class);\n            request = mock(MutableHttpServletRequest.class);\n            response = mock(MutableHttpServletResponse.class);\n\n            defaultValidator = mock(Validator.class);\n            defaultValidatorInfo = new ValidatorInfo(\"defaultrole\", \"defaultwadl\", null);\n            defaultValidatorInfo.setValidator(defaultValidator);\n            \n            role1Validator = mock(Validator.class);\n            role1ValidatorInfo = new ValidatorInfo(\"role1\", \"role1wadl\", null);\n            role1ValidatorInfo.setValidator(role1Validator);\n            \n            role2Validator = mock(Validator.class);\n            role2ValidatorInfo = new ValidatorInfo(\"role2\", \"role2wadl\", null);\n            role2ValidatorInfo.setValidator(role2Validator);\n            \n            nullValidatorInfo = mock(ValidatorInfo.class);\n            when(nullValidatorInfo.getRole()).thenReturn(\"nullValidator\");\n            when(nullValidatorInfo.getValidator()).thenReturn(null);\n            \n            blowupValidator = mock(Validator.class);\n            when(blowupValidator.validate(request, response, chain)).thenThrow(new RuntimeException(\"Test\"));\n            blowupValidatorInfo = new ValidatorInfo(\"blowupValidator\", \"blowupWadl\", null);\n            blowupValidatorInfo.setValidator(blowupValidator);\n\n            List<ValidatorInfo> validators = new ArrayList<ValidatorInfo>();\n            validators.add(defaultValidatorInfo);\n            validators.add(role1ValidatorInfo);\n            validators.add(role2ValidatorInfo);\n            validators.add(nullValidatorInfo);\n            validators.add(blowupValidatorInfo);\n            \n            instance = new ApiValidatorHandler(defaultValidatorInfo, validators, false);\n            instance.setFilterChain(chain);\n\n        }","commit_id":"182300cc89ad19cebac442da951df39d9b5390f7","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public Source resolve(String href, String base) throws TransformerException {\n\n        if (href != null && href.toLowerCase().startsWith(CLASSPATH_PREFIX)) {\n            String path = href.substring(CLASSPATH_PREFIX.length());\n            return new StreamSource(getClass().getResourceAsStream(path));\n        }\n        \n        return super.resolve(href, base);\n    }","id":24255,"modified_method":"@Override\n    public Source resolve(String href, String base) throws TransformerException {\n\n        if (href != null && href.toLowerCase().startsWith(CLASSPATH_PREFIX)) {\n            String path = href.substring(CLASSPATH_PREFIX.length());\n            InputStream resource = getClass().getResourceAsStream(path);\n            if (resource == null) {\n                return null;\n            }\n            \n            return new StreamSource(resource);\n        }\n        \n        return super.resolve(href, base);\n    }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"public void removeStream(InputStream inputStreamReference) {\n        String key = getHref(inputStreamReference);\n        streams.remove(key);\n    }","id":24256,"modified_method":"public void removeStream(InputStream inputStreamReference) {\n        String key = getHref(inputStreamReference);\n        removeStream(key);\n    }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public Source resolve(String href, String base) throws TransformerException {\n        InputStream stream = streams.get(href);\n        if (stream != null) {\n            return new StreamSource(stream);\n        }\n\n        if (!resolvers.isEmpty()) {\n            for (URIResolver resolver : resolvers) {\n                Source source = resolver.resolve(href, base);\n                if (source != null) {\n                    return source;\n                }\n            }\n\n            return null;\n        }\n        \n        return super.resolve(href, base);\n    }","id":24257,"modified_method":"@Override\n    public Source resolve(String href, String base) throws TransformerException {\n        InputStream stream = streams.get(href);\n        if (stream != null) {\n            return new StreamSource(stream);\n        }\n\n        if (!resolvers.isEmpty()) {\n            for (URIResolver resolver : resolvers) {\n                Source source = resolver.resolve(href, base);\n                if (source != null) {\n                    return source;\n                }\n            }\n\n        }\n        \n        return super.resolve(href, base);\n    }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"private XsltHandlerChainPool getHandlerChainPool(String contentType, List<HeaderValue> accept, ArrayList<XsltHandlerChainPool> pools) {\n        for (HeaderValue value : accept) {\n            for (XsltHandlerChainPool pool : pools) {\n                if (pool.accepts(contentType, value.getValue())) {\n                    return pool;\n                }\n            }\n        }\n\n        return null;\n    }","id":24258,"modified_method":"private XmlFilterChainPool getHandlerChainPool(String method, MediaType contentType, List<MediaType> accept, String status, ArrayList<XmlFilterChainPool> pools) {\n        for (MediaType value : accept) {\n            for (XmlFilterChainPool pool : pools) {\n                if (pool.accepts(method, contentType, value, status)) {\n                    return pool;\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public FilterDirector handleResponse(HttpServletRequest httpRequest, ReadableHttpServletResponse httpResponse) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        MutableHttpServletResponse response = MutableHttpServletResponse.wrap(httpRequest, httpResponse);\n        final FilterDirector filterDirector = new FilterDirectorImpl();\n\n        String contentType = response.getHeader(\"content-type\");\n        List<HeaderValue> acceptValues = request.getPreferredHeaderValues(\"Accept\");\n        XsltHandlerChainPool pool = getHandlerChainPool(contentType, acceptValues, responseProcessors);\n\n        if (pool != null) {\n            try {\n                final InputStream in = response.getBufferedOutputAsInputStream();\n                //final ByteBuffer internalBuffer = new CyclicByteBuffer(DEFAULT_BUFFER_SIZE, true);\n                //final ByteBufferServletOutputStream out = new ByteBufferServletOutputStream(internalBuffer);\n                final OutputStream out = filterDirector.getResponseOutputStream();\n                \n                pool.getPool().use(new SimpleResourceContext<XsltHandlerChain>() {\n                    @Override\n                    public void perform(XsltHandlerChain chain) throws ResourceContextException {\n                        chain.executeChain(in, out, null, null);\n                    }\n                });\n                response.setContentType(pool.getResultContentType());\n                filterDirector.setResponseStatusCode(response.getStatus());\n            } catch (IOException ex) {\n                Logger.getLogger(TranslationHandler.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n\n        filterDirector.setFilterAction(FilterAction.PASS);\n\n        return filterDirector;\n\n    }","id":24259,"modified_method":"@Override\n    public FilterDirector handleResponse(HttpServletRequest httpRequest, ReadableHttpServletResponse httpResponse) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        MutableHttpServletResponse response = MutableHttpServletResponse.wrap(httpRequest, httpResponse);\n        final FilterDirector filterDirector = new FilterDirectorImpl();\n        filterDirector.setFilterAction(FilterAction.PASS);\n\n        MediaRangeProcessor processor = new MediaRangeProcessor(request.getPreferredHeaderValues(\"Accept\", DEFAULT_TYPE));\n        MimeType contentMimeType = MimeType.getMatchingMimeType(response.getHeader(\"content-type\"));\n        MediaType contentType = new MediaType(contentMimeType);\n        List<MediaType> acceptValues = processor.process();\n\n        XmlFilterChainPool pool = getHandlerChainPool(\"\", contentType, acceptValues, String.valueOf(response.getStatus()), responseProcessors);\n\n        if (pool != null) {\n            try {\n                executePool(request, response, pool, response.getBufferedOutputAsInputStream(), filterDirector.getResponseOutputStream());\n                response.setContentType(pool.getResultContentType());\n                filterDirector.setResponseStatusCode(response.getStatus());\n            } catch (XsltFilterException ex) {\n                LOG.error(\"Error executing response transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                response.setContentLength(0);\n            } catch (IOException ex) {\n                LOG.error(\"Error executing response transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                response.setContentLength(0);\n            }\n        } else {\n            filterDirector.setResponseStatusCode(response.getStatus());\n        }\n\n        return filterDirector;\n    }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n    public FilterDirector handleRequest(HttpServletRequest httpRequest, ReadableHttpServletResponse response) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        FilterDirector filterDirector = new FilterDirectorImpl();\n\n        String contentType = request.getContentType();\n        List<HeaderValue> acceptValues = request.getPreferredHeaderValues(\"Accept\");\n        XsltHandlerChainPool pool = getHandlerChainPool(contentType, acceptValues, requestProcessors);\n\n        if (pool != null) {\n            try {\n                final InputStream in = request.getInputStream();\n                final ByteBuffer internalBuffer = new CyclicByteBuffer(DEFAULT_BUFFER_SIZE, true);\n                final ByteBufferServletOutputStream out = new ByteBufferServletOutputStream(internalBuffer);\n                pool.getPool().use(new SimpleResourceContext<XsltHandlerChain>() {\n                    @Override\n                    public void perform(XsltHandlerChain chain) throws ResourceContextException {\n                        chain.executeChain(in, out, null, null);\n                    }\n                });\n                request.setInputStream(new ByteBufferServletInputStream(internalBuffer));\n                filterDirector.requestHeaderManager().putHeader(\"content-type\", pool.getResultContentType());\n            } catch (IOException ex) {\n                Logger.getLogger(TranslationHandler.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n\n        filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE);\n\n        return filterDirector;\n    }","id":24260,"modified_method":"@Override\n    public FilterDirector handleRequest(HttpServletRequest httpRequest, ReadableHttpServletResponse httpResponse) {\n        MutableHttpServletRequest request = MutableHttpServletRequest.wrap(httpRequest);\n        MutableHttpServletResponse response = MutableHttpServletResponse.wrap(httpRequest, httpResponse);\n        FilterDirector filterDirector = new FilterDirectorImpl();\n\n        MediaRangeProcessor processor = new MediaRangeProcessor(request.getPreferredHeaderValues(\"Accept\", DEFAULT_TYPE));\n        MimeType contentMimeType = MimeType.getMatchingMimeType(request.getHeader(\"content-type\"));\n        MediaType contentType = new MediaType(contentMimeType);\n        List<MediaType> acceptValues = processor.process();\n        XmlFilterChainPool pool = getHandlerChainPool(request.getMethod(), contentType, acceptValues, \"\", requestProcessors);\n\n        if (pool != null) {\n            try {\n                final ByteBuffer internalBuffer = new CyclicByteBuffer(DEFAULT_BUFFER_SIZE, true);\n                executePool(request, response, pool, request.getInputStream(), new ByteBufferServletOutputStream(internalBuffer));\n                request.setInputStream(new ByteBufferServletInputStream(internalBuffer));\n                filterDirector.requestHeaderManager().putHeader(\"content-type\", pool.getResultContentType());\n                filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE);\n            } catch (XsltFilterException ex) {\n                LOG.error(\"Error executing request transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                filterDirector.setFilterAction(FilterAction.RETURN);\n            } catch (IOException ex) {\n                LOG.error(\"Error executing request transformer chain\", ex);\n                filterDirector.setResponseStatus(HttpStatusCode.INTERNAL_SERVER_ERROR);\n                filterDirector.setFilterAction(FilterAction.RETURN);\n            }\n        } else {\n            filterDirector.setFilterAction(FilterAction.PROCESS_RESPONSE);\n        }\n\n\n        return filterDirector;\n    }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"public TranslationHandler(TranslationConfig translationConfig, ArrayList<XsltHandlerChainPool> requestProcessors, ArrayList<XsltHandlerChainPool> responseProcessors) {\n        this.config = translationConfig;\n        this.requestProcessors = requestProcessors;\n        this.responseProcessors = responseProcessors;\n        //postProcessor = new RequestStreamPostProcessor();\n    }","id":24261,"modified_method":"public TranslationHandler(TranslationConfig translationConfig, ArrayList<XmlFilterChainPool> requestProcessors, ArrayList<XmlFilterChainPool> responseProcessors) {\n        this.config = translationConfig;\n        this.requestProcessors = requestProcessors;\n        this.responseProcessors = responseProcessors;\n    }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"public TranslationHandlerFactory() {\n        transformerFactory = (SAXTransformerFactory) TransformerFactory.newInstance();\n        xsltChainBuilder = new XsltHandlerChainBuilder(transformerFactory);\n        requestProcessors = new ArrayList<XsltHandlerChainPool>();\n        responseProcessors = new ArrayList<XsltHandlerChainPool>();\n        \n    }","id":24262,"modified_method":"public TranslationHandlerFactory() {\n        transformerFactory = (SAXTransformerFactory) TransformerFactory.newInstance();\n        xsltChainBuilder = new XsltFilterChainBuilder(transformerFactory);\n        requestProcessors = new ArrayList<XmlFilterChainPool>();\n        responseProcessors = new ArrayList<XmlFilterChainPool>();\n\n    }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"@Override\n        public void configurationUpdated(TranslationConfig config) {\n            requestProcessors.clear();\n            responseProcessors.clear();\n\n            for (final ResponseTranslation translation : config.getResponseTranslations().getResponseTranslation()) {\n\n                Pool<XsltHandlerChain> pool = new GenericBlockingResourcePool<XsltHandlerChain>(\n                        new ConstructionStrategy<XsltHandlerChain>() {\n                            @Override\n                            public XsltHandlerChain construct() throws ResourceConstructionException {\n                                List<StyleSheetInfo> stylesheets = new ArrayList<StyleSheetInfo>();\n                                for (StyleSheet sheet : translation.getStyleSheets().getStyle()) {\n                                    stylesheets.add(new StyleSheetInfo(sheet.getId(), sheet.getHref()));\n                                }\n\n                                return xsltChainBuilder.build(stylesheets.toArray(new StyleSheetInfo[0]));\n                            }\n                        });\n                \n                responseProcessors.add(new XsltHandlerChainPool(translation.getContentType(), translation.getAccept(), translation.getTranslatedContentType(), pool));\n            }\n\n        }","id":24263,"modified_method":"@Override\n        public void configurationUpdated(TranslationConfig config) {\n            requestProcessors.clear();\n            responseProcessors.clear();\n\n            if (config.getResponseTranslations() != null) {\n                for (final ResponseTranslation translation : config.getResponseTranslations().getResponseTranslation()) {\n\n                    final List<Parameter> params = new ArrayList<Parameter>();\n                    Pool<XsltFilterChain> pool = new GenericBlockingResourcePool<XsltFilterChain>(\n                            new ConstructionStrategy<XsltFilterChain>() {\n                                @Override\n                                public XsltFilterChain construct() throws ResourceConstructionException {\n                                    List<StyleSheetInfo> stylesheets = new ArrayList<StyleSheetInfo>();\n                                    for (StyleSheet sheet : translation.getStyleSheets().getStyle()) {\n                                        stylesheets.add(new StyleSheetInfo(sheet.getId(), sheet.getHref()));\n                                        for (StyleParam param: sheet.getParam()) {\n                                            params.add(new Parameter<String>(sheet.getId(), param.getName(), param.getValue()));\n                                        }\n                                    }\n\n                                    return xsltChainBuilder.build(stylesheets.toArray(new StyleSheetInfo[0]));\n                                }\n                            });\n\n                    responseProcessors.add(new XmlFilterChainPool(\n                            translation.getContentType(),\n                            translation.getAccept(),\n                            translation.getCodeRegex(),\n                            translation.getTranslatedContentType(),\n                            params,\n                            pool));\n                }\n            }\n\n            if (config.getRequestTranslations() != null) {\n                for (final RequestTranslation translation : config.getRequestTranslations().getRequestTranslation()) {\n\n                    final List<Parameter> params = new ArrayList<Parameter>();\n                    Pool<XsltFilterChain> pool = new GenericBlockingResourcePool<XsltFilterChain>(\n                            new ConstructionStrategy<XsltFilterChain>() {\n                                @Override\n                                public XsltFilterChain construct() throws ResourceConstructionException {\n                                    List<StyleSheetInfo> stylesheets = new ArrayList<StyleSheetInfo>();\n                                    for (StyleSheet sheet : translation.getStyleSheets().getStyle()) {\n                                        stylesheets.add(new StyleSheetInfo(sheet.getId(), sheet.getHref()));\n                                        for (StyleParam param: sheet.getParam()) {\n                                            params.add(new Parameter<String>(sheet.getId(), param.getName(), param.getValue()));\n                                        }\n                                    }\n\n                                    return xsltChainBuilder.build(stylesheets.toArray(new StyleSheetInfo[0]));\n                                }\n                            });\n\n                    requestProcessors.add(new XmlFilterChainPool(\n                            translation.getContentType(),\n                            translation.getAccept(),\n                            translation.getHttpMethods(),\n                            translation.getTranslatedContentType(),\n                            params,\n                            pool));\n                }\n            }\n        }","commit_id":"3d6a90c41eb36dfc072b577e882ef95bf23a1265","url":"https://github.com/rackerlabs/repose"},{"original_method":"AuthorizableImpl(@Nonnull String id, @Nonnull Tree tree,\n                     @Nonnull UserManagerImpl userManager) throws RepositoryException {\n        checkValidTree(tree);\n\n        this.id = id;\n        this.userManager = userManager;\n\n        PropertyState pNameProp = tree.getProperty(REP_PRINCIPAL_NAME);\n        if (pNameProp != null) {\n            principalName = pNameProp.getValue(STRING);\n        } else {\n            String msg = \"Authorizable without principal name \" + id;\n            log.warn(msg);\n            //FIXME OAK-414 UserImport needs this workaround\n            //throw new RepositoryException(msg);\n            principalName = id;\n        }\n    }","id":24264,"modified_method":"AuthorizableImpl(@Nonnull String id, @Nonnull Tree tree,\n                     @Nonnull UserManagerImpl userManager) throws RepositoryException {\n        checkValidTree(tree);\n\n        this.id = id;\n        this.userManager = userManager;\n\n        PropertyState pNameProp = tree.getProperty(REP_PRINCIPAL_NAME);\n        if (pNameProp != null) {\n            principalName = pNameProp.getValue(STRING);\n        } else {\n            String msg = \"Authorizable without principal name \" + id;\n            log.warn(msg);\n            throw new RepositoryException(msg);\n        }\n    }","commit_id":"a55699a9031547f5675da37982c16b218f284a3a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n            throws RepositoryException {\n        Node parent = parents.peek();\n\n        // process node\n\n        Node node = null;\n        String id = nodeInfo.getUUID();\n        String nodeName = nodeInfo.getName();\n        String ntName = nodeInfo.getPrimaryTypeName();\n        String[] mixins = nodeInfo.getMixinTypeNames();\n\n        if (parent == null) {\n            log.debug(\"Skipping node: \" + nodeName);\n            // parent node was skipped, skip this child node too\n            parents.push(null); // push null onto stack for skipped node\n            // notify the p-i-importer\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n\n        if (parent.getDefinition().isProtected()) {\n            // skip protected node\n            parents.push(null);\n            log.debug(\"Skipping protected node: \" + nodeName);\n\n            if (pnImporter != null) {\n                // pnImporter was already started (current nodeInfo is a sibling)\n                // notify it about this child node.\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                // no importer defined yet:\n                // test if there is a ProtectedNodeImporter among the configured\n                // importers that can handle this.\n                // if there is one, notify the ProtectedNodeImporter about the\n                // start of a item tree that is protected by this parent. If it\n                // potentially is able to deal with it, notify it about the child node.\n                for (ProtectedItemImporter pni : pItemImporters) {\n                    if (pni instanceof ProtectedNodeImporter && ((ProtectedNodeImporter) pni).start(root.getTree(parent.getPath()))) {\n                        log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = (ProtectedNodeImporter) pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    } /* else: p-i-Importer isn't able to deal with the protected tree.\n                     try next. and if none can handle the passed parent the\n                     tree below will be skipped */\n                }\n            }\n            return;\n        }\n\n        if (parent.hasNode(nodeName)) {\n            // a node with that name already exists...\n            Node existing = parent.getNode(nodeName);\n            NodeDefinition def = existing.getDefinition();\n            if (!def.allowsSameNameSiblings()) {\n                // existing doesn't allow same-name siblings,\n                // check for potential conflicts\n                if (def.isProtected() && existing.isNodeType(ntName)) {\n                    /*\n                     use the existing node as parent for the possible subsequent\n                     import of a protected tree, that the protected node importer\n                     may or may not be able to deal with.\n                     -> upon the next 'startNode' the check for the parent being\n                        protected will notify the protected node importer.\n                     -> if the importer is able to deal with that node it needs\n                        to care of the complete subtree until it is notified\n                        during the 'endNode' call.\n                     -> if the import can't deal with that node or if that node\n                        is the a leaf in the tree to be imported 'end' will\n                        not have an effect on the importer, that was never started.\n                    */\n                    log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    return;\n                }\n                if (def.isAutoCreated() && existing.isNodeType(ntName)) {\n                    // this node has already been auto-created, no need to create it\n                    node = existing;\n                } else {\n                    // edge case: colliding node does have same uuid\n                    // (see http://issues.apache.org/jira/browse/JCR-1128)\n                    if (!(existing.getIdentifier().equals(id)\n                            && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING\n                            || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\n                        throw new ItemExistsException(\n                                \"Node with the same UUID exists:\" + existing);\n                    }\n                    // fall through\n                }\n            }\n        }\n\n        if (node == null) {\n            // create node\n            if (id == null) {\n                // no potential uuid conflict, always add new node\n                checkPermission(parent, nodeName);\n                node = createNode(parent, nodeName, ntName, mixins, id);\n            } else {\n                // potential uuid conflict\n                boolean isConflicting;\n                try {\n                    // the following is a fail-fast test whether\n                    // an item exists (regardless of access control)\n                    session.getNodeByIdentifier(id);\n                    isConflicting = true;\n                } catch (ItemNotFoundException e) {\n                    isConflicting = false;\n                } catch (RepositoryException e) {\n                    log.warn(\"Access Control Issues?\", e);\n                    isConflicting = true;\n                }\n\n                if (isConflicting) {\n                    // resolve uuid conflict\n                    node = resolveUUIDConflict(parent, id, nodeInfo);\n                    if (node == null) {\n                        // no new node has been created, so skip this node\n                        parents.push(null); // push null onto stack for skipped node\n                        log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    // create new with given uuid\n                    checkPermission(parent, nodeName);\n                    node = createNode(parent, nodeName, ntName, mixins, id);\n                }\n            }\n        }\n\n        // process properties\n\n        for (PropInfo pi : propInfos) {\n            // find applicable definition\n            //TODO find a proper way to get the EffectiveNodeTypeProvider\n            NodeTypeManager nodeTypeManager = session.getWorkspace().getNodeTypeManager();\n            if (nodeTypeManager instanceof EffectiveNodeTypeProvider) {\n                EffectiveNodeTypeProvider entp = (EffectiveNodeTypeProvider) nodeTypeManager;\n\n                //TODO find better heuristics?\n                PropertyDefinition def = pi.getPropertyDef(entp.getEffectiveNodeType(node));\n                if (def.isProtected()) {\n                    // skip protected property\n                    log.debug(\"Skipping protected property \" + pi.getName());\n\n                    // notify the ProtectedPropertyImporter.\n                    for (ProtectedItemImporter ppi : pItemImporters) {\n                        if (ppi instanceof ProtectedPropertyImporter && ((ProtectedPropertyImporter) ppi).handlePropInfo(root.getTree(node.getPath()), pi, def)) {\n                            log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                            break;\n                        } /* else: p-i-Importer isn't able to deal with this property.\n                             try next pp-importer */\n\n                    }\n                } else {\n                    // regular property -> create the property\n                    createProperty(node, pi, def);\n                }\n            } else {\n                log.warn(\"missing EffectiveNodeTypeProvider\");\n            }\n        }\n\n        parents.push(node);\n    }","id":24265,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n            throws RepositoryException {\n        Node parent = parents.peek();\n\n        // process node\n\n        Node node = null;\n        String id = nodeInfo.getUUID();\n        String nodeName = nodeInfo.getName();\n        String ntName = nodeInfo.getPrimaryTypeName();\n        String[] mixins = nodeInfo.getMixinTypeNames();\n\n        if (parent == null) {\n            log.debug(\"Skipping node: \" + nodeName);\n            // parent node was skipped, skip this child node too\n            parents.push(null); // push null onto stack for skipped node\n            // notify the p-i-importer\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n\n        if (parent.getDefinition().isProtected()) {\n            // skip protected node\n            parents.push(null);\n            log.debug(\"Skipping protected node: \" + nodeName);\n\n            if (pnImporter != null) {\n                // pnImporter was already started (current nodeInfo is a sibling)\n                // notify it about this child node.\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                // no importer defined yet:\n                // test if there is a ProtectedNodeImporter among the configured\n                // importers that can handle this.\n                // if there is one, notify the ProtectedNodeImporter about the\n                // start of a item tree that is protected by this parent. If it\n                // potentially is able to deal with it, notify it about the child node.\n                for (ProtectedItemImporter pni : pItemImporters) {\n                    if (pni instanceof ProtectedNodeImporter && ((ProtectedNodeImporter) pni).start(root.getTree(parent.getPath()))) {\n                        log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = (ProtectedNodeImporter) pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    } /* else: p-i-Importer isn't able to deal with the protected tree.\n                     try next. and if none can handle the passed parent the\n                     tree below will be skipped */\n                }\n            }\n            return;\n        }\n\n        if (parent.hasNode(nodeName)) {\n            // a node with that name already exists...\n            Node existing = parent.getNode(nodeName);\n            NodeDefinition def = existing.getDefinition();\n            if (!def.allowsSameNameSiblings()) {\n                // existing doesn't allow same-name siblings,\n                // check for potential conflicts\n                if (def.isProtected() && existing.isNodeType(ntName)) {\n                    /*\n                     use the existing node as parent for the possible subsequent\n                     import of a protected tree, that the protected node importer\n                     may or may not be able to deal with.\n                     -> upon the next 'startNode' the check for the parent being\n                        protected will notify the protected node importer.\n                     -> if the importer is able to deal with that node it needs\n                        to care of the complete subtree until it is notified\n                        during the 'endNode' call.\n                     -> if the import can't deal with that node or if that node\n                        is the a leaf in the tree to be imported 'end' will\n                        not have an effect on the importer, that was never started.\n                    */\n                    log.debug(\"Skipping protected node: \" + existing);\n                    parents.push(existing);\n                    return;\n                }\n                if (def.isAutoCreated() && existing.isNodeType(ntName)) {\n                    // this node has already been auto-created, no need to create it\n                    node = existing;\n                } else {\n                    // edge case: colliding node does have same uuid\n                    // (see http://issues.apache.org/jira/browse/JCR-1128)\n                    if (!(existing.getIdentifier().equals(id)\n                            && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING\n                            || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\n                        throw new ItemExistsException(\n                                \"Node with the same UUID exists:\" + existing);\n                    }\n                    // fall through\n                }\n            }\n        }\n\n        if (node == null) {\n            // create node\n            if (id == null) {\n                // no potential uuid conflict, always add new node\n                checkPermission(parent, nodeName);\n                node = createNode(parent, nodeName, ntName, mixins, id);\n            } else {\n                // potential uuid conflict\n                boolean isConflicting;\n                try {\n                    // the following is a fail-fast test whether\n                    // an item exists (regardless of access control)\n                    session.getNodeByIdentifier(id);\n                    isConflicting = true;\n                } catch (ItemNotFoundException e) {\n                    isConflicting = false;\n                } catch (RepositoryException e) {\n                    log.warn(\"Access Control Issues?\", e);\n                    isConflicting = true;\n                }\n\n                if (isConflicting) {\n                    // resolve uuid conflict\n                    node = resolveUUIDConflict(parent, id, nodeInfo);\n                    if (node == null) {\n                        // no new node has been created, so skip this node\n                        parents.push(null); // push null onto stack for skipped node\n                        log.debug(\"Skipping existing node \" + nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    // create new with given uuid\n                    checkPermission(parent, nodeName);\n                    node = createNode(parent, nodeName, ntName, mixins, id);\n                }\n            }\n        }\n\n        // process properties\n\n        //TODO remove hack that processes principal name first\n        int principalNameIndex = -1;\n        for (int k = 0; k < propInfos.size(); k++) {\n            PropInfo propInfo = propInfos.get(k);\n            if (\"rep:principalName\".equals(propInfo.getName())) {\n                principalNameIndex = k;\n                break;\n            }\n        }\n        if (principalNameIndex >= 0) {\n            propInfos.add(0, propInfos.remove(principalNameIndex));\n        }\n        for (PropInfo pi : propInfos) {\n            // find applicable definition\n            //TODO find a proper way to get the EffectiveNodeTypeProvider\n            NodeTypeManager nodeTypeManager = session.getWorkspace().getNodeTypeManager();\n            if (nodeTypeManager instanceof EffectiveNodeTypeProvider) {\n                EffectiveNodeTypeProvider entp = (EffectiveNodeTypeProvider) nodeTypeManager;\n\n                //TODO find better heuristics?\n                PropertyDefinition def = pi.getPropertyDef(entp.getEffectiveNodeType(node));\n                if (def.isProtected()) {\n                    // skip protected property\n                    log.debug(\"Skipping protected property \" + pi.getName());\n\n                    // notify the ProtectedPropertyImporter.\n                    for (ProtectedItemImporter ppi : pItemImporters) {\n                        if (ppi instanceof ProtectedPropertyImporter && ((ProtectedPropertyImporter) ppi).handlePropInfo(root.getTree(node.getPath()), pi, def)) {\n                            log.debug(\"Protected property -> delegated to ProtectedPropertyImporter\");\n                            break;\n                        } /* else: p-i-Importer isn't able to deal with this property.\n                             try next pp-importer */\n\n                    }\n                } else {\n                    // regular property -> create the property\n                    createProperty(node, pi, def);\n                }\n            } else {\n                log.warn(\"missing EffectiveNodeTypeProvider\");\n            }\n        }\n\n        parents.push(node);\n    }","commit_id":"a55699a9031547f5675da37982c16b218f284a3a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Test\n    public void testImportUser() throws RepositoryException, IOException, SAXException {\n            String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                    \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                    \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                    \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                    \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                    \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>t<\/sv:value><\/sv:property>\" +\n                    \"   <sv:property sv:name=\\\"rep:disabled\\\" sv:type=\\\"String\\\"><sv:value>disabledUser<\/sv:value><\/sv:property>\" +\n                    \"<\/sv:node>\";\n\n        Node parent = superuser.getNode(USERPATH);\n            try {\n                doImport(USERPATH, xml);\n\n                Authorizable newUser = userMgr.getAuthorizable(\"t\");\n                assertNotNull(newUser);\n                assertFalse(newUser.isGroup());\n                assertEquals(\"t\", newUser.getPrincipal().getName());\n                assertEquals(\"t\", newUser.getID());\n                assertTrue(((User) newUser).isDisabled());\n                assertEquals(\"disabledUser\", ((User) newUser).getDisabledReason());\n\n                Node n = superuser.getNode(newUser.getPath());\n                assertTrue(n.isNew());\n                assertTrue(n.getParent().isSame(parent));\n\n                assertEquals(\"t\", n.getName());\n                assertEquals(\"t\", n.getProperty(UserConstants.REP_PRINCIPAL_NAME).getString());\n                assertEquals(\"{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375\", n.getProperty(UserConstants.REP_PASSWORD).getString());\n                assertEquals(\"disabledUser\", n.getProperty(UserConstants.REP_DISABLED).getString());\n\n                // saving changes of the import -> must succeed. add mandatory\n                // props should have been created.\n                superuser.save();\n\n            } finally {\n                if (parent.hasNode(\"t\")) {\n                    parent.getNode(\"t\").remove();\n                    superuser.save();\n                }\n        }\n    }","id":24266,"modified_method":"@Test\n    public void testImportUser() throws RepositoryException, IOException, SAXException {\n            String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                    \"<sv:node sv:name=\\\"t\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                    \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:User<\/sv:value><\/sv:property>\" +\n                    \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>e358efa4-89f5-3062-b10d-d7316b65649e<\/sv:value><\/sv:property>\" +\n                    \"   <sv:property sv:name=\\\"rep:password\\\" sv:type=\\\"String\\\"><sv:value>{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375<\/sv:value><\/sv:property>\" +\n                    \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>t<\/sv:value><\/sv:property>\" +\n                    \"   <sv:property sv:name=\\\"rep:disabled\\\" sv:type=\\\"String\\\"><sv:value>disabledUser<\/sv:value><\/sv:property>\" +\n                    \"<\/sv:node>\";\n\n        Node target = superuser.getNode(USERPATH);\n        try {\n            doImport(USERPATH, xml);\n\n            assertTrue(target.isModified());\n            assertTrue(superuser.hasPendingChanges());\n\n            Authorizable newUser = userMgr.getAuthorizable(\"t\");\n            assertNotNull(newUser);\n            assertFalse(newUser.isGroup());\n            assertEquals(\"t\", newUser.getPrincipal().getName());\n            assertEquals(\"t\", newUser.getID());\n            assertTrue(((User) newUser).isDisabled());\n            assertEquals(\"disabledUser\", ((User) newUser).getDisabledReason());\n\n            Node n = superuser.getNode(newUser.getPath());\n            assertTrue(n.isNew());\n            assertTrue(n.getParent().isSame(target));\n\n            assertEquals(\"t\", n.getName());\n            assertEquals(\"t\", n.getProperty(UserConstants.REP_PRINCIPAL_NAME).getString());\n            assertEquals(\"{sha1}8efd86fb78a56a5145ed7739dcb00c78581c5375\", n.getProperty(UserConstants.REP_PASSWORD).getString());\n            assertEquals(\"disabledUser\", n.getProperty(UserConstants.REP_DISABLED).getString());\n\n            // saving changes of the import -> must succeed. add mandatory\n            // props should have been created.\n            superuser.save();\n\n        } finally {\n            superuser.refresh(false);\n            if (target.hasNode(\"t\")) {\n                target.getNode(\"t\").remove();\n                superuser.save();\n            }\n        }\n    }","commit_id":"a55699a9031547f5675da37982c16b218f284a3a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void testImportGroup() throws RepositoryException, IOException, SAXException  {\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"g\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:Group<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>g<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        Node parent = superuser.getNode(GROUPPATH);\n            try {\n                doImport(GROUPPATH, xml);\n\n            Authorizable newGroup = userMgr.getAuthorizable(\"g\");\n            assertNotNull(newGroup);\n            assertTrue(newGroup.isGroup());\n            assertEquals(\"g\", newGroup.getPrincipal().getName());\n            assertEquals(\"g\", newGroup.getID());\n\n            Node n = superuser.getNode(newGroup.getPath());\n            assertTrue(n.isNew());\n            assertTrue(n.getParent().isSame(parent));\n\n            assertEquals(\"g\", n.getName());\n            assertEquals(\"g\", n.getProperty(UserConstants.REP_PRINCIPAL_NAME).getString());\n\n            // saving changes of the import -> must succeed. add mandatory\n            // props should have been created.\n            superuser.save();\n\n        } finally {\n            if (parent.hasNode(\"g\")) {\n                parent.getNode(\"g\").remove();\n                superuser.save();\n            }\n        }\n    }","id":24267,"modified_method":"public void testImportGroup() throws RepositoryException, IOException, SAXException  {\n        String xml = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                \"<sv:node sv:name=\\\"g\\\" xmlns:mix=\\\"http://www.jcp.org/jcr/mix/1.0\\\" xmlns:nt=\\\"http://www.jcp.org/jcr/nt/1.0\\\" xmlns:fn_old=\\\"http://www.w3.org/2004/10/xpath-functions\\\" xmlns:fn=\\\"http://www.w3.org/2005/xpath-functions\\\" xmlns:xs=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:sv=\\\"http://www.jcp.org/jcr/sv/1.0\\\" xmlns:rep=\\\"internal\\\" xmlns:jcr=\\\"http://www.jcp.org/jcr/1.0\\\">\" +\n                \"   <sv:property sv:name=\\\"jcr:primaryType\\\" sv:type=\\\"Name\\\"><sv:value>rep:Group<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"jcr:uuid\\\" sv:type=\\\"String\\\"><sv:value>b2f5ff47-4366-31b6-a533-d8dc3614845d<\/sv:value><\/sv:property>\" +\n                \"   <sv:property sv:name=\\\"rep:principalName\\\" sv:type=\\\"String\\\"><sv:value>g<\/sv:value><\/sv:property>\" +\n                \"<\/sv:node>\";\n\n        Node target = superuser.getNode(GROUPPATH);\n        try {\n            doImport(GROUPPATH, xml);\n\n            assertTrue(target.isModified());\n            assertTrue(superuser.hasPendingChanges());\n\n            Authorizable newGroup = userMgr.getAuthorizable(\"g\");\n            assertNotNull(newGroup);\n            assertTrue(newGroup.isGroup());\n            assertEquals(\"g\", newGroup.getPrincipal().getName());\n            assertEquals(\"g\", newGroup.getID());\n\n            Node n = superuser.getNode(newGroup.getPath());\n            assertTrue(n.isNew());\n            assertTrue(n.getParent().isSame(target));\n\n            assertEquals(\"g\", n.getName());\n            assertEquals(\"g\", n.getProperty(UserConstants.REP_PRINCIPAL_NAME).getString());\n\n            // saving changes of the import -> must succeed. add mandatory\n            // props should have been created.\n            superuser.save();\n\n        } finally {\n            superuser.refresh(false);\n            if (target.hasNode(\"g\")) {\n                target.getNode(\"g\").remove();\n                superuser.save();\n            }\n        }\n    }","commit_id":"a55699a9031547f5675da37982c16b218f284a3a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // avoid collision with testing a-folders that may have been created\n        // with another test (but not removed as user/groups got removed)\n        String path = USERPATH + \"/t\";\n        if (superuser.nodeExists(path)) {\n            superuser.getNode(path).remove();\n        }\n        path = GROUPPATH + \"/g\";\n        if (superuser.nodeExists(path)) {\n            superuser.getNode(path).remove();\n        }\n        superuser.save();\n    }","id":24268,"modified_method":"@Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // avoid collision with testing a-folders that may have been created\n        // with another test (but not removed as user/groups got removed)\n        String path = USERPATH + \"/t\";\n        if (superuser.nodeExists(path)) {\n            superuser.getNode(path).remove();\n        }\n        path = GROUPPATH + \"/g\";\n        if (superuser.nodeExists(path)) {\n            superuser.getNode(path).remove();\n        }\n        superuser.save();\n        sImpl = (SessionImpl)superuser;\n    }","commit_id":"a55699a9031547f5675da37982c16b218f284a3a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean handlePropInfo(Tree parent, PropInfo propInfo, PropertyDefinition def) throws RepositoryException {\n        checkInitialized();\n\n        Authorizable a = userManager.getAuthorizable(parent);\n        if (a == null) {\n            log.warn(\"Cannot handle protected PropInfo \" + propInfo + \". Node \" + parent + \" doesn't represent a valid Authorizable.\");\n            return false;\n        }\n\n        String propName = propInfo.getName();\n        if (REP_PRINCIPAL_NAME.equals(propName)) {\n            if (!isValid(def, NT_REP_AUTHORIZABLE, false)) {\n                return false;\n            }\n\n            String principalName = propInfo.getTextValue().getString();\n            userManager.setPrincipal(parent, new TreeBasedPrincipal(principalName, parent, namePathMapper));\n            /*\n            Execute authorizable actions for a NEW group as this is the\n            same place in the userManager#createGroup that the actions\n            are called.\n            In case of a NEW user the actions are executed if the password\n            has been imported before.\n            */\n            if (parent.getStatus() == Tree.Status.NEW) {\n                if (a.isGroup()) {\n                    userManager.onCreate((Group) a);\n                } else if (currentPw.containsKey(a.getID())) {\n                    userManager.onCreate((User) a, currentPw.remove(a.getID()));\n                }\n            }\n            return true;\n        } else if (REP_PASSWORD.equals(propName)) {\n            if (a.isGroup() || !isValid(def, NT_REP_USER, false)) {\n                log.warn(\"Unexpected authorizable or definition for property rep:password\");\n                return false;\n            }\n\n            String pw = propInfo.getTextValue().getString();\n            userManager.setPassword(parent, pw, false);\n\n            /*\n            Execute authorizable actions for a NEW user at this point after\n            having set the password if the principal name has already been\n            processed, otherwise postpone it.\n            */\n            if (parent.getStatus() == Tree.Status.NEW) {\n                if (parent.hasProperty(REP_PRINCIPAL_NAME)) {\n                    userManager.onCreate((User) a, pw);\n                } else {\n                    // principal name not yet available -> remember the pw\n                    currentPw.clear();\n                    currentPw.put(a.getID(), pw);\n                }\n            }\n            return true;\n\n        } else if (REP_IMPERSONATORS.equals(propName)) {\n            if (a.isGroup() || !isValid(def, MIX_REP_IMPERSONATABLE, true)) {\n                log.warn(\"Unexpected authorizable or definition for property rep:impersonators\");\n                return false;\n            }\n            // since impersonators may be imported later on, postpone processing\n            // to the end.\n            // see -> process References\n            TextValue[] tvs = propInfo.getTextValues();\n            referenceTracker.processedReference(new Impersonators(a.getID(), tvs));\n            return true;\n\n        } else if (REP_DISABLED.equals(propName)) {\n            if (a.isGroup() || !isValid(def, NT_REP_USER, false)) {\n                log.warn(\"Unexpected authorizable or definition for property rep:disabled\");\n                return false;\n            }\n\n            ((User) a).disable(propInfo.getTextValue().getString());\n            return true;\n\n        } else if (REP_MEMBERS.equals(propName)) {\n            if (!a.isGroup() || !isValid(def, NT_REP_GROUP, true)) {\n                return false;\n            }\n            // since group-members are references to user/groups that potentially\n            // are to be imported later on -> postpone processing to the end.\n            // see -> process References\n            Membership membership = new Membership(a.getID());\n            membership.addMembers(propInfo.getTextValues());\n            referenceTracker.processedReference(membership);\n            return true;\n\n        } // else: cannot handle -> return false\n\n        return false;\n    }","id":24269,"modified_method":"@Override\n    public boolean handlePropInfo(Tree parent, PropInfo propInfo, PropertyDefinition def) throws RepositoryException {\n        checkInitialized();\n\n        //TODO remove hack that processes principal name first\n        String propName = propInfo.getName();\n        Authorizable a = null;\n        try {\n            a = userManager.getAuthorizable(parent);\n        } catch (RepositoryException ignore) {}\n        if (a == null && !REP_PRINCIPAL_NAME.equals(propName)) {\n            log.warn(\"Cannot handle protected PropInfo \" + propInfo + \". Node \" + parent + \" doesn't represent a valid Authorizable.\");\n            return false;\n        }\n        if (REP_PRINCIPAL_NAME.equals(propName)) {\n            if (!isValid(def, NT_REP_AUTHORIZABLE, false)) {\n                return false;\n            }\n\n            String principalName = propInfo.getTextValue().getString();\n            userManager.setPrincipal(parent, new TreeBasedPrincipal(principalName, parent, namePathMapper));\n            /*\n            Execute authorizable actions for a NEW group as this is the\n            same place in the userManager#createGroup that the actions\n            are called.\n            In case of a NEW user the actions are executed if the password\n            has been imported before.\n            */\n            a = userManager.getAuthorizable(parent);\n            if (a == null) {\n                log.warn(\"Cannot handle protected PropInfo \" + propInfo + \". Node \" + parent + \" doesn't represent a valid Authorizable.\");\n                return false;\n            }\n            if (parent.getStatus() == Tree.Status.NEW) {\n                if (a.isGroup()) {\n                    userManager.onCreate((Group) a);\n                } else if (currentPw.containsKey(a.getID())) {\n                    userManager.onCreate((User) a, currentPw.remove(a.getID()));\n                }\n            }\n            return true;\n        } else if (REP_PASSWORD.equals(propName)) {\n            if (a.isGroup() || !isValid(def, NT_REP_USER, false)) {\n                log.warn(\"Unexpected authorizable or definition for property rep:password\");\n                return false;\n            }\n\n            String pw = propInfo.getTextValue().getString();\n            userManager.setPassword(parent, pw, false);\n\n            /*\n            Execute authorizable actions for a NEW user at this point after\n            having set the password if the principal name has already been\n            processed, otherwise postpone it.\n            */\n            if (parent.getStatus() == Tree.Status.NEW) {\n                if (parent.hasProperty(REP_PRINCIPAL_NAME)) {\n                    userManager.onCreate((User) a, pw);\n                } else {\n                    // principal name not yet available -> remember the pw\n                    currentPw.clear();\n                    currentPw.put(a.getID(), pw);\n                }\n            }\n            return true;\n\n        } else if (REP_IMPERSONATORS.equals(propName)) {\n            if (a.isGroup() || !isValid(def, MIX_REP_IMPERSONATABLE, true)) {\n                log.warn(\"Unexpected authorizable or definition for property rep:impersonators\");\n                return false;\n            }\n            // since impersonators may be imported later on, postpone processing\n            // to the end.\n            // see -> process References\n            TextValue[] tvs = propInfo.getTextValues();\n            referenceTracker.processedReference(new Impersonators(a.getID(), tvs));\n            return true;\n\n        } else if (REP_DISABLED.equals(propName)) {\n            if (a.isGroup() || !isValid(def, NT_REP_USER, false)) {\n                log.warn(\"Unexpected authorizable or definition for property rep:disabled\");\n                return false;\n            }\n\n            ((User) a).disable(propInfo.getTextValue().getString());\n            return true;\n\n        } else if (REP_MEMBERS.equals(propName)) {\n            if (!a.isGroup() || !isValid(def, NT_REP_GROUP, true)) {\n                return false;\n            }\n            // since group-members are references to user/groups that potentially\n            // are to be imported later on -> postpone processing to the end.\n            // see -> process References\n            Membership membership = new Membership(a.getID());\n            membership.addMembers(propInfo.getTextValues());\n            referenceTracker.processedReference(membership);\n            return true;\n\n        } // else: cannot handle -> return false\n\n        return false;\n    }","commit_id":"a55699a9031547f5675da37982c16b218f284a3a","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@CheckForNull\n    private Authorizable getAuthorizable(String resultPath) {\n        Authorizable authorizable = null;\n        try {\n            Tree tree = root.getTree(resultPath);\n            AuthorizableType type = UserUtility.getType(tree);\n            while (tree != null && type == null) {\n                tree = tree.getParent();\n                type = UserUtility.getType(tree);\n            }\n            if (type != null && (targetType == null || targetType == type)) {\n                authorizable = userManager.getAuthorizableByPath(tree.getPath());\n            }\n        } catch (RepositoryException e) {\n            log.debug(\"Failed to access authorizable \" + resultPath);\n        }\n        return authorizable;\n    }","id":24270,"modified_method":"@CheckForNull\n    private Authorizable getAuthorizable(String resultPath) {\n        Authorizable authorizable = null;\n        try {\n            Tree tree = root.getTree(resultPath);\n            AuthorizableType type = UserUtility.getType(tree);\n            while (tree != null && type == null) {\n                tree = tree.getParent();\n                type = UserUtility.getType(tree);\n            }\n            if (tree != null && (targetType == null || targetType == type)) {\n                authorizable = userManager.getAuthorizableByPath(tree.getPath());\n            }\n        } catch (RepositoryException e) {\n            log.debug(\"Failed to access authorizable \" + resultPath);\n        }\n        return authorizable;\n    }","commit_id":"991f2fb9b4a01c8f66be221489d11f76361b0eb9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean start(Tree protectedParent) throws RepositoryException {\n        if (NT_REP_MEMBERS.equals(TreeUtil.getPrimaryTypeName(protectedParent))) {\n            Tree groupTree = protectedParent;\n            while (!groupTree.isRoot() && NT_REP_MEMBERS.equals(TreeUtil.getPrimaryTypeName(groupTree))) {\n                groupTree = groupTree.getParent();\n            }\n            Authorizable auth = userManager.getAuthorizable(groupTree);\n            if (auth == null) {\n                log.debug(\"Cannot handle protected node \" + protectedParent + \". It nor one of its parents represent a valid Authorizable.\");\n                return false;\n            } else {\n                currentMembership = new Membership(auth.getID());\n                return true;\n            }\n        } // else: parent node is not of type rep:Members\n\n        return false;\n    }","id":24271,"modified_method":"@Override\n    public boolean start(Tree protectedParent) throws RepositoryException {\n        if (isMemberNode(protectedParent)) {\n            Tree groupTree = protectedParent;\n            while (isMemberNode(groupTree)) {\n                groupTree = groupTree.getParent();\n            }\n            Authorizable auth = (groupTree == null) ? null : userManager.getAuthorizable(groupTree);\n            if (auth == null) {\n                log.debug(\"Cannot handle protected node \" + protectedParent + \". It nor one of its parents represent a valid Authorizable.\");\n                return false;\n            } else {\n                currentMembership = new Membership(auth.getID());\n                return true;\n            }\n        } // else: parent node is not of type rep:Members\n\n        return false;\n    }","commit_id":"991f2fb9b4a01c8f66be221489d11f76361b0eb9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void process() throws RepositoryException {\n            Authorizable a = userManager.getAuthorizable(userId);\n            if (a == null || a.isGroup()) {\n                throw new RepositoryException(userId + \" does not represent a valid user.\");\n            }\n\n            Impersonation imp = ((User) a).getImpersonation();\n\n            // 1. collect principals to add and to remove.\n            Map<String, Principal> toRemove = new HashMap<String, Principal>();\n            for (PrincipalIterator pit = imp.getImpersonators(); pit.hasNext(); ) {\n                Principal princ = pit.nextPrincipal();\n                toRemove.put(princ.getName(), princ);\n            }\n\n            List<String> toAdd = new ArrayList<String>();\n            for (final String principalName : principalNames) {\n                if (toRemove.remove(principalName) == null) {\n                    // add it to the list of new impersonators to be added.\n                    toAdd.add(principalName);\n                } // else: no need to revoke impersonation for the given principal.\n            }\n\n            // 2. adjust set of impersonators\n            for (Principal princicpal : toRemove.values()) {\n                if (!imp.revokeImpersonation(princicpal)) {\n                    String principalName = princicpal.getName();\n                    handleFailure(\"Failed to revoke impersonation for \" + principalName + \" on \" + a);\n                }\n            }\n            List<String> nonExisting = new ArrayList<String>();\n            for (String principalName : toAdd) {\n                if (!imp.grantImpersonation(new PrincipalImpl(principalName))) {\n                    handleFailure(\"Failed to grant impersonation for \" + principalName + \" on \" + a);\n                    if (importBehavior == ImportBehavior.BESTEFFORT &&\n                            getPrincipalManager().getPrincipal(principalName) == null) {\n                        log.info(\"ImportBehavior.BESTEFFORT: Remember non-existing impersonator for special processing.\");\n                        nonExisting.add(principalName);\n                    }\n                }\n            }\n\n            if (!nonExisting.isEmpty()) {\n                Tree userTree = root.getTree(a.getPath());\n                // copy over all existing impersonators to the nonExisting list\n                PropertyState impersonators = userTree.getProperty(REP_PRINCIPAL_NAME);\n                for (String existing : impersonators.getValue(STRINGS)) {\n                    nonExisting.add(existing);\n                }\n                // and write back the complete list including those principal\n                // names that are unknown to principal provider.\n                userTree.setProperty(REP_PRINCIPAL_NAME, nonExisting, Type.STRINGS);\n            }\n        }","id":24272,"modified_method":"private void process() throws RepositoryException {\n            Authorizable a = userManager.getAuthorizable(userId);\n            if (a == null || a.isGroup()) {\n                throw new RepositoryException(userId + \" does not represent a valid user.\");\n            }\n\n            Impersonation imp = checkNotNull(((User) a).getImpersonation());\n\n            // 1. collect principals to add and to remove.\n            Map<String, Principal> toRemove = new HashMap<String, Principal>();\n            for (PrincipalIterator pit = imp.getImpersonators(); pit.hasNext(); ) {\n                Principal princ = pit.nextPrincipal();\n                toRemove.put(princ.getName(), princ);\n            }\n\n            List<String> toAdd = new ArrayList<String>();\n            for (final String principalName : principalNames) {\n                if (toRemove.remove(principalName) == null) {\n                    // add it to the list of new impersonators to be added.\n                    toAdd.add(principalName);\n                } // else: no need to revoke impersonation for the given principal.\n            }\n\n            // 2. adjust set of impersonators\n            for (Principal princicpal : toRemove.values()) {\n                if (!imp.revokeImpersonation(princicpal)) {\n                    String principalName = princicpal.getName();\n                    handleFailure(\"Failed to revoke impersonation for \" + principalName + \" on \" + a);\n                }\n            }\n            List<String> nonExisting = new ArrayList<String>();\n            for (String principalName : toAdd) {\n                if (!imp.grantImpersonation(new PrincipalImpl(principalName))) {\n                    handleFailure(\"Failed to grant impersonation for \" + principalName + \" on \" + a);\n                    if (importBehavior == ImportBehavior.BESTEFFORT &&\n                            getPrincipalManager().getPrincipal(principalName) == null) {\n                        log.info(\"ImportBehavior.BESTEFFORT: Remember non-existing impersonator for special processing.\");\n                        nonExisting.add(principalName);\n                    }\n                }\n            }\n\n            if (!nonExisting.isEmpty()) {\n                Tree userTree = checkNotNull(root.getTree(a.getPath()));\n                // copy over all existing impersonators to the nonExisting list\n                PropertyState impersonators = userTree.getProperty(REP_IMPERSONATORS);\n                if (impersonators != null) {\n                    for (String existing : impersonators.getValue(STRINGS)) {\n                        nonExisting.add(existing);\n                    }\n                }\n                // and write back the complete list including those principal\n                // names that are unknown to principal provider.\n                userTree.setProperty(REP_IMPERSONATORS, nonExisting, Type.STRINGS);\n            }\n        }","commit_id":"991f2fb9b4a01c8f66be221489d11f76361b0eb9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Nonnull\n    @Override\n    public NodeState initialize(NodeState workspaceRoot, String workspaceName,\n                                IndexHookProvider indexHook, QueryIndexProvider indexProvider,\n                                CommitHook commitHook) {\n        MemoryNodeStore store = new MemoryNodeStore();\n        NodeStoreBranch branch = store.branch();\n        branch.setRoot(workspaceRoot);\n        try {\n            branch.merge(IndexHookManager.of(indexHook));\n        } catch (CommitFailedException e) {\n            throw new RuntimeException(e);\n        }\n        Root root = new RootImpl(store, commitHook, workspaceName, SystemSubject.INSTANCE, securityProvider, indexProvider);\n\n        UserConfiguration userConfiguration = securityProvider.getUserConfiguration();\n        UserManager userManager = userConfiguration.getUserManager(root, NamePathMapper.DEFAULT);\n\n        String errorMsg = \"Failed to initialize user content.\";\n        try {\n            NodeUtil rootTree = new NodeUtil(root.getTree(\"/\"));\n            NodeUtil index = rootTree.getOrAddChild(IndexConstants.INDEX_DEFINITIONS_NAME, JcrConstants.NT_UNSTRUCTURED);\n            IndexUtils.createIndexDefinition(index, \"authorizableId\", true, new String[]{REP_AUTHORIZABLE_ID}, null);\n            IndexUtils.createIndexDefinition(index, \"principalName\", true,\n                    new String[]{REP_PRINCIPAL_NAME},\n                    new String[]{NT_REP_GROUP, NT_REP_USER});\n            IndexUtils.createIndexDefinition(index, \"members\", false, new String[]{UserConstants.REP_MEMBERS}, null);\n\n            String adminId = userConfiguration.getConfigurationParameters().getConfigValue(PARAM_ADMIN_ID, DEFAULT_ADMIN_ID);\n            if (userManager.getAuthorizable(adminId) == null) {\n                // TODO: init admin with null password and force application to set it.\n                userManager.createUser(adminId, adminId);\n            }\n            String anonymousId = userConfiguration.getConfigurationParameters().getConfigValue(PARAM_ANONYMOUS_ID, DEFAULT_ANONYMOUS_ID);\n            if (userManager.getAuthorizable(anonymousId) == null) {\n                userManager.createUser(anonymousId, null);\n            }\n            if (root.hasPendingChanges()) {\n                root.commit();\n            }\n        } catch (RepositoryException e) {\n            log.error(errorMsg, e);\n            throw new RuntimeException(e);\n        } catch (CommitFailedException e) {\n            log.error(errorMsg, e);\n            throw new RuntimeException(e);\n        }\n        return store.getRoot();\n    }","id":24273,"modified_method":"@Nonnull\n    @Override\n    public NodeState initialize(NodeState workspaceRoot, String workspaceName,\n                                IndexHookProvider indexHook, QueryIndexProvider indexProvider,\n                                CommitHook commitHook) {\n        MemoryNodeStore store = new MemoryNodeStore();\n        NodeStoreBranch branch = store.branch();\n        branch.setRoot(workspaceRoot);\n        try {\n            branch.merge(IndexHookManager.of(indexHook));\n        } catch (CommitFailedException e) {\n            throw new RuntimeException(e);\n        }\n        Root root = new RootImpl(store, commitHook, workspaceName, SystemSubject.INSTANCE, securityProvider, indexProvider);\n\n        UserConfiguration userConfiguration = securityProvider.getUserConfiguration();\n        UserManager userManager = userConfiguration.getUserManager(root, NamePathMapper.DEFAULT);\n\n        String errorMsg = \"Failed to initialize user content.\";\n        try {\n            NodeUtil rootTree = checkNotNull(new NodeUtil(root.getTree(\"/\")));\n            NodeUtil index = rootTree.getOrAddChild(IndexConstants.INDEX_DEFINITIONS_NAME, JcrConstants.NT_UNSTRUCTURED);\n            IndexUtils.createIndexDefinition(index, \"authorizableId\", true, new String[]{REP_AUTHORIZABLE_ID}, null);\n            IndexUtils.createIndexDefinition(index, \"principalName\", true,\n                    new String[]{REP_PRINCIPAL_NAME},\n                    new String[]{NT_REP_GROUP, NT_REP_USER});\n            IndexUtils.createIndexDefinition(index, \"members\", false, new String[]{UserConstants.REP_MEMBERS}, null);\n\n            String adminId = userConfiguration.getConfigurationParameters().getConfigValue(PARAM_ADMIN_ID, DEFAULT_ADMIN_ID);\n            if (userManager.getAuthorizable(adminId) == null) {\n                // TODO: init admin with null password and force application to set it.\n                userManager.createUser(adminId, adminId);\n            }\n            String anonymousId = userConfiguration.getConfigurationParameters().getConfigValue(PARAM_ANONYMOUS_ID, DEFAULT_ANONYMOUS_ID);\n            if (userManager.getAuthorizable(anonymousId) == null) {\n                userManager.createUser(anonymousId, null);\n            }\n            if (root.hasPendingChanges()) {\n                root.commit();\n            }\n        } catch (RepositoryException e) {\n            log.error(errorMsg, e);\n            throw new RuntimeException(e);\n        } catch (CommitFailedException e) {\n            log.error(errorMsg, e);\n            throw new RuntimeException(e);\n        }\n        return store.getRoot();\n    }","commit_id":"991f2fb9b4a01c8f66be221489d11f76361b0eb9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@CheckForNull\n    public static AuthorizableType getType(@Nonnull Tree authorizableNode) {\n        String ntName = TreeUtil.getPrimaryTypeName(authorizableNode);\n        if (ntName != null) {\n            if (UserConstants.NT_REP_GROUP.equals(ntName)) {\n                return AuthorizableType.GROUP;\n            } else if (UserConstants.NT_REP_USER.equals(ntName)) {\n                return AuthorizableType.USER;\n            }\n        }\n        return null;\n    }","id":24274,"modified_method":"@CheckForNull\n    public static AuthorizableType getType(@Nullable Tree authorizableNode) {\n        String ntName = (authorizableNode == null) ? null : TreeUtil.getPrimaryTypeName(authorizableNode);\n        if (ntName != null) {\n            if (UserConstants.NT_REP_GROUP.equals(ntName)) {\n                return AuthorizableType.GROUP;\n            } else if (UserConstants.NT_REP_USER.equals(ntName)) {\n                return AuthorizableType.USER;\n            }\n        }\n        return null;\n    }","commit_id":"991f2fb9b4a01c8f66be221489d11f76361b0eb9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"UserValidator(Tree parentBefore, Tree parentAfter, UserValidatorProvider provider) {\n        this.parentBefore = parentBefore;\n        this.parentAfter = parentAfter;\n        this.provider = provider;\n\n        authorizableType = (parentAfter == null) ? null : UserUtility.getType(parentAfter);\n    }","id":24275,"modified_method":"UserValidator(Tree parentBefore, Tree parentAfter, UserValidatorProvider provider) {\n        this.parentBefore = parentBefore;\n        this.parentAfter = parentAfter;\n        this.provider = provider;\n\n        authorizableType = UserUtility.getType(parentAfter);\n    }","commit_id":"991f2fb9b4a01c8f66be221489d11f76361b0eb9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private static boolean isValidUUID(@Nonnull Tree parent, @Nonnull String uuid) {\n        String id = UserProvider.getAuthorizableId(parent);\n        return uuid.equals(UserProvider.getContentID(id));\n    }","id":24276,"modified_method":"private static boolean isValidUUID(@Nonnull Tree parent, @Nonnull String uuid) {\n        String id = UserProvider.getAuthorizableId(parent);\n        return id != null && uuid.equals(UserProvider.getContentID(id));\n    }","commit_id":"991f2fb9b4a01c8f66be221489d11f76361b0eb9","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean commit() throws LoginException {\n        if (externalUser == null) {\n            return false;\n        }\n        Set<? extends Principal> principals = getPrincipals(externalUser.getId());\n        if (!principals.isEmpty()) {\n            if (!subject.isReadOnly()) {\n                subject.getPrincipals().addAll(principals);\n                subject.getPublicCredentials().add(credentials);\n                setAuthInfo(new AuthInfoImpl(externalUser.getId(), null, principals), subject);\n            } else {\n                log.debug(\"Could not add information to read only subject {}\", subject);\n            }\n            return true;\n        }\n        return false;\n    }","id":24277,"modified_method":"@Override\n    public boolean commit() throws LoginException {\n        if (externalUser == null) {\n            return false;\n        }\n        Set<? extends Principal> principals = getPrincipals(externalUser.getId());\n        if (!principals.isEmpty()) {\n            if (!subject.isReadOnly()) {\n                subject.getPrincipals().addAll(principals);\n                subject.getPublicCredentials().add(credentials);\n                setAuthInfo(createAuthInfo(externalUser.getId(), principals), subject);\n            } else {\n                log.debug(\"Could not add information to read only subject {}\", subject);\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@After\n    public void after() throws Exception {\n        if (testIdpReg != null) {\n            testIdpReg.unregister();\n            testIdpReg = null;\n        }\n        idp = null;\n        setSyncConfig(null);\n\n        try {\n            UserManager userManager = getUserManager(root);\n            Iterator<Authorizable> iter = userManager.findAuthorizables(\"jcr:primaryType\", null);\n            while (iter.hasNext()) {\n                ids.remove(iter.next().getID());\n            }\n            for (String id : ids) {\n                Authorizable a = userManager.getAuthorizable(id);\n                if (a != null) {\n                    a.remove();\n                }\n            }\n            root.commit();\n        } finally {\n            root.refresh();\n            super.after();\n        }\n    }","id":24278,"modified_method":"@After\n    public void after() throws Exception {\n        if (testIdpReg != null) {\n            testIdpReg.unregister();\n            testIdpReg = null;\n        }\n        destroyIDP(idp);\n        idp = null;\n        setSyncConfig(null);\n\n        try {\n            UserManager userManager = getUserManager(root);\n            Iterator<Authorizable> iter = userManager.findAuthorizables(\"jcr:primaryType\", null);\n            while (iter.hasNext()) {\n                ids.remove(iter.next().getID());\n            }\n            for (String id : ids) {\n                Authorizable a = userManager.getAuthorizable(id);\n                if (a != null) {\n                    a.remove();\n                }\n            }\n            root.commit();\n        } finally {\n            root.refresh();\n            super.after();\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Collects the declared (direct) groups of an identity\n     * @param ref reference to the identity\n     * @return map of identities where the key is the DN of the LDAP entity\n     */\n    public Map<String, ExternalIdentityRef> getDeclaredGroupRefs(ExternalIdentityRef ref) throws ExternalIdentityException {\n        if (!isMyRef(ref)) {\n            return Collections.emptyMap();\n        }\n        String searchFilter = config.getMemberOfSearchFilter(ref.getId());\n\n        LdapConnection connection = null;\n        try {\n            // Create the SearchRequest object\n            SearchRequest req = new SearchRequestImpl();\n            req.setScope(SearchScope.SUBTREE);\n            req.addAttributes(SchemaConstants.NO_ATTRIBUTE);\n            req.setTimeLimit((int) config.getSearchTimeout());\n            req.setBase(new Dn(config.getGroupConfig().getBaseDN()));\n            req.setFilter(searchFilter);\n\n            Map<String, ExternalIdentityRef> groups = new HashMap<String, ExternalIdentityRef>();\n            DebugTimer timer = new DebugTimer();\n            connection = connect();\n            timer.mark(\"connect\");\n\n            SearchCursor searchCursor = connection.search(req);\n            timer.mark(\"search\");\n            while (searchCursor.next()) {\n                Response response = searchCursor.get();\n                if (response instanceof SearchResultEntry) {\n                    Entry resultEntry = ((SearchResultEntry) response).getEntry();\n                    ExternalIdentityRef groupRef = new ExternalIdentityRef(resultEntry.getDn().toString(), this.getName());\n                    groups.put(groupRef.getId(), groupRef);\n                }\n            }\n            timer.mark(\"iterate\");\n            if (log.isDebugEnabled()) {\n                log.debug(\"search below {} with {} found {} entries. {}\",\n                        config.getGroupConfig().getBaseDN(), searchFilter, groups.size(), timer.getString());\n            }\n            return groups;\n        } catch (Exception e) {\n            log.error(\"Error during ldap membership search.\" ,e);\n            throw new ExternalIdentityException(\"Error during ldap membership search.\", e);\n        } finally {\n            disconnect(connection);\n        }\n    }","id":24279,"modified_method":"/**\n     * Collects the declared (direct) groups of an identity\n     * @param ref reference to the identity\n     * @return map of identities where the key is the DN of the LDAP entity\n     */\n    public Map<String, ExternalIdentityRef> getDeclaredGroupRefs(ExternalIdentityRef ref) throws ExternalIdentityException {\n        if (!isMyRef(ref)) {\n            return Collections.emptyMap();\n        }\n        String searchFilter = config.getMemberOfSearchFilter(ref.getId());\n\n        LdapConnection connection = null;\n        SearchCursor searchCursor = null;\n        try {\n            // Create the SearchRequest object\n            SearchRequest req = new SearchRequestImpl();\n            req.setScope(SearchScope.SUBTREE);\n            req.addAttributes(SchemaConstants.NO_ATTRIBUTE);\n            req.setTimeLimit((int) config.getSearchTimeout());\n            req.setBase(new Dn(config.getGroupConfig().getBaseDN()));\n            req.setFilter(searchFilter);\n\n            Map<String, ExternalIdentityRef> groups = new HashMap<String, ExternalIdentityRef>();\n            DebugTimer timer = new DebugTimer();\n            connection = connect();\n            timer.mark(\"connect\");\n\n            searchCursor = connection.search(req);\n            timer.mark(\"search\");\n            while (searchCursor.next()) {\n                Response response = searchCursor.get();\n                if (response instanceof SearchResultEntry) {\n                    Entry resultEntry = ((SearchResultEntry) response).getEntry();\n                    ExternalIdentityRef groupRef = new ExternalIdentityRef(resultEntry.getDn().toString(), this.getName());\n                    groups.put(groupRef.getId(), groupRef);\n                }\n            }\n            timer.mark(\"iterate\");\n            if (log.isDebugEnabled()) {\n                log.debug(\"search below {} with {} found {} entries. {}\",\n                        config.getGroupConfig().getBaseDN(), searchFilter, groups.size(), timer.getString());\n            }\n            return groups;\n        } catch (Exception e) {\n            log.error(\"Error during ldap membership search.\" ,e);\n            throw new ExternalIdentityException(\"Error during ldap membership search.\", e);\n        } finally {\n            if (searchCursor != null) {\n                searchCursor.close();\n            }\n            disconnect(connection);\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Entry getEntry(LdapConnection connection, LdapProviderConfig.Identity idConfig, String id)\n            throws CursorException, LdapException {\n        String searchFilter = idConfig.getSearchFilter(id);\n\n        // Create the SearchRequest object\n        SearchRequest req = new SearchRequestImpl();\n        req.setScope(SearchScope.SUBTREE);\n        req.addAttributes(SchemaConstants.ALL_USER_ATTRIBUTES);\n        req.setTimeLimit((int) config.getSearchTimeout());\n        req.setBase(new Dn(idConfig.getBaseDN()));\n        req.setFilter(searchFilter);\n\n        // Process the request\n        SearchCursor searchCursor = connection.search(req);\n        while (searchCursor.next()) {\n            Response response = searchCursor.get();\n\n            // process the SearchResultEntry\n            if (response instanceof SearchResultEntry) {\n                Entry resultEntry = ((SearchResultEntry) response).getEntry();\n                if (searchCursor.next()) {\n                    log.warn(\"search for {} returned more than one entry. discarding additional ones.\", searchFilter);\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"search below {} with {} found {}\", idConfig.getBaseDN(), searchFilter, resultEntry.getDn());\n                }\n                return resultEntry;\n            }\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"search below {} with {} found 0 entries.\", idConfig.getBaseDN(), searchFilter);\n        }\n        return null;\n    }","id":24280,"modified_method":"private Entry getEntry(LdapConnection connection, LdapProviderConfig.Identity idConfig, String id)\n            throws CursorException, LdapException {\n        String searchFilter = idConfig.getSearchFilter(id);\n\n        // Create the SearchRequest object\n        SearchRequest req = new SearchRequestImpl();\n        req.setScope(SearchScope.SUBTREE);\n        req.addAttributes(SchemaConstants.ALL_USER_ATTRIBUTES);\n        req.setTimeLimit((int) config.getSearchTimeout());\n        req.setBase(new Dn(idConfig.getBaseDN()));\n        req.setFilter(searchFilter);\n\n        // Process the request\n        SearchCursor searchCursor = null;\n        try {\n            searchCursor = connection.search(req);\n            while (searchCursor.next()) {\n                Response response = searchCursor.get();\n\n                // process the SearchResultEntry\n                if (response instanceof SearchResultEntry) {\n                    Entry resultEntry = ((SearchResultEntry) response).getEntry();\n                    if (searchCursor.next()) {\n                        log.warn(\"search for {} returned more than one entry. discarding additional ones.\", searchFilter);\n                    }\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"search below {} with {} found {}\", idConfig.getBaseDN(), searchFilter, resultEntry.getDn());\n                    }\n                    return resultEntry;\n                }\n            }\n        } finally {\n            if (searchCursor != null) {\n                searchCursor.close();\n            }\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"search below {} with {} found 0 entries.\", idConfig.getBaseDN(), searchFilter);\n        }\n        return null;\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void disconnect(@Nullable LdapConnection connection) throws ExternalIdentityException {\n        try {\n            if (connection != null) {\n                adminPool.releaseConnection(connection);\n            }\n        } catch (Exception e) {\n            log.warn(\"Error while disconnecting from the ldap server.\", e);\n        }\n    }","id":24281,"modified_method":"private void disconnect(@Nullable LdapConnection connection) throws ExternalIdentityException {\n        try {\n            if (connection != null) {\n                if (disableConnectionPooling) {\n                    connection.close();\n                }\n                adminPool.releaseConnection(connection);\n            }\n        } catch (Exception e) {\n            log.warn(\"Error while disconnecting from the ldap server.\", e);\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Ignore() // FIXME\n    @Test\n    public void testSyncCreateGroup() throws Exception {\n        ContentSession cs = null;\n        try {\n            cs = login(new SimpleCredentials(USER_ID, USER_PWD.toCharArray()));\n\n            root.refresh();\n            assertNull(userManager.getAuthorizable(USER_ID));\n            assertNull(userManager.getAuthorizable(GROUP_DN));\n        } finally {\n            if (cs != null) {\n                cs.close();\n            }\n            options.clear();\n        }\n    }","id":24282,"modified_method":"@Test\n    public void testSyncCreateGroup() throws Exception {\n        ContentSession cs = null;\n        try {\n            cs = login(new SimpleCredentials(USER_ID, USER_PWD.toCharArray()));\n\n            root.refresh();\n            assertNotNull(userManager.getAuthorizable(USER_ID));\n            assertNotNull(userManager.getAuthorizable(GROUP_NAME));\n        } finally {\n            if (cs != null) {\n                cs.close();\n            }\n            options.clear();\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Ignore // FIXME\n    @Test\n    public void testConcurrentLogin() throws Exception {\n        concurrentLogin(false);\n    }","id":24283,"modified_method":"@Test\n    @Ignore(\"OAK-1541\")\n    public void testConcurrentLogin() throws Exception {\n        concurrentLogin(CONCURRENT_TEST_USERS);\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Ignore() // FIXME\n    @Test\n    public void testSyncUpdate() throws Exception {\n        // create user upfront in order to test update mode\n        userManager.createUser(USER_ID, null);\n        root.commit();\n\n        ContentSession cs = null;\n        try {\n            cs = login(new SimpleCredentials(USER_ID, USER_PWD.toCharArray()));\n\n            root.refresh();\n            Authorizable user = userManager.getAuthorizable(USER_ID);\n            assertNotNull(user);\n            assertTrue(user.hasProperty(USER_PROP));\n            assertNull(userManager.getAuthorizable(GROUP_DN));\n        } finally {\n            if (cs != null) {\n                cs.close();\n            }\n            options.clear();\n        }\n    }","id":24284,"modified_method":"@Test\n    public void testSyncUpdate() throws Exception {\n        // create user upfront in order to test update mode\n        Authorizable user = userManager.createUser(USER_ID, null);\n        ExternalUser externalUser = idp.getUser(USER_ID);\n        user.setProperty(\"rep:externalId\", new ValueFactoryImpl(root, NamePathMapper.DEFAULT).createValue(externalUser.getExternalId().getString()));\n        root.commit();\n\n        ContentSession cs = null;\n        try {\n            cs = login(new SimpleCredentials(USER_ID, USER_PWD.toCharArray()));\n\n            root.refresh();\n             user = userManager.getAuthorizable(USER_ID);\n            assertNotNull(user);\n            assertTrue(user.hasProperty(USER_PROP));\n            assertNull(userManager.getAuthorizable(GROUP_DN));\n        } finally {\n            if (cs != null) {\n                cs.close();\n            }\n            options.clear();\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    protected ExternalIdentityProvider createIDP() {\n        LdapProviderConfig cfg = new LdapProviderConfig()\n                .setName(\"ldap\")\n                .setHostname(\"127.0.0.1\")\n                .setPort(LDAP_SERVER.getPort())\n                .setBindDN(ServerDNConstants.ADMIN_SYSTEM_DN)\n                .setBindPassword(InternalLdapServer.ADMIN_PW)\n                .setGroupMemberAttribute(InternalLdapServer.GROUP_MEMBER_ATTR);\n\n        cfg.getUserConfig()\n                .setBaseDN(ServerDNConstants.USERS_SYSTEM_DN)\n                .setObjectClasses(\"inetOrgPerson\");\n        cfg.getGroupConfig()\n                .setBaseDN(ServerDNConstants.GROUPS_SYSTEM_DN)\n                .setObjectClasses(InternalLdapServer.GROUP_CLASS_ATTR);\n\n        return new LdapIdentityProvider(cfg);\n    }","id":24285,"modified_method":"@Override\n    protected ExternalIdentityProvider createIDP() {\n        LdapProviderConfig cfg = new LdapProviderConfig()\n                .setName(\"ldap\")\n                .setHostname(\"127.0.0.1\")\n                .setPort(LDAP_SERVER.getPort())\n                .setBindDN(ServerDNConstants.ADMIN_SYSTEM_DN)\n                .setBindPassword(InternalLdapServer.ADMIN_PW)\n                .setGroupMemberAttribute(InternalLdapServer.GROUP_MEMBER_ATTR);\n\n        cfg.getUserConfig()\n                .setBaseDN(ServerDNConstants.USERS_SYSTEM_DN)\n                .setObjectClasses(\"inetOrgPerson\");\n        cfg.getGroupConfig()\n                .setBaseDN(ServerDNConstants.GROUPS_SYSTEM_DN)\n                .setObjectClasses(InternalLdapServer.GROUP_CLASS_ATTR);\n\n        LdapIdentityProvider ldapIDP = new LdapIdentityProvider(cfg);\n        ldapIDP.disableConnectionPooling = true;\n        return ldapIDP;\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Ignore // FIXME\n    @Test\n    public void testConcurrentLoginSameGroup() throws Exception {\n        concurrentLogin(true);\n    }","id":24286,"modified_method":"@Test\n    @Ignore(\"OAK-1541\")\n    public void testConcurrentLoginSameGroup() throws Exception {\n        concurrentLogin(CONCURRENT_GROUP_TEST_USERS);\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Ignore() // FIXME\n    @Test\n    public void testReLogin() throws Exception {\n        ContentSession cs = null;\n        try {\n            cs = login(new SimpleCredentials(USER_ID, USER_PWD.toCharArray()));\n\n            root.refresh();\n            Authorizable user = userManager.getAuthorizable(USER_ID);\n            assertNotNull(user);\n            assertFalse(root.getTree(user.getPath()).hasProperty(UserConstants.REP_PASSWORD));\n\n            cs.close();\n            // login again\n            cs = login(new SimpleCredentials(USER_ID, USER_PWD.toCharArray()));\n            assertEquals(USER_ID, cs.getAuthInfo().getUserID());\n        } finally {\n            if (cs != null) {\n                cs.close();\n            }\n            options.clear();\n        }\n    }","id":24287,"modified_method":"@Test\n    public void testReLogin() throws Exception {\n        ContentSession cs = null;\n        try {\n            cs = login(new SimpleCredentials(USER_ID, USER_PWD.toCharArray()));\n\n            root.refresh();\n            Authorizable user = userManager.getAuthorizable(USER_ID);\n            assertNotNull(user);\n            assertFalse(root.getTree(user.getPath()).hasProperty(UserConstants.REP_PASSWORD));\n\n            cs.close();\n            // login again\n            cs = login(new SimpleCredentials(USER_ID, USER_PWD.toCharArray()));\n            root.refresh();\n            assertEquals(USER_ID, cs.getAuthInfo().getUserID());\n        } finally {\n            if (cs != null) {\n                cs.close();\n            }\n            options.clear();\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Ignore() // FIXME\n    @Test\n    public void testPrincipalsFromAuthInfo() throws Exception {\n        ContentSession cs = null;\n        try {\n            SimpleCredentials sc = new SimpleCredentials(USER_ID, USER_PWD.toCharArray());\n            sc.setAttribute(\"attr\", \"val\");\n\n            cs = login(sc);\n            AuthInfo ai = cs.getAuthInfo();\n\n            root.refresh();\n            PrincipalProvider pp = getSecurityProvider().getConfiguration(PrincipalConfiguration.class).getPrincipalProvider(root, NamePathMapper.DEFAULT);\n            Set<? extends Principal> expected = pp.getPrincipals(USER_ID);\n            assertEquals(2, expected.size());\n            assertEquals(expected, ai.getPrincipals());\n\n        } finally {\n            if (cs != null) {\n                cs.close();\n            }\n        }\n    }","id":24288,"modified_method":"@Test\n    public void testPrincipalsFromAuthInfo() throws Exception {\n        ContentSession cs = null;\n        try {\n            SimpleCredentials sc = new SimpleCredentials(USER_ID, USER_PWD.toCharArray());\n            sc.setAttribute(\"attr\", \"val\");\n\n            cs = login(sc);\n            AuthInfo ai = cs.getAuthInfo();\n\n            root.refresh();\n            PrincipalProvider pp = getSecurityProvider().getConfiguration(PrincipalConfiguration.class).getPrincipalProvider(root, NamePathMapper.DEFAULT);\n            Set<? extends Principal> expected = pp.getPrincipals(USER_ID);\n            assertEquals(3, expected.size());\n            assertEquals(expected, ai.getPrincipals());\n\n        } finally {\n            if (cs != null) {\n                cs.close();\n            }\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private void concurrentLogin(boolean sameGroup) throws Exception {\n        final List<Exception> exceptions = new ArrayList<Exception>();\n        List<Thread> workers = new ArrayList<Thread>();\n        for (int i = 0; i < CONCURRENT_LOGINS; i++) {\n            final String userId = \"user-\" + i;\n            final String pass = \"secret\";\n            String userDN = LDAP_SERVER.addUser(userId, \"test\", userId, pass);\n            if (sameGroup) {\n                LDAP_SERVER.addMember(GROUP_DN, userDN);\n            }\n            workers.add(new Thread(new Runnable() {\n                public void run() {\n                    try {\n                        login(new SimpleCredentials(\n                                userId, pass.toCharArray())).close();\n                    } catch (Exception e) {\n                        exceptions.add(e);\n                    }\n                }\n            }));\n        }\n        for (Thread t : workers) {\n            t.start();\n        }\n        for (Thread t : workers) {\n            t.join();\n        }\n        for (Exception e : exceptions) {\n            e.printStackTrace();\n        }\n        if (!exceptions.isEmpty()) {\n            throw exceptions.get(0);\n        }\n    }","id":24289,"modified_method":"private void concurrentLogin(String [] users) throws Exception {\n        final List<Exception> exceptions = new ArrayList<Exception>();\n        List<Thread> workers = new ArrayList<Thread>();\n        for (String userId: users) {\n            final String uid = userId;\n            workers.add(new Thread(new Runnable() {\n                public void run() {\n                    try {\n                        login(new SimpleCredentials(uid, USER_PWD.toCharArray())).close();\n                    } catch (Exception e) {\n                        exceptions.add(e);\n                    }\n                }\n            }));\n        }\n        for (Thread t : workers) {\n            t.start();\n        }\n        for (Thread t : workers) {\n            t.join();\n        }\n        for (Exception e : exceptions) {\n            e.printStackTrace();\n        }\n        if (!exceptions.isEmpty()) {\n            throw exceptions.get(0);\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected static void createLdapFixture() throws Exception {\n        LDAP_SERVER.addMember(\n                GROUP_DN = LDAP_SERVER.addGroup(GROUP_NAME),\n                LDAP_SERVER.addUser(USER_FIRSTNAME, USER_LASTNAME, USER_ID, USER_PWD));\n    }","id":24290,"modified_method":"protected static void createLdapFixture() throws Exception {\n        LDAP_SERVER.addMember(\n                GROUP_DN = LDAP_SERVER.addGroup(GROUP_NAME),\n                LDAP_SERVER.addUser(USER_FIRSTNAME, USER_LASTNAME, USER_ID, USER_PWD));\n        for (int i = 0; i < NUM_CONCURRENT_LOGINS * 2; i++) {\n            final String userId = \"user-\" + i;\n            String userDN = LDAP_SERVER.addUser(userId, \"test\", userId, USER_PWD);\n            if (i%2 == 0) {\n                CONCURRENT_GROUP_TEST_USERS[i/2] = userId;\n                LDAP_SERVER.addMember(GROUP_DN, userDN);\n            } else {\n                CONCURRENT_TEST_USERS[i/2] = userId;\n            }\n        }\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"protected ExternalIdentityProvider createIDP() {\n        providerConfig = new LdapProviderConfig()\n                .setName(IDP_NAME)\n                .setHostname(\"127.0.0.1\")\n                .setPort(LDAP_SERVER.getPort())\n                .setBindDN(ServerDNConstants.ADMIN_SYSTEM_DN)\n                .setBindPassword(InternalLdapServer.ADMIN_PW)\n                .setGroupMemberAttribute(\"uniquemember\");\n\n        providerConfig.getUserConfig()\n                .setBaseDN(ServerDNConstants.USERS_SYSTEM_DN)\n                .setObjectClasses(\"inetOrgPerson\");\n        providerConfig.getGroupConfig()\n                .setBaseDN(ServerDNConstants.GROUPS_SYSTEM_DN)\n                .setObjectClasses(\"groupOfUniqueNames\");\n\n        return new LdapIdentityProvider(providerConfig);\n    }","id":24291,"modified_method":"protected ExternalIdentityProvider createIDP() {\n        providerConfig = new LdapProviderConfig()\n                .setName(IDP_NAME)\n                .setHostname(\"127.0.0.1\")\n                .setPort(LDAP_SERVER.getPort())\n                .setBindDN(ServerDNConstants.ADMIN_SYSTEM_DN)\n                .setBindPassword(InternalLdapServer.ADMIN_PW)\n                .setGroupMemberAttribute(\"uniquemember\");\n\n        providerConfig.getUserConfig()\n                .setBaseDN(ServerDNConstants.USERS_SYSTEM_DN)\n                .setObjectClasses(\"inetOrgPerson\");\n        providerConfig.getGroupConfig()\n                .setBaseDN(ServerDNConstants.GROUPS_SYSTEM_DN)\n                .setObjectClasses(\"groupOfUniqueNames\");\n\n        LdapIdentityProvider ldapIDP = new LdapIdentityProvider(providerConfig);\n        ldapIDP.disableConnectionPooling = true;\n        return ldapIDP;\n    }","commit_id":"b88b388dd144e6309768f5a2d93f19106857878c","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Package scoped to help with testing.\n     */\n    String getWorkspaceName(SlingHttpServletRequest request) {\n        return request.getResourceResolver().adaptTo(Session.class).getWorkspace().getName();\n    }","id":24292,"modified_method":"/**\n     * Package scoped to help with testing.\n     */\n    String getWorkspaceName(SlingHttpServletRequest request) {\n        return WorkspaceResourceResolver.getWorkspaceName(request.getResourceResolver());\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Activate this component.\n     */\n    protected void activate(ComponentContext context) {\n        // from configuration if available\n        final Dictionary<?, ?> properties = context.getProperties();\n        Object servletRoot = properties.get(PROP_SERVLET_ROOT);\n        if (servletRoot == null) {\n            servletRoot = DEFAULT_SERVLET_ROOT;\n        }\n\n        final Collection<ServiceReference> refs;\n        synchronized (this) {\n\n            refs = pendingServlets;\n            pendingServlets = new ArrayList<ServiceReference>();\n\n            // register servlets immediately from now on\n            this.context = context;\n\n            // workspace handling and resource resolver creation\n            this.useDefaultWorkspace = OsgiUtil.toBoolean(properties.get(PROP_USE_DEFAULT_WORKSPACE), DEFAULT_USE_DEFAULT_WORKSPACE);\n            this.useRequestWorkspace = OsgiUtil.toBoolean(properties.get(PROP_USE_REQUEST_WORKSPACE), DEFAULT_USE_REQUEST_WORKSPACE);\n\n            this.scriptSessions = new ConcurrentHashMap<String, Session>();\n            this.scriptResolvers = new ConcurrentHashMap<String, WorkspaceResourceResolver>();\n\n            String defaultWorkspaceProp = (String) properties.get(PROP_DEFAULT_SCRIPT_WORKSPACE);\n            if ( defaultWorkspaceProp != null && defaultWorkspaceProp.trim().length() == 0 ) {\n                defaultWorkspaceProp = null;\n            }\n            this.defaultScriptSession = createScriptSession(defaultWorkspaceProp);\n\n            // we load the workspaceName out of the session to ensure the value is\n            // non-null\n            this.defaultScriptWorkspaceName = this.defaultScriptSession.getWorkspace().getName();\n            this.defaultScriptResolver = new WorkspaceResourceResolver(jcrResourceResolverFactory\n                    .getResourceResolver(defaultScriptSession), defaultScriptWorkspaceName);\n\n            servletResourceProviderFactory = new ServletResourceProviderFactory(servletRoot,\n                    this.defaultScriptResolver.getSearchPath());\n        }\n        createAllServlets(refs);\n\n        // execution paths\n        this.executionPaths = OsgiUtil.toStringArray(properties.get(PROP_PATHS), DEFAULT_PATHS);\n        if ( this.executionPaths != null ) {\n            // if we find a string combination that basically allows all paths,\n            // we simply set the array to null\n            if ( this.executionPaths.length == 0 ) {\n                this.executionPaths = null;\n            } else {\n                boolean hasRoot = false;\n                for(int i = 0 ; i < this.executionPaths.length; i++) {\n                    final String path = this.executionPaths[i];\n                    if ( path == null || path.length() == 0 || path.equals(\"/\") ) {\n                        hasRoot = true;\n                    }\n                }\n                if ( hasRoot ) {\n                    this.executionPaths = null;\n                }\n            }\n        }\n\n        // create cache - if a cache size is configured\n        final int cacheSize = OsgiUtil.toInteger(properties.get(PROP_CACHE_SIZE), DEFAULT_CACHE_SIZE);\n        if (cacheSize > 5) {\n            this.cache = new ConcurrentHashMap<AbstractResourceCollector, Servlet>(cacheSize);\n        }\n\n        // and finally register as event listener\n        this.eventHandlerReg = context.getBundleContext().registerService(EventHandler.class.getName(), this,\n                properties);\n    }","id":24293,"modified_method":"/**\n     * Activate this component.\n     */\n    protected void activate(ComponentContext context) throws LoginException {\n        // from configuration if available\n        final Dictionary<?, ?> properties = context.getProperties();\n        Object servletRoot = properties.get(PROP_SERVLET_ROOT);\n        if (servletRoot == null) {\n            servletRoot = DEFAULT_SERVLET_ROOT;\n        }\n\n        final Collection<ServiceReference> refs;\n        synchronized (this) {\n\n            refs = pendingServlets;\n            pendingServlets = new ArrayList<ServiceReference>();\n\n            // register servlets immediately from now on\n            this.context = context;\n\n            // workspace handling and resource resolver creation\n            this.useDefaultWorkspace = OsgiUtil.toBoolean(properties.get(PROP_USE_DEFAULT_WORKSPACE), DEFAULT_USE_DEFAULT_WORKSPACE);\n            this.useRequestWorkspace = OsgiUtil.toBoolean(properties.get(PROP_USE_REQUEST_WORKSPACE), DEFAULT_USE_REQUEST_WORKSPACE);\n\n            this.scriptResolvers = new ConcurrentHashMap<String, WorkspaceResourceResolver>();\n\n            String defaultWorkspaceProp = (String) properties.get(PROP_DEFAULT_SCRIPT_WORKSPACE);\n            if ( defaultWorkspaceProp != null && defaultWorkspaceProp.trim().length() == 0 ) {\n                defaultWorkspaceProp = null;\n            }\n\n            this.defaultScriptResolver = new WorkspaceResourceResolver(\n                    resourceResolverFactory.getAdministrativeResourceResolver(this.createAuthenticationInfo(defaultWorkspaceProp)));\n\n            servletResourceProviderFactory = new ServletResourceProviderFactory(servletRoot,\n                    this.defaultScriptResolver.getSearchPath());\n        }\n        createAllServlets(refs);\n\n        // execution paths\n        this.executionPaths = OsgiUtil.toStringArray(properties.get(PROP_PATHS), DEFAULT_PATHS);\n        if ( this.executionPaths != null ) {\n            // if we find a string combination that basically allows all paths,\n            // we simply set the array to null\n            if ( this.executionPaths.length == 0 ) {\n                this.executionPaths = null;\n            } else {\n                boolean hasRoot = false;\n                for(int i = 0 ; i < this.executionPaths.length; i++) {\n                    final String path = this.executionPaths[i];\n                    if ( path == null || path.length() == 0 || path.equals(\"/\") ) {\n                        hasRoot = true;\n                    }\n                }\n                if ( hasRoot ) {\n                    this.executionPaths = null;\n                }\n            }\n        }\n\n        // create cache - if a cache size is configured\n        final int cacheSize = OsgiUtil.toInteger(properties.get(PROP_CACHE_SIZE), DEFAULT_CACHE_SIZE);\n        if (cacheSize > 5) {\n            this.cache = new ConcurrentHashMap<AbstractResourceCollector, Servlet>(cacheSize);\n        }\n\n        // and finally register as event listener\n        this.eventHandlerReg = context.getBundleContext().registerService(EventHandler.class.getName(), this,\n                properties);\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"public void handleError(Throwable throwable, SlingHttpServletRequest request, SlingHttpServletResponse response)\n            throws IOException {\n        String wspName = getWorkspaceName(request);\n        WorkspaceResourceResolver scriptResolver = getScriptResolver(wspName);\n\n        // do not handle, if already handling ....\n        if (request.getAttribute(SlingConstants.ERROR_REQUEST_URI) != null) {\n            log.error(\"handleError: Recursive invocation. Not further handling Throwable:\", throwable);\n            return;\n        }\n\n        // start tracker\n        RequestProgressTracker tracker = request.getRequestProgressTracker();\n        String timerName = \"handleError:throwable=\" + throwable.getClass().getName();\n        tracker.startTimer(timerName);\n\n        try {\n\n            // find the error handler component\n            Servlet servlet = null;\n            Resource resource = getErrorResource(request);\n\n            Class<?> tClass = throwable.getClass();\n            while (servlet == null && tClass != Object.class) {\n                // find a servlet for the simple class name as the method name\n                ResourceCollector locationUtil = new ResourceCollector(tClass.getSimpleName(),\n                        ServletResolverConstants.ERROR_HANDLER_PATH, resource, scriptResolver.getWorkspaceName(),\n                        this.executionPaths);\n                servlet = getServlet(locationUtil, request, scriptResolver);\n\n                // go to the base class\n                tClass = tClass.getSuperclass();\n            }\n\n            if (servlet == null) {\n                servlet = getDefaultErrorServlet(request, scriptResolver,\n                    resource);\n            }\n\n            // set the message properties\n            request.setAttribute(SlingConstants.ERROR_EXCEPTION, throwable);\n            request.setAttribute(SlingConstants.ERROR_EXCEPTION_TYPE, throwable.getClass());\n            request.setAttribute(SlingConstants.ERROR_MESSAGE, throwable.getMessage());\n\n            // log a track entry after resolution before calling the handler\n            tracker.logTimer(timerName, \"Using handler {0}\", RequestUtil.getServletName(servlet));\n\n            handleError(servlet, request, response);\n\n        } finally {\n\n            tracker.logTimer(timerName, \"Error handler finished\");\n\n        }\n    }","id":24294,"modified_method":"public void handleError(Throwable throwable, SlingHttpServletRequest request, SlingHttpServletResponse response)\n    throws IOException {\n        // do not handle, if already handling ....\n        if (request.getAttribute(SlingConstants.ERROR_REQUEST_URI) != null) {\n            log.error(\"handleError: Recursive invocation. Not further handling Throwable:\", throwable);\n            return;\n        }\n\n        // start tracker\n        RequestProgressTracker tracker = request.getRequestProgressTracker();\n        String timerName = \"handleError:throwable=\" + throwable.getClass().getName();\n        tracker.startTimer(timerName);\n\n        try {\n            final WorkspaceResourceResolver scriptResolver = getScriptResolver(getWorkspaceName(request));\n\n            // find the error handler component\n            Servlet servlet = null;\n            Resource resource = getErrorResource(request);\n\n            Class<?> tClass = throwable.getClass();\n            while (servlet == null && tClass != Object.class) {\n                // find a servlet for the simple class name as the method name\n                ResourceCollector locationUtil = new ResourceCollector(tClass.getSimpleName(),\n                        ServletResolverConstants.ERROR_HANDLER_PATH, resource, scriptResolver.getWorkspaceName(),\n                        this.executionPaths);\n                servlet = getServlet(locationUtil, request, scriptResolver);\n\n                // go to the base class\n                tClass = tClass.getSuperclass();\n            }\n\n            if (servlet == null) {\n                servlet = getDefaultErrorServlet(request, scriptResolver,\n                    resource);\n            }\n\n            // set the message properties\n            request.setAttribute(SlingConstants.ERROR_EXCEPTION, throwable);\n            request.setAttribute(SlingConstants.ERROR_EXCEPTION_TYPE, throwable.getClass());\n            request.setAttribute(SlingConstants.ERROR_MESSAGE, throwable.getMessage());\n\n            // log a track entry after resolution before calling the handler\n            tracker.logTimer(timerName, \"Using handler {0}\", RequestUtil.getServletName(servlet));\n\n            handleError(servlet, request, response);\n        } finally {\n\n            tracker.logTimer(timerName, \"Error handler finished\");\n\n        }\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"private WorkspaceResourceResolver getScriptResolver(String wspName) {\n        if (wspName.equals(defaultScriptWorkspaceName)) {\n            return defaultScriptResolver;\n        }\n\n        WorkspaceResourceResolver scriptResolver = scriptResolvers.get(wspName);\n        if (scriptResolver != null) {\n            return scriptResolver;\n        }\n\n        // create the script session\n        Session scriptSession = createScriptSession(wspName);\n\n        Session sessionFromMap = scriptSessions.putIfAbsent(wspName, scriptSession);\n        if (sessionFromMap != null) {\n            // another session was bound while this session was being created\n            // abandon ship\n            scriptSession.logout();\n            scriptSession = sessionFromMap;\n        }\n\n        scriptResolver = new WorkspaceResourceResolver(this.jcrResourceResolverFactory.getResourceResolver(scriptSession),\n                wspName);\n        WorkspaceResourceResolver resolverFromMap = scriptResolvers.putIfAbsent(wspName, scriptResolver);\n        if (resolverFromMap != null) {\n            // another resolver was bound while this resolver was being created\n            // abandon ship\n            scriptResolver = resolverFromMap;\n        }\n\n        return scriptResolver;\n    }","id":24295,"modified_method":"/**\n     * Get a resource resolver for the given workspace.\n     * If the login to the given workspace does not work, we return the default resource resolver!\n     * @param wspName The workspace name or null for the default workspace\n     * @return A resource resolver\n     */\n    private WorkspaceResourceResolver getScriptResolver(String wspName) {\n        if (wspName == null || wspName.equals(defaultScriptResolver.getWorkspaceName())) {\n            return defaultScriptResolver;\n        }\n\n        WorkspaceResourceResolver scriptResolver = scriptResolvers.get(wspName);\n        if (scriptResolver != null) {\n            return scriptResolver;\n        }\n\n        try {\n            scriptResolver = new WorkspaceResourceResolver(this.resourceResolverFactory.getResourceResolver(createAuthenticationInfo(wspName)));\n            WorkspaceResourceResolver resolverFromMap = scriptResolvers.putIfAbsent(wspName, scriptResolver);\n            if (resolverFromMap != null) {\n                // another resolver was bound while this resolver was being created\n                // abandon ship\n                scriptResolver.close();\n                scriptResolver = resolverFromMap;\n            }\n        } catch (LoginException le) {\n            log.warn(\"Unable to login into workspace \" + wspName + \" : \" + le.getMessage(), le);\n            scriptResolver = defaultScriptResolver;\n        }\n        return scriptResolver;\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.engine.servlets.ErrorHandler#handleError(int,\n     *      String, SlingHttpServletRequest, SlingHttpServletResponse)\n     */\n    public void handleError(int status, String message, SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws IOException {\n        String wspName = getWorkspaceName(request);\n        WorkspaceResourceResolver scriptResolver = getScriptResolver(wspName);\n\n        // do not handle, if already handling ....\n        if (request.getAttribute(SlingConstants.ERROR_REQUEST_URI) != null) {\n            log.error(\"handleError: Recursive invocation. Not further handling status \" + status + \"(\" + message + \")\");\n            return;\n        }\n\n        // start tracker\n        RequestProgressTracker tracker = request.getRequestProgressTracker();\n        String timerName = \"handleError:status=\" + status;\n        tracker.startTimer(timerName);\n\n        try {\n\n            // find the error handler component\n            Resource resource = getErrorResource(request);\n\n            // find a servlet for the status as the method name\n            ResourceCollector locationUtil = new ResourceCollector(String.valueOf(status),\n                    ServletResolverConstants.ERROR_HANDLER_PATH, resource, scriptResolver.getWorkspaceName(),\n                    this.executionPaths);\n            Servlet servlet = getServlet(locationUtil, request, scriptResolver);\n\n            // fall back to default servlet if none\n            if (servlet == null) {\n                servlet = getDefaultErrorServlet(request, scriptResolver,\n                    resource);\n            }\n\n            // set the message properties\n            request.setAttribute(ERROR_STATUS, new Integer(status));\n            request.setAttribute(ERROR_MESSAGE, message);\n\n            // the servlet name for a sendError handling is still stored\n            // as the request attribute\n            Object servletName = request.getAttribute(SLING_CURRENT_SERVLET_NAME);\n            if (servletName instanceof String) {\n                request.setAttribute(ERROR_SERVLET_NAME, servletName);\n            }\n\n            // log a track entry after resolution before calling the handler\n            tracker.logTimer(timerName, \"Using handler {0}\", RequestUtil.getServletName(servlet));\n\n            handleError(servlet, request, response);\n\n        } finally {\n\n            tracker.logTimer(timerName, \"Error handler finished\");\n\n        }\n    }","id":24296,"modified_method":"/**\n     * @see org.apache.sling.engine.servlets.ErrorHandler#handleError(int,\n     *      String, SlingHttpServletRequest, SlingHttpServletResponse)\n     */\n    public void handleError(int status, String message, SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws IOException {\n\n        // do not handle, if already handling ....\n        if (request.getAttribute(SlingConstants.ERROR_REQUEST_URI) != null) {\n            log.error(\"handleError: Recursive invocation. Not further handling status \" + status + \"(\" + message + \")\");\n            return;\n        }\n\n        // start tracker\n        RequestProgressTracker tracker = request.getRequestProgressTracker();\n        String timerName = \"handleError:status=\" + status;\n        tracker.startTimer(timerName);\n\n        try {\n            final WorkspaceResourceResolver scriptResolver = getScriptResolver(getWorkspaceName(request));\n\n            // find the error handler component\n            Resource resource = getErrorResource(request);\n\n            // find a servlet for the status as the method name\n            ResourceCollector locationUtil = new ResourceCollector(String.valueOf(status),\n                    ServletResolverConstants.ERROR_HANDLER_PATH, resource, scriptResolver.getWorkspaceName(),\n                    this.executionPaths);\n            Servlet servlet = getServlet(locationUtil, request, scriptResolver);\n\n            // fall back to default servlet if none\n            if (servlet == null) {\n                servlet = getDefaultErrorServlet(request, scriptResolver,\n                    resource);\n            }\n\n            // set the message properties\n            request.setAttribute(ERROR_STATUS, new Integer(status));\n            request.setAttribute(ERROR_MESSAGE, message);\n\n            // the servlet name for a sendError handling is still stored\n            // as the request attribute\n            Object servletName = request.getAttribute(SLING_CURRENT_SERVLET_NAME);\n            if (servletName instanceof String) {\n                request.setAttribute(ERROR_SERVLET_NAME, servletName);\n            }\n\n            // log a track entry after resolution before calling the handler\n            tracker.logTimer(timerName, \"Using handler {0}\", RequestUtil.getServletName(servlet));\n\n            handleError(servlet, request, response);\n\n        } finally {\n\n            tracker.logTimer(timerName, \"Error handler finished\");\n\n        }\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Deactivate this component.\n     */\n    protected void deactivate(ComponentContext context) {\n        // unregister event handler\n        if (this.eventHandlerReg != null) {\n            this.eventHandlerReg.unregister();\n            this.eventHandlerReg = null;\n        }\n\n        // Copy the list of servlets first, to minimize the need for\n        // synchronization\n        final Collection<ServiceReference> refs;\n        synchronized (this) {\n            refs = new ArrayList<ServiceReference>(servletsByReference.keySet());\n        }\n        // destroy all servlets\n        destroyAllServlets(refs);\n\n        // destroy the fallback error handler servlet\n        if (fallbackErrorServlet != null) {\n            try {\n                fallbackErrorServlet.destroy();\n            } catch (Throwable t) {\n                // ignore\n            } finally {\n                fallbackErrorServlet = null;\n            }\n        }\n\n        // close sessions\n        if (this.scriptSessions != null && (!this.scriptSessions.isEmpty())) {\n            for (Session session : this.scriptSessions.values()) {\n                session.logout();\n            }\n        }\n        this.scriptSessions = null;\n        this.scriptResolvers = null;\n\n        if (this.defaultScriptSession != null) {\n            this.defaultScriptSession.logout();\n        }\n        this.defaultScriptSession = null;\n        this.defaultScriptResolver = null;\n\n        this.context = null;\n        this.cache = null;\n        this.servletResourceProviderFactory = null;\n    }","id":24297,"modified_method":"/**\n     * Deactivate this component.\n     */\n    protected void deactivate(ComponentContext context) {\n        // unregister event handler\n        if (this.eventHandlerReg != null) {\n            this.eventHandlerReg.unregister();\n            this.eventHandlerReg = null;\n        }\n\n        // Copy the list of servlets first, to minimize the need for\n        // synchronization\n        final Collection<ServiceReference> refs;\n        synchronized (this) {\n            refs = new ArrayList<ServiceReference>(servletsByReference.keySet());\n        }\n        // destroy all servlets\n        destroyAllServlets(refs);\n\n        // destroy the fallback error handler servlet\n        if (fallbackErrorServlet != null) {\n            try {\n                fallbackErrorServlet.destroy();\n            } catch (Throwable t) {\n                // ignore\n            } finally {\n                fallbackErrorServlet = null;\n            }\n        }\n\n        // close sessions\n        if (this.scriptResolvers != null ) {\n            for (final ResourceResolver resolver : this.scriptResolvers.values()) {\n                resolver.close();\n            }\n            this.scriptResolvers = null;\n        }\n\n        if (this.defaultScriptResolver != null) {\n            this.defaultScriptResolver.close();\n            this.defaultScriptResolver = null;\n        }\n\n        this.context = null;\n        this.cache = null;\n        this.servletResourceProviderFactory = null;\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.api.servlets.ServletResolver#resolveServlet(org.apache.sling.api.SlingHttpServletRequest)\n     */\n    public Servlet resolveServlet(final SlingHttpServletRequest request) {\n        final Resource resource = request.getResource();\n\n        // start tracking servlet resolution\n        final RequestProgressTracker tracker = request.getRequestProgressTracker();\n        final String timerName = \"resolveServlet(\" + resource + \")\";\n        tracker.startTimer(timerName);\n\n        final String type = resource.getResourceType();\n        if (log.isDebugEnabled()) {\n            log.debug(\"resolveServlet called for resource {}\", resource);\n        }\n\n        Servlet servlet = null;\n        String wspName = getWorkspaceName(request);\n\n        if (this.useRequestWorkspace) {\n            // First, we use a resource resolver using the same workspace as the\n            // resource\n            WorkspaceResourceResolver scriptResolver = getScriptResolver(wspName);\n            servlet = resolveServlet(request, type, scriptResolver);\n\n            if (servlet == null && defaultScriptWorkspaceName != wspName && this.useDefaultWorkspace) {\n                servlet = resolveServlet(request, type, defaultScriptResolver);\n            }\n\n        } else {\n            servlet = resolveServlet(request, type, defaultScriptResolver);\n        }\n\n        // last resort, use the core bundle default servlet\n        if (servlet == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No specific servlet found, trying default\");\n            }\n            servlet = getDefaultServlet();\n        }\n\n        // track servlet resolution termination\n        if (servlet == null) {\n            tracker.logTimer(timerName, \"Servlet resolution failed. See log for details\");\n        } else {\n            tracker.logTimer(timerName, \"Using servlet {0}\", RequestUtil.getServletName(servlet));\n        }\n\n        // log the servlet found\n        if (log.isDebugEnabled()) {\n            if (servlet != null) {\n                log.debug(\"Servlet {} found for resource={}\", RequestUtil.getServletName(servlet), resource);\n            } else {\n                log.debug(\"No servlet found for resource={}\", resource);\n            }\n        }\n\n        return servlet;\n    }","id":24298,"modified_method":"/**\n     * @see org.apache.sling.api.servlets.ServletResolver#resolveServlet(org.apache.sling.api.SlingHttpServletRequest)\n     */\n    public Servlet resolveServlet(final SlingHttpServletRequest request) {\n        final Resource resource = request.getResource();\n\n        // start tracking servlet resolution\n        final RequestProgressTracker tracker = request.getRequestProgressTracker();\n        final String timerName = \"resolveServlet(\" + resource + \")\";\n        tracker.startTimer(timerName);\n\n        final String type = resource.getResourceType();\n        if (log.isDebugEnabled()) {\n            log.debug(\"resolveServlet called for resource {}\", resource);\n        }\n\n        Servlet servlet = null;\n\n        if (this.useRequestWorkspace) {\n            final String wspName = getWorkspaceName(request);\n            // First, we use a resource resolver using the same workspace as the\n            // resource\n            WorkspaceResourceResolver scriptResolver = getScriptResolver(wspName);\n            servlet = resolveServlet(request, type, scriptResolver);\n\n            if (servlet == null && this.useDefaultWorkspace\n                    && !WorkspaceResourceResolver.isSameWorkspace(wspName, defaultScriptResolver.getWorkspaceName()) ) {\n                servlet = resolveServlet(request, type, defaultScriptResolver);\n            }\n\n        } else {\n            servlet = resolveServlet(request, type, defaultScriptResolver);\n        }\n\n        // last resort, use the core bundle default servlet\n        if (servlet == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No specific servlet found, trying default\");\n            }\n            servlet = getDefaultServlet();\n        }\n\n        // track servlet resolution termination\n        if (servlet == null) {\n            tracker.logTimer(timerName, \"Servlet resolution failed. See log for details\");\n        } else {\n            tracker.logTimer(timerName, \"Using servlet {0}\", RequestUtil.getServletName(servlet));\n        }\n\n        // log the servlet found\n        if (log.isDebugEnabled()) {\n            if (servlet != null) {\n                log.debug(\"Servlet {} found for resource={}\", RequestUtil.getServletName(servlet), resource);\n            } else {\n                log.debug(\"No servlet found for resource={}\", resource);\n            }\n        }\n\n        return servlet;\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"@Before public void setUp() throws Exception {\n        mockResourceResolver = new MockResourceResolver() {\n            public void close() {\n                // nothing to do;\n            }\n        };\n        mockResourceResolver.setSearchPath(\"/\");\n\n        final JcrResourceResolverFactory factory = new JcrResourceResolverFactory() {\n\n            public ResourceResolver getResourceResolver(Session session) {\n                return mockResourceResolver;\n            }\n        };\n\n        servlet = new MockSlingRequestHandlerServlet();\n        servletResolver = new SlingServletResolver() {\n\n            @Override\n            String getWorkspaceName(SlingHttpServletRequest request) {\n                return getRequestWorkspaceName();\n            }\n\n        };\n\n        // set sling repository\n        final SlingRepository repository = this.context.mock(SlingRepository.class);\n        addExpectations(repository);\n\n        Class<?> resolverClass = servletResolver.getClass().getSuperclass();\n\n        // set resource resolver factory\n        final Field resolverField = resolverClass.getDeclaredField(\"jcrResourceResolverFactory\");\n        resolverField.setAccessible(true);\n        resolverField.set(servletResolver, factory);\n\n        final Field repositoryField = resolverClass.getDeclaredField(\"repository\");\n        repositoryField.setAccessible(true);\n        repositoryField.set(servletResolver, repository);\n\n        MockBundle bundle = new MockBundle(1L);\n        MockComponentContext mockComponentContext = new MockComponentContext(\n            bundle, SlingServletResolverTest.this.servlet);\n        MockServiceReference serviceReference = new MockServiceReference(bundle);\n        serviceReference.setProperty(Constants.SERVICE_ID, 1L);\n        serviceReference.setProperty(SLING_SERLVET_NAME,\n            SERVLET_NAME);\n        serviceReference.setProperty(\n            ServletResolverConstants.SLING_SERVLET_PATHS, SERVLET_PATH);\n        serviceReference.setProperty(\n            ServletResolverConstants.SLING_SERVLET_EXTENSIONS,\n            SERVLET_EXTENSION);\n        mockComponentContext.locateService(SERVLET_NAME, serviceReference);\n\n        configureComponentContext(mockComponentContext);\n\n        servletResolver.bindServlet(serviceReference);\n        servletResolver.activate(mockComponentContext);\n\n        String path = \"/\"\n            + MockSlingHttpServletRequest.RESOURCE_TYPE\n            + \"/\"\n            + ResourceUtil.getName(MockSlingHttpServletRequest.RESOURCE_TYPE)\n            + \".servlet\";\n        MockServletResource res = new MockServletResource(mockResourceResolver,\n            servlet, path);\n        mockResourceResolver.addResource(res);\n\n        MockResource parent = new MockResource(mockResourceResolver,\n            ResourceUtil.getParent(res.getPath()), \"nt:folder\");\n        mockResourceResolver.addResource(parent);\n\n        List<Resource> childRes = new ArrayList<Resource>();\n        childRes.add(res);\n        mockResourceResolver.addChildren(parent, childRes);\n    }","id":24299,"modified_method":"@Before public void setUp() throws Exception {\n        mockResourceResolver = new MockResourceResolver() {\n            public void close() {\n                // nothing to do;\n            }\n\n            @Override\n            public <AdapterType> AdapterType adaptTo(Class<AdapterType> type) {\n                return null;\n            }\n        };\n        mockResourceResolver.setSearchPath(\"/\");\n\n        final ResourceResolverFactory factory = new ResourceResolverFactory() {\n\n            public ResourceResolver getAdministrativeResourceResolver(\n                    Map<String, Object> authenticationInfo)\n                    throws LoginException {\n                return mockResourceResolver;\n            }\n\n            public ResourceResolver getResourceResolver(\n                    Map<String, Object> authenticationInfo)\n                    throws LoginException {\n                return mockResourceResolver;\n            }\n        };\n\n        servlet = new MockSlingRequestHandlerServlet();\n        servletResolver = new SlingServletResolver() {\n\n            @Override\n            String getWorkspaceName(SlingHttpServletRequest request) {\n                return getRequestWorkspaceName();\n            }\n\n        };\n\n        Class<?> resolverClass = servletResolver.getClass().getSuperclass();\n\n        // set resource resolver factory\n        final Field resolverField = resolverClass.getDeclaredField(\"resourceResolverFactory\");\n        resolverField.setAccessible(true);\n        resolverField.set(servletResolver, factory);\n\n        MockBundle bundle = new MockBundle(1L);\n        MockComponentContext mockComponentContext = new MockComponentContext(\n            bundle, SlingServletResolverTest.this.servlet);\n        MockServiceReference serviceReference = new MockServiceReference(bundle);\n        serviceReference.setProperty(Constants.SERVICE_ID, 1L);\n        serviceReference.setProperty(SLING_SERLVET_NAME,\n            SERVLET_NAME);\n        serviceReference.setProperty(\n            ServletResolverConstants.SLING_SERVLET_PATHS, SERVLET_PATH);\n        serviceReference.setProperty(\n            ServletResolverConstants.SLING_SERVLET_EXTENSIONS,\n            SERVLET_EXTENSION);\n        mockComponentContext.locateService(SERVLET_NAME, serviceReference);\n\n        configureComponentContext(mockComponentContext);\n\n        servletResolver.bindServlet(serviceReference);\n        servletResolver.activate(mockComponentContext);\n\n        String path = \"/\"\n            + MockSlingHttpServletRequest.RESOURCE_TYPE\n            + \"/\"\n            + ResourceUtil.getName(MockSlingHttpServletRequest.RESOURCE_TYPE)\n            + \".servlet\";\n        MockServletResource res = new MockServletResource(mockResourceResolver,\n            servlet, path);\n        mockResourceResolver.addResource(res);\n\n        MockResource parent = new MockResource(mockResourceResolver,\n            ResourceUtil.getParent(res.getPath()), \"nt:folder\");\n        mockResourceResolver.addResource(parent);\n\n        List<Resource> childRes = new ArrayList<Resource>();\n        childRes.add(res);\n        mockResourceResolver.addChildren(parent, childRes);\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"public WorkspaceResourceResolver(ResourceResolver delegate, String workspaceName) {\n        this.delegate = delegate;\n        this.workspaceName = workspaceName;\n    }","id":24300,"modified_method":"public WorkspaceResourceResolver(ResourceResolver delegate) {\n        this.delegate = delegate;\n        this.workspaceName = getWorkspaceName(delegate);\n    }","commit_id":"1ba1f40d10f2b2cb8cf8de225a533800cae9312d","url":"https://github.com/apache/sling"},{"original_method":"public AbstractResourceCollector(final String baseResourceType,\n            final String resourceType,\n            final String resourceSuperType,\n            final String extension,\n            final String[] executionPaths) {\n        this.baseResourceType = baseResourceType;\n        this.resourceType = resourceType;\n        this.resourceSuperType = resourceSuperType;\n        this.extension = extension;\n        this.executionPaths = executionPaths;\n    }","id":24301,"modified_method":"public AbstractResourceCollector(final String baseResourceType,\n            final String resourceType,\n            final String resourceSuperType,\n            final String workspaceName,\n            final String extension,\n            final String[] executionPaths) {\n        this.baseResourceType = baseResourceType;\n        this.resourceType = resourceType;\n        this.resourceSuperType = resourceSuperType;\n        this.extension = extension;\n        this.executionPaths = executionPaths;\n        this.workspaceName = workspaceName;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n        if ( !(obj instanceof AbstractResourceCollector) ) {\n            return false;\n        }\n        if ( obj == this ) {\n            return true;\n        }\n        final AbstractResourceCollector o = (AbstractResourceCollector)obj;\n        if ( stringEquals(resourceType, o.resourceType)\n             && stringEquals(resourceSuperType, o.resourceSuperType)\n             && stringEquals(extension, o.extension)\n             && stringEquals(baseResourceType, o.baseResourceType)) {\n            return true;\n        }\n        return false;\n    }","id":24302,"modified_method":"@Override\n    public boolean equals(Object obj) {\n        if ( !(obj instanceof AbstractResourceCollector) ) {\n            return false;\n        }\n        if ( obj == this ) {\n            return true;\n        }\n        final AbstractResourceCollector o = (AbstractResourceCollector)obj;\n        if ( stringEquals(resourceType, o.resourceType)\n             && stringEquals(resourceSuperType, o.resourceSuperType)\n             && stringEquals(extension, o.extension)\n             && stringEquals(baseResourceType, o.baseResourceType)\n             && stringEquals(workspaceName, o.workspaceName)) {\n            return true;\n        }\n        return false;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns a resource for the given <code>path<\/code>.\n     * If no resource exists at the given path a\n     * <code>SyntheticResource<\/code> is returned.\n     *\n     * @param resolver The <code>ResourceResolver<\/code> used to access the\n     *            resource.\n     * @param path The absolute path of the resource to return.\n     * @return The actual resource at the given <code>path<\/code> or a\n     *         synthetic resource representing the path location.\n     */\n    protected final Resource getResource(final ResourceResolver resolver,\n                                         String path) {\n        Resource res = resolver.getResource(path);\n\n        if (res == null) {\n            if (!path.startsWith(\"/\")) {\n                path = \"/\".concat(path);\n            }\n\n            res = new SyntheticResource(resolver, path, \"$synthetic$\");\n        }\n\n        return res;\n    }","id":24303,"modified_method":"/**\n     * Returns a resource for the given <code>path<\/code>.\n     * If no resource exists at the given path a\n     * <code>SyntheticResource<\/code> is returned.\n     *\n     * @param resolver The <code>ResourceResolver<\/code> used to access the\n     *            resource.\n     * @param path The absolute path of the resource to return.\n     * @return The actual resource at the given <code>path<\/code> or a\n     *         synthetic resource representing the path location.\n     */\n    protected final Resource getResource(final ResourceResolver resolver,\n                                         String path) {\n        if ( this.workspaceName != null ) {\n            path = workspaceName + ':' + path;\n        }\n        Resource res = resolver.getResource(path);\n\n        if (res == null) {\n            if (!path.startsWith(\"/\")) {\n                path = \"/\".concat(path);\n            }\n\n            res = new SyntheticResource(resolver, path, \"$synthetic$\");\n        }\n\n        return res;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"public NamedScriptResourceCollector(final String baseResourceType,\n                              final String resourceType,\n                              final String resourceSuperType,\n                              final String scriptName,\n                              final String extension,\n                              final String[] executionPaths) {\n        super(baseResourceType, resourceType, resourceSuperType, extension, executionPaths);\n        this.scriptName = scriptName;\n        // create the hash code once\n        final String key = baseResourceType + ':' + this.scriptName + ':' +\n            this.resourceType + ':' + (this.resourceSuperType == null ? \"\" : this.resourceSuperType) +\n            ':' + (this.extension == null ? \"\" : this.extension);\n        this.hashCode = key.hashCode();\n    }","id":24304,"modified_method":"public NamedScriptResourceCollector(final String baseResourceType,\n                              final String resourceType,\n                              final String resourceSuperType,\n                              final String scriptName,\n                              final String extension,\n                              final String[] executionPaths) {\n        super(baseResourceType, resourceType, resourceSuperType, null, extension, executionPaths);\n        this.scriptName = scriptName;\n        // create the hash code once\n        final String key = baseResourceType + ':' + this.scriptName + ':' +\n            this.resourceType + ':' + (this.resourceSuperType == null ? \"\" : this.resourceSuperType) +\n            ':' + (this.extension == null ? \"\" : this.extension);\n        this.hashCode = key.hashCode();\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Creates a <code>ResourceCollector<\/code> finding servlets and scripts\n     * for the given <code>methodName<\/code>.\n     *\n     * @param methodName The <code>methodName<\/code> used to find scripts for.\n     *            This must not be <code>null<\/code>.\n     * @param workspaceName The <code>workspaceName<\/code>.\n     * @param baseResourceType The basic resource type to use as a final\n     *            resource super type. If this is <code>null<\/code> the\n     *            default value\n     *            {@link org.apache.sling.servlets.resolver.internal.ServletResolverConstants#DEFAULT_SERVLET_NAME}\n     *            is assumed.\n     */\n    private ResourceCollector(final SlingHttpServletRequest request,\n            final String workspaceName,\n            final String[] executionPaths) {\n        super(ServletResolverConstants.DEFAULT_SERVLET_NAME,\n                request.getResource().getResourceType(),\n                request.getResource().getResourceSuperType(),\n                request.getRequestPathInfo().getExtension(),\n                executionPaths);\n        this.methodName = request.getMethod();\n\n        RequestPathInfo requestpaInfo = request.getRequestPathInfo();\n\n        requestSelectors = requestpaInfo.getSelectors();\n        numRequestSelectors = requestSelectors.length;\n\n        isGet = \"GET\".equals(methodName) || \"HEAD\".equals(methodName);\n        isHtml = isGet && \"html\".equals(extension);\n\n        this.workspaceName = workspaceName;\n        // create the hash code once\n        final String key = methodName + ':' + baseResourceType + ':' + extension + ':' + requestpaInfo.getSelectorString() + ':' +\n            (this.resourceType == null ? \"\" : this.resourceType)+ ':' + (this.resourceSuperType == null ? \"\" : this.resourceSuperType) +\n            ':' + (this.workspaceName == null ? \"\" : this.workspaceName);\n        this.hashCode = key.hashCode();\n    }","id":24305,"modified_method":"/**\n     * Creates a <code>ResourceCollector<\/code> finding servlets and scripts\n     * for the given <code>methodName<\/code>.\n     *\n     * @param methodName The <code>methodName<\/code> used to find scripts for.\n     *            This must not be <code>null<\/code>.\n     * @param workspaceName The <code>workspaceName<\/code>.\n     * @param baseResourceType The basic resource type to use as a final\n     *            resource super type. If this is <code>null<\/code> the\n     *            default value\n     *            {@link org.apache.sling.servlets.resolver.internal.ServletResolverConstants#DEFAULT_SERVLET_NAME}\n     *            is assumed.\n     */\n    private ResourceCollector(final SlingHttpServletRequest request,\n            final String workspaceName,\n            final String[] executionPaths) {\n        super(ServletResolverConstants.DEFAULT_SERVLET_NAME,\n                request.getResource().getResourceType(),\n                request.getResource().getResourceSuperType(),\n                workspaceName,\n                request.getRequestPathInfo().getExtension(),\n                executionPaths);\n        this.methodName = request.getMethod();\n\n        RequestPathInfo requestpaInfo = request.getRequestPathInfo();\n\n        requestSelectors = requestpaInfo.getSelectors();\n        numRequestSelectors = requestSelectors.length;\n\n        isGet = \"GET\".equals(methodName) || \"HEAD\".equals(methodName);\n        isHtml = isGet && \"html\".equals(extension);\n\n        // create the hash code once\n        final String key = methodName + ':' + baseResourceType + ':' + extension + ':' + requestpaInfo.getSelectorString() + ':' +\n            (this.resourceType == null ? \"\" : this.resourceType)+ ':' + (this.resourceSuperType == null ? \"\" : this.resourceSuperType) +\n            ':' + (this.workspaceName == null ? \"\" : this.workspaceName);\n        this.hashCode = key.hashCode();\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Creates a <code>ResourceCollector<\/code> finding servlets and scripts\n     * for the given <code>methodName<\/code>.\n     *\n     * @param methodName The <code>methodName<\/code> used to find scripts for.\n     *            This must not be <code>null<\/code>.\n     * @param baseResourceType The basic resource type to use as a final\n     *            resource super type. If this is <code>null<\/code> the\n     *            default value\n     *            {@link org.apache.sling.servlets.resolver.internal.ServletResolverConstants#DEFAULT_SERVLET_NAME}\n     *            is assumed.\n     * @param resource the resource to invoke, the resource type and resource super type are taken from this resource.\n     */\n    public ResourceCollector(final String methodName,\n            final String baseResourceType,\n            final Resource resource,\n            final String workspaceName,\n            final String[] executionPaths) {\n        super((baseResourceType != null ? baseResourceType : ServletResolverConstants.DEFAULT_SERVLET_NAME),\n                resource.getResourceType(),\n                resource.getResourceSuperType(),\n                null,\n                executionPaths);\n        this.methodName = methodName;\n        this.requestSelectors = new String[0];\n        this.numRequestSelectors = 0;\n        this.isGet = false;\n        this.isHtml = false;\n\n        this.workspaceName = workspaceName;\n        // create the hash code once\n        final String key = methodName + ':' + baseResourceType + ':' + extension + \"::\" +\n            (this.resourceType == null ? \"\" : this.resourceType)+ ':' + (this.resourceSuperType == null ? \"\" : this.resourceSuperType) +\n            ':' + (this.workspaceName == null ? \"\" : this.workspaceName);\n        this.hashCode = key.hashCode();\n    }","id":24306,"modified_method":"/**\n     * Creates a <code>ResourceCollector<\/code> finding servlets and scripts\n     * for the given <code>methodName<\/code>.\n     *\n     * @param methodName The <code>methodName<\/code> used to find scripts for.\n     *            This must not be <code>null<\/code>.\n     * @param baseResourceType The basic resource type to use as a final\n     *            resource super type. If this is <code>null<\/code> the\n     *            default value\n     *            {@link org.apache.sling.servlets.resolver.internal.ServletResolverConstants#DEFAULT_SERVLET_NAME}\n     *            is assumed.\n     * @param resource the resource to invoke, the resource type and resource super type are taken from this resource.\n     */\n    public ResourceCollector(final String methodName,\n            final String baseResourceType,\n            final Resource resource,\n            final String workspaceName,\n            final String[] executionPaths) {\n        super((baseResourceType != null ? baseResourceType : ServletResolverConstants.DEFAULT_SERVLET_NAME),\n                resource.getResourceType(),\n                resource.getResourceSuperType(),\n                workspaceName,\n                null,\n                executionPaths);\n        this.methodName = methodName;\n        this.requestSelectors = new String[0];\n        this.numRequestSelectors = 0;\n        this.isGet = false;\n        this.isHtml = false;\n\n        // create the hash code once\n        final String key = methodName + ':' + baseResourceType + ':' + extension + \"::\" +\n            (this.resourceType == null ? \"\" : this.resourceType)+ ':' + (this.resourceSuperType == null ? \"\" : this.resourceSuperType) +\n            ':' + (this.workspaceName == null ? \"\" : this.workspaceName);\n        this.hashCode = key.hashCode();\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"protected void getWeightedResources(final Set<Resource> resources,\n                                        Resource location) {\n\n        ResourceResolver resolver = location.getResourceResolver();\n        Resource current = location;\n        String parentName = ResourceUtil.getName(current);\n\n        int selIdx = 0;\n        String selector;\n        do {\n            selector = (selIdx < numRequestSelectors)\n                    ? requestSelectors[selIdx]\n                    : null;\n\n            Iterator<Resource> children = resolver.listChildren(current);\n            while (children.hasNext()) {\n                Resource child = children.next();\n\n                if ( !this.isPathAllowed(child.getPath()) ) {\n                    continue;\n                }\n                String scriptName = ResourceUtil.getName(child);\n                int lastDot = scriptName.lastIndexOf('.');\n                if (lastDot < 0) {\n                    // no extension in the name, this is not a script\n                    continue;\n                }\n\n                scriptName = scriptName.substring(0, lastDot);\n\n                if (isGet) {\n\n                    if (selector != null\n                        && scriptName.equals(selector + \".\" + extension)) {\n                        addWeightedResource(resources, child, selIdx + 1,\n                            WeightedResource.WEIGHT_EXTENSION);\n                        continue;\n                    }\n\n                    if (scriptName.equals(parentName + \".\" + extension)) {\n                        addWeightedResource(resources, child, selIdx,\n                            WeightedResource.WEIGHT_EXTENSION\n                                + WeightedResource.WEIGHT_PREFIX);\n                        continue;\n                    }\n\n                    if (scriptName.equals(extension)) {\n                        addWeightedResource(resources, child, selIdx,\n                            WeightedResource.WEIGHT_EXTENSION);\n                        continue;\n                    }\n\n                    if (isHtml) {\n                        if (selector != null && scriptName.equals(selector)) {\n                            addWeightedResource(resources, child, selIdx + 1,\n                                WeightedResource.WEIGHT_NONE);\n                            continue;\n                        }\n                        if (scriptName.equals(parentName)) {\n                            addWeightedResource(resources, child, selIdx,\n                                WeightedResource.WEIGHT_PREFIX);\n                            continue;\n                        }\n                    }\n                }\n\n                if (selector != null\n                    && scriptName.equals(selector + \".\" + methodName)) {\n                    addWeightedResource(resources, child, selIdx + 1,\n                        WeightedResource.WEIGHT_NONE);\n                    continue;\n                }\n\n                if (scriptName.equals(methodName)) {\n                    addWeightedResource(resources, child, selIdx,\n                        WeightedResource.WEIGHT_NONE);\n                    continue;\n                }\n            }\n\n            if (selector != null) {\n                current = resolver.getResource(current, selector);\n                parentName = selector;\n                selIdx++;\n            }\n        } while (selector != null && current != null);\n\n        // special treatment for servlets registered with neither a method\n        // name nor extensions and selectors\n        String path = location.getPath()\n            + ServletResourceProviderFactory.SERVLET_PATH_EXTENSION;\n        if ( this.isPathAllowed(path) ) {\n            location = location.getResourceResolver().getResource(path);\n            if (location != null) {\n                addWeightedResource(resources, location, 0,\n                    WeightedResource.WEIGHT_LAST_RESSORT);\n            }\n        }\n    }","id":24307,"modified_method":"protected void getWeightedResources(final Set<Resource> resources,\n                                        final Resource location) {\n\n        final ResourceResolver resolver = location.getResourceResolver();\n        Resource current = location;\n        String parentName = ResourceUtil.getName(current);\n\n        int selIdx = 0;\n        String selector;\n        do {\n            selector = (selIdx < numRequestSelectors)\n                    ? requestSelectors[selIdx]\n                    : null;\n\n            Iterator<Resource> children = resolver.listChildren(current);\n            while (children.hasNext()) {\n                Resource child = children.next();\n\n                if ( !this.isPathAllowed(child.getPath()) ) {\n                    continue;\n                }\n                String scriptName = ResourceUtil.getName(child);\n                int lastDot = scriptName.lastIndexOf('.');\n                if (lastDot < 0) {\n                    // no extension in the name, this is not a script\n                    continue;\n                }\n\n                scriptName = scriptName.substring(0, lastDot);\n\n                if (isGet) {\n\n                    if (selector != null\n                        && scriptName.equals(selector + \".\" + extension)) {\n                        addWeightedResource(resources, child, selIdx + 1,\n                            WeightedResource.WEIGHT_EXTENSION);\n                        continue;\n                    }\n\n                    if (scriptName.equals(parentName + \".\" + extension)) {\n                        addWeightedResource(resources, child, selIdx,\n                            WeightedResource.WEIGHT_EXTENSION\n                                + WeightedResource.WEIGHT_PREFIX);\n                        continue;\n                    }\n\n                    if (scriptName.equals(extension)) {\n                        addWeightedResource(resources, child, selIdx,\n                            WeightedResource.WEIGHT_EXTENSION);\n                        continue;\n                    }\n\n                    if (isHtml) {\n                        if (selector != null && scriptName.equals(selector)) {\n                            addWeightedResource(resources, child, selIdx + 1,\n                                WeightedResource.WEIGHT_NONE);\n                            continue;\n                        }\n                        if (scriptName.equals(parentName)) {\n                            addWeightedResource(resources, child, selIdx,\n                                WeightedResource.WEIGHT_PREFIX);\n                            continue;\n                        }\n                    }\n                }\n\n                if (selector != null\n                    && scriptName.equals(selector + \".\" + methodName)) {\n                    addWeightedResource(resources, child, selIdx + 1,\n                        WeightedResource.WEIGHT_NONE);\n                    continue;\n                }\n\n                if (scriptName.equals(methodName)) {\n                    addWeightedResource(resources, child, selIdx,\n                        WeightedResource.WEIGHT_NONE);\n                    continue;\n                }\n            }\n\n            if (selector != null) {\n                current = resolver.getResource(current, selector);\n                parentName = selector;\n                selIdx++;\n            }\n        } while (selector != null && current != null);\n\n        // special treatment for servlets registered with neither a method\n        // name nor extensions and selectors\n        String path = location.getPath()\n            + ServletResourceProviderFactory.SERVLET_PATH_EXTENSION;\n        if ( this.isPathAllowed(path) ) {\n            current = location.getResourceResolver().getResource(path);\n            if (current != null) {\n                addWeightedResource(resources, current, 0,\n                    WeightedResource.WEIGHT_LAST_RESSORT);\n            }\n        }\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"@Override\n    public boolean equals(Object obj) {\n        if ( !(obj instanceof ResourceCollector) ) {\n            return false;\n        }\n        if ( obj == this ) {\n            return true;\n        }\n        if ( super.equals(obj) ) {\n            final ResourceCollector o = (ResourceCollector)obj;\n            if ( isGet == o.isGet\n                 && isHtml == o.isHtml\n                 && numRequestSelectors == o.numRequestSelectors\n                 && stringEquals(methodName, o.methodName)\n                 && stringEquals(workspaceName, o.workspaceName)) {\n                // now compare selectors\n                for(int i=0;i<numRequestSelectors;i++) {\n                    if ( !stringEquals(requestSelectors[i], o.requestSelectors[i]) ) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }","id":24308,"modified_method":"@Override\n    public boolean equals(Object obj) {\n        if ( !(obj instanceof ResourceCollector) ) {\n            return false;\n        }\n        if ( obj == this ) {\n            return true;\n        }\n        if ( super.equals(obj) ) {\n            final ResourceCollector o = (ResourceCollector)obj;\n            if ( isGet == o.isGet\n                 && isHtml == o.isHtml\n                 && numRequestSelectors == o.numRequestSelectors\n                 && stringEquals(methodName, o.methodName)) {\n                // now compare selectors\n                for(int i=0;i<numRequestSelectors;i++) {\n                    if ( !stringEquals(requestSelectors[i], o.requestSelectors[i]) ) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.api.servlets.ServletResolver#resolveServlet(org.apache.sling.api.SlingHttpServletRequest)\n     */\n    public Servlet resolveServlet(final SlingHttpServletRequest request) {\n        final Resource resource = request.getResource();\n\n        // start tracking servlet resolution\n        final RequestProgressTracker tracker = request.getRequestProgressTracker();\n        final String timerName = \"resolveServlet(\" + resource + \")\";\n        tracker.startTimer(timerName);\n\n        final String type = resource.getResourceType();\n        if (log.isDebugEnabled()) {\n            log.debug(\"resolveServlet called for resource {}\", resource);\n        }\n\n        Servlet servlet = null;\n\n        if (this.useRequestWorkspace) {\n            final String wspName = getWorkspaceName(request);\n            // First, we use a resource resolver using the same workspace as the\n            // resource\n            WorkspaceResourceResolver scriptResolver = getScriptResolver(wspName);\n            servlet = resolveServlet(request, type, scriptResolver);\n\n            if (servlet == null && this.useDefaultWorkspace\n                    && !WorkspaceResourceResolver.isSameWorkspace(wspName, defaultScriptResolver.getWorkspaceName()) ) {\n                servlet = resolveServlet(request, type, defaultScriptResolver);\n            }\n\n        } else {\n            servlet = resolveServlet(request, type, defaultScriptResolver);\n        }\n\n        // last resort, use the core bundle default servlet\n        if (servlet == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No specific servlet found, trying default\");\n            }\n            servlet = getDefaultServlet();\n        }\n\n        // track servlet resolution termination\n        if (servlet == null) {\n            tracker.logTimer(timerName, \"Servlet resolution failed. See log for details\");\n        } else {\n            tracker.logTimer(timerName, \"Using servlet {0}\", RequestUtil.getServletName(servlet));\n        }\n\n        // log the servlet found\n        if (log.isDebugEnabled()) {\n            if (servlet != null) {\n                log.debug(\"Servlet {} found for resource={}\", RequestUtil.getServletName(servlet), resource);\n            } else {\n                log.debug(\"No servlet found for resource={}\", resource);\n            }\n        }\n\n        return servlet;\n    }","id":24309,"modified_method":"/**\n     * @see org.apache.sling.api.servlets.ServletResolver#resolveServlet(org.apache.sling.api.SlingHttpServletRequest)\n     */\n    public Servlet resolveServlet(final SlingHttpServletRequest request) {\n        final Resource resource = request.getResource();\n\n        // start tracking servlet resolution\n        final RequestProgressTracker tracker = request.getRequestProgressTracker();\n        final String timerName = \"resolveServlet(\" + resource + \")\";\n        tracker.startTimer(timerName);\n\n        final String type = resource.getResourceType();\n        if (log.isDebugEnabled()) {\n            log.debug(\"resolveServlet called for resource {}\", resource);\n        }\n\n        Servlet servlet = null;\n\n        if (this.useRequestWorkspace) {\n            final String wspName = getWorkspaceName(request);\n            // First, we use a resource resolver using the same workspace as the\n            // resource\n            servlet = resolveServlet(request, type, scriptResolver, wspName);\n\n            // now we try the default workspace\n            if (servlet == null && this.useDefaultWorkspace && wspName != null ) {\n                servlet = resolveServlet(request, type, scriptResolver, this.defaultWorkspaceName);\n            }\n\n        } else {\n            servlet = resolveServlet(request, type, scriptResolver, this.defaultWorkspaceName);\n        }\n\n        // last resort, use the core bundle default servlet\n        if (servlet == null) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"No specific servlet found, trying default\");\n            }\n            servlet = getDefaultServlet();\n        }\n\n        // track servlet resolution termination\n        if (servlet == null) {\n            tracker.logTimer(timerName, \"Servlet resolution failed. See log for details\");\n        } else {\n            tracker.logTimer(timerName, \"Using servlet {0}\", RequestUtil.getServletName(servlet));\n        }\n\n        // log the servlet found\n        if (log.isDebugEnabled()) {\n            if (servlet != null) {\n                log.debug(\"Servlet {} found for resource={}\", RequestUtil.getServletName(servlet), resource);\n            } else {\n                log.debug(\"No servlet found for resource={}\", resource);\n            }\n        }\n\n        return servlet;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Activate this component.\n     */\n    protected void activate(ComponentContext context) throws LoginException {\n        // from configuration if available\n        final Dictionary<?, ?> properties = context.getProperties();\n        Object servletRoot = properties.get(PROP_SERVLET_ROOT);\n        if (servletRoot == null) {\n            servletRoot = DEFAULT_SERVLET_ROOT;\n        }\n\n        final Collection<ServiceReference> refs;\n        synchronized (this) {\n\n            refs = pendingServlets;\n            pendingServlets = new ArrayList<ServiceReference>();\n\n            // register servlets immediately from now on\n            this.context = context;\n\n            // workspace handling and resource resolver creation\n            this.useDefaultWorkspace = OsgiUtil.toBoolean(properties.get(PROP_USE_DEFAULT_WORKSPACE), DEFAULT_USE_DEFAULT_WORKSPACE);\n            this.useRequestWorkspace = OsgiUtil.toBoolean(properties.get(PROP_USE_REQUEST_WORKSPACE), DEFAULT_USE_REQUEST_WORKSPACE);\n\n            this.scriptResolvers = new ConcurrentHashMap<String, WorkspaceResourceResolver>();\n\n            String defaultWorkspaceProp = (String) properties.get(PROP_DEFAULT_SCRIPT_WORKSPACE);\n            if ( defaultWorkspaceProp != null && defaultWorkspaceProp.trim().length() == 0 ) {\n                defaultWorkspaceProp = null;\n            }\n\n            this.defaultScriptResolver = new WorkspaceResourceResolver(\n                    resourceResolverFactory.getAdministrativeResourceResolver(this.createAuthenticationInfo(defaultWorkspaceProp)));\n\n            servletResourceProviderFactory = new ServletResourceProviderFactory(servletRoot,\n                    this.defaultScriptResolver.getSearchPath());\n        }\n        createAllServlets(refs);\n\n        // execution paths\n        this.executionPaths = OsgiUtil.toStringArray(properties.get(PROP_PATHS), DEFAULT_PATHS);\n        if ( this.executionPaths != null ) {\n            // if we find a string combination that basically allows all paths,\n            // we simply set the array to null\n            if ( this.executionPaths.length == 0 ) {\n                this.executionPaths = null;\n            } else {\n                boolean hasRoot = false;\n                for(int i = 0 ; i < this.executionPaths.length; i++) {\n                    final String path = this.executionPaths[i];\n                    if ( path == null || path.length() == 0 || path.equals(\"/\") ) {\n                        hasRoot = true;\n                    }\n                }\n                if ( hasRoot ) {\n                    this.executionPaths = null;\n                }\n            }\n        }\n\n        // create cache - if a cache size is configured\n        final int cacheSize = OsgiUtil.toInteger(properties.get(PROP_CACHE_SIZE), DEFAULT_CACHE_SIZE);\n        if (cacheSize > 5) {\n            this.cache = new ConcurrentHashMap<AbstractResourceCollector, Servlet>(cacheSize);\n        }\n\n        // and finally register as event listener\n        this.eventHandlerReg = context.getBundleContext().registerService(EventHandler.class.getName(), this,\n                properties);\n    }","id":24310,"modified_method":"/**\n     * Activate this component.\n     */\n    protected void activate(ComponentContext context) throws LoginException {\n        // from configuration if available\n        final Dictionary<?, ?> properties = context.getProperties();\n        Object servletRoot = properties.get(PROP_SERVLET_ROOT);\n        if (servletRoot == null) {\n            servletRoot = DEFAULT_SERVLET_ROOT;\n        }\n\n        final Collection<ServiceReference> refs;\n        synchronized (this) {\n\n            refs = pendingServlets;\n            pendingServlets = new ArrayList<ServiceReference>();\n\n            // register servlets immediately from now on\n            this.context = context;\n\n            // workspace handling and resource resolver creation\n            this.useDefaultWorkspace = OsgiUtil.toBoolean(properties.get(PROP_USE_DEFAULT_WORKSPACE), DEFAULT_USE_DEFAULT_WORKSPACE);\n            this.useRequestWorkspace = OsgiUtil.toBoolean(properties.get(PROP_USE_REQUEST_WORKSPACE), DEFAULT_USE_REQUEST_WORKSPACE);\n\n            String defaultWorkspaceProp = (String) properties.get(PROP_DEFAULT_SCRIPT_WORKSPACE);\n            if ( defaultWorkspaceProp != null && defaultWorkspaceProp.trim().length() == 0 ) {\n                defaultWorkspaceProp = null;\n            }\n            this.defaultWorkspaceName = defaultWorkspaceProp;\n\n            this.scriptResolver =\n                    resourceResolverFactory.getAdministrativeResourceResolver(this.createAuthenticationInfo());\n\n            servletResourceProviderFactory = new ServletResourceProviderFactory(servletRoot,\n                    this.scriptResolver.getSearchPath());\n        }\n        createAllServlets(refs);\n\n        // execution paths\n        this.executionPaths = OsgiUtil.toStringArray(properties.get(PROP_PATHS), DEFAULT_PATHS);\n        if ( this.executionPaths != null ) {\n            // if we find a string combination that basically allows all paths,\n            // we simply set the array to null\n            if ( this.executionPaths.length == 0 ) {\n                this.executionPaths = null;\n            } else {\n                boolean hasRoot = false;\n                for(int i = 0 ; i < this.executionPaths.length; i++) {\n                    final String path = this.executionPaths[i];\n                    if ( path == null || path.length() == 0 || path.equals(\"/\") ) {\n                        hasRoot = true;\n                    }\n                }\n                if ( hasRoot ) {\n                    this.executionPaths = null;\n                }\n            }\n        }\n\n        // create cache - if a cache size is configured\n        final int cacheSize = OsgiUtil.toInteger(properties.get(PROP_CACHE_SIZE), DEFAULT_CACHE_SIZE);\n        if (cacheSize > 5) {\n            this.cache = new ConcurrentHashMap<AbstractResourceCollector, Servlet>(cacheSize);\n        }\n\n        // and finally register as event listener\n        this.eventHandlerReg = context.getBundleContext().registerService(EventHandler.class.getName(), this,\n                properties);\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"public void handleError(Throwable throwable, SlingHttpServletRequest request, SlingHttpServletResponse response)\n    throws IOException {\n        // do not handle, if already handling ....\n        if (request.getAttribute(SlingConstants.ERROR_REQUEST_URI) != null) {\n            log.error(\"handleError: Recursive invocation. Not further handling Throwable:\", throwable);\n            return;\n        }\n\n        // start tracker\n        RequestProgressTracker tracker = request.getRequestProgressTracker();\n        String timerName = \"handleError:throwable=\" + throwable.getClass().getName();\n        tracker.startTimer(timerName);\n\n        try {\n            final WorkspaceResourceResolver scriptResolver = getScriptResolver(getWorkspaceName(request));\n\n            // find the error handler component\n            Servlet servlet = null;\n            Resource resource = getErrorResource(request);\n\n            Class<?> tClass = throwable.getClass();\n            while (servlet == null && tClass != Object.class) {\n                // find a servlet for the simple class name as the method name\n                ResourceCollector locationUtil = new ResourceCollector(tClass.getSimpleName(),\n                        ServletResolverConstants.ERROR_HANDLER_PATH, resource, scriptResolver.getWorkspaceName(),\n                        this.executionPaths);\n                servlet = getServlet(locationUtil, request, scriptResolver);\n\n                // go to the base class\n                tClass = tClass.getSuperclass();\n            }\n\n            if (servlet == null) {\n                servlet = getDefaultErrorServlet(request, scriptResolver,\n                    resource);\n            }\n\n            // set the message properties\n            request.setAttribute(SlingConstants.ERROR_EXCEPTION, throwable);\n            request.setAttribute(SlingConstants.ERROR_EXCEPTION_TYPE, throwable.getClass());\n            request.setAttribute(SlingConstants.ERROR_MESSAGE, throwable.getMessage());\n\n            // log a track entry after resolution before calling the handler\n            tracker.logTimer(timerName, \"Using handler {0}\", RequestUtil.getServletName(servlet));\n\n            handleError(servlet, request, response);\n        } finally {\n\n            tracker.logTimer(timerName, \"Error handler finished\");\n\n        }\n    }","id":24311,"modified_method":"public void handleError(Throwable throwable, SlingHttpServletRequest request, SlingHttpServletResponse response)\n    throws IOException {\n        // do not handle, if already handling ....\n        if (request.getAttribute(SlingConstants.ERROR_REQUEST_URI) != null) {\n            log.error(\"handleError: Recursive invocation. Not further handling Throwable:\", throwable);\n            return;\n        }\n\n        // start tracker\n        RequestProgressTracker tracker = request.getRequestProgressTracker();\n        String timerName = \"handleError:throwable=\" + throwable.getClass().getName();\n        tracker.startTimer(timerName);\n\n        try {\n            final String wspName = getWorkspaceName(request);\n\n            // find the error handler component\n            Servlet servlet = null;\n            Resource resource = getErrorResource(request);\n\n            Class<?> tClass = throwable.getClass();\n            while (servlet == null && tClass != Object.class) {\n                // find a servlet for the simple class name as the method name\n                ResourceCollector locationUtil = new ResourceCollector(tClass.getSimpleName(),\n                        ServletResolverConstants.ERROR_HANDLER_PATH, resource, wspName,\n                        this.executionPaths);\n                servlet = getServlet(locationUtil, request, scriptResolver);\n\n                // go to the base class\n                tClass = tClass.getSuperclass();\n            }\n\n            if (servlet == null) {\n                servlet = getDefaultErrorServlet(request, scriptResolver,\n                    resource, wspName);\n            }\n\n            // set the message properties\n            request.setAttribute(SlingConstants.ERROR_EXCEPTION, throwable);\n            request.setAttribute(SlingConstants.ERROR_EXCEPTION_TYPE, throwable.getClass());\n            request.setAttribute(SlingConstants.ERROR_MESSAGE, throwable.getMessage());\n\n            // log a track entry after resolution before calling the handler\n            tracker.logTimer(timerName, \"Using handler {0}\", RequestUtil.getServletName(servlet));\n\n            handleError(servlet, request, response);\n        } finally {\n\n            tracker.logTimer(timerName, \"Error handler finished\");\n\n        }\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.api.servlets.ServletResolver#resolveServlet(org.apache.sling.api.resource.ResourceResolver, java.lang.String)\n     */\n    public Servlet resolveServlet(final ResourceResolver resolver, final String scriptName) {\n        if ( resolver == null ) {\n            throw new IllegalArgumentException(\"Resource resolver must not be null\");\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"resolveServlet called for for script name {}\", scriptName);\n        }\n\n        final Servlet servlet = resolveServlet(defaultScriptResolver, null, scriptName);\n\n        // log the servlet found\n        if (log.isDebugEnabled()) {\n            if (servlet != null) {\n                log.debug(\"Servlet {} found for script name {}\", RequestUtil.getServletName(servlet), scriptName);\n            } else {\n                log.debug(\"No servlet found for script name {}\", scriptName);\n            }\n        }\n\n        return servlet;\n    }","id":24312,"modified_method":"/**\n     * @see org.apache.sling.api.servlets.ServletResolver#resolveServlet(org.apache.sling.api.resource.ResourceResolver, java.lang.String)\n     */\n    public Servlet resolveServlet(final ResourceResolver resolver, final String scriptName) {\n        if ( resolver == null ) {\n            throw new IllegalArgumentException(\"Resource resolver must not be null\");\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"resolveServlet called for for script name {}\", scriptName);\n        }\n\n        final Servlet servlet = resolveServlet(scriptResolver, null, scriptName);\n\n        // log the servlet found\n        if (log.isDebugEnabled()) {\n            if (servlet != null) {\n                log.debug(\"Servlet {} found for script name {}\", RequestUtil.getServletName(servlet), scriptName);\n            } else {\n                log.debug(\"No servlet found for script name {}\", scriptName);\n            }\n        }\n\n        return servlet;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Deactivate this component.\n     */\n    protected void deactivate(ComponentContext context) {\n        // unregister event handler\n        if (this.eventHandlerReg != null) {\n            this.eventHandlerReg.unregister();\n            this.eventHandlerReg = null;\n        }\n\n        // Copy the list of servlets first, to minimize the need for\n        // synchronization\n        final Collection<ServiceReference> refs;\n        synchronized (this) {\n            refs = new ArrayList<ServiceReference>(servletsByReference.keySet());\n        }\n        // destroy all servlets\n        destroyAllServlets(refs);\n\n        // destroy the fallback error handler servlet\n        if (fallbackErrorServlet != null) {\n            try {\n                fallbackErrorServlet.destroy();\n            } catch (Throwable t) {\n                // ignore\n            } finally {\n                fallbackErrorServlet = null;\n            }\n        }\n\n        // close sessions\n        if (this.scriptResolvers != null ) {\n            for (final ResourceResolver resolver : this.scriptResolvers.values()) {\n                resolver.close();\n            }\n            this.scriptResolvers = null;\n        }\n\n        if (this.defaultScriptResolver != null) {\n            this.defaultScriptResolver.close();\n            this.defaultScriptResolver = null;\n        }\n\n        this.context = null;\n        this.cache = null;\n        this.servletResourceProviderFactory = null;\n    }","id":24313,"modified_method":"/**\n     * Deactivate this component.\n     */\n    protected void deactivate(ComponentContext context) {\n        // unregister event handler\n        if (this.eventHandlerReg != null) {\n            this.eventHandlerReg.unregister();\n            this.eventHandlerReg = null;\n        }\n\n        // Copy the list of servlets first, to minimize the need for\n        // synchronization\n        final Collection<ServiceReference> refs;\n        synchronized (this) {\n            refs = new ArrayList<ServiceReference>(servletsByReference.keySet());\n        }\n        // destroy all servlets\n        destroyAllServlets(refs);\n\n        // destroy the fallback error handler servlet\n        if (fallbackErrorServlet != null) {\n            try {\n                fallbackErrorServlet.destroy();\n            } catch (Throwable t) {\n                // ignore\n            } finally {\n                fallbackErrorServlet = null;\n            }\n        }\n\n        if (this.scriptResolver != null) {\n            this.scriptResolver.close();\n            this.scriptResolver = null;\n        }\n\n        this.context = null;\n        this.cache = null;\n        this.servletResourceProviderFactory = null;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.osgi.service.event.EventHandler#handleEvent(org.osgi.service.event.Event)\n     */\n    public void handleEvent(Event event) {\n        if (this.cache != null) {\n            boolean flushCache = false;\n\n            // we may receive different events\n            final String topic = event.getTopic();\n            if (topic.startsWith(\"javax/script/ScriptEngineFactory/\")) {\n                // script engine factory added or removed: we always flush\n                flushCache = true;\n            } else if (topic.startsWith(\"org/apache/sling/api/adapter/AdapterFactory/\")) {\n                // adapter factory added or removed: we always flush\n                // as adapting might be transitive\n                flushCache = true;\n            } else {\n                // this is a resource event\n\n                // if the path of the event is a sub path of a search path\n                // we flush the whole cache\n                String path = (String) event.getProperty(SlingConstants.PROPERTY_PATH);\n                if (path.contains(\":\")) {\n                    path = path.substring(path.indexOf(\":\") + 1);\n                }\n                final String[] searchPaths = this.defaultScriptResolver.getSearchPath();\n                int index = 0;\n                while (!flushCache && index < searchPaths.length) {\n                    if (path.startsWith(searchPaths[index])) {\n                        flushCache = true;\n                    }\n                    index++;\n                }\n            }\n            if (flushCache) {\n                this.cache.clear();\n            }\n        }\n    }","id":24314,"modified_method":"/**\n     * @see org.osgi.service.event.EventHandler#handleEvent(org.osgi.service.event.Event)\n     */\n    public void handleEvent(Event event) {\n        if (this.cache != null) {\n            boolean flushCache = false;\n\n            // we may receive different events\n            final String topic = event.getTopic();\n            if (topic.startsWith(\"javax/script/ScriptEngineFactory/\")) {\n                // script engine factory added or removed: we always flush\n                flushCache = true;\n            } else if (topic.startsWith(\"org/apache/sling/api/adapter/AdapterFactory/\")) {\n                // adapter factory added or removed: we always flush\n                // as adapting might be transitive\n                flushCache = true;\n            } else {\n                // this is a resource event\n\n                // if the path of the event is a sub path of a search path\n                // we flush the whole cache\n                String path = (String) event.getProperty(SlingConstants.PROPERTY_PATH);\n                if (path.contains(\":\")) {\n                    path = path.substring(path.indexOf(\":\") + 1);\n                }\n                final String[] searchPaths = this.scriptResolver.getSearchPath();\n                int index = 0;\n                while (!flushCache && index < searchPaths.length) {\n                    if (path.startsWith(searchPaths[index])) {\n                        flushCache = true;\n                    }\n                    index++;\n                }\n            }\n            if (flushCache) {\n                this.cache.clear();\n            }\n        }\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns a servlet suitable for handling a request. The\n     * <code>locationUtil<\/code> is used find any servlets or scripts usable for\n     * the request. Each servlet returned is in turn asked whether it is\n     * actually willing to handle the request in case the servlet is an\n     * <code>OptingServlet<\/code>. The first servlet willing to handle the\n     * request is used.\n     *\n     * @param locationUtil The helper used to find appropriate servlets ordered\n     *            by matching priority.\n     * @param request The request used to give to any <code>OptingServlet<\/code>\n     *            for them to decide on whether they are willing to handle the\n     *            request\n     * @param resource The <code>Resource<\/code> for which to find a script.\n     *            This need not be the same as\n     *            <code>request.getResource()<\/code> in case of error handling\n     *            where the resource may not have been assigned to the request\n     *            yet.\n     * @return a servlet for handling the request or <code>null<\/code> if no\n     *         such servlet willing to handle the request could be found.\n     */\n    private Servlet getServlet(final AbstractResourceCollector locationUtil,\n            final SlingHttpServletRequest request,\n            final ResourceResolver scriptResolver) {\n        final Servlet scriptServlet = (this.cache != null ? this.cache.get(locationUtil) : null);\n        if (scriptServlet != null) {\n            log.debug(\"Using cached servlet {}\", scriptServlet.getClass().getName());\n            return scriptServlet;\n        }\n\n        final Collection<Resource> candidates = locationUtil.getServlets(scriptResolver);\n\n        if (log.isDebugEnabled()) {\n            if (candidates.isEmpty()) {\n                log.debug(\"No servlet candidates found\");\n            } else {\n                log.debug(\"Ordered list of servlet candidates follows\");\n                for (Resource candidateResource : candidates) {\n                    log.debug(\"Servlet candidate: {}\", candidateResource.getPath());\n                }\n            }\n        }\n\n        boolean hasOptingServlet = false;\n        for (Resource candidateResource : candidates) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Checking if candidate resource {} adapts to servlet and accepts request\", candidateResource\n                        .getPath());\n            }\n            Servlet candidate = candidateResource.adaptTo(Servlet.class);\n            if (candidate != null) {\n                final boolean isOptingServlet = candidate instanceof OptingServlet;\n                boolean servletAcceptsRequest = !isOptingServlet || (request != null && ((OptingServlet) candidate).accepts(request));\n                if (servletAcceptsRequest) {\n                    if (!hasOptingServlet && !isOptingServlet && this.cache != null) {\n                        this.cache.put(locationUtil, candidate);\n                    }\n                    log.debug(\"Using servlet provided by candidate resource {}\", candidateResource.getPath());\n                    return candidate;\n                }\n                if (isOptingServlet) {\n                    hasOptingServlet = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Candidate {} does not accept request, ignored\", candidateResource.getPath());\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Candidate {} does not adapt to a servlet, ignored\", candidateResource.getPath());\n                }\n            }\n        }\n\n        // exhausted all candidates, we don't have a servlet\n        return null;\n    }","id":24315,"modified_method":"/**\n     * Returns a servlet suitable for handling a request. The\n     * <code>locationUtil<\/code> is used find any servlets or scripts usable for\n     * the request. Each servlet returned is in turn asked whether it is\n     * actually willing to handle the request in case the servlet is an\n     * <code>OptingServlet<\/code>. The first servlet willing to handle the\n     * request is used.\n     *\n     * @param locationUtil The helper used to find appropriate servlets ordered\n     *            by matching priority.\n     * @param request The request used to give to any <code>OptingServlet<\/code>\n     *            for them to decide on whether they are willing to handle the\n     *            request\n     * @param resource The <code>Resource<\/code> for which to find a script.\n     *            This need not be the same as\n     *            <code>request.getResource()<\/code> in case of error handling\n     *            where the resource may not have been assigned to the request\n     *            yet.\n     * @return a servlet for handling the request or <code>null<\/code> if no\n     *         such servlet willing to handle the request could be found.\n     */\n    private Servlet getServlet(final AbstractResourceCollector locationUtil,\n            final SlingHttpServletRequest request,\n            final ResourceResolver scriptResolver) {\n        final Servlet scriptServlet = (this.cache != null ? this.cache.get(locationUtil) : null);\n        if (scriptServlet != null) {\n            if ( log.isDebugEnabled() ) {\n                log.debug(\"Using cached servlet {}\", RequestUtil.getServletName(scriptServlet));\n            }\n            return scriptServlet;\n        }\n\n        final Collection<Resource> candidates = locationUtil.getServlets(scriptResolver);\n\n        if (log.isDebugEnabled()) {\n            if (candidates.isEmpty()) {\n                log.debug(\"No servlet candidates found\");\n            } else {\n                log.debug(\"Ordered list of servlet candidates follows\");\n                for (Resource candidateResource : candidates) {\n                    log.debug(\"Servlet candidate: {}\", candidateResource.getPath());\n                }\n            }\n        }\n\n        boolean hasOptingServlet = false;\n        for (Resource candidateResource : candidates) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Checking if candidate resource {} adapts to servlet and accepts request\", candidateResource\n                        .getPath());\n            }\n            Servlet candidate = candidateResource.adaptTo(Servlet.class);\n            if (candidate != null) {\n                final boolean isOptingServlet = candidate instanceof OptingServlet;\n                boolean servletAcceptsRequest = !isOptingServlet || (request != null && ((OptingServlet) candidate).accepts(request));\n                if (servletAcceptsRequest) {\n                    if (!hasOptingServlet && !isOptingServlet && this.cache != null) {\n                        this.cache.put(locationUtil, candidate);\n                    }\n                    log.debug(\"Using servlet provided by candidate resource {}\", candidateResource.getPath());\n                    return candidate;\n                }\n                if (isOptingServlet) {\n                    hasOptingServlet = true;\n                }\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Candidate {} does not accept request, ignored\", candidateResource.getPath());\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Candidate {} does not adapt to a servlet, ignored\", candidateResource.getPath());\n                }\n            }\n        }\n\n        // exhausted all candidates, we don't have a servlet\n        return null;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.engine.servlets.ErrorHandler#handleError(int,\n     *      String, SlingHttpServletRequest, SlingHttpServletResponse)\n     */\n    public void handleError(int status, String message, SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws IOException {\n\n        // do not handle, if already handling ....\n        if (request.getAttribute(SlingConstants.ERROR_REQUEST_URI) != null) {\n            log.error(\"handleError: Recursive invocation. Not further handling status \" + status + \"(\" + message + \")\");\n            return;\n        }\n\n        // start tracker\n        RequestProgressTracker tracker = request.getRequestProgressTracker();\n        String timerName = \"handleError:status=\" + status;\n        tracker.startTimer(timerName);\n\n        try {\n            final WorkspaceResourceResolver scriptResolver = getScriptResolver(getWorkspaceName(request));\n\n            // find the error handler component\n            Resource resource = getErrorResource(request);\n\n            // find a servlet for the status as the method name\n            ResourceCollector locationUtil = new ResourceCollector(String.valueOf(status),\n                    ServletResolverConstants.ERROR_HANDLER_PATH, resource, scriptResolver.getWorkspaceName(),\n                    this.executionPaths);\n            Servlet servlet = getServlet(locationUtil, request, scriptResolver);\n\n            // fall back to default servlet if none\n            if (servlet == null) {\n                servlet = getDefaultErrorServlet(request, scriptResolver,\n                    resource);\n            }\n\n            // set the message properties\n            request.setAttribute(ERROR_STATUS, new Integer(status));\n            request.setAttribute(ERROR_MESSAGE, message);\n\n            // the servlet name for a sendError handling is still stored\n            // as the request attribute\n            Object servletName = request.getAttribute(SLING_CURRENT_SERVLET_NAME);\n            if (servletName instanceof String) {\n                request.setAttribute(ERROR_SERVLET_NAME, servletName);\n            }\n\n            // log a track entry after resolution before calling the handler\n            tracker.logTimer(timerName, \"Using handler {0}\", RequestUtil.getServletName(servlet));\n\n            handleError(servlet, request, response);\n\n        } finally {\n\n            tracker.logTimer(timerName, \"Error handler finished\");\n\n        }\n    }","id":24316,"modified_method":"/**\n     * @see org.apache.sling.engine.servlets.ErrorHandler#handleError(int,\n     *      String, SlingHttpServletRequest, SlingHttpServletResponse)\n     */\n    public void handleError(int status, String message, SlingHttpServletRequest request,\n            SlingHttpServletResponse response) throws IOException {\n\n        // do not handle, if already handling ....\n        if (request.getAttribute(SlingConstants.ERROR_REQUEST_URI) != null) {\n            log.error(\"handleError: Recursive invocation. Not further handling status \" + status + \"(\" + message + \")\");\n            return;\n        }\n\n        // start tracker\n        RequestProgressTracker tracker = request.getRequestProgressTracker();\n        String timerName = \"handleError:status=\" + status;\n        tracker.startTimer(timerName);\n\n        try {\n            final String wspName = getWorkspaceName(request);\n\n            // find the error handler component\n            Resource resource = getErrorResource(request);\n\n            // find a servlet for the status as the method name\n            ResourceCollector locationUtil = new ResourceCollector(String.valueOf(status),\n                    ServletResolverConstants.ERROR_HANDLER_PATH, resource, wspName,\n                    this.executionPaths);\n            Servlet servlet = getServlet(locationUtil, request, scriptResolver);\n\n            // fall back to default servlet if none\n            if (servlet == null) {\n                servlet = getDefaultErrorServlet(request, scriptResolver,\n                    resource, wspName);\n            }\n\n            // set the message properties\n            request.setAttribute(ERROR_STATUS, new Integer(status));\n            request.setAttribute(ERROR_MESSAGE, message);\n\n            // the servlet name for a sendError handling is still stored\n            // as the request attribute\n            Object servletName = request.getAttribute(SLING_CURRENT_SERVLET_NAME);\n            if (servletName instanceof String) {\n                request.setAttribute(ERROR_SERVLET_NAME, servletName);\n            }\n\n            // log a track entry after resolution before calling the handler\n            tracker.logTimer(timerName, \"Using handler {0}\", RequestUtil.getServletName(servlet));\n\n            handleError(servlet, request, response);\n\n        } finally {\n\n            tracker.logTimer(timerName, \"Error handler finished\");\n\n        }\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Resolve an appropriate servlet for a given request and resource type\n     * using the provided ResourceResolver.\n     */\n    private Servlet resolveServlet(final SlingHttpServletRequest request, final String type,\n            final WorkspaceResourceResolver resolver) {\n        Servlet servlet = null;\n\n        // first check whether the type of a resource is the absolute\n        // path of a servlet (or script)\n        if (type.charAt(0) == '/') {\n            if ( this.isPathAllowed(type) ) {\n                final Resource res = resolver.getResource(type);\n                if (res != null) {\n                    servlet = res.adaptTo(Servlet.class);\n                }\n                if (servlet != null && log.isDebugEnabled()) {\n                    log.debug(\"Servlet {} found using absolute resource type {}\", RequestUtil.getServletName(servlet),\n                                    type);\n                }\n            }\n        }\n        if ( servlet == null ) {\n            // the resource type is not absolute, so lets go for the deep search\n            final ResourceCollector locationUtil = ResourceCollector.create(request, resolver.getWorkspaceName(), this.executionPaths);\n            servlet = getServlet(locationUtil, request, resolver);\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"getServlet returns servlet {}\", RequestUtil.getServletName(servlet));\n            }\n        }\n        return servlet;\n    }","id":24317,"modified_method":"/**\n     * Resolve an appropriate servlet for a given request and resource type\n     * using the provided ResourceResolver and workspace\n     */\n    private Servlet resolveServlet(final SlingHttpServletRequest request,\n            final String type,\n            final ResourceResolver resolver,\n            final String workspaceName) {\n        Servlet servlet = null;\n\n        // first check whether the type of a resource is the absolute\n        // path of a servlet (or script)\n        if (type.charAt(0) == '/') {\n            if ( this.isPathAllowed(type) ) {\n                String path = type;\n                if ( workspaceName != null ) {\n                    path = workspaceName + ':' + type;\n                }\n                final Resource res = resolver.getResource(path);\n                if (res != null) {\n                    servlet = res.adaptTo(Servlet.class);\n                }\n                if (servlet != null && log.isDebugEnabled()) {\n                    log.debug(\"Servlet {} found using absolute resource type {}\", RequestUtil.getServletName(servlet),\n                                    type);\n                }\n            }\n        }\n        if ( servlet == null ) {\n            // the resource type is not absolute, so lets go for the deep search\n            final ResourceCollector locationUtil = ResourceCollector.create(request, workspaceName, this.executionPaths);\n            servlet = getServlet(locationUtil, request, resolver);\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"getServlet returns servlet {}\", RequestUtil.getServletName(servlet));\n            }\n        }\n        return servlet;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * @see org.apache.sling.api.servlets.ServletResolver#resolveServlet(org.apache.sling.api.resource.Resource, java.lang.String)\n     */\n    public Servlet resolveServlet(final Resource resource, final String scriptName) {\n        if ( resource == null ) {\n            throw new IllegalArgumentException(\"Resource must not be null\");\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"resolveServlet called for resource {} with script name {}\", resource, scriptName);\n        }\n\n        final Servlet servlet = resolveServlet(defaultScriptResolver, resource, scriptName);\n\n        // log the servlet found\n        if (log.isDebugEnabled()) {\n            if (servlet != null) {\n                log.debug(\"Servlet {} found for resource {} and script name {}\", new Object[] {RequestUtil.getServletName(servlet), resource, scriptName});\n            } else {\n                log.debug(\"No servlet found for resource {} and script name {}\", resource, scriptName);\n            }\n        }\n\n        return servlet;\n    }","id":24318,"modified_method":"/**\n     * @see org.apache.sling.api.servlets.ServletResolver#resolveServlet(org.apache.sling.api.resource.Resource, java.lang.String)\n     */\n    public Servlet resolveServlet(final Resource resource, final String scriptName) {\n        if ( resource == null ) {\n            throw new IllegalArgumentException(\"Resource must not be null\");\n        }\n        if (log.isDebugEnabled()) {\n            log.debug(\"resolveServlet called for resource {} with script name {}\", resource, scriptName);\n        }\n\n        final Servlet servlet = resolveServlet(scriptResolver, resource, scriptName);\n\n        // log the servlet found\n        if (log.isDebugEnabled()) {\n            if (servlet != null) {\n                log.debug(\"Servlet {} found for resource {} and script name {}\", new Object[] {RequestUtil.getServletName(servlet), resource, scriptName});\n            } else {\n                log.debug(\"No servlet found for resource {} and script name {}\", resource, scriptName);\n            }\n        }\n\n        return servlet;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Package scoped to help with testing.\n     */\n    String getWorkspaceName(SlingHttpServletRequest request) {\n        return WorkspaceResourceResolver.getWorkspaceName(request.getResourceResolver());\n    }","id":24319,"modified_method":"/**\n     * Package scoped to help with testing.\n     */\n    String getWorkspaceName(SlingHttpServletRequest request) {\n        if ( this.useRequestWorkspace ) {\n            final String path = request.getResource().getPath();\n            final int pos = path.indexOf(\":/\");\n            if ( pos == -1 ) {\n                return null; // default workspace\n            }\n            return path.substring(0, pos);\n        }\n        return null;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns the default error handler servlet, which is called in case there\n     * is no other - better matching - servlet registered to handle an error or\n     * exception.\n     * <p>\n     * The default error handler servlet is registered for the resource type\n     * \"sling/servlet/errorhandler\" and method \"default\". This may be\n     * overwritten by applications globally or according to the resource type\n     * hierarchy of the resource.\n     * <p>\n     * If no default error handler servlet can be found an adhoc error handler\n     * is used as a final fallback.\n     */\n    private Servlet getDefaultErrorServlet(\n            final SlingHttpServletRequest request,\n            final WorkspaceResourceResolver scriptResolver,\n            final Resource resource) {\n\n        // find a default error handler according to the resource type\n        // tree of the given resource\n        final ResourceCollector locationUtil = new ResourceCollector(\n            ServletResolverConstants.DEFAULT_ERROR_HANDLER_NAME,\n            ServletResolverConstants.ERROR_HANDLER_PATH, resource,\n            scriptResolver.getWorkspaceName(),\n            this.executionPaths);\n        final Servlet servlet = getServlet(locationUtil, request,\n            scriptResolver);\n        if (servlet != null) {\n            return servlet;\n        }\n\n        // if no registered default error handler could be found use\n        // the DefaultErrorHandlerServlet as an ad-hoc fallback\n        if (fallbackErrorServlet == null) {\n            // fall back to an adhoc instance of the DefaultErrorHandlerServlet\n            // if the actual service is not registered (yet ?)\n            try {\n                final Servlet defaultServlet = new DefaultErrorHandlerServlet();\n                defaultServlet.init(new SlingServletConfig(servletContext,\n                    null, \"Sling (Ad Hoc) Default Error Handler Servlet\"));\n                fallbackErrorServlet = defaultServlet;\n            } catch (ServletException se) {\n                log.error(\"Failed to initialize error servlet\", se);\n            }\n        }\n        return fallbackErrorServlet;\n    }","id":24320,"modified_method":"/**\n     * Returns the default error handler servlet, which is called in case there\n     * is no other - better matching - servlet registered to handle an error or\n     * exception.\n     * <p>\n     * The default error handler servlet is registered for the resource type\n     * \"sling/servlet/errorhandler\" and method \"default\". This may be\n     * overwritten by applications globally or according to the resource type\n     * hierarchy of the resource.\n     * <p>\n     * If no default error handler servlet can be found an adhoc error handler\n     * is used as a final fallback.\n     */\n    private Servlet getDefaultErrorServlet(\n            final SlingHttpServletRequest request,\n            final ResourceResolver scriptResolver,\n            final Resource resource,\n            final String workspaceName) {\n\n        // find a default error handler according to the resource type\n        // tree of the given resource\n        final ResourceCollector locationUtil = new ResourceCollector(\n            ServletResolverConstants.DEFAULT_ERROR_HANDLER_NAME,\n            ServletResolverConstants.ERROR_HANDLER_PATH, resource,\n            workspaceName,\n            this.executionPaths);\n        final Servlet servlet = getServlet(locationUtil, request,\n            scriptResolver);\n        if (servlet != null) {\n            return servlet;\n        }\n\n        // if no registered default error handler could be found use\n        // the DefaultErrorHandlerServlet as an ad-hoc fallback\n        if (fallbackErrorServlet == null) {\n            // fall back to an adhoc instance of the DefaultErrorHandlerServlet\n            // if the actual service is not registered (yet ?)\n            try {\n                final Servlet defaultServlet = new DefaultErrorHandlerServlet();\n                defaultServlet.init(new SlingServletConfig(servletContext,\n                    null, \"Sling (Ad Hoc) Default Error Handler Servlet\"));\n                fallbackErrorServlet = defaultServlet;\n            } catch (ServletException se) {\n                log.error(\"Failed to initialize error servlet\", se);\n            }\n        }\n        return fallbackErrorServlet;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"private Map<String, Object> createAuthenticationInfo(String wspName) {\n        final Map<String, Object> authInfo = new HashMap<String, Object>();\n        // if a script user is configured we use this user to read the scripts\n        final String scriptUser = OsgiUtil.toString(context.getProperties().get(PROP_SCRIPT_USER), null);\n        if (scriptUser != null && scriptUser.length() > 0) {\n            authInfo.put(ResourceResolverFactory.SUDO_USER_ID, scriptUser);\n        }\n        if ( wspName != null ) {\n            authInfo.put(\"user.jcr.workspace\", wspName);\n        }\n        return authInfo;\n    }","id":24321,"modified_method":"private Map<String, Object> createAuthenticationInfo() {\n        final Map<String, Object> authInfo = new HashMap<String, Object>();\n        // if a script user is configured we use this user to read the scripts\n        final String scriptUser = OsgiUtil.toString(context.getProperties().get(PROP_SCRIPT_USER), null);\n        if (scriptUser != null && scriptUser.length() > 0) {\n            authInfo.put(ResourceResolverFactory.SUDO_USER_ID, scriptUser);\n        }\n        return authInfo;\n    }","commit_id":"7a34badfe7caea339c8453de3a76742521b59765","url":"https://github.com/apache/sling"},{"original_method":"/**\r\n\t * Creates a new dialog that will handle the wait while we're doing the hard work.\r\n\t */\r\n\tpublic GetTableSizeProgressDialog(Shell shell, DatabaseMeta dbInfo, String tableName)\r\n\t{\r\n\t\tthis.shell = shell;\r\n\t\tthis.dbMeta = dbInfo;\r\n\t\tthis.tableName = tableName;\r\n\t}","id":24322,"modified_method":"/**\r\n\t * Creates a new dialog that will handle the wait while we're doing the hard work.\r\n\t */\r\n  public GetTableSizeProgressDialog(Shell shell, DatabaseMeta dbInfo, String tableName) {\r\n    this(shell, dbInfo, tableName, null);\r\n  }","commit_id":"b4cc477dee9dfb3ae95829097bd98ae93c521567","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getDDLForOther() {\r\n\t\t\r\n\t\tif (databases != null) {\r\n\t\t\ttry {\r\n\t\t\t\t\r\n\t\t\t\t// Now select the other connection...\r\n\t\t\t\t\r\n\t\t\t\t// Only take non-SAP ERP connections....\r\n\t\t\t\tList<DatabaseMeta> dbs = new ArrayList<DatabaseMeta>();\r\n\t\t\t\tfor (int i = 0; i < databases.size(); i++) {\r\n\t\t\t\t\tif (((databases.get(i)).getDatabaseInterface().isExplorable())) {\r\n\t\t\t\t\t\tdbs.add(databases.get(i));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tString conn[] = new String[dbs.size()];\r\n\t\t\t\tfor (int i = 0; i < conn.length; i++)\r\n\t\t\t\t\tconn[i] = (dbs.get(i)).getName();\r\n\t\t\t\t\r\n\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(this.dbExplorerDialog.getShell(), conn, BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.TargetDatabase.Title\"), BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.TargetDatabase.Message\"));\r\n\t\t\t\tString target = esd.open();\r\n\t\t\t\tif (target != null) {\r\n\t\t\t\t\tDatabaseMeta targetdbi = DatabaseMeta.findDatabase(dbs, target);\r\n\t\t\t\t\tDatabase targetdb = new Database(null, targetdbi);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\ttargetdb.connect();\r\n\t\t\t\t\t\tRowMetaInterface r = targetdb.getTableFields(this.model.getTable().getName());\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tString sql = targetdb.getCreateTableStatement(this.model.getTable().getName(), r, null, false, null, true);\r\n\t\t\t\t\t\tSQLEditor se = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, sql);\r\n\t\t\t\t\t\tse.open();\r\n\t\t\t\t\t} finally {\r\n\t\t\t\t\t\ttargetdb.disconnect();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (KettleDatabaseException dbe) {\r\n\t\t\t\tnew ErrorDialog(this.dbExplorerDialog.getShell(), BaseMessages.getString(PKG, \"Dialog.Error.Header\"), BaseMessages.getString(PKG, \"DatabaseExplorerDialog.Error.GenDDL\"), dbe);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tMessageBox mb = new MessageBox(this.dbExplorerDialog.getShell(), SWT.NONE | SWT.ICON_INFORMATION);\r\n\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"DatabaseExplorerDialog.NoConnectionsKnown.Message\"));\r\n\t\t\tmb.setText(BaseMessages.getString(PKG, \"DatabaseExplorerDialog.NoConnectionsKnown.Title\"));\r\n\t\t\tmb.open();\r\n\t\t}\r\n\t}","id":24323,"modified_method":"public void getDDLForOther() {\r\n\t\t\r\n\t\tif (databases != null) {\r\n\t\t\ttry {\r\n\t\t\t\t\r\n\t\t\t\t// Now select the other connection...\r\n\t\t\t\t\r\n\t\t\t\t// Only take non-SAP ERP connections....\r\n\t\t\t\tList<DatabaseMeta> dbs = new ArrayList<DatabaseMeta>();\r\n\t\t\t\tfor (int i = 0; i < databases.size(); i++) {\r\n\t\t\t\t\tif (((databases.get(i)).getDatabaseInterface().isExplorable())) {\r\n\t\t\t\t\t\tdbs.add(databases.get(i));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tString conn[] = new String[dbs.size()];\r\n\t\t\t\tfor (int i = 0; i < conn.length; i++)\r\n\t\t\t\t\tconn[i] = (dbs.get(i)).getName();\r\n\t\t\t\t\r\n\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(this.dbExplorerDialog.getShell(), conn, BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.TargetDatabase.Title\"), BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.TargetDatabase.Message\"));\r\n\t\t\t\tString target = esd.open();\r\n\t\t\t\tif (target != null) {\r\n\t\t\t\t\tDatabaseMeta targetdbi = DatabaseMeta.findDatabase(dbs, target);\r\n\t\t\t\t\tDatabase targetdb = new Database(null, targetdbi);\r\n\t\t\t\t\ttry{\r\n\t\t\t\t\t\ttargetdb.connect();\r\n            String tableName = getSchemaAndTable(model);\r\n\t\t\t\t\t\tRowMetaInterface r = targetdb.getTableFields(tableName);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tString sql = targetdb.getCreateTableStatement(tableName, r, null, false, null, true);\r\n\t\t\t\t\t\tSQLEditor se = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, sql);\r\n\t\t\t\t\t\tse.open();\r\n\t\t\t\t\t} finally {\r\n\t\t\t\t\t\ttargetdb.disconnect();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (KettleDatabaseException dbe) {\r\n\t\t\t\tnew ErrorDialog(this.dbExplorerDialog.getShell(), BaseMessages.getString(PKG, \"Dialog.Error.Header\"), BaseMessages.getString(PKG, \"DatabaseExplorerDialog.Error.GenDDL\"), dbe);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tMessageBox mb = new MessageBox(this.dbExplorerDialog.getShell(), SWT.NONE | SWT.ICON_INFORMATION);\r\n\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"DatabaseExplorerDialog.NoConnectionsKnown.Message\"));\r\n\t\t\tmb.setText(BaseMessages.getString(PKG, \"DatabaseExplorerDialog.NoConnectionsKnown.Title\"));\r\n\t\t\tmb.open();\r\n\t\t}\r\n\t}","commit_id":"b4cc477dee9dfb3ae95829097bd98ae93c521567","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void dataProfile(){\r\n\t\tShell dbShell = (Shell) dbExplorerDialog.getRootObject();\r\n\t\ttry {\r\n\t\t\tTransProfileFactory profileFactory = new TransProfileFactory(this.model.getDatabaseMeta(), model.getTable().getName());\r\n\t\t\tTransMeta transMeta = profileFactory.generateTransformation(new LoggingObject(model.getTable()));\r\n\t\t\tTransPreviewProgressDialog progressDialog = new TransPreviewProgressDialog(dbShell, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   transMeta, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   new String[] { TransProfileFactory.RESULT_STEP_NAME, }, new int[] { 25000, } );\r\n\t\t\t\r\n\t\t\tprogressDialog.open();\r\n\t\t\t\r\n\t\t\tif (!progressDialog.isCancelled())\r\n\t\t\t{\r\n\t\t\t\tTrans trans = progressDialog.getTrans();\r\n\t\t\t\tString loggingText = progressDialog.getLoggingText();\r\n\t\t\t\t\r\n\t\t\t\tif (trans.getResult()!=null && trans.getResult().getNrErrors()>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tEnterTextDialog etd = new EnterTextDialog(dbShell, BaseMessages.getString(PKG,\"System.Dialog.PreviewError.Title\"),  \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  BaseMessages.getString(PKG,\"System.Dialog.PreviewError.Message\"), loggingText, true );\r\n\t\t\t\t\tetd.setReadOnly();\r\n\t\t\t\t\tetd.open();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tPreviewRowsDialog prd = new PreviewRowsDialog(dbShell, transMeta, SWT.NONE, TransProfileFactory.RESULT_STEP_NAME,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  progressDialog.getPreviewRowsMeta(TransProfileFactory.RESULT_STEP_NAME), progressDialog\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getPreviewRows(TransProfileFactory.RESULT_STEP_NAME), loggingText);\r\n\t\t\t\tprd.open();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t} catch(Exception e) {\r\n\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG,\"DatabaseExplorerDialog.UnexpectedProfilingError.Title\"),\r\n\t\t\t\t\t\t\tBaseMessages.getString(PKG,\"DatabaseExplorerDialog.UnexpectedProfilingError.Message\"), e);\r\n\t\t}\r\n\t\t\r\n\t}","id":24324,"modified_method":"public void dataProfile(){\r\n\t\tShell dbShell = (Shell) dbExplorerDialog.getRootObject();\r\n\t\ttry {\r\n\t\t\tTransProfileFactory profileFactory = new TransProfileFactory(this.model.getDatabaseMeta(), getSchemaAndTable(this.model));\r\n\t\t\tTransMeta transMeta = profileFactory.generateTransformation(new LoggingObject(model.getTable()));\r\n\t\t\tTransPreviewProgressDialog progressDialog = new TransPreviewProgressDialog(dbShell, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   transMeta, \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   new String[] { TransProfileFactory.RESULT_STEP_NAME, }, new int[] { 25000, } );\r\n\t\t\t\r\n\t\t\tprogressDialog.open();\r\n\t\t\t\r\n\t\t\tif (!progressDialog.isCancelled())\r\n\t\t\t{\r\n\t\t\t\tTrans trans = progressDialog.getTrans();\r\n\t\t\t\tString loggingText = progressDialog.getLoggingText();\r\n\t\t\t\t\r\n\t\t\t\tif (trans.getResult()!=null && trans.getResult().getNrErrors()>0)\r\n\t\t\t\t{\r\n\t\t\t\t\tEnterTextDialog etd = new EnterTextDialog(dbShell, BaseMessages.getString(PKG,\"System.Dialog.PreviewError.Title\"),  \r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  BaseMessages.getString(PKG,\"System.Dialog.PreviewError.Message\"), loggingText, true );\r\n\t\t\t\t\tetd.setReadOnly();\r\n\t\t\t\t\tetd.open();\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tPreviewRowsDialog prd = new PreviewRowsDialog(dbShell, transMeta, SWT.NONE, TransProfileFactory.RESULT_STEP_NAME,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  progressDialog.getPreviewRowsMeta(TransProfileFactory.RESULT_STEP_NAME), progressDialog\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .getPreviewRows(TransProfileFactory.RESULT_STEP_NAME), loggingText);\r\n\t\t\t\tprd.open();\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t} catch(Exception e) {\r\n\t\t\tnew ErrorDialog(shell, BaseMessages.getString(PKG,\"DatabaseExplorerDialog.UnexpectedProfilingError.Title\"),\r\n\t\t\t\t\t\t\tBaseMessages.getString(PKG,\"DatabaseExplorerDialog.UnexpectedProfilingError.Message\"), e);\r\n\t\t}\r\n\t\t\r\n\t}","commit_id":"b4cc477dee9dfb3ae95829097bd98ae93c521567","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void showLayout() {\r\n\t\tXulStepFieldsDialog theStepFieldsDialog = new XulStepFieldsDialog(this.shell, SWT.NONE, this.model.getDatabaseMeta(), this.model.getTable().getName(), null);\r\n\t\ttheStepFieldsDialog.open(false);\r\n\t}","id":24325,"modified_method":"public void showLayout() {\r\n    String schema = this.model.getSchema() != null ? this.model.getSchema().getName() : null;\r\n\t\tXulStepFieldsDialog theStepFieldsDialog = new XulStepFieldsDialog(this.shell, SWT.NONE, this.model.getDatabaseMeta(), this.model.getTable().getName(), null, schema);\r\n\t\ttheStepFieldsDialog.open(false);\r\n\t}","commit_id":"b4cc477dee9dfb3ae95829097bd98ae93c521567","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void viewSql() {\r\n\t\tif (this.model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSQLEditor theSqlEditor = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, \"SELECT * FROM \" + this.model.getTable().getName());\r\n\t\ttheSqlEditor.open();\r\n\t}","id":24326,"modified_method":"public void viewSql() {\r\n\t\tif (this.model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSQLEditor theSqlEditor = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, \"SELECT * FROM \" + getSchemaAndTable(this.model));\r\n\t\ttheSqlEditor.open();\r\n\t}","commit_id":"b4cc477dee9dfb3ae95829097bd98ae93c521567","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void truncate() {\r\n\t\tif (this.model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSQLEditor theSqlEditor = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, \"-- TRUNCATE TABLE \" + this.model.getTable().getName());\r\n\t\ttheSqlEditor.open();\r\n\t}","id":24327,"modified_method":"public void truncate() {\r\n\t\tif (this.model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tSQLEditor theSqlEditor = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, \"-- TRUNCATE TABLE \" + getSchemaAndTable(this.model));\r\n\t\ttheSqlEditor.open();\r\n\t}","commit_id":"b4cc477dee9dfb3ae95829097bd98ae93c521567","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getDDL() {\r\n\t\tif(model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tDatabase db = new Database(null, this.model.getDatabaseMeta());\r\n\t\ttry {\r\n\t\t\tdb.connect();\r\n\t\t\tRowMetaInterface r = db.getTableFields(this.model.getTable().getName());\r\n\t\t\tString sql = db.getCreateTableStatement(this.model.getTable().getName(), r, null, false, null, true);\r\n\t\t\tSQLEditor se = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, sql);\r\n\t\t\tse.open();\r\n\t\t} catch (KettleDatabaseException dbe) {\r\n\t\t\tnew ErrorDialog(this.dbExplorerDialog.getShell(), BaseMessages.getString(PKG, \"Dialog.Error.Header\"), BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.Error.RetrieveLayout\"), dbe);\r\n\t\t} finally {\r\n\t\t\tdb.disconnect();\r\n\t\t}\r\n\t}","id":24328,"modified_method":"public void getDDL() {\r\n\t\tif(model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tDatabase db = new Database(null, this.model.getDatabaseMeta());\r\n\t\ttry {\r\n\t\t\tdb.connect();\r\n      String tableName = getSchemaAndTable(this.model);\r\n\r\n\t\t\tRowMetaInterface r = db.getTableFields(tableName);\r\n\t\t\tString sql = db.getCreateTableStatement(tableName, r, null, false, null, true);\r\n\t\t\tSQLEditor se = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, sql);\r\n\t\t\tse.open();\r\n\t\t} catch (KettleDatabaseException dbe) {\r\n\t\t\tnew ErrorDialog(this.dbExplorerDialog.getShell(), BaseMessages.getString(PKG, \"Dialog.Error.Header\"), BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.Error.RetrieveLayout\"), dbe);\r\n\t\t} finally {\r\n\t\t\tdb.disconnect();\r\n\t\t}\r\n\t}","commit_id":"b4cc477dee9dfb3ae95829097bd98ae93c521567","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void displayRowCount() {\r\n\t\tif (this.model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tGetTableSizeProgressDialog pd = new GetTableSizeProgressDialog(this.shell, this.model.getDatabaseMeta(), this.model.getTable().getName());\r\n\t\t\tLong theCount = pd.open();\r\n\t\t\tif (theCount != null) {\r\n\t\t\t\tXulMessageBox theMessageBox = (XulMessageBox) document.createElement(\"messagebox\");\r\n\t\t\t\ttheMessageBox.setModalParent(this.dbExplorerDialog.getShell());\r\n\t\t\t\ttheMessageBox.setTitle(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Title\"));\r\n\t\t\t\ttheMessageBox.setMessage(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Message\", this.model.getTable(), theCount.toString()));\r\n\t\t\t\ttheMessageBox.open();\r\n\t\t\t}\r\n\t\t} catch (XulException e) {\r\n\t\t\tlogger.error(e);\r\n\t\t}\r\n\t}","id":24329,"modified_method":"public void displayRowCount() {\r\n\t\tif (this.model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tString schema = this.model.getSchema() != null ? this.model.getSchema().getName() : null;\r\n      GetTableSizeProgressDialog pd = new GetTableSizeProgressDialog(this.shell, this.model.getDatabaseMeta(), this.model.getTable().getName(), schema);\r\n\t\t\tLong theCount = pd.open();\r\n\t\t\tif (theCount != null) {\r\n\t\t\t\tXulMessageBox theMessageBox = (XulMessageBox) document.createElement(\"messagebox\");\r\n\t\t\t\ttheMessageBox.setModalParent(this.dbExplorerDialog.getShell());\r\n\t\t\t\ttheMessageBox.setTitle(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Title\"));\r\n\t\t\t\ttheMessageBox.setMessage(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Message\", this.model.getTable(), theCount.toString()));\r\n\t\t\t\ttheMessageBox.open();\r\n\t\t\t}\r\n\t\t} catch (XulException e) {\r\n\t\t\tlogger.error(e);\r\n\t\t}\r\n\t}","commit_id":"b4cc477dee9dfb3ae95829097bd98ae93c521567","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public static long getGroupIdFromScopeId(\n\t\t\tString scopeId, long siteGroupId, boolean privateLayout)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (scopeId.startsWith(SCOPE_ID_CHILD_GROUP_PREFIX)) {\n\t\t\tString scopeIdSuffix = scopeId.substring(\n\t\t\t\tSCOPE_ID_CHILD_GROUP_PREFIX.length());\n\n\t\t\treturn GetterUtil.getLong(scopeIdSuffix);\n\t\t}\n\t\telse if (scopeId.startsWith(SCOPE_ID_GROUP_PREFIX)) {\n\t\t\tString scopeIdSuffix = scopeId.substring(\n\t\t\t\tSCOPE_ID_GROUP_PREFIX.length());\n\n\t\t\tif (scopeIdSuffix.equals(GroupConstants.DEFAULT)) {\n\t\t\t\treturn siteGroupId;\n\t\t\t}\n\n\t\t\treturn GetterUtil.getLong(scopeIdSuffix);\n\t\t}\n\t\telse if (scopeId.startsWith(SCOPE_ID_LAYOUT_UUID_PREFIX)) {\n\t\t\tString layoutUuid = scopeId.substring(\n\t\t\t\tSCOPE_ID_LAYOUT_UUID_PREFIX.length());\n\n\t\t\tLayout scopeIdLayout =\n\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\tlayoutUuid, siteGroupId, privateLayout);\n\n\t\t\tGroup scopeIdGroup = scopeIdLayout.getScopeGroup();\n\n\t\t\treturn scopeIdGroup.getGroupId();\n\t\t}\n\t\telse if (scopeId.startsWith(SCOPE_ID_LAYOUT_PREFIX)) {\n\n\t\t\t// Legacy preferences\n\n\t\t\tString scopeIdSuffix = scopeId.substring(\n\t\t\t\tSCOPE_ID_LAYOUT_PREFIX.length());\n\n\t\t\tlong scopeIdLayoutId = GetterUtil.getLong(scopeIdSuffix);\n\n\t\t\tLayout scopeIdLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\tsiteGroupId, privateLayout, scopeIdLayoutId);\n\n\t\t\tGroup scopeIdGroup = scopeIdLayout.getScopeGroup();\n\n\t\t\treturn scopeIdGroup.getGroupId();\n\t\t}\n\t\telse if (scopeId.startsWith(SCOPE_ID_PARENT_GROUP_PREFIX)) {\n\t\t\tString scopeIdSuffix = scopeId.substring(\n\t\t\t\tSCOPE_ID_PARENT_GROUP_PREFIX.length());\n\n\t\t\treturn GetterUtil.getLong(scopeIdSuffix);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Invalid scope ID \" + scopeId);\n\t\t}\n\t}","id":24330,"modified_method":"public static long getGroupIdFromScopeId(\n\t\t\tString scopeId, long siteGroupId, boolean privateLayout)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (scopeId.startsWith(SCOPE_ID_CHILD_GROUP_PREFIX)) {\n\t\t\tString scopeIdSuffix = scopeId.substring(\n\t\t\t\tSCOPE_ID_CHILD_GROUP_PREFIX.length());\n\n\t\t\treturn GetterUtil.getLong(scopeIdSuffix);\n\t\t}\n\t\telse if (scopeId.startsWith(SCOPE_ID_GROUP_PREFIX)) {\n\t\t\tString scopeIdSuffix = scopeId.substring(\n\t\t\t\tSCOPE_ID_GROUP_PREFIX.length());\n\n\t\t\tif (scopeIdSuffix.equals(GroupConstants.DEFAULT)) {\n\t\t\t\treturn siteGroupId;\n\t\t\t}\n\n\t\t\treturn GetterUtil.getLong(scopeIdSuffix);\n\t\t}\n\t\telse if (scopeId.startsWith(SCOPE_ID_LAYOUT_UUID_PREFIX)) {\n\t\t\tString layoutUuid = scopeId.substring(\n\t\t\t\tSCOPE_ID_LAYOUT_UUID_PREFIX.length());\n\n\t\t\tLayout scopeIdLayout =\n\t\t\t\tLayoutLocalServiceUtil.getLayoutByUuidAndGroupId(\n\t\t\t\t\tlayoutUuid, siteGroupId, privateLayout);\n\n\t\t\tGroup scopeIdGroup = null;\n\n\t\t\tif (scopeIdLayout.hasScopeGroup()) {\n\t\t\t\tscopeIdGroup = scopeIdLayout.getScopeGroup();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong userId = PrincipalThreadLocal.getUserId();\n\n\t\t\t\tString name = String.valueOf(scopeIdLayout.getPlid());\n\n\t\t\t\tscopeIdGroup = GroupLocalServiceUtil.addGroup(\n\t\t\t\t\tuserId, GroupConstants.DEFAULT_PARENT_GROUP_ID,\n\t\t\t\t\tLayout.class.getName(), scopeIdLayout.getPlid(),\n\t\t\t\t\tGroupConstants.DEFAULT_LIVE_GROUP_ID, name, null, 0, null,\n\t\t\t\t\tfalse, true, null);\n\t\t\t}\n\n\t\t\treturn scopeIdGroup.getGroupId();\n\t\t}\n\t\telse if (scopeId.startsWith(SCOPE_ID_LAYOUT_PREFIX)) {\n\n\t\t\t// Legacy preferences\n\n\t\t\tString scopeIdSuffix = scopeId.substring(\n\t\t\t\tSCOPE_ID_LAYOUT_PREFIX.length());\n\n\t\t\tlong scopeIdLayoutId = GetterUtil.getLong(scopeIdSuffix);\n\n\t\t\tLayout scopeIdLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\tsiteGroupId, privateLayout, scopeIdLayoutId);\n\n\t\t\tGroup scopeIdGroup = scopeIdLayout.getScopeGroup();\n\n\t\t\treturn scopeIdGroup.getGroupId();\n\t\t}\n\t\telse if (scopeId.startsWith(SCOPE_ID_PARENT_GROUP_PREFIX)) {\n\t\t\tString scopeIdSuffix = scopeId.substring(\n\t\t\t\tSCOPE_ID_PARENT_GROUP_PREFIX.length());\n\n\t\t\treturn GetterUtil.getLong(scopeIdSuffix);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Invalid scope ID \" + scopeId);\n\t\t}\n\t}","commit_id":"55f210f858d7ab3d9b1bcc2cf6035e01ff3601ba","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public FileCacheOutputStream exportLayoutsAsStream(\n\t\t\tlong groupId, boolean privateLayout, long[] layoutIds,\n\t\t\tMap<String, String[]> parameterMap, Date startDate, Date endDate)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean exportCategories = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.CATEGORIES);\n\t\tboolean exportPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PERMISSIONS);\n\t\tboolean exportUserPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.USER_PERMISSIONS);\n\t\tboolean exportPortletArchivedSetups = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_ARCHIVED_SETUPS);\n\t\tboolean exportPortletUserPreferences = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_USER_PREFERENCES);\n\t\tboolean exportTheme = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.THEME);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Export categories \" + exportCategories);\n\t\t\t_log.debug(\"Export permissions \" + exportPermissions);\n\t\t\t_log.debug(\"Export user permissions \" + exportUserPermissions);\n\t\t\t_log.debug(\n\t\t\t\t\"Export portlet archived setups \" +\n\t\t\t\t\texportPortletArchivedSetups);\n\t\t\t_log.debug(\n\t\t\t\t\"Export portlet user preferences \" +\n\t\t\t\t\texportPortletUserPreferences);\n\t\t\t_log.debug(\"Export theme \" + exportTheme);\n\t\t}\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tLayoutCache layoutCache = new LayoutCache();\n\n\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\tgroupId, privateLayout);\n\n\t\tlong companyId = layoutSet.getCompanyId();\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(companyId);\n\n\t\tZipWriter zipWriter = null;\n\n\t\ttry {\n\t\t\tzipWriter = new ZipWriter();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\tPortletDataContext context = new PortletDataContextImpl(\n\t\t\tcompanyId, groupId, parameterMap, new HashSet<String>(), startDate,\n\t\t\tendDate, zipWriter);\n\n\t\tGroup guestGroup = GroupLocalServiceUtil.getGroup(\n\t\t\tcompanyId, GroupConstants.GUEST);\n\n\t\t// Build compatibility\n\n\t\tDocument doc = SAXReaderUtil.createDocument();\n\n\t\tElement root = doc.addElement(\"root\");\n\n\t\tElement header = root.addElement(\"header\");\n\n\t\theader.addAttribute(\n\t\t\t\"build-number\", String.valueOf(ReleaseInfo.getBuildNumber()));\n\t\theader.addAttribute(\"export-date\", Time.getRFC822());\n\n\t\tif (context.hasDateRange()) {\n\t\t\theader.addAttribute(\n\t\t\t\t\"start-date\", String.valueOf(context.getStartDate()));\n\t\t\theader.addAttribute(\n\t\t\t\t\"end-date\", String.valueOf(context.getEndDate()));\n\t\t}\n\n\t\theader.addAttribute(\"type\", \"layout-set\");\n\t\theader.addAttribute(\"group-id\", String.valueOf(groupId));\n\t\theader.addAttribute(\"private-layout\", String.valueOf(privateLayout));\n\t\theader.addAttribute(\"theme-id\", layoutSet.getThemeId());\n\t\theader.addAttribute(\"color-scheme-id\", layoutSet.getColorSchemeId());\n\n\t\t// Layout Configuration Portlet\n\n\t\tPortlet layoutConfigurationPortlet =\n\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\tcontext.getCompanyId(), PortletKeys.LAYOUT_CONFIGURATION);\n\n\t\t// Layouts\n\n\t\tMap<String, Object[]> portletIds =\n\t\t\tnew LinkedHashMap<String, Object[]>();\n\n\t\tList<Layout> layouts = null;\n\n\t\tif ((layoutIds == null) || (layoutIds.length == 0)) {\n\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(groupId, privateLayout);\n\t\t}\n\t\telse {\n\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\tgroupId, privateLayout, layoutIds);\n\t\t}\n\n\t\tElement layoutsEl = root.addElement(\"layouts\");\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tcontext.setPlid(layout.getPlid());\n\n\t\t\tDocument layoutDoc = SAXReaderUtil.createDocument();\n\n\t\t\tElement layoutEl = layoutDoc.addElement(\"layout\");\n\n\t\t\tlayoutEl.addAttribute(\"old-plid\", String.valueOf(layout.getPlid()));\n\t\t\tlayoutEl.addAttribute(\n\t\t\t\t\"layout-id\", String.valueOf(layout.getLayoutId()));\n\t\t\tlayoutEl.addElement(\"parent-layout-id\").addText(\n\t\t\t\tString.valueOf(layout.getParentLayoutId()));\n\t\t\tlayoutEl.addElement(\"name\").addCDATA(layout.getName());\n\t\t\tlayoutEl.addElement(\"title\").addCDATA(layout.getTitle());\n\t\t\tlayoutEl.addElement(\"description\").addText(layout.getDescription());\n\t\t\tlayoutEl.addElement(\"type\").addText(layout.getType());\n\t\t\tlayoutEl.addElement(\"type-settings\").addCDATA(\n\t\t\t\tlayout.getTypeSettings());\n\t\t\tlayoutEl.addElement(\"hidden\").addText(\n\t\t\t\tString.valueOf(layout.getHidden()));\n\t\t\tlayoutEl.addElement(\"friendly-url\").addText(\n\t\t\t\tlayout.getFriendlyURL());\n\t\t\tlayoutEl.addElement(\"icon-image\").addText(\n\t\t\t\tString.valueOf(layout.getIconImage()));\n\n\t\t\tif (layout.isIconImage()) {\n\t\t\t\tImage image = ImageLocalServiceUtil.getImage(\n\t\t\t\t\tlayout.getIconImageId());\n\n\t\t\t\tif (image != null) {\n\t\t\t\t\tString iconPath = getLayoutIconPath(context, layout, image);\n\n\t\t\t\t\tlayoutEl.addElement(\"icon-image-path\").addText(\n\t\t\t\t\t\ticonPath);\n\n\t\t\t\t\tcontext.addZipEntry(iconPath, image.getTextObj());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlayoutEl.addElement(\"theme-id\").addText(layout.getThemeId());\n\t\t\tlayoutEl.addElement(\"color-scheme-id\").addText(\n\t\t\t\tlayout.getColorSchemeId());\n\t\t\tlayoutEl.addElement(\"wap-theme-id\").addText(layout.getWapThemeId());\n\t\t\tlayoutEl.addElement(\"wap-color-scheme-id\").addText(\n\t\t\t\tlayout.getWapColorSchemeId());\n\t\t\tlayoutEl.addElement(\"css\").addCDATA(layout.getCss());\n\t\t\tlayoutEl.addElement(\"priority\").addText(\n\t\t\t\tString.valueOf(layout.getPriority()));\n\n\t\t\t// Layout permissions\n\n\t\t\tif (exportPermissions) {\n\t\t\t\tElement permissionsEl = layoutEl.addElement(\"permissions\");\n\n\t\t\t\tString resourceName = Layout.class.getName();\n\t\t\t\tString resourcePrimKey = String.valueOf(layout.getPlid());\n\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\texportLayoutPermissions_5(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, resourceName,\n\t\t\t\t\t\tresourcePrimKey, permissionsEl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texportLayoutPermissions_4(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, guestGroup,\n\t\t\t\t\t\tresourceName, resourcePrimKey, permissionsEl,\n\t\t\t\t\t\texportUserPermissions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (layout.getType().equals(LayoutConstants.TYPE_PORTLET)) {\n\t\t\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\t\tlong scopeGroupId = groupId;\n\n\t\t\t\tfor (String portletId : layoutTypePortlet.getPortletIds()) {\n\t\t\t\t\tjavax.portlet.PortletPreferences jxPreferences =\n\t\t\t\t\t\tPortletPreferencesFactoryUtil.getLayoutPortletSetup(\n\t\t\t\t\t\t\tlayout, portletId);\n\n\t\t\t\t\tlong scopeLayoutId = GetterUtil.getLong(\n\t\t\t\t\t\tjxPreferences.getValue(\"lfr-scope-layout-id\", null));\n\n\t\t\t\t\tif (scopeLayoutId != 0) {\n\t\t\t\t\t\tLayout scopeLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\t\t\tgroupId, layout.isPrivateLayout(), scopeLayoutId);\n\n\t\t\t\t\t\tGroup scopeGroup = scopeLayout.getScopeGroup();\n\n\t\t\t\t\t\tif (scopeGroup != null) {\n\t\t\t\t\t\t\tscopeGroupId = scopeGroup.getGroupId();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tString key = PortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\tlayout.getPlid(), portletId);\n\n\t\t\t\t\tportletIds.put(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\t\tportletId, layout.getPlid(), scopeGroupId,\n\t\t\t\t\t\t\tscopeLayoutId\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString layoutPath = context.getLayoutPath(layout.getLayoutId()) +\n\t\t\t\t\"/layout.xml\";\n\n\t\t\tElement el = layoutsEl.addElement(\"layout\");\n\n\t\t\tel.addAttribute(\"layout-id\", String.valueOf(layout.getLayoutId()));\n\t\t\tel.addAttribute(\"path\", layoutPath);\n\n\t\t\t_portletExporter.exportPortletData(\n\t\t\t\tcontext, layoutConfigurationPortlet, layout, null, layoutEl);\n\n\t\t\ttry {\n\t\t\t\tcontext.addZipEntry(layoutPath, layoutDoc.formattedString());\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM != 5) {\n\t\t\tElement rolesEl = root.addElement(\"roles\");\n\n\t\t\t// Layout roles\n\n\t\t\tif (exportPermissions) {\n\t\t\t\texportLayoutRoles(layoutCache, companyId, groupId, rolesEl);\n\t\t\t}\n\t\t}\n\n\t\t// Export Portlets\n\n\t\tElement portletsEl = root.addElement(\"portlets\");\n\n\t\tfor (Map.Entry<String, Object[]> portletIdsEntry :\n\t\t\t\tportletIds.entrySet()) {\n\n\t\t\tString portletId = (String)portletIdsEntry.getValue()[0];\n\t\t\tlong plid = (Long)portletIdsEntry.getValue()[1];\n\t\t\tlong scopeGroupId = (Long)portletIdsEntry.getValue()[2];\n\t\t\tlong scopeLayoutId = (Long)portletIdsEntry.getValue()[3];\n\n\t\t\tLayout layout = LayoutUtil.findByPrimaryKey(plid);\n\n\t\t\tcontext.setPlid(layout.getPlid());\n\t\t\tcontext.setOldPlid(layout.getPlid());\n\t\t\tcontext.setScopeGroupId(scopeGroupId);\n\t\t\tcontext.setScopeLayoutId(scopeLayoutId);\n\n\t\t\tboolean[] exportPortletControls = getExportPortletControls(\n\t\t\t\tcontext.getCompanyId(), portletId, context, parameterMap);\n\n\t\t\t_portletExporter.exportPortlet(\n\t\t\t\tcontext, layoutCache, portletId, layout, portletsEl,\n\t\t\t\tdefaultUserId, exportPermissions, exportPortletArchivedSetups,\n\t\t\t\texportPortletControls[0], exportPortletControls[1],\n\t\t\t\texportPortletUserPreferences, exportUserPermissions);\n\t\t}\n\n\t\t// Categories\n\n\t\tif (exportCategories) {\n\t\t\texportCategories(context);\n\t\t}\n\n\t\t_portletExporter.exportCategories(context, root);\n\n\t\t// Comments\n\n\t\t_portletExporter.exportComments(context, root);\n\n\t\t// Ratings\n\n\t\t_portletExporter.exportRatings(context, root);\n\n\t\t// Tags\n\n\t\t_portletExporter.exportTags(context, root);\n\n\t\t// Look and feel\n\n\t\tInputStream themeZip = null;\n\n\t\ttry {\n\t\t\tif (exportTheme) {\n\t\t\t\tthemeZip = exportTheme(layoutSet).getFileInputStream();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\t// Log\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Exporting layouts takes \" + stopWatch.getTime() + \" ms\");\n\t\t}\n\n\t\t// Zip\n\n\t\ttry {\n\t\t\tcontext.addZipEntry(\"/manifest.xml\", doc.formattedString());\n\n\t\t\tif (themeZip != null) {\n\t\t\t\tcontext.addZipEntry(\"/theme.zip\", themeZip);\n\t\t\t}\n\n\t\t\treturn zipWriter.finishWithStream();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\t}","id":24331,"modified_method":"public FileCacheOutputStream exportLayoutsAsStream(\n\t\t\tlong groupId, boolean privateLayout, long[] layoutIds,\n\t\t\tMap<String, String[]> parameterMap, Date startDate, Date endDate)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean exportCategories = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.CATEGORIES);\n\t\tboolean exportPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PERMISSIONS);\n\t\tboolean exportUserPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.USER_PERMISSIONS);\n\t\tboolean exportPortletArchivedSetups = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_ARCHIVED_SETUPS);\n\t\tboolean exportPortletUserPreferences = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_USER_PREFERENCES);\n\t\tboolean exportTheme = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.THEME);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Export categories \" + exportCategories);\n\t\t\t_log.debug(\"Export permissions \" + exportPermissions);\n\t\t\t_log.debug(\"Export user permissions \" + exportUserPermissions);\n\t\t\t_log.debug(\n\t\t\t\t\"Export portlet archived setups \" +\n\t\t\t\t\texportPortletArchivedSetups);\n\t\t\t_log.debug(\n\t\t\t\t\"Export portlet user preferences \" +\n\t\t\t\t\texportPortletUserPreferences);\n\t\t\t_log.debug(\"Export theme \" + exportTheme);\n\t\t}\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tLayoutCache layoutCache = new LayoutCache();\n\n\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\tgroupId, privateLayout);\n\n\t\tlong companyId = layoutSet.getCompanyId();\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(companyId);\n\n\t\tZipWriter zipWriter = null;\n\n\t\ttry {\n\t\t\tzipWriter = new ZipWriter();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\tPortletDataContext context = new PortletDataContextImpl(\n\t\t\tcompanyId, groupId, parameterMap, new HashSet<String>(), startDate,\n\t\t\tendDate, zipWriter);\n\n\t\tGroup guestGroup = GroupLocalServiceUtil.getGroup(\n\t\t\tcompanyId, GroupConstants.GUEST);\n\n\t\t// Build compatibility\n\n\t\tDocument doc = SAXReaderUtil.createDocument();\n\n\t\tElement root = doc.addElement(\"root\");\n\n\t\tElement header = root.addElement(\"header\");\n\n\t\theader.addAttribute(\n\t\t\t\"build-number\", String.valueOf(ReleaseInfo.getBuildNumber()));\n\t\theader.addAttribute(\"export-date\", Time.getRFC822());\n\n\t\tif (context.hasDateRange()) {\n\t\t\theader.addAttribute(\n\t\t\t\t\"start-date\", String.valueOf(context.getStartDate()));\n\t\t\theader.addAttribute(\n\t\t\t\t\"end-date\", String.valueOf(context.getEndDate()));\n\t\t}\n\n\t\theader.addAttribute(\"type\", \"layout-set\");\n\t\theader.addAttribute(\"group-id\", String.valueOf(groupId));\n\t\theader.addAttribute(\"private-layout\", String.valueOf(privateLayout));\n\t\theader.addAttribute(\"theme-id\", layoutSet.getThemeId());\n\t\theader.addAttribute(\"color-scheme-id\", layoutSet.getColorSchemeId());\n\n\t\t// Layout Configuration Portlet\n\n\t\tPortlet layoutConfigurationPortlet =\n\t\t\tPortletLocalServiceUtil.getPortletById(\n\t\t\t\tcontext.getCompanyId(), PortletKeys.LAYOUT_CONFIGURATION);\n\n\t\t// Layouts\n\n\t\tMap<String, Object[]> portletIds =\n\t\t\tnew LinkedHashMap<String, Object[]>();\n\n\t\tList<Layout> layouts = null;\n\n\t\tif ((layoutIds == null) || (layoutIds.length == 0)) {\n\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(groupId, privateLayout);\n\t\t}\n\t\telse {\n\t\t\tlayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\t\tgroupId, privateLayout, layoutIds);\n\t\t}\n\n\t\tElement layoutsEl = root.addElement(\"layouts\");\n\n\t\tfor (Layout layout : layouts) {\n\t\t\tcontext.setPlid(layout.getPlid());\n\n\t\t\tDocument layoutDoc = SAXReaderUtil.createDocument();\n\n\t\t\tElement layoutEl = layoutDoc.addElement(\"layout\");\n\n\t\t\tlayoutEl.addAttribute(\"old-plid\", String.valueOf(layout.getPlid()));\n\t\t\tlayoutEl.addAttribute(\n\t\t\t\t\"layout-id\", String.valueOf(layout.getLayoutId()));\n\t\t\tlayoutEl.addElement(\"parent-layout-id\").addText(\n\t\t\t\tString.valueOf(layout.getParentLayoutId()));\n\t\t\tlayoutEl.addElement(\"name\").addCDATA(layout.getName());\n\t\t\tlayoutEl.addElement(\"title\").addCDATA(layout.getTitle());\n\t\t\tlayoutEl.addElement(\"description\").addText(layout.getDescription());\n\t\t\tlayoutEl.addElement(\"type\").addText(layout.getType());\n\t\t\tlayoutEl.addElement(\"type-settings\").addCDATA(\n\t\t\t\tlayout.getTypeSettings());\n\t\t\tlayoutEl.addElement(\"hidden\").addText(\n\t\t\t\tString.valueOf(layout.getHidden()));\n\t\t\tlayoutEl.addElement(\"friendly-url\").addText(\n\t\t\t\tlayout.getFriendlyURL());\n\t\t\tlayoutEl.addElement(\"icon-image\").addText(\n\t\t\t\tString.valueOf(layout.getIconImage()));\n\n\t\t\tif (layout.isIconImage()) {\n\t\t\t\tImage image = ImageLocalServiceUtil.getImage(\n\t\t\t\t\tlayout.getIconImageId());\n\n\t\t\t\tif (image != null) {\n\t\t\t\t\tString iconPath = getLayoutIconPath(context, layout, image);\n\n\t\t\t\t\tlayoutEl.addElement(\"icon-image-path\").addText(\n\t\t\t\t\t\ticonPath);\n\n\t\t\t\t\tcontext.addZipEntry(iconPath, image.getTextObj());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlayoutEl.addElement(\"theme-id\").addText(layout.getThemeId());\n\t\t\tlayoutEl.addElement(\"color-scheme-id\").addText(\n\t\t\t\tlayout.getColorSchemeId());\n\t\t\tlayoutEl.addElement(\"wap-theme-id\").addText(layout.getWapThemeId());\n\t\t\tlayoutEl.addElement(\"wap-color-scheme-id\").addText(\n\t\t\t\tlayout.getWapColorSchemeId());\n\t\t\tlayoutEl.addElement(\"css\").addCDATA(layout.getCss());\n\t\t\tlayoutEl.addElement(\"priority\").addText(\n\t\t\t\tString.valueOf(layout.getPriority()));\n\n\t\t\t// Layout permissions\n\n\t\t\tif (exportPermissions) {\n\t\t\t\tElement permissionsEl = layoutEl.addElement(\"permissions\");\n\n\t\t\t\tString resourceName = Layout.class.getName();\n\t\t\t\tString resourcePrimKey = String.valueOf(layout.getPlid());\n\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\texportLayoutPermissions_5(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, resourceName,\n\t\t\t\t\t\tresourcePrimKey, permissionsEl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\texportLayoutPermissions_4(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, guestGroup,\n\t\t\t\t\t\tresourceName, resourcePrimKey, permissionsEl,\n\t\t\t\t\t\texportUserPermissions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (layout.getType().equals(LayoutConstants.TYPE_PORTLET)) {\n\t\t\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\t\t\tlong scopeGroupId = groupId;\n\n\t\t\t\tfor (String portletId : layoutTypePortlet.getPortletIds()) {\n\t\t\t\t\tjavax.portlet.PortletPreferences jxPreferences =\n\t\t\t\t\t\tPortletPreferencesFactoryUtil.getLayoutPortletSetup(\n\t\t\t\t\t\t\tlayout, portletId);\n\n\t\t\t\t\tlong scopeLayoutId = GetterUtil.getLong(\n\t\t\t\t\t\tjxPreferences.getValue(\"lfr-scope-layout-id\", null));\n\n\t\t\t\t\tif (scopeLayoutId != 0) {\n\t\t\t\t\t\tLayout scopeLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\t\t\tgroupId, layout.isPrivateLayout(), scopeLayoutId);\n\n\t\t\t\t\t\tGroup scopeGroup = scopeLayout.getScopeGroup();\n\n\t\t\t\t\t\tif (scopeGroup != null) {\n\t\t\t\t\t\t\tscopeGroupId = scopeGroup.getGroupId();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tString key = PortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\tlayout.getPlid(), portletId);\n\n\t\t\t\t\tportletIds.put(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\t\tportletId, layout.getPlid(), scopeGroupId,\n\t\t\t\t\t\t\tscopeLayoutId\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (String portletId : ALWAYS_EXPORT_PORTLET_IDS) {\n\t\t\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\t\tcontext.getCompanyId(), portletId);\n\n\t\t\t\tif (!portlet.isActive()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (portlet.isScopeable() && layout.hasScopeGroup()) {\n\t\t\t\t\tString key = PortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\tlayout.getPlid(), portletId);\n\n\t\t\t\t\tportletIds.put(\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\t\tportletId, layout.getPlid(),\n\t\t\t\t\t\t\tlayout.getScopeGroup().getGroupId(),\n\t\t\t\t\t\t\tlayout.getLayoutId()\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString key = PortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\t0, portletId);\n\n\t\t\t\t\tif (portletIds.get(key) == null) {\n\t\t\t\t\t\tportletIds.put(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tnew Object[] {\n\t\t\t\t\t\t\t\tportletId, layout.getPlid(), groupId, 0L\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString layoutPath = context.getLayoutPath(layout.getLayoutId()) +\n\t\t\t\t\"/layout.xml\";\n\n\t\t\tElement el = layoutsEl.addElement(\"layout\");\n\n\t\t\tel.addAttribute(\"layout-id\", String.valueOf(layout.getLayoutId()));\n\t\t\tel.addAttribute(\"path\", layoutPath);\n\n\t\t\t_portletExporter.exportPortletData(\n\t\t\t\tcontext, layoutConfigurationPortlet, layout, null, layoutEl);\n\n\t\t\ttry {\n\t\t\t\tcontext.addZipEntry(layoutPath, layoutDoc.formattedString());\n\t\t\t}\n\t\t\tcatch (IOException ioe) {\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM != 5) {\n\t\t\tElement rolesEl = root.addElement(\"roles\");\n\n\t\t\t// Layout roles\n\n\t\t\tif (exportPermissions) {\n\t\t\t\texportLayoutRoles(layoutCache, companyId, groupId, rolesEl);\n\t\t\t}\n\t\t}\n\n\t\t// Export Portlets\n\n\t\tElement portletsEl = root.addElement(\"portlets\");\n\n\t\tfor (Map.Entry<String, Object[]> portletIdsEntry :\n\t\t\t\tportletIds.entrySet()) {\n\n\t\t\tString portletId = (String)portletIdsEntry.getValue()[0];\n\t\t\tlong plid = (Long)portletIdsEntry.getValue()[1];\n\t\t\tlong scopeGroupId = (Long)portletIdsEntry.getValue()[2];\n\t\t\tlong scopeLayoutId = (Long)portletIdsEntry.getValue()[3];\n\n\t\t\tLayout layout = LayoutUtil.findByPrimaryKey(plid);\n\n\t\t\tcontext.setPlid(layout.getPlid());\n\t\t\tcontext.setOldPlid(layout.getPlid());\n\t\t\tcontext.setScopeGroupId(scopeGroupId);\n\t\t\tcontext.setScopeLayoutId(scopeLayoutId);\n\n\t\t\tboolean[] exportPortletControls = getExportPortletControls(\n\t\t\t\tcontext.getCompanyId(), portletId, context, parameterMap);\n\n\t\t\t_portletExporter.exportPortlet(\n\t\t\t\tcontext, layoutCache, portletId, layout, portletsEl,\n\t\t\t\tdefaultUserId, exportPermissions, exportPortletArchivedSetups,\n\t\t\t\texportPortletControls[0], exportPortletControls[1],\n\t\t\t\texportPortletUserPreferences, exportUserPermissions);\n\t\t}\n\n\t\t// Categories\n\n\t\tif (exportCategories) {\n\t\t\texportCategories(context);\n\t\t}\n\n\t\t_portletExporter.exportCategories(context, root);\n\n\t\t// Comments\n\n\t\t_portletExporter.exportComments(context, root);\n\n\t\t// Ratings\n\n\t\t_portletExporter.exportRatings(context, root);\n\n\t\t// Tags\n\n\t\t_portletExporter.exportTags(context, root);\n\n\t\t// Look and feel\n\n\t\tInputStream themeZip = null;\n\n\t\ttry {\n\t\t\tif (exportTheme) {\n\t\t\t\tthemeZip = exportTheme(layoutSet).getFileInputStream();\n\t\t\t}\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\n\t\t// Log\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Exporting layouts takes \" + stopWatch.getTime() + \" ms\");\n\t\t}\n\n\t\t// Zip\n\n\t\ttry {\n\t\t\tcontext.addZipEntry(\"/manifest.xml\", doc.formattedString());\n\n\t\t\tif (themeZip != null) {\n\t\t\t\tcontext.addZipEntry(\"/theme.zip\", themeZip);\n\t\t\t}\n\n\t\t\treturn zipWriter.finishWithStream();\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tthrow new SystemException(ioe);\n\t\t}\n\t}","commit_id":"4b28ddaa36404bd7485899ff8d888fe45ffe6a84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void importLayouts(\n\t\t\tlong userId, long groupId, boolean privateLayout,\n\t\t\tMap<String, String[]> parameterMap, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean deleteMissingLayouts = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.DELETE_MISSING_LAYOUTS,\n\t\t\tBoolean.TRUE.booleanValue());\n\t\tboolean deletePortletData = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.DELETE_PORTLET_DATA);\n\t\tboolean importCategories = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.CATEGORIES);\n\t\tboolean importPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PERMISSIONS);\n\t\tboolean importUserPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PERMISSIONS);\n\t\tboolean importPortletData = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_DATA);\n\t\tboolean importPortletSetup = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_SETUP);\n\t\tboolean importPortletArchivedSetups = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_ARCHIVED_SETUPS);\n\t\tboolean importPortletUserPreferences = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_USER_PREFERENCES);\n\t\tboolean importTheme = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.THEME);\n\t\tString layoutsImportMode = MapUtil.getString(\n\t\t\tparameterMap, PortletDataHandlerKeys.LAYOUTS_IMPORT_MODE,\n\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_ID);\n\t\tString portletsMergeMode = MapUtil.getString(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLETS_MERGE_MODE,\n\t\t\tPortletDataHandlerKeys.PORTLETS_MERGE_MODE_REPLACE);\n\t\tString userIdStrategy = MapUtil.getString(\n\t\t\tparameterMap, PortletDataHandlerKeys.USER_ID_STRATEGY);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Delete portlet data \" + deletePortletData);\n\t\t\t_log.debug(\"Import categories \" + importCategories);\n\t\t\t_log.debug(\"Import permissions \" + importPermissions);\n\t\t\t_log.debug(\"Import user permissions \" + importUserPermissions);\n\t\t\t_log.debug(\"Import portlet data \" + importPortletData);\n\t\t\t_log.debug(\"Import portlet setup \" + importPortletSetup);\n\t\t\t_log.debug(\n\t\t\t\t\"Import portlet archived setups \" +\n\t\t\t\t\timportPortletArchivedSetups);\n\t\t\t_log.debug(\n\t\t\t\t\"Import portlet user preferences \" +\n\t\t\t\t\timportPortletUserPreferences);\n\t\t\t_log.debug(\"Import theme \" + importTheme);\n\t\t}\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tLayoutCache layoutCache = new LayoutCache();\n\n\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\tgroupId, privateLayout);\n\n\t\tlong companyId = layoutSet.getCompanyId();\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\n\t\tUserIdStrategy strategy = _portletImporter.getUserIdStrategy(\n\t\t\tuser, userIdStrategy);\n\n\t\tZipReader zipReader = new ZipReader(is);\n\n\t\tPortletDataContext context = new PortletDataContextImpl(\n\t\t\tcompanyId, groupId, parameterMap, new HashSet<String>(), strategy,\n\t\t\tzipReader);\n\n\t\tcontext.setPrivateLayout(privateLayout);\n\n\t\tGroup guestGroup = GroupLocalServiceUtil.getGroup(\n\t\t\tcompanyId, GroupConstants.GUEST);\n\n\t\t// Zip\n\n\t\tElement root = null;\n\t\tbyte[] themeZip = null;\n\n\t\t// Manifest\n\n\t\tString xml = context.getZipEntryAsString(\"/manifest.xml\");\n\n\t\tif (xml == null) {\n\t\t\tthrow new LARFileException(\"manifest.xml not found in the LAR\");\n\t\t}\n\n\t\ttry {\n\t\t\tDocument doc = SAXReaderUtil.read(xml);\n\n\t\t\troot = doc.getRootElement();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new LARFileException(e);\n\t\t}\n\n\t\t// Build compatibility\n\n\t\tElement header = root.element(\"header\");\n\n\t\tint buildNumber = ReleaseInfo.getBuildNumber();\n\n\t\tint importBuildNumber = GetterUtil.getInteger(\n\t\t\theader.attributeValue(\"build-number\"));\n\n\t\tif (buildNumber != importBuildNumber) {\n\t\t\tthrow new LayoutImportException(\n\t\t\t\t\"LAR build number \" + importBuildNumber + \" does not match \" +\n\t\t\t\t\t\"portal build number \" + buildNumber);\n\t\t}\n\n\t\t// Type compatibility\n\n\t\tString larType = header.attributeValue(\"type\");\n\n\t\tif (!larType.equals(\"layout-set\")) {\n\t\t\tthrow new LARTypeException(\n\t\t\t\t\"Invalid type of LAR file (\" + larType + \")\");\n\t\t}\n\n\t\t// Import GroupId\n\n\t\tlong sourceGroupId = GetterUtil.getLong(\n\t\t\theader.attributeValue(\"group-id\"));\n\n\t\tcontext.setSourceGroupId(sourceGroupId);\n\n\t\t// Look and feel\n\n\t\tif (importTheme) {\n\t\t\tthemeZip = context.getZipEntryAsByteArray(\"theme.zip\");\n\t\t}\n\n\t\t// Look and feel\n\n\t\tString themeId = header.attributeValue(\"theme-id\");\n\t\tString colorSchemeId = header.attributeValue(\"color-scheme-id\");\n\n\t\tboolean useThemeZip = false;\n\n\t\tif (themeZip != null) {\n\t\t\ttry {\n\t\t\t\tString importThemeId = importTheme(layoutSet, themeZip);\n\n\t\t\t\tif (importThemeId != null) {\n\t\t\t\t\tthemeId = importThemeId;\n\t\t\t\t\tcolorSchemeId =\n\t\t\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\n\t\t\t\t\tuseThemeZip = true;\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Importing theme takes \" + stopWatch.getTime() + \" ms\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t}\n\n\t\tboolean wapTheme = false;\n\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroupId, privateLayout, themeId, colorSchemeId, StringPool.BLANK,\n\t\t\twapTheme);\n\n\t\t// Read categories, comments, ratings, and tags to make them available\n\t\t// to the data handlers through the context\n\n\t\tif (importCategories) {\n\t\t\timportCategories(context);\n\t\t}\n\n\t\t_portletImporter.readCategories(context, root);\n\t\t_portletImporter.readComments(context, root);\n\t\t_portletImporter.readRatings(context, root);\n\t\t_portletImporter.readTags(context, root);\n\n\t\t// Layouts\n\n\t\tList<Layout> previousLayouts = LayoutUtil.findByG_P(\n\t\t\tgroupId, privateLayout);\n\n\t\tSet<Long> newLayoutIds = new HashSet<Long>();\n\n\t\tMap<Long, Long> newLayoutIdPlidMap =\n\t\t\t(Map<Long, Long>)context.getNewPrimaryKeysMap(Layout.class);\n\n\t\tList<Element> layoutEls = root.element(\"layouts\").elements(\"layout\");\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (layoutEls.size() > 0) {\n\t\t\t\t_log.debug(\"Importing layouts\");\n\t\t\t}\n\t\t}\n\n\t\tfor (Element layoutRefEl : layoutEls) {\n\t\t\tlong layoutId = GetterUtil.getInteger(\n\t\t\t\tlayoutRefEl.attributeValue(\"layout-id\"));\n\n\t\t\tlong oldLayoutId = layoutId;\n\n\t\t\tString layoutPath = layoutRefEl.attributeValue(\"path\");\n\n\t\t\tElement layoutEl = null;\n\n\t\t\ttry {\n\t\t\t\tDocument layoutDoc = SAXReaderUtil.read(\n\t\t\t\t\tcontext.getZipEntryAsString(layoutPath));\n\n\t\t\t\tlayoutEl = layoutDoc.getRootElement();\n\t\t\t}\n\t\t\tcatch (DocumentException de) {\n\t\t\t\tthrow new SystemException(de);\n\t\t\t}\n\n\t\t\tlong parentLayoutId = GetterUtil.getInteger(\n\t\t\t\tlayoutEl.elementText(\"parent-layout-id\"));\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Importing layout with layout id \" + layoutId +\n\t\t\t\t\t\t\" and parent layout id \" + parentLayoutId);\n\t\t\t}\n\n\t\t\tlong oldPlid = GetterUtil.getInteger(\n\t\t\t\tlayoutEl.attributeValue(\"old-plid\"));\n\n\t\t\tString name = layoutEl.elementText(\"name\");\n\t\t\tString title = layoutEl.elementText(\"title\");\n\t\t\tString description = layoutEl.elementText(\"description\");\n\t\t\tString type = layoutEl.elementText(\"type\");\n\t\t\tString typeSettings = layoutEl.elementText(\"type-settings\");\n\t\t\tboolean hidden = GetterUtil.getBoolean(\n\t\t\t\tlayoutEl.elementText(\"hidden\"));\n\t\t\tString friendlyURL = layoutEl.elementText(\"friendly-url\");\n\t\t\tboolean iconImage = GetterUtil.getBoolean(\n\t\t\t\tlayoutEl.elementText(\"icon-image\"));\n\n\t\t\tbyte[] iconBytes = null;\n\n\t\t\tif (iconImage) {\n\t\t\t\tString path = layoutEl.elementText(\"icon-image-path\");\n\n\t\t\t\ticonBytes = context.getZipEntryAsByteArray(path);\n\t\t\t}\n\n\t\t\tif (useThemeZip) {\n\t\t\t\tthemeId = StringPool.BLANK;\n\t\t\t\tcolorSchemeId = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthemeId = layoutEl.elementText(\"theme-id\");\n\t\t\t\tcolorSchemeId = layoutEl.elementText(\"color-scheme-id\");\n\t\t\t}\n\n\t\t\tString wapThemeId = layoutEl.elementText(\"wap-theme-id\");\n\t\t\tString wapColorSchemeId = layoutEl.elementText(\n\t\t\t\t\"wap-color-scheme-id\");\n\t\t\tString css = layoutEl.elementText(\"css\");\n\t\t\tint priority = GetterUtil.getInteger(\n\t\t\t\tlayoutEl.elementText(\"priority\"));\n\n\t\t\tLayout layout = null;\n\n\t\t\tif (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_ADD_AS_NEW)) {\n\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t\tfriendlyURL = StringPool.SLASH + layoutId;\n\t\t\t}\n\t\t\telse if (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_NAME)) {\n\n\t\t\t\tLocale locale = LocaleUtil.getDefault();\n\n\t\t\t\tString localizedName = LocalizationUtil.getLocalization(\n\t\t\t\t\tname, LocaleUtil.toLanguageId(locale));\n\n\t\t\t\tfor (Layout curLayout : previousLayouts) {\n\t\t\t\t\tif (curLayout.getName(locale).equals(localizedName)) {\n\t\t\t\t\t\tlayout = curLayout;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayout = LayoutUtil.fetchByG_P_L(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tif (layout == null) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Layout with {groupId=\" + groupId + \",privateLayout=\" +\n\t\t\t\t\t\t\tprivateLayout + \",layoutId=\" + layoutId +\n\t\t\t\t\t\t\t\t\"} does not exist\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Layout with {groupId=\" + groupId + \",privateLayout=\" +\n\t\t\t\t\t\t\tprivateLayout + \",layoutId=\" + layoutId +\n\t\t\t\t\t\t\t\t\"} exists\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (layout == null) {\n\t\t\t\tlong plid = CounterLocalServiceUtil.increment();\n\n\t\t\t\tlayout = LayoutUtil.create(plid);\n\n\t\t\t\tlayout.setGroupId(groupId);\n\t\t\t\tlayout.setPrivateLayout(privateLayout);\n\t\t\t\tlayout.setLayoutId(layoutId);\n\t\t\t}\n\n\t\t\tlayout.setCompanyId(user.getCompanyId());\n\t\t\tlayout.setParentLayoutId(parentLayoutId);\n\t\t\tlayout.setName(name);\n\t\t\tlayout.setTitle(title);\n\t\t\tlayout.setDescription(description);\n\t\t\tlayout.setType(type);\n\n\t\t\tif (layout.getType().equals(LayoutConstants.TYPE_PORTLET) &&\n\t\t\t\t\tValidator.isNotNull(layout.getTypeSettings()) &&\n\t\t\t\t\t\t!portletsMergeMode.equals(\n\t\t\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\t\t\tPORTLETS_MERGE_MODE_REPLACE)) {\n\t\t\t\tmergePortlets(layout, typeSettings, portletsMergeMode);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayout.setTypeSettings(typeSettings);\n\t\t\t}\n\n\t\t\tlayout.setHidden(hidden);\n\t\t\tlayout.setFriendlyURL(friendlyURL);\n\n\t\t\tif (iconImage) {\n\t\t\t\tlayout.setIconImage(iconImage);\n\n\t\t\t\tif (layout.isNew()) {\n\t\t\t\t\tlong iconImageId = CounterLocalServiceUtil.increment();\n\n\t\t\t\t\tlayout.setIconImageId(iconImageId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlayout.setThemeId(themeId);\n\t\t\tlayout.setColorSchemeId(colorSchemeId);\n\t\t\tlayout.setWapThemeId(wapThemeId);\n\t\t\tlayout.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayout.setCss(css);\n\t\t\tlayout.setPriority(priority);\n\n\t\t\tfixTypeSettings(layout);\n\n\t\t\tLayoutUtil.update(layout, false);\n\n\t\t\tif ((iconBytes != null) && (iconBytes.length > 0)) {\n\t\t\t\tImageLocalServiceUtil.updateImage(\n\t\t\t\t\tlayout.getIconImageId(), iconBytes);\n\t\t\t}\n\n\t\t\tcontext.setPlid(layout.getPlid());\n\t\t\tcontext.setOldPlid(oldPlid);\n\n\t\t\tnewLayoutIdPlidMap.put(oldLayoutId, layout.getPlid());\n\n\t\t\tnewLayoutIds.add(layoutId);\n\n\t\t\tElement permissionsEl = layoutEl.element(\"permissions\");\n\n\t\t\t// Layout permissions\n\n\t\t\tif (importPermissions && (permissionsEl != null)) {\n\t\t\t\tString resourceName = Layout.class.getName();\n\t\t\t\tString resourcePrimKey = String.valueOf(layout.getPlid());\n\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\timportLayoutPermissions_5(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, userId, resourceName,\n\t\t\t\t\t\tresourcePrimKey, permissionsEl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportLayoutPermissions_4(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, guestGroup, layout,\n\t\t\t\t\t\tresourceName, resourcePrimKey, permissionsEl,\n\t\t\t\t\t\timportUserPermissions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_portletImporter.importPortletData(\n\t\t\t\tcontext, PortletKeys.LAYOUT_CONFIGURATION, null, layoutEl);\n\t\t}\n\n\t\tList<Element> portletEls = root.element(\"portlets\").elements(\"portlet\");\n\n\t\t// Delete portlet data\n\n\t\tif (deletePortletData) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tif (portletEls.size() > 0) {\n\t\t\t\t\t_log.debug(\"Deleting portlet data\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Element portletRefEl : portletEls) {\n\t\t\t\tString portletId = portletRefEl.attributeValue(\"portlet-id\");\n\t\t\t\tlong layoutId = GetterUtil.getLong(\n\t\t\t\t\tportletRefEl.attributeValue(\"layout-id\"));\n\t\t\t\tlong plid = newLayoutIdPlidMap.get(layoutId);\n\n\t\t\t\tcontext.setPlid(plid);\n\n\t\t\t\t_portletImporter.deletePortletData(context, portletId, plid);\n\t\t\t}\n\t\t}\n\n\t\t// Import portlets\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (portletEls.size() > 0) {\n\t\t\t\t_log.debug(\"Importing portlets\");\n\t\t\t}\n\t\t}\n\n\t\tfor (Element portletRefEl : portletEls) {\n\t\t\tString portletPath = portletRefEl.attributeValue(\"path\");\n\t\t\tString portletId = portletRefEl.attributeValue(\"portlet-id\");\n\t\t\tlong layoutId = GetterUtil.getLong(\n\t\t\t\tportletRefEl.attributeValue(\"layout-id\"));\n\t\t\tlong plid = newLayoutIdPlidMap.get(layoutId);\n\t\t\tlong oldPlid = GetterUtil.getLong(\n\t\t\t\tportletRefEl.attributeValue(\"old-plid\"));\n\n\t\t\tLayout layout = LayoutUtil.findByPrimaryKey(plid);\n\n\t\t\tcontext.setPlid(plid);\n\t\t\tcontext.setOldPlid(oldPlid);\n\n\t\t\tElement portletEl = null;\n\n\t\t\ttry {\n\t\t\t\tDocument portletDoc = SAXReaderUtil.read(\n\t\t\t\t\tcontext.getZipEntryAsString(portletPath));\n\n\t\t\t\tportletEl = portletDoc.getRootElement();\n\t\t\t}\n\t\t\tcatch (DocumentException de) {\n\t\t\t\tthrow new SystemException(de);\n\t\t\t}\n\n\t\t\t// The order of the import is important. You must always import\n\t\t\t// the portlet preferences first, then the portlet data, then\n\t\t\t// the portlet permissions. The import of the portlet data\n\t\t\t// assumes that portlet preferences already exist.\n\n\t\t\t// Portlet preferences\n\n\t\t\t_portletImporter.importPortletPreferences(\n\t\t\t\tcontext, layoutSet.getCompanyId(), layout.getGroupId(),\n\t\t\t\tlayout, null, portletEl, importPortletSetup,\n\t\t\t\timportPortletArchivedSetups, importPortletUserPreferences,\n\t\t\t\tfalse);\n\n\t\t\t// Portlet data\n\n\t\t\tElement portletDataEl = portletEl.element(\"portlet-data\");\n\n\t\t\tif (importPortletData && portletDataEl != null) {\n\t\t\t\t_portletImporter.importPortletData(\n\t\t\t\t\tcontext, portletId, plid, portletDataEl);\n\t\t\t}\n\n\t\t\t// Portlet permissions\n\n\t\t\tElement permissionsEl = portletEl.element(\"permissions\");\n\n\t\t\tif (importPermissions && (permissionsEl != null)) {\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\tString resourceName = PortletConstants.getRootPortletId(\n\t\t\t\t\t\tportletId);\n\n\t\t\t\t\tString resourcePrimKey =\n\t\t\t\t\t\tPortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\t\tlayout.getPlid(), portletId);\n\n\t\t\t\t\timportPortletPermissions_5(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, userId, resourceName,\n\t\t\t\t\t\tresourcePrimKey, permissionsEl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportPortletPermissions_4(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, guestGroup, layout,\n\t\t\t\t\t\tpermissionsEl, importUserPermissions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Archived setups\n\n\t\t\t_portletImporter.importPortletPreferences(\n\t\t\t\tcontext, layoutSet.getCompanyId(), groupId, null, null,\n\t\t\t\tportletEl, importPortletSetup, importPortletArchivedSetups,\n\t\t\t\timportPortletUserPreferences, false);\n\n\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM != 5) {\n\n\t\t\t\t// Portlet roles\n\n\t\t\t\tElement rolesEl = portletEl.element(\"roles\");\n\n\t\t\t\tif (importPermissions && (rolesEl != null)) {\n\t\t\t\t\timportPortletRoles(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, portletEl);\n\n\t\t\t\t\timportPortletRoles(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, portletId, rolesEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM != 5) {\n\t\t\tElement rolesEl = root.element(\"roles\");\n\n\t\t\t// Layout roles\n\n\t\t\tif (importPermissions) {\n\t\t\t\timportLayoutRoles(layoutCache, companyId, groupId, rolesEl);\n\t\t\t}\n\t\t}\n\n\t\t// Delete missing layouts\n\n\t\tif (deleteMissingLayouts) {\n\t\t\tdeleteMissingLayouts(\n\t\t\t\tgroupId, privateLayout, newLayoutIds, previousLayouts);\n\t\t}\n\n\t\t// Page count\n\n\t\tLayoutSetLocalServiceUtil.updatePageCount(groupId, privateLayout);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Importing layouts takes \" + stopWatch.getTime() + \" ms\");\n\t\t}\n\t}","id":24332,"modified_method":"public void importLayouts(\n\t\t\tlong userId, long groupId, boolean privateLayout,\n\t\t\tMap<String, String[]> parameterMap, InputStream is)\n\t\tthrows PortalException, SystemException {\n\n\t\tboolean deleteMissingLayouts = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.DELETE_MISSING_LAYOUTS,\n\t\t\tBoolean.TRUE.booleanValue());\n\t\tboolean deletePortletData = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.DELETE_PORTLET_DATA);\n\t\tboolean importCategories = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.CATEGORIES);\n\t\tboolean importPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PERMISSIONS);\n\t\tboolean importUserPermissions = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PERMISSIONS);\n\t\tboolean importPortletData = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_DATA);\n\t\tboolean importPortletSetup = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_SETUP);\n\t\tboolean importPortletArchivedSetups = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_ARCHIVED_SETUPS);\n\t\tboolean importPortletUserPreferences = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLET_USER_PREFERENCES);\n\t\tboolean importTheme = MapUtil.getBoolean(\n\t\t\tparameterMap, PortletDataHandlerKeys.THEME);\n\t\tString layoutsImportMode = MapUtil.getString(\n\t\t\tparameterMap, PortletDataHandlerKeys.LAYOUTS_IMPORT_MODE,\n\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_ID);\n\t\tString portletsMergeMode = MapUtil.getString(\n\t\t\tparameterMap, PortletDataHandlerKeys.PORTLETS_MERGE_MODE,\n\t\t\tPortletDataHandlerKeys.PORTLETS_MERGE_MODE_REPLACE);\n\t\tString userIdStrategy = MapUtil.getString(\n\t\t\tparameterMap, PortletDataHandlerKeys.USER_ID_STRATEGY);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Delete portlet data \" + deletePortletData);\n\t\t\t_log.debug(\"Import categories \" + importCategories);\n\t\t\t_log.debug(\"Import permissions \" + importPermissions);\n\t\t\t_log.debug(\"Import user permissions \" + importUserPermissions);\n\t\t\t_log.debug(\"Import portlet data \" + importPortletData);\n\t\t\t_log.debug(\"Import portlet setup \" + importPortletSetup);\n\t\t\t_log.debug(\n\t\t\t\t\"Import portlet archived setups \" +\n\t\t\t\t\timportPortletArchivedSetups);\n\t\t\t_log.debug(\n\t\t\t\t\"Import portlet user preferences \" +\n\t\t\t\t\timportPortletUserPreferences);\n\t\t\t_log.debug(\"Import theme \" + importTheme);\n\t\t}\n\n\t\tStopWatch stopWatch = null;\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\tstopWatch = new StopWatch();\n\n\t\t\tstopWatch.start();\n\t\t}\n\n\t\tLayoutCache layoutCache = new LayoutCache();\n\n\t\tLayoutSet layoutSet = LayoutSetLocalServiceUtil.getLayoutSet(\n\t\t\tgroupId, privateLayout);\n\n\t\tlong companyId = layoutSet.getCompanyId();\n\n\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\n\t\tUserIdStrategy strategy = _portletImporter.getUserIdStrategy(\n\t\t\tuser, userIdStrategy);\n\n\t\tZipReader zipReader = new ZipReader(is);\n\n\t\tPortletDataContext context = new PortletDataContextImpl(\n\t\t\tcompanyId, groupId, parameterMap, new HashSet<String>(), strategy,\n\t\t\tzipReader);\n\n\t\tcontext.setPrivateLayout(privateLayout);\n\n\t\tGroup guestGroup = GroupLocalServiceUtil.getGroup(\n\t\t\tcompanyId, GroupConstants.GUEST);\n\n\t\t// Zip\n\n\t\tElement root = null;\n\t\tbyte[] themeZip = null;\n\n\t\t// Manifest\n\n\t\tString xml = context.getZipEntryAsString(\"/manifest.xml\");\n\n\t\tif (xml == null) {\n\t\t\tthrow new LARFileException(\"manifest.xml not found in the LAR\");\n\t\t}\n\n\t\ttry {\n\t\t\tDocument doc = SAXReaderUtil.read(xml);\n\n\t\t\troot = doc.getRootElement();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new LARFileException(e);\n\t\t}\n\n\t\t// Build compatibility\n\n\t\tElement header = root.element(\"header\");\n\n\t\tint buildNumber = ReleaseInfo.getBuildNumber();\n\n\t\tint importBuildNumber = GetterUtil.getInteger(\n\t\t\theader.attributeValue(\"build-number\"));\n\n\t\tif (buildNumber != importBuildNumber) {\n\t\t\tthrow new LayoutImportException(\n\t\t\t\t\"LAR build number \" + importBuildNumber + \" does not match \" +\n\t\t\t\t\t\"portal build number \" + buildNumber);\n\t\t}\n\n\t\t// Type compatibility\n\n\t\tString larType = header.attributeValue(\"type\");\n\n\t\tif (!larType.equals(\"layout-set\")) {\n\t\t\tthrow new LARTypeException(\n\t\t\t\t\"Invalid type of LAR file (\" + larType + \")\");\n\t\t}\n\n\t\t// Import GroupId\n\n\t\tlong sourceGroupId = GetterUtil.getLong(\n\t\t\theader.attributeValue(\"group-id\"));\n\n\t\tcontext.setSourceGroupId(sourceGroupId);\n\n\t\t// Look and feel\n\n\t\tif (importTheme) {\n\t\t\tthemeZip = context.getZipEntryAsByteArray(\"theme.zip\");\n\t\t}\n\n\t\t// Look and feel\n\n\t\tString themeId = header.attributeValue(\"theme-id\");\n\t\tString colorSchemeId = header.attributeValue(\"color-scheme-id\");\n\n\t\tboolean useThemeZip = false;\n\n\t\tif (themeZip != null) {\n\t\t\ttry {\n\t\t\t\tString importThemeId = importTheme(layoutSet, themeZip);\n\n\t\t\t\tif (importThemeId != null) {\n\t\t\t\t\tthemeId = importThemeId;\n\t\t\t\t\tcolorSchemeId =\n\t\t\t\t\t\tColorSchemeImpl.getDefaultRegularColorSchemeId();\n\n\t\t\t\t\tuseThemeZip = true;\n\t\t\t\t}\n\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Importing theme takes \" + stopWatch.getTime() + \" ms\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tthrow new SystemException(e);\n\t\t\t}\n\t\t}\n\n\t\tboolean wapTheme = false;\n\n\t\tLayoutSetLocalServiceUtil.updateLookAndFeel(\n\t\t\tgroupId, privateLayout, themeId, colorSchemeId, StringPool.BLANK,\n\t\t\twapTheme);\n\n\t\t// Read categories, comments, ratings, and tags to make them available\n\t\t// to the data handlers through the context\n\n\t\tif (importCategories) {\n\t\t\timportCategories(context);\n\t\t}\n\n\t\t_portletImporter.readCategories(context, root);\n\t\t_portletImporter.readComments(context, root);\n\t\t_portletImporter.readRatings(context, root);\n\t\t_portletImporter.readTags(context, root);\n\n\t\t// Layouts\n\n\t\tList<Layout> previousLayouts = LayoutUtil.findByG_P(\n\t\t\tgroupId, privateLayout);\n\n\t\tSet<Long> newLayoutIds = new HashSet<Long>();\n\n\t\tMap<Long, Long> newLayoutIdPlidMap =\n\t\t\t(Map<Long, Long>)context.getNewPrimaryKeysMap(Layout.class);\n\n\t\tList<Element> layoutEls = root.element(\"layouts\").elements(\"layout\");\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (layoutEls.size() > 0) {\n\t\t\t\t_log.debug(\"Importing layouts\");\n\t\t\t}\n\t\t}\n\n\t\tfor (Element layoutRefEl : layoutEls) {\n\t\t\tlong layoutId = GetterUtil.getInteger(\n\t\t\t\tlayoutRefEl.attributeValue(\"layout-id\"));\n\n\t\t\tlong oldLayoutId = layoutId;\n\n\t\t\tString layoutPath = layoutRefEl.attributeValue(\"path\");\n\n\t\t\tElement layoutEl = null;\n\n\t\t\ttry {\n\t\t\t\tDocument layoutDoc = SAXReaderUtil.read(\n\t\t\t\t\tcontext.getZipEntryAsString(layoutPath));\n\n\t\t\t\tlayoutEl = layoutDoc.getRootElement();\n\t\t\t}\n\t\t\tcatch (DocumentException de) {\n\t\t\t\tthrow new SystemException(de);\n\t\t\t}\n\n\t\t\tlong parentLayoutId = GetterUtil.getInteger(\n\t\t\t\tlayoutEl.elementText(\"parent-layout-id\"));\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Importing layout with layout id \" + layoutId +\n\t\t\t\t\t\t\" and parent layout id \" + parentLayoutId);\n\t\t\t}\n\n\t\t\tlong oldPlid = GetterUtil.getInteger(\n\t\t\t\tlayoutEl.attributeValue(\"old-plid\"));\n\n\t\t\tString name = layoutEl.elementText(\"name\");\n\t\t\tString title = layoutEl.elementText(\"title\");\n\t\t\tString description = layoutEl.elementText(\"description\");\n\t\t\tString type = layoutEl.elementText(\"type\");\n\t\t\tString typeSettings = layoutEl.elementText(\"type-settings\");\n\t\t\tboolean hidden = GetterUtil.getBoolean(\n\t\t\t\tlayoutEl.elementText(\"hidden\"));\n\t\t\tString friendlyURL = layoutEl.elementText(\"friendly-url\");\n\t\t\tboolean iconImage = GetterUtil.getBoolean(\n\t\t\t\tlayoutEl.elementText(\"icon-image\"));\n\n\t\t\tbyte[] iconBytes = null;\n\n\t\t\tif (iconImage) {\n\t\t\t\tString path = layoutEl.elementText(\"icon-image-path\");\n\n\t\t\t\ticonBytes = context.getZipEntryAsByteArray(path);\n\t\t\t}\n\n\t\t\tif (useThemeZip) {\n\t\t\t\tthemeId = StringPool.BLANK;\n\t\t\t\tcolorSchemeId = StringPool.BLANK;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthemeId = layoutEl.elementText(\"theme-id\");\n\t\t\t\tcolorSchemeId = layoutEl.elementText(\"color-scheme-id\");\n\t\t\t}\n\n\t\t\tString wapThemeId = layoutEl.elementText(\"wap-theme-id\");\n\t\t\tString wapColorSchemeId = layoutEl.elementText(\n\t\t\t\t\"wap-color-scheme-id\");\n\t\t\tString css = layoutEl.elementText(\"css\");\n\t\t\tint priority = GetterUtil.getInteger(\n\t\t\t\tlayoutEl.elementText(\"priority\"));\n\n\t\t\tLayout layout = null;\n\n\t\t\tif (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.LAYOUTS_IMPORT_MODE_ADD_AS_NEW)) {\n\n\t\t\t\tlayoutId = LayoutLocalServiceUtil.getNextLayoutId(\n\t\t\t\t\tgroupId, privateLayout);\n\t\t\t\tfriendlyURL = StringPool.SLASH + layoutId;\n\t\t\t}\n\t\t\telse if (layoutsImportMode.equals(\n\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\tLAYOUTS_IMPORT_MODE_MERGE_BY_LAYOUT_NAME)) {\n\n\t\t\t\tLocale locale = LocaleUtil.getDefault();\n\n\t\t\t\tString localizedName = LocalizationUtil.getLocalization(\n\t\t\t\t\tname, LocaleUtil.toLanguageId(locale));\n\n\t\t\t\tfor (Layout curLayout : previousLayouts) {\n\t\t\t\t\tif (curLayout.getName(locale).equals(localizedName)) {\n\t\t\t\t\t\tlayout = curLayout;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayout = LayoutUtil.fetchByG_P_L(\n\t\t\t\t\tgroupId, privateLayout, layoutId);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tif (layout == null) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Layout with {groupId=\" + groupId + \",privateLayout=\" +\n\t\t\t\t\t\t\tprivateLayout + \",layoutId=\" + layoutId +\n\t\t\t\t\t\t\t\t\"} does not exist\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Layout with {groupId=\" + groupId + \",privateLayout=\" +\n\t\t\t\t\t\t\tprivateLayout + \",layoutId=\" + layoutId +\n\t\t\t\t\t\t\t\t\"} exists\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (layout == null) {\n\t\t\t\tlong plid = CounterLocalServiceUtil.increment();\n\n\t\t\t\tlayout = LayoutUtil.create(plid);\n\n\t\t\t\tlayout.setGroupId(groupId);\n\t\t\t\tlayout.setPrivateLayout(privateLayout);\n\t\t\t\tlayout.setLayoutId(layoutId);\n\t\t\t}\n\n\t\t\tlayout.setCompanyId(user.getCompanyId());\n\t\t\tlayout.setParentLayoutId(parentLayoutId);\n\t\t\tlayout.setName(name);\n\t\t\tlayout.setTitle(title);\n\t\t\tlayout.setDescription(description);\n\t\t\tlayout.setType(type);\n\n\t\t\tif (layout.getType().equals(LayoutConstants.TYPE_PORTLET) &&\n\t\t\t\t\tValidator.isNotNull(layout.getTypeSettings()) &&\n\t\t\t\t\t\t!portletsMergeMode.equals(\n\t\t\t\t\t\t\tPortletDataHandlerKeys.\n\t\t\t\t\t\t\t\tPORTLETS_MERGE_MODE_REPLACE)) {\n\t\t\t\tmergePortlets(layout, typeSettings, portletsMergeMode);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlayout.setTypeSettings(typeSettings);\n\t\t\t}\n\n\t\t\tlayout.setHidden(hidden);\n\t\t\tlayout.setFriendlyURL(friendlyURL);\n\n\t\t\tif (iconImage) {\n\t\t\t\tlayout.setIconImage(iconImage);\n\n\t\t\t\tif (layout.isNew()) {\n\t\t\t\t\tlong iconImageId = CounterLocalServiceUtil.increment();\n\n\t\t\t\t\tlayout.setIconImageId(iconImageId);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlayout.setThemeId(themeId);\n\t\t\tlayout.setColorSchemeId(colorSchemeId);\n\t\t\tlayout.setWapThemeId(wapThemeId);\n\t\t\tlayout.setWapColorSchemeId(wapColorSchemeId);\n\t\t\tlayout.setCss(css);\n\t\t\tlayout.setPriority(priority);\n\n\t\t\tfixTypeSettings(layout);\n\n\t\t\tLayoutUtil.update(layout, false);\n\n\t\t\tif ((iconBytes != null) && (iconBytes.length > 0)) {\n\t\t\t\tImageLocalServiceUtil.updateImage(\n\t\t\t\t\tlayout.getIconImageId(), iconBytes);\n\t\t\t}\n\n\t\t\tcontext.setPlid(layout.getPlid());\n\t\t\tcontext.setOldPlid(oldPlid);\n\n\t\t\tnewLayoutIdPlidMap.put(oldLayoutId, layout.getPlid());\n\n\t\t\tnewLayoutIds.add(layoutId);\n\n\t\t\tElement permissionsEl = layoutEl.element(\"permissions\");\n\n\t\t\t// Layout permissions\n\n\t\t\tif (importPermissions && (permissionsEl != null)) {\n\t\t\t\tString resourceName = Layout.class.getName();\n\t\t\t\tString resourcePrimKey = String.valueOf(layout.getPlid());\n\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\timportLayoutPermissions_5(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, userId, resourceName,\n\t\t\t\t\t\tresourcePrimKey, permissionsEl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportLayoutPermissions_4(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, guestGroup, layout,\n\t\t\t\t\t\tresourceName, resourcePrimKey, permissionsEl,\n\t\t\t\t\t\timportUserPermissions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_portletImporter.importPortletData(\n\t\t\t\tcontext, PortletKeys.LAYOUT_CONFIGURATION, null, layoutEl);\n\t\t}\n\n\t\tList<Element> portletEls = root.element(\"portlets\").elements(\"portlet\");\n\n\t\t// Delete portlet data\n\n\t\tif (deletePortletData) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\tif (portletEls.size() > 0) {\n\t\t\t\t\t_log.debug(\"Deleting portlet data\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Element portletRefEl : portletEls) {\n\t\t\t\tString portletId = portletRefEl.attributeValue(\"portlet-id\");\n\t\t\t\tlong layoutId = GetterUtil.getLong(\n\t\t\t\t\tportletRefEl.attributeValue(\"layout-id\"));\n\t\t\t\tlong plid = newLayoutIdPlidMap.get(layoutId);\n\n\t\t\t\tcontext.setPlid(plid);\n\n\t\t\t\t_portletImporter.deletePortletData(context, portletId, plid);\n\t\t\t}\n\t\t}\n\n\t\t// Import portlets\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tif (portletEls.size() > 0) {\n\t\t\t\t_log.debug(\"Importing portlets\");\n\t\t\t}\n\t\t}\n\n\t\tfor (Element portletRefEl : portletEls) {\n\t\t\tString portletPath = portletRefEl.attributeValue(\"path\");\n\t\t\tString portletId = portletRefEl.attributeValue(\"portlet-id\");\n\t\t\tlong layoutId = GetterUtil.getLong(\n\t\t\t\tportletRefEl.attributeValue(\"layout-id\"));\n\t\t\tlong plid = newLayoutIdPlidMap.get(layoutId);\n\t\t\tlong oldPlid = GetterUtil.getLong(\n\t\t\t\tportletRefEl.attributeValue(\"old-plid\"));\n\n\t\t\tLayout layout = LayoutUtil.findByPrimaryKey(plid);\n\n\t\t\tcontext.setPlid(plid);\n\t\t\tcontext.setOldPlid(oldPlid);\n\n\t\t\tElement portletEl = null;\n\n\t\t\ttry {\n\t\t\t\tDocument portletDoc = SAXReaderUtil.read(\n\t\t\t\t\tcontext.getZipEntryAsString(portletPath));\n\n\t\t\t\tportletEl = portletDoc.getRootElement();\n\t\t\t}\n\t\t\tcatch (DocumentException de) {\n\t\t\t\tthrow new SystemException(de);\n\t\t\t}\n\n\t\t\t// The order of the import is important. You must always import\n\t\t\t// the portlet preferences first, then the portlet data, then\n\t\t\t// the portlet permissions. The import of the portlet data\n\t\t\t// assumes that portlet preferences already exist.\n\n\t\t\t// Portlet preferences\n\n\t\t\t_portletImporter.importPortletPreferences(\n\t\t\t\tcontext, layoutSet.getCompanyId(), layout.getGroupId(),\n\t\t\t\tlayout, null, portletEl, importPortletSetup,\n\t\t\t\timportPortletArchivedSetups, importPortletUserPreferences,\n\t\t\t\tfalse);\n\n\t\t\t// Portlet data scope\n\n\t\t\tlong scopeLayoutId = GetterUtil.getLong(\n\t\t\t\tportletEl.attributeValue(\"scope-layout-id\"));\n\n\t\t\tif (scopeLayoutId > 0) {\n\t\t\t\tcontext.setScopeLayoutId(scopeLayoutId);\n\t\t\t}\n\n\t\t\t// Portlet data\n\n\t\t\tElement portletDataEl = portletEl.element(\"portlet-data\");\n\n\t\t\tif (importPortletData && portletDataEl != null) {\n\t\t\t\t_portletImporter.importPortletData(\n\t\t\t\t\tcontext, portletId, plid, portletDataEl);\n\t\t\t}\n\n\t\t\t// Portlet permissions\n\n\t\t\tElement permissionsEl = portletEl.element(\"permissions\");\n\n\t\t\tif (importPermissions && (permissionsEl != null)) {\n\t\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM == 5) {\n\t\t\t\t\tString resourceName = PortletConstants.getRootPortletId(\n\t\t\t\t\t\tportletId);\n\n\t\t\t\t\tString resourcePrimKey =\n\t\t\t\t\t\tPortletPermissionUtil.getPrimaryKey(\n\t\t\t\t\t\t\tlayout.getPlid(), portletId);\n\n\t\t\t\t\timportPortletPermissions_5(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, userId, resourceName,\n\t\t\t\t\t\tresourcePrimKey, permissionsEl);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportPortletPermissions_4(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, guestGroup, layout,\n\t\t\t\t\t\tpermissionsEl, importUserPermissions);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Archived setups\n\n\t\t\t_portletImporter.importPortletPreferences(\n\t\t\t\tcontext, layoutSet.getCompanyId(), groupId, null, null,\n\t\t\t\tportletEl, importPortletSetup, importPortletArchivedSetups,\n\t\t\t\timportPortletUserPreferences, false);\n\n\t\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM != 5) {\n\n\t\t\t\t// Portlet roles\n\n\t\t\t\tElement rolesEl = portletEl.element(\"roles\");\n\n\t\t\t\tif (importPermissions && (rolesEl != null)) {\n\t\t\t\t\timportPortletRoles(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, portletEl);\n\n\t\t\t\t\timportPortletRoles(\n\t\t\t\t\t\tlayoutCache, companyId, groupId, portletId, rolesEl);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (PropsValues.PERMISSIONS_USER_CHECK_ALGORITHM != 5) {\n\t\t\tElement rolesEl = root.element(\"roles\");\n\n\t\t\t// Layout roles\n\n\t\t\tif (importPermissions) {\n\t\t\t\timportLayoutRoles(layoutCache, companyId, groupId, rolesEl);\n\t\t\t}\n\t\t}\n\n\t\t// Delete missing layouts\n\n\t\tif (deleteMissingLayouts) {\n\t\t\tdeleteMissingLayouts(\n\t\t\t\tgroupId, privateLayout, newLayoutIds, previousLayouts);\n\t\t}\n\n\t\t// Page count\n\n\t\tLayoutSetLocalServiceUtil.updatePageCount(groupId, privateLayout);\n\n\t\tif (_log.isInfoEnabled()) {\n\t\t\t_log.info(\"Importing layouts takes \" + stopWatch.getTime() + \" ms\");\n\t\t}\n\t}","commit_id":"4b28ddaa36404bd7485899ff8d888fe45ffe6a84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String importPortletData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences portletPreferences, Element portletDataRefEl)\n\t\tthrows SystemException {\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tcontext.getCompanyId(), portletId);\n\n\t\tif (portlet == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not import portlet data for \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not exist\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString portletDataHandlerClass =\n\t\t\tportlet.getPortletDataHandlerClass();\n\n\t\tif (Validator.isNull(portletDataHandlerClass)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not import portlet data for \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not have a \" +\n\t\t\t\t\t\t\t\"PortletDataHandler\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Importing data for \" + portletId);\n\t\t}\n\n\t\t// Layout scope\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tlong scopeLayoutId = context.getScopeLayoutId();\n\n\t\tif (scopeLayoutId == 0) {\n\t\t\tscopeLayoutId = GetterUtil.getLong(\n\t\t\t\tportletDataRefEl.getParent().attributeValue(\"scope-layout-id\"));\n\t\t}\n\n\t\tif (scopeLayoutId > 0) {\n\t\t\ttry {\n\t\t\t\tLayout scopeLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tcontext.getGroupId(), context.isPrivateLayout(),\n\t\t\t\t\tscopeLayoutId);\n\n\t\t\t\tif (scopeLayout.hasScopeGroup()) {\n\t\t\t\t\tGroup scopeGroup = scopeLayout.getScopeGroup();\n\n\t\t\t\t\tcontext.setGroupId(scopeGroup.getGroupId());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t}\n\t\t}\n\n\t\tPortletPreferencesImpl preferencesImpl = null;\n\n\t\tif (portletPreferences != null) {\n\t\t\tpreferencesImpl = (PortletPreferencesImpl)\n\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\tportletPreferences.getPreferences());\n\t\t}\n\n\t\tString portletData = context.getZipEntryAsString(\n\t\t\tportletDataRefEl.attributeValue(\"path\"));\n\n\t\ttry {\n\t\t\tpreferencesImpl =\n\t\t\t\t(PortletPreferencesImpl)PortletClassInvoker.invoke(\n\t\t\t\t\tportletId, portletDataHandlerClass, \"importData\", context,\n\t\t\t\t\tportletId, preferencesImpl, portletData);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcontext.setGroupId(groupId);\n\t\t}\n\n\t\tif (preferencesImpl == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn PortletPreferencesSerializer.toXML(preferencesImpl);\n\t}","id":24333,"modified_method":"protected String importPortletData(\n\t\t\tPortletDataContext context, String portletId,\n\t\t\tPortletPreferences portletPreferences, Element portletDataRefEl)\n\t\tthrows SystemException {\n\n\t\tPortlet portlet = PortletLocalServiceUtil.getPortletById(\n\t\t\tcontext.getCompanyId(), portletId);\n\n\t\tif (portlet == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not import portlet data for \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not exist\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tString portletDataHandlerClass =\n\t\t\tportlet.getPortletDataHandlerClass();\n\n\t\tif (Validator.isNull(portletDataHandlerClass)) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Do not import portlet data for \" + portletId +\n\t\t\t\t\t\t\" because the portlet does not have a \" +\n\t\t\t\t\t\t\t\"PortletDataHandler\");\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Importing data for \" + portletId);\n\t\t}\n\n\t\t// Layout scope\n\n\t\tlong groupId = context.getGroupId();\n\n\t\tlong scopeLayoutId = context.getScopeLayoutId();\n\n\t\tif (scopeLayoutId == 0) {\n\t\t\tscopeLayoutId = GetterUtil.getLong(\n\t\t\t\tportletDataRefEl.getParent().attributeValue(\"scope-layout-id\"));\n\t\t}\n\n\t\tif (scopeLayoutId > 0) {\n\t\t\ttry {\n\t\t\t\tLayout scopeLayout = LayoutLocalServiceUtil.getLayout(\n\t\t\t\t\tcontext.getGroupId(), context.isPrivateLayout(),\n\t\t\t\t\tscopeLayoutId);\n\n\t\t\t\tGroup scopeGroup;\n\n\t\t\t\tif (scopeLayout.hasScopeGroup()) {\n\t\t\t\t\tscopeGroup = scopeLayout.getScopeGroup();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString name = String.valueOf(scopeLayout.getPlid());\n\n\t\t\t\t\tscopeGroup = GroupLocalServiceUtil.addGroup(\n\t\t\t\t\t\tcontext.getUserId(null), Layout.class.getName(),\n\t\t\t\t\t\tscopeLayout.getPlid(), name, null, 0, null, true);\n\t\t\t\t}\n\n\t\t\t\tcontext.setGroupId(scopeGroup.getGroupId());\n\t\t\t}\n\t\t\tcatch (PortalException pe) {\n\t\t\t}\n\t\t}\n\n\t\tPortletPreferencesImpl preferencesImpl = null;\n\n\t\tif (portletPreferences != null) {\n\t\t\tpreferencesImpl = (PortletPreferencesImpl)\n\t\t\t\tPortletPreferencesSerializer.fromDefaultXML(\n\t\t\t\t\tportletPreferences.getPreferences());\n\t\t}\n\n\t\tString portletData = context.getZipEntryAsString(\n\t\t\tportletDataRefEl.attributeValue(\"path\"));\n\n\t\ttry {\n\t\t\tpreferencesImpl =\n\t\t\t\t(PortletPreferencesImpl)PortletClassInvoker.invoke(\n\t\t\t\t\tportletId, portletDataHandlerClass, \"importData\", context,\n\t\t\t\t\tportletId, preferencesImpl, portletData);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcontext.setGroupId(groupId);\n\t\t}\n\n\t\tif (preferencesImpl == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn PortletPreferencesSerializer.toXML(preferencesImpl);\n\t}","commit_id":"4b28ddaa36404bd7485899ff8d888fe45ffe6a84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importPortletData(\n\t\t\tPortletDataContext context, String portletId, long plid,\n\t\t\tElement portletDataRefEl)\n\t\tthrows SystemException {\n\n\t\ttry {\n\t\t\tlong ownerId = PortletKeys. PREFS_OWNER_ID_DEFAULT;\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_LAYOUT;\n\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tPortletPreferencesUtil.findByO_O_P_P(\n\t\t\t\t\townerId, ownerType, plid, portletId);\n\n\t\t\tString xml = importPortletData(\n\t\t\t\tcontext, portletId, portletPreferences, portletDataRefEl);\n\n\t\t\tif (xml != null) {\n\t\t\t\tPortletPreferencesLocalServiceUtil.updatePreferences(\n\t\t\t\t\townerId, ownerType, plid, portletId, xml);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchPortletPreferencesException nsppe) {\n\t\t}\n\t}","id":24334,"modified_method":"protected void importPortletData(\n\t\t\tPortletDataContext context, String portletId, long plid,\n\t\t\tElement portletDataRefEl)\n\t\tthrows SystemException {\n\n\t\tlong ownerId = PortletKeys. PREFS_OWNER_ID_DEFAULT;\n\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_LAYOUT;\n\n\t\tPortletPreferences portletPreferences = null;\n\n\t\ttry {\n\t\t\tportletPreferences = PortletPreferencesUtil.findByO_O_P_P(\n\t\t\t\townerId, ownerType, plid, portletId);\n\t\t}\n\t\tcatch (NoSuchPortletPreferencesException nsppe) {\n\t\t\tportletPreferences =\n\t\t\t\tnew com.liferay.portal.model.impl.PortletPreferencesImpl();\n\t\t}\n\n\t\tString xml = importPortletData(\n\t\t\tcontext, portletId, portletPreferences, portletDataRefEl);\n\n\t\tif (xml != null) {\n\t\t\tPortletPreferencesLocalServiceUtil.updatePreferences(\n\t\t\t\townerId, ownerType, plid, portletId, xml);\n\t\t}\n\t}","commit_id":"4b28ddaa36404bd7485899ff8d888fe45ffe6a84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deletePortletData(\n\t\t\tPortletDataContext context, String portletId, long plid)\n\t\tthrows SystemException {\n\n\t\ttry {\n\t\t\tlong ownerId = PortletKeys.PREFS_OWNER_ID_DEFAULT;\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_LAYOUT;\n\n\t\t\tPortletPreferences portletPreferences =\n\t\t\t\tPortletPreferencesUtil.findByO_O_P_P(\n\t\t\t\t\townerId, ownerType, plid, portletId);\n\n\t\t\tString xml = deletePortletData(\n\t\t\t\tcontext, portletId, portletPreferences);\n\n\t\t\tif (xml != null) {\n\t\t\t\tPortletPreferencesLocalServiceUtil.updatePreferences(\n\t\t\t\t\townerId, ownerType, plid, portletId, xml);\n\t\t\t}\n\t\t}\n\t\tcatch (NoSuchPortletPreferencesException nsppe) {\n\t\t}\n\t}","id":24335,"modified_method":"protected void deletePortletData(\n\t\t\tPortletDataContext context, String portletId, long plid)\n\t\tthrows SystemException {\n\n\t\tlong ownerId = PortletKeys.PREFS_OWNER_ID_DEFAULT;\n\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_LAYOUT;\n\n\t\tPortletPreferences portletPreferences = null;\n\n\t\ttry {\n\t\t\tportletPreferences = PortletPreferencesUtil.findByO_O_P_P(\n\t\t\t\townerId, ownerType, plid, portletId);\n\t\t}\n\t\tcatch (NoSuchPortletPreferencesException nsppe) {\n\t\t\tportletPreferences =\n\t\t\t\tnew com.liferay.portal.model.impl.PortletPreferencesImpl();\n\t\t}\n\n\t\tString xml = deletePortletData(\n\t\t\tcontext, portletId, portletPreferences);\n\n\t\tif (xml != null) {\n\t\t\tPortletPreferencesLocalServiceUtil.updatePreferences(\n\t\t\t\townerId, ownerType, plid, portletId, xml);\n\t\t}\n\t}","commit_id":"4b28ddaa36404bd7485899ff8d888fe45ffe6a84","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tGroup group = GroupLocalServiceUtil.fetchGroup(groupId);\n\n\t\tif (group == null) {\n\t\t\tgroup = (Group)request.getAttribute(WebKeys.GROUP);\n\t\t}\n\n\t\tif (group == null) {\n\t\t\tgroup = themeDisplay.getScopeGroup();\n\t\t}\n\n\t\tif (group == null) {\n\t\t\treturn SKIP_BODY;\n\t\t}\n\n\t\tGroup liveGroup = StagingUtil.getLiveGroup(group.getGroupId());\n\t\tGroup stagingGroup = StagingUtil.getStagingGroup(group.getGroupId());\n\n\t\tpageContext.setAttribute(\"group\", group);\n\t\tpageContext.setAttribute(\"groupId\", group.getGroupId());\n\t\tpageContext.setAttribute(\"liveGroup\", liveGroup);\n\t\tpageContext.setAttribute(\"liveGroupId\", liveGroup.getGroupId());\n\t\tpageContext.setAttribute(\n\t\t\t\"privateLayout\", ParamUtil.getBoolean(request, \"privateLayout\"));\n\t\tpageContext.setAttribute(\"stagingGroup\", stagingGroup);\n\t\tpageContext.setAttribute(\"stagingGroupId\", stagingGroup.getGroupId());\n\n\t\treturn SKIP_BODY;\n\t}","id":24336,"modified_method":"@Override\n\tpublic int doStartTag() {\n\t\tHttpServletRequest request =\n\t\t\t(HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tGroup group = themeDisplay.getScopeGroup();\n\n\t\tpageContext.setAttribute(\"group\", group);\n\t\tpageContext.setAttribute(\"groupId\", group.getGroupId());\n\t\tpageContext.setAttribute(\"liveGroup\", null);\n\t\tpageContext.setAttribute(\"liveGroupId\", 0L);\n\t\tpageContext.setAttribute(\"stagingGroup\", null);\n\t\tpageContext.setAttribute(\"stagingGroupId\", 0L);\n\n\t\tLayout layout = themeDisplay.getLayout();\n\n\t\tboolean privateLayout = GetterUtil.getBoolean(\n\t\t\tParamUtil.getBoolean(\n\t\t\t\trequest, \"privateLayout\", layout.isPrivateLayout()));\n\n\t\tpageContext.setAttribute(\"privateLayout\", privateLayout);\n\n\t\tif (!group.isStaged() && !group.isStagedRemotely() &&\n\t\t\t!group.hasLocalOrRemoteStagingGroup()) {\n\n\t\t\treturn SKIP_BODY;\n\t\t}\n\n\t\tGroup liveGroup = StagingUtil.getLiveGroup(group.getGroupId());\n\t\tGroup stagingGroup = StagingUtil.getStagingGroup(group.getGroupId());\n\n\t\tpageContext.setAttribute(\"liveGroup\", liveGroup);\n\t\tpageContext.setAttribute(\"liveGroupId\", liveGroup.getGroupId());\n\t\tpageContext.setAttribute(\"stagingGroup\", stagingGroup);\n\t\tpageContext.setAttribute(\"stagingGroupId\", stagingGroup.getGroupId());\n\n\t\tif (Validator.isNotNull(_portletId)) {\n\t\t\tboolean isStagedPortlet = liveGroup.isStagedPortlet(_portletId);\n\n\t\t\tif (group.isStagedRemotely()) {\n\t\t\t\tisStagedPortlet = stagingGroup.isStagedPortlet(_portletId);\n\t\t\t}\n\n\t\t\tif (isStagedPortlet) {\n\t\t\t\tpageContext.setAttribute(\"group\", stagingGroup);\n\t\t\t\tpageContext.setAttribute(\"groupId\", stagingGroup.getGroupId());\n\t\t\t\tpageContext.setAttribute(\"scopeGroup\", stagingGroup);\n\t\t\t\tpageContext.setAttribute(\n\t\t\t\t\t\"scopeGroupId\", stagingGroup.getGroupId());\n\t\t\t}\n\t\t}\n\n\t\treturn SKIP_BODY;\n\t}","commit_id":"bbee045e25ea7a37bb46c1c809669a97a84e9b78","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void timeReached() {\n            requestLeaseSet(_ls.getDestination().calculateHash(), _ls, _expirationTime, _onCreate, _onFailed);\n        }","id":24337,"modified_method":"public void timeReached() {\n            Hash h = _ls.getDestination().calculateHash();\n            SessionParams sp = _sessions.get(h);\n            if (sp == null) {\n                if (_log.shouldLog(Log.WARN))\n                    _log.warn(\"cancelling rerequest, session went away\");\n                return;\n            }\n            synchronized(ClientConnectionRunner.this) {\n                if (sp.rerequestTimer != Rerequest.this) {\n                    if (_log.shouldLog(Log.WARN))\n                        _log.warn(\"cancelling rerequest, newer request came in\");\n                    return;\n                }\n            }\n            requestLeaseSet(_ls.getDestination().calculateHash(), _ls, _expirationTime, _onCreate, _onFailed);\n        }","commit_id":"cd62d7170c28819e287df3dfb541e4da7a9610eb","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Request that a particular client authorize the Leases contained in the \n     * LeaseSet, after which the onCreateJob is queued up.  If that doesn't occur\n     * within the timeout specified, queue up the onFailedJob.  This call does not\n     * block.\n     *\n     * @param h the Destination's hash\n     * @param set LeaseSet with requested leases - this object must be updated to contain the \n     *            signed version (as well as any changed/added/removed Leases)\n     *            The LeaseSet contains Leases and destination only, it is unsigned.\n     * @param expirationTime ms to wait before failing\n     * @param onCreateJob Job to run after the LeaseSet is authorized, null OK\n     * @param onFailedJob Job to run after the timeout passes without receiving authorization, null OK\n     */\n    void requestLeaseSet(Hash h, LeaseSet set, long expirationTime, Job onCreateJob, Job onFailedJob) {\n        if (_dead) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Requesting leaseSet from a dead client: \" + set);\n            if (onFailedJob != null)\n                _context.jobQueue().addJob(onFailedJob);\n            return;\n        }\n        SessionParams sp = _sessions.get(h);\n        if (sp == null) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Requesting leaseSet for an unknown sesssion\");\n            return;\n        }\n        // We can't use LeaseSet.equals() here because the dest, keys, and sig on\n        // the new LeaseSet are null. So we compare leases one by one.\n        // In addition, the client rewrites the expiration time of all the leases to\n        // the earliest one, so we can't use Lease.equals() or Lease.getEndDate().\n        // So compare by tunnel ID, and then by gateway.\n        // (on the remote possibility that two gateways are using the same ID).\n        // TunnelPool.locked_buildNewLeaseSet() ensures that leases are sorted,\n        //  so the comparison will always work.\n        int leases = set.getLeaseCount();\n        // synch so _currentLeaseSet isn't changed out from under us\n        LeaseSet current = null;\n        Destination dest = sp.dest;\n        synchronized (this) {\n            current = sp.currentLeaseSet;\n            if (current != null && current.getLeaseCount() == leases) {\n                for (int i = 0; i < leases; i++) {\n                    if (! current.getLease(i).getTunnelId().equals(set.getLease(i).getTunnelId()))\n                        break;\n                    if (! current.getLease(i).getGateway().equals(set.getLease(i).getGateway()))\n                        break;\n                    if (i == leases - 1) {\n                        if (_log.shouldLog(Log.INFO))\n                            _log.info(\"Requested leaseSet hasn't changed\");\n                        if (onCreateJob != null)\n                            _context.jobQueue().addJob(onCreateJob);\n                        return; // no change\n                    }\n                }\n            }\n        }\n        if (_log.shouldLog(Log.INFO))\n            _log.info(\"Current leaseSet \" + current + \"\\nNew leaseSet \" + set);\n        LeaseRequestState state;\n        synchronized (this) {\n            state = sp.leaseRequest;\n            if (state != null) {\n                LeaseSet requested = state.getRequested();\n                LeaseSet granted = state.getGranted();\n                long ours = set.getEarliestLeaseDate();\n                if ( ( (requested != null) && (requested.getEarliestLeaseDate() > ours) ) || \n                     ( (granted != null) && (granted.getEarliestLeaseDate() > ours) ) ) {\n                    // theirs is newer\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Already requesting, theirs newer, do nothing: \" + state);\n                } else {\n                    // ours is newer, so wait a few secs and retry\n                    set.setDestination(dest);\n                    _context.simpleTimer2().addEvent(new Rerequest(set, expirationTime, onCreateJob, onFailedJob), 3*1000);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Already requesting, ours newer, wait 3 sec: \" + state);\n                }\n                // fire onCreated?\n                return; // already requesting\n            } else {\n                set.setDestination(dest);\n                sp.leaseRequest = state = new LeaseRequestState(onCreateJob, onFailedJob,\n                                                                _context.clock().now() + expirationTime, set);\n                if (_log.shouldLog(Log.DEBUG))\n                    _log.debug(\"New request: \" + state);\n            }\n        }\n        _context.jobQueue().addJob(new RequestLeaseSetJob(_context, this, state));\n    }","id":24338,"modified_method":"/**\n     * Request that a particular client authorize the Leases contained in the \n     * LeaseSet, after which the onCreateJob is queued up.  If that doesn't occur\n     * within the timeout specified, queue up the onFailedJob.  This call does not\n     * block.\n     *\n     * Job args are always null, may need some fixups if we start using them.\n     *\n     * @param h the Destination's hash\n     * @param set LeaseSet with requested leases - this object must be updated to contain the \n     *            signed version (as well as any changed/added/removed Leases)\n     *            The LeaseSet contains Leases and destination only, it is unsigned.\n     * @param expirationTime ms to wait before failing\n     * @param onCreateJob Job to run after the LeaseSet is authorized, null OK\n     * @param onFailedJob Job to run after the timeout passes without receiving authorization, null OK\n     */\n    void requestLeaseSet(Hash h, LeaseSet set, long expirationTime, Job onCreateJob, Job onFailedJob) {\n        if (_dead) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Requesting leaseSet from a dead client: \" + set);\n            if (onFailedJob != null)\n                _context.jobQueue().addJob(onFailedJob);\n            return;\n        }\n        SessionParams sp = _sessions.get(h);\n        if (sp == null) {\n            if (_log.shouldLog(Log.WARN))\n                _log.warn(\"Requesting leaseSet for an unknown sesssion\");\n            return;\n        }\n        // We can't use LeaseSet.equals() here because the dest, keys, and sig on\n        // the new LeaseSet are null. So we compare leases one by one.\n        // In addition, the client rewrites the expiration time of all the leases to\n        // the earliest one, so we can't use Lease.equals() or Lease.getEndDate().\n        // So compare by tunnel ID, and then by gateway.\n        // (on the remote possibility that two gateways are using the same ID).\n        // TunnelPool.locked_buildNewLeaseSet() ensures that leases are sorted,\n        //  so the comparison will always work.\n        int leases = set.getLeaseCount();\n        // synch so _currentLeaseSet isn't changed out from under us\n        LeaseSet current = null;\n        Destination dest = sp.dest;\n        LeaseRequestState state;\n        synchronized (this) {\n            current = sp.currentLeaseSet;\n            if (current != null && current.getLeaseCount() == leases) {\n                for (int i = 0; i < leases; i++) {\n                    if (! current.getLease(i).getTunnelId().equals(set.getLease(i).getTunnelId()))\n                        break;\n                    if (! current.getLease(i).getGateway().equals(set.getLease(i).getGateway()))\n                        break;\n                    if (i == leases - 1) {\n                        if (_log.shouldLog(Log.INFO))\n                            _log.info(\"Requested leaseSet hasn't changed\");\n                        if (onCreateJob != null)\n                            _context.jobQueue().addJob(onCreateJob);\n                        return; // no change\n                    }\n                }\n            }\n\n            if (_log.shouldLog(Log.INFO))\n                _log.info(\"Current leaseSet \" + current + \"\\nNew leaseSet \" + set);\n\n            state = sp.leaseRequest;\n            if (state != null) {\n                LeaseSet requested = state.getRequested();\n                LeaseSet granted = state.getGranted();\n                long ours = set.getEarliestLeaseDate();\n                if ( ( (requested != null) && (requested.getEarliestLeaseDate() > ours) ) || \n                     ( (granted != null) && (granted.getEarliestLeaseDate() > ours) ) ) {\n                    // theirs is newer\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Already requesting, theirs newer, do nothing: \" + state);\n                } else {\n                    // ours is newer, so wait a few secs and retry\n                    set.setDestination(dest);\n                    Rerequest timer = new Rerequest(set, expirationTime, onCreateJob, onFailedJob);\n                    sp.rerequestTimer = timer;\n                    _context.simpleTimer2().addEvent(timer, 3*1000);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"Already requesting, ours newer, wait 3 sec: \" + state);\n                }\n                // fire onCreated?\n                return; // already requesting\n            } else {\n                set.setDestination(dest);\n                if (current == null && _context.tunnelManager().getOutboundClientTunnelCount(h) <= 0) {\n                    // at startup of a client, where we don't have a leaseset, wait for\n                    // an outbound tunnel also, so the client doesn't start sending data\n                    // before we are ready\n                    Rerequest timer = new Rerequest(set, expirationTime, onCreateJob, onFailedJob);\n                    sp.rerequestTimer = timer;\n                    _context.simpleTimer2().addEvent(timer, 1000);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"No current LS but no OB tunnels, wait 1 sec for \" + h);\n                    return;\n                } else {\n                    // so the timer won't fire off with an older LS request\n                    sp.rerequestTimer = null;\n                    sp.leaseRequest = state = new LeaseRequestState(onCreateJob, onFailedJob,\n                                                                _context.clock().now() + expirationTime, set);\n                    if (_log.shouldLog(Log.DEBUG))\n                        _log.debug(\"New request: \" + state);\n                }\n            }\n        }\n        _context.jobQueue().addJob(new RequestLeaseSetJob(_context, this, state));\n    }","commit_id":"cd62d7170c28819e287df3dfb541e4da7a9610eb","url":"https://github.com/i2p/i2p.i2p"},{"original_method":"/**\n     * Create and start listener using configuration information from jmsConfig. Uses\n     * resolveOrCreateDestination to determine the destination for the listener.\n     * \n     * @param jmsConfig configuration information\n     * @param listenerHandler object to be called when a message arrives\n     * @param destinationName null for temp dest or a destination name\n     * @param messageSelectorPrefix prefix for the messageselector\n     * @return\n     */\n    public static DefaultMessageListenerContainer createJmsListener(JMSConfiguration jmsConfig,\n                                                                    MessageListener listenerHandler,\n                                                                    String destinationName, \n                                                                    String messageSelectorPrefix) {\n        DefaultMessageListenerContainer jmsListener = jmsConfig.isUseJms11()\n            ? new DefaultMessageListenerContainer() : new DefaultMessageListenerContainer102();\n        jmsListener.setConcurrentConsumers(jmsConfig.getConcurrentConsumers());\n        jmsListener.setMaxConcurrentConsumers(jmsConfig.getMaxConcurrentConsumers());\n        jmsListener.setPubSubDomain(jmsConfig.isPubSubDomain());\n        jmsListener.setAutoStartup(true);\n        jmsListener.setConnectionFactory(jmsConfig.getConnectionFactory());\n        jmsListener.setMessageSelector(jmsConfig.getMessageSelector());\n        jmsListener.setDurableSubscriptionName(jmsConfig.getDurableSubscriptionName());\n        jmsListener.setSessionTransacted(jmsConfig.isSessionTransacted());\n        jmsListener.setTransactionManager(jmsConfig.getTransactionManager());\n        jmsListener.setMessageListener(listenerHandler);\n        if (messageSelectorPrefix != null && jmsConfig.isUseConduitIdSelector()) {\n            jmsListener.setMessageSelector(\"JMSCorrelationID LIKE '\" + messageSelectorPrefix + \"%'\");\n        }\n        if (jmsConfig.getDestinationResolver() != null) {\n            jmsListener.setDestinationResolver(jmsConfig.getDestinationResolver());\n        }\n        if (jmsConfig.getTaskExecutor() != null) {\n            jmsListener.setTaskExecutor(jmsConfig.getTaskExecutor());\n        } else {\n            SimpleAsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor();\n            taskExecutor.setConcurrencyLimit(jmsConfig.getMaxConcurrentTasks());\n            jmsListener.setTaskExecutor(taskExecutor);\n        }\n        JmsTemplate jmsTemplate = createJmsTemplate(jmsConfig, null);\n        Destination dest = JMSFactory.resolveOrCreateDestination(jmsTemplate, destinationName, jmsConfig\n            .isPubSubDomain());\n        jmsListener.setDestination(dest);\n        jmsListener.initialize();\n        return jmsListener;\n    }","id":24339,"modified_method":"/**\n     * Create and start listener using configuration information from jmsConfig. Uses\n     * resolveOrCreateDestination to determine the destination for the listener.\n     * \n     * @param jmsConfig configuration information\n     * @param listenerHandler object to be called when a message arrives\n     * @param destinationName null for temp dest or a destination name\n     * @param messageSelectorPrefix prefix for the messageselector\n     * @return\n     */\n    public static DefaultMessageListenerContainer createJmsListener(JMSConfiguration jmsConfig,\n                                                                    MessageListener listenerHandler,\n                                                                    String destinationName, \n                                                                    String messageSelectorPrefix) {\n        DefaultMessageListenerContainer jmsListener = jmsConfig.isUseJms11()\n            ? new DefaultMessageListenerContainer() : new DefaultMessageListenerContainer102();\n        jmsListener.setConcurrentConsumers(jmsConfig.getConcurrentConsumers());\n        jmsListener.setMaxConcurrentConsumers(jmsConfig.getMaxConcurrentConsumers());\n        jmsListener.setPubSubDomain(jmsConfig.isPubSubDomain());\n        jmsListener.setAutoStartup(true);\n        jmsListener.setConnectionFactory(jmsConfig.getConnectionFactory());\n        jmsListener.setMessageSelector(jmsConfig.getMessageSelector());\n        jmsListener.setDurableSubscriptionName(jmsConfig.getDurableSubscriptionName());\n        jmsListener.setSessionTransacted(jmsConfig.isSessionTransacted());\n        jmsListener.setTransactionManager(jmsConfig.getTransactionManager());\n        jmsListener.setMessageListener(listenerHandler);\n        if (jmsConfig.getRecoveryInterval() != JMSConfiguration.DEFAULT_VALUE) {\n            jmsListener.setRecoveryInterval(jmsConfig.getRecoveryInterval());\n        }\n        if (jmsConfig.getCacheLevelName() != null && (jmsConfig.getCacheLevelName().trim().length() > 0)) {\n            jmsListener.setCacheLevelName(jmsConfig.getCacheLevelName());\n        } else if (jmsConfig.getCacheLevel() != JMSConfiguration.DEFAULT_VALUE) {\n            jmsListener.setCacheLevel(jmsConfig.getCacheLevel());\n        }\n        if (messageSelectorPrefix != null && jmsConfig.isUseConduitIdSelector()) {\n            jmsListener.setMessageSelector(\"JMSCorrelationID LIKE '\" + messageSelectorPrefix + \"%'\");\n        }\n        if (jmsConfig.getDestinationResolver() != null) {\n            jmsListener.setDestinationResolver(jmsConfig.getDestinationResolver());\n        }\n        if (jmsConfig.getTaskExecutor() != null) {\n            jmsListener.setTaskExecutor(jmsConfig.getTaskExecutor());\n        } else {\n            SimpleAsyncTaskExecutor taskExecutor = new SimpleAsyncTaskExecutor();\n            taskExecutor.setConcurrencyLimit(jmsConfig.getMaxConcurrentTasks());\n            jmsListener.setTaskExecutor(taskExecutor);\n        }\n        if (jmsConfig.isAutoResolveDestination()) {\n            jmsListener.setDestinationName(destinationName);\n        } else {\n            JmsTemplate jmsTemplate = createJmsTemplate(jmsConfig, null);\n            Destination dest = JMSFactory.resolveOrCreateDestination(jmsTemplate, destinationName, jmsConfig\n                .isPubSubDomain());\n            jmsListener.setDestination(dest);\n        }\n        jmsListener.initialize();\n        return jmsListener;\n    }","commit_id":"9317052aff3279f03df91fa97391b9eb96f336ee","url":"https://github.com/apache/cxf"},{"original_method":"public Object sendMessage(String destination, Message message, long timeout)\r\n\tthrows MessageBusException {\r\n\t\tString replyTo = message.getResponseDestination();\r\n\t\tif (!_bus.hasDestination(replyTo)) {\r\n\t\t\tthrow new MessageBusException(\r\n\t\t\t\t\"No response destination configured: \" + replyTo);\r\n\t\t}\r\n\t\tmessage.setDestination(destination);\r\n\t\tString responseId = _uuidGenerator.generate();\r\n\t\tmessage.setResponseId(responseId);\r\n\t\t_SynchronousMessageListener listener =\r\n\t\t\tnew _SynchronousMessageListener(message, timeout);\r\n\t\treturn listener.send();\r\n\t}","id":24340,"modified_method":"public Object sendMessage(String destination, Message message, long timeout)\n\t\tthrows MessageBusException {\n\n\t\tmessage.setDestination(destination);\n\n\t\tString responseDestination = message.getResponseDestination();\n\n\t\tif (!_messageBus.hasDestination(responseDestination)) {\n\t\t\tthrow new MessageBusException(\n\t\t\t\t\"Response destination \" + responseDestination +\n\t\t\t\t\t\" is not configured\");\n\t\t}\n\n\t\tmessage.setDestination(destination);\n\n\t\tString responseId = _portalUUID.generate();\n\n\t\tmessage.setResponseId(responseId);\n\n\t\tSynchronousMessageListener synchronousMessageListener =\n\t\t\tnew SynchronousMessageListener(_messageBus, message, timeout);\n\n\t\treturn synchronousMessageListener.send();\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Object sendMessage(String destination, Message message)\r\n\tthrows MessageBusException {\r\n\t\treturn sendMessage(destination, message, _defaultTimeout);\r\n\r\n\t}","id":24341,"modified_method":"public Object sendMessage(String destination, Message message)\n\t\tthrows MessageBusException {\n\n\t\treturn sendMessage(destination, message, _timeout);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DefaultSynchronousMessageSender(MessageBus bus,\r\n\t\t\t\t\t\t\t\t\t\t   PortalUUID uuidGenerator,\r\n\t\t\t\t\t\t\t\t\t\t   long defaultTimeout) {\r\n\t\t_bus = bus;\r\n\t\t_uuidGenerator = uuidGenerator;\r\n\t\t_defaultTimeout = defaultTimeout;\r\n\t}","id":24342,"modified_method":"public DefaultSynchronousMessageSender(\n\t\tMessageBus messageBus, PortalUUID portalUUID, long timeout) {\n\n\t\t_messageBus = messageBus;\n\t\t_portalUUID = portalUUID;\n\t\t_timeout = timeout;\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Hits search(\n\t\t\tlong companyId, Query query, Sort sort, int start, int end)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tSearchRequest searchRequest = new SearchRequest();\n\n\t\t\tsearchRequest.setCommand(SearchRequest.COMMAND_SEARCH);\n\t\t\tsearchRequest.setCompanyId(companyId);\n\t\t\tsearchRequest.setQuery(query);\n\t\t\tsearchRequest.setSort(sort);\n\t\t\tsearchRequest.setStart(start);\n\t\t\tsearchRequest.setEnd(end);\n\n\t\t\tHits hits = (Hits)MessageBusUtil.sendSynchronizedMessage(\n\t\t\t\tDestinationNames.SEARCH_READER,\n\t\t\t\tDestinationNames.SEARCH_READER_RESPONSE, searchRequest);\n\n\t\t\treturn hits;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t}","id":24343,"modified_method":"public Hits search(\n\t\t\tlong companyId, Query query, Sort sort, int start, int end)\n\t\tthrows SearchException {\n\n\t\ttry {\n\t\t\tSearchRequest searchRequest = new SearchRequest();\n\n\t\t\tsearchRequest.setCommand(SearchRequest.COMMAND_SEARCH);\n\t\t\tsearchRequest.setCompanyId(companyId);\n\t\t\tsearchRequest.setQuery(query);\n\t\t\tsearchRequest.setSort(sort);\n\t\t\tsearchRequest.setStart(start);\n\t\t\tsearchRequest.setEnd(end);\n\n\t\t\tHits hits = (Hits)MessageBusUtil.sendSynchronousMessage(\n\t\t\t\tDestinationNames.SEARCH_READER, searchRequest);\n\n\t\t\treturn hits;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SearchException(e);\n\t\t}\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void doReceive(Message message) throws Exception {\n\t\tSearchRequest searchRequest = (SearchRequest)message.getPayload();\n\n\t\tString command = searchRequest.getCommand();\n\t\tMessage reply = new Message();\n\t\tif (command.equals(SearchRequest.COMMAND_INDEX_ONLY)) {\n\t\t\tdoCommandIndexOnly(reply);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_SEARCH)) {\n\t\t\tdoCommandSearch(reply, searchRequest);\n\t\t}\n\t}","id":24344,"modified_method":"public void doReceive(Message message) throws Exception {\n\t\tSearchRequest searchRequest = (SearchRequest)message.getPayload();\n\n\t\tString command = searchRequest.getCommand();\n\n\t\tif (command.equals(SearchRequest.COMMAND_INDEX_ONLY)) {\n\t\t\tdoCommandIndexOnly(message);\n\t\t}\n\t\telse if (command.equals(SearchRequest.COMMAND_SEARCH)) {\n\t\t\tdoCommandSearch(message, searchRequest);\n\t\t}\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public LuceneReaderMessageListener(MessageSender sender) {\n\t\t_messageSender = sender;\n\t}","id":24345,"modified_method":"public LuceneReaderMessageListener(MessageSender messageSender) {\n\t\t_messageSender = messageSender;\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String getResponseDestination() {\n\t\treturn _responseDestination;\n\t}","id":24346,"modified_method":"public String getResponseDestination() {\n\t\tif (Validator.isNull(_responseDestination)) {\n\t\t\treturn _destination + _DEFAULT_RESPONSE_DESTINATION_SUFFIX;\n\t\t}\n\t\telse {\n\t\t\treturn _responseDestination;\n\t\t}\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"{responseDestination=\");\n\t\tsb.append(_responseDestination);\n\t\tsb.append(\", \");\n\t\tsb.append(\"responseId=\");\n\t\tsb.append(_responseId);\n\t\tsb.append(\", \");\n\t\tsb.append(\"payload=\");\n\t\tsb.append(_payload);\n\t\tsb.append(\", \");\n\t\tsb.append(\"values=\");\n\t\tsb.append(_values);\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","id":24347,"modified_method":"public String toString() {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tsb.append(\"{destination=\");\n\t\tsb.append(_destination);\n\t\tsb.append(\", responseDestination=\");\n\t\tsb.append(_responseDestination);\n\t\tsb.append(\", \");\n\t\tsb.append(\"responseId=\");\n\t\tsb.append(_responseId);\n\t\tsb.append(\", \");\n\t\tsb.append(\"payload=\");\n\t\tsb.append(_payload);\n\t\tsb.append(\", \");\n\t\tsb.append(\"values=\");\n\t\tsb.append(_values);\n\t\tsb.append(\"}\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void sendMessage(String destination, Object payload) {\n\t\tMessage message = new Message();\n\n\t\tmessage.setPayload(payload);\n\t\t_instance._sendMessage(destination, message);\n\t}","id":24348,"modified_method":"public static void sendMessage(String destination, Object payload) {\n\t\t_instance._sendMessage(destination, payload);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void init(\n\t\tMessageBus messageBus, MessageSender messageSender,\n\t\tSynchronousMessageSender syncSender) {\n\n\t\t_instance._init(messageBus, messageSender, syncSender);\n\t}","id":24349,"modified_method":"public static void init(\n\t\tMessageBus messageBus, MessageSender messageSender,\n\t\tSynchronousMessageSender synchronousMessageSender) {\n\n\t\t_instance._init(messageBus, messageSender, synchronousMessageSender);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _init(MessageBus messageBus, MessageSender messageSender,\n\t\t\t\t\t   SynchronousMessageSender synchronousSender) {\n\t\t_messageBus = messageBus;\n\t\t_messageSender = messageSender;\n\t\t_synchronousSender = synchronousSender;\n\t}","id":24350,"modified_method":"private void _init(\n\t\tMessageBus messageBus, MessageSender messageSender,\n\t\tSynchronousMessageSender synchronousMessageSender) {\n\n\t\t_messageBus = messageBus;\n\t\t_messageSender = messageSender;\n\t\t_synchronousMessageSender = synchronousMessageSender;\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object sendSynchronizedMessage(\n\t\t\tString destination, String responseDestination,\n\t\t\tObject payload)\n\t\tthrows MessageBusException {\n\t\tMessage message = new Message();\n\t\tmessage.setResponseDestination(responseDestination);\n\t\tmessage.setPayload(payload);\n\t\treturn _instance._sendSynchronizedMessage(destination, message);\n\t}","id":24351,"modified_method":"public static Object sendSynchronousMessage(\n\t\t\tString destination, Object payload)\n\t\tthrows MessageBusException {\n\n\t\treturn _instance._sendSynchronousMessage(destination, payload);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Object _sendSynchronizedMessage(\n\t\t\tString destination, Message message, long timeout)\n\t\tthrows MessageBusException {\n\t\treturn _synchronousSender.sendMessage(destination, message, timeout);\n\t}","id":24352,"modified_method":"private Object _sendSynchronousMessage(\n\t\t\tString destination, Message message, long timeout)\n\t\tthrows MessageBusException {\n\n\t\treturn _synchronousMessageSender.sendMessage(\n\t\t\tdestination, message, timeout);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Object _sendSynchronizedMessage(\n\t\tString destination, Message message)\n\t\tthrows MessageBusException {\n\t\treturn _synchronousSender.sendMessage(destination, message);\n\t}","id":24353,"modified_method":"private Object _sendSynchronousMessage(String destination, Message message)\n\t\tthrows MessageBusException {\n\n\t\treturn _synchronousMessageSender.sendMessage(destination, message);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object sendSynchronizedMessage(\n\t\t\tString destination, String responseDestination,\n\t\t\tMessage message, long timeout)\n\t\tthrows MessageBusException {\n\t\tmessage.setResponseDestination(responseDestination);\n\t\treturn _instance._sendSynchronizedMessage(destination, message, timeout);\n\t}","id":24354,"modified_method":"public static Object sendSynchronousMessage(\n\t\t\tString destination, Message message, long timeout)\n\t\tthrows MessageBusException {\n\n\t\treturn _instance._sendSynchronousMessage(\n\t\t\tdestination, message, timeout);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Object sendSynchronizedMessage(\n\t\t\tString destination, String responseDestination,\n\t\t\tMessage message)\n\t\tthrows MessageBusException {\n\t\tmessage.setResponseDestination(responseDestination);\n\t\treturn _instance._sendSynchronizedMessage(\n\t\t\tdestination, message);\n\t}","id":24355,"modified_method":"public static Object sendSynchronousMessage(\n\t\t\tString destination, Message message)\n\t\tthrows MessageBusException {\n\n\t\treturn _instance._sendSynchronousMessage(destination, message);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<SchedulerRequest> getScheduledJobs(String groupName)\n\t\tthrows SchedulerException {\n\n\t\ttry {\n\t\t\tSchedulerRequest schedulerRequest = new SchedulerRequest(\n\t\t\t\tSchedulerRequest.COMMAND_RETRIEVE, null, groupName, null, null,\n\t\t\t\tnull, null, null, null);\n\n\t\t\tList<SchedulerRequest> schedulerRequests =\n\t\t\t\t(List<SchedulerRequest>)MessageBusUtil.sendSynchronizedMessage(\n\t\t\t\t\tDestinationNames.SCHEDULER, DestinationNames.SCHEDULER_RESPONSE,\n\t\t\t\t\tschedulerRequest);\n\n\t\t\treturn schedulerRequests;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(e);\n\t\t}\n\t}","id":24356,"modified_method":"public List<SchedulerRequest> getScheduledJobs(String groupName)\n\t\tthrows SchedulerException {\n\n\t\ttry {\n\t\t\tSchedulerRequest schedulerRequest = new SchedulerRequest(\n\t\t\t\tSchedulerRequest.COMMAND_RETRIEVE, null, groupName, null, null,\n\t\t\t\tnull, null, null, null);\n\n\t\t\tList<SchedulerRequest> schedulerRequests =\n\t\t\t\t(List<SchedulerRequest>)MessageBusUtil.sendSynchronousMessage(\n\t\t\t\t\tDestinationNames.SCHEDULER, schedulerRequest);\n\n\t\t\treturn schedulerRequests;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SchedulerException(e);\n\t\t}\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SchedulerMessageListener(SchedulerEngine schedulerEngine,\n\t\t\t\t\t\t\t\t\tMessageSender sender) {\n\t\t_schedulerEngine = schedulerEngine;\n\t\t_messageSender = sender;\n\t}","id":24357,"modified_method":"public SchedulerMessageListener(\n\t\tMessageSender messageSender, SchedulerEngine schedulerEngine) {\n\n\t\t_messageSender = messageSender;\n\t\t_schedulerEngine = schedulerEngine;\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean _isIndexReadOnly() {\n\t\tif (_indexReadOnly != null) {\n\t\t\treturn _indexReadOnly.booleanValue();\n\t\t}\n\n\t\ttry {\n\t\t\tSearchRequest searchRequest = new SearchRequest();\n\n\t\t\tsearchRequest.setCommand(SearchRequest.COMMAND_INDEX_ONLY);\n\n\t\t\t_indexReadOnly = (Boolean)MessageBusUtil.sendSynchronizedMessage(\n\t\t\t\tDestinationNames.SEARCH_READER,\n\t\t\t\tDestinationNames.SEARCH_READER_RESPONSE, searchRequest);\n\n\t\t\tif (_indexReadOnly == null) {\n\t\t\t\t_indexReadOnly = Boolean.FALSE;\n\t\t\t}\n\n\t\t\treturn _indexReadOnly.booleanValue();\n\t\t}\n\t\tcatch (MessageBusException mbe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Unable to check index status\", mbe);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}","id":24358,"modified_method":"private boolean _isIndexReadOnly() {\n\t\tif (_indexReadOnly != null) {\n\t\t\treturn _indexReadOnly.booleanValue();\n\t\t}\n\n\t\ttry {\n\t\t\tSearchRequest searchRequest = new SearchRequest();\n\n\t\t\tsearchRequest.setCommand(SearchRequest.COMMAND_INDEX_ONLY);\n\n\t\t\t_indexReadOnly = (Boolean)MessageBusUtil.sendSynchronousMessage(\n\t\t\t\tDestinationNames.SEARCH_READER, searchRequest);\n\n\t\t\tif (_indexReadOnly == null) {\n\t\t\t\t_indexReadOnly = Boolean.FALSE;\n\t\t\t}\n\n\t\t\treturn _indexReadOnly.booleanValue();\n\t\t}\n\t\tcatch (MessageBusException mbe) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\"Unable to check index status\", mbe);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ServiceTestSuite() {\n\t\tInitUtil.initWithSpring();\n\n\t\t// Resource repositories root\n\n\t\tFileUtil.deltree(PropsValues.RESOURCE_REPOSITORIES_ROOT);\n\n\t\t// JCR\n\n\t\ttry {\n\t\t\tJCRFactoryUtil.prepare();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Lucene\n\n\t\tLuceneUtil.checkLuceneDir(TestPropsValues.COMPANY_ID);\n\n\t\t// Messaging\n\n\t\tMessageBus messageBus = (MessageBus)PortalBeanLocatorUtil.locate(\n\t\t\tMessageBus.class.getName());\n\t\tMessageSender messageSender =\n\t\t\t(MessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tMessageSender.class.getName());\n\t\tSynchronousMessageSender syncMessageSender =\n\t\t\t(SynchronousMessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tSynchronousMessageSender.class.getName());\n\n\t\tMessageBusUtil.init(messageBus, messageSender, syncMessageSender);\n\n\t\t// Scheduler\n\n\t\tSchedulerEngine schedulerEngine =\n\t\t\t(SchedulerEngine)PortalBeanLocatorUtil.locate(\n\t\t\t\tSchedulerEngine.class.getName());\n\n\t\tSchedulerEngineUtil.init(new SchedulerEngineProxy());\n\n\t\ttry {\n\t\t\tschedulerEngine.start();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Search\n\n\t\tLuceneSearchEngineUtil.init();\n\n\t\tSearchEngineUtil.init(new IndexSearcherImpl(), new IndexWriterImpl());\n\n\t\t// Tests\n\n\t\taddTestSuite(BookmarksFolderServiceTest.class);\n\t\taddTestSuite(BookmarksEntryServiceTest.class);\n\t\taddTestSuite(DLFileEntryServiceTest.class);\n\t\taddTestSuite(IGImageServiceTest.class);\n\t\taddTestSuite(MBMessageServiceTest.class);\n\t\taddTestSuite(SocialRelationLocalServiceTest.class);\n\n\t\t// Company\n\n\t\ttry {\n\t\t\tCompanyLocalServiceUtil.checkCompany(\n\t\t\t\tTestPropsValues.COMPANY_WEB_ID);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","id":24359,"modified_method":"public ServiceTestSuite() {\n\t\tInitUtil.initWithSpring();\n\n\t\t// Resource repositories root\n\n\t\tFileUtil.deltree(PropsValues.RESOURCE_REPOSITORIES_ROOT);\n\n\t\t// JCR\n\n\t\ttry {\n\t\t\tJCRFactoryUtil.prepare();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Lucene\n\n\t\tLuceneUtil.checkLuceneDir(TestPropsValues.COMPANY_ID);\n\n\t\t// Messaging\n\n\t\tMessageBus messageBus = (MessageBus)PortalBeanLocatorUtil.locate(\n\t\t\tMessageBus.class.getName());\n\t\tMessageSender messageSender =\n\t\t\t(MessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tMessageSender.class.getName());\n\t\tSynchronousMessageSender synchronousMessageSender =\n\t\t\t(SynchronousMessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tSynchronousMessageSender.class.getName());\n\n\t\tMessageBusUtil.init(\n\t\t\tmessageBus, messageSender, synchronousMessageSender);\n\n\t\t// Scheduler\n\n\t\tSchedulerEngine schedulerEngine =\n\t\t\t(SchedulerEngine)PortalBeanLocatorUtil.locate(\n\t\t\t\tSchedulerEngine.class.getName());\n\n\t\tSchedulerEngineUtil.init(new SchedulerEngineProxy());\n\n\t\ttry {\n\t\t\tschedulerEngine.start();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t// Search\n\n\t\tLuceneSearchEngineUtil.init();\n\n\t\tSearchEngineUtil.init(new IndexSearcherImpl(), new IndexWriterImpl());\n\n\t\t// Tests\n\n\t\taddTestSuite(BookmarksFolderServiceTest.class);\n\t\taddTestSuite(BookmarksEntryServiceTest.class);\n\t\taddTestSuite(DLFileEntryServiceTest.class);\n\t\taddTestSuite(IGImageServiceTest.class);\n\t\taddTestSuite(MBMessageServiceTest.class);\n\t\taddTestSuite(SocialRelationLocalServiceTest.class);\n\n\t\t// Company\n\n\t\ttry {\n\t\t\tCompanyLocalServiceUtil.checkCompany(\n\t\t\t\tTestPropsValues.COMPANY_WEB_ID);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void doRun(String[] ids) throws Exception {\n\n\t\t// Print release information\n\n\t\tSystem.out.println(\"Starting \" + ReleaseInfo.getReleaseInfo());\n\n\t\t// Clear locks\n\n\t\ttry {\n\t\t\tLockServiceUtil.clear();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t// Add shutdown hook\n\n\t\tRuntime.getRuntime().addShutdownHook(new Thread(new ShutdownHook()));\n\n\t\t// Velocity\n\n\t\tLiferayResourceLoader.setListeners(PropsUtil.getArray(\n\t\t\tPropsKeys.VELOCITY_ENGINE_RESOURCE_LISTENERS));\n\n\t\tExtendedProperties props = new ExtendedProperties();\n\n\t\tprops.setProperty(RuntimeConstants.RESOURCE_LOADER, \"servlet\");\n\n\t\tprops.setProperty(\n\t\t\t\"servlet.\" + RuntimeConstants.RESOURCE_LOADER + \".class\",\n\t\t\tLiferayResourceLoader.class.getName());\n\n\t\tprops.setProperty(\n\t\t\tRuntimeConstants.RESOURCE_MANAGER_CLASS,\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_RESOURCE_MANAGER));\n\n\t\tprops.setProperty(\n\t\t\tRuntimeConstants.RESOURCE_MANAGER_CACHE_CLASS,\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_RESOURCE_MANAGER_CACHE));\n\n\t\tprops.setProperty(\n\t\t\t\"velocimacro.library\",\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_VELOCIMACRO_LIBRARY));\n\n\t\tprops.setProperty(\n\t\t\tRuntimeConstants.RUNTIME_LOG_LOGSYSTEM_CLASS,\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_LOGGER));\n\n\t\tprops.setProperty(\n\t\t\t\"runtime.log.logsystem.log4j.category\",\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_LOGGER_CATEGORY));\n\n\t\tVelocity.setExtendedProperties(props);\n\n\t\ttry {\n\t\t\tVelocity.init();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t// Disable database caching before upgrade\n\n\t\tCacheRegistry.setActive(false);\n\n\t\t// Upgrade\n\n\t\tint buildNumber = ReleaseLocalServiceUtil.getBuildNumberOrCreate();\n\n\t\tif (buildNumber < ReleaseInfo.RELEASE_4_2_1_BUILD_NUMBER) {\n\t\t\tString msg = \"You must first upgrade to Liferay Portal 4.2.1\";\n\n\t\t\t_log.fatal(msg);\n\n\t\t\tthrow new RuntimeException(msg);\n\t\t}\n\n\t\tboolean ranUpgradeProcess = false;\n\n\t\tString[] upgradeProcesses = PropsUtil.getArray(\n\t\t\tPropsKeys.UPGRADE_PROCESSES);\n\n\t\tfor (int i = 0; i < upgradeProcesses.length; i++) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Initializing upgrade \" + upgradeProcesses[i]);\n\t\t\t}\n\n\t\t\tUpgradeProcess upgradeProcess = (UpgradeProcess)InstancePool.get(\n\t\t\t\tupgradeProcesses[i]);\n\n\t\t\tif (upgradeProcess == null) {\n\t\t\t\t_log.error(upgradeProcesses[i] + \" cannot be found\");\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((upgradeProcess.getThreshold() == 0) ||\n\t\t\t\t(upgradeProcess.getThreshold() > buildNumber)) {\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Running upgrade \" + upgradeProcesses[i]);\n\t\t\t\t}\n\n\t\t\t\tupgradeProcess.upgrade();\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Finished upgrade \" + upgradeProcesses[i]);\n\t\t\t\t}\n\n\t\t\t\tranUpgradeProcess = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Upgrade threshold \" + upgradeProcess.getThreshold() +\n\t\t\t\t\t\t\t\" will not trigger upgrade\");\n\n\t\t\t\t\t_log.debug(\"Skipping upgrade \" + upgradeProcesses[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Class names\n\n\t\tClassNameLocalServiceUtil.checkClassNames();\n\n\t\t// Delete temporary images\n\n\t\tdeleteTemporaryImages();\n\n\t\t// Update indexes\n\n\t\tif (ranUpgradeProcess) {\n\t\t\tDBUtil.getInstance().runSQLTemplate(\"indexes.sql\", false);\n\t\t}\n\n\t\t// Enable database caching after upgrade\n\n\t\tCacheRegistry.setActive(true);\n\n\t\t// Clear the caches only if the upgrade process was run\n\n\t\tif (ranUpgradeProcess) {\n\t\t\tMultiVMPoolUtil.clear();\n\t\t}\n\n\t\t// Messaging\n\n\t\tMessageBus messageBus = (MessageBus)PortalBeanLocatorUtil.locate(\n\t\t\tMessageBus.class.getName());\n\t\tMessageSender messageSender =\n\t\t\t(MessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tMessageSender.class.getName());\n\t\tSynchronousMessageSender syncMessageSender =\n\t\t\t(SynchronousMessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tSynchronousMessageSender.class.getName());\n\n\t\tMessageBusUtil.init(messageBus, messageSender, syncMessageSender);\n\n\t\t// Scheduler\n\n\t\tSchedulerEngineUtil.init(new SchedulerEngineProxy());\n\n\t\tSchedulerEngineUtil.start();\n\n\t\t// Search\n\n\t\tLuceneSearchEngineUtil.init();\n\n\t\tSearchEngineUtil.init(new IndexSearcherImpl(), new IndexWriterImpl());\n\n\t\t// Verify\n\n\t\tRelease release = ReleaseLocalServiceUtil.getRelease();\n\n\t\tint verifyFrequency = GetterUtil.getInteger(\n\t\t\tPropsUtil.get(PropsKeys.VERIFY_FREQUENCY));\n\t\tboolean verified = release.isVerified();\n\n\t\tif ((verifyFrequency == VerifyProcess.ALWAYS) ||\n\t\t\t((verifyFrequency == VerifyProcess.ONCE) && !verified) ||\n\t\t\t(ranUpgradeProcess)) {\n\n\t\t\tString[] verifyProcesses = PropsUtil.getArray(\n\t\t\t\tPropsKeys.VERIFY_PROCESSES);\n\n\t\t\tfor (int i = 0; i < verifyProcesses.length; i++) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Initializing verification \" + verifyProcesses[i]);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tVerifyProcess verifyProcess = (VerifyProcess)Class.forName(\n\t\t\t\t\t\tverifyProcesses[i]).newInstance();\n\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\"Running verification \" + verifyProcesses[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tverifyProcess.verify();\n\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\t\"Finished verification \" + verifyProcesses[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tverified = true;\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\t\t\t_log.error(verifyProcesses[i] + \" cannot be found\");\n\t\t\t\t}\n\t\t\t\tcatch (InstantiationException ie) {\n\t\t\t\t\t_log.error(verifyProcesses[i] + \" cannot be initiated\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update release\n\n\t\tReleaseLocalServiceUtil.updateRelease(verified);\n\t}","id":24360,"modified_method":"protected void doRun(String[] ids) throws Exception {\n\n\t\t// Print release information\n\n\t\tSystem.out.println(\"Starting \" + ReleaseInfo.getReleaseInfo());\n\n\t\t// Clear locks\n\n\t\ttry {\n\t\t\tLockServiceUtil.clear();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t// Add shutdown hook\n\n\t\tRuntime.getRuntime().addShutdownHook(new Thread(new ShutdownHook()));\n\n\t\t// Velocity\n\n\t\tLiferayResourceLoader.setListeners(PropsUtil.getArray(\n\t\t\tPropsKeys.VELOCITY_ENGINE_RESOURCE_LISTENERS));\n\n\t\tExtendedProperties props = new ExtendedProperties();\n\n\t\tprops.setProperty(RuntimeConstants.RESOURCE_LOADER, \"servlet\");\n\n\t\tprops.setProperty(\n\t\t\t\"servlet.\" + RuntimeConstants.RESOURCE_LOADER + \".class\",\n\t\t\tLiferayResourceLoader.class.getName());\n\n\t\tprops.setProperty(\n\t\t\tRuntimeConstants.RESOURCE_MANAGER_CLASS,\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_RESOURCE_MANAGER));\n\n\t\tprops.setProperty(\n\t\t\tRuntimeConstants.RESOURCE_MANAGER_CACHE_CLASS,\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_RESOURCE_MANAGER_CACHE));\n\n\t\tprops.setProperty(\n\t\t\t\"velocimacro.library\",\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_VELOCIMACRO_LIBRARY));\n\n\t\tprops.setProperty(\n\t\t\tRuntimeConstants.RUNTIME_LOG_LOGSYSTEM_CLASS,\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_LOGGER));\n\n\t\tprops.setProperty(\n\t\t\t\"runtime.log.logsystem.log4j.category\",\n\t\t\tPropsUtil.get(PropsKeys.VELOCITY_ENGINE_LOGGER_CATEGORY));\n\n\t\tVelocity.setExtendedProperties(props);\n\n\t\ttry {\n\t\t\tVelocity.init();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\t\t}\n\n\t\t// Disable database caching before upgrade\n\n\t\tCacheRegistry.setActive(false);\n\n\t\t// Upgrade\n\n\t\tint buildNumber = ReleaseLocalServiceUtil.getBuildNumberOrCreate();\n\n\t\tif (buildNumber < ReleaseInfo.RELEASE_4_2_1_BUILD_NUMBER) {\n\t\t\tString msg = \"You must first upgrade to Liferay Portal 4.2.1\";\n\n\t\t\t_log.fatal(msg);\n\n\t\t\tthrow new RuntimeException(msg);\n\t\t}\n\n\t\tboolean ranUpgradeProcess = false;\n\n\t\tString[] upgradeProcesses = PropsUtil.getArray(\n\t\t\tPropsKeys.UPGRADE_PROCESSES);\n\n\t\tfor (int i = 0; i < upgradeProcesses.length; i++) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Initializing upgrade \" + upgradeProcesses[i]);\n\t\t\t}\n\n\t\t\tUpgradeProcess upgradeProcess = (UpgradeProcess)InstancePool.get(\n\t\t\t\tupgradeProcesses[i]);\n\n\t\t\tif (upgradeProcess == null) {\n\t\t\t\t_log.error(upgradeProcesses[i] + \" cannot be found\");\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ((upgradeProcess.getThreshold() == 0) ||\n\t\t\t\t(upgradeProcess.getThreshold() > buildNumber)) {\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Running upgrade \" + upgradeProcesses[i]);\n\t\t\t\t}\n\n\t\t\t\tupgradeProcess.upgrade();\n\n\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t_log.info(\"Finished upgrade \" + upgradeProcesses[i]);\n\t\t\t\t}\n\n\t\t\t\tranUpgradeProcess = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Upgrade threshold \" + upgradeProcess.getThreshold() +\n\t\t\t\t\t\t\t\" will not trigger upgrade\");\n\n\t\t\t\t\t_log.debug(\"Skipping upgrade \" + upgradeProcesses[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Class names\n\n\t\tClassNameLocalServiceUtil.checkClassNames();\n\n\t\t// Delete temporary images\n\n\t\tdeleteTemporaryImages();\n\n\t\t// Update indexes\n\n\t\tif (ranUpgradeProcess) {\n\t\t\tDBUtil.getInstance().runSQLTemplate(\"indexes.sql\", false);\n\t\t}\n\n\t\t// Enable database caching after upgrade\n\n\t\tCacheRegistry.setActive(true);\n\n\t\t// Clear the caches only if the upgrade process was run\n\n\t\tif (ranUpgradeProcess) {\n\t\t\tMultiVMPoolUtil.clear();\n\t\t}\n\n\t\t// Messaging\n\n\t\tMessageBus messageBus = (MessageBus)PortalBeanLocatorUtil.locate(\n\t\t\tMessageBus.class.getName());\n\t\tMessageSender messageSender =\n\t\t\t(MessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tMessageSender.class.getName());\n\t\tSynchronousMessageSender synchronousMessageSender =\n\t\t\t(SynchronousMessageSender)PortalBeanLocatorUtil.locate(\n\t\t\t\tSynchronousMessageSender.class.getName());\n\n\t\tMessageBusUtil.init(\n\t\t\tmessageBus, messageSender, synchronousMessageSender);\n\n\t\t// Scheduler\n\n\t\tSchedulerEngineUtil.init(new SchedulerEngineProxy());\n\n\t\tSchedulerEngineUtil.start();\n\n\t\t// Search\n\n\t\tLuceneSearchEngineUtil.init();\n\n\t\tSearchEngineUtil.init(new IndexSearcherImpl(), new IndexWriterImpl());\n\n\t\t// Verify\n\n\t\tRelease release = ReleaseLocalServiceUtil.getRelease();\n\n\t\tint verifyFrequency = GetterUtil.getInteger(\n\t\t\tPropsUtil.get(PropsKeys.VERIFY_FREQUENCY));\n\t\tboolean verified = release.isVerified();\n\n\t\tif ((verifyFrequency == VerifyProcess.ALWAYS) ||\n\t\t\t((verifyFrequency == VerifyProcess.ONCE) && !verified) ||\n\t\t\t(ranUpgradeProcess)) {\n\n\t\t\tString[] verifyProcesses = PropsUtil.getArray(\n\t\t\t\tPropsKeys.VERIFY_PROCESSES);\n\n\t\t\tfor (int i = 0; i < verifyProcesses.length; i++) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Initializing verification \" + verifyProcesses[i]);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tVerifyProcess verifyProcess = (VerifyProcess)Class.forName(\n\t\t\t\t\t\tverifyProcesses[i]).newInstance();\n\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\"Running verification \" + verifyProcesses[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tverifyProcess.verify();\n\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\t\"Finished verification \" + verifyProcesses[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tverified = true;\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException cnfe) {\n\t\t\t\t\t_log.error(verifyProcesses[i] + \" cannot be found\");\n\t\t\t\t}\n\t\t\t\tcatch (InstantiationException ie) {\n\t\t\t\t\t_log.error(verifyProcesses[i] + \" cannot be initiated\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Update release\n\n\t\tReleaseLocalServiceUtil.updateRelease(verified);\n\t}","commit_id":"93b0f9f705201af25b4debcde8267db9e66a58c6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    public void setRequirements(FabricRequirements requirements) throws IOException {\n        try {\n            String json = RequirementsJson.toJSON(requirements);\n            zooKeeper.setData(requirementsJsonPath, json);\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","id":24361,"modified_method":"@Override\n    public void setRequirements(FabricRequirements requirements) throws IOException {\n        try {\n            String json = RequirementsJson.toJSON(requirements);\n            zooKeeper.createOrSetWithParents(requirementsJsonPath, json, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","commit_id":"fcbcc4017f5c7e9037d7f3952948b4191bcd2cef","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    public FabricRequirements getRequirements() {\n        try {\n            if (zooKeeper.exists(requirementsJsonPath) == null) {\n                 return null;\n            } else {\n                String json = zooKeeper.getStringData(requirementsJsonPath);\n                return RequirementsJson.fromJSON(json);\n            }\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","id":24362,"modified_method":"@Override\n    public FabricRequirements getRequirements() {\n        try {\n            FabricRequirements answer = null;\n            if (zooKeeper.exists(requirementsJsonPath) != null) {\n                String json = zooKeeper.getStringData(requirementsJsonPath);\n                answer = RequirementsJson.fromJSON(json);\n            }\n            if (answer == null) {\n                answer = new FabricRequirements();\n            }\n            return answer;\n        } catch (Exception e) {\n            throw new FabricException(e);\n        }\n    }","commit_id":"fcbcc4017f5c7e9037d7f3952948b4191bcd2cef","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public FabricStatus(FabricService service) {\n        this.service = service;\n        requirements = service.getRequirements();\n        if (requirements == null) {\n            requirements = new FabricRequirements();\n        }\n        List<ProfileRequirements> profileRequirements = requirements.getProfileRequirements();\n        for (ProfileRequirements profileRequirement : profileRequirements) {\n            String key = profileRequirement.getProfile();\n            ProfileStatus status = profileStatusMap.get(key);\n            if (status == null) {\n                status = createStatus(key, profileRequirement);\n                profileStatusMap.put(key, status);\n            }\n        }\n        Container[] containers = service.getContainers();\n        for (Container container : containers) {\n            if (container.isAliveAndOK()) {\n                Profile[] profiles = container.getProfiles();\n                for (Profile profile : profiles) {\n                    String key = profile.getId();\n                    ProfileStatus status = profileStatusMap.get(key);\n                    if (status == null) {\n                        status = createStatus(key, null);\n                        profileStatusMap.put(key, status);\n                    }\n                    status.incrementCount();\n                }\n            }\n        }\n    }","id":24363,"modified_method":"public FabricStatus(FabricService service) {\n        this.service = service;\n        requirements = service.getRequirements();\n        List<ProfileRequirements> profileRequirements = requirements.getProfileRequirements();\n        for (ProfileRequirements profileRequirement : profileRequirements) {\n            String key = profileRequirement.getProfile();\n            ProfileStatus status = profileStatusMap.get(key);\n            if (status == null) {\n                status = createStatus(key, profileRequirement);\n                profileStatusMap.put(key, status);\n            }\n        }\n        Container[] containers = service.getContainers();\n        for (Container container : containers) {\n            if (container.isAliveAndOK()) {\n                Profile[] profiles = container.getProfiles();\n                for (Profile profile : profiles) {\n                    String key = profile.getId();\n                    ProfileStatus status = profileStatusMap.get(key);\n                    if (status == null) {\n                        status = createStatus(key, null);\n                        profileStatusMap.put(key, status);\n                    }\n                    status.incrementCount();\n                }\n            }\n        }\n    }","commit_id":"fcbcc4017f5c7e9037d7f3952948b4191bcd2cef","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        PrintStream out = System.out;\n        FabricRequirements requirements = fabricService.getRequirements();\n        if (requirements == null) {\n            out.println(\"No requirements are defined for this fabric. Please create a requirements JSON file in \" + FabricServiceImpl.requirementsJsonPath);\n        } else {\n            printRequirements(out, requirements);\n        }\n        return null;\n    }","id":24364,"modified_method":"@Override\n    protected Object doExecute() throws Exception {\n        checkFabricAvailable();\n        PrintStream out = System.out;\n        FabricRequirements requirements = fabricService.getRequirements();\n        printRequirements(out, requirements);\n        return null;\n    }","commit_id":"fcbcc4017f5c7e9037d7f3952948b4191bcd2cef","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Override\n    protected void printRequirements(PrintStream out, FabricRequirements requirements) {\n        out.println(String.format(\"%-40s %-14s %s\", \"[profile]\", \"[instances]\", \"[health]\"));\n\n        FabricStatus status = getFabricService().getFabricStatus();\n        Collection<ProfileStatus> statuses = status.getProfileStatusMap().values();\n        for (ProfileStatus profile : statuses) {\n            String id = profile.getProfile();\n            int instances = profile.getCount();\n\n            Integer minimum = profile.getMinimumInstances();\n            Integer maximum = profile.getMinimumInstances();\n            double health = profile.getHealth(instances);\n\n            out.println(String.format(\"%-40s %-14s %s\", id, instances, percentText(health)));\n        }\n    }","id":24365,"modified_method":"protected void printStatus(PrintStream out, FabricStatus status) {\n        out.println(String.format(\"%-40s %-14s %s\", \"[profile]\", \"[instances]\", \"[health]\"));\n\n        Collection<ProfileStatus> statuses = status.getProfileStatusMap().values();\n        for (ProfileStatus profile : statuses) {\n            String id = profile.getProfile();\n            int instances = profile.getCount();\n\n            Integer minimum = profile.getMinimumInstances();\n            Integer maximum = profile.getMinimumInstances();\n            double health = profile.getHealth(instances);\n\n            out.println(String.format(\"%-40s %-14s %s\", id, instances, percentText(health)));\n        }\n    }","commit_id":"fcbcc4017f5c7e9037d7f3952948b4191bcd2cef","url":"https://github.com/fabric8io/fabric8"},{"original_method":"public Object deserialize(String json) {\n\t\ttry {\n\t\t\tObject obj = _serializer.fromJSON(json);\n\n\t\t\tif (obj instanceof LongWrapper) {\n\t\t\t\tLongWrapper longWrapper = (LongWrapper)obj;\n\n\t\t\t\treturn longWrapper.getValue();\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn obj;\n\t\t\t}\n\t\t}\n\t\tcatch (UnmarshallException ue) {\n\t\t\t _log.error(ue, ue);\n\n\t\t\tthrow new IllegalStateException(\"Unable to deserialize oject\", ue);\n\t\t}\n\t}","id":24366,"modified_method":"public Object deserialize(String json) {\n\t\ttry {\n\t\t\treturn _serializer.fromJSON(json);\n\t\t}\n\t\tcatch (UnmarshallException ue) {\n\t\t\t _log.error(ue, ue);\n\n\t\t\tthrow new IllegalStateException(\"Unable to deserialize oject\", ue);\n\t\t}\n\t}","commit_id":"d90d2f6c5f86dcc7736fb99c7707220cc9a19fd4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String serialize(Object obj) {\n\t\ttry {\n\t\t\tif (obj instanceof Long) {\n\t\t\t\tobj = new LongWrapper((Long)obj);\n\t\t\t}\n\n\t\t\treturn _serializer.toJSON(obj);\n\t\t}\n\t\tcatch (MarshallException me) {\n\t\t\t_log.error(me, me);\n\n\t\t\tthrow new IllegalStateException(\"Unable to serialize oject\", me);\n\t\t}\n\t}","id":24367,"modified_method":"public String serialize(Object obj) {\n\t\ttry {\n\t\t\treturn _serializer.toJSON(obj);\n\t\t}\n\t\tcatch (MarshallException me) {\n\t\t\t_log.error(me, me);\n\n\t\t\tthrow new IllegalStateException(\"Unable to serialize oject\", me);\n\t\t}\n\t}","commit_id":"d90d2f6c5f86dcc7736fb99c7707220cc9a19fd4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected OETLProcessor getProcessor(final String cfg) {\n    final OETLProcessor proc = new OETLProcessor();\n    proc.getFactory().registerLoader(TestLoader.class);\n    proc.parse(new ODocument().fromJSON(cfg, \"noMap\"), null);\n    return proc;\n  }","id":24368,"modified_method":"protected OETLProcessor getProcessor(final String cfgJson) {\n    ODocument cfg = new ODocument().fromJSON(cfgJson, \"noMap\");\n    return getProcessor(cfg);\n  }","commit_id":"f0b48784bdfe6f1277038a59d3a41ace3e7ad769","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static void incrementViewCounter(HttpPrincipal httpPrincipal,\n\t\tjava.lang.String className, long classPK)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\ttry {\n\t\t\tMethodKey methodKey = new MethodKey(AssetEntryServiceUtil.class.getName(),\n\t\t\t\t\t\"incrementViewCounter\", _incrementViewCounterParameterTypes6);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(methodKey,\n\t\t\t\t\tclassName, classPK);\n\n\t\t\ttry {\n\t\t\t\tTunnelUtil.invoke(httpPrincipal, methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)e;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.SystemException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.SystemException)e;\n\t\t\t\t}\n\n\t\t\t\tthrow new com.liferay.portal.kernel.exception.SystemException(e);\n\t\t\t}\n\t\t}\n\t\tcatch (com.liferay.portal.kernel.exception.SystemException se) {\n\t\t\t_log.error(se, se);\n\n\t\t\tthrow se;\n\t\t}\n\t}","id":24369,"modified_method":"public static com.liferay.portlet.asset.model.AssetEntry incrementViewCounter(\n\t\tHttpPrincipal httpPrincipal, java.lang.String className, long classPK)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\ttry {\n\t\t\tMethodKey methodKey = new MethodKey(AssetEntryServiceUtil.class.getName(),\n\t\t\t\t\t\"incrementViewCounter\", _incrementViewCounterParameterTypes6);\n\n\t\t\tMethodHandler methodHandler = new MethodHandler(methodKey,\n\t\t\t\t\tclassName, classPK);\n\n\t\t\tObject returnObj = null;\n\n\t\t\ttry {\n\t\t\t\treturnObj = TunnelUtil.invoke(httpPrincipal, methodHandler);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.PortalException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.PortalException)e;\n\t\t\t\t}\n\n\t\t\t\tif (e instanceof com.liferay.portal.kernel.exception.SystemException) {\n\t\t\t\t\tthrow (com.liferay.portal.kernel.exception.SystemException)e;\n\t\t\t\t}\n\n\t\t\t\tthrow new com.liferay.portal.kernel.exception.SystemException(e);\n\t\t\t}\n\n\t\t\treturn (com.liferay.portlet.asset.model.AssetEntry)returnObj;\n\t\t}\n\t\tcatch (com.liferay.portal.kernel.exception.SystemException se) {\n\t\t\t_log.error(se, se);\n\n\t\t\tthrow se;\n\t\t}\n\t}","commit_id":"9425f8c961ab4773a9b4f3e577acd5d5a28a6c9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void incrementViewCounter(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = getGuestOrUser();\n\n\t\tassetEntryLocalService.incrementViewCounter(\n\t\t\tuser.getUserId(), className, classPK, 1);\n\n\t\tif (!user.isDefaultUser()) {\n\t\t\tAssetEntry assetEntry = assetEntryLocalService.getEntry(\n\t\t\t\tclassName, classPK);\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuser.getUserId(), assetEntry.getGroupId(), className, classPK,\n\t\t\t\tSocialActivityConstants.TYPE_VIEW, StringPool.BLANK, 0);\n\t\t}\n\t}","id":24370,"modified_method":"public AssetEntry incrementViewCounter(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = getGuestOrUser();\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.incrementViewCounter(\n\t\t\tuser.getUserId(), className, classPK, 1);\n\n\t\tif (!user.isDefaultUser()) {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuser.getUserId(), assetEntry.getGroupId(), className, classPK,\n\t\t\t\tSocialActivityConstants.TYPE_VIEW, StringPool.BLANK, 0);\n\t\t}\n\n\t\treturn assetEntry;\n\t}","commit_id":"9425f8c961ab4773a9b4f3e577acd5d5a28a6c9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void incrementViewCounter(java.lang.String className,\n\t\tlong classPK) throws RemoteException {\n\t\ttry {\n\t\t\tAssetEntryServiceUtil.incrementViewCounter(className, classPK);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new RemoteException(e.getMessage());\n\t\t}\n\t}","id":24371,"modified_method":"public static com.liferay.portlet.asset.model.AssetEntrySoap incrementViewCounter(\n\t\tjava.lang.String className, long classPK) throws RemoteException {\n\t\ttry {\n\t\t\tcom.liferay.portlet.asset.model.AssetEntry returnValue = AssetEntryServiceUtil.incrementViewCounter(className,\n\t\t\t\t\tclassPK);\n\n\t\t\treturn com.liferay.portlet.asset.model.AssetEntrySoap.toSoapModel(returnValue);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new RemoteException(e.getMessage());\n\t\t}\n\t}","commit_id":"9425f8c961ab4773a9b4f3e577acd5d5a28a6c9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void incrementViewCounter(java.lang.String className,\n\t\tlong classPK)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\tgetService().incrementViewCounter(className, classPK);\n\t}","id":24372,"modified_method":"public static com.liferay.portlet.asset.model.AssetEntry incrementViewCounter(\n\t\tjava.lang.String className, long classPK)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn getService().incrementViewCounter(className, classPK);\n\t}","commit_id":"9425f8c961ab4773a9b4f3e577acd5d5a28a6c9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void incrementViewCounter(java.lang.String className, long classPK)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\t_assetEntryService.incrementViewCounter(className, classPK);\n\t}","id":24373,"modified_method":"public com.liferay.portlet.asset.model.AssetEntry incrementViewCounter(\n\t\tjava.lang.String className, long classPK)\n\t\tthrows com.liferay.portal.kernel.exception.PortalException,\n\t\t\tcom.liferay.portal.kernel.exception.SystemException {\n\t\treturn _assetEntryService.incrementViewCounter(className, classPK);\n\t}","commit_id":"9425f8c961ab4773a9b4f3e577acd5d5a28a6c9e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@BufferedIncrement(incrementClass = NumberIncrement.class)\n\tpublic void incrementViewCounter(\n\t\t\tlong userId, String className, long classPK, int increment)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!PropsValues.ASSET_ENTRY_INCREMENT_VIEW_COUNTER_ENABLED) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (classPK <= 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tAssetEntry entry = assetEntryPersistence.fetchByC_C(\n\t\t\tclassNameId, classPK);\n\n\t\tif (entry != null) {\n\t\t\tentry.setViewCount(entry.getViewCount() + increment);\n\n\t\t\tassetEntryPersistence.update(entry, false);\n\n\t\t\t// Social\n\n\t\t\tif ((userId > 0) && (entry.getUserId() != userId)) {\n\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\tuserId, entry.getEntryId(), ActionKeys.VIEW,\n\t\t\t\t\tStringPool.BLANK);\n\t\t\t}\n\t\t}\n\t}","id":24374,"modified_method":"@BufferedIncrement(incrementClass = NumberIncrement.class)\n\tpublic AssetEntry incrementViewCounter(\n\t\t\tlong userId, String className, long classPK, int increment)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (!PropsValues.ASSET_ENTRY_INCREMENT_VIEW_COUNTER_ENABLED) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (classPK <= 0) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlong classNameId = PortalUtil.getClassNameId(className);\n\n\t\tAssetEntry entry = assetEntryPersistence.fetchByC_C(\n\t\t\tclassNameId, classPK);\n\n\t\tif (entry == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tentry.setViewCount(entry.getViewCount() + increment);\n\n\t\tassetEntryPersistence.update(entry, false);\n\n\t\t// Social\n\n\t\tif ((userId > 0) && (entry.getUserId() != userId)) {\n\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\tuserId, entry.getEntryId(), ActionKeys.VIEW, StringPool.BLANK);\n\t\t}\n\n\t\treturn entry;\n\t}","commit_id":"acb99a97c5761bdad1d3ec73db8eb0f458734766","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void incrementViewCounter(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tassetEntryLocalService.incrementViewCounter(\n\t\t\tgetGuestOrUserId(), className, classPK, 1);\n\t}","id":24375,"modified_method":"public AssetEntry incrementViewCounter(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn assetEntryLocalService.incrementViewCounter(\n\t\t\tgetGuestOrUserId(), className, classPK, 1);\n\t}","commit_id":"acb99a97c5761bdad1d3ec73db8eb0f458734766","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@BufferedIncrement(incrementClass = NumberIncrement.class)\n\tpublic void incrementViewCounter(long threadId, int increment)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(threadId);\n\n\t\tthread.setViewCount(thread.getViewCount() + increment);\n\n\t\tmbThreadPersistence.update(thread, false);\n\t}","id":24376,"modified_method":"@BufferedIncrement(incrementClass = NumberIncrement.class)\n\tpublic MBThread incrementViewCounter(long threadId, int increment)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(threadId);\n\n\t\tthread.setViewCount(thread.getViewCount() + increment);\n\n\t\tmbThreadPersistence.update(thread, false);\n\n\t\treturn thread;\n\t}","commit_id":"acb99a97c5761bdad1d3ec73db8eb0f458734766","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected final void cacheDomElement(final XmlTag tag) {\n    synchronized (PsiLock.LOCK) {\n      myXmlTag = tag;\n      DomManagerImpl.setCachedElement(tag, this);\n    }\n  }","id":24377,"modified_method":"protected final void cacheDomElement(final XmlTag tag) {\n    synchronized (PsiLock.LOCK) {\n      DomManagerImpl.setCachedElement(myXmlTag, null);\n      myXmlTag = tag;\n      DomManagerImpl.setCachedElement(tag, this);\n    }\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final DomElement addChild(final String tagName, final Class aClass, int index) throws IncorrectOperationException {\n    createFixedChildrenTags(tagName, myMethodsMap.getFixedChildrenCount(tagName));\n    final DomElement element = createCollectionElement(aClass, addEmptyTag(tagName, index));\n    myManager.fireEvent(new CollectionElementAddedEvent(element, tagName));\n    return element;\n  }","id":24378,"modified_method":"public final DomElement addChild(final String tagName, final Class aClass, int index) throws IncorrectOperationException {\n    createFixedChildrenTags(tagName, myMethodsMap.getFixedChildrenCount(tagName));\n    return addCollectionElement(aClass, addEmptyTag(tagName, index));\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private XmlTag addEmptyTag(final String tagName, int index) throws IncorrectOperationException {\n    final XmlTag tag = getXmlTag();\n    final XmlTag[] subTags = tag.findSubTags(tagName);\n    if (subTags.length < index) {\n      index = subTags.length;\n    }\n    final boolean changing = myManager.isChanging();\n    myManager.setChanging(true);\n    try {\n      XmlTag newTag = createEmptyTag(tagName);\n      if (index == 0) {\n        return (XmlTag)tag.add(newTag);\n      }\n\n      return (XmlTag)tag.addAfter(newTag, subTags[index - 1]);\n    }\n    finally {\n      myManager.setChanging(changing);\n    }\n  }","id":24379,"modified_method":"private XmlTag addEmptyTag(final String tagName, int index) throws IncorrectOperationException {\n    final XmlTag tag = getXmlTag();\n    final XmlTag[] subTags = tag.findSubTags(tagName);\n    if (subTags.length < index) {\n      index = subTags.length;\n    }\n    final boolean changing = myManager.setChanging(true);\n    try {\n      XmlTag newTag = createEmptyTag(tagName);\n      if (index == 0) {\n        return (XmlTag)tag.add(newTag);\n      }\n\n      return (XmlTag)tag.addAfter(newTag, subTags[index - 1]);\n    }\n    finally {\n      myManager.setChanging(changing);\n    }\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void fireUndefinedEvent() {\n    myManager.fireEvent(new ElementUndefinedEvent(this));\n  }","id":24380,"modified_method":"protected final void fireUndefinedEvent() {\n    myManager.fireEvent(new ElementUndefinedEvent(getProxy()));\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final XmlTag ensureTagExists() {\n    if (getXmlTag() == null) {\n      final boolean changing = myManager.isChanging();\n      myManager.setChanging(true);\n      try {\n        setXmlTag(createEmptyTag());\n      }\n      catch (IncorrectOperationException e) {\n        LOG.error(e);\n      }\n      finally {\n        myManager.setChanging(changing);\n        myManager.fireEvent(new ElementDefinedEvent(this));\n      }\n    }\n    return getXmlTag();\n  }","id":24381,"modified_method":"public final XmlTag ensureTagExists() {\n    final XmlTag tag = getXmlTag();\n    if (tag != null) return tag;\n\n    final boolean changing = myManager.setChanging(true);\n    try {\n      setXmlTag(createEmptyTag());\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    finally {\n      myManager.setChanging(changing);\n      myManager.fireEvent(new ElementDefinedEvent(this));\n    }\n    return getXmlTag();\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void visitDocumentChanged(final XmlDocumentChanged change) {\n    final DomFileElementImpl element = getCachedElement((XmlFile)change.getDocument().getContainingFile());\n    if (element != null) {\n      final XmlTag rootTag = element.getRootTag();\n      if (rootTag != null) {\n        invalidateSubtree(rootTag);\n      }\n      element.invalidateRoot();\n      fireEvent(new ContentsChangedEvent(element));\n    }\n  }","id":24382,"modified_method":"public final void visitDocumentChanged(final XmlDocumentChanged change) {\n    final DomFileElementImpl element = getCachedElement((XmlFile)change.getDocument().getContainingFile());\n    if (element != null) {\n      final XmlTag rootTag = element.getRootTag();\n      if (rootTag != null) {\n        invalidateSubtree(rootTag, true);\n      }\n      element.invalidateRoot();\n      fireEvent(new ContentsChangedEvent(element));\n    }\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void xmlElementChanged(final XmlElement xmlElement) {\n    if (xmlElement instanceof XmlText) {\n      fireTagValueChanged(((XmlText)xmlElement).getParentTag());\n    }\n  }","id":24383,"modified_method":"private void xmlElementChanged(final XmlElement xmlElement) {\n    if (isTagValueChange(xmlElement)) {\n      fireTagValueChanged(((XmlText)xmlElement).getParentTag());\n    }\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void invalidateSubtree(final XmlTag root) {\n    final DomInvocationHandler element = getCachedElement(root);\n    if (element != null) {\n      setCachedElement(root, null);\n      element.invalidate();\n      for (XmlTag tag : root.getSubTags()) {\n        invalidateSubtree(tag);\n      }\n    }\n  }","id":24384,"modified_method":"static void invalidateSubtree(final XmlTag root, final boolean invalidateRoot) {\n    final DomInvocationHandler element = getCachedElement(root);\n    if (element != null) {\n      setCachedElement(root, null);\n      if (invalidateRoot) {\n        element.invalidate();\n      }\n      for (XmlTag tag : root.getSubTags()) {\n        invalidateSubtree(tag, true);\n      }\n    }\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void visitXmlTagChildAdd(final XmlTagChildAdd change) {\n    final XmlTag tag = change.getTag();\n\n    final XmlTagChild child = change.getChild();\n    if (child instanceof XmlText) {\n      fireTagValueChanged(tag);\n    }\n  }","id":24385,"modified_method":"public final void visitXmlTagChildAdd(final XmlTagChildAdd change) {\n    final XmlTagChild child = change.getChild();\n    final XmlTag tag = change.getTag();\n    if (isTagValueChange(child)) {\n      fireTagValueChanged(tag);\n    }\n    if (child instanceof XmlTag) {\n      XmlTag childTag = (XmlTag)child;\n      final DomInvocationHandler element = getCachedElement(tag);\n      if (element != null) {\n        element.processChildTagAdded(childTag);\n      }\n    }\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void visitXmlTagChildRemoved(final XmlTagChildRemoved change) {\n    final XmlTagChild child = change.getChild();\n    if (child instanceof XmlText) {\n      fireTagValueChanged(change.getTag());\n    }\n  }","id":24386,"modified_method":"public final void visitXmlTagChildRemoved(final XmlTagChildRemoved change) {\n    final XmlTag tag = change.getTag();\n    if (isTagValueChange(change.getChild(), tag)) {\n      fireTagValueChanged(tag);\n    }\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void visitXmlTagNameChanged(final XmlTagNameChanged xmlTagNameChanged) {\n\n  }","id":24387,"modified_method":"public final void visitXmlTagNameChanged(final XmlTagNameChanged xmlTagNameChanged) {\n    xmlElementChanged(xmlTagNameChanged.getTag());\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final void setChanging(final boolean changing) {\n    myChanging = changing;\n  }","id":24388,"modified_method":"public final synchronized boolean setChanging(final boolean changing) {\n    boolean oldChanging = myChanging;\n    myChanging = changing;\n    return oldChanging;\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void undefine() {\n    final DomInvocationHandler parent = getParentHandler();\n    parent.checkInitialized();\n    final XmlTag[] subTags = parent.getXmlTag().findSubTags(getTagName());\n    if (subTags.length <= myIndex) {\n      return;\n    }\n\n    try {\n      XmlTag tag = getXmlTag();\n      assert tag != null;\n      if (subTags.length == myIndex + 1) {\n        myXmlTag = null;\n        tag.delete();\n      } else {\n        cacheDomElement((XmlTag) tag.replace(createEmptyTag()));\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    fireUndefinedEvent();\n  }","id":24389,"modified_method":"public void undefine() {\n    final DomInvocationHandler parent = getParentHandler();\n    parent.checkInitialized();\n    final XmlTag[] subTags = parent.getXmlTag().findSubTags(getTagName());\n    if (subTags.length <= myIndex) {\n      return;\n    }\n\n    final boolean changing = getManager().setChanging(true);\n    try {\n      XmlTag tag = getXmlTag();\n      assert tag != null;\n      if (subTags.length == myIndex + 1) {\n        myXmlTag = null;\n        tag.delete();\n      } else {\n        cacheDomElement((XmlTag) tag.replace(createEmptyTag()));\n      }\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    } finally {\n      getManager().setChanging(changing);\n    }\n    fireUndefinedEvent();\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object invoke(final DomInvocationHandler handler, final Object[] args) throws Throwable {\n    XmlTag tag = handler.ensureTagExists();\n    final DomManagerImpl manager = handler.getManager();\n    final boolean changing = manager.isChanging();\n    manager.setChanging(true);\n    try {\n      final String oldValue = getValue(tag);\n      if (args[0] == null) {\n        clearValue(tag);\n        manager.fireEvent(createEvent(handler, oldValue, null));\n      } else {\n        final String newValue = myConverter.toString(args[0], new ConvertContextImpl(handler));\n        setValue(tag, newValue);\n        manager.fireEvent(createEvent(handler, oldValue, newValue));\n      }\n    }\n    finally {\n      manager.setChanging(changing);\n    }\n    return null;\n  }","id":24390,"modified_method":"public Object invoke(final DomInvocationHandler handler, final Object[] args) throws Throwable {\n    XmlTag tag = handler.ensureTagExists();\n    final DomManagerImpl manager = handler.getManager();\n    final boolean changing = manager.setChanging(true);\n    try {\n      final String oldValue = getValue(tag);\n      if (args[0] == null) {\n        clearValue(tag);\n        manager.fireEvent(createEvent(handler, oldValue, null));\n      } else {\n        final String newValue = myConverter.toString(args[0], new ConvertContextImpl(handler));\n        setValue(tag, newValue);\n        manager.fireEvent(createEvent(handler, oldValue, newValue));\n      }\n    }\n    finally {\n      manager.setChanging(changing);\n    }\n    return null;\n  }","commit_id":"7fcd339b9b9cf0899d638a3ae477c84097a4b13e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DefaultCachedMetaData(ModuleDescriptorCacheEntry entry, ModuleDescriptor moduleDescriptor, BuildCommencedTimeProvider timeProvider) {\n        this.moduleSource = entry.moduleSource;\n        this.descriptorHash = entry.moduleDescriptorHash;\n        this.ageMillis = timeProvider.getCurrentTime() - entry.createTimestamp;\n        if (moduleDescriptor == null) {\n            metaData = null;\n        } else {\n            metaData = new ModuleDescriptorAdapter(moduleDescriptor);\n            metaData.setChanging(entry.isChanging);\n        }\n    }","id":24391,"modified_method":"public DefaultCachedMetaData(ModuleDescriptorCacheEntry entry, ModuleDescriptor moduleDescriptor, BuildCommencedTimeProvider timeProvider) {\n        this.moduleSource = entry.moduleSource;\n        this.descriptorHash = entry.moduleDescriptorHash;\n        this.ageMillis = timeProvider.getCurrentTime() - entry.createTimestamp;\n        if (moduleDescriptor == null) {\n            metaData = null;\n        } else {\n            ModuleDescriptorAdapter moduleDescriptorAdapter = new ModuleDescriptorAdapter(moduleDescriptor);\n            moduleDescriptorAdapter.setChanging(entry.isChanging);\n            moduleDescriptorAdapter.setMetaDataOnly(entry.isMetaDataOnly);\n            metaData = moduleDescriptorAdapter;\n        }\n    }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"public VersionNumber getArtifactCacheLayoutVersion() {\n        if (isSameOrNewer(\"1.12-rc-1\")) {\n            return VersionNumber.parse(\"2.3\");\n        } else if (isSameOrNewer(\"1.11-rc-1\")) {\n            return VersionNumber.parse(\"2.2\");\n        } else if (isSameOrNewer(\"1.9-rc-2\")) {\n            return VersionNumber.parse(\"2.1\");\n        } else if (isSameOrNewer(\"1.9-rc-1\")) {\n            return VersionNumber.parse(\"1.31\");\n        } else if (isSameOrNewer(\"1.7-rc-1\")) {\n            return VersionNumber.parse(\"0.26\");\n        } else if (isSameOrNewer(\"1.6-rc-1\")) {\n            return VersionNumber.parse(\"0.24\");\n        } else if (isSameOrNewer(\"1.4-rc-1\")) {\n            return VersionNumber.parse(\"0.23\");\n        } else if (isSameOrNewer(\"1.3\")) {\n            return VersionNumber.parse(\"0.15\");\n        } else {\n            return VersionNumber.parse(\"0.1\");\n        }\n    }","id":24392,"modified_method":"public VersionNumber getArtifactCacheLayoutVersion() {\n        if (isSameOrNewer(\"1.12-rc-1\")) {\n            return VersionNumber.parse(\"2.4\");\n        } else if (isSameOrNewer(\"1.11-rc-1\")) {\n            return VersionNumber.parse(\"2.2\");\n        } else if (isSameOrNewer(\"1.9-rc-2\")) {\n            return VersionNumber.parse(\"2.1\");\n        } else if (isSameOrNewer(\"1.9-rc-1\")) {\n            return VersionNumber.parse(\"1.31\");\n        } else if (isSameOrNewer(\"1.7-rc-1\")) {\n            return VersionNumber.parse(\"0.26\");\n        } else if (isSameOrNewer(\"1.6-rc-1\")) {\n            return VersionNumber.parse(\"0.24\");\n        } else if (isSameOrNewer(\"1.4-rc-1\")) {\n            return VersionNumber.parse(\"0.23\");\n        } else if (isSameOrNewer(\"1.3\")) {\n            return VersionNumber.parse(\"0.15\");\n        } else {\n            return VersionNumber.parse(\"0.1\");\n        }\n    }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedMetaData cacheMetaData(ModuleVersionRepository repository, ModuleVersionMetaData metaData, ModuleSource moduleSource) {\n        return cacheModuleDescriptor(repository, metaData.getId(), metaData.getDescriptor(), moduleSource, metaData.isChanging());\n    }","id":24393,"modified_method":"public CachedMetaData cacheMetaData(ModuleVersionRepository repository, ModuleVersionMetaData metaData, ModuleSource moduleSource) {\n        ModuleDescriptor moduleDescriptor = metaData.getDescriptor();\n        LOGGER.debug(\"Recording module descriptor in cache: {} [changing = {}]\", moduleDescriptor.getModuleRevisionId(), metaData.isChanging());\n        LocallyAvailableResource resource = moduleDescriptorStore.putModuleDescriptor(repository, moduleDescriptor);\n        ModuleDescriptorCacheEntry entry = createEntry(metaData.isChanging(), metaData.isMetaDataOnly(), resource.getSha1(), moduleSource);\n        getCache().put(createKey(repository, metaData.getId()), entry);\n        return new DefaultCachedMetaData(entry, null, timeProvider);\n    }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"public void write(Encoder encoder, ModuleDescriptorCacheEntry value) throws Exception {\n            encoder.writeBoolean(value.isMissing);\n            encoder.writeBoolean(value.isChanging);\n            encoder.writeLong(value.createTimestamp);\n            moduleSourceSerializer.write(encoder, value.moduleSource);\n            byte[] hash = value.moduleDescriptorHash.toByteArray();\n            encoder.writeBinary(hash);\n        }","id":24394,"modified_method":"public void write(Encoder encoder, ModuleDescriptorCacheEntry value) throws Exception {\n            encoder.writeBoolean(value.isMissing);\n            encoder.writeBoolean(value.isChanging);\n            encoder.writeBoolean(value.isMetaDataOnly);\n            encoder.writeLong(value.createTimestamp);\n            moduleSourceSerializer.write(encoder, value.moduleSource);\n            byte[] hash = value.moduleDescriptorHash.toByteArray();\n            encoder.writeBinary(hash);\n        }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleDescriptorCacheEntry read(Decoder decoder) throws Exception {\n            boolean isMissing = decoder.readBoolean();\n            boolean isChanging = decoder.readBoolean();\n            long createTimestamp = decoder.readLong();\n            ModuleSource moduleSource = moduleSourceSerializer.read(decoder);\n            byte[] encodedHash = decoder.readBinary();\n            BigInteger hash = new BigInteger(encodedHash);\n            return new ModuleDescriptorCacheEntry(isChanging, isMissing, createTimestamp, hash, moduleSource);\n        }","id":24395,"modified_method":"public ModuleDescriptorCacheEntry read(Decoder decoder) throws Exception {\n            boolean isMissing = decoder.readBoolean();\n            boolean isChanging = decoder.readBoolean();\n            boolean isMetaData = decoder.readBoolean();\n            long createTimestamp = decoder.readLong();\n            ModuleSource moduleSource = moduleSourceSerializer.read(decoder);\n            byte[] encodedHash = decoder.readBinary();\n            BigInteger hash = new BigInteger(encodedHash);\n            return new ModuleDescriptorCacheEntry(isChanging, isMetaData, isMissing, createTimestamp, hash, moduleSource);\n        }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleDescriptorCacheEntry createMissingEntry(boolean changing) {\n        return new ModuleDescriptorCacheEntry(changing, true, timeProvider.getCurrentTime(), BigInteger.ZERO, null);\n    }","id":24396,"modified_method":"private ModuleDescriptorCacheEntry createMissingEntry(boolean changing) {\n        return new ModuleDescriptorCacheEntry(changing, false, true, timeProvider.getCurrentTime(), BigInteger.ZERO, null);\n    }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedMetaData cacheMissing(ModuleVersionRepository repository, ModuleVersionIdentifier id) {\n        return cacheModuleDescriptor(repository, id, null, null, false);\n    }","id":24397,"modified_method":"public CachedMetaData cacheMissing(ModuleVersionRepository repository, ModuleVersionIdentifier id) {\n        LOGGER.debug(\"Recording absence of module descriptor in cache: {} [changing = {}]\", id, false);\n        ModuleDescriptorCacheEntry entry = createMissingEntry(false);\n        getCache().put(createKey(repository, id), entry);\n        return new DefaultCachedMetaData(entry, null, timeProvider);\n    }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleDescriptorCacheEntry createEntry(boolean changing, HashValue moduleDescriptorHash, ModuleSource moduleSource) {\n        return new ModuleDescriptorCacheEntry(changing, false, timeProvider.getCurrentTime(), moduleDescriptorHash.asBigInteger(), moduleSource);\n    }","id":24398,"modified_method":"private ModuleDescriptorCacheEntry createEntry(boolean changing, boolean metaDataOnly, HashValue moduleDescriptorHash, ModuleSource moduleSource) {\n        return new ModuleDescriptorCacheEntry(changing, metaDataOnly, false, timeProvider.getCurrentTime(), moduleDescriptorHash.asBigInteger(), moduleSource);\n    }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"ModuleDescriptorCacheEntry(boolean isChanging, boolean isMissing, long createTimestamp, BigInteger moduleDescriptorHash, ModuleSource moduleSource) {\n        this.isChanging = isChanging;\n        this.isMissing = isMissing;\n        this.createTimestamp = createTimestamp;\n        this.moduleSource = moduleSource;\n        this.moduleDescriptorHash = moduleDescriptorHash;\n    }","id":24399,"modified_method":"ModuleDescriptorCacheEntry(boolean isChanging, boolean isMetaDataOnly, boolean isMissing, long createTimestamp, BigInteger moduleDescriptorHash, ModuleSource moduleSource) {\n        this.isChanging = isChanging;\n        this.isMetaDataOnly = isMetaDataOnly;\n        this.isMissing = isMissing;\n        this.createTimestamp = createTimestamp;\n        this.moduleSource = moduleSource;\n        this.moduleDescriptorHash = moduleDescriptorHash;\n    }","commit_id":"26709c5619626c9c1a43dba245b3483ca074f211","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultCachedMetaData(ModuleDescriptorCacheEntry entry, ModuleDescriptor moduleDescriptor, BuildCommencedTimeProvider timeProvider) {\n        this.moduleSource = entry.moduleSource;\n        this.descriptorHash = entry.moduleDescriptorHash;\n        this.ageMillis = timeProvider.getCurrentTime() - entry.createTimestamp;\n        if (moduleDescriptor == null) {\n            metaData = null;\n        } else {\n            metaData = new ModuleDescriptorAdapter(moduleDescriptor);\n            metaData.setChanging(entry.isChanging);\n        }\n    }","id":24400,"modified_method":"public DefaultCachedMetaData(ModuleDescriptorCacheEntry entry, ModuleDescriptor moduleDescriptor, BuildCommencedTimeProvider timeProvider) {\n        this.moduleSource = entry.moduleSource;\n        this.descriptorHash = entry.moduleDescriptorHash;\n        this.ageMillis = timeProvider.getCurrentTime() - entry.createTimestamp;\n        if (moduleDescriptor == null) {\n            metaData = null;\n        } else {\n            ModuleDescriptorAdapter moduleDescriptorAdapter = new ModuleDescriptorAdapter(moduleDescriptor);\n            moduleDescriptorAdapter.setChanging(entry.isChanging);\n            moduleDescriptorAdapter.setMetaDataOnly(entry.isMetaDataOnly);\n            metaData = moduleDescriptorAdapter;\n        }\n    }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"public VersionNumber getArtifactCacheLayoutVersion() {\n        if (isSameOrNewer(\"1.12-rc-1\")) {\n            return VersionNumber.parse(\"2.3\");\n        } else if (isSameOrNewer(\"1.11-rc-1\")) {\n            return VersionNumber.parse(\"2.2\");\n        } else if (isSameOrNewer(\"1.9-rc-2\")) {\n            return VersionNumber.parse(\"2.1\");\n        } else if (isSameOrNewer(\"1.9-rc-1\")) {\n            return VersionNumber.parse(\"1.31\");\n        } else if (isSameOrNewer(\"1.7-rc-1\")) {\n            return VersionNumber.parse(\"0.26\");\n        } else if (isSameOrNewer(\"1.6-rc-1\")) {\n            return VersionNumber.parse(\"0.24\");\n        } else if (isSameOrNewer(\"1.4-rc-1\")) {\n            return VersionNumber.parse(\"0.23\");\n        } else if (isSameOrNewer(\"1.3\")) {\n            return VersionNumber.parse(\"0.15\");\n        } else {\n            return VersionNumber.parse(\"0.1\");\n        }\n    }","id":24401,"modified_method":"public VersionNumber getArtifactCacheLayoutVersion() {\n        if (isSameOrNewer(\"1.12-rc-1\")) {\n            return VersionNumber.parse(\"2.4\");\n        } else if (isSameOrNewer(\"1.11-rc-1\")) {\n            return VersionNumber.parse(\"2.2\");\n        } else if (isSameOrNewer(\"1.9-rc-2\")) {\n            return VersionNumber.parse(\"2.1\");\n        } else if (isSameOrNewer(\"1.9-rc-1\")) {\n            return VersionNumber.parse(\"1.31\");\n        } else if (isSameOrNewer(\"1.7-rc-1\")) {\n            return VersionNumber.parse(\"0.26\");\n        } else if (isSameOrNewer(\"1.6-rc-1\")) {\n            return VersionNumber.parse(\"0.24\");\n        } else if (isSameOrNewer(\"1.4-rc-1\")) {\n            return VersionNumber.parse(\"0.23\");\n        } else if (isSameOrNewer(\"1.3\")) {\n            return VersionNumber.parse(\"0.15\");\n        } else {\n            return VersionNumber.parse(\"0.1\");\n        }\n    }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedMetaData cacheMissing(ModuleVersionRepository repository, ModuleVersionIdentifier id) {\n        return cacheModuleDescriptor(repository, id, null, null, false);\n    }","id":24402,"modified_method":"public CachedMetaData cacheMissing(ModuleVersionRepository repository, ModuleVersionIdentifier id) {\n        LOGGER.debug(\"Recording absence of module descriptor in cache: {} [changing = {}]\", id, false);\n        ModuleDescriptorCacheEntry entry = createMissingEntry(false);\n        getCache().put(createKey(repository, id), entry);\n        return new DefaultCachedMetaData(entry, null, timeProvider);\n    }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"public void write(Encoder encoder, ModuleDescriptorCacheEntry value) throws Exception {\n            encoder.writeBoolean(value.isMissing);\n            encoder.writeBoolean(value.isChanging);\n            encoder.writeLong(value.createTimestamp);\n            moduleSourceSerializer.write(encoder, value.moduleSource);\n            byte[] hash = value.moduleDescriptorHash.toByteArray();\n            encoder.writeBinary(hash);\n        }","id":24403,"modified_method":"public void write(Encoder encoder, ModuleDescriptorCacheEntry value) throws Exception {\n            encoder.writeBoolean(value.isMissing);\n            encoder.writeBoolean(value.isChanging);\n            encoder.writeBoolean(value.isMetaDataOnly);\n            encoder.writeLong(value.createTimestamp);\n            moduleSourceSerializer.write(encoder, value.moduleSource);\n            byte[] hash = value.moduleDescriptorHash.toByteArray();\n            encoder.writeBinary(hash);\n        }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleDescriptorCacheEntry createMissingEntry(boolean changing) {\n        return new ModuleDescriptorCacheEntry(changing, true, timeProvider.getCurrentTime(), BigInteger.ZERO, null);\n    }","id":24404,"modified_method":"private ModuleDescriptorCacheEntry createMissingEntry(boolean changing) {\n        return new ModuleDescriptorCacheEntry(changing, false, true, timeProvider.getCurrentTime(), BigInteger.ZERO, null);\n    }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"private ModuleDescriptorCacheEntry createEntry(boolean changing, HashValue moduleDescriptorHash, ModuleSource moduleSource) {\n        return new ModuleDescriptorCacheEntry(changing, false, timeProvider.getCurrentTime(), moduleDescriptorHash.asBigInteger(), moduleSource);\n    }","id":24405,"modified_method":"private ModuleDescriptorCacheEntry createEntry(boolean changing, boolean metaDataOnly, HashValue moduleDescriptorHash, ModuleSource moduleSource) {\n        return new ModuleDescriptorCacheEntry(changing, metaDataOnly, false, timeProvider.getCurrentTime(), moduleDescriptorHash.asBigInteger(), moduleSource);\n    }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"public CachedMetaData cacheMetaData(ModuleVersionRepository repository, ModuleVersionMetaData metaData, ModuleSource moduleSource) {\n        return cacheModuleDescriptor(repository, metaData.getId(), metaData.getDescriptor(), moduleSource, metaData.isChanging());\n    }","id":24406,"modified_method":"public CachedMetaData cacheMetaData(ModuleVersionRepository repository, ModuleVersionMetaData metaData, ModuleSource moduleSource) {\n        ModuleDescriptor moduleDescriptor = metaData.getDescriptor();\n        LOGGER.debug(\"Recording module descriptor in cache: {} [changing = {}]\", moduleDescriptor.getModuleRevisionId(), metaData.isChanging());\n        LocallyAvailableResource resource = moduleDescriptorStore.putModuleDescriptor(repository, moduleDescriptor);\n        ModuleDescriptorCacheEntry entry = createEntry(metaData.isChanging(), metaData.isMetaDataOnly(), resource.getSha1(), moduleSource);\n        getCache().put(createKey(repository, metaData.getId()), entry);\n        return new DefaultCachedMetaData(entry, null, timeProvider);\n    }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleDescriptorCacheEntry read(Decoder decoder) throws Exception {\n            boolean isMissing = decoder.readBoolean();\n            boolean isChanging = decoder.readBoolean();\n            long createTimestamp = decoder.readLong();\n            ModuleSource moduleSource = moduleSourceSerializer.read(decoder);\n            byte[] encodedHash = decoder.readBinary();\n            BigInteger hash = new BigInteger(encodedHash);\n            return new ModuleDescriptorCacheEntry(isChanging, isMissing, createTimestamp, hash, moduleSource);\n        }","id":24407,"modified_method":"public ModuleDescriptorCacheEntry read(Decoder decoder) throws Exception {\n            boolean isMissing = decoder.readBoolean();\n            boolean isChanging = decoder.readBoolean();\n            boolean isMetaData = decoder.readBoolean();\n            long createTimestamp = decoder.readLong();\n            ModuleSource moduleSource = moduleSourceSerializer.read(decoder);\n            byte[] encodedHash = decoder.readBinary();\n            BigInteger hash = new BigInteger(encodedHash);\n            return new ModuleDescriptorCacheEntry(isChanging, isMetaData, isMissing, createTimestamp, hash, moduleSource);\n        }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"ModuleDescriptorCacheEntry(boolean isChanging, boolean isMissing, long createTimestamp, BigInteger moduleDescriptorHash, ModuleSource moduleSource) {\n        this.isChanging = isChanging;\n        this.isMissing = isMissing;\n        this.createTimestamp = createTimestamp;\n        this.moduleSource = moduleSource;\n        this.moduleDescriptorHash = moduleDescriptorHash;\n    }","id":24408,"modified_method":"ModuleDescriptorCacheEntry(boolean isChanging, boolean isMetaDataOnly, boolean isMissing, long createTimestamp, BigInteger moduleDescriptorHash, ModuleSource moduleSource) {\n        this.isChanging = isChanging;\n        this.isMetaDataOnly = isMetaDataOnly;\n        this.isMissing = isMissing;\n        this.createTimestamp = createTimestamp;\n        this.moduleSource = moduleSource;\n        this.moduleDescriptorHash = moduleDescriptorHash;\n    }","commit_id":"4e730bce52c67089f5ba1f453489d708628d09e6","url":"https://github.com/gradle/gradle"},{"original_method":"protected void addItemReference(final Component comp, int[] path, String varnm) {\n\t\tfinal Binder binder = (Binder)comp.getAttribute(BinderImpl.BINDER, true);\n\t\tif (binder == null) return; //no binder\n\t\tcomp.setAttribute(TREE_PATH, path);\n\t\tfinal String expression = BinderImpl.MODEL+\".getChild(\"+TREE_PATH+\")\";\n\t\tcomp.setAttribute(varnm, new ReferenceImpl(binder, expression, comp)); //reference\n\t}","id":24409,"modified_method":"protected void addItemReference(final Component comp, int[] path, String varnm) {\n\t\tfinal Binder binder = (Binder)comp.getAttribute(BinderImpl.BINDER, true);\n\t\tif (binder == null) return; //no binder\n\t\tcomp.setAttribute(TREE_PATH, path);\n\t\tfinal String expression = BinderImpl.MODEL+\"[\"+TREE_PATH+\"]\";\n\t\tcomp.setAttribute(varnm, new ReferenceImpl(binder, expression, comp)); //reference\n\t}","commit_id":"b3172c73b70ec5e6b12ba01c5e7f889341cf627b","url":"https://github.com/zkoss/zk"},{"original_method":"public BindELResolver(XelContext ctx) {\n\t\tsuper(ctx);\n\t\t_resolver = new CompositeELResolver();\n\t\t_resolver.add(new PathELResolver()); //must be the first\n\t\t_resolver.add(new FormELResolver());\n\t\t_resolver.add(new ListModelELResolver());\n\t\t_resolver.add(super.getELResolver());\n\t}","id":24410,"modified_method":"public BindELResolver(XelContext ctx) {\n\t\tsuper(ctx);\n\t\t_resolver = new CompositeELResolver();\n\t\t_resolver.add(new PathELResolver()); //must be the first\n\t\t_resolver.add(new FormELResolver());\n\t\t_resolver.add(new ListModelELResolver());\n\t\t_resolver.add(new TreeModelELResolver());\n\t\t_resolver.add(super.getELResolver());\n\t}","commit_id":"b3172c73b70ec5e6b12ba01c5e7f889341cf627b","url":"https://github.com/zkoss/zk"},{"original_method":"@Override\r\n    public Object getValue(ELContext context, Object base, Object property)\r\n            throws NullPointerException, PropertyNotFoundException, ELException {\r\n        if (context == null) {\r\n            throw new NullPointerException();\r\n        }\r\n\r\n        if (base instanceof ListModel<?>) {\r\n            context.setPropertyResolved(true);\r\n            ListModel<?> listmodel = (ListModel<?>) base;\r\n            int idx = coerce(property);\r\n            if (idx < 0 || idx >= listmodel.getSize()) {\r\n                return null;\r\n            }\r\n            return listmodel.getElementAt(idx);\r\n        }\r\n\r\n        return null;\r\n    }","id":24411,"modified_method":"@Override\r\n    public Object getValue(ELContext context, Object base, Object property)\r\n            throws NullPointerException, PropertyNotFoundException, ELException {\r\n        if (context == null) {\r\n            throw new NullPointerException();\r\n        }\r\n\r\n        if (base instanceof ListModel<?>) {\r\n            ListModel<?> listmodel = (ListModel<?>) base;\r\n            Integer idx = coerce(property);\r\n            if (idx==null || idx < 0 || idx >= listmodel.getSize()) {\r\n                return null;\r\n            }\r\n            context.setPropertyResolved(true);\r\n            return listmodel.getElementAt(idx);\r\n        }\r\n\r\n        return null;\r\n    }","commit_id":"b3172c73b70ec5e6b12ba01c5e7f889341cf627b","url":"https://github.com/zkoss/zk"},{"original_method":"private static final int coerce(Object property) {\r\n        if (property instanceof Number) {\r\n            return ((Number) property).intValue();\r\n        }\r\n        if (property instanceof Character) {\r\n            return ((Character) property).charValue();\r\n        }\r\n        if (property instanceof Boolean) {\r\n            return (((Boolean) property).booleanValue() ? 1 : 0);\r\n        }\r\n        if (property instanceof String) {\r\n            return Integer.parseInt((String) property);\r\n        }\r\n        throw new IllegalArgumentException(property != null ?\r\n                property.toString() : \"null\");\r\n    }","id":24412,"modified_method":"private static final Integer coerce(Object property) {\r\n    \t//should only handle a property that is possible a number\r\n        if (property instanceof Number) {\r\n            return ((Number)property).intValue();\r\n        }\r\n        if (property instanceof Character) {\r\n            return (int)((Character) property).charValue();\r\n        }\r\n        if (property instanceof Boolean) {\r\n            return (((Boolean) property).booleanValue() ? 1 : 0);\r\n        }\r\n        //just ignore other types (especially a string)\r\n        return null;\r\n    }","commit_id":"b3172c73b70ec5e6b12ba01c5e7f889341cf627b","url":"https://github.com/zkoss/zk"},{"original_method":"@Override\r\n    public Class<?> getType(ELContext context, Object base, Object property)\r\n            throws NullPointerException, PropertyNotFoundException, ELException {\r\n        if (context == null) {\r\n            throw new NullPointerException();\r\n        }\r\n\r\n        if (base instanceof ListModel<?>) {\r\n            context.setPropertyResolved(true);\r\n            ListModel<?> listmodel = (ListModel<?>) base;\r\n            int idx = coerce(property);\r\n            if (idx < 0 || idx >= listmodel.getSize()) {\r\n                throw new PropertyNotFoundException(\r\n                        new ArrayIndexOutOfBoundsException(idx).getMessage());\r\n            }\r\n            return Object.class;\r\n        }\r\n\r\n        return null;\r\n    }","id":24413,"modified_method":"@Override\r\n    public Class<?> getType(ELContext context, Object base, Object property)\r\n            throws NullPointerException, PropertyNotFoundException, ELException {\r\n        if (context == null) {\r\n            throw new NullPointerException();\r\n        }\r\n\r\n        if (base instanceof ListModel<?>) {\r\n            ListModel<?> listmodel = (ListModel<?>) base;\r\n            Integer idx = coerce(property);\r\n            if (idx == null) return null;\r\n            if (idx < 0 || idx >= listmodel.getSize()) {\r\n                throw new PropertyNotFoundException(\r\n                        new ArrayIndexOutOfBoundsException(idx).getMessage());\r\n            }\r\n            context.setPropertyResolved(true);\r\n            return Object.class;\r\n        }\r\n\r\n        return null;\r\n    }","commit_id":"b3172c73b70ec5e6b12ba01c5e7f889341cf627b","url":"https://github.com/zkoss/zk"},{"original_method":"@Test\n  public void testDescription() throws Exception {\n    PipelinePhase.Builder builder =\n      PipelinePhase.builder(ImmutableSet.of(BatchSource.PLUGIN_TYPE, Constants.CONNECTOR_TYPE));\n    /*\n     * source1 --|\n     *           |--> sink.connector\n     * source2 --|\n     */\n    builder.addStages(BatchSource.PLUGIN_TYPE, ImmutableList.of(new StageInfo(\"source1\"), new StageInfo(\"source2\")));\n    builder.addStage(Constants.CONNECTOR_TYPE, new StageInfo(\"sink.connector\"));\n\n    builder.addConnection(\"source1\", \"sink.connector\");\n    builder.addConnection(\"source2\", \"sink.connector\");\n\n\n    BatchPhaseSpec phaseSpec =\n      new BatchPhaseSpec(\"phase-1\", builder.build(), new Resources(), false, Collections.<String, String>emptyMap());\n    Assert.assertEquals(\"Sources 'source1', 'source2' to sinks 'sink.connector'.\", phaseSpec.getDescription());\n  }","id":24414,"modified_method":"@Test\n  public void testDescription() throws Exception {\n    /*\n     * source1 --|\n     *           |--> sink.connector\n     * source2 --|\n     */\n    PipelinePhase.Builder builder =\n      PipelinePhase.builder(ImmutableSet.of(BatchSource.PLUGIN_TYPE, Constants.CONNECTOR_TYPE))\n        .addStage(StageInfo.builder(\"source1\", BatchSource.PLUGIN_TYPE).build())\n        .addStage(StageInfo.builder(\"source2\", BatchSource.PLUGIN_TYPE)\n                    .addInputSchema(\"a\", Schema.recordOf(\"stuff\", Schema.Field.of(\"x\", Schema.of(Schema.Type.INT))))\n                    .build())\n        .addStage(StageInfo.builder(\"sink.connector\", Constants.CONNECTOR_TYPE).build())\n        .addConnection(\"source1\", \"sink.connector\")\n        .addConnection(\"source2\", \"sink.connector\");\n\n    BatchPhaseSpec phaseSpec =\n      new BatchPhaseSpec(\"phase-1\", builder.build(), new Resources(), new Resources(),\n                         false, Collections.<String, String>emptyMap());\n    String phaseSpecStr = GSON.toJson(phaseSpec);\n    Assert.assertEquals(\"Sources 'source1', 'source2' to sinks 'sink.connector'.\", phaseSpec.getDescription());\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int hashCode() {\n    return Objects.hash(super.hashCode(), endingActions);\n  }","id":24415,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(super.hashCode(), endingActions, driverResources);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"private BatchPipelineSpec(Set<StageSpec> stages,\n                            Set<Connection> connections,\n                            Resources resources,\n                            boolean stageLoggingEnabled,\n                            List<ActionSpec> endingActions) {\n    super(stages, connections, resources, stageLoggingEnabled);\n    this.endingActions = ImmutableList.copyOf(endingActions);\n  }","id":24416,"modified_method":"private BatchPipelineSpec(Set<StageSpec> stages,\n                            Set<Connection> connections,\n                            Resources resources,\n                            Resources driverResources,\n                            boolean stageLoggingEnabled,\n                            List<ActionSpec> endingActions) {\n    super(stages, connections, resources, stageLoggingEnabled);\n    this.endingActions = ImmutableList.copyOf(endingActions);\n    this.driverResources = driverResources;\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    if (!super.equals(o)) {\n      return false;\n    }\n\n    BatchPipelineSpec that = (BatchPipelineSpec) o;\n\n    return Objects.equals(endingActions, that.endingActions);\n  }","id":24417,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    if (!super.equals(o)) {\n      return false;\n    }\n\n    BatchPipelineSpec that = (BatchPipelineSpec) o;\n\n    return Objects.equals(endingActions, that.endingActions) && Objects.equals(driverResources, that.driverResources);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public BatchPipelineSpec build() {\n      return new BatchPipelineSpec(stages, connections, resources, stageLoggingEnabled, endingActions);\n    }","id":24418,"modified_method":"public BatchPipelineSpec build() {\n      return new BatchPipelineSpec(stages, connections, resources,\n                                   driverResources == null ? resources : driverResources,\n                                   stageLoggingEnabled, endingActions);\n    }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public BatchPipelineSpec generateSpec(ETLBatchConfig config) {\n    BatchPipelineSpec.Builder specBuilder = BatchPipelineSpec.builder();\n\n    for (ETLStage endingAction : config.getPostActions()) {\n      String name = endingAction.getName();\n      PipelineConfigurer pipelineConfigurer = new DefaultPipelineConfigurer(configurer, name);\n      PluginSpec pluginSpec = configurePlugin(endingAction.getName(), endingAction.getPlugin(), pipelineConfigurer);\n      specBuilder.addAction(new ActionSpec(name, pluginSpec));\n    }\n\n    configureStages(config, specBuilder);\n    return specBuilder.build();\n  }","id":24419,"modified_method":"@Override\n  public BatchPipelineSpec generateSpec(ETLBatchConfig config) {\n    BatchPipelineSpec.Builder specBuilder = BatchPipelineSpec.builder()\n      .setDriverResources(config.getDriverResources());\n\n    for (ETLStage endingAction : config.getPostActions()) {\n      String name = endingAction.getName();\n      PipelineConfigurer pipelineConfigurer = new DefaultPipelineConfigurer(configurer, name);\n      PluginSpec pluginSpec = configurePlugin(endingAction.getName(), endingAction.getPlugin(), pipelineConfigurer);\n      specBuilder.addAction(new ActionSpec(name, pluginSpec));\n    }\n\n    configureStages(config, specBuilder);\n    return specBuilder.build();\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure() {\n    ETLBatchConfig config = getConfig();\n    setDescription(DEFAULT_DESCRIPTION);\n\n    PipelineSpecGenerator<ETLBatchConfig, BatchPipelineSpec> specGenerator = new BatchPipelineSpecGenerator(\n      getConfigurer(),\n      ImmutableSet.of(BatchSource.PLUGIN_TYPE),\n      ImmutableSet.of(BatchSink.PLUGIN_TYPE, SparkSink.PLUGIN_TYPE),\n      TimePartitionedFileSet.class,\n      FileSetProperties.builder()\n        .setInputFormat(AvroKeyInputFormat.class)\n        .setOutputFormat(AvroKeyOutputFormat.class)\n        .setEnableExploreOnCreate(true)\n        .setSerDe(\"org.apache.hadoop.hive.serde2.avro.AvroSerDe\")\n        .setExploreInputFormat(\"org.apache.hadoop.hive.ql.io.avro.AvroContainerInputFormat\")\n        .setExploreOutputFormat(\"org.apache.hadoop.hive.ql.io.avro.AvroContainerOutputFormat\")\n        .setTableProperty(\"avro.schema.literal\", Constants.ERROR_SCHEMA.toString())\n        .build());\n    BatchPipelineSpec spec = specGenerator.generateSpec(config);\n\n    PipelinePlanner planner = new PipelinePlanner(supportedPluginTypes,\n                                                  ImmutableSet.of(BatchAggregator.PLUGIN_TYPE, BatchJoiner.PLUGIN_TYPE),\n                                                  ImmutableSet.of(SparkCompute.PLUGIN_TYPE, SparkSink.PLUGIN_TYPE));\n    PipelinePlan plan = planner.plan(spec);\n\n    addWorkflow(new SmartWorkflow(spec, plan, getConfigurer(), config.getEngine()));\n    scheduleWorkflow(Schedules.builder(SCHEDULE_NAME)\n                       .setDescription(\"Data pipeline schedule\")\n                       .createTimeSchedule(config.getSchedule()),\n                     SmartWorkflow.NAME);\n  }","id":24420,"modified_method":"@Override\n  public void configure() {\n    ETLBatchConfig config = getConfig();\n    setDescription(DEFAULT_DESCRIPTION);\n\n    PipelineSpecGenerator<ETLBatchConfig, BatchPipelineSpec> specGenerator = new BatchPipelineSpecGenerator(\n      getConfigurer(),\n      ImmutableSet.of(BatchSource.PLUGIN_TYPE),\n      ImmutableSet.of(BatchSink.PLUGIN_TYPE, SparkSink.PLUGIN_TYPE),\n      TimePartitionedFileSet.class,\n      FileSetProperties.builder()\n        .setInputFormat(AvroKeyInputFormat.class)\n        .setOutputFormat(AvroKeyOutputFormat.class)\n        .setEnableExploreOnCreate(true)\n        .setSerDe(\"org.apache.hadoop.hive.serde2.avro.AvroSerDe\")\n        .setExploreInputFormat(\"org.apache.hadoop.hive.ql.io.avro.AvroContainerInputFormat\")\n        .setExploreOutputFormat(\"org.apache.hadoop.hive.ql.io.avro.AvroContainerOutputFormat\")\n        .setTableProperty(\"avro.schema.literal\", Constants.ERROR_SCHEMA.toString())\n        .build());\n    BatchPipelineSpec spec = specGenerator.generateSpec(config);\n\n    addWorkflow(new SmartWorkflow(spec, supportedPluginTypes, getConfigurer(), config.getEngine()));\n    scheduleWorkflow(Schedules.builder(SCHEDULE_NAME)\n                       .setDescription(\"Data pipeline schedule\")\n                       .createTimeSchedule(config.getSchedule()),\n                     SmartWorkflow.NAME);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testSinglePhaseWithSparkSink() throws Exception {\n    /*\n     * source1 ---|\n     *            |--> sparksink\n     * source2 ---|\n     */\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(new ETLStage(\"source1\", MockSource.getPlugin(\"messages1\")))\n      .addStage(new ETLStage(\"source2\", MockSource.getPlugin(\"messages2\")))\n      .addStage(new ETLStage(\"customsink\",\n                             new ETLPlugin(NaiveBayesTrainer.PLUGIN_NAME, SparkSink.PLUGIN_TYPE,\n                                           ImmutableMap.of(\"fileSetName\", \"modelFileSet\",\n                                                           \"path\", \"output\",\n                                                           \"fieldToClassify\", SpamMessage.TEXT_FIELD,\n                                                           \"predictionField\", SpamMessage.SPAM_PREDICTION_FIELD),\n                                           null)))\n      .addConnection(\"source1\", \"customsink\")\n      .addConnection(\"source2\", \"customsink\")\n      .build();\n\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n    Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, \"SparkSinkApp\");\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n\n\n    // set up five spam messages and five non-spam messages to be used for classification\n    List<StructuredRecord> messagesToWrite = new ArrayList<>();\n    messagesToWrite.add(new SpamMessage(\"buy our clothes\", 1.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"sell your used books to us\", 1.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"earn money for free\", 1.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"this is definitely not spam\", 1.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"you won the lottery\", 1.0).toStructuredRecord());\n\n    // write records to source1\n    DataSetManager<Table> inputManager = getDataset(Id.Namespace.DEFAULT, \"messages1\");\n    MockSource.writeInput(inputManager, messagesToWrite);\n\n    messagesToWrite.clear();\n    messagesToWrite.add(new SpamMessage(\"how was your day\", 0.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"what are you up to\", 0.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"this is a genuine message\", 0.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"this is an even more genuine message\", 0.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"could you send me the report\", 0.0).toStructuredRecord());\n\n    // write records to source2\n    inputManager = getDataset(Id.Namespace.DEFAULT, \"messages2\");\n    MockSource.writeInput(inputManager, messagesToWrite);\n\n    // ingest in some messages to be classified\n    StreamManager textsToClassify = getStreamManager(NaiveBayesTrainer.TEXTS_TO_CLASSIFY);\n    textsToClassify.send(\"how are you doing today\");\n    textsToClassify.send(\"free money money\");\n    textsToClassify.send(\"what are you doing today\");\n    textsToClassify.send(\"genuine report\");\n\n    // manually trigger the pipeline\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForFinish(5, TimeUnit.MINUTES);\n\n\n    DataSetManager<KeyValueTable> classifiedTexts = getDataset(NaiveBayesTrainer.CLASSIFIED_TEXTS);\n\n    Assert.assertEquals(0.0d, Bytes.toDouble(classifiedTexts.get().read(\"how are you doing today\")), 0.01d);\n    // only 'free money money' should be predicated as spam\n    Assert.assertEquals(1.0d, Bytes.toDouble(classifiedTexts.get().read(\"free money money\")), 0.01d);\n    Assert.assertEquals(0.0d, Bytes.toDouble(classifiedTexts.get().read(\"what are you doing today\")), 0.01d);\n    Assert.assertEquals(0.0d, Bytes.toDouble(classifiedTexts.get().read(\"genuine report\")), 0.01d);\n\n    validateMetric(5, appId, \"source1.records.out\");\n    validateMetric(5, appId, \"source2.records.out\");\n    validateMetric(10, appId, \"customsink.records.in\");\n  }","id":24421,"modified_method":"private void testSinglePhaseWithSparkSink() throws Exception {\n    /*\n     * source1 ---|\n     *            |--> sparksink\n     * source2 ---|\n     */\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(new ETLStage(\"source1\", MockSource.getPlugin(\"messages1\")))\n      .addStage(new ETLStage(\"source2\", MockSource.getPlugin(\"messages2\")))\n      .addStage(new ETLStage(\"customsink\",\n                             new ETLPlugin(NaiveBayesTrainer.PLUGIN_NAME, SparkSink.PLUGIN_TYPE,\n                                           ImmutableMap.of(\"fileSetName\", \"modelFileSet\",\n                                                           \"path\", \"output\",\n                                                           \"fieldToClassify\", SpamMessage.TEXT_FIELD,\n                                                           \"predictionField\", SpamMessage.SPAM_PREDICTION_FIELD),\n                                           null)))\n      .addConnection(\"source1\", \"customsink\")\n      .addConnection(\"source2\", \"customsink\")\n      .build();\n\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n    Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, \"SparkSinkApp\");\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n\n\n    // set up five spam messages and five non-spam messages to be used for classification\n    List<StructuredRecord> messagesToWrite = new ArrayList<>();\n    messagesToWrite.add(new SpamMessage(\"buy our clothes\", 1.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"sell your used books to us\", 1.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"earn money for free\", 1.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"this is definitely not spam\", 1.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"you won the lottery\", 1.0).toStructuredRecord());\n\n    // write records to source1\n    DataSetManager<Table> inputManager = getDataset(Id.Namespace.DEFAULT, \"messages1\");\n    MockSource.writeInput(inputManager, messagesToWrite);\n\n    messagesToWrite.clear();\n    messagesToWrite.add(new SpamMessage(\"how was your day\", 0.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"what are you up to\", 0.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"this is a genuine message\", 0.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"this is an even more genuine message\", 0.0).toStructuredRecord());\n    messagesToWrite.add(new SpamMessage(\"could you send me the report\", 0.0).toStructuredRecord());\n\n    // write records to source2\n    inputManager = getDataset(Id.Namespace.DEFAULT, \"messages2\");\n    MockSource.writeInput(inputManager, messagesToWrite);\n\n    // ingest in some messages to be classified\n    StreamManager textsToClassify = getStreamManager(NaiveBayesTrainer.TEXTS_TO_CLASSIFY);\n    textsToClassify.send(\"how are you doing today\");\n    textsToClassify.send(\"free money money\");\n    textsToClassify.send(\"what are you doing today\");\n    textsToClassify.send(\"genuine report\");\n\n    // manually trigger the pipeline\n    final WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForFinish(5, TimeUnit.MINUTES);\n\n\n    DataSetManager<KeyValueTable> classifiedTexts = getDataset(NaiveBayesTrainer.CLASSIFIED_TEXTS);\n\n    Assert.assertEquals(0.0d, Bytes.toDouble(classifiedTexts.get().read(\"how are you doing today\")), 0.01d);\n    // only 'free money money' should be predicated as spam\n    Assert.assertEquals(1.0d, Bytes.toDouble(classifiedTexts.get().read(\"free money money\")), 0.01d);\n    Assert.assertEquals(0.0d, Bytes.toDouble(classifiedTexts.get().read(\"what are you doing today\")), 0.01d);\n    Assert.assertEquals(0.0d, Bytes.toDouble(classifiedTexts.get().read(\"genuine report\")), 0.01d);\n\n    validateMetric(5, appId, \"source1.records.out\");\n    validateMetric(5, appId, \"source2.records.out\");\n    validateMetric(10, appId, \"customsink.records.in\");\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"private void testParallelAggregators(Engine engine) throws Exception {\n    String source1Name = \"pAggInput1-\" + engine.name();\n    String source2Name = \"pAggInput2-\" + engine.name();\n    String sink1Name = \"pAggOutput1-\" + engine.name();\n    String sink2Name = \"pAggOutput2-\" + engine.name();\n    /*\n       source1 --|--> agg1 --> sink1\n                 |\n       source1 --|--> agg2 --> sink2\n     */\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .setEngine(engine)\n      .addStage(new ETLStage(\"source1\", MockSource.getPlugin(source1Name)))\n      .addStage(new ETLStage(\"source2\", MockSource.getPlugin(source2Name)))\n      .addStage(new ETLStage(\"sink1\", MockSink.getPlugin(sink1Name)))\n      .addStage(new ETLStage(\"sink2\", MockSink.getPlugin(sink2Name)))\n      .addStage(new ETLStage(\"agg1\", FieldCountAggregator.getPlugin(\"user\", \"string\")))\n      .addStage(new ETLStage(\"agg2\", FieldCountAggregator.getPlugin(\"item\", \"long\")))\n      .addConnection(\"source1\", \"agg1\")\n      .addConnection(\"source1\", \"agg2\")\n      .addConnection(\"source2\", \"agg1\")\n      .addConnection(\"source2\", \"agg2\")\n      .addConnection(\"agg1\", \"sink1\")\n      .addConnection(\"agg2\", \"sink2\")\n      .build();\n\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n    Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, \"ParallelAggApp\");\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n    // total programs = 4; 1 workflow, 1 job for source1,source2 -> agg1.connector,agg2.connector\n    // 1 job for agg1.connector -> sink1 and another job for agg2.connector -> sink2\n    Assert.assertEquals(4, appManager.getInfo().getPrograms().size());\n    Schema inputSchema = Schema.recordOf(\n      \"testRecord\",\n      Schema.Field.of(\"user\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"item\", Schema.of(Schema.Type.LONG))\n    );\n\n    // write few records to each source\n    DataSetManager<Table> inputManager = getDataset(Id.Namespace.DEFAULT, source1Name);\n    MockSource.writeInput(inputManager, ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"user\", \"samuel\").set(\"item\", 1L).build(),\n      StructuredRecord.builder(inputSchema).set(\"user\", \"samuel\").set(\"item\", 2L).build()));\n\n    inputManager = getDataset(Id.Namespace.DEFAULT, source2Name);\n    MockSource.writeInput(inputManager, ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"user\", \"samuel\").set(\"item\", 3L).build(),\n      StructuredRecord.builder(inputSchema).set(\"user\", \"john\").set(\"item\", 4L).build(),\n      StructuredRecord.builder(inputSchema).set(\"user\", \"john\").set(\"item\", 3L).build()));\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    Schema outputSchema1 = Schema.recordOf(\n      \"user.count\",\n      Schema.Field.of(\"user\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"ct\", Schema.of(Schema.Type.LONG))\n    );\n    Schema outputSchema2 = Schema.recordOf(\n      \"item.count\",\n      Schema.Field.of(\"item\", Schema.of(Schema.Type.LONG)),\n      Schema.Field.of(\"ct\", Schema.of(Schema.Type.LONG))\n    );\n\n    // check output\n    DataSetManager<Table> sinkManager = getDataset(sink1Name);\n    Set<StructuredRecord> expected = ImmutableSet.of(\n      StructuredRecord.builder(outputSchema1).set(\"user\", \"all\").set(\"ct\", 5L).build(),\n      StructuredRecord.builder(outputSchema1).set(\"user\", \"samuel\").set(\"ct\", 3L).build(),\n      StructuredRecord.builder(outputSchema1).set(\"user\", \"john\").set(\"ct\", 2L).build());\n    Set<StructuredRecord> actual = Sets.newHashSet(MockSink.readOutput(sinkManager));\n    Assert.assertEquals(expected, actual);\n\n    sinkManager = getDataset(sink2Name);\n    expected = ImmutableSet.of(\n      StructuredRecord.builder(outputSchema2).set(\"item\", 0L).set(\"ct\", 5L).build(),\n      StructuredRecord.builder(outputSchema2).set(\"item\", 1L).set(\"ct\", 1L).build(),\n      StructuredRecord.builder(outputSchema2).set(\"item\", 2L).set(\"ct\", 1L).build(),\n      StructuredRecord.builder(outputSchema2).set(\"item\", 3L).set(\"ct\", 2L).build(),\n      StructuredRecord.builder(outputSchema2).set(\"item\", 4L).set(\"ct\", 1L).build());\n    actual = Sets.newHashSet(MockSink.readOutput(sinkManager));\n    Assert.assertEquals(expected, actual);\n\n    validateMetric(2, appId, \"source1.records.out\");\n    validateMetric(3, appId, \"source2.records.out\");\n    validateMetric(5, appId, \"agg1.records.in\");\n    // 2 users, but FieldCountAggregator always emits an 'all' group\n    validateMetric(3, appId, \"agg1.aggregator.groups\");\n    validateMetric(3, appId, \"agg1.records.out\");\n    validateMetric(5, appId, \"agg2.records.in\");\n    // 4 items, but FieldCountAggregator always emits an 'all' group\n    validateMetric(5, appId, \"agg2.aggregator.groups\");\n    validateMetric(5, appId, \"agg2.records.out\");\n    validateMetric(3, appId, \"sink1.records.in\");\n    validateMetric(5, appId, \"sink2.records.in\");\n  }","id":24422,"modified_method":"private void testParallelAggregators(Engine engine) throws Exception {\n    String source1Name = \"pAggInput1-\" + engine.name();\n    String source2Name = \"pAggInput2-\" + engine.name();\n    String sink1Name = \"pAggOutput1-\" + engine.name();\n    String sink2Name = \"pAggOutput2-\" + engine.name();\n    /*\n       source1 --|--> agg1 --> sink1\n                 |\n       source2 --|--> agg2 --> sink2\n     */\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .setEngine(engine)\n      .addStage(new ETLStage(\"source1\", MockSource.getPlugin(source1Name)))\n      .addStage(new ETLStage(\"source2\", MockSource.getPlugin(source2Name)))\n      .addStage(new ETLStage(\"sink1\", MockSink.getPlugin(sink1Name)))\n      .addStage(new ETLStage(\"sink2\", MockSink.getPlugin(sink2Name)))\n      .addStage(new ETLStage(\"agg1\", FieldCountAggregator.getPlugin(\"user\", \"string\")))\n      .addStage(new ETLStage(\"agg2\", FieldCountAggregator.getPlugin(\"item\", \"long\")))\n      .addConnection(\"source1\", \"agg1\")\n      .addConnection(\"source1\", \"agg2\")\n      .addConnection(\"source2\", \"agg1\")\n      .addConnection(\"source2\", \"agg2\")\n      .addConnection(\"agg1\", \"sink1\")\n      .addConnection(\"agg2\", \"sink2\")\n      .build();\n\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n    Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, \"ParallelAggApp\");\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n    Schema inputSchema = Schema.recordOf(\n      \"testRecord\",\n      Schema.Field.of(\"user\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"item\", Schema.of(Schema.Type.LONG))\n    );\n\n    // write few records to each source\n    DataSetManager<Table> inputManager = getDataset(Id.Namespace.DEFAULT, source1Name);\n    MockSource.writeInput(inputManager, ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"user\", \"samuel\").set(\"item\", 1L).build(),\n      StructuredRecord.builder(inputSchema).set(\"user\", \"samuel\").set(\"item\", 2L).build()));\n\n    inputManager = getDataset(Id.Namespace.DEFAULT, source2Name);\n    MockSource.writeInput(inputManager, ImmutableList.of(\n      StructuredRecord.builder(inputSchema).set(\"user\", \"samuel\").set(\"item\", 3L).build(),\n      StructuredRecord.builder(inputSchema).set(\"user\", \"john\").set(\"item\", 4L).build(),\n      StructuredRecord.builder(inputSchema).set(\"user\", \"john\").set(\"item\", 3L).build()));\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    Schema outputSchema1 = Schema.recordOf(\n      \"user.count\",\n      Schema.Field.of(\"user\", Schema.of(Schema.Type.STRING)),\n      Schema.Field.of(\"ct\", Schema.of(Schema.Type.LONG))\n    );\n    Schema outputSchema2 = Schema.recordOf(\n      \"item.count\",\n      Schema.Field.of(\"item\", Schema.of(Schema.Type.LONG)),\n      Schema.Field.of(\"ct\", Schema.of(Schema.Type.LONG))\n    );\n\n    // check output\n    DataSetManager<Table> sinkManager = getDataset(sink1Name);\n    Set<StructuredRecord> expected = ImmutableSet.of(\n      StructuredRecord.builder(outputSchema1).set(\"user\", \"all\").set(\"ct\", 5L).build(),\n      StructuredRecord.builder(outputSchema1).set(\"user\", \"samuel\").set(\"ct\", 3L).build(),\n      StructuredRecord.builder(outputSchema1).set(\"user\", \"john\").set(\"ct\", 2L).build());\n    Set<StructuredRecord> actual = Sets.newHashSet(MockSink.readOutput(sinkManager));\n    Assert.assertEquals(expected, actual);\n\n    sinkManager = getDataset(sink2Name);\n    expected = ImmutableSet.of(\n      StructuredRecord.builder(outputSchema2).set(\"item\", 0L).set(\"ct\", 5L).build(),\n      StructuredRecord.builder(outputSchema2).set(\"item\", 1L).set(\"ct\", 1L).build(),\n      StructuredRecord.builder(outputSchema2).set(\"item\", 2L).set(\"ct\", 1L).build(),\n      StructuredRecord.builder(outputSchema2).set(\"item\", 3L).set(\"ct\", 2L).build(),\n      StructuredRecord.builder(outputSchema2).set(\"item\", 4L).set(\"ct\", 1L).build());\n    actual = Sets.newHashSet(MockSink.readOutput(sinkManager));\n    Assert.assertEquals(expected, actual);\n\n    validateMetric(2, appId, \"source1.records.out\");\n    validateMetric(3, appId, \"source2.records.out\");\n    validateMetric(5, appId, \"agg1.records.in\");\n    // 2 users, but FieldCountAggregator always emits an 'all' group\n    validateMetric(3, appId, \"agg1.aggregator.groups\");\n    validateMetric(3, appId, \"agg1.records.out\");\n    validateMetric(5, appId, \"agg2.records.in\");\n    // 4 items, but FieldCountAggregator always emits an 'all' group\n    validateMetric(5, appId, \"agg2.aggregator.groups\");\n    validateMetric(5, appId, \"agg2.records.out\");\n    validateMetric(3, appId, \"sink1.records.in\");\n    validateMetric(5, appId, \"sink2.records.in\");\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testPipelineWithActions() throws Exception {\n\n    String actionTable = \"actionTable\";\n    String action1RowKey = \"action1.row\";\n    String action1ColumnKey = \"action1.column\";\n    String action1Value = \"action1.value\";\n    String action2RowKey = \"action2.row\";\n    String action2ColumnKey = \"action2.column\";\n    String action2Value = \"action2.value\";\n    String action3RowKey = \"action3.row\";\n    String action3ColumnKey = \"action3.column\";\n    String action3Value = \"action3.value\";\n\n    ETLBatchConfig etlConfig = ETLBatchConfig.builder(\"* * * * *\")\n      .addStage(new ETLStage(\"action1\", MockAction.getPlugin(actionTable, action1RowKey, action1ColumnKey,\n                                                             action1Value)))\n      .addStage(new ETLStage(\"action2\", MockAction.getPlugin(actionTable, action2RowKey, action2ColumnKey,\n                                                             action2Value)))\n      .addStage(new ETLStage(\"action3\", MockAction.getPlugin(actionTable, action3RowKey, action3ColumnKey,\n                                                             action3Value)))\n      .addStage(new ETLStage(\"source\", MockSource.getPlugin(\"myInput\")))\n      .addStage(new ETLStage(\"sink\", MockSink.getPlugin(\"myOutput\")))\n      .addConnection(\"source\", \"sink\")\n      .addConnection(\"action1\", \"action2\")\n      .addConnection(\"action2\", \"source\")\n      .addConnection(\"sink\", \"action3\")\n      .build();\n\n    AppRequest<ETLBatchConfig> appRequest = new AppRequest<>(APP_ARTIFACT, etlConfig);\n    Id.Application appId = Id.Application.from(Id.Namespace.DEFAULT, \"MyApp\");\n    ApplicationManager appManager = deployApplication(appId, appRequest);\n\n\n    Schema schema = Schema.recordOf(\n      \"testRecord\",\n      Schema.Field.of(\"name\", Schema.of(Schema.Type.STRING))\n    );\n    StructuredRecord recordSamuel = StructuredRecord.builder(schema).set(\"name\", \"samuel\").build();\n    StructuredRecord recordBob = StructuredRecord.builder(schema).set(\"name\", \"bob\").build();\n\n    // write records to source\n    DataSetManager<Table> inputManager = getDataset(Id.Namespace.DEFAULT, \"myInput\");\n    MockSource.writeInput(inputManager, ImmutableList.of(recordSamuel, recordBob));\n\n    WorkflowManager workflowManager = appManager.getWorkflowManager(SmartWorkflow.NAME);\n    workflowManager.start();\n    workflowManager.waitForFinish(5, TimeUnit.MINUTES);\n\n    // check sink\n    DataSetManager<Table> sinkManager = getDataset(\"myOutput\");\n    Set<StructuredRecord> expected = ImmutableSet.of(recordSamuel, recordBob);\n    Set<StructuredRecord> actual = Sets.newHashSet(MockSink.readOutput(sinkManager));\n    Assert.assertEquals(expected, actual);\n\n    DataSetManager<Table> actionTableDS = getDataset(actionTable);\n    Assert.assertEquals(action1Value, MockAction.readOutput(actionTableDS, action1RowKey, action1ColumnKey));\n    Assert.assertEquals(action2Value, MockAction.readOutput(actionTableDS, action2RowKey, action2ColumnKey));\n    Assert.assertEquals(action3Value, MockAction.readOutput(actionTableDS, action3RowKey, action3ColumnKey));\n\n    validateMetric(2, appId, \"source.records.out\");\n    validateMetric(2, appId, \"sink.records.in\");\n  }","id":24423,"modified_method":"@Test\n  public void testPipelineWithActionsMR() throws Exception {\n    testPipelineWithActions(Engine.MAPREDUCE);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure() {\n    ETLBatchConfig config = getConfig().convertOldConfig();\n    setDescription(DEFAULT_DESCRIPTION);\n\n    PipelineSpecGenerator<ETLBatchConfig, BatchPipelineSpec> specGenerator = new BatchPipelineSpecGenerator(\n      getConfigurer(),\n      ImmutableSet.of(BatchSource.PLUGIN_TYPE), ImmutableSet.of(BatchSink.PLUGIN_TYPE),\n      TimePartitionedFileSet.class,\n      FileSetProperties.builder()\n        .setInputFormat(AvroKeyInputFormat.class)\n        .setOutputFormat(AvroKeyOutputFormat.class)\n        .setEnableExploreOnCreate(true)\n        .setSerDe(\"org.apache.hadoop.hive.serde2.avro.AvroSerDe\")\n        .setExploreInputFormat(\"org.apache.hadoop.hive.ql.io.avro.AvroContainerInputFormat\")\n        .setExploreOutputFormat(\"org.apache.hadoop.hive.ql.io.avro.AvroContainerOutputFormat\")\n        .setTableProperty(\"avro.schema.literal\", Constants.ERROR_SCHEMA.toString())\n        .build());\n\n    BatchPipelineSpec spec = specGenerator.generateSpec(config);\n\n    int sourceCount = 0;\n    for (StageSpec stageSpec : spec.getStages()) {\n      if (BatchSource.PLUGIN_TYPE.equals(stageSpec.getPlugin().getType())) {\n        sourceCount++;\n      }\n    }\n    if (sourceCount != 1) {\n      throw new IllegalArgumentException(\"Invalid pipeline. There must only be one source.\");\n    }\n\n    PipelinePlanner planner = new PipelinePlanner(SUPPORTED_PLUGIN_TYPES,\n                                                  ImmutableSet.<String>of(), ImmutableSet.<String>of());\n    PipelinePlan plan = planner.plan(spec);\n\n    if (plan.getPhases().size() != 1) {\n      // should never happen if there is only one source\n      throw new IllegalArgumentException(\"There was an error planning the pipeline. There should only be one phase.\");\n    }\n\n    PipelinePhase pipeline = plan.getPhases().values().iterator().next();\n\n    switch (config.getEngine()) {\n      case MAPREDUCE:\n        BatchPhaseSpec batchPhaseSpec = new BatchPhaseSpec(ETLMapReduce.NAME, pipeline,\n                                                           config.getResources(),\n                                                           config.isStageLoggingEnabled(),\n                                                           new HashMap<String, String>());\n        addMapReduce(new ETLMapReduce(batchPhaseSpec));\n        break;\n      case SPARK:\n        batchPhaseSpec = new BatchPhaseSpec(ETLSpark.class.getSimpleName(), pipeline,\n                                            config.getResources(),\n                                            config.isStageLoggingEnabled(),\n                                            new HashMap<String, String>());\n        addSpark(new ETLSpark(batchPhaseSpec));\n        break;\n      default:\n        throw new IllegalArgumentException(\n          String.format(\"Invalid execution engine '%s'. Must be one of %s.\",\n                        config.getEngine(), Joiner.on(',').join(Engine.values())));\n    }\n\n    addWorkflow(new ETLWorkflow(spec, config.getEngine()));\n    scheduleWorkflow(Schedules.builder(SCHEDULE_NAME)\n                       .setDescription(\"ETL Batch schedule\")\n                       .createTimeSchedule(config.getSchedule()),\n                     ETLWorkflow.NAME);\n  }","id":24424,"modified_method":"@Override\n  public void configure() {\n    ETLBatchConfig config = getConfig().convertOldConfig();\n    setDescription(DEFAULT_DESCRIPTION);\n\n    PipelineSpecGenerator<ETLBatchConfig, BatchPipelineSpec> specGenerator = new BatchPipelineSpecGenerator(\n      getConfigurer(),\n      ImmutableSet.of(BatchSource.PLUGIN_TYPE), ImmutableSet.of(BatchSink.PLUGIN_TYPE),\n      TimePartitionedFileSet.class,\n      FileSetProperties.builder()\n        .setInputFormat(AvroKeyInputFormat.class)\n        .setOutputFormat(AvroKeyOutputFormat.class)\n        .setEnableExploreOnCreate(true)\n        .setSerDe(\"org.apache.hadoop.hive.serde2.avro.AvroSerDe\")\n        .setExploreInputFormat(\"org.apache.hadoop.hive.ql.io.avro.AvroContainerInputFormat\")\n        .setExploreOutputFormat(\"org.apache.hadoop.hive.ql.io.avro.AvroContainerOutputFormat\")\n        .setTableProperty(\"avro.schema.literal\", Constants.ERROR_SCHEMA.toString())\n        .build());\n\n    BatchPipelineSpec spec = specGenerator.generateSpec(config);\n\n    int sourceCount = 0;\n    for (StageSpec stageSpec : spec.getStages()) {\n      if (BatchSource.PLUGIN_TYPE.equals(stageSpec.getPlugin().getType())) {\n        sourceCount++;\n      }\n    }\n    if (sourceCount != 1) {\n      throw new IllegalArgumentException(\"Invalid pipeline. There must only be one source.\");\n    }\n\n    PipelinePlanner planner = new PipelinePlanner(SUPPORTED_PLUGIN_TYPES,\n                                                  ImmutableSet.<String>of(), ImmutableSet.<String>of());\n    PipelinePlan plan = planner.plan(spec);\n\n    if (plan.getPhases().size() != 1) {\n      // should never happen if there is only one source\n      throw new IllegalArgumentException(\"There was an error planning the pipeline. There should only be one phase.\");\n    }\n\n    PipelinePhase pipeline = plan.getPhases().values().iterator().next();\n\n    switch (config.getEngine()) {\n      case MAPREDUCE:\n        BatchPhaseSpec batchPhaseSpec = new BatchPhaseSpec(ETLMapReduce.NAME, pipeline,\n                                                           config.getResources(),\n                                                           config.getDriverResources(),\n                                                           config.isStageLoggingEnabled(),\n                                                           new HashMap<String, String>());\n        addMapReduce(new ETLMapReduce(batchPhaseSpec));\n        break;\n      case SPARK:\n        batchPhaseSpec = new BatchPhaseSpec(ETLSpark.class.getSimpleName(), pipeline,\n                                            config.getResources(),\n                                            config.getDriverResources(),\n                                            config.isStageLoggingEnabled(),\n                                            new HashMap<String, String>());\n        addSpark(new ETLSpark(batchPhaseSpec));\n        break;\n      default:\n        throw new IllegalArgumentException(\n          String.format(\"Invalid execution engine '%s'. Must be one of %s.\",\n                        config.getEngine(), Joiner.on(',').join(Engine.values())));\n    }\n\n    addWorkflow(new ETLWorkflow(spec, config.getEngine()));\n    scheduleWorkflow(Schedules.builder(SCHEDULE_NAME)\n                       .setDescription(\"ETL Batch schedule\")\n                       .createTimeSchedule(config.getSchedule()),\n                     ETLWorkflow.NAME);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void configure() {\n    setName(phaseSpec.getPhaseName());\n    setDescription(\"MapReduce phase executor. \" + phaseSpec.getDescription());\n\n    setMapperResources(phaseSpec.getResources());\n    setDriverResources(phaseSpec.getResources());\n\n    Set<String> sources = phaseSpec.getPhase().getSources();\n    // Planner should make sure this never happens\n    if (sources.isEmpty()) {\n      throw new IllegalArgumentException(String.format(\n        \"Pipeline phase '%s' must contain at least one source but it has no sources.\", phaseSpec.getPhaseName()));\n    }\n    if (phaseSpec.getPhase().getSinks().isEmpty()) {\n      throw new IllegalArgumentException(String.format(\n        \"Pipeline phase '%s' must contain at least one sink but does not have any.\", phaseSpec.getPhaseName()));\n    }\n    Set<StageInfo> reducers = phaseSpec.getPhase().getStagesOfType(BatchAggregator.PLUGIN_TYPE,\n                                                                   BatchJoiner.PLUGIN_TYPE);\n    if (reducers.size() > 1) {\n      throw new IllegalArgumentException(String.format(\n        \"Pipeline phase '%s' cannot contain more than one reducer but it has reducers '%s'.\",\n        phaseSpec.getPhaseName(), Joiner.on(',').join(reducers)));\n    } else if (!reducers.isEmpty()) {\n      String reducerName = reducers.iterator().next().getName();\n      PipelinePhase mapperPipeline = phaseSpec.getPhase().subsetTo(ImmutableSet.of(reducerName));\n      for (StageInfo stageInfo : mapperPipeline) {\n        // error datasets are not supported in the map phase of a mapreduce, because we can only\n        // write out the group/join key and not error dataset data.\n        // we need to re-think how error datasets are done. perhaps they are just sinks instead of a special thing.\n        if (stageInfo.getErrorDatasetName() != null) {\n          throw new IllegalArgumentException(String.format(\n            \"Stage %s is not allowed to have an error dataset because it connects to reducer %s.\",\n            stageInfo.getName(), reducerName));\n        }\n      }\n    }\n\n    // add source, sink, transform ids to the properties. These are needed at runtime to instantiate the plugins\n    Map<String, String> properties = new HashMap<>();\n    properties.put(Constants.PIPELINEID, GSON.toJson(phaseSpec));\n    setProperties(properties);\n  }","id":24425,"modified_method":"@Override\n  public void configure() {\n    setName(phaseSpec.getPhaseName());\n    setDescription(\"MapReduce phase executor. \" + phaseSpec.getDescription());\n\n    setMapperResources(phaseSpec.getResources());\n    setDriverResources(phaseSpec.getDriverResources());\n\n    Set<String> sources = phaseSpec.getPhase().getSources();\n    // Planner should make sure this never happens\n    if (sources.isEmpty()) {\n      throw new IllegalArgumentException(String.format(\n        \"Pipeline phase '%s' must contain at least one source but it has no sources.\", phaseSpec.getPhaseName()));\n    }\n    if (phaseSpec.getPhase().getSinks().isEmpty()) {\n      throw new IllegalArgumentException(String.format(\n        \"Pipeline phase '%s' must contain at least one sink but does not have any.\", phaseSpec.getPhaseName()));\n    }\n    Set<StageInfo> reducers = phaseSpec.getPhase().getStagesOfType(BatchAggregator.PLUGIN_TYPE,\n                                                                   BatchJoiner.PLUGIN_TYPE);\n    if (reducers.size() > 1) {\n      throw new IllegalArgumentException(String.format(\n        \"Pipeline phase '%s' cannot contain more than one reducer but it has reducers '%s'.\",\n        phaseSpec.getPhaseName(), Joiner.on(',').join(reducers)));\n    } else if (!reducers.isEmpty()) {\n      String reducerName = reducers.iterator().next().getName();\n      PipelinePhase mapperPipeline = phaseSpec.getPhase().subsetTo(ImmutableSet.of(reducerName));\n      for (StageInfo stageInfo : mapperPipeline) {\n        // error datasets are not supported in the map phase of a mapreduce, because we can only\n        // write out the group/join key and not error dataset data.\n        // we need to re-think how error datasets are done. perhaps they are just sinks instead of a special thing.\n        if (stageInfo.getErrorDatasetName() != null) {\n          throw new IllegalArgumentException(String.format(\n            \"Stage %s is not allowed to have an error dataset because it connects to reducer %s.\",\n            stageInfo.getName(), reducerName));\n        }\n      }\n    }\n\n    // add source, sink, transform ids to the properties. These are needed at runtime to instantiate the plugins\n    Map<String, String> properties = new HashMap<>();\n    properties.put(Constants.PIPELINEID, GSON.toJson(phaseSpec));\n    setProperties(properties);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int hashCode() {\n    return Objects.hash(stages, dag);\n  }","id":24426,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(stagesByType, stagesByName, dag);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public Set<String> getStageOutputs(String stage) {\n    Set<String> outputs = dag.getNodeOutputs(stage);\n    return Collections.unmodifiableSet(outputs == null ? new HashSet<String>() : outputs);\n  }","id":24427,"modified_method":"public Set<String> getStageOutputs(String stage) {\n    Set<String> outputs = dag == null ? null : dag.getNodeOutputs(stage);\n    return Collections.unmodifiableSet(outputs == null ? new HashSet<String>() : outputs);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Iterator<StageInfo> iterator() {\n    List<Iterator<StageInfo>> iterators = new ArrayList<>(stages.size());\n    for (Map.Entry<String, Set<StageInfo>> stagesEntry : stages.entrySet()) {\n      iterators.add(stagesEntry.getValue().iterator());\n    }\n    return Iterators.concat(iterators.iterator());\n  }","id":24428,"modified_method":"@Override\n  public Iterator<StageInfo> iterator() {\n    return stagesByName.values().iterator();\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public PipelinePhase(Map<String, Set<StageInfo>> stages, Dag dag) {\n    this.stages = ImmutableMap.copyOf(stages);\n    this.dag = dag;\n  }","id":24429,"modified_method":"private PipelinePhase(Set<StageInfo> stages, @Nullable Dag dag) {\n    stagesByType = new HashMap<>();\n    stagesByName = new HashMap<>();\n    for (StageInfo stage : stages) {\n      stagesByName.put(stage.getName(), stage);\n      String pluginType = stage.getPluginType();\n      Set<StageInfo> typeStages = stagesByType.get(pluginType);\n      if (typeStages == null) {\n        typeStages = new HashSet<>();\n        stagesByType.put(pluginType, typeStages);\n      }\n      typeStages.add(stage);\n    }\n    this.dag = dag;\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public Set<StageInfo> getStagesOfType(String... pluginTypes) {\n    Set<StageInfo> stageInfos = new HashSet<>();\n    for (String pluginType: pluginTypes) {\n      if (stages.get(pluginType) != null) {\n        stageInfos.addAll(stages.get(pluginType));\n      }\n    }\n    return Collections.unmodifiableSet(stageInfos);\n  }","id":24430,"modified_method":"public Set<StageInfo> getStagesOfType(String... pluginTypes) {\n    Set<StageInfo> stageInfos = new HashSet<>();\n    for (String pluginType: pluginTypes) {\n      Set<StageInfo> typeStages = stagesByType.get(pluginType);\n      if (typeStages != null) {\n        stageInfos.addAll(typeStages);\n      }\n    }\n    return Collections.unmodifiableSet(stageInfos);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public Set<String> getPluginTypes() {\n    return stages.keySet();\n  }","id":24431,"modified_method":"public Set<String> getPluginTypes() {\n    return stagesByType.keySet();\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public Builder(Set<String> supportedPluginTypes) {\n      this.supportedPluginTypes = supportedPluginTypes;\n      this.stages = new HashMap<>();\n      this.connections = new HashSet<>();\n    }","id":24432,"modified_method":"public Builder(Set<String> supportedPluginTypes) {\n      this.supportedPluginTypes = supportedPluginTypes;\n      this.stages = new HashSet<>();\n      this.connections = new HashSet<>();\n    }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Get an unmodifiable set of stages that use the specified plugin type.\n   *\n   * @param pluginType the plugin type\n   * @return unmodifiable set of stages that use the specified plugin type\n   */\n  public Set<StageInfo> getStagesOfType(String pluginType) {\n    Set<StageInfo> stageInfos = stages.get(pluginType);\n    return Collections.unmodifiableSet(stageInfos == null ? new HashSet<StageInfo>() : stageInfos);\n  }","id":24433,"modified_method":"/**\n   * Get an unmodifiable set of stages that use the specified plugin type.\n   *\n   * @param pluginType the plugin type\n   * @return unmodifiable set of stages that use the specified plugin type\n   */\n  public Set<StageInfo> getStagesOfType(String pluginType) {\n    Set<StageInfo> stagesOfType = stagesByType.get(pluginType);\n    return Collections.unmodifiableSet(stagesOfType == null ? new HashSet<StageInfo>() : stagesOfType);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    PipelinePhase that = (PipelinePhase) o;\n\n    return Objects.equals(stages, that.stages) &&\n      Objects.equals(dag, that.dag);\n  }","id":24434,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    PipelinePhase that = (PipelinePhase) o;\n\n    return Objects.equals(stagesByType, that.stagesByType) &&\n      Objects.equals(stagesByName, that.stagesByName) &&\n      Objects.equals(dag, that.dag);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public Builder addConnections(String from, Collection<String> to) {\n      for (String toStage : to) {\n        connections.add(new Connection(from, toStage));\n      }\n      return this;\n    }","id":24435,"modified_method":"public Builder addConnections(String input, Collection<String> outputs) {\n      for (String output : outputs) {\n        addConnection(input, output);\n      }\n      return this;\n    }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public Builder addConnection(String from, String to) {\n      return addConnections(from, ImmutableSet.of(to));\n    }","id":24436,"modified_method":"public Builder addConnection(String from, String to) {\n      connections.add(new co.cask.cdap.etl.proto.Connection(from, to));\n      return this;\n    }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"private PipelinePhase getSubset(final Dag subsetDag) {\n    Map<String, Set<StageInfo>> subsetStages = new HashMap<>();\n    for (Map.Entry<String, Set<StageInfo>> stagesEntry : stages.entrySet()) {\n      final Set<StageInfo> stagesOfType = Sets.filter(stagesEntry.getValue(), new Predicate<StageInfo>() {\n        @Override\n        public boolean apply(StageInfo stageInfo) {\n          return subsetDag.getNodes().contains(stageInfo.getName());\n        }\n      });\n      if (!stagesOfType.isEmpty()) {\n        subsetStages.put(stagesEntry.getKey(), stagesOfType);\n      }\n    }\n    return new PipelinePhase(subsetStages, subsetDag);\n  }","id":24437,"modified_method":"private PipelinePhase getSubset(final Dag subsetDag) {\n    Set<StageInfo> subsetStages = new HashSet<>();\n    for (StageInfo stage : stagesByName.values()) {\n      if (subsetDag.getNodes().contains(stage.getName())) {\n        subsetStages.add(stage);\n      }\n    }\n    return new PipelinePhase(subsetStages, subsetDag);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public Builder addStages(String pluginType, Collection<StageInfo> stages) {\n      if (!supportedPluginTypes.contains(pluginType)) {\n        throw new IllegalArgumentException(\n          String.format(\"%s is an unsupported plugin type. Plugin type must be one of %s.\",\n                        pluginType, Joiner.on(',').join(supportedPluginTypes)));\n      }\n      Set<StageInfo> existingStages = this.stages.get(pluginType);\n      if (existingStages == null) {\n        existingStages = new HashSet<>();\n        this.stages.put(pluginType, existingStages);\n      }\n      existingStages.addAll(stages);\n      return this;\n    }","id":24438,"modified_method":"public Builder addStages(Collection<StageInfo> stages) {\n      for (StageInfo stage : stages) {\n        addStage(stage);\n      }\n      return this;\n    }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public Builder addStage(String pluginType, StageInfo stageInfo) {\n      return addStages(pluginType, ImmutableSet.of(stageInfo));\n    }","id":24439,"modified_method":"public Builder addStage(StageInfo stageInfo) {\n      String pluginType = stageInfo.getPluginType();\n      if (!supportedPluginTypes.contains(pluginType)) {\n        throw new IllegalArgumentException(\n          String.format(\"%s is an unsupported plugin type. Plugin type must be one of %s.\",\n                        pluginType, Joiner.on(',').join(supportedPluginTypes)));\n      }\n      stages.add(stageInfo);\n      return this;\n    }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return \"PipelinePhase{\" +\n      \"stages=\" + stages +\n      \", dag=\" + dag +\n      '}';\n  }","id":24440,"modified_method":"@Override\n  public String toString() {\n    return \"PipelinePhase{\" +\n      \"stagesByType=\" + stagesByType +\n      \", stagesByName=\" + stagesByName +\n      \", dag=\" + dag +\n      '}';\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public PipelinePhase build() {\n      return new PipelinePhase(stages, new Dag(connections));\n    }","id":24441,"modified_method":"public PipelinePhase build() {\n      return new PipelinePhase(stages, connections.isEmpty() ? null : new Dag(connections));\n    }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Converts a Dag into a PipelinePhase, using what we know about the plugin type of each node in the dag.\n   * The PipelinePhase is what programs will take as input, and keeps track of sources, transforms, sinks, etc.\n   *\n   * @param dag the dag to convert\n   * @param connectors connector nodes across all dags\n   * @param specs specifications for every stage\n   * @return the converted dag\n   */\n  private PipelinePhase dagToPipeline(Dag dag, Set<String> connectors, Map<String, StageSpec> specs) {\n    PipelinePhase.Builder phaseBuilder = PipelinePhase.builder(supportedPluginTypes);\n\n    for (String stageName : dag.getTopologicalOrder()) {\n      Set<String> outputs = dag.getNodeOutputs(stageName);\n      if (!outputs.isEmpty()) {\n        phaseBuilder.addConnections(stageName, outputs);\n      }\n\n      // add connectors\n      if (connectors.contains(stageName)) {\n        phaseBuilder.addStage(Constants.CONNECTOR_TYPE, new StageInfo(stageName));\n        continue;\n      }\n\n      // add other plugin types\n      StageSpec spec = specs.get(stageName);\n      String pluginType = spec.getPlugin().getType();\n      StageInfo stageInfo = new StageInfo(stageName, spec.getInputs(), spec.getInputSchemas(), spec.getOutputs(),\n                                          spec.getOutputSchema(), spec.getErrorDatasetName());\n      phaseBuilder.addStage(pluginType, stageInfo);\n    }\n\n    return phaseBuilder.build();\n  }","id":24442,"modified_method":"/**\n   * Converts a Dag into a PipelinePhase, using what we know about the plugin type of each node in the dag.\n   * The PipelinePhase is what programs will take as input, and keeps track of sources, transforms, sinks, etc.\n   *\n   * @param dag the dag to convert\n   * @param connectors connector nodes across all dags\n   * @param specs specifications for every stage\n   * @return the converted dag\n   */\n  private PipelinePhase dagToPipeline(Dag dag, Set<String> connectors, Map<String, StageSpec> specs) {\n    PipelinePhase.Builder phaseBuilder = PipelinePhase.builder(supportedPluginTypes);\n\n    for (String stageName : dag.getTopologicalOrder()) {\n      Set<String> outputs = dag.getNodeOutputs(stageName);\n      if (!outputs.isEmpty()) {\n        phaseBuilder.addConnections(stageName, outputs);\n      }\n\n      // add connectors\n      if (connectors.contains(stageName)) {\n        phaseBuilder.addStage(StageInfo.builder(stageName, Constants.CONNECTOR_TYPE).build());\n        continue;\n      }\n\n      // add other plugin types\n      StageSpec spec = specs.get(stageName);\n      String pluginType = spec.getPlugin().getType();\n      phaseBuilder.addStage(StageInfo.builder(stageName, pluginType)\n                              .addInputs(spec.getInputs())\n                              .addInputSchemas(spec.getInputSchemas())\n                              .addOutputs(spec.getOutputs())\n                              .setOutputSchema(spec.getOutputSchema())\n                              .setErrorDatasetName(spec.getErrorDatasetName())\n                              .build());\n    }\n\n    return phaseBuilder.build();\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * This method is responsible for populating phases and phaseConnections with the Action phases.\n   * Action phase is a single stage {@link PipelinePhase} which does not have any dag.\n   * @param specs the Map of stage specs\n   * @param actionNodes the Set of action nodes in the pipeline\n   * @param phases the Map of phases created so far\n   * @param phaseConnections the Set of connections between phases added so far\n   * @param outgoingActionConnections the Map that holds set of stages to which\n   *                                  there is an outgoing connection from a Action stage\n   * @param incomingActionConnections the Map that holds set of stages to which\n   *                                  there is a incoming connection to an Action stage\n   * @param subdags subdags created so far from the pipeline stages\n   */\n  private void populateActionPhases(Map<String, StageSpec> specs, Set<String> actionNodes,\n                                    Map<String, PipelinePhase> phases, Set<Connection> phaseConnections,\n                                    SetMultimap<String, String> outgoingActionConnections,\n                                    SetMultimap<String, String> incomingActionConnections, Map<String, Dag> subdags) {\n\n    // Create single stage phases for the Action nodes\n    for (String node : actionNodes) {\n      StageSpec actionStageSpec = specs.get(node);\n      StageInfo actionStageInfo = new StageInfo(node, actionStageSpec.getInputs(), actionStageSpec.getInputSchemas(),\n                                                actionStageSpec.getOutputs(), actionStageSpec.getOutputSchema(),\n                                                actionStageSpec.getErrorDatasetName());\n\n      Map<String, Set<StageInfo>> stages  = new HashMap<>();\n      Set<StageInfo> actionStageInfos = new HashSet<>();\n      actionStageInfos.add(actionStageInfo);\n      stages.put(node, actionStageInfos);\n      phases.put(node, new PipelinePhase(stages, null));\n    }\n\n    // Build phaseConnections for the Action nodes\n    for (String sourceAction : outgoingActionConnections.keySet()) {\n      // Check if destination is one of the source stages in the pipeline\n      for (Map.Entry<String, Dag> subdagEntry : subdags.entrySet()) {\n        if (Sets.intersection(outgoingActionConnections.get(sourceAction),\n                              subdagEntry.getValue().getSources()).size() > 0) {\n          phaseConnections.add(new Connection(sourceAction, subdagEntry.getKey()));\n        }\n      }\n\n      // Check if destination is other Action node\n      for (String destination : outgoingActionConnections.get(sourceAction)) {\n        if (actionNodes.contains(destination)) {\n          phaseConnections.add(new Connection(sourceAction, destination));\n        }\n      }\n    }\n\n    // At this point we have build phaseConnections from Action node to another Action node or phaseConnections\n    // from Action node to another subdags. However it is also possible that sudags connects to the action node.\n    // Build those connections here.\n\n    for (String destinationAction : incomingActionConnections.keySet()) {\n      // Check if source is one of the sink stages in the pipeline\n      for (Map.Entry<String, Dag> subdagEntry : subdags.entrySet()) {\n        if (Sets.intersection(incomingActionConnections.get(destinationAction),\n                              subdagEntry.getValue().getSinks()).size() > 0) {\n          phaseConnections.add(new Connection(subdagEntry.getKey(), destinationAction));\n        }\n      }\n    }\n  }","id":24443,"modified_method":"/**\n   * This method is responsible for populating phases and phaseConnections with the Action phases.\n   * Action phase is a single stage {@link PipelinePhase} which does not have any dag.\n   * @param specs the Map of stage specs\n   * @param actionNodes the Set of action nodes in the pipeline\n   * @param phases the Map of phases created so far\n   * @param phaseConnections the Set of connections between phases added so far\n   * @param outgoingActionConnections the Map that holds set of stages to which\n   *                                  there is an outgoing connection from a Action stage\n   * @param incomingActionConnections the Map that holds set of stages to which\n   *                                  there is a incoming connection to an Action stage\n   * @param subdags subdags created so far from the pipeline stages\n   */\n  private void populateActionPhases(Map<String, StageSpec> specs, Set<String> actionNodes,\n                                    Map<String, PipelinePhase> phases, Set<Connection> phaseConnections,\n                                    SetMultimap<String, String> outgoingActionConnections,\n                                    SetMultimap<String, String> incomingActionConnections, Map<String, Dag> subdags) {\n\n    // Create single stage phases for the Action nodes\n    for (String node : actionNodes) {\n      StageSpec actionStageSpec = specs.get(node);\n      StageInfo actionStageInfo = StageInfo.builder(node, Action.PLUGIN_TYPE)\n        .addInputs(actionStageSpec.getInputs())\n        .addInputSchemas(actionStageSpec.getInputSchemas())\n        .addOutputs(actionStageSpec.getOutputs())\n        .setOutputSchema(actionStageSpec.getOutputSchema())\n        .setErrorDatasetName(actionStageSpec.getErrorDatasetName())\n        .build();\n      phases.put(node, PipelinePhase.builder(supportedPluginTypes).addStage(actionStageInfo).build());\n    }\n\n    // Build phaseConnections for the Action nodes\n    for (String sourceAction : outgoingActionConnections.keySet()) {\n      // Check if destination is one of the source stages in the pipeline\n      for (Map.Entry<String, Dag> subdagEntry : subdags.entrySet()) {\n        if (Sets.intersection(outgoingActionConnections.get(sourceAction),\n                              subdagEntry.getValue().getSources()).size() > 0) {\n          phaseConnections.add(new Connection(sourceAction, subdagEntry.getKey()));\n        }\n      }\n\n      // Check if destination is other Action node\n      for (String destination : outgoingActionConnections.get(sourceAction)) {\n        if (actionNodes.contains(destination)) {\n          phaseConnections.add(new Connection(sourceAction, destination));\n        }\n      }\n    }\n\n    // At this point we have build phaseConnections from Action node to another Action node or phaseConnections\n    // from Action node to another subdags. However it is also possible that sudags connects to the action node.\n    // Build those connections here.\n\n    for (String destinationAction : incomingActionConnections.keySet()) {\n      // Check if source is one of the sink stages in the pipeline\n      for (Map.Entry<String, Dag> subdagEntry : subdags.entrySet()) {\n        if (Sets.intersection(incomingActionConnections.get(destinationAction),\n                              subdagEntry.getValue().getSinks()).size() > 0) {\n          phaseConnections.add(new Connection(subdagEntry.getKey(), destinationAction));\n        }\n      }\n    }\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testGeneratePlan() {\n    /*\n             |--- n2(r) ----------|\n             |                    |                                    |-- n10\n        n1 --|--- n3(r) --- n5 ---|--- n6 --- n7(r) --- n8 --- n9(r) --|\n             |                    |                                    |-- n11\n             |--- n4(r) ----------|\n     */\n    // create the spec for this pipeline\n    ArtifactId artifactId = new ArtifactId(\"dummy\", new ArtifactVersion(\"1.0.0\"), ArtifactScope.SYSTEM);\n    Map<String, String> empty = ImmutableMap.of();\n    PluginSpec nodePlugin = new PluginSpec(NODE, \"mock\", empty, artifactId);\n    PluginSpec reducePlugin = new PluginSpec(AGGREGATOR, \"mock\", empty, artifactId);\n    Schema schema = Schema.recordOf(\"stuff\", Schema.Field.of(\"x\", Schema.of(Schema.Type.INT)));\n    Set<StageSpec> stageSpecs = ImmutableSet.of(\n      StageSpec.builder(\"n1\", nodePlugin)\n        .setOutputSchema(schema)\n        .addOutputs(\"n2\", \"n3\", \"n4\")\n        .build(),\n      StageSpec.builder(\"n2\", reducePlugin)\n        .addInputSchema(\"n1\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n1\")\n        .addOutputs(\"n6\")\n        .build(),\n      StageSpec.builder(\"n3\", reducePlugin)\n        .addInputSchema(\"n1\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n1\")\n        .addOutputs(\"n5\")\n        .build(),\n      StageSpec.builder(\"n4\", reducePlugin)\n        .addInputSchema(\"n1\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n1\")\n        .addOutputs(\"n6\")\n        .build(),\n      StageSpec.builder(\"n5\", nodePlugin)\n        .addInputSchema(\"n3\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n3\")\n        .addOutputs(\"n6\")\n        .build(),\n      StageSpec.builder(\"n6\", nodePlugin)\n        .addInputSchemas(ImmutableMap.<String, Schema>of(\"n2\", schema, \"n5\", schema, \"n4\", schema))\n        .setOutputSchema(schema)\n        .addInputs(\"n2\", \"n5\", \"n4\")\n        .addOutputs(\"n7\")\n        .build(),\n      StageSpec.builder(\"n7\", reducePlugin)\n        .addInputSchema(\"n6\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n6\")\n        .addOutputs(\"n8\")\n        .build(),\n      StageSpec.builder(\"n8\", nodePlugin)\n        .addInputSchema(\"n7\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n7\")\n        .addOutputs(\"n9\")\n        .build(),\n      StageSpec.builder(\"n9\", reducePlugin)\n        .addInputSchema(\"n8\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n8\")\n        .addOutputs(\"n10\", \"n11\")\n        .build(),\n      StageSpec.builder(\"n10\", nodePlugin)\n        .addInputSchema(\"n9\", schema)\n        .addInputs(\"n9\")\n        .build(),\n      StageSpec.builder(\"n11\", nodePlugin)\n        .addInputSchema(\"n9\", schema)\n        .addInputs(\"n9\")\n        .build()\n    );\n    Set<Connection> connections = ImmutableSet.of(\n      new Connection(\"n1\", \"n2\"),\n      new Connection(\"n1\", \"n3\"),\n      new Connection(\"n1\", \"n4\"),\n      new Connection(\"n2\", \"n6\"),\n      new Connection(\"n3\", \"n5\"),\n      new Connection(\"n4\", \"n6\"),\n      new Connection(\"n5\", \"n6\"),\n      new Connection(\"n6\", \"n7\"),\n      new Connection(\"n7\", \"n8\"),\n      new Connection(\"n8\", \"n9\"),\n      new Connection(\"n9\", \"n10\"),\n      new Connection(\"n9\", \"n11\")\n    );\n    Set<String> pluginTypes = ImmutableSet.of(NODE, AGGREGATOR, Constants.CONNECTOR_TYPE);\n    Set<String> reduceTypes = ImmutableSet.of(AGGREGATOR);\n    Set<String> isolationTypes = ImmutableSet.of();\n    PipelinePlanner planner = new PipelinePlanner(pluginTypes, reduceTypes, isolationTypes);\n    PipelineSpec pipelineSpec = new PipelineSpec(stageSpecs, connections, new Resources(), true);\n\n    Map<String, PipelinePhase> phases = new HashMap<>();\n    /*\n             |--- n2.connector\n             |\n        n1 --|--- n3.connector\n             |\n             |--- n4.connector\n     */\n    PipelinePhase phase1 = PipelinePhase.builder(pluginTypes)\n      .addStage(NODE, new StageInfo(\"n1\", ImmutableSet.<String>of(), ImmutableMap.<String, Schema>of(),\n                                    ImmutableSet.<String>of(\"n2\", \"n3\", \"n4\"), schema, null))\n      .addStages(Constants.CONNECTOR_TYPE, ImmutableSet.of(\n        new StageInfo(\"n2.connector\"),\n        new StageInfo(\"n3.connector\"),\n        new StageInfo(\"n4.connector\")))\n      .addConnections(\"n1\", ImmutableSet.of(\"n2.connector\", \"n3.connector\", \"n4.connector\"))\n      .build();\n    String phase1Name = getPhaseName(\"n1\", \"n2.connector\", \"n3.connector\", \"n4.connector\");\n    phases.put(phase1Name, phase1);\n\n    /*\n        phase2:\n        n2.connector --- n2(r) --- n6 --- n7.connector\n     */\n    PipelinePhase phase2 = PipelinePhase.builder(pluginTypes)\n      .addStage(AGGREGATOR, new StageInfo(\"n2\", ImmutableSet.<String>of(\"n1\"),\n                                          ImmutableMap.<String, Schema>of(\"n1\", schema),\n                                          ImmutableSet.<String>of(\"n6\"), schema, null))\n      .addStages(Constants.CONNECTOR_TYPE,\n                 ImmutableSet.of(new StageInfo(\"n2.connector\"), new StageInfo(\"n7.connector\")))\n      .addStage(NODE, new StageInfo(\"n6\", ImmutableSet.<String>of(\"n2\", \"n4\", \"n5\"),\n                                    ImmutableMap.<String, Schema>of(\"n2\", schema, \"n4\", schema, \"n5\", schema),\n                                    ImmutableSet.<String>of(\"n7\"), schema, null))\n      .addConnection(\"n2.connector\", \"n2\")\n      .addConnection(\"n2\", \"n6\")\n      .addConnection(\"n6\", \"n7.connector\")\n      .build();\n    String phase2Name = getPhaseName(\"n2.connector\", \"n7.connector\");\n    phases.put(phase2Name, phase2);\n\n    /*\n        phase3:\n        n3.connector --- n3(r) --- n5 --- n6 --- n7.connector\n     */\n    PipelinePhase phase3 = PipelinePhase.builder(pluginTypes)\n      .addStages(NODE, ImmutableSet.of(new StageInfo(\"n5\", ImmutableSet.<String>of(\"n3\"),\n                                                     ImmutableMap.<String, Schema>of(\"n3\", schema),\n                                                     ImmutableSet.<String>of(\"n6\"), schema, null),\n                                       new StageInfo(\"n6\", ImmutableSet.<String>of(\"n2\", \"n4\", \"n5\"),\n                                                     ImmutableMap.<String, Schema>of(\"n2\", schema, \"n4\",\n                                                                                     schema, \"n5\", schema),\n                                                     ImmutableSet.<String>of(\"n7\"), schema, null)))\n      .addStage(AGGREGATOR, new StageInfo(\"n3\", ImmutableSet.<String>of(\"n1\"),\n                                          ImmutableMap.<String, Schema>of(\"n1\", schema),\n                                          ImmutableSet.<String>of(\"n5\"), schema, null))\n      .addStages(Constants.CONNECTOR_TYPE,\n                 ImmutableSet.of(new StageInfo(\"n3.connector\"), new StageInfo(\"n7.connector\")))\n      .addConnection(\"n3.connector\", \"n3\")\n      .addConnection(\"n3\", \"n5\")\n      .addConnection(\"n5\", \"n6\")\n      .addConnection(\"n6\", \"n7.connector\")\n      .build();\n    String phase3Name = getPhaseName(\"n3.connector\", \"n7.connector\");\n    phases.put(phase3Name, phase3);\n\n    /*\n        phase4:\n        n4.connector --- n4(r) --- n6 --- n7.connector\n     */\n    PipelinePhase phase4 = PipelinePhase.builder(pluginTypes)\n      .addStage(AGGREGATOR, new StageInfo(\"n4\", ImmutableSet.<String>of(\"n1\"),\n                                          ImmutableMap.<String, Schema>of(\"n1\", schema),\n                                          ImmutableSet.<String>of(\"n6\"), schema, null))\n      .addStages(Constants.CONNECTOR_TYPE,\n                 ImmutableSet.of(new StageInfo(\"n4.connector\"), new StageInfo(\"n7.connector\")))\n      .addStage(NODE, new StageInfo(\"n6\", ImmutableSet.<String>of(\"n2\", \"n4\", \"n5\"),\n                                    ImmutableMap.<String, Schema>of(\"n2\", schema, \"n4\", schema, \"n5\", schema),\n                                    ImmutableSet.<String>of(\"n7\"), schema, null))\n      .addConnection(\"n4.connector\", \"n4\")\n      .addConnection(\"n4\", \"n6\")\n      .addConnection(\"n6\", \"n7.connector\")\n      .build();\n    String phase4Name = getPhaseName(\"n4.connector\", \"n7.connector\");\n    phases.put(phase4Name, phase4);\n\n    /*\n        phase5:\n        n7.connector --- n7(r) --- n8 --- n9.connector\n     */\n    PipelinePhase phase5 = PipelinePhase.builder(pluginTypes)\n      .addStage(NODE, new StageInfo(\"n8\", ImmutableSet.<String>of(\"n7\"),\n                                    ImmutableMap.<String, Schema>of(\"n7\", schema),\n                                    ImmutableSet.<String>of(\"n9\"), schema, null))\n      .addStage(AGGREGATOR, new StageInfo(\"n7\", ImmutableSet.<String>of(\"n6\"),\n                                          ImmutableMap.<String, Schema>of(\"n6\", schema),\n                                          ImmutableSet.<String>of(\"n8\"), schema, null))\n      .addStages(Constants.CONNECTOR_TYPE,\n                 ImmutableSet.of(new StageInfo(\"n7.connector\"), new StageInfo(\"n9.connector\")))\n      .addConnection(\"n7.connector\", \"n7\")\n      .addConnection(\"n7\", \"n8\")\n      .addConnection(\"n8\", \"n9.connector\")\n      .build();\n    String phase5Name = getPhaseName(\"n7.connector\", \"n9.connector\");\n    phases.put(phase5Name, phase5);\n\n    /*\n        phase6:\n                                 |-- n10\n        n9.connector --- n9(r) --|\n                                 |-- n11\n     */\n    PipelinePhase phase6 = PipelinePhase.builder(pluginTypes)\n      .addStages(NODE, ImmutableSet.of(new StageInfo(\"n10\", ImmutableSet.<String>of(\"n9\"),\n                                                     ImmutableMap.<String, Schema>of(\"n9\", schema),\n                                                     ImmutableSet.<String>of(), null, null),\n                                       new StageInfo(\"n11\", ImmutableSet.<String>of(\"n9\"),\n                                                     ImmutableMap.<String, Schema>of(\"n9\", schema),\n                                                     ImmutableSet.<String>of(), null, null)))\n      .addStage(AGGREGATOR, new StageInfo(\"n9\", ImmutableSet.<String>of(\"n8\"),\n                                          ImmutableMap.<String, Schema>of(\"n8\", schema),\n                                          ImmutableSet.<String>of(\"n10\", \"n11\"), schema, null))\n      .addStage(Constants.CONNECTOR_TYPE, new StageInfo(\"n9.connector\"))\n      .addConnection(\"n9.connector\", \"n9\")\n      .addConnection(\"n9\", \"n10\")\n      .addConnection(\"n9\", \"n11\")\n      .build();\n    String phase6Name = getPhaseName(\"n9.connector\", \"n10\", \"n11\");\n    phases.put(phase6Name, phase6);\n\n    Set<Connection> phaseConnections = new HashSet<>();\n    phaseConnections.add(new Connection(phase1Name, phase2Name));\n    phaseConnections.add(new Connection(phase1Name, phase3Name));\n    phaseConnections.add(new Connection(phase1Name, phase4Name));\n    phaseConnections.add(new Connection(phase2Name, phase5Name));\n    phaseConnections.add(new Connection(phase3Name, phase5Name));\n    phaseConnections.add(new Connection(phase4Name, phase5Name));\n    phaseConnections.add(new Connection(phase5Name, phase6Name));\n\n    PipelinePlan expected = new PipelinePlan(phases, phaseConnections);\n    PipelinePlan actual = planner.plan(pipelineSpec);\n    Assert.assertEquals(expected, actual);\n  }","id":24444,"modified_method":"@Test\n  public void testGeneratePlan() {\n    /*\n             |--- n2(r) ----------|\n             |                    |                                    |-- n10\n        n1 --|--- n3(r) --- n5 ---|--- n6 --- n7(r) --- n8 --- n9(r) --|\n             |                    |                                    |-- n11\n             |--- n4(r) ----------|\n     */\n    // create the spec for this pipeline\n    ArtifactId artifactId = new ArtifactId(\"dummy\", new ArtifactVersion(\"1.0.0\"), ArtifactScope.SYSTEM);\n    Map<String, String> empty = ImmutableMap.of();\n    PluginSpec nodePlugin = new PluginSpec(NODE, \"mock\", empty, artifactId);\n    PluginSpec reducePlugin = new PluginSpec(AGGREGATOR, \"mock\", empty, artifactId);\n    Schema schema = Schema.recordOf(\"stuff\", Schema.Field.of(\"x\", Schema.of(Schema.Type.INT)));\n    Set<StageSpec> stageSpecs = ImmutableSet.of(\n      StageSpec.builder(\"n1\", nodePlugin)\n        .setOutputSchema(schema)\n        .addOutputs(\"n2\", \"n3\", \"n4\")\n        .build(),\n      StageSpec.builder(\"n2\", reducePlugin)\n        .addInputSchema(\"n1\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n1\")\n        .addOutputs(\"n6\")\n        .build(),\n      StageSpec.builder(\"n3\", reducePlugin)\n        .addInputSchema(\"n1\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n1\")\n        .addOutputs(\"n5\")\n        .build(),\n      StageSpec.builder(\"n4\", reducePlugin)\n        .addInputSchema(\"n1\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n1\")\n        .addOutputs(\"n6\")\n        .build(),\n      StageSpec.builder(\"n5\", nodePlugin)\n        .addInputSchema(\"n3\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n3\")\n        .addOutputs(\"n6\")\n        .build(),\n      StageSpec.builder(\"n6\", nodePlugin)\n        .addInputSchemas(ImmutableMap.of(\"n2\", schema, \"n5\", schema, \"n4\", schema))\n        .setOutputSchema(schema)\n        .addInputs(\"n2\", \"n5\", \"n4\")\n        .addOutputs(\"n7\")\n        .build(),\n      StageSpec.builder(\"n7\", reducePlugin)\n        .addInputSchema(\"n6\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n6\")\n        .addOutputs(\"n8\")\n        .build(),\n      StageSpec.builder(\"n8\", nodePlugin)\n        .addInputSchema(\"n7\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n7\")\n        .addOutputs(\"n9\")\n        .build(),\n      StageSpec.builder(\"n9\", reducePlugin)\n        .addInputSchema(\"n8\", schema)\n        .setOutputSchema(schema)\n        .addInputs(\"n8\")\n        .addOutputs(\"n10\", \"n11\")\n        .build(),\n      StageSpec.builder(\"n10\", nodePlugin)\n        .addInputSchema(\"n9\", schema)\n        .addInputs(\"n9\")\n        .build(),\n      StageSpec.builder(\"n11\", nodePlugin)\n        .addInputSchema(\"n9\", schema)\n        .addInputs(\"n9\")\n        .build()\n    );\n    Set<Connection> connections = ImmutableSet.of(\n      new Connection(\"n1\", \"n2\"),\n      new Connection(\"n1\", \"n3\"),\n      new Connection(\"n1\", \"n4\"),\n      new Connection(\"n2\", \"n6\"),\n      new Connection(\"n3\", \"n5\"),\n      new Connection(\"n4\", \"n6\"),\n      new Connection(\"n5\", \"n6\"),\n      new Connection(\"n6\", \"n7\"),\n      new Connection(\"n7\", \"n8\"),\n      new Connection(\"n8\", \"n9\"),\n      new Connection(\"n9\", \"n10\"),\n      new Connection(\"n9\", \"n11\")\n    );\n    Set<String> pluginTypes = ImmutableSet.of(NODE, AGGREGATOR, Constants.CONNECTOR_TYPE);\n    Set<String> reduceTypes = ImmutableSet.of(AGGREGATOR);\n    Set<String> isolationTypes = ImmutableSet.of();\n    PipelinePlanner planner = new PipelinePlanner(pluginTypes, reduceTypes, isolationTypes);\n    PipelineSpec pipelineSpec = new PipelineSpec(stageSpecs, connections, new Resources(), true);\n\n    Map<String, PipelinePhase> phases = new HashMap<>();\n    /*\n             |--- n2.connector\n             |\n        n1 --|--- n3.connector\n             |\n             |--- n4.connector\n     */\n    PipelinePhase phase1 = PipelinePhase.builder(pluginTypes)\n      .addStage(StageInfo.builder(\"n1\", NODE).addOutputs(\"n2\", \"n3\", \"n4\").setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n2.connector\", Constants.CONNECTOR_TYPE).build())\n      .addStage(StageInfo.builder(\"n3.connector\", Constants.CONNECTOR_TYPE).build())\n      .addStage(StageInfo.builder(\"n4.connector\", Constants.CONNECTOR_TYPE).build())\n      .addConnections(\"n1\", ImmutableSet.of(\"n2.connector\", \"n3.connector\", \"n4.connector\"))\n      .build();\n    String phase1Name = getPhaseName(\"n1\", \"n2.connector\", \"n3.connector\", \"n4.connector\");\n    phases.put(phase1Name, phase1);\n\n    /*\n        phase2:\n        n2.connector --- n2(r) --- n6 --- n7.connector\n     */\n    PipelinePhase phase2 = PipelinePhase.builder(pluginTypes)\n      .addStage(StageInfo.builder(\"n2\", AGGREGATOR)\n                  .addInputs(\"n1\")\n                  .addInputSchema(\"n1\", schema)\n                  .addOutputs(\"n6\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n6\", NODE)\n                  .addInputs(\"n2\", \"n4\", \"n5\")\n                  .addInputSchema(\"n2\", schema)\n                  .addInputSchema(\"n4\", schema)\n                  .addInputSchema(\"n5\", schema)\n                  .addOutputs(\"n7\")\n                  .setOutputSchema(schema)\n                  .build())\n      .addStage(StageInfo.builder(\"n2.connector\", Constants.CONNECTOR_TYPE).build())\n      .addStage(StageInfo.builder(\"n7.connector\", Constants.CONNECTOR_TYPE).build())\n      .addConnection(\"n2.connector\", \"n2\")\n      .addConnection(\"n2\", \"n6\")\n      .addConnection(\"n6\", \"n7.connector\")\n      .build();\n    String phase2Name = getPhaseName(\"n2.connector\", \"n7.connector\");\n    phases.put(phase2Name, phase2);\n\n    /*\n        phase3:\n        n3.connector --- n3(r) --- n5 --- n6 --- n7.connector\n     */\n    PipelinePhase phase3 = PipelinePhase.builder(pluginTypes)\n      .addStage(StageInfo.builder(\"n5\", NODE)\n                  .addInputs(\"n3\")\n                  .addInputSchema(\"n3\", schema)\n                  .addOutputs(\"n6\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n6\", NODE)\n                  .addInputs(\"n2\", \"n4\", \"n5\")\n                  .addInputSchema(\"n2\", schema)\n                  .addInputSchema(\"n4\", schema)\n                  .addInputSchema(\"n5\", schema)\n                  .addOutputs(\"n7\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n3\", AGGREGATOR)\n                  .addInputs(\"n1\")\n                  .addInputSchema(\"n1\", schema)\n                  .addOutputs(\"n5\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n3.connector\", Constants.CONNECTOR_TYPE).build())\n      .addStage(StageInfo.builder(\"n7.connector\", Constants.CONNECTOR_TYPE).build())\n      .addConnection(\"n3.connector\", \"n3\")\n      .addConnection(\"n3\", \"n5\")\n      .addConnection(\"n5\", \"n6\")\n      .addConnection(\"n6\", \"n7.connector\")\n      .build();\n    String phase3Name = getPhaseName(\"n3.connector\", \"n7.connector\");\n    phases.put(phase3Name, phase3);\n\n    /*\n        phase4:\n        n4.connector --- n4(r) --- n6 --- n7.connector\n     */\n    PipelinePhase phase4 = PipelinePhase.builder(pluginTypes)\n      .addStage(StageInfo.builder(\"n4\", AGGREGATOR)\n                  .addInputs(\"n1\")\n                  .addInputSchema(\"n1\", schema)\n                  .addOutputs(\"n6\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n6\", NODE)\n                  .addInputs(\"n2\", \"n4\", \"n5\")\n                  .addInputSchema(\"n2\", schema)\n                  .addInputSchema(\"n4\", schema)\n                  .addInputSchema(\"n5\", schema)\n                  .addOutputs(\"n7\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n4.connector\", Constants.CONNECTOR_TYPE).build())\n      .addStage(StageInfo.builder(\"n7.connector\", Constants.CONNECTOR_TYPE).build())\n      .addConnection(\"n4.connector\", \"n4\")\n      .addConnection(\"n4\", \"n6\")\n      .addConnection(\"n6\", \"n7.connector\")\n      .build();\n    String phase4Name = getPhaseName(\"n4.connector\", \"n7.connector\");\n    phases.put(phase4Name, phase4);\n\n    /*\n        phase5:\n        n7.connector --- n7(r) --- n8 --- n9.connector\n     */\n    PipelinePhase phase5 = PipelinePhase.builder(pluginTypes)\n      .addStage(StageInfo.builder(\"n8\", NODE)\n                  .addInputs(\"n7\")\n                  .addInputSchema(\"n7\", schema)\n                  .addOutputs(\"n9\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n7\", AGGREGATOR)\n                  .addInputs(\"n6\")\n                  .addInputSchema(\"n6\", schema)\n                  .addOutputs(\"n8\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n7.connector\", Constants.CONNECTOR_TYPE).build())\n      .addStage(StageInfo.builder(\"n9.connector\", Constants.CONNECTOR_TYPE).build())\n      .addConnection(\"n7.connector\", \"n7\")\n      .addConnection(\"n7\", \"n8\")\n      .addConnection(\"n8\", \"n9.connector\")\n      .build();\n    String phase5Name = getPhaseName(\"n7.connector\", \"n9.connector\");\n    phases.put(phase5Name, phase5);\n\n    /*\n        phase6:\n                                 |-- n10\n        n9.connector --- n9(r) --|\n                                 |-- n11\n     */\n    PipelinePhase phase6 = PipelinePhase.builder(pluginTypes)\n      .addStage(StageInfo.builder(\"n10\", NODE)\n                  .addInputs(\"n9\")\n                  .addInputSchema(\"n9\", schema).build())\n      .addStage(StageInfo.builder(\"n11\", NODE)\n                  .addInputs(\"n9\")\n                  .addInputSchema(\"n9\", schema).build())\n      .addStage(StageInfo.builder(\"n9\", AGGREGATOR)\n                  .addInputs(\"n8\")\n                  .addInputSchema(\"n8\", schema)\n                  .addOutputs(\"n10\", \"n11\")\n                  .setOutputSchema(schema).build())\n      .addStage(StageInfo.builder(\"n9.connector\", Constants.CONNECTOR_TYPE).build())\n      .addConnection(\"n9.connector\", \"n9\")\n      .addConnection(\"n9\", \"n10\")\n      .addConnection(\"n9\", \"n11\")\n      .build();\n    String phase6Name = getPhaseName(\"n9.connector\", \"n10\", \"n11\");\n    phases.put(phase6Name, phase6);\n\n    Set<Connection> phaseConnections = new HashSet<>();\n    phaseConnections.add(new Connection(phase1Name, phase2Name));\n    phaseConnections.add(new Connection(phase1Name, phase3Name));\n    phaseConnections.add(new Connection(phase1Name, phase4Name));\n    phaseConnections.add(new Connection(phase2Name, phase5Name));\n    phaseConnections.add(new Connection(phase3Name, phase5Name));\n    phaseConnections.add(new Connection(phase4Name, phase5Name));\n    phaseConnections.add(new Connection(phase5Name, phase6Name));\n\n    PipelinePlan expected = new PipelinePlan(phases, phaseConnections);\n    PipelinePlan actual = planner.plan(pipelineSpec);\n    Assert.assertEquals(expected, actual);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void configure() {\n    setName(NAME);\n    setDescription(DESCRIPTION);\n\n    // set the pipeline spec as a property in case somebody like the UI wants to read it\n    Map<String, String> properties = new HashMap<>();\n    properties.put(Constants.PIPELINE_SPEC_KEY, GSON.toJson(spec));\n    setProperties(properties);\n\n    // single phase, just add the program directly\n    if (plan.getPhases().size() == 1) {\n      addProgram(plan.getPhases().keySet().iterator().next(), new TrunkProgramAdder(getConfigurer()));\n      return;\n    }\n\n    // Dag classes don't allow a 'dag' without connections\n    if (plan.getPhaseConnections().isEmpty()) {\n\n      WorkflowProgramAdder programAdder;\n      // multiple phases, do a fork then join\n      WorkflowForkConfigurer forkConfigurer = getConfigurer().fork();\n      programAdder = new BranchProgramAdder(forkConfigurer);\n      for (String phaseName : plan.getPhases().keySet()) {\n        addProgram(phaseName, programAdder);\n      }\n      if (forkConfigurer != null) {\n        forkConfigurer.join();\n      }\n      return;\n    }\n\n    dag = new ControlDag(plan.getPhaseConnections());\n    // after flattening, there is guaranteed to be just one source\n    dag.flatten();\n    String start = dag.getSources().iterator().next();\n    addPrograms(start, getConfigurer());\n  }","id":24445,"modified_method":"@Override\n  protected void configure() {\n    setName(NAME);\n    setDescription(DESCRIPTION);\n\n    // set the pipeline spec as a property in case somebody like the UI wants to read it\n    Map<String, String> properties = new HashMap<>();\n    properties.put(Constants.PIPELINE_SPEC_KEY, GSON.toJson(spec));\n    setProperties(properties);\n\n    useSpark = engine == Engine.SPARK;\n    if (!useSpark) {\n      for (StageSpec stageSpec : spec.getStages()) {\n        String pluginType = stageSpec.getPlugin().getType();\n        if (SparkCompute.PLUGIN_TYPE.equals(pluginType) || SparkSink.PLUGIN_TYPE.equals(pluginType)) {\n          useSpark = true;\n          break;\n        }\n      }\n    }\n\n    PipelinePlanner planner;\n    if (useSpark) {\n      // if the pipeline uses spark, we don't need to break the pipeline up into phases, we can just have\n      // a single phase.\n      planner = new PipelinePlanner(supportedPluginTypes, ImmutableSet.<String>of(), ImmutableSet.<String>of());\n    } else {\n      planner = new PipelinePlanner(supportedPluginTypes,\n                                    ImmutableSet.of(BatchAggregator.PLUGIN_TYPE, BatchJoiner.PLUGIN_TYPE),\n                                    ImmutableSet.of(SparkCompute.PLUGIN_TYPE, SparkSink.PLUGIN_TYPE));\n    }\n    plan = planner.plan(spec);\n\n    // single phase, just add the program directly\n    if (plan.getPhases().size() == 1) {\n      addProgram(plan.getPhases().keySet().iterator().next(), new TrunkProgramAdder(getConfigurer()));\n      return;\n    }\n\n    // Dag classes don't allow a 'dag' without connections\n    if (plan.getPhaseConnections().isEmpty()) {\n\n      WorkflowProgramAdder programAdder;\n      // multiple phases, do a fork then join\n      WorkflowForkConfigurer forkConfigurer = getConfigurer().fork();\n      programAdder = new BranchProgramAdder(forkConfigurer);\n      for (String phaseName : plan.getPhases().keySet()) {\n        addProgram(phaseName, programAdder);\n      }\n      if (forkConfigurer != null) {\n        forkConfigurer.join();\n      }\n      return;\n    }\n\n    dag = new ControlDag(plan.getPhaseConnections());\n    // after flattening, there is guaranteed to be just one source\n    dag.flatten();\n    String start = dag.getSources().iterator().next();\n    addPrograms(start, getConfigurer());\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"private void addProgram(String phaseName, WorkflowProgramAdder programAdder) {\n    PipelinePhase phase = plan.getPhase(phaseName);\n    // if the origin plan didn't have this name, it means it is a join node\n    // artificially added by the control dag flattening process. So nothing to add, skip it\n    if (phase == null) {\n      return;\n    }\n\n    // can't use phase name as a program name because it might contain invalid characters\n    String programName = \"phase-\" + phaseNum;\n    phaseNum++;\n    // TODO: add support for other program types based on the plugin types in the phase\n\n    // if this phase uses connectors, add the local dataset for that connector if we haven't already\n    for (StageInfo connectorInfo : phase.getStagesOfType(Constants.CONNECTOR_TYPE)) {\n      String connectorName = connectorInfo.getName();\n      String datasetName = connectorDatasets.get(connectorName);\n      if (datasetName == null) {\n        datasetName = UUID.randomUUID().toString();\n        connectorDatasets.put(connectorName, datasetName);\n        // add the local dataset\n        ConnectorSource connectorSource = new ConnectorSource(datasetName, null);\n        connectorSource.configure(getConfigurer());\n      }\n    }\n\n    Map<String, String> phaseConnectorDatasets = new HashMap<>();\n    for (StageInfo connectorStage : phase.getStagesOfType(Constants.CONNECTOR_TYPE)) {\n      phaseConnectorDatasets.put(connectorStage.getName(), connectorDatasets.get(connectorStage.getName()));\n    }\n    BatchPhaseSpec batchPhaseSpec = new BatchPhaseSpec(programName, phase, spec.getResources(),\n                                                       spec.isStageLoggingEnabled(), phaseConnectorDatasets);\n\n    // Custom action is the only phase in the pipeline which has no associated dag\n    boolean hasCustomAction = batchPhaseSpec.getPhase().getSources().isEmpty()\n      && batchPhaseSpec.getPhase().getSinks().isEmpty();\n    if (hasCustomAction) {\n      // Add custom action to the Workflow\n      programAdder.addAction(new PipelineAction(batchPhaseSpec));\n      return;\n    }\n\n    boolean hasSparkCompute = !batchPhaseSpec.getPhase().getStagesOfType(SparkCompute.PLUGIN_TYPE).isEmpty();\n    boolean hasSparkSink = !batchPhaseSpec.getPhase().getStagesOfType(SparkSink.PLUGIN_TYPE).isEmpty();\n\n    if (hasSparkCompute || hasSparkSink) {\n      // always use ETLSpark if this phase has a spark plugin\n      applicationConfigurer.addSpark(new ETLSpark(batchPhaseSpec));\n      programAdder.addSpark(programName);\n    } else {\n      switch (engine) {\n        case MAPREDUCE:\n          applicationConfigurer.addMapReduce(new ETLMapReduce(batchPhaseSpec));\n          programAdder.addMapReduce(programName);\n          break;\n        case SPARK:\n          applicationConfigurer.addSpark(new ETLSpark(batchPhaseSpec));\n          programAdder.addSpark(programName);\n          break;\n        default:\n          // should never happen\n          throw new IllegalStateException(\"Unsupported engine \" + engine);\n      }\n    }\n  }","id":24446,"modified_method":"private void addProgram(String phaseName, WorkflowProgramAdder programAdder) {\n    PipelinePhase phase = plan.getPhase(phaseName);\n    // if the origin plan didn't have this name, it means it is a join node\n    // artificially added by the control dag flattening process. So nothing to add, skip it\n    if (phase == null) {\n      return;\n    }\n\n    // can't use phase name as a program name because it might contain invalid characters\n    String programName = \"phase-\" + phaseNum;\n    phaseNum++;\n\n    // if this phase uses connectors, add the local dataset for that connector if we haven't already\n    for (StageInfo connectorInfo : phase.getStagesOfType(Constants.CONNECTOR_TYPE)) {\n      String connectorName = connectorInfo.getName();\n      String datasetName = connectorDatasets.get(connectorName);\n      if (datasetName == null) {\n        datasetName = UUID.randomUUID().toString();\n        connectorDatasets.put(connectorName, datasetName);\n        // add the local dataset\n        ConnectorSource connectorSource = new ConnectorSource(datasetName, null);\n        connectorSource.configure(getConfigurer());\n      }\n    }\n\n    Map<String, String> phaseConnectorDatasets = new HashMap<>();\n    for (StageInfo connectorStage : phase.getStagesOfType(Constants.CONNECTOR_TYPE)) {\n      phaseConnectorDatasets.put(connectorStage.getName(), connectorDatasets.get(connectorStage.getName()));\n    }\n    BatchPhaseSpec batchPhaseSpec = new BatchPhaseSpec(programName, phase, spec.getResources(),\n                                                       spec.getDriverResources(),\n                                                       spec.isStageLoggingEnabled(), phaseConnectorDatasets);\n\n    // Custom action is the only phase in the pipeline which has no associated dag\n    boolean hasCustomAction = batchPhaseSpec.getPhase().getSources().isEmpty()\n      && batchPhaseSpec.getPhase().getSinks().isEmpty();\n    if (hasCustomAction) {\n      // Add custom action to the Workflow\n      programAdder.addAction(new PipelineAction(batchPhaseSpec));\n      return;\n    }\n\n    if (useSpark) {\n      applicationConfigurer.addSpark(new ETLSpark(batchPhaseSpec));\n      programAdder.addSpark(programName);\n    } else {\n      applicationConfigurer.addMapReduce(new ETLMapReduce(batchPhaseSpec));\n      programAdder.addMapReduce(programName);\n    }\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public SmartWorkflow(BatchPipelineSpec spec,\n                       PipelinePlan plan,\n                       ApplicationConfigurer applicationConfigurer,\n                       Engine engine) {\n    this.spec = spec;\n    this.plan = plan;\n    this.applicationConfigurer = applicationConfigurer;\n    this.phaseNum = 1;\n    this.connectorDatasets = new HashMap<>();\n    this.engine = engine;\n  }","id":24447,"modified_method":"public SmartWorkflow(BatchPipelineSpec spec,\n                       Set<String> supportedPluginTypes,\n                       ApplicationConfigurer applicationConfigurer,\n                       Engine engine) {\n    this.spec = spec;\n    this.supportedPluginTypes = supportedPluginTypes;\n    this.applicationConfigurer = applicationConfigurer;\n    this.phaseNum = 1;\n    this.connectorDatasets = new HashMap<>();\n    this.engine = engine;\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    StageInfo that = (StageInfo) o;\n\n    return Objects.equals(name, that.name) &&\n      Objects.equals(inputs, that.inputs) &&\n      Objects.equals(inputSchemas, that.inputSchemas) &&\n      Objects.equals(outputs, that.outputs) &&\n      Objects.equals(outputSchema, that.outputSchema) &&\n      Objects.equals(errorDatasetName, that.errorDatasetName);\n  }","id":24448,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    StageInfo that = (StageInfo) o;\n\n    return Objects.equals(name, that.name) &&\n      Objects.equals(pluginType, that.pluginType) &&\n      Objects.equals(inputs, that.inputs) &&\n      Objects.equals(inputSchemas, that.inputSchemas) &&\n      Objects.equals(outputs, that.outputs) &&\n      Objects.equals(outputSchema, that.outputSchema) &&\n      Objects.equals(errorDatasetName, that.errorDatasetName);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return \"StageInfo{\" +\n      \"name='\" + name + '\\'' +\n      \"inputs='\" + inputs + '\\'' +\n      \"inputSchemas='\" + inputSchemas + '\\'' +\n      \"outputs='\" + outputs + '\\'' +\n      \"outputSchema='\" + outputSchema + '\\'' +\n      \", errorDatasetName='\" + errorDatasetName + '\\'' +\n      '}';\n  }","id":24449,"modified_method":"@Override\n  public String toString() {\n    return \"StageInfo{\" +\n      \"name='\" + name + '\\'' +\n      \"pluginType='\" + pluginType + '\\'' +\n      \"inputs='\" + inputs + '\\'' +\n      \"inputSchemas='\" + inputSchemas + '\\'' +\n      \"outputs='\" + outputs + '\\'' +\n      \"outputSchema='\" + outputSchema + '\\'' +\n      \", errorDatasetName='\" + errorDatasetName + '\\'' +\n      '}';\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"public StageInfo(String name, @Nullable Set<String> inputs, @Nullable Map<String, Schema> inputSchemas,\n                   @Nullable Set<String> outputs, @Nullable Schema outputSchema, @Nullable String errorDatasetName) {\n    this.name = name;\n    this.inputSchemas = inputSchemas;\n    this.outputSchema = outputSchema;\n    this.inputs = ImmutableSet.copyOf(inputs);\n    this.outputs = ImmutableSet.copyOf(outputs);\n    this.errorDatasetName = errorDatasetName;\n  }","id":24450,"modified_method":"private StageInfo(String name, String pluginType, Set<String> inputs, Map<String, Schema> inputSchemas,\n                    Set<String> outputs, @Nullable Schema outputSchema, @Nullable String errorDatasetName) {\n    this.name = name;\n    this.pluginType = pluginType;\n    this.inputSchemas = Collections.unmodifiableMap(inputSchemas);\n    this.outputSchema = outputSchema;\n    this.inputs = ImmutableSet.copyOf(inputs);\n    this.outputs = ImmutableSet.copyOf(outputs);\n    this.errorDatasetName = errorDatasetName;\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int hashCode() {\n    return Objects.hash(name, inputs, inputSchemas, outputs, outputSchema, errorDatasetName);\n  }","id":24451,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hash(name, pluginType, inputs, inputSchemas,\n                        outputs, outputSchema, errorDatasetName);\n  }","commit_id":"adbe8850f5e14dae21bb65e53586048b6bc3f2dd","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n\tpublic void roomDisconnect(IConnection conn) {\n\n\t\tString remoteHost = Red5.getConnectionLocal().getRemoteAddress();\n\t\tint remotePort = Red5.getConnectionLocal().getRemotePort();    \t\n\t\tString clientId = Red5.getConnectionLocal().getClient().getId();\n\t\tlog.info(\"***** \" + APP + \"[clientid=\" + clientId + \"] disconnnected from \" + remoteHost + \":\" + remotePort + \".\");\n    \t\n\t\tconnInvokerService.removeConnection(getBbbSession().getInternalUserID());\n    \t\n\t\tBigBlueButtonSession bbbSession = (BigBlueButtonSession) Red5.getConnectionLocal().getAttribute(Constants.SESSION);\n\t\t\n\t\tString meetingId = bbbSession.getRoom();\n\t\tString userId = bbbSession.getInternalUserID();\n\t\tString connType = getConnectionType(Red5.getConnectionLocal().getType());\n\t\tString userFullname = bbbSession.getUsername();\n\t\tString connId = Red5.getConnectionLocal().getSessionId();\n\t\t\n\t\tlog.info(\"User disconnected: sessionId=[\" + connId + \"], encoding=[\" + connType +\n\t\t\t\t\"], meetingId= [\" + meetingId + \"], userId=[\" + userId + \"] username=[\" + userFullname +\"]\");\n\t\n\t\tMap<String, Object> logData = new HashMap<String, Object>();\n\t\tlogData.put(\"meetingId\", meetingId);\n\t\tlogData.put(\"connType\", connType);\n\t\tlogData.put(\"connId\", connId);\n\t\tlogData.put(\"userId\", userId);\n\t\tlogData.put(\"username\", userFullname);\n\t\tlogData.put(\"event\", \"user_leaving_bbb_apps\");\n\t\tlogData.put(\"description\", \"User leaving BBB Apps.\");\n\t\t\n\t\tbbbGW.userLeft(bbbSession.getRoom(), getBbbSession().getInternalUserID());\n\t\t\n\t\tsuper.roomDisconnect(conn);\n\t}","id":24452,"modified_method":"@Override\n\tpublic void roomDisconnect(IConnection conn) {\n\n\t\tString remoteHost = Red5.getConnectionLocal().getRemoteAddress();\n\t\tint remotePort = Red5.getConnectionLocal().getRemotePort();    \t\n\t\tString clientId = Red5.getConnectionLocal().getClient().getId();\n\t\tlog.info(\"***** \" + APP + \"[clientid=\" + clientId + \"] disconnnected from \" + remoteHost + \":\" + remotePort + \".\");\n\n\t    BigBlueButtonSession bbbSession = (BigBlueButtonSession) Red5.getConnectionLocal().getAttribute(Constants.SESSION);\n\t          \n\t    String meetingId = bbbSession.getRoom();\n\t    String userId = bbbSession.getInternalUserID();\n\t    String connType = getConnectionType(Red5.getConnectionLocal().getType());\n\t    String userFullname = bbbSession.getUsername();\n\t    String connId = Red5.getConnectionLocal().getSessionId();\n\t    \n        String sessionId =  CONN + connId + \"-\" + userId;\n\t    \n\t    log.info(\"User disconnected: sessionId=[\" + sessionId + \"], encoding=[\" + connType +\n\t                \"], meetingId= [\" + meetingId + \"], userId=[\" + userId + \"] username=[\" + userFullname +\"]\");\n\t    \n\t    Map<String, Object> logData = new HashMap<String, Object>();\n\t    logData.put(\"meetingId\", meetingId);\n\t    logData.put(\"connType\", connType);\n\t    logData.put(\"connId\", connId);\n\t    logData.put(\"sessionId\", sessionId);\n\t    logData.put(\"userId\", userId);\n\t    logData.put(\"username\", userFullname);\n\t    logData.put(\"event\", \"user_leaving_bbb_apps\");\n\t    logData.put(\"description\", \"User leaving BBB Apps.\");\n\t    \n\t    Gson gson = new Gson();\n\t    String logStr =  gson.toJson(logData);\n\t        \n\t    log.info(\"User leaving bbb-apps: data={}\", logStr);\n\t        \n\t\tconnInvokerService.removeConnection(sessionId);\n    \t        \n\t\tbbbGW.userLeft(bbbSession.getRoom(), getBbbSession().getInternalUserID(), sessionId);\n\t\t\n\t\tsuper.roomDisconnect(conn);\n\t}","commit_id":"5798f727c54acae6de100cbb3a436e1383df8a61","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void joinMeeting(String userId) {\n\t\tBigBlueButtonSession bbbSession = getBbbSession();\n\t\tif (bbbSession != null) {\n\t\t\tString userid = bbbSession.getInternalUserID();\n\t\t\tString username = bbbSession.getUsername();\n\t\t\tString role = bbbSession.getRole();\n\t\t\tString meetingId = bbbSession.getRoom();\n\t\t\tlog.debug(APP + \":joinMeeting - [\" + meetingId + \"] [\" + userid + \", \" + username + \", \" + role + \"]\");\n\t\t\t\n\t\t\tbbbGW.userJoin(meetingId, userid);\n\t\t}\n\t\t\n\t}","id":24453,"modified_method":"public void joinMeeting(String userId) {\n\t\tBigBlueButtonSession bbbSession = getBbbSession();\n\t\tif (bbbSession != null) {\n\t\t\tString userid = bbbSession.getInternalUserID();\n\t\t\tString username = bbbSession.getUsername();\n\t\t\tString role = bbbSession.getRole();\n\t\t\tString meetingId = bbbSession.getRoom();\n\t\t\tlog.debug(APP + \":joinMeeting - [\" + meetingId + \"] [\" + userid + \", \" + username + \", \" + role + \"]\");\n\t\t    \n\t\t\tString connId = Red5.getConnectionLocal().getSessionId();    \n\t        String sessionId =  CONN + connId + \"-\" + userId;\n\t        \n\t        Map<String, Object> logData = new HashMap<String, Object>();\n\t        logData.put(\"meetingId\", meetingId);\n\t        logData.put(\"connId\", connId);\n\t        logData.put(\"userId\", userId);\n\t        logData.put(\"sessionId\", sessionId);\n\t        logData.put(\"username\", username);\n\t        logData.put(\"event\", \"user_join_bbb_apps\");\n\t        logData.put(\"description\", \"User join BBB Apps.\");\n\t        \n\t        Gson gson = new Gson();\n\t        String logStr =  gson.toJson(logData);\n\t        \n\t        log.info(\"User join bbb-aaps: data={}\", logStr);\n\t\t\tbbbGW.userJoin(meetingId, userid, sessionId);\n\t\t}\n\t\t\n\t}","commit_id":"5798f727c54acae6de100cbb3a436e1383df8a61","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n\tpublic boolean roomConnect(IConnection connection, Object[] params) {\n\t\tString username = ((String) params[0]).toString();\n\t\tString role = ((String) params[1]).toString();\n\t\tString room = ((String)params[2]).toString();\n               \n\t\tString voiceBridge = ((String) params[3]).toString();\n\t\t\n\t\tboolean record = (Boolean)params[4];\n\t\t\n\t\tString externalUserID = ((String) params[5]).toString();\n\t\tString internalUserID = ((String) params[6]).toString();\n    \t\n\t\tBoolean locked = false;\n\t\tif (params.length >= 7 && ((Boolean) params[7])) {\n\t\t\tlocked = true;\n\t\t}\n    \t\n\t\tBoolean muted  = false;\n\t\tif (params.length >= 8 && ((Boolean) params[8])) {\n\t\t\tmuted = true;\n\t\t}\n    \t\n\t\tMap<String, Boolean> lsMap = null;\n\t\tif (params.length >= 9) {\n\t\t\ttry {\n\t\t\t\tlsMap = (Map<String, Boolean> ) params[9];\n\t\t\t} catch(Exception e){\n\t\t\t\tlsMap = new HashMap<String, Boolean>();\n\t\t\t}\n\t\t}\n    \t   \t    \t\n\t\tif (record == true) {\n\t\t\trecorderApplication.createRecordSession(room);\n\t\t}\n\t\t\t\n\t\tBigBlueButtonSession bbbSession = new BigBlueButtonSession(room, internalUserID,  username, role, \n    \t\t\tvoiceBridge, record, externalUserID, muted);\n\t\tconnection.setAttribute(Constants.SESSION, bbbSession);        \n\t\tconnection.setAttribute(\"INTERNAL_USER_ID\", internalUserID);\n        \n\t\tString debugInfo = \"internalUserID=\" + internalUserID + \",username=\" + username + \",role=\" +  role + \",\" + \n        \t\t\t\t\t\",voiceConf=\" + voiceBridge + \",room=\" + room + \",externalUserid=\" + externalUserID;\n\t\tlog.debug(\"User [{}] connected to room [{}]\", debugInfo, room); \n\n\t\tbbbGW.initLockSettings(room, locked, lsMap);\n\t\t\n\t\tconnInvokerService.addConnection(bbbSession.getInternalUserID(), connection);\n\n\t\tString meetingId = bbbSession.getRoom();\n\t\tString userId = bbbSession.getInternalUserID();\n\t\tString connType = getConnectionType(Red5.getConnectionLocal().getType());\n\t\tString userFullname = bbbSession.getUsername();\n\t\tString connId = Red5.getConnectionLocal().getSessionId();\n\t\t\n\t\tlog.info(\"User connected: sessionId=[\" + connId + \"], encoding=[\" + connType +\n\t\t\t\t\"], meetingId= [\" + meetingId\n\t\t\t\t+ \"], userId=[\" + userId + \"] username=[\" + userFullname +\"]\");\n\n\n\t\tMap<String, Object> logData = new HashMap<String, Object>();\n\t\tlogData.put(\"meetingId\", meetingId);\n\t\tlogData.put(\"connType\", connType);\n\t\tlogData.put(\"connId\", connId);\n\t\tlogData.put(\"userId\", userId);\n\t\tlogData.put(\"username\", userFullname);\n\t\tlogData.put(\"event\", \"user_joining_bbb_apps\");\n\t\tlogData.put(\"description\", \"User joining BBB Apps.\");\n\t\t\n\t\tGson gson = new Gson();\n    String logStr =  gson.toJson(logData);\n\t\t\n\t\tlog.info(\"User joining bbbb-aps: data={}\", logStr);\n\t\t\n\t\treturn super.roomConnect(connection, params);\n        \n\t}","id":24454,"modified_method":"@Override\n\tpublic boolean roomConnect(IConnection connection, Object[] params) {\n\t\tString username = ((String) params[0]).toString();\n\t\tString role = ((String) params[1]).toString();\n\t\tString room = ((String)params[2]).toString();\n               \n\t\tString voiceBridge = ((String) params[3]).toString();\n\t\t\n\t\tboolean record = (Boolean)params[4];\n\t\t\n\t\tString externalUserID = ((String) params[5]).toString();\n\t\tString internalUserID = ((String) params[6]).toString();\n    \t\n\t\tBoolean locked = false;\n\t\tif (params.length >= 7 && ((Boolean) params[7])) {\n\t\t\tlocked = true;\n\t\t}\n    \t\n\t\tBoolean muted  = false;\n\t\tif (params.length >= 8 && ((Boolean) params[8])) {\n\t\t\tmuted = true;\n\t\t}\n    \t\n\t\tMap<String, Boolean> lsMap = null;\n\t\tif (params.length >= 9) {\n\t\t\ttry {\n\t\t\t\tlsMap = (Map<String, Boolean> ) params[9];\n\t\t\t} catch(Exception e){\n\t\t\t\tlsMap = new HashMap<String, Boolean>();\n\t\t\t}\n\t\t}\n    \t   \t    \t\n\t\tif (record == true) {\n\t\t\trecorderApplication.createRecordSession(room);\n\t\t}\n\t\t\t\n\t\tBigBlueButtonSession bbbSession = new BigBlueButtonSession(room, internalUserID,  username, role, \n    \t\t\tvoiceBridge, record, externalUserID, muted);\n\t\tconnection.setAttribute(Constants.SESSION, bbbSession);        \n\t\tconnection.setAttribute(\"INTERNAL_USER_ID\", internalUserID);\n        \n\t\tString debugInfo = \"internalUserID=\" + internalUserID + \",username=\" + username + \",role=\" +  role + \",\" + \n        \t\t\t\t\t\",voiceConf=\" + voiceBridge + \",room=\" + room + \",externalUserid=\" + externalUserID;\n\t\tlog.debug(\"User [{}] connected to room [{}]\", debugInfo, room); \n\n\t\tbbbGW.initLockSettings(room, locked, lsMap);\n\n\t    String meetingId = bbbSession.getRoom();\n\t    String userId = bbbSession.getInternalUserID();\n\t    String connType = getConnectionType(Red5.getConnectionLocal().getType());\n\t    String userFullname = bbbSession.getUsername();\n\t    String connId = Red5.getConnectionLocal().getSessionId();\n\t        \n\t\tString sessionId =  CONN + connId + \"-\" + userId;\n\t\tconnInvokerService.addConnection(sessionId, connection);\n\t\t\n\t\tlog.info(\"User connected: sessionId=[\" + sessionId + \"], encoding=[\" + connType +\n\t\t\t\t\"], meetingId= [\" + meetingId\n\t\t\t\t+ \"], userId=[\" + userId + \"] username=[\" + userFullname +\"]\");\n\n\n\t\tMap<String, Object> logData = new HashMap<String, Object>();\n\t\tlogData.put(\"meetingId\", meetingId);\n\t\tlogData.put(\"connType\", connType);\n\t\tlogData.put(\"connId\", connId);\n\t\tlogData.put(\"userId\", userId);\n\t\tlogData.put(\"sessionId\", sessionId);\n\t\tlogData.put(\"username\", userFullname);\n\t\tlogData.put(\"event\", \"user_joining_bbb_apps\");\n\t\tlogData.put(\"description\", \"User joining BBB Apps.\");\n\t\t\n\t\tGson gson = new Gson();\n        String logStr =  gson.toJson(logData);\n\t\t\n\t\tlog.info(\"User joining bbb-aaps: data={}\", logStr);\n\t\t\n\t\treturn super.roomConnect(connection, params);\n        \n\t}","commit_id":"5798f727c54acae6de100cbb3a436e1383df8a61","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void validateToken(String token) {\n\t\tBigBlueButtonSession bbbSession = (BigBlueButtonSession) Red5.getConnectionLocal().getAttribute(Constants.SESSION);\n\t\tassert bbbSession != null;\n\t\tString userId = bbbSession.getInternalUserID();\n\t\tString meetingId = Red5.getConnectionLocal().getScope().getName();\n\t\tbbbGW.validateAuthToken(meetingId, userId, token, meetingId + \"/\" + userId);\n\t}","id":24455,"modified_method":"public void validateToken(Map<String, String> msg) {\n//\t   String userId = (String) msg.get(\"userId\");\n\t   String token = (String) msg.get(\"authToken\");\n\t        \n\t\tBigBlueButtonSession bbbSession = (BigBlueButtonSession) Red5.getConnectionLocal().getAttribute(Constants.SESSION);\n\t\tassert bbbSession != null;\n\t\tString userId = bbbSession.getInternalUserID();\n\t\tString meetingId = Red5.getConnectionLocal().getScope().getName();\n        String connId = Red5.getConnectionLocal().getSessionId();    \n        String sessionId =  CONN + connId + \"-\" + userId;\n        \n        Map<String, Object> logData = new HashMap<String, Object>();\n        logData.put(\"meetingId\", meetingId);\n        logData.put(\"connId\", connId);\n        logData.put(\"sessionId\", sessionId);\n        logData.put(\"userId\", userId);\n        logData.put(\"token\", token);\n        logData.put(\"event\", \"user_validate_token_bbb_apps\");\n        logData.put(\"description\", \"User validate token BBB Apps.\");\n        \n        Gson gson = new Gson();\n        String logStr =  gson.toJson(logData);\n            \n        log.info(\"User validate token bbb-apps: data={}\", logStr);\n\t\tbbbGW.validateAuthToken(meetingId, userId, token, meetingId + \"/\" + userId, sessionId);\n\t}","commit_id":"5798f727c54acae6de100cbb3a436e1383df8a61","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\r\n\tpublic void handleMessage(String pattern, String channel, String message) {\r\n//\t\tSystem.out.println(\"Checking message: \" + pattern + \" \" + channel + \" \" + message);\r\n\t\tif (channel.equalsIgnoreCase(MessagingConstants.TO_MEETING_CHANNEL)) {\r\n//\t\t\tSystem.out.println(\"Meeting message: \" + channel + \" \" + message);\r\n\t\t\tIMessage msg = MessageFromJsonConverter.convert(message);\r\n\t\t\t\r\n\t\t\tif (msg != null) {\r\n\t\t\t\tif (msg instanceof EndMeetingMessage) {\r\n\t\t\t\t\tEndMeetingMessage emm = (EndMeetingMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received end meeting request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.endMeeting(emm.meetingId);\r\n\t\t\t\t} else if (msg instanceof CreateMeetingMessage) {\r\n\t\t\t\t\tCreateMeetingMessage emm = (CreateMeetingMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received create meeting request. Meeting id [{}]\", emm.id);\r\n\t\t\t\t\tbbbGW.createMeeting2(emm.id, emm.externalId, emm.name, emm.record, emm.voiceBridge, \r\n\t\t\t\t\t\t\t  emm.duration, emm.autoStartRecording, emm.allowStartStopRecording);\r\n\t\t\t\t} else if (msg instanceof RegisterUserMessage) {\r\n\t\t\t\t\tRegisterUserMessage emm = (RegisterUserMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received register user request. Meeting id [{}], userid=[{}], token=[{}]\", emm.meetingID, emm.internalUserId, emm.authToken);\r\n\t\t\t\t\tbbbGW.registerUser(emm.meetingID, emm.internalUserId, emm.fullname, emm.role, emm.externUserID, emm.authToken);\r\n\t\t\t\t} else if (msg instanceof DestroyMeetingMessage) {\r\n\t\t\t\t\tDestroyMeetingMessage emm = (DestroyMeetingMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received destroy meeting request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.destroyMeeting(emm.meetingId);\r\n\t\t\t\t} else if (msg instanceof ValidateAuthTokenMessage) {\r\n\t\t\t\t\tValidateAuthTokenMessage emm = (ValidateAuthTokenMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received ValidateAuthTokenMessage token request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.validateAuthToken(emm.meetingId, emm.userId, emm.token, emm.replyTo);\r\n\t\t\t\t} else if (msg instanceof UserConnectedToGlobalAudio) {\r\n\t\t\t\t\tUserConnectedToGlobalAudio emm = (UserConnectedToGlobalAudio) msg;\r\n\t\t\t\t\t\r\n\t\t\t\t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n\t\t\t\t\tlogData.put(\"voiceConf\", emm.voiceConf);\r\n\t\t\t\t\tlogData.put(\"userId\", emm.userid);\r\n\t\t\t\t\tlogData.put(\"username\", emm.name);\r\n\t\t\t\t\tlogData.put(\"event\", \"user_connected_to_global_audio\");\r\n\t\t\t\t\tlogData.put(\"description\", \"User connected to global audio.\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tGson gson = new Gson();\r\n\t\t\t\t\tString logStr =  gson.toJson(logData);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlog.info(\"User connected to global audio: data={}\", logStr);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbbbGW.userConnectedToGlobalAudio(emm.voiceConf, emm.userid, emm.name);\r\n\t\t\t\t} else if (msg instanceof UserDisconnectedFromGlobalAudio) {\r\n\t\t\t\t\tUserDisconnectedFromGlobalAudio emm = (UserDisconnectedFromGlobalAudio) msg;\r\n\t\t\t\t\t\r\n\t\t\t\t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n\t\t\t\t\tlogData.put(\"voiceConf\", emm.voiceConf);\r\n\t\t\t\t\tlogData.put(\"userId\", emm.userid);\r\n\t\t\t\t\tlogData.put(\"username\", emm.name);\r\n\t\t\t\t\tlogData.put(\"event\", \"user_disconnected_from_global_audio\");\r\n\t\t\t\t\tlogData.put(\"description\", \"User disconnected from global audio.\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tGson gson = new Gson();\r\n\t\t\t\t\tString logStr =  gson.toJson(logData);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlog.info(\"User disconnected from global audio: data={}\", logStr);\r\n\t\t\t\t\tbbbGW.userDisconnectedFromGlobalAudio(emm.voiceConf, emm.userid, emm.name);\r\n\t\t\t\t}\r\n\t\t\t\telse if (msg instanceof GetAllMeetingsRequest) {\r\n\t\t\t\t\tGetAllMeetingsRequest emm = (GetAllMeetingsRequest) msg;\r\n\t\t\t\t\tlog.info(\"Received GetAllMeetingsRequest\");\r\n\t\t\t\t\tbbbGW.getAllMeetings(\"no_need_of_a_meeting_id\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (channel.equalsIgnoreCase(MessagingConstants.TO_SYSTEM_CHANNEL)) {\r\n\t\t\tIMessage msg = MessageFromJsonConverter.convert(message);\r\n\t\t\t\r\n\t\t\tif (msg != null) {\r\n\t\t\t\tif (msg instanceof KeepAliveMessage) {\r\n\t\t\t\t\tKeepAliveMessage emm = (KeepAliveMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received KeepAliveMessage request. Meeting id [{}]\", emm.keepAliveId);\r\n\t\t\t\t\tbbbGW.isAliveAudit(emm.keepAliveId);\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":24456,"modified_method":"@Override\r\n\tpublic void handleMessage(String pattern, String channel, String message) {\r\n//\t\tSystem.out.println(\"Checking message: \" + pattern + \" \" + channel + \" \" + message);\r\n\t\tif (channel.equalsIgnoreCase(MessagingConstants.TO_MEETING_CHANNEL)) {\r\n//\t\t\tSystem.out.println(\"Meeting message: \" + channel + \" \" + message);\r\n\t\t\tIMessage msg = MessageFromJsonConverter.convert(message);\r\n\t\t\t\r\n\t\t\tif (msg != null) {\r\n\t\t\t\tif (msg instanceof EndMeetingMessage) {\r\n\t\t\t\t\tEndMeetingMessage emm = (EndMeetingMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received end meeting request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.endMeeting(emm.meetingId);\r\n\t\t\t\t} else if (msg instanceof CreateMeetingMessage) {\r\n\t\t\t\t\tCreateMeetingMessage emm = (CreateMeetingMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received create meeting request. Meeting id [{}]\", emm.id);\r\n\t\t\t\t\tbbbGW.createMeeting2(emm.id, emm.externalId, emm.name, emm.record, emm.voiceBridge, \r\n\t\t\t\t\t\t\t  emm.duration, emm.autoStartRecording, emm.allowStartStopRecording);\r\n\t\t\t\t} else if (msg instanceof RegisterUserMessage) {\r\n\t\t\t\t\tRegisterUserMessage emm = (RegisterUserMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received register user request. Meeting id [{}], userid=[{}], token=[{}]\", emm.meetingID, emm.internalUserId, emm.authToken);\r\n\t\t\t\t\tbbbGW.registerUser(emm.meetingID, emm.internalUserId, emm.fullname, emm.role, emm.externUserID, emm.authToken);\r\n\t\t\t\t} else if (msg instanceof DestroyMeetingMessage) {\r\n\t\t\t\t\tDestroyMeetingMessage emm = (DestroyMeetingMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received destroy meeting request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.destroyMeeting(emm.meetingId);\r\n\t\t\t\t} else if (msg instanceof ValidateAuthTokenMessage) {\r\n\t\t\t\t\tValidateAuthTokenMessage emm = (ValidateAuthTokenMessage) msg;\r\n\t\t\t\t\tlog.info(\"Received ValidateAuthTokenMessage token request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tlog.warn(\"TODO: Need to pass sessionId on ValidateAuthTokenMessage message.\");\r\n\t\t\t\t\tString sessionId = \"tobeimplemented\";\r\n\t\t\t\t\tbbbGW.validateAuthToken(emm.meetingId, emm.userId, emm.token, emm.replyTo, sessionId);\r\n\t\t\t\t} else if (msg instanceof UserConnectedToGlobalAudio) {\r\n\t\t\t\t\tUserConnectedToGlobalAudio emm = (UserConnectedToGlobalAudio) msg;\r\n\t\t\t\t\t\r\n\t\t\t\t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n\t\t\t\t\tlogData.put(\"voiceConf\", emm.voiceConf);\r\n\t\t\t\t\tlogData.put(\"userId\", emm.userid);\r\n\t\t\t\t\tlogData.put(\"username\", emm.name);\r\n\t\t\t\t\tlogData.put(\"event\", \"user_connected_to_global_audio\");\r\n\t\t\t\t\tlogData.put(\"description\", \"User connected to global audio.\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tGson gson = new Gson();\r\n\t\t\t\t\tString logStr =  gson.toJson(logData);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlog.info(\"User connected to global audio: data={}\", logStr);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbbbGW.userConnectedToGlobalAudio(emm.voiceConf, emm.userid, emm.name);\r\n\t\t\t\t} else if (msg instanceof UserDisconnectedFromGlobalAudio) {\r\n\t\t\t\t\tUserDisconnectedFromGlobalAudio emm = (UserDisconnectedFromGlobalAudio) msg;\r\n\t\t\t\t\t\r\n\t\t\t\t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n\t\t\t\t\tlogData.put(\"voiceConf\", emm.voiceConf);\r\n\t\t\t\t\tlogData.put(\"userId\", emm.userid);\r\n\t\t\t\t\tlogData.put(\"username\", emm.name);\r\n\t\t\t\t\tlogData.put(\"event\", \"user_disconnected_from_global_audio\");\r\n\t\t\t\t\tlogData.put(\"description\", \"User disconnected from global audio.\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tGson gson = new Gson();\r\n\t\t\t\t\tString logStr =  gson.toJson(logData);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlog.info(\"User disconnected from global audio: data={}\", logStr);\r\n\t\t\t\t\tbbbGW.userDisconnectedFromGlobalAudio(emm.voiceConf, emm.userid, emm.name);\r\n\t\t\t\t}\r\n\t\t\t\telse if (msg instanceof GetAllMeetingsRequest) {\r\n\t\t\t\t\tGetAllMeetingsRequest emm = (GetAllMeetingsRequest) msg;\r\n\t\t\t\t\tlog.info(\"Received GetAllMeetingsRequest\");\r\n\t\t\t\t\tbbbGW.getAllMeetings(\"no_need_of_a_meeting_id\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (channel.equalsIgnoreCase(MessagingConstants.TO_SYSTEM_CHANNEL)) {\r\n\t\t\tIMessage msg = MessageFromJsonConverter.convert(message);\r\n\t\t\t\r\n\t\t\tif (msg != null) {\r\n\t\t\t\tif (msg instanceof KeepAliveMessage) {\r\n\t\t\t\t\tKeepAliveMessage emm = (KeepAliveMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received KeepAliveMessage request. Meeting id [{}]\", emm.keepAliveId);\r\n\t\t\t\t\tbbbGW.isAliveAudit(emm.keepAliveId);\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"5798f727c54acae6de100cbb3a436e1383df8a61","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private static IMessage processValidateAuthTokenMessage(JsonObject header, JsonObject payload) {\r\n\t\tString id = payload.get(Constants.MEETING_ID).getAsString();\r\n\t\tString userid = payload.get(Constants.USER_ID).getAsString();\r\n\t\tString authToken = payload.get(Constants.AUTH_TOKEN).getAsString();\r\n\t\tString replyTo = header.get(Constants.REPLY_TO).getAsString();\r\n\t\t\r\n\t\treturn new ValidateAuthTokenMessage(id, userid, authToken, replyTo);\r\n\t}","id":24457,"modified_method":"private static IMessage processValidateAuthTokenMessage(JsonObject header, JsonObject payload) {\r\n\t\tString id = payload.get(Constants.MEETING_ID).getAsString();\r\n\t\tString userid = payload.get(Constants.USER_ID).getAsString();\r\n\t\tString authToken = payload.get(Constants.AUTH_TOKEN).getAsString();\r\n\t\tString replyTo = header.get(Constants.REPLY_TO).getAsString();\r\n\t\tString sessionId = \"tobeimplemented\";\r\n\t\treturn new ValidateAuthTokenMessage(id, userid, authToken, replyTo,\r\n\t\t    sessionId);\r\n\t}","commit_id":"5798f727c54acae6de100cbb3a436e1383df8a61","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"@Override\n\tpublic void handleMessage(String pattern, String channel, String message) {\n\t\tif (channel.equalsIgnoreCase(MessagingConstants.TO_USERS_CHANNEL)) {\n\n\t\t\tJsonParser parser = new JsonParser();\n\t\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\t\t\tJsonObject headerObject = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payloadObject = (JsonObject) obj.get(\"payload\");\n\n\t\t\tString eventName =  headerObject.get(\"name\").toString().replace(\"\\\"\", \"\");\n\n\t\t\tif(eventName.equalsIgnoreCase(\"user_leaving_request\") ||\n\t\t\t\teventName.equalsIgnoreCase(\"user_raised_hand_message\") ||\n\t\t\t\teventName.equalsIgnoreCase(\"user_lowered_hand_message\")){\n\n\t\t\t\tString roomName = payloadObject.get(\"meeting_id\").toString().replace(\"\\\"\", \"\");\n\t\t\t\tString userID = payloadObject.get(\"userid\").toString().replace(\"\\\"\", \"\");\n\n\t\t\t\tif(eventName.equalsIgnoreCase(\"user_leaving_request\")){\n\t\t\t\t\tbbbInGW.userLeft(roomName, userID);\n\t\t\t\t}\n\t\t\t\telse if(eventName.equalsIgnoreCase(\"user_raised_hand_message\")){\n\t\t\t\t\tbbbInGW.userRaiseHand(roomName, userID);\n\t\t\t\t}\n\t\t\t\telse if(eventName.equalsIgnoreCase(\"user_lowered_hand_message\")){\n\t\t\t\t\tString requesterID = payloadObject.get(\"lowered_by\").toString().replace(\"\\\"\", \"\");\n\t\t\t\t\tbbbInGW.lowerHand(roomName, userID, requesterID);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":24458,"modified_method":"@Override\n\tpublic void handleMessage(String pattern, String channel, String message) {\n\t\tif (channel.equalsIgnoreCase(MessagingConstants.TO_USERS_CHANNEL)) {\n\n\t\t\tJsonParser parser = new JsonParser();\n\t\t\tJsonObject obj = (JsonObject) parser.parse(message);\n\t\t\tJsonObject headerObject = (JsonObject) obj.get(\"header\");\n\t\t\tJsonObject payloadObject = (JsonObject) obj.get(\"payload\");\n\n\t\t\tString eventName =  headerObject.get(\"name\").toString().replace(\"\\\"\", \"\");\n\n\t\t\tif(eventName.equalsIgnoreCase(\"user_leaving_request\") ||\n\t\t\t\teventName.equalsIgnoreCase(\"user_raised_hand_message\") ||\n\t\t\t\teventName.equalsIgnoreCase(\"user_lowered_hand_message\")){\n\n\t\t\t\tString roomName = payloadObject.get(\"meeting_id\").toString().replace(\"\\\"\", \"\");\n\t\t\t\tString userID = payloadObject.get(\"userid\").toString().replace(\"\\\"\", \"\");\n\n\t\t\t\tif(eventName.equalsIgnoreCase(\"user_leaving_request\")){\n\t\t\t\t  /**\n\t\t\t\t   * TODO: HTML5 client need to pass this parameter. (ralam jan 22, 2015)\n\t\t\t\t   */\n\t\t\t\t  log.warn(\"TODO: Need to pass sessionId on user_leaving_request message.\");\n\t\t\t\t  String sessionId = \"tobeimplemented\";\n\t\t\t\t  bbbInGW.userLeft(roomName, userID, sessionId);\n\t\t\t\t}\n\t\t\t\telse if(eventName.equalsIgnoreCase(\"user_raised_hand_message\")){\n\t\t\t\t\tbbbInGW.userRaiseHand(roomName, userID);\n\t\t\t\t}\n\t\t\t\telse if(eventName.equalsIgnoreCase(\"user_lowered_hand_message\")){\n\t\t\t\t\tString requesterID = payloadObject.get(\"lowered_by\").toString().replace(\"\\\"\", \"\");\n\t\t\t\t\tbbbInGW.lowerHand(roomName, userID, requesterID);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"5798f727c54acae6de100cbb3a436e1383df8a61","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public ValidateAuthTokenMessage(String meetingId, String userId, String token, String replyTo) {\r\n\t\tthis.meetingId = meetingId;\r\n\t\tthis.userId = userId;\r\n\t\tthis.token = token;\r\n\t\tthis.replyTo = replyTo;\t\r\n\t}","id":24459,"modified_method":"public ValidateAuthTokenMessage(String meetingId, String userId, String token, String replyTo, String sessionId) {\r\n\t\tthis.meetingId = meetingId;\r\n\t\tthis.userId = userId;\r\n\t\tthis.token = token;\r\n\t\tthis.replyTo = replyTo;\r\n\t\tthis.sessionId = sessionId;\r\n\t}","commit_id":"5798f727c54acae6de100cbb3a436e1383df8a61","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"private JCExpression transformNamedInvocation(InvocationExpression ce) {\n        final ListBuffer<JCExpression> callArgs = new ListBuffer<JCExpression>();\n        final ListBuffer<JCExpression> passArgs = new ListBuffer<JCExpression>();\n        final String methodName;\n        final java.util.List<ParameterList> parameterLists;\n        final Primary primary = ce.getPrimary();\n        final Declaration primaryDecl = primary.getDeclaration();\n        if (primaryDecl instanceof Method) {\n            Method methodDecl = (Method)primaryDecl;\n            methodName = methodDecl.getName();\n            parameterLists = methodDecl.getParameterLists();\n        } else if (primaryDecl instanceof com.redhat.ceylon.compiler.typechecker.model.Class) {\n            com.redhat.ceylon.compiler.typechecker.model.Class methodDecl = (com.redhat.ceylon.compiler.typechecker.model.Class)primaryDecl;\n            methodName = methodDecl.getName();\n            parameterLists = methodDecl.getParameterLists();\n        } else {\n            throw new RuntimeException(\"Illegal State: \" + (primaryDecl != null ? primaryDecl.getClass() : \"null\"));\n        }\n        java.util.List<NamedArgument> namedArguments = ce.getNamedArgumentList().getNamedArguments();\n        java.util.List<Parameter> declaredParams = parameterLists.get(0).getParameters();\n        for (Parameter declaredParam : declaredParams) {\n            boolean found = false;\n            int index = 0;\n            for (NamedArgument namedArg : namedArguments) {\n                at(namedArg);\n                if (declaredParam.getName().equals(namedArg.getIdentifier().getText())) {\n                    JCExpression argExpr = make().Indexed(makeSelect(\"this\", \"args\"), makeInteger(index));\n                    argExpr = make().TypeCast(makeJavaType(namedArgType(namedArg), this.TYPE_PARAM), argExpr);\n                    callArgs.append(unboxType(argExpr, declaredParam.getType()));\n                    found = true;\n                    break;\n                }\n                index += 1;\n            }\n            if (!found) {\n                throw new RuntimeException(\"No value specified for argument '\" + declaredParam.getName()+ \"' and default values not implemented yet\");\n            }\n        }\n        for (NamedArgument namedArg : namedArguments) {\n            at(namedArg);\n            passArgs.append(transformArg(namedArg));\n        }\n        at(ce);\n\n        List<JCExpression> typeArgs = transformTypeArguments(ce);\n        \n        JCExpression receiverType;\n        final boolean generateNew;\n        final boolean haveInstance;\n        if (primary instanceof BaseMemberOrTypeExpression) {\n            passArgs.prepend(make().Literal(TypeTags.BOT, null));\n            receiverType = makeIdent(\"java.lang.Void\");\n            generateNew = primary instanceof BaseTypeExpression;\n            haveInstance = false;\n        } else if (primary instanceof QualifiedMemberOrTypeExpression) {\n            QualifiedMemberOrTypeExpression memberExpr = (QualifiedMemberOrTypeExpression)primary;\n            CeylonVisitor visitor = new CeylonVisitor(gen(), typeArgs, callArgs);\n            memberExpr.getPrimary().visit(visitor);\n            passArgs.prepend((JCExpression)visitor.getSingleResult());\n            receiverType = makeJavaType(memberExpr.getPrimary().getTypeModel(), this.TYPE_PARAM);\n            generateNew = primary instanceof QualifiedTypeExpression;\n            haveInstance = true;\n        } else {\n            throw new RuntimeException(\"Not Implemented: Named argument calls only implemented on member and type expressions\");\n        }\n\n        // Construct the call$() method\n        boolean isVoid = ce.getTypeModel().isExactly(typeFact().getVoidDeclaration().getType());\n        JCExpression resultType = makeJavaType(ce.getTypeModel(), (isTypeParameter(determineExpressionType(ce))) ? this.TYPE_PARAM: 0);\n        final String callMethodName = \"call$\";\n        MethodDefinitionBuilder callMethod = MethodDefinitionBuilder.method(gen(), callMethodName);\n        callMethod.modifiers(Flags.PUBLIC);\n        callMethod.resultType(resultType);\n        if (generateNew) {\n            callMethod.body(make().Return(make().NewClass(null, null, resultType, callArgs.toList(), null)));\n        } else {\n            JCExpression expr;\n            if (haveInstance) {\n                expr = make().Apply(null, makeSelect(\"this\", \"instance\", methodName), callArgs.toList());\n            } else {\n                expr = make().Apply(null, makeIdent(methodName), callArgs.toList());\n            }\n            if (isVoid) {\n                callMethod.body(List.<JCStatement>of(\n                        make().Exec(expr),\n                        make().Return(make().Literal(TypeTags.BOT, null))));\n            } else {\n                callMethod.body(make().Return(expr));\n            }\n        }\n\n        // Construct the class\n        JCExpression namedArgsClass = make().TypeApply(makeIdent(syms().ceylonNamedArgumentCall),\n                List.<JCExpression>of(receiverType));\n\n        JCClassDecl classDecl = make().ClassDef(make().Modifiers(0),\n                names().empty,\n                List.<JCTypeParameter>nil(),\n                namedArgsClass,\n                List.<JCExpression>nil(),\n                List.<JCTree>of(callMethod.build()));\n\n        // Create an instance of the class\n        JCNewClass newClass = make().NewClass(null,\n                null,\n                namedArgsClass,\n                passArgs.toList(),\n                classDecl);\n\n        // Call the call$() method\n        return make().Apply(null,\n                makeSelect(newClass, callMethodName), List.<JCExpression>nil());\n    }","id":24460,"modified_method":"private JCExpression transformNamedInvocation(InvocationExpression ce) {\n        final ListBuffer<JCExpression> callArgs = new ListBuffer<JCExpression>();\n        final ListBuffer<JCExpression> passArgs = new ListBuffer<JCExpression>();\n        final String methodName;\n        final java.util.List<ParameterList> parameterLists;\n        final Primary primary = ce.getPrimary();\n        final Declaration primaryDecl = primary.getDeclaration();\n        if (primaryDecl instanceof Method) {\n            Method methodDecl = (Method)primaryDecl;\n            methodName = methodDecl.getName();\n            parameterLists = methodDecl.getParameterLists();\n        } else if (primaryDecl instanceof com.redhat.ceylon.compiler.typechecker.model.Class) {\n            com.redhat.ceylon.compiler.typechecker.model.Class methodDecl = (com.redhat.ceylon.compiler.typechecker.model.Class)primaryDecl;\n            methodName = methodDecl.getName();\n            parameterLists = methodDecl.getParameterLists();\n        } else {\n            throw new RuntimeException(\"Illegal State: \" + (primaryDecl != null ? primaryDecl.getClass() : \"null\"));\n        }\n        java.util.List<NamedArgument> namedArguments = ce.getNamedArgumentList().getNamedArguments();\n        java.util.List<Parameter> declaredParams = parameterLists.get(0).getParameters();\n        for (Parameter declaredParam : declaredParams) {\n            boolean found = false;\n            int index = 0;\n            for (NamedArgument namedArg : namedArguments) {\n                at(namedArg);\n                if (declaredParam.getName().equals(namedArg.getIdentifier().getText())) {\n                    JCExpression argExpr = make().Indexed(makeSelect(\"this\", \"args\"), makeInteger(index));\n                    argExpr = make().TypeCast(makeJavaType(namedArgType(namedArg), this.TYPE_PARAM), argExpr);\n                    callArgs.append(unboxType(argExpr, declaredParam.getType()));\n                    found = true;\n                    break;\n                }\n                index += 1;\n            }\n            if (!found) {\n                throw new RuntimeException(\"No value specified for argument '\" + declaredParam.getName()+ \"' and default values not implemented yet\");\n            }\n        }\n        for (NamedArgument namedArg : namedArguments) {\n            at(namedArg);\n            passArgs.append(transformArg(namedArg));\n        }\n        at(ce);\n\n        List<JCExpression> typeArgs = transformTypeArguments(ce);\n        \n        JCExpression receiverType;\n        final JCExpression receiver;\n        final boolean generateNew;\n        if (primary instanceof BaseMemberOrTypeExpression) {\n            BaseMemberOrTypeExpression memberExpr = (BaseMemberOrTypeExpression)primary;\n            generateNew = primary instanceof BaseTypeExpression;\n            if (memberExpr.getDeclaration().isToplevel()) {\n                passArgs.prepend(make().Literal(TypeTags.BOT, null));\n                receiverType = makeIdent(\"java.lang.Void\");\n                receiver = makeSelect(memberExpr.getDeclaration().getName(), methodName);// TODO encapsulate this\n            } else if (!memberExpr.getDeclaration().isClassMember()) {// local\n                passArgs.prepend(makeIdent(memberExpr.getDeclaration().getName())); // TODO Check it's as simple as this, and encapsulat\n                receiverType = makeIdent(memberExpr.getDeclaration().getName());// TODO: get the generated name somehow\n                receiver = makeSelect(\"this\", \"instance\", methodName);\n            } else {\n                passArgs.prepend(make().Literal(TypeTags.BOT, null));\n                receiverType = makeIdent(\"java.lang.Void\");\n                receiver = makeIdent(methodName);\n            }\n        } else if (primary instanceof QualifiedMemberOrTypeExpression) {\n            QualifiedMemberOrTypeExpression memberExpr = (QualifiedMemberOrTypeExpression)primary;\n            CeylonVisitor visitor = new CeylonVisitor(gen(), typeArgs, callArgs);\n            memberExpr.getPrimary().visit(visitor);\n            passArgs.prepend((JCExpression)visitor.getSingleResult());\n            receiverType = makeJavaType(memberExpr.getPrimary().getTypeModel(), this.TYPE_PARAM);\n            receiver = makeSelect(\"this\", \"instance\", methodName);\n            generateNew = primary instanceof QualifiedTypeExpression;\n            \n        } else {\n            throw new RuntimeException(\"Not Implemented: Named argument calls only implemented on member and type expressions\");\n        }\n\n        // Construct the call$() method\n        boolean isVoid = ce.getTypeModel().isExactly(typeFact().getVoidDeclaration().getType());\n        JCExpression resultType = makeJavaType(ce.getTypeModel(), (isTypeParameter(determineExpressionType(ce))) ? this.TYPE_PARAM: 0);\n        final String callMethodName = \"call$\";\n        MethodDefinitionBuilder callMethod = MethodDefinitionBuilder.method(gen(), callMethodName);\n        callMethod.modifiers(Flags.PUBLIC);\n        callMethod.resultType(resultType);\n        if (generateNew) {\n            callMethod.body(make().Return(make().NewClass(null, null, resultType, callArgs.toList(), null)));\n        } else {\n            JCExpression expr = make().Apply(null, receiver, callArgs.toList());;\n            \n            if (isVoid) {\n                callMethod.body(List.<JCStatement>of(\n                        make().Exec(expr),\n                        make().Return(make().Literal(TypeTags.BOT, null))));\n            } else {\n                callMethod.body(make().Return(expr));\n            }\n        }\n\n        // Construct the class\n        JCExpression namedArgsClass = make().TypeApply(makeIdent(syms().ceylonNamedArgumentCall),\n                List.<JCExpression>of(receiverType));\n\n        JCClassDecl classDecl = make().ClassDef(make().Modifiers(0),\n                names().empty,\n                List.<JCTypeParameter>nil(),\n                namedArgsClass,\n                List.<JCExpression>nil(),\n                List.<JCTree>of(callMethod.build()));\n\n        // Create an instance of the class\n        JCNewClass newClass = make().NewClass(null,\n                null,\n                namedArgsClass,\n                passArgs.toList(),\n                classDecl);\n\n        // Call the call$() method\n        return make().Apply(null,\n                makeSelect(newClass, callMethodName), List.<JCExpression>nil());\n    }","commit_id":"6e4f8c4b3fd0bb3683786889f7c735d289ad3bc5","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/** Creates an anonymous class that extends Iterable and implements the specified comprehension.\n     */\n    public JCExpression transformComprehension(Comprehension comp) {\n        at(comp);\n        Tree.ComprehensionClause clause = comp.getForComprehensionClause();\n        ProducedType targetIterType = typeFact().getIterableType(clause.getTypeModel());\n        int idx = 0;\n        ExpressionComprehensionClause excc = null;\n        String prevItemVar = null;\n        //Iterator fields\n        ListBuffer<JCTree> fields = new ListBuffer<JCTree>();\n        while (clause != null) {\n            final String iterVar = \"iter$\"+idx;\n            String itemVar = null;\n            //spread 1162\n            if (clause instanceof ForComprehensionClause) {\n\n                ForComprehensionClause fcl = (ForComprehensionClause)clause;\n                SpecifierExpression specexpr = fcl.getForIterator().getSpecifierExpression();\n                ProducedType iterType = specexpr.getExpression().getTypeModel();\n                JCExpression iterTypeExpr = makeJavaType(typeFact().getIteratorType(\n                        typeFact().getIteratedType(iterType)), CLASS_NEW|EXTENDS);\n                if (clause == comp.getForComprehensionClause()) {\n                    //The first iterator can be initialized as a field\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(iterVar), iterTypeExpr,\n                        make().Apply(null, make().Select(transformExpression(specexpr.getExpression()),\n                            names().fromString(\"getIterator\")), List.<JCExpression>nil())));\n                } else {\n                    //The subsequent iterators need to be inside a method,\n                    //in case they depend on the current element of the previous iterator\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(iterVar), iterTypeExpr, null));\n                    JCBlock body = make().Block(0l, List.<JCStatement>of(\n                            make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(iterVar), makeNull()),\n                                    make().Exec(make().Apply(null, makeSelect(\"this\", prevItemVar), List.<JCExpression>nil())),\n                                    null),\n                            make().Exec(make().Assign(makeUnquotedIdent(iterVar), make().Apply(null,\n                                    make().Select(transformExpression(specexpr.getExpression()),\n                                    names().fromString(\"getIterator\")), List.<JCExpression>nil()))),\n                            make().Return(makeUnquotedIdent(iterVar))\n                    ));\n                    fields.add(make().MethodDef(make().Modifiers(2),\n                            names().fromString(iterVar), iterTypeExpr, List.<JCTree.JCTypeParameter>nil(),\n                            List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(), body, null));\n                }\n                //Add the item var\n                if (fcl.getForIterator() instanceof ValueIterator) {\n                    Value item = ((ValueIterator)fcl.getForIterator()).getVariable().getDeclarationModel();\n                    itemVar = item.getName();\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(itemVar), makeJavaType(item.getType(),NO_PRIMITIVES), null));\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(itemVar+\"$exhausted\"),\n                        makeJavaType(typeFact().getBooleanDeclaration().getType()), null));\n                } else if (fcl.getForIterator() instanceof KeyValueIterator) {\n                    KeyValueIterator kviter = (KeyValueIterator)fcl.getForIterator();\n                    itemVar = null;//compname+\"$item$\"+idx;\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(kviter.getKeyVariable().getDeclarationModel().getName()),\n                            makeJavaType(kviter.getKeyVariable().getDeclarationModel().getType()), null));\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(kviter.getValueVariable().getDeclarationModel().getName()),\n                            makeJavaType(kviter.getValueVariable().getDeclarationModel().getType()), null));\n                } else {\n                    return makeErroneous(fcl, \"No support yet for iterators of type \" + fcl.getForIterator().getClass().getName());\n                }\n\n                //Now the context for this iterator\n                ListBuffer<JCStatement> contextBody = new ListBuffer<JCStatement>();\n                if (idx>0) {\n                    contextBody.add(make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(iterVar), makeNull()),\n                            make().Exec(make().Apply(null, makeSelect(\"this\", iterVar), List.<JCExpression>nil())), null));\n                }\n\n                //First we assign the next item to an Object variable\n                String tmpItem = tempName(\"item\");\n                contextBody.add(make().VarDef(make().Modifiers(0), names().fromString(tmpItem),\n                        makeJavaType(typeFact().getObjectDeclaration().getType()),\n                        make().Apply(null, make().Select(makeUnquotedIdent(iterVar), names().fromString(\"next\")), List.<JCExpression>nil())));\n                //Then we check if it's exhausted\n                contextBody.add(make().Exec(make().Assign(makeUnquotedIdent(itemVar+\"$exhausted\"),\n                        make().Binary(JCTree.EQ, makeUnquotedIdent(tmpItem), makeFinished()))));\n                //Variables get assigned in the else block\n                ListBuffer<JCStatement> elseBody = new ListBuffer<JCStatement>();\n                if (fcl.getForIterator() instanceof ValueIterator) {\n                    ProducedType itemType = ((ValueIterator)fcl.getForIterator()).getVariable().getDeclarationModel().getType();\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(itemVar),\n                            make().TypeCast(makeJavaType(itemType,NO_PRIMITIVES), makeUnquotedIdent(tmpItem)))));\n                } else {\n                    KeyValueIterator kviter = (KeyValueIterator)fcl.getForIterator();\n                    Value key = kviter.getKeyVariable().getDeclarationModel();\n                    Value item = kviter.getValueVariable().getDeclarationModel();\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(key.getName()),\n                            make().TypeCast(makeJavaType(key.getType()), make().TypeCast(\n                                    makeJavaType(typeFact().getEntryType(key.getType(), item.getType())),\n                                    make().Apply(null, make().Select(makeUnquotedIdent(tmpItem),\n                                            names().fromString(\"getKey\")), List.<JCExpression>nil()))))));\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(item.getName()),\n                            make().TypeCast(makeJavaType(item.getType()), make().TypeCast(\n                                    makeJavaType(typeFact().getEntryType(key.getType(), item.getType())),\n                                    make().Apply(null, make().Select(makeUnquotedIdent(tmpItem),\n                                            names().fromString(\"getItem\")), List.<JCExpression>nil()))))));\n                }\n                ListBuffer<JCStatement> innerBody = new ListBuffer<JCStatement>();\n                if (idx>0) {\n                    innerBody.add(make().If(make().Binary(JCTree.EQ,\n                            make().Apply(null, makeSelect(\"this\", prevItemVar), List.<JCExpression>nil()), makeBoolean(true)),\n                            make().Block(0, List.<JCStatement>of(\n                                make().Exec(make().Assign(makeUnquotedIdent(iterVar),\n                                        make().Apply(null, makeSelect(\"this\", iterVar), List.<JCExpression>nil()))),\n                                make().Return(make().Apply(null,\n                                        make().Select(makeUnquotedIdent(\"this\"),\n                                        names().fromString(itemVar)), List.<JCExpression>nil()))\n                    )), null));\n                }\n                innerBody.add(make().Return(makeBoolean(false)));\n                contextBody.add(make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(itemVar+\"$exhausted\"), makeBoolean(true)),\n                    make().Block(0, innerBody.toList()),\n                    make().Block(0, elseBody.toList())));\n                contextBody.add(make().Return(makeBoolean(true)));\n                fields.add(make().MethodDef(make().Modifiers(2), names().fromString(itemVar),\n                    makeJavaType(typeFact().getBooleanDeclaration().getType()),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(),\n                    make().Block(0, contextBody.toList()), null));\n                clause = fcl.getComprehensionClause();\n\n            } else if (clause instanceof IfComprehensionClause) {\n\n                Condition cond = ((IfComprehensionClause)clause).getCondition();\n                //The context of an if is an iteration through the parent, checking each element against the condition\n                Variable var = null;\n                if (cond instanceof IsCondition || cond instanceof ExistsOrNonemptyCondition) {\n                    var = cond instanceof IsCondition ? ((IsCondition)cond).getVariable()\n                            : ((ExistsOrNonemptyCondition)cond).getVariable();\n                    //Initialize the condition's attribute to finished so that this is returned\n                    //in case the condition is not met and the iterator is exhausted\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(var.getDeclarationModel().getName()),\n                            makeJavaType(typeFact().getObjectDeclaration().getType()), makeFinished()));\n                }\n                JCExpression condExpr = make().Binary(JCTree.EQ, make().Apply(null,\n                    make().Select(makeUnquotedIdent(\"this\"), names().fromString(prevItemVar)), List.<JCExpression>nil()),\n                    makeBoolean(true));\n                if (cond instanceof IsCondition || cond instanceof ExistsOrNonemptyCondition) {\n                    //TODO AND condExpr with negated transformed cond\n                } else {\n                    //TODO AND condExpr with negated transformed cond\n                }\n                itemVar = \"next\" + idx;\n                fields.add(make().MethodDef(make().Modifiers(2), names().fromString(itemVar),\n                    makeJavaType(typeFact().getBooleanDeclaration().getType()),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(),\n                    List.<JCExpression>nil(), make().Block(0, List.<JCStatement>of(\n                        make().WhileLoop(condExpr, make().Block(0, List.<JCStatement>nil())),\n                        make().Return(make().Unary(JCTree.NOT, makeUnquotedIdent(prevItemVar+\"$exhausted\")))\n                )), null));\n                clause = ((IfComprehensionClause)clause).getComprehensionClause();\n\n            } else if (clause instanceof ExpressionComprehensionClause) {\n\n                //Just keep a reference to the expression\n                excc = (ExpressionComprehensionClause)clause;\n                at(excc);\n                clause = null;\n\n            } else {\n                return makeErroneous(clause, \"No support for comprehension clause of type \" + clause.getClass().getName());\n            }\n            idx++;\n            if (itemVar != null) prevItemVar = itemVar;\n        }\n\n        //Define the next() method for the Iterator\n        fields.add(make().MethodDef(make().Modifiers(1), names().fromString(\"next\"),\n            makeJavaType(typeFact().getObjectDeclaration().getType()), List.<JCTree.JCTypeParameter>nil(),\n            List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(), make().Block(0, List.<JCStatement>of(\n                make().Return(\n                    make().Conditional(\n                        make().Binary(JCTree.EQ, make().Apply(null, make().Select(makeUnquotedIdent(\"this\"),\n                            names().fromString(prevItemVar)), List.<JCExpression>nil()), makeBoolean(true)),\n                        transformExpression(excc.getExpression(), BoxingStrategy.BOXED, typeFact().getIteratedType(targetIterType)),\n                        makeFinished()))\n        )), null));\n        ProducedType iteratorType = typeFact().getIteratorType(typeFact().getIteratedType(targetIterType));\n        JCExpression iterator = make().NewClass(null, null,makeJavaType(iteratorType, CLASS_NEW|EXTENDS),\n                List.<JCExpression>nil(), make().AnonymousClassDef(make().Modifiers(0), fields.toList()));\n        JCExpression iterable = make().NewClass(null, null,\n                make().TypeApply(makeIdent(syms().ceylonAbstractIterableType),\n                    List.<JCExpression>of(makeJavaType(typeFact().getIteratedType(targetIterType), NO_PRIMITIVES))),\n                List.<JCExpression>nil(), make().AnonymousClassDef(make().Modifiers(0), List.<JCTree>of(\n                    make().MethodDef(make().Modifiers(1), names().fromString(\"getIterator\"),\n                        makeJavaType(iteratorType, CLASS_NEW|EXTENDS),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(),\n                    make().Block(0, List.<JCStatement>of(make().Return(iterator))), null)\n        )));\n        return iterable;\n    }","id":24461,"modified_method":"/** Creates an anonymous class that extends Iterable and implements the specified comprehension.\n     */\n    public JCExpression transformComprehension(Comprehension comp) {\n        at(comp);\n        Tree.ComprehensionClause clause = comp.getForComprehensionClause();\n        ProducedType targetIterType = typeFact().getIterableType(clause.getTypeModel());\n        int idx = 0;\n        ExpressionComprehensionClause excc = null;\n        String prevItemVar = null;\n        String ctxtName = null;\n        //Iterator fields\n        ListBuffer<JCTree> fields = new ListBuffer<JCTree>();\n        while (clause != null) {\n            final String iterVar = \"iter$\"+idx;\n            String itemVar = null;\n            //spread 1162\n            if (clause instanceof ForComprehensionClause) {\n\n                ForComprehensionClause fcl = (ForComprehensionClause)clause;\n                SpecifierExpression specexpr = fcl.getForIterator().getSpecifierExpression();\n                ProducedType iterType = specexpr.getExpression().getTypeModel();\n                JCExpression iterTypeExpr = makeJavaType(typeFact().getIteratorType(\n                        typeFact().getIteratedType(iterType)), CLASS_NEW|EXTENDS);\n                if (clause == comp.getForComprehensionClause()) {\n                    //The first iterator can be initialized as a field\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(iterVar), iterTypeExpr,\n                        make().Apply(null, make().Select(transformExpression(specexpr.getExpression()),\n                            names().fromString(\"getIterator\")), List.<JCExpression>nil())));\n                } else {\n                    //The subsequent iterators need to be inside a method,\n                    //in case they depend on the current element of the previous iterator\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(iterVar), iterTypeExpr, null));\n                    JCBlock body = make().Block(0l, List.<JCStatement>of(\n                            make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(iterVar), makeNull()),\n                                    make().Exec(make().Apply(null, makeSelect(\"this\", ctxtName), List.<JCExpression>nil())),\n                                    null),\n                            make().Exec(make().Assign(makeUnquotedIdent(iterVar), make().Apply(null,\n                                    make().Select(transformExpression(specexpr.getExpression()),\n                                    names().fromString(\"getIterator\")), List.<JCExpression>nil()))),\n                            make().Return(makeUnquotedIdent(iterVar))\n                    ));\n                    fields.add(make().MethodDef(make().Modifiers(2),\n                            names().fromString(iterVar), iterTypeExpr, List.<JCTree.JCTypeParameter>nil(),\n                            List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(), body, null));\n                }\n                //Add the item var\n                if (fcl.getForIterator() instanceof ValueIterator) {\n                    Value item = ((ValueIterator)fcl.getForIterator()).getVariable().getDeclarationModel();\n                    itemVar = item.getName();\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(itemVar), makeJavaType(item.getType(),NO_PRIMITIVES), null));\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(itemVar+\"$exhausted\"),\n                        makeJavaType(typeFact().getBooleanDeclaration().getType()), null));\n                } else if (fcl.getForIterator() instanceof KeyValueIterator) {\n                    KeyValueIterator kviter = (KeyValueIterator)fcl.getForIterator();\n                    itemVar = null;//compname+\"$item$\"+idx;\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(kviter.getKeyVariable().getDeclarationModel().getName()),\n                            makeJavaType(kviter.getKeyVariable().getDeclarationModel().getType()), null));\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(kviter.getValueVariable().getDeclarationModel().getName()),\n                            makeJavaType(kviter.getValueVariable().getDeclarationModel().getType()), null));\n                } else {\n                    return makeErroneous(fcl, \"No support yet for iterators of type \" + fcl.getForIterator().getClass().getName());\n                }\n\n                //Now the context for this iterator\n                ListBuffer<JCStatement> contextBody = new ListBuffer<JCStatement>();\n                if (idx>0) {\n                    contextBody.add(make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(iterVar), makeNull()),\n                            make().Exec(make().Apply(null, makeSelect(\"this\", iterVar), List.<JCExpression>nil())), null));\n                }\n\n                //First we assign the next item to an Object variable\n                String tmpItem = tempName(\"item\");\n                contextBody.add(make().VarDef(make().Modifiers(0), names().fromString(tmpItem),\n                        makeJavaType(typeFact().getObjectDeclaration().getType()),\n                        make().Apply(null, make().Select(makeUnquotedIdent(iterVar), names().fromString(\"next\")), List.<JCExpression>nil())));\n                //Then we check if it's exhausted\n                contextBody.add(make().Exec(make().Assign(makeUnquotedIdent(itemVar+\"$exhausted\"),\n                        make().Binary(JCTree.EQ, makeUnquotedIdent(tmpItem), makeFinished()))));\n                //Variables get assigned in the else block\n                ListBuffer<JCStatement> elseBody = new ListBuffer<JCStatement>();\n                if (fcl.getForIterator() instanceof ValueIterator) {\n                    ProducedType itemType = ((ValueIterator)fcl.getForIterator()).getVariable().getDeclarationModel().getType();\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(itemVar),\n                            make().TypeCast(makeJavaType(itemType,NO_PRIMITIVES), makeUnquotedIdent(tmpItem)))));\n                } else {\n                    KeyValueIterator kviter = (KeyValueIterator)fcl.getForIterator();\n                    Value key = kviter.getKeyVariable().getDeclarationModel();\n                    Value item = kviter.getValueVariable().getDeclarationModel();\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(key.getName()),\n                            make().TypeCast(makeJavaType(key.getType()), make().TypeCast(\n                                    makeJavaType(typeFact().getEntryType(key.getType(), item.getType())),\n                                    make().Apply(null, make().Select(makeUnquotedIdent(tmpItem),\n                                            names().fromString(\"getKey\")), List.<JCExpression>nil()))))));\n                    elseBody.add(make().Exec(make().Assign(makeUnquotedIdent(item.getName()),\n                            make().TypeCast(makeJavaType(item.getType()), make().TypeCast(\n                                    makeJavaType(typeFact().getEntryType(key.getType(), item.getType())),\n                                    make().Apply(null, make().Select(makeUnquotedIdent(tmpItem),\n                                            names().fromString(\"getItem\")), List.<JCExpression>nil()))))));\n                }\n                ListBuffer<JCStatement> innerBody = new ListBuffer<JCStatement>();\n                if (idx>0) {\n                    innerBody.add(make().If(make().Binary(JCTree.EQ,\n                            make().Apply(null, makeSelect(\"this\", ctxtName), List.<JCExpression>nil()), makeBoolean(true)),\n                            make().Block(0, List.<JCStatement>of(\n                                make().Exec(make().Assign(makeUnquotedIdent(iterVar),\n                                        make().Apply(null, makeSelect(\"this\", iterVar), List.<JCExpression>nil()))),\n                                make().Return(make().Apply(null,\n                                        make().Select(makeUnquotedIdent(\"this\"),\n                                        names().fromString(itemVar)), List.<JCExpression>nil()))\n                    )), null));\n                }\n                innerBody.add(make().Return(makeBoolean(false)));\n                contextBody.add(make().If(make().Binary(JCTree.EQ, makeUnquotedIdent(itemVar+\"$exhausted\"), makeBoolean(true)),\n                    make().Block(0, innerBody.toList()),\n                    make().Block(0, elseBody.toList())));\n                contextBody.add(make().Return(makeBoolean(true)));\n                //Create the context method that returns the next item for this iterator\n                ctxtName = itemVar;\n                fields.add(make().MethodDef(make().Modifiers(2), names().fromString(itemVar),\n                    makeJavaType(typeFact().getBooleanDeclaration().getType()),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(),\n                    make().Block(0, contextBody.toList()), null));\n                clause = fcl.getComprehensionClause();\n\n            } else if (clause instanceof IfComprehensionClause) {\n\n                Condition cond = ((IfComprehensionClause)clause).getCondition();\n                //The context of an if is an iteration through the parent, checking each element against the condition\n                Variable var = null;\n                if (cond instanceof IsCondition || cond instanceof ExistsOrNonemptyCondition) {\n                    var = cond instanceof IsCondition ? ((IsCondition)cond).getVariable()\n                            : ((ExistsOrNonemptyCondition)cond).getVariable();\n                    //Initialize the condition's attribute to finished so that this is returned\n                    //in case the condition is not met and the iterator is exhausted\n                    fields.add(make().VarDef(make().Modifiers(2), names().fromString(var.getDeclarationModel().getName()),\n                            makeJavaType(typeFact().getObjectDeclaration().getType()), makeFinished()));\n                }\n                JCExpression condExpr = make().Binary(JCTree.EQ, make().Apply(null,\n                    make().Select(makeUnquotedIdent(\"this\"), names().fromString(ctxtName)), List.<JCExpression>nil()),\n                    makeBoolean(true));\n                //AND previous iterator condition with the comprehension's\n                final JCExpression otherCondition;\n                if (cond instanceof IsCondition) {\n                    otherCondition = transformExpression(((IsCondition) cond).getExpression());\n                } else if (cond instanceof ExistsOrNonemptyCondition) {\n                    otherCondition = transformExpression(((ExistsOrNonemptyCondition) cond).getExpression());\n                } else if (cond instanceof BooleanCondition) {\n                    otherCondition = transformExpression(((BooleanCondition) cond).getExpression(),\n                            BoxingStrategy.UNBOXED, typeFact().getBooleanDeclaration().getType());\n                } else {\n                    return makeErroneous(cond, \"This type of condition is not supported yet for comprehensions\");\n                }\n                condExpr = make().Binary(JCTree.AND, condExpr, make().Unary(JCTree.NOT, otherCondition));\n                //Create the context method that filters from the last iterator\n                ctxtName = \"next\"+idx;\n                fields.add(make().MethodDef(make().Modifiers(2), names().fromString(ctxtName),\n                    makeJavaType(typeFact().getBooleanDeclaration().getType()),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(),\n                    List.<JCExpression>nil(), make().Block(0, List.<JCStatement>of(\n                        make().WhileLoop(condExpr, make().Block(0, List.<JCStatement>nil())),\n                        make().Return(make().Unary(JCTree.NOT, makeUnquotedIdent(prevItemVar+\"$exhausted\")))\n                )), null));\n                clause = ((IfComprehensionClause)clause).getComprehensionClause();\n                itemVar = prevItemVar;\n\n            } else if (clause instanceof ExpressionComprehensionClause) {\n\n                //Just keep a reference to the expression\n                excc = (ExpressionComprehensionClause)clause;\n                at(excc);\n                clause = null;\n\n            } else {\n                return makeErroneous(clause, \"No support for comprehension clause of type \" + clause.getClass().getName());\n            }\n            idx++;\n            if (itemVar != null) prevItemVar = itemVar;\n        }\n\n        //Define the next() method for the Iterator\n        fields.add(make().MethodDef(make().Modifiers(1), names().fromString(\"next\"),\n            makeJavaType(typeFact().getObjectDeclaration().getType()), List.<JCTree.JCTypeParameter>nil(),\n            List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(), make().Block(0, List.<JCStatement>of(\n                make().Return(\n                    make().Conditional(\n                        make().Binary(JCTree.EQ, make().Apply(null, make().Select(makeUnquotedIdent(\"this\"),\n                            names().fromString(ctxtName)), List.<JCExpression>nil()), makeBoolean(true)),\n                        transformExpression(excc.getExpression(), BoxingStrategy.BOXED, typeFact().getIteratedType(targetIterType)),\n                        makeFinished()))\n        )), null));\n        ProducedType iteratorType = typeFact().getIteratorType(typeFact().getIteratedType(targetIterType));\n        JCExpression iterator = make().NewClass(null, null,makeJavaType(iteratorType, CLASS_NEW|EXTENDS),\n                List.<JCExpression>nil(), make().AnonymousClassDef(make().Modifiers(0), fields.toList()));\n        JCExpression iterable = make().NewClass(null, null,\n                make().TypeApply(makeIdent(syms().ceylonAbstractIterableType),\n                    List.<JCExpression>of(makeJavaType(typeFact().getIteratedType(targetIterType), NO_PRIMITIVES))),\n                List.<JCExpression>nil(), make().AnonymousClassDef(make().Modifiers(0), List.<JCTree>of(\n                    make().MethodDef(make().Modifiers(1), names().fromString(\"getIterator\"),\n                        makeJavaType(iteratorType, CLASS_NEW|EXTENDS),\n                    List.<JCTree.JCTypeParameter>nil(), List.<JCTree.JCVariableDecl>nil(), List.<JCExpression>nil(),\n                    make().Block(0, List.<JCStatement>of(make().Return(iterator))), null)\n        )));\n        return iterable;\n    }","commit_id":"16f9185562fc0fefdfe905f6a582b8bc3ae7dd1c","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public ClassDefinitionBuilder reifiedIs(ProducedType type, java.util.List<TypeParameter> typeParameters,\n            java.util.List<ProducedType> satisfiedTypes, ProducedType extendedType){\n        if ((modifiers & INTERFACE) != 0) {\n            // place the real body in the impl class\n            concreteInterfaceMemberDefs.reifiedIs(type, typeParameters, satisfiedTypes, extendedType);\n        }else{\n            MethodDefinitionBuilder method = MethodDefinitionBuilder.systemMethod(gen, gen.naming.getIsMethodName(type));\n            method.modifiers(PUBLIC);\n            method.resultType(List.<JCAnnotation>nil(), gen.make().TypeIdent(TypeTags.BOOLEAN));\n            // in classes this overrides an interface method\n            if(type.getDeclaration() instanceof com.redhat.ceylon.compiler.typechecker.model.Class)\n                method.isOverride(true);\n\n            String paramName = \"type\";\n            ParameterDefinitionBuilder param = ParameterDefinitionBuilder.instance(gen, paramName);\n            param.type(gen.makeTypeDescriptorType(), List.<JCAnnotation>nil());\n            method.parameter(param);\n\n            // we build the body last to first, and last is false or extended type\n            JCExpression lastTest;\n            if(extendedType != null && !gen.willEraseToObject(extendedType)){\n                if(Decl.isCeylon(extendedType.getDeclaration()))\n                    lastTest = gen.make().Apply(null, gen.makeSelect(\"super\", gen.naming.getIsMethodName(extendedType)), List.of(gen.makeUnquotedIdent(paramName)));\n                else\n                    lastTest = gen.makeUtilInvocation(\"isReifiedJava\", \n                            List.of(gen.makeReifiedTypeArgument(extendedType), gen.makeUnquotedIdent(paramName)), \n                            List.<JCTree.JCExpression>nil());\n            }else\n                lastTest = gen.makeBoolean(false);\n            List<JCStatement> body = List.<JCStatement>of(gen.make().Return(lastTest));\n\n            // then before that we test every interface\n            if(!satisfiedTypes.isEmpty()){\n                JCExpression interfacesTest = null;\n                for(ProducedType pt : satisfiedTypes){\n                    JCExpression isCall;\n                    Interface iface = (Interface) pt.getDeclaration();\n                    if(Decl.isCeylon(iface)){\n                        final String implFieldName = gen.getCompanionFieldName(iface);\n                        String isDelegateName = gen.naming.getIsMethodName(pt);\n                        isCall = gen.make().Apply(null, gen.makeSelect(implFieldName, isDelegateName), \n                                                  List.<JCExpression>of(gen.makeUnquotedIdent(paramName)));\n                    }else{\n                        isCall = gen.makeUtilInvocation(\"isReifiedJava\", \n                                List.of(gen.makeReifiedTypeArgument(pt), gen.makeUnquotedIdent(paramName)), \n                                List.<JCTree.JCExpression>nil());\n                    }\n                    if(interfacesTest != null)\n                        interfacesTest = gen.make().Binary(JCTree.OR, isCall, interfacesTest);\n                    else\n                        interfacesTest = isCall;\n                }\n                JCStatement ifInterfacesTest = gen.make().If(interfacesTest, gen.make().Return(gen.makeBoolean(true)), null);\n                body = body.prepend(ifInterfacesTest);\n            }\n            \n            // no point checking for exact class since anonymous classes can't be referred to by \"is\"\n            if(!type.getDeclaration().isAnonymous()){\n                // finally check for the exact class match\n                JCExpression classDescriptorCall = gen.makeReifiedTypeArgument(type);\n                JCExpression classEqualsCall = gen.make().Apply(null, gen.makeSelect(classDescriptorCall, \"equals\"), List.of(gen.makeUnquotedIdent(paramName)));\n                JCStatement classTest = gen.make().If(classEqualsCall, gen.make().Return(gen.makeBoolean(true)), null);\n                body = body.prepend(classTest);\n            }\n\n            method.body(body);\n            defs(method.build());\n        }\n        \n        return this;\n    }","id":24462,"modified_method":"public ClassDefinitionBuilder reifiedIs(ProducedType type, java.util.List<TypeParameter> typeParameters,\n            java.util.List<ProducedType> satisfiedTypes, ProducedType extendedType){\n        if ((modifiers & INTERFACE) != 0) {\n            // place the real body in the impl class\n            concreteInterfaceMemberDefs.reifiedIs(type, typeParameters, satisfiedTypes, extendedType);\n        }else{\n            MethodDefinitionBuilder method = MethodDefinitionBuilder.systemMethod(gen, gen.naming.getIsMethodName(type));\n            method.modifiers(PUBLIC);\n            method.resultType(List.<JCAnnotation>nil(), gen.make().TypeIdent(TypeTags.BOOLEAN));\n            // in classes this overrides an interface method\n            if(type.getDeclaration() instanceof com.redhat.ceylon.compiler.typechecker.model.Class)\n                method.isOverride(true);\n\n            String paramName = \"type\";\n            ParameterDefinitionBuilder param = ParameterDefinitionBuilder.instance(gen, paramName);\n            param.type(gen.makeTypeDescriptorType(), List.<JCAnnotation>nil());\n            method.parameter(param);\n\n            // we build the body last to first, and last is false or extended type\n            JCExpression lastTest;\n            if(extendedType != null && !gen.willEraseToObject(extendedType)){\n                if(Decl.isCeylon(extendedType.getDeclaration()))\n                    lastTest = gen.make().Apply(null, gen.makeSelect(\"super\", gen.naming.getIsMethodName(extendedType)), List.of(gen.makeUnquotedIdent(paramName)));\n                else\n                    lastTest = gen.makeUtilInvocation(\"isReifiedJava\", \n                            List.of(gen.makeReifiedTypeArgument(extendedType), gen.makeUnquotedIdent(paramName)), \n                            List.<JCTree.JCExpression>nil());\n            }else\n                lastTest = gen.makeBoolean(false);\n            List<JCStatement> body = List.<JCStatement>of(gen.make().Return(lastTest));\n\n            // then before that we test every interface\n            if(!satisfiedTypes.isEmpty()){\n                JCExpression interfacesTest = null;\n                for(ProducedType pt : satisfiedTypes){\n                    JCExpression isCall;\n                    Interface iface = (Interface) pt.getDeclaration();\n                    if(Decl.isCeylon(iface)){\n                        String isDelegateName = gen.naming.getIsMethodName(pt);\n                        String implFieldName = gen.getCompanionFieldName(iface);\n                        JCExpression testMethod;\n                        if(isCompanion){\n                            String implMethodName = gen.naming.getCompanionAccessorName(iface);\n                            JCExpression interfaceImplAccessor = gen.make().Apply(null, gen.makeSelect(gen.naming.makeQuotedThis(), implMethodName),\n                                                                                  List.<JCExpression>nil());\n                            testMethod = gen.makeSelect(interfaceImplAccessor, isDelegateName);\n                        }else{\n                            testMethod = gen.makeSelect(implFieldName, isDelegateName);\n                        }\n                        isCall = gen.make().Apply(null, testMethod, \n                                                  List.<JCExpression>of(gen.makeUnquotedIdent(paramName)));\n                    }else{\n                        isCall = gen.makeUtilInvocation(\"isReifiedJava\", \n                                List.of(gen.makeReifiedTypeArgument(pt), gen.makeUnquotedIdent(paramName)), \n                                List.<JCTree.JCExpression>nil());\n                    }\n                    if(interfacesTest != null)\n                        interfacesTest = gen.make().Binary(JCTree.OR, isCall, interfacesTest);\n                    else\n                        interfacesTest = isCall;\n                }\n                JCStatement ifInterfacesTest = gen.make().If(interfacesTest, gen.make().Return(gen.makeBoolean(true)), null);\n                body = body.prepend(ifInterfacesTest);\n            }\n            \n            // no point checking for exact class since anonymous classes can't be referred to by \"is\"\n            if(!type.getDeclaration().isAnonymous()){\n                // finally check for the exact class match\n                JCExpression classDescriptorCall = gen.makeReifiedTypeArgument(type);\n                JCExpression classEqualsCall = gen.make().Apply(null, gen.makeSelect(classDescriptorCall, \"equals\"), List.of(gen.makeUnquotedIdent(paramName)));\n                JCStatement classTest = gen.make().If(classEqualsCall, gen.make().Return(gen.makeBoolean(true)), null);\n                body = body.prepend(classTest);\n            }\n\n            method.body(body);\n            defs(method.build());\n        }\n        \n        return this;\n    }","commit_id":"e9b36e72a962703c42dcbbffc8d294dbfbc50c56","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void write(File outputFile, String output) throws IOException {\n\t\ttry (Writer writer = new OutputStreamWriter(\n\t\t\tnew FileOutputStream(outputFile, false), StringPool.UTF8)) {\n\n\t\t\twriter.write(output);\n\t\t}\n\t}","id":24463,"modified_method":"private void write(File file, String string) throws IOException {\n\t\ttry (Writer writer = new OutputStreamWriter(\n\t\t\t\tnew FileOutputStream(file, false), StringPool.UTF8)) {\n\n\t\t\twriter.write(string);\n\t\t}\n\t}","commit_id":"38caca4e113d7dee1b3fe20e66806421c17acccb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SassCompiler(String[] args) throws Exception {\n\t\tfinal SassCompiler compiler = new SassCompiler();\n\n\t\tfor (String arg : args) {\n\t\t\tfinal File file = new File(arg);\n\n\t\t\tif (isValidFile(file)) {\n\t\t\t\tfinal String output = compiler.compileFile(arg, \"\", \"\");\n\n\t\t\t\tfinal File outputFile = getOutputFile(file);\n\t\t\t\twrite(outputFile, output);\n\t\t\t}\n\t\t}\n\t}","id":24464,"modified_method":"public SassCompiler(String[] fileNames) throws Exception {\n\t\tfinal SassCompiler sassCompiler = new SassCompiler();\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tFile file = new File(fileName);\n\n\t\t\tif (!isValidFile(file)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twrite(\n\t\t\t\tgetOutputFile(file),\n\t\t\t\tsassCompiler.compileFile(fileName, \"\", \"\"));\n\t\t}\n\t}","commit_id":"38caca4e113d7dee1b3fe20e66806421c17acccb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public String compileFile(\n\t\t\tString inputFile, String includePath, String imgPath)\n\t\tthrows SassCompilerException {\n\n\t\t// NONE((byte)0), DEFAULT((byte)1), MAP((byte)2);\n\n\t\tfinal byte sourceComments = (byte) 0;\n\n\t\tfinal String includePaths =\n\t\t\tincludePath + File.pathSeparator + new File(inputFile).getParent();\n\n\t\tSass_File_Context sassFileContext = null;\n\n\t\ttry {\n\t\t\tfinal Sass_Options opt = _libsass.sass_make_options();\n\t\t\t_libsass.sass_option_set_input_path(opt, inputFile);\n\t\t\t_libsass.sass_option_set_output_path(opt, \"\");\n\t\t\t_libsass.sass_option_set_image_path(opt, imgPath);\n\t\t\t_libsass.sass_option_set_output_style(\n\t\t\t\topt, Sass_Output_Style.SASS_STYLE_COMPACT);\n\t\t\t_libsass.sass_option_set_source_comments(opt, sourceComments);\n\t\t\t_libsass.sass_option_set_include_path(opt, includePaths);\n\n\t\t\tsassFileContext = _libsass.sass_make_file_context(inputFile);\n\t\t\t_libsass.sass_file_context_set_options(sassFileContext, opt);\n\n\t\t\t_libsass.sass_compile_file_context(sassFileContext);\n\n\t\t\tfinal Sass_Context context = _libsass.sass_file_context_get_context(\n\t\t\t\tsassFileContext);\n\t\t\tfinal int errorStatus = _libsass.sass_context_get_error_status(\n\t\t\t\tcontext);\n\n\t\t\tif (errorStatus != 0) {\n\t\t\t\tString errorMsg = _libsass.sass_context_get_error_message(\n\t\t\t\t\tcontext);\n\t\t\t\tthrow new SassCompilerException(errorMsg);\n\t\t\t}\n\n\t\t\tfinal String outputString = _libsass.sass_context_get_output_string(\n\t\t\t\tcontext);\n\n\t\t\tif ((outputString == null) || (outputString == null)) {\n\t\t\t\tthrow new SassCompilerException(\"libsass returned null\");\n\t\t\t}\n\n\t\t\treturn outputString;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (sassFileContext != null) {\n\t\t\t\t\t_libsass.sass_delete_file_context(sassFileContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tthrow new SassCompilerException(t);\n\t\t\t}\n\t\t}\n\t}","id":24465,"modified_method":"public String compileFile(\n\t\t\tString inputFile, String includePath, String imgPath)\n\t\tthrows SassCompilerException {\n\n\t\t// NONE((byte)0), DEFAULT((byte)1), MAP((byte)2);\n\n\t\tbyte sourceComments = (byte)0;\n\n\t\tString includePaths =\n\t\t\tincludePath + File.pathSeparator + new File(inputFile).getParent();\n\n\t\tSass_File_Context sassFileContext = null;\n\n\t\ttry {\n\t\t\tfinal Sass_Options opt = _sassLibrary.sass_make_options();\n\n\t\t\t_sassLibrary.sass_option_set_input_path(opt, inputFile);\n\t\t\t_sassLibrary.sass_option_set_output_path(opt, \"\");\n\t\t\t_sassLibrary.sass_option_set_image_path(opt, imgPath);\n\t\t\t_sassLibrary.sass_option_set_output_style(\n\t\t\t\topt, Sass_Output_Style.SASS_STYLE_COMPACT);\n\t\t\t_sassLibrary.sass_option_set_source_comments(opt, sourceComments);\n\t\t\t_sassLibrary.sass_option_set_include_path(opt, includePaths);\n\n\t\t\tsassFileContext = _sassLibrary.sass_make_file_context(inputFile);\n\t\t\t_sassLibrary.sass_file_context_set_options(sassFileContext, opt);\n\n\t\t\t_sassLibrary.sass_compile_file_context(sassFileContext);\n\n\t\t\tfinal Sass_Context context = _sassLibrary.sass_file_context_get_context(\n\t\t\t\tsassFileContext);\n\t\t\tfinal int errorStatus = _sassLibrary.sass_context_get_error_status(\n\t\t\t\tcontext);\n\n\t\t\tif (errorStatus != 0) {\n\t\t\t\tString errorMsg = _sassLibrary.sass_context_get_error_message(\n\t\t\t\t\tcontext);\n\t\t\t\tthrow new SassCompilerException(errorMsg);\n\t\t\t}\n\n\t\t\tfinal String outputString = _sassLibrary.sass_context_get_output_string(\n\t\t\t\tcontext);\n\n\t\t\tif ((outputString == null) || (outputString == null)) {\n\t\t\t\tthrow new SassCompilerException(\"libsass returned null\");\n\t\t\t}\n\n\t\t\treturn outputString;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (sassFileContext != null) {\n\t\t\t\t\t_sassLibrary.sass_delete_file_context(sassFileContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tthrow new SassCompilerException(t);\n\t\t\t}\n\t\t}\n\t}","commit_id":"38caca4e113d7dee1b3fe20e66806421c17acccb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean isValidFile(File file) {\n\t\treturn file != null && file.exists() &&\n\t\t\tfile.getName().endsWith(\".scss\");\n\t}","id":24466,"modified_method":"private boolean isValidFile(File file) {\n\t\tif (file == null) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\tif (!file.exists()) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tString fileName = file.getName();\n\n\t\treturn fileName.endsWith(\".scss\");\n\t}","commit_id":"38caca4e113d7dee1b3fe20e66806421c17acccb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void flushContext(CompileContext context) {\n    if (context != null) {\n      context.getTimestamps().force();\n      context.getDataManager().flush(false);\n    }\n    final ExternalJavacDescriptor descriptor = ExternalJavacDescriptor.KEY.get(context);\n    if (descriptor != null) {\n      try {\n        final RequestFuture future = descriptor.client.sendShutdownRequest();\n        future.waitFor(500L, TimeUnit.MILLISECONDS);\n      }\n      finally {\n        // ensure process is not running\n        descriptor.process.destroyProcess();\n      }\n      ExternalJavacDescriptor.KEY.set(context, null);\n    }\n    cleanupJavacNameTable();\n  }","id":24467,"modified_method":"private static void flushContext(CompileContext context) {\n    if (context != null) {\n      context.getTimestamps().force();\n      context.getDataManager().flush(false);\n    }\n    final ExternalJavacDescriptor descriptor = ExternalJavacDescriptor.KEY.get(context);\n    if (descriptor != null) {\n      try {\n        final RequestFuture future = descriptor.client.sendShutdownRequest();\n        future.waitFor(500L, TimeUnit.MILLISECONDS);\n      }\n      finally {\n        // ensure process is not running\n        descriptor.process.destroyProcess();\n      }\n      ExternalJavacDescriptor.KEY.set(context, null);\n    }\n    //cleanupJavacNameTable();\n  }","commit_id":"16d1250f9c1579d886b128b155ed6075896afbe3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void collectFromDirectory(File directory, Set<JavaFileObject.Kind> fileKinds, boolean recurse, ListBuffer<JavaFileObject> result) {\n    final File[] children = directory.listFiles();\n    if (children != null) {\n      for (File child : children) {\n        if (isValidFile(child.getName(), fileKinds) && isFile(child)) {\n          final JavaFileObject fe = new InputFileObject(child);\n          result.append(fe);\n        }\n      }\n    }\n  }","id":24468,"modified_method":"private void collectFromDirectory(File directory, Set<JavaFileObject.Kind> fileKinds, boolean recurse, ListBuffer<JavaFileObject> result) {\n    final File[] children = directory.listFiles();\n    if (children != null) {\n      final boolean acceptUnknownFiles = fileKinds.contains(JavaFileObject.Kind.OTHER);\n      for (File child : children) {\n        if (isValidFile(child.getName(), fileKinds)) {\n          if (acceptUnknownFiles && !isFile(child)) {\n            continue;\n          }\n          final JavaFileObject fe = new InputFileObject(child);\n          result.append(fe);\n        }\n      }\n    }\n  }","commit_id":"16d1250f9c1579d886b128b155ed6075896afbe3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void listDirectory(File directory, Set<JavaFileObject.Kind> fileKinds, ListBuffer<JavaFileObject> resultList) {\n    final File[] files = directory.listFiles();\n    if (files != null) {\n      if (sortFiles != null) {\n        Arrays.sort(files, sortFiles);\n      }\n  \n      for (File f: files) {\n        String fileName = f.getName();\n        if (isValidFile(fileName, fileKinds) && isFile(f)) {\n          JavaFileObject fe = new InputFileObject(this, f);\n          resultList.append(fe);\n        }\n      }\n    }\n  }","id":24469,"modified_method":"private void listDirectory(File directory, Set<JavaFileObject.Kind> fileKinds, ListBuffer<JavaFileObject> resultList) {\n    final File[] files = directory.listFiles();\n    if (files != null) {\n      if (sortFiles != null) {\n        Arrays.sort(files, sortFiles);\n      }\n      final boolean acceptUnknownFiles = fileKinds.contains(JavaFileObject.Kind.OTHER);\n      for (File f: files) {\n        final String fileName = f.getName();\n        if (isValidFile(fileName, fileKinds)) {\n          if (acceptUnknownFiles && !isFile(f)) {\n            continue;\n          }\n          final JavaFileObject fe = new InputFileObject(this, f);\n          resultList.append(fe);\n        }\n      }\n    }\n  }","commit_id":"16d1250f9c1579d886b128b155ed6075896afbe3","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AudioBackAction() {\n        super(tr(\"Back\"), \"audio-back\", tr(\"Jump back.\"),\n        Shortcut.registerShortcut(\"audio:back\", tr(\"Audio: {0}\", tr(\"Back\")), KeyEvent.VK_F6, Shortcut.GROUP_DIRECT), true);\n        amount = -Main.pref.getDouble(\"audio.forwardbackamount\",10.0);\n        this.putValue(\"help\", \"Action/Back\");\n    }","id":24470,"modified_method":"public AudioBackAction() {\n        super(tr(\"Back\"), \"audio-back\", tr(\"Jump back.\"),\n        Shortcut.registerShortcut(\"audio:back\", tr(\"Audio: {0}\", tr(\"Back\")), KeyEvent.VK_F6, Shortcut.GROUP_DIRECT), true);\n        amount = -Main.pref.getDouble(\"audio.forwardbackamount\",\"10.0\");\n        this.putValue(\"help\", \"Action/Back\");\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"public AudioFwdAction() {\n        super(tr(\"Forward\"), \"audio-fwd\", tr(\"Jump forward\"),\n        Shortcut.registerShortcut(\"audio:forward\", tr(\"Audio: {0}\", tr(\"Forward\")), KeyEvent.VK_F7, Shortcut.GROUP_DIRECT), true);\n        amount = Main.pref.getDouble(\"audio.forwardbackamount\",10.0);\n    }","id":24471,"modified_method":"public AudioFwdAction() {\n        super(tr(\"Forward\"), \"audio-fwd\", tr(\"Jump forward\"),\n        Shortcut.registerShortcut(\"audio:forward\", tr(\"Audio: {0}\", tr(\"Forward\")), KeyEvent.VK_F7, Shortcut.GROUP_DIRECT), true);\n        amount = Main.pref.getDouble(\"audio.forwardbackamount\",\"10.0\");\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void addGui(PreferenceDialog gui) {\n        gui.display.setPreferredSize(new Dimension(400,600));\n        JPanel panel = new JPanel(new GridBagLayout());\n        panel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n        // drawRawGpsLines\n        drawRawGpsLines.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e) {\n                            forceRawGpsLines.setEnabled(drawRawGpsLines.isSelected());\n                            drawRawGpsMaxLineLength.setEnabled(drawRawGpsLines.isSelected());\n                            drawGpsArrows.setEnabled(drawRawGpsLines.isSelected());\n                            drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            drawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            colorTracks.setEnabled(drawRawGpsLines.isSelected());\n            }\n        });\n        drawRawGpsLines.setSelected(Main.pref.getBoolean(\"draw.rawgps.lines\"));\n        drawRawGpsLines.setToolTipText(tr(\"If your gps device draws too few lines, select this to draw lines along your way.\"));\n        panel.add(drawRawGpsLines, GBC.eol().insets(20,0,0,0));\n\n        // drawRawGpsMaxLineLength\n        drawRawGpsMaxLineLength.setText(Integer.toString(Main.pref.getInteger(\"draw.rawgps.max-line-length\", -1)));\n        drawRawGpsMaxLineLength.setToolTipText(tr(\"Maximum length (in meters) to draw lines. Set to '-1' to draw all lines.\"));\n        drawRawGpsMaxLineLength.setEnabled(drawRawGpsLines.isSelected());\n        panel.add(new JLabel(tr(\"Maximum length (meters)\")), GBC.std().insets(40,0,0,0));\n        panel.add(drawRawGpsMaxLineLength, GBC.eol().fill(GBC.HORIZONTAL).insets(5,0,0,5));\n\n        // forceRawGpsLines\n        forceRawGpsLines.setToolTipText(tr(\"Force drawing of lines if the imported data contain no line information.\"));\n        forceRawGpsLines.setSelected(Main.pref.getBoolean(\"draw.rawgps.lines.force\"));\n        forceRawGpsLines.setEnabled(drawRawGpsLines.isSelected());\n        panel.add(forceRawGpsLines, GBC.eop().insets(40,0,0,0));\n\n        // drawGpsArrows\n        drawGpsArrows.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e) {\n                            drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            drawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n            }\n        });\n        drawGpsArrows.setToolTipText(tr(\"Draw direction arrows for lines, connecting GPS points.\"));\n        drawGpsArrows.setSelected(Main.pref.getBoolean(\"draw.rawgps.direction\"));\n        drawGpsArrows.setEnabled(drawRawGpsLines.isSelected());\n        panel.add(drawGpsArrows, GBC.eop().insets(40,0,0,0));\n\n        // drawGpsArrowsFast\n        drawGpsArrowsFast.setToolTipText(tr(\"Draw the direction arrows using table lookups instead of complex math.\"));\n        drawGpsArrowsFast.setSelected(Main.pref.getBoolean(\"draw.rawgps.alternatedirection\"));\n        drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n        panel.add(drawGpsArrowsFast, GBC.eop().insets(60,0,0,0));\n\n        // drawGpsArrowsMinDist\n        drawGpsArrowsMinDist.setToolTipText(tr(\"Don't draw arrows if they are not at least this distance away from the last one.\"));\n        drawGpsArrowsMinDist.setText(Integer.toString(Main.pref.getInteger(\"draw.rawgps.min-arrow-distance\", 0)));\n        drawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n        panel.add(new JLabel(tr(\"Minimum distance (pixels)\")), GBC.std().insets(60,0,0,0));\n        panel.add(drawGpsArrowsMinDist, GBC.eol().fill(GBC.HORIZONTAL).insets(5,0,0,5));\n\n        // colorTracks\n        colorTracks.setSelected(Main.pref.getBoolean(\"draw.rawgps.colors\"));\n        colorTracks.setToolTipText(tr(\"Choose the hue for the track color by the velocity at that point.\"));\n        colorTracks.setEnabled(drawRawGpsLines.isSelected());\n        panel.add(colorTracks, GBC.eop().insets(40,0,0,0));\n\n        // largeGpsPoints\n        largeGpsPoints.setSelected(Main.pref.getBoolean(\"draw.rawgps.large\"));\n        largeGpsPoints.setToolTipText(tr(\"Draw larger dots for the GPS points.\"));\n        panel.add(largeGpsPoints, GBC.eop().insets(20,0,0,0));\n\n        panel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n        JScrollPane scrollpane = new JScrollPane(panel);\n        scrollpane.setBorder(BorderFactory.createEmptyBorder( 0, 0, 0, 0 ));\n        gui.displaycontent.addTab(tr(\"GPS Points\"), scrollpane);\n        panel = new JPanel(new GridBagLayout());\n        panel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n        // directionHint\n        directionHint.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e) {\n                            if (directionHint.isSelected()){\n                                interestingDirections.setSelected(Main.pref.getBoolean(\"draw.segment.relevant_directions_only\", true));\n                            }else{\n                                interestingDirections.setSelected(false);\n                            }\n                            interestingDirections.setEnabled(directionHint.isSelected());\n            }\n        });\n        directionHint.setToolTipText(tr(\"Draw direction hints for way segments.\"));\n        directionHint.setSelected(Main.pref.getBoolean(\"draw.segment.direction\"));\n        panel.add(directionHint, GBC.eop().insets(20,0,0,0));\n\n        // only interesting directions\n        interestingDirections.setToolTipText(tr(\"Only interesting direction hints (e.g. with oneway tag).\"));\n        interestingDirections.setSelected(Main.pref.getBoolean(\"draw.segment.relevant_directions_only\", true));\n        interestingDirections.setEnabled(directionHint.isSelected());\n        panel.add(interestingDirections, GBC.eop().insets(40,0,0,0));\n\n        // segment order number\n        segmentOrderNumber.setToolTipText(tr(\"Draw the order numbers of all segments within their way.\"));\n        segmentOrderNumber.setSelected(Main.pref.getBoolean(\"draw.segment.order_number\"));\n        panel.add(segmentOrderNumber, GBC.eop().insets(20,0,0,0));\n\n        // antialiasing\n        useAntialiasing.setToolTipText(tr(\"Apply antialiasing to the map view resulting in a smoother appearance.\"));\n        useAntialiasing.setSelected(Main.pref.getBoolean(\"mappaint.use-antialiasing\"));\n        panel.add(useAntialiasing, GBC.eop().insets(20,0,0,0));\n\n        // downloaded area\n        sourceBounds.setToolTipText(tr(\"Draw the boundaries of data loaded from the server.\"));\n        sourceBounds.setSelected(Main.pref.getBoolean(\"draw.data.downloaded_area\", true));\n        panel.add(sourceBounds, GBC.eop().insets(20,0,0,0));\n\n        // virtual nodes\n        virtualNodes.setToolTipText(tr(\"Draw virtual nodes in select mode for easy way modification.\"));\n        virtualNodes.setSelected(Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) != 0);\n        panel.add(virtualNodes, GBC.eop().insets(20,0,0,0));\n\n        // background layers in inactive color\n        inactive.setToolTipText(tr(\"Draw the inactive data layers in a different color.\"));\n        inactive.setSelected(Main.pref.getBoolean(\"draw.data.inactive_color\", true));\n        panel.add(inactive, GBC.eop().insets(20,0,0,0));\n\n        panel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n        scrollpane = new JScrollPane(panel);\n        scrollpane.setBorder(BorderFactory.createEmptyBorder( 0, 0, 0, 0 ));\n        gui.displaycontent.addTab(tr(\"OSM Data\"), scrollpane);\n    }","id":24472,"modified_method":"public void addGui(PreferenceDialog gui) {\n        gui.display.setPreferredSize(new Dimension(400,600));\n        JPanel panel = new JPanel(new GridBagLayout());\n        panel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n        // drawRawGpsLines\n        drawRawGpsLines.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e) {\n                            forceRawGpsLines.setEnabled(drawRawGpsLines.isSelected());\n                            drawRawGpsMaxLineLength.setEnabled(drawRawGpsLines.isSelected());\n                            drawGpsArrows.setEnabled(drawRawGpsLines.isSelected());\n                            drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            drawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            colorTracks.setEnabled(drawRawGpsLines.isSelected());\n            }\n        });\n        drawRawGpsLines.setSelected(Main.pref.getBoolean(\"draw.rawgps.lines\"));\n        drawRawGpsLines.setToolTipText(tr(\"If your gps device draws too few lines, select this to draw lines along your way.\"));\n        panel.add(drawRawGpsLines, GBC.eol().insets(20,0,0,0));\n\n        // drawRawGpsMaxLineLength\n        drawRawGpsMaxLineLength.setText(Integer.toString(Main.pref.getInteger(\"draw.rawgps.max-line-length\", -1)));\n        drawRawGpsMaxLineLength.setToolTipText(tr(\"Maximum length (in meters) to draw lines. Set to '-1' to draw all lines.\"));\n        drawRawGpsMaxLineLength.setEnabled(drawRawGpsLines.isSelected());\n        panel.add(new JLabel(tr(\"Maximum length (meters)\")), GBC.std().insets(40,0,0,0));\n        panel.add(drawRawGpsMaxLineLength, GBC.eol().fill(GBC.HORIZONTAL).insets(5,0,0,5));\n\n        // forceRawGpsLines\n        forceRawGpsLines.setToolTipText(tr(\"Force drawing of lines if the imported data contain no line information.\"));\n        forceRawGpsLines.setSelected(Main.pref.getBoolean(\"draw.rawgps.lines.force\"));\n        forceRawGpsLines.setEnabled(drawRawGpsLines.isSelected());\n        panel.add(forceRawGpsLines, GBC.eop().insets(40,0,0,0));\n\n        // drawGpsArrows\n        drawGpsArrows.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e) {\n                            drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n                            drawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n            }\n        });\n        drawGpsArrows.setToolTipText(tr(\"Draw direction arrows for lines, connecting GPS points.\"));\n        drawGpsArrows.setSelected(Main.pref.getBoolean(\"draw.rawgps.direction\"));\n        drawGpsArrows.setEnabled(drawRawGpsLines.isSelected());\n        panel.add(drawGpsArrows, GBC.eop().insets(40,0,0,0));\n\n        // drawGpsArrowsFast\n        drawGpsArrowsFast.setToolTipText(tr(\"Draw the direction arrows using table lookups instead of complex math.\"));\n        drawGpsArrowsFast.setSelected(Main.pref.getBoolean(\"draw.rawgps.alternatedirection\"));\n        drawGpsArrowsFast.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n        panel.add(drawGpsArrowsFast, GBC.eop().insets(60,0,0,0));\n\n        // drawGpsArrowsMinDist\n        drawGpsArrowsMinDist.setToolTipText(tr(\"Don't draw arrows if they are not at least this distance away from the last one.\"));\n        drawGpsArrowsMinDist.setText(Integer.toString(Main.pref.getInteger(\"draw.rawgps.min-arrow-distance\", 0)));\n        drawGpsArrowsMinDist.setEnabled(drawGpsArrows.isSelected() && drawGpsArrows.isEnabled());\n        panel.add(new JLabel(tr(\"Minimum distance (pixels)\")), GBC.std().insets(60,0,0,0));\n        panel.add(drawGpsArrowsMinDist, GBC.eol().fill(GBC.HORIZONTAL).insets(5,0,0,5));\n\n        // colorTracks\n        colorTracks.setSelected(Main.pref.getBoolean(\"draw.rawgps.colors\"));\n        colorTracks.setToolTipText(tr(\"Choose the hue for the track color by the velocity at that point.\"));\n        colorTracks.setEnabled(drawRawGpsLines.isSelected());\n        panel.add(colorTracks, GBC.eop().insets(40,0,0,0));\n\n        // largeGpsPoints\n        largeGpsPoints.setSelected(Main.pref.getBoolean(\"draw.rawgps.large\"));\n        largeGpsPoints.setToolTipText(tr(\"Draw larger dots for the GPS points.\"));\n        panel.add(largeGpsPoints, GBC.eop().insets(20,0,0,0));\n\n        panel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n        JScrollPane scrollpane = new JScrollPane(panel);\n        scrollpane.setBorder(BorderFactory.createEmptyBorder( 0, 0, 0, 0 ));\n        gui.displaycontent.addTab(tr(\"GPS Points\"), scrollpane);\n        panel = new JPanel(new GridBagLayout());\n        panel.setBorder(BorderFactory.createEmptyBorder(5,5,5,5));\n\n        // directionHint\n        directionHint.addActionListener(new ActionListener(){\n            public void actionPerformed(ActionEvent e) {\n                            if (directionHint.isSelected()){\n                                interestingDirections.setSelected(Main.pref.getBoolean(\"draw.segment.relevant_directions_only\", true));\n                            }else{\n                                interestingDirections.setSelected(false);\n                            }\n                            interestingDirections.setEnabled(directionHint.isSelected());\n            }\n        });\n        directionHint.setToolTipText(tr(\"Draw direction hints for way segments.\"));\n        directionHint.setSelected(Main.pref.getBoolean(\"draw.segment.direction\", true));\n        panel.add(directionHint, GBC.eop().insets(20,0,0,0));\n\n        // only interesting directions\n        interestingDirections.setToolTipText(tr(\"Only interesting direction hints (e.g. with oneway tag).\"));\n        interestingDirections.setSelected(Main.pref.getBoolean(\"draw.segment.relevant_directions_only\", true));\n        interestingDirections.setEnabled(directionHint.isSelected());\n        panel.add(interestingDirections, GBC.eop().insets(40,0,0,0));\n\n        // segment order number\n        segmentOrderNumber.setToolTipText(tr(\"Draw the order numbers of all segments within their way.\"));\n        segmentOrderNumber.setSelected(Main.pref.getBoolean(\"draw.segment.order_number\", false));\n        panel.add(segmentOrderNumber, GBC.eop().insets(20,0,0,0));\n\n        // antialiasing\n        useAntialiasing.setToolTipText(tr(\"Apply antialiasing to the map view resulting in a smoother appearance.\"));\n        useAntialiasing.setSelected(Main.pref.getBoolean(\"mappaint.use-antialiasing\", false));\n        panel.add(useAntialiasing, GBC.eop().insets(20,0,0,0));\n\n        // downloaded area\n        sourceBounds.setToolTipText(tr(\"Draw the boundaries of data loaded from the server.\"));\n        sourceBounds.setSelected(Main.pref.getBoolean(\"draw.data.downloaded_area\", true));\n        panel.add(sourceBounds, GBC.eop().insets(20,0,0,0));\n\n        // virtual nodes\n        virtualNodes.setToolTipText(tr(\"Draw virtual nodes in select mode for easy way modification.\"));\n        virtualNodes.setSelected(Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) != 0);\n        panel.add(virtualNodes, GBC.eop().insets(20,0,0,0));\n\n        // background layers in inactive color\n        inactive.setToolTipText(tr(\"Draw the inactive data layers in a different color.\"));\n        inactive.setSelected(Main.pref.getBoolean(\"draw.data.inactive_color\", true));\n        panel.add(inactive, GBC.eop().insets(20,0,0,0));\n\n        panel.add(Box.createVerticalGlue(), GBC.eol().fill(GBC.BOTH));\n        scrollpane = new JScrollPane(panel);\n        scrollpane.setBorder(BorderFactory.createEmptyBorder( 0, 0, 0, 0 ));\n        gui.displaycontent.addTab(tr(\"OSM Data\"), scrollpane);\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"Color convertColor(String colString)\n    {\n        int i = colString.indexOf(\"#\");\n        String colorString;\n        if(i < 0) // name only\n            colorString = Main.pref.get(\"color.mappaint.\"+styleName+\".\"+colString);\n        else if(i == 0) // value only\n            colorString = colString;\n        else // value and name\n            colorString = Main.pref.get(\"color.mappaint.\"+styleName+\".\"+colString.substring(0,i), colString.substring(i));\n        return ColorHelper.html2color(colorString);\n    }","id":24473,"modified_method":"Color convertColor(String colString)\n    {\n        int i = colString.indexOf(\"#\");\n        Color ret;\n        if(i < 0) // name only\n            ret = Main.pref.getColor(\"mappaint.\"+styleName+\".\"+colString, Color.red);\n        else if(i == 0) // value only\n            ret = ColorHelper.html2color(colString);\n        else // value and name\n            ret = Main.pref.getColor(\"mappaint.\"+styleName+\".\"+colString.substring(0,i),\n            ColorHelper.html2color(colString.substring(i)));\n        return ret;\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"public MainMenu() {\n        JMenuItem current;\n\n        add(fileMenu, newAction);\n        add(fileMenu, openFile);\n        add(fileMenu, openLocation);\n        fileMenu.addSeparator();\n        add(fileMenu, save);\n        add(fileMenu, saveAs);\n        add(fileMenu, gpxExport);\n        fileMenu.addSeparator();\n        add(fileMenu, download);\n        add(fileMenu, upload);\n        fileMenu.addSeparator();\n        add(fileMenu, exit);\n        add(fileMenu, KeyEvent.VK_F, \"file\");\n\n        add(editMenu, undo);\n        add(editMenu, redo);\n        editMenu.addSeparator();\n        add(editMenu, copy);\n        add(editMenu, paste);\n        add(editMenu, pasteTags);\n        add(editMenu, duplicate);\n        add(editMenu, delete);\n        editMenu.addSeparator();\n        add(editMenu, selectAll);\n        add(editMenu, unselectAll);\n        editMenu.addSeparator();\n        add(editMenu, search);\n        editMenu.addSeparator();\n        add(editMenu, preferences);\n        add(editMenu, KeyEvent.VK_E, \"edit\");\n\n        // TODO move code to an \"action\" like the others?\n        final JCheckBoxMenuItem wireframe = new JCheckBoxMenuItem(tr(\"Wireframe View\"));\n        wireframe.setSelected(Main.pref.getBoolean(\"draw.wireframe\", false));\n        wireframe.setAccelerator(Shortcut.registerShortcut(\"menu:view:wireframe\", tr(\"Toggle Wireframe view\"),\n                KeyEvent.VK_W, Shortcut.GROUP_MENU).getKeyStroke());\n        wireframe.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent ev) {\n                Main.pref.put(\"draw.wireframe\", wireframe.isSelected());\n                if (Main.map != null) {\n                    Main.map.mapView.repaint();\n                }\n            }\n        });\n        viewMenu.add(wireframe);\n        viewMenu.addSeparator();\n        add(viewMenu, new ZoomInAction());\n        add(viewMenu, new ZoomOutAction());\n        viewMenu.addSeparator();\n        for (String mode : AutoScaleAction.modes) {\n            JosmAction autoScaleAction = new AutoScaleAction(mode);\n            add(viewMenu, autoScaleAction);\n        }\n        add(viewMenu, KeyEvent.VK_V, \"view\");\n\n        add(toolsMenu, splitWay);\n        add(toolsMenu, combineWay);\n        toolsMenu.addSeparator();\n        add(toolsMenu, reverseWay);\n        toolsMenu.addSeparator();\n        add(toolsMenu, alignInCircle);\n        add(toolsMenu, alignInLine);\n        add(toolsMenu, ortho);\n        toolsMenu.addSeparator();\n        add(toolsMenu, addnode);\n        add(toolsMenu, createCircle);\n        toolsMenu.addSeparator();\n        add(toolsMenu, mergeNodes);\n        add(toolsMenu, joinNodeWay);\n        add(toolsMenu, unglueNodes);\n        toolsMenu.addSeparator();\n        add(toolsMenu, historyinfo);\n        add(toolsMenu, KeyEvent.VK_T, \"tools\");\n\n        add(presetsMenu, KeyEvent.VK_P, \"presets\");\n\n        if (!Main.pref.getBoolean(\"audio.menuinvisible\")) {\n            add(audioMenu, audioPlayPause);\n            add(audioMenu, audioNext);\n            add(audioMenu, audioPrev);\n            add(audioMenu, audioFwd);\n            add(audioMenu, audioBack);\n            add(audioMenu, audioSlower);\n            add(audioMenu, audioFaster);\n            add(audioMenu, KeyEvent.VK_A, \"audio\");\n        }\n\n\t\t/* TODO: Anyone really using this feature? */\n        /*JMenuItem check = new JMenuItem(\"DEBUG: Check Dataset\");\n        check.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                DataSetChecker.check();\n            }\n        });\n        helpMenu.add(check);*/\n        current = helpMenu.add(help); // why is help not a JosmAction?\n        current.setAccelerator(Shortcut.registerShortcut(\"system:help\", tr(\"Help\"), KeyEvent.VK_F1,\n                Shortcut.GROUP_DIRECT).getKeyStroke());\n        add(helpMenu, about);\n        add(helpMenu, KeyEvent.VK_H, \"help\");\n    }","id":24474,"modified_method":"public MainMenu() {\n        JMenuItem current;\n\n        add(fileMenu, newAction);\n        add(fileMenu, openFile);\n        add(fileMenu, openLocation);\n        fileMenu.addSeparator();\n        add(fileMenu, save);\n        add(fileMenu, saveAs);\n        add(fileMenu, gpxExport);\n        fileMenu.addSeparator();\n        add(fileMenu, download);\n        add(fileMenu, upload);\n        fileMenu.addSeparator();\n        add(fileMenu, exit);\n        add(fileMenu, KeyEvent.VK_F, \"file\");\n\n        add(editMenu, undo);\n        add(editMenu, redo);\n        editMenu.addSeparator();\n        add(editMenu, copy);\n        add(editMenu, paste);\n        add(editMenu, pasteTags);\n        add(editMenu, duplicate);\n        add(editMenu, delete);\n        editMenu.addSeparator();\n        add(editMenu, selectAll);\n        add(editMenu, unselectAll);\n        editMenu.addSeparator();\n        add(editMenu, search);\n        editMenu.addSeparator();\n        add(editMenu, preferences);\n        add(editMenu, KeyEvent.VK_E, \"edit\");\n\n        // TODO move code to an \"action\" like the others?\n        final JCheckBoxMenuItem wireframe = new JCheckBoxMenuItem(tr(\"Wireframe View\"));\n        wireframe.setSelected(Main.pref.getBoolean(\"draw.wireframe\", false));\n        wireframe.setAccelerator(Shortcut.registerShortcut(\"menu:view:wireframe\", tr(\"Toggle Wireframe view\"),\n                KeyEvent.VK_W, Shortcut.GROUP_MENU).getKeyStroke());\n        wireframe.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent ev) {\n                Main.pref.put(\"draw.wireframe\", wireframe.isSelected());\n                if (Main.map != null) {\n                    Main.map.mapView.repaint();\n                }\n            }\n        });\n        viewMenu.add(wireframe);\n        viewMenu.addSeparator();\n        add(viewMenu, new ZoomInAction());\n        add(viewMenu, new ZoomOutAction());\n        viewMenu.addSeparator();\n        for (String mode : AutoScaleAction.modes) {\n            JosmAction autoScaleAction = new AutoScaleAction(mode);\n            add(viewMenu, autoScaleAction);\n        }\n        add(viewMenu, KeyEvent.VK_V, \"view\");\n\n        add(toolsMenu, splitWay);\n        add(toolsMenu, combineWay);\n        toolsMenu.addSeparator();\n        add(toolsMenu, reverseWay);\n        toolsMenu.addSeparator();\n        add(toolsMenu, alignInCircle);\n        add(toolsMenu, alignInLine);\n        add(toolsMenu, ortho);\n        toolsMenu.addSeparator();\n        add(toolsMenu, addnode);\n        add(toolsMenu, createCircle);\n        toolsMenu.addSeparator();\n        add(toolsMenu, mergeNodes);\n        add(toolsMenu, joinNodeWay);\n        add(toolsMenu, unglueNodes);\n        toolsMenu.addSeparator();\n        add(toolsMenu, historyinfo);\n        add(toolsMenu, KeyEvent.VK_T, \"tools\");\n\n        add(presetsMenu, KeyEvent.VK_P, \"presets\");\n\n        if (!Main.pref.getBoolean(\"audio.menuinvisible\", false)) {\n            add(audioMenu, audioPlayPause);\n            add(audioMenu, audioNext);\n            add(audioMenu, audioPrev);\n            add(audioMenu, audioFwd);\n            add(audioMenu, audioBack);\n            add(audioMenu, audioSlower);\n            add(audioMenu, audioFaster);\n            add(audioMenu, KeyEvent.VK_A, \"audio\");\n        }\n\n\t\t/* TODO: Anyone really using this feature? */\n        /*JMenuItem check = new JMenuItem(\"DEBUG: Check Dataset\");\n        check.addActionListener(new ActionListener() {\n            public void actionPerformed(ActionEvent e) {\n                DataSetChecker.check();\n            }\n        });\n        helpMenu.add(check);*/\n        current = helpMenu.add(help); // why is help not a JosmAction?\n        current.setAccelerator(Shortcut.registerShortcut(\"system:help\", tr(\"Help\"), KeyEvent.VK_F1,\n                Shortcut.GROUP_DIRECT).getKeyStroke());\n        add(helpMenu, about);\n        add(helpMenu, KeyEvent.VK_H, \"help\");\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected InputStream getInputStreamRaw(String urlStr, PleaseWaitDialog pleaseWaitDlg) throws IOException {\n\n        System.out.println(\"download: \"+urlStr);\n        initAuthentication();\n        URL url = new URL(urlStr);\n        activeConnection = (HttpURLConnection)url.openConnection();\n        if (cancel) {\n            activeConnection.disconnect();\n            return null;\n        }\n\n        if (Boolean.parseBoolean(Main.pref.get(\"osm-server.use-compression\", \"true\")))\n            activeConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n\n        activeConnection.setConnectTimeout(15000);\n        if (isAuthCancelled() && activeConnection.getResponseCode() == 401)\n            return null;\n        if (activeConnection.getResponseCode() == 500)\n        {\n            throw new IOException(tr(\"Server returned internal error. Try a reduced area or retry after waiting some time.\"));\n        }\n//      System.out.println(\"got return: \"+activeConnection.getResponseCode());\n\n        String encoding = activeConnection.getContentEncoding();\n        InputStream inputStream = new ProgressInputStream(activeConnection, pleaseWaitDlg);\n        if (encoding != null && encoding.equalsIgnoreCase(\"gzip\")) {\n            inputStream = new GZIPInputStream(inputStream);\n        }\n        else if (encoding != null && encoding.equalsIgnoreCase(\"deflate\")) {\n            inputStream = new InflaterInputStream(inputStream, new Inflater(true));\n        }\n        return inputStream;\n    }","id":24475,"modified_method":"protected InputStream getInputStreamRaw(String urlStr, PleaseWaitDialog pleaseWaitDlg) throws IOException {\n\n        System.out.println(\"download: \"+urlStr);\n        initAuthentication();\n        URL url = new URL(urlStr);\n        activeConnection = (HttpURLConnection)url.openConnection();\n        if (cancel) {\n            activeConnection.disconnect();\n            return null;\n        }\n\n        if (Main.pref.getBoolean(\"osm-server.use-compression\", true))\n            activeConnection.setRequestProperty(\"Accept-Encoding\", \"gzip, deflate\");\n\n        activeConnection.setConnectTimeout(15000);\n        if (isAuthCancelled() && activeConnection.getResponseCode() == 401)\n            return null;\n        if (activeConnection.getResponseCode() == 500)\n        {\n            throw new IOException(tr(\"Server returned internal error. Try a reduced area or retry after waiting some time.\"));\n        }\n//      System.out.println(\"got return: \"+activeConnection.getResponseCode());\n\n        String encoding = activeConnection.getContentEncoding();\n        InputStream inputStream = new ProgressInputStream(activeConnection, pleaseWaitDlg);\n        if (encoding != null && encoding.equalsIgnoreCase(\"gzip\")) {\n            inputStream = new GZIPInputStream(inputStream);\n        }\n        else if (encoding != null && encoding.equalsIgnoreCase(\"deflate\")) {\n            inputStream = new InflaterInputStream(inputStream, new Inflater(true));\n        }\n        return inputStream;\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"synchronized public boolean put(final String key, String value) {\n        String oldvalue = properties.get(key);\n        if(value != null && value.length() == 0)\n            value = null;\n        if(!((oldvalue == null && value == null) || (value != null\n        && oldvalue != null && oldvalue.equals(value))))\n        {\n            if (value == null)\n                properties.remove(key);\n            else\n                properties.put(key, value);\n            save();\n            firePreferenceChanged(key, value);\n            return true;\n        }\n        return false;\n    }","id":24476,"modified_method":"synchronized public boolean put(final String key, String value) {\n        String oldvalue = properties.get(key);\n        if(value != null && value.length() == 0)\n            value = null;\n        if(!((oldvalue == null && value == null) || (value != null\n        && oldvalue != null && oldvalue.equals(value))))\n        {\n            if (value == null)\n                properties.remove(key);\n            else\n                properties.put(key, value);\n            String s = defaults.get(key);\n            if(s == null || !s.equals(value))\n                save();\n            firePreferenceChanged(key, value);\n            return true;\n        }\n        return false;\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"public final void resetToDefault() {\n        properties.clear();\n        properties.put(\"projection\", \"org.openstreetmap.josm.data.projection.Epsg4326\");\n        properties.put(\"draw.segment.direction\", \"true\");\n        properties.put(\"draw.wireframe\", \"false\");\n        properties.put(\"layerlist.visible\", \"true\");\n        properties.put(\"propertiesdialog.visible\", \"true\");\n        properties.put(\"selectionlist.visible\", \"true\");\n        properties.put(\"commandstack.visible\", \"true\");\n        properties.put(\"osm-server.url\", \"http://www.openstreetmap.org/api\");\n        if (System.getProperty(\"os.name\").toUpperCase().indexOf(\"WINDOWS\") == -1) {\n            properties.put(\"laf\", \"javax.swing.plaf.metal.MetalLookAndFeel\");\n        } else {\n            properties.put(\"laf\", \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n        }\n        save();\n    }","id":24477,"modified_method":"public final void resetToDefault() {\n        properties.clear();\n        put(\"layerlist.visible\", true);\n        put(\"propertiesdialog.visible\", true);\n        put(\"selectionlist.visible\", true);\n        put(\"commandstack.visible\", true);\n        put(\"osm-server.url\", \"http://www.openstreetmap.org/api\");\n        if (System.getProperty(\"os.name\").toUpperCase().indexOf(\"WINDOWS\") == -1) {\n            put(\"laf\", \"javax.swing.plaf.metal.MetalLookAndFeel\");\n        } else {\n            put(\"laf\", \"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n        }\n        save();\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Called after every put. In case of a problem, do nothing but output the error\n     * in log.\n     */\n    public void save() {\n        try {\n            setSystemProperties();\n            final PrintWriter out = new PrintWriter(new FileWriter(getPreferencesDir() + \"preferences\"), false);\n            for (final Entry<String, String> e : properties.entrySet()) {\n                out.println(e.getKey() + \"=\" + e.getValue());\n            }\n            out.close();\n        } catch (final IOException e) {\n            e.printStackTrace();\n            // do not message anything, since this can be called from strange\n            // places.\n        }\n    }","id":24478,"modified_method":"/**\n     * Called after every put. In case of a problem, do nothing but output the error\n     * in log.\n     */\n    public void save() {\n        /* currently unused, but may help to fix configuration issues in future */\n        properties.put(\"josm.version\", AboutAction.getVersionString());\n        try {\n            setSystemProperties();\n            final PrintWriter out = new PrintWriter(new FileWriter(getPreferencesDir() + \"preferences\"), false);\n            for (final Entry<String, String> e : properties.entrySet()) {\n                String s = defaults.get(e.getKey());\n                /* don't save default values */\n                if(s == null || !s.equals(e.getValue()))\n                    out.println(e.getKey() + \"=\" + e.getValue());\n            }\n            out.close();\n        } catch (final IOException e) {\n            e.printStackTrace();\n            // do not message anything, since this can be called from strange\n            // places.\n        }\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void getSettings(Boolean virtual) {\n        showDirectionArrow = Main.pref.getBoolean(\"draw.segment.direction\");\n        showRelevantDirectionsOnly = Main.pref.getBoolean(\"draw.segment.relevant_directions_only\", true);\n        showOrderNumber = Main.pref.getBoolean(\"draw.segment.order_number\");\n        selectedNodeRadius = Main.pref.getInteger(\"mappaint.node.selected-size\", 5) / 2;\n        selectedNodeSize = selectedNodeRadius * 2;\n        unselectedNodeRadius = Main.pref.getInteger(\"mappaint.node.unselected-size\", 3) / 2;\n        unselectedNodeSize = unselectedNodeRadius * 2;\n        taggedNodeRadius = Main.pref.getInteger(\"mappaint.node.tagged-size\", 5) / 2;\n        taggedNodeSize = taggedNodeRadius * 2;\n        defaultSegmentWidth = Main.pref.getInteger(\"mappaint.segment.default-width\", 2);\n        fillSelectedNode = Main.pref.getBoolean(\"mappaint.node.fill-selected\", true);\n        fillUnselectedNode = Main.pref.getBoolean(\"mappaint.node.fill-unselected\", false);\n        virtualNodeSize = virtual ? Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) / 2 : 0;\n        virtualNodeSpace = Main.pref.getInteger(\"mappaint.node.virtual-space\", 70);\n        segmentNumberSpace = Main.pref.getInteger(\"mappaint.segmentnumber.space\", 40);\n\n        ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n            Main.pref.getBoolean(\"mappaint.use-antialiasing\", false) ?\n            RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);\n    }","id":24479,"modified_method":"protected void getSettings(Boolean virtual) {\n        showDirectionArrow = Main.pref.getBoolean(\"draw.segment.direction\", true);\n        showRelevantDirectionsOnly = Main.pref.getBoolean(\"draw.segment.relevant_directions_only\", true);\n        showOrderNumber = Main.pref.getBoolean(\"draw.segment.order_number\", false);\n        selectedNodeRadius = Main.pref.getInteger(\"mappaint.node.selected-size\", 5) / 2;\n        selectedNodeSize = selectedNodeRadius * 2;\n        unselectedNodeRadius = Main.pref.getInteger(\"mappaint.node.unselected-size\", 3) / 2;\n        unselectedNodeSize = unselectedNodeRadius * 2;\n        taggedNodeRadius = Main.pref.getInteger(\"mappaint.node.tagged-size\", 5) / 2;\n        taggedNodeSize = taggedNodeRadius * 2;\n        defaultSegmentWidth = Main.pref.getInteger(\"mappaint.segment.default-width\", 2);\n        fillSelectedNode = Main.pref.getBoolean(\"mappaint.node.fill-selected\", true);\n        fillUnselectedNode = Main.pref.getBoolean(\"mappaint.node.fill-unselected\", false);\n        virtualNodeSize = virtual ? Main.pref.getInteger(\"mappaint.node.virtual-size\", 8) / 2 : 0;\n        virtualNodeSpace = Main.pref.getInteger(\"mappaint.node.virtual-space\", 70);\n        segmentNumberSpace = Main.pref.getInteger(\"mappaint.segmentnumber.space\", 40);\n\n        ((Graphics2D)g).setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n            Main.pref.getBoolean(\"mappaint.use-antialiasing\", false) ?\n            RenderingHints.VALUE_ANTIALIAS_ON : RenderingHints.VALUE_ANTIALIAS_OFF);\n    }","commit_id":"194a0ddd821d842798521af0fb363d18ac165e4d","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n   *\n   * @param token The access token to be validated.\n   * @return The state after validation\n   */\n  @Override\n  public State validate(String token) {\n    AccessToken accessToken;\n    State state = State.TOKEN_VALID;\n    if (token == null) {\n      LOG.debug(\"Token is missing\");\n      return State.TOKEN_MISSING;\n    }\n    byte[] decodedToken = Base64.decodeBase64(token);\n\n    try {\n      accessToken = accessTokenCodec.decode(decodedToken);\n      tokenManager.validateSecret(accessToken);\n    } catch (IOException ioe) {\n      state = State.TOKEN_BROKEN;\n      LOG.debug(state.getMsg());\n      return State.TOKEN_INVALID;\n    } catch (InvalidTokenException ite) {\n        InvalidTokenException.Reason reason = ite.getReason();\n        switch(reason) {\n          case INVALID:\n            state = State.TOKEN_INVALID;\n            break;\n          case EXPIRED:\n            state = State.TOKEN_EXPIRED;\n            break;\n          case INTERNAL:\n            state = State.TOKEN_INTERNAL;\n            break;\n        }\n        LOG.debug(state.getMsg());\n    }\n    return state;\n  }","id":24480,"modified_method":"/**\n   *\n   * @param token The access token to be validated.\n   * @return The state after validation\n   */\n  @Override\n  public State validate(String token) {\n    AccessToken accessToken;\n    State state = State.TOKEN_VALID;\n    if (token == null) {\n      LOG.debug(\"Token is missing\");\n      return State.TOKEN_MISSING;\n    }\n    byte[] decodedToken = Base64.decodeBase64(token);\n\n    try {\n      accessToken = accessTokenCodec.decode(decodedToken);\n      tokenManager.validateSecret(accessToken);\n    } catch (IOException ioe) {\n      state = State.TOKEN_INVALID;\n      LOG.debug(\"Unknown Schema version for Access Token.\");\n    } catch (InvalidTokenException ite) {\n        InvalidTokenException.Reason reason = ite.getReason();\n        switch(reason) {\n          case INVALID:\n            state = State.TOKEN_INVALID;\n            break;\n          case EXPIRED:\n            state = State.TOKEN_EXPIRED;\n            break;\n          case INTERNAL:\n            state = State.TOKEN_INTERNAL;\n            break;\n        }\n        LOG.debug(state.getMsg());\n    }\n    return state;\n  }","commit_id":"a619bb0e5c96ae37e68fdca8348de7d7d47c6ca7","url":"https://github.com/caskdata/cdap"},{"original_method":"private void openOutboundAndWrite(MessageEvent e) throws Exception {\n    final HttpRequest msg = (HttpRequest) e.getMessage();\n\n    // Suspend incoming traffic until connected to the outbound service.\n    final Channel inboundChannel = e.getChannel();\n    inboundChannel.setReadable(false);\n\n    String auth = msg.getHeader(HttpHeaders.Names.AUTHORIZATION);\n    String path = msg.getUri();\n    String host = msg.getHeader(HttpHeaders.Names.HOST);\n    String httpMethod = msg.getMethod().getName();\n    String accessToken = null;\n\n    if (auth != null) {\n      String[] fragments = auth.split(\"\\\\s+\");\n      if (fragments.length > 1) {\n        accessToken = fragments[1];\n      }\n    }\n    //Decoding the header\n    final HeaderInfo headerInfo = new HeaderInfo(path, host, httpMethod);\n\n    if (securityEnabled) {\n      TokenValidator.State tokenState = tokenValidator.validate(accessToken);\n      HttpResponse httpResponse = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.UNAUTHORIZED);\n      switch (tokenState) {\n        case TOKEN_MISSING:\n          httpResponse.addHeader(HttpHeaders.Names.WWW_AUTHENTICATE, \"Bearer realm=\\\"\" + realm + \"\\\"\");\n          httpResponse.setHeader(HttpHeaders.Names.CONTENT_LENGTH, 0);\n          break;\n\n        case TOKEN_INVALID:\n        case TOKEN_EXPIRED:\n        case TOKEN_INTERNAL:\n        case TOKEN_BROKEN:\n          httpResponse.addHeader(HttpHeaders.Names.WWW_AUTHENTICATE, \"Bearer realm=\\\"\" + realm + \"\\\"\" +\n            \"  error=\\\"invalid_token\\\"\" +\n            \"  error_description=\\\"\" + tokenState.getMsg() + \"\\\"\");\n          httpResponse.setHeader(HttpHeaders.Names.CONTENT_LENGTH, 0);\n          break;\n      }\n      if (tokenState != TokenValidator.State.TOKEN_VALID) {\n        inboundChannel.getPipeline().addLast(\"encoder\", new HttpResponseEncoder());\n        e.getChannel().write(httpResponse).addListener(ChannelFutureListener.CLOSE);\n        return;\n      }\n    }\n\n    // Discover endpoint.\n    int inboundPort = ((InetSocketAddress) inboundChannel.getLocalAddress()).getPort();\n    Discoverable discoverable = serviceLookup.getDiscoverable(inboundPort, new Supplier<HeaderInfo>() {\n      @Override\n      public HeaderInfo get() {\n        return headerInfo;\n      }\n    });\n\n    if (discoverable == null) {\n      inboundChannel.close();\n      return;\n    }\n\n    // Connect to outbound service.\n    final InetSocketAddress address = discoverable.getSocketAddress();\n    LOG.trace(\"Opening connection from {} to {} for {}\",\n              inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n    ChannelFuture outFuture = clientBootstrap.connect(address);\n\n    outboundChannel = outFuture.getChannel();\n    outFuture.addListener(new ChannelFutureListener() {\n      public void operationComplete(ChannelFuture future) throws Exception {\n        if (future.isSuccess()) {\n\n          outboundChannel.getPipeline().addLast(\"outbound-handler\", new OutboundHandler(inboundChannel));\n\n          // the decoder is added after Outboundhandler in the pipeline as it is a downstream channel\n          outboundChannel.getPipeline().addLast(\"HttpRequestEncoder\", new HttpRequestEncoder());\n\n          // Write the message to outBoundChannel.\n          outboundChannel.write(msg);\n\n          // Begin to accept incoming traffic.\n          inboundChannel.setReadable(true);\n          LOG.trace(\"Connection opened from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n        } else {\n          // Close the connection if the connection attempt has failed.\n          inboundChannel.close();\n          LOG.trace(\"Failed to open connection from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress(), future.getCause());\n        }\n      }\n    });\n  }","id":24481,"modified_method":"private void openOutboundAndWrite(MessageEvent e) throws Exception {\n    final HttpRequest msg = (HttpRequest) e.getMessage();\n\n    // Suspend incoming traffic until connected to the outbound service.\n    final Channel inboundChannel = e.getChannel();\n    inboundChannel.setReadable(false);\n\n    String auth = msg.getHeader(HttpHeaders.Names.AUTHORIZATION);\n    String path = msg.getUri();\n    String host = msg.getHeader(HttpHeaders.Names.HOST);\n    String httpMethod = msg.getMethod().getName();\n    String accessToken = null;\n\n    if (auth != null) {\n      String[] fragments = auth.split(\"\\\\s+\");\n      if (fragments.length > 1) {\n        accessToken = fragments[1];\n      }\n    }\n    //Decoding the header\n    final HeaderInfo headerInfo = new HeaderInfo(path, host, httpMethod);\n\n    if (securityEnabled) {\n      TokenValidator.State tokenState = tokenValidator.validate(accessToken);\n      HttpResponse httpResponse = new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.UNAUTHORIZED);\n      switch (tokenState) {\n        case TOKEN_MISSING:\n          httpResponse.addHeader(HttpHeaders.Names.WWW_AUTHENTICATE, \"Bearer realm=\\\"\" + realm + \"\\\"\");\n          httpResponse.setHeader(HttpHeaders.Names.CONTENT_LENGTH, 0);\n          break;\n\n        case TOKEN_INVALID:\n        case TOKEN_EXPIRED:\n        case TOKEN_INTERNAL:\n          httpResponse.addHeader(HttpHeaders.Names.WWW_AUTHENTICATE, \"Bearer realm=\\\"\" + realm + \"\\\"\" +\n            \"  error=\\\"invalid_token\\\"\" +\n            \"  error_description=\\\"\" + tokenState.getMsg() + \"\\\"\");\n          httpResponse.setHeader(HttpHeaders.Names.CONTENT_LENGTH, 0);\n          break;\n      }\n      if (tokenState != TokenValidator.State.TOKEN_VALID) {\n        inboundChannel.getPipeline().addLast(\"encoder\", new HttpResponseEncoder());\n        e.getChannel().write(httpResponse).addListener(ChannelFutureListener.CLOSE);\n        return;\n      }\n    }\n\n    // Discover endpoint.\n    int inboundPort = ((InetSocketAddress) inboundChannel.getLocalAddress()).getPort();\n    Discoverable discoverable = serviceLookup.getDiscoverable(inboundPort, new Supplier<HeaderInfo>() {\n      @Override\n      public HeaderInfo get() {\n        return headerInfo;\n      }\n    });\n\n    if (discoverable == null) {\n      inboundChannel.close();\n      return;\n    }\n\n    // Connect to outbound service.\n    final InetSocketAddress address = discoverable.getSocketAddress();\n    LOG.trace(\"Opening connection from {} to {} for {}\",\n              inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n    ChannelFuture outFuture = clientBootstrap.connect(address);\n\n    outboundChannel = outFuture.getChannel();\n    outFuture.addListener(new ChannelFutureListener() {\n      public void operationComplete(ChannelFuture future) throws Exception {\n        if (future.isSuccess()) {\n\n          outboundChannel.getPipeline().addLast(\"outbound-handler\", new OutboundHandler(inboundChannel));\n\n          // the decoder is added after Outboundhandler in the pipeline as it is a downstream channel\n          outboundChannel.getPipeline().addLast(\"HttpRequestEncoder\", new HttpRequestEncoder());\n\n          // Write the message to outBoundChannel.\n          outboundChannel.write(msg);\n\n          // Begin to accept incoming traffic.\n          inboundChannel.setReadable(true);\n          LOG.trace(\"Connection opened from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress());\n        } else {\n          // Close the connection if the connection attempt has failed.\n          inboundChannel.close();\n          LOG.trace(\"Failed to open connection from {} to {} for {}\",\n                    inboundChannel.getLocalAddress(), address, inboundChannel.getRemoteAddress(), future.getCause());\n        }\n      }\n    });\n  }","commit_id":"a619bb0e5c96ae37e68fdca8348de7d7d47c6ca7","url":"https://github.com/caskdata/cdap"},{"original_method":"public static void readFromPreferences() {\n        /* don't prefix icon path, as it should be generic */\n        String internalicon = \"resource://images/styles/standard/;resource://images/styles/\";\n        String internalfile = \"standard=resource://styles/standard/elemstyles.xml\";\n\n        iconDirs = Main.pref.get(\"mappaint.iconpaths\");\n        iconDirs = iconDirs == null || iconDirs.length() == 0 ? internalicon : iconDirs + \";\" + internalicon;\n\n        String file = Main.pref.get(\"mappaint.sources\");\n        file = file == null || file.length() == 0 ? internalfile : internalfile + \";\" + file;\n\n        for(String fileset : file.split(\";\"))\n        {\n            try\n            {\n                String[] a;\n                if(fileset.indexOf(\"=\") >= 0)\n                    a = fileset.split(\"=\", 2);\n                else\n                    a = new String[] {\"standard\", fileset};\n                XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n                ElemStyleHandler handler = new ElemStyleHandler(a[0]);\n                xmlReader.setContentHandler(handler);\n                xmlReader.setErrorHandler(handler);\n                xmlReader.parse(new InputSource(new MirroredInputStream(a[1])));\n            }\n            catch (Exception e)\n            {\n                System.out.println(\"Mappaint-Style problems: \\\"\" + fileset + \"\\\"\");\n            }\n        }\n        iconDirs = null;\n    }","id":24482,"modified_method":"public static void readFromPreferences() {\n        String[] a = null;\n        \n        /* don't prefix icon path, as it should be generic */\n        String internalicon = \"resource://images/styles/standard/;resource://images/styles/\";\n        String internalfile = \"standard=resource://styles/standard/elemstyles.xml\";\n\n        iconDirs = Main.pref.get(\"mappaint.icon.sources\");\n        if(Main.pref.getBoolean(\"mappaint.icon.enable-defaults\", true))\n            iconDirs = iconDirs == null || iconDirs.length() == 0 ? internalicon : iconDirs + \";\" + internalicon;\n\n        String file = Main.pref.get(\"mappaint.style.sources\");\n        if(Main.pref.getBoolean(\"mappaint.style.enable-defaults\", true))\n            file = (file == null || file.length() == 0) ? internalfile : internalfile + \";\" + file;\n\n        for(String fileset : file.split(\";\"))\n        {\n            try\n            {\n                if(fileset.indexOf(\"=\") >= 0)\n                    a = fileset.split(\"=\", 2);\n                else\n                    a = new String[] {\"standard\", fileset};\n                XMLReader xmlReader = XMLReaderFactory.createXMLReader();\n                ElemStyleHandler handler = new ElemStyleHandler(a[0]);\n                xmlReader.setContentHandler(handler);\n                xmlReader.setErrorHandler(handler);\n                xmlReader.parse(new InputSource(new MirroredInputStream(a[1])));\n            }\n            catch (Exception e)\n            {\n                System.out.println(\"Mappaint-Style \\\"\" + a[0] + \"\\\" file \\\"\" + a[1] + \"\\\"\");\n                System.out.println(\"Mappaint-Style problems: \" + e);\n            }\n        }\n        iconDirs = null;\n    }","commit_id":"b1aa1f7c08bb446c444a135828a81fd30cdc0401","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void addTerms(\n\t\t\tString[] fields, Map<String, List<String>> termFieldsValuesMap)\n\t\tthrows ParseException {\n\n\t\tfor (String field : fields) {\n\t\t\tList<String> valuesList = termFieldsValuesMap.get(field);\n\n\t\t\tfor (String value : valuesList) {\n\t\t\t\taddTerm(field, value);\n\t\t\t}\n\t\t}\n\t}","id":24483,"modified_method":"protected Map<String, List<Query>> addTerms(\n\t\t\tString[] fields, Map<String, List<String>> termFieldsValuesMap)\n\t\tthrows ParseException {\n\n\t\tMap<String, List<Query>> queries = new HashMap<>(\n\t\t\t(int)(fields.length / .75));\n\n\t\tfor (String field : fields) {\n\t\t\tList<String> valuesList = termFieldsValuesMap.get(field);\n\n\t\t\tList<Query> queryList = new ArrayList<>(valuesList.size());\n\n\t\t\tqueries.put(field, queryList);\n\n\t\t\tfor (String value : valuesList) {\n\t\t\t\tQuery query = addTerm(field, value);\n\n\t\t\t\tqueryList.add(query);\n\t\t\t}\n\t\t}\n\n\t\treturn queries;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerms(String[] fields, String values) throws ParseException {\n\t\tif (Validator.isNull(values)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (fields == null) {\n\t\t\tfields = new String[0];\n\t\t}\n\n\t\tfor (String field : fields) {\n\t\t\taddTerm(field, values);\n\t\t}\n\t}","id":24484,"modified_method":"@Override\n\tpublic Map<String, Query> addTerms(String[] fields, String values)\n\t\tthrows ParseException {\n\n\t\tif (Validator.isNull(values)) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\n\t\tif (fields == null) {\n\t\t\tfields = new String[0];\n\t\t}\n\n\t\tMap<String, Query> queries = new HashMap<>((int)(fields.length / .75));\n\n\t\tfor (String field : fields) {\n\t\t\tQuery query = addTerm(field, values);\n\n\t\t\tqueries.put(field, query);\n\t\t}\n\n\t\treturn queries;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerms(String[] fields, String value, boolean like)\n\t\tthrows ParseException {\n\n\t\tif (Validator.isNull(value)) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (String field : fields) {\n\t\t\taddTerm(field, value, like);\n\t\t}\n\t}","id":24485,"modified_method":"@Override\n\tpublic Map<String, Query> addTerms(\n\t\t\tString[] fields, String value, boolean like)\n\t\tthrows ParseException {\n\n\t\tif (Validator.isNull(value)) {\n\t\t\treturn Collections.emptyMap();\n\t\t}\n\n\t\tMap<String, Query> queries = new HashMap<>((int)(fields.length / .75));\n\n\t\tfor (String field : fields) {\n\t\t\tQuery query = addTerm(field, value, like);\n\n\t\t\tqueries.put(field, query);\n\t\t}\n\n\t\treturn queries;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, int startValue, int endValue) {\n\n\t\tfor (int i = startValue; i <= endValue; i++) {\n\t\t\taddExactTerm(field, i);\n\t\t}\n\t}","id":24486,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, int startValue, int endValue) {\n\n\t\tList<Query> queries = new ArrayList<>();\n\n\t\tfor (int i = startValue; i <= endValue; i++) {\n\t\t\tQuery query = addExactTerm(field, i);\n\n\t\t\tqueries.add(query);\n\t\t}\n\n\t\treturn queries;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Integer value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24487,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Integer value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, int value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24488,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, int value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Boolean value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24489,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Boolean value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, String value, boolean like) {\n\t\taddRequiredTerm(field, value, like, false);\n\t}","id":24490,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, String value, boolean like) {\n\t\treturn addRequiredTerm(field, value, like, false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Double value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24491,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Double value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, double value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24492,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, double value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Long value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24493,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Long value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Double value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24494,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Double value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Integer value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24495,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Integer value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addRequiredTerm(\n\t\tString field, String value, boolean like, boolean parseKeywords) {\n\n\t\tif (like) {\n\t\t\tvalue = StringUtil.replace(\n\t\t\t\tvalue, StringPool.PERCENT, StringPool.BLANK);\n\t\t}\n\n\t\tString[] values = null;\n\n\t\tif (parseKeywords) {\n\t\t\tvalues = parseKeywords(value);\n\t\t}\n\t\telse {\n\t\t\tvalues = new String[] {value};\n\t\t}\n\n\t\tBooleanQuery booleanQuery = new BooleanQueryImpl();\n\n\t\tfor (String curValue : values) {\n\t\t\tQueryTerm queryTerm = new QueryTermImpl(\n\t\t\t\tfield, String.valueOf(curValue));\n\n\t\t\tQuery query = null;\n\n\t\t\tif (like) {\n\t\t\t\tquery = new WildcardQueryImpl(queryTerm);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery = new TermQueryImpl(queryTerm);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tbooleanQuery.add(query, BooleanClauseOccur.SHOULD);\n\t\t\t}\n\t\t\tcatch (ParseException pe) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"ParseException thrown, skipping query\", pe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tadd(booleanQuery, BooleanClauseOccur.MUST);\n\t}","id":24496,"modified_method":"public Query addRequiredTerm(\n\t\tString field, String value, boolean like, boolean parseKeywords) {\n\n\t\tif (like) {\n\t\t\tvalue = StringUtil.replace(\n\t\t\t\tvalue, StringPool.PERCENT, StringPool.BLANK);\n\t\t}\n\n\t\tString[] values = null;\n\n\t\tif (parseKeywords) {\n\t\t\tvalues = parseKeywords(value);\n\t\t}\n\t\telse {\n\t\t\tvalues = new String[] {value};\n\t\t}\n\n\t\tBooleanQuery booleanQuery = new BooleanQueryImpl();\n\n\t\tfor (String curValue : values) {\n\t\t\tQueryTerm queryTerm = new QueryTermImpl(\n\t\t\t\tfield, String.valueOf(curValue));\n\n\t\t\tQuery query = null;\n\n\t\t\tif (like) {\n\t\t\t\tquery = new WildcardQueryImpl(queryTerm);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tquery = new TermQueryImpl(queryTerm);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tbooleanQuery.add(query, BooleanClauseOccur.SHOULD);\n\t\t\t}\n\t\t\tcatch (ParseException pe) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\"ParseException thrown, skipping query\", pe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn add(booleanQuery, BooleanClauseOccur.MUST);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, long startValue, long endValue) {\n\t\tTermRangeQuery termRangeQuery = new TermRangeQueryImpl(\n\t\t\tfield, String.valueOf(startValue), String.valueOf(endValue), true,\n\t\t\ttrue);\n\n\t\tadd(termRangeQuery, BooleanClauseOccur.SHOULD);\n\t}","id":24497,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, long startValue, long endValue) {\n\t\tTermRangeQuery termRangeQuery = new TermRangeQueryImpl(\n\t\t\tfield, String.valueOf(startValue), String.valueOf(endValue), true,\n\t\t\ttrue);\n\n\t\treturn add(termRangeQuery, BooleanClauseOccur.SHOULD);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, String value) {\n\t\tTermQueryImpl termQuery = new TermQueryImpl(\n\t\t\tnew QueryTermImpl(field, String.valueOf(value)));\n\n\t\tadd(termQuery, BooleanClauseOccur.SHOULD);\n\t}","id":24498,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, String value) {\n\t\tTermQueryImpl termQuery = new TermQueryImpl(\n\t\t\tnew QueryTermImpl(field, String.valueOf(value)));\n\n\t\treturn add(termQuery, BooleanClauseOccur.SHOULD);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Short value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24499,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Short value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, short value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24500,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, short value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, boolean value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24501,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, boolean value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, Short startValue, Short endValue) {\n\t\taddRangeTerm(field, startValue.shortValue(), endValue.shortValue());\n\t}","id":24502,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, Short startValue, Short endValue) {\n\t\treturn addRangeTerm(\n\t\t\tfield, startValue.shortValue(), endValue.shortValue());\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, short value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24503,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, short value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Short value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24504,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Short value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, short startValue, short endValue) {\n\n\t\tfor (short i = startValue; i <= endValue; i++) {\n\t\t\taddExactTerm(field, i);\n\t\t}\n\t}","id":24505,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, short startValue, short endValue) {\n\n\t\tList<Query> queries = new ArrayList<>();\n\n\t\tfor (short i = startValue; i <= endValue; i++) {\n\t\t\tQuery query = addExactTerm(field, i);\n\n\t\t\tqueries.add(query);\n\t\t}\n\n\t\treturn queries;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, Short startValue, Short endValue) {\n\n\t\taddNumericRangeTerm(\n\t\t\tfield, startValue.shortValue(), endValue.shortValue());\n\t}","id":24506,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, Short startValue, Short endValue) {\n\n\t\treturn addNumericRangeTerm(\n\t\t\tfield, startValue.shortValue(), endValue.shortValue());\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, Long startValue, Long endValue) {\n\n\t\taddNumericRangeTerm(\n\t\t\tfield, startValue.longValue(), endValue.longValue());\n\t}","id":24507,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, Long startValue, Long endValue) {\n\n\t\treturn addNumericRangeTerm(\n\t\t\tfield, startValue.longValue(), endValue.longValue());\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, Integer startValue, Integer endValue) {\n\n\t\taddNumericRangeTerm(field, startValue.intValue(), endValue.intValue());\n\t}","id":24508,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, Integer startValue, Integer endValue) {\n\n\t\treturn addNumericRangeTerm(\n\t\t\tfield, startValue.intValue(), endValue.intValue());\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Long value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24509,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Long value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerm(String field, String value) {\n\t\taddTerm(field, value, false);\n\t}","id":24510,"modified_method":"@Override\n\tpublic Query addTerm(String field, String value) {\n\t\treturn addTerm(field, value, false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void add(Query query, String occur) {\n\t\tBooleanClauseOccur booleanClauseOccur = new BooleanClauseOccurImpl(\n\t\t\toccur);\n\n\t\tadd(query, booleanClauseOccur);\n\t}","id":24511,"modified_method":"@Override\n\tpublic Query add(Query query, String occur) {\n\t\tBooleanClauseOccur booleanClauseOccur = new BooleanClauseOccurImpl(\n\t\t\toccur);\n\n\t\tadd(query, booleanClauseOccur);\n\n\t\treturn query;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, String startValue, String endValue) {\n\t\tTermRangeQuery termRangeQuery = new TermRangeQueryImpl(\n\t\t\tfield, startValue, endValue, true, true);\n\n\t\tadd(termRangeQuery, BooleanClauseOccur.SHOULD);\n\t}","id":24512,"modified_method":"@Override\n\tpublic Query addRangeTerm(\n\t\tString field, String startValue, String endValue) {\n\n\t\tTermRangeQuery termRangeQuery = new TermRangeQueryImpl(\n\t\t\tfield, startValue, endValue, true, true);\n\n\t\treturn add(termRangeQuery, BooleanClauseOccur.SHOULD);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerm(String field, String value, boolean like) {\n\t\taddTerm(field, value, like, BooleanClauseOccur.SHOULD);\n\t}","id":24513,"modified_method":"@Override\n\tpublic Query addTerm(String field, String value, boolean like) {\n\t\treturn addTerm(field, value, like, BooleanClauseOccur.SHOULD);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, double value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24514,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, double value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, int value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24515,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, int value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, String value) {\n\t\taddRequiredTerm(field, value, false);\n\t}","id":24516,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, String value) {\n\t\treturn addRequiredTerm(field, value, false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerm(String field, long value) {\n\t\taddTerm(field, String.valueOf(value), false);\n\t}","id":24517,"modified_method":"@Override\n\tpublic Query addTerm(String field, long value) {\n\t\treturn addTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, long value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24518,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, long value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, long startValue, long endValue) {\n\n\t\tfor (long i = startValue; i <= endValue; i++) {\n\t\t\taddExactTerm(field, i);\n\t\t}\n\t}","id":24519,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, long startValue, long endValue) {\n\n\t\tList<Query> queries = new ArrayList<>();\n\n\t\tfor (long i = startValue; i <= endValue; i++) {\n\t\t\tQuery query = addExactTerm(field, i);\n\n\t\t\tqueries.add(query);\n\t\t}\n\n\t\treturn queries;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, short startValue, short endValue) {\n\t\tTermRangeQuery termRangeQuery = new TermRangeQueryImpl(\n\t\t\tfield, String.valueOf(startValue), String.valueOf(endValue), true,\n\t\t\ttrue);\n\n\t\tadd(termRangeQuery, BooleanClauseOccur.SHOULD);\n\t}","id":24520,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, short startValue, short endValue) {\n\t\tTermRangeQuery termRangeQuery = new TermRangeQueryImpl(\n\t\t\tfield, String.valueOf(startValue), String.valueOf(endValue), true,\n\t\t\ttrue);\n\n\t\treturn add(termRangeQuery, BooleanClauseOccur.SHOULD);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void addTerm(\n\t\tString field, String value, boolean like, boolean parseKeywords) {\n\n\t\tif (like) {\n\t\t\tvalue = StringUtil.replace(\n\t\t\t\tvalue, StringPool.PERCENT, StringPool.BLANK);\n\t\t}\n\n\t\tif (parseKeywords) {\n\t\t\tString[] keywords = parseKeywords(value);\n\n\t\t\tfor (String keyword : keywords) {\n\t\t\t\taddTerm(field, keyword, like);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\taddTerm(field, value, like);\n\t\t}\n\t}","id":24521,"modified_method":"public Collection<Query> addTerm(\n\t\tString field, String value, boolean like, boolean parseKeywords) {\n\n\t\tif (like) {\n\t\t\tvalue = StringUtil.replace(\n\t\t\t\tvalue, StringPool.PERCENT, StringPool.BLANK);\n\t\t}\n\n\t\tList<Query> queries = new ArrayList<>();\n\n\t\tif (parseKeywords) {\n\t\t\tString[] keywords = parseKeywords(value);\n\n\t\t\tfor (String keyword : keywords) {\n\t\t\t\tQuery query = addTerm(field, keyword, like);\n\n\t\t\t\tqueries.add(query);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tQuery query = addTerm(field, value, like);\n\n\t\t\tqueries.add(query);\n\t\t}\n\n\t\treturn queries;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, Long startValue, Long endValue) {\n\t\taddRangeTerm(field, startValue.longValue(), endValue.longValue());\n\t}","id":24522,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, Long startValue, Long endValue) {\n\t\treturn addRangeTerm(\n\t\t\tfield, startValue.longValue(), endValue.longValue());\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerm(\n\t\tString field, String value, boolean like,\n\t\tBooleanClauseOccur booleanClauseOccur) {\n\n\t\tQuery query = null;\n\n\t\tif (like) {\n\t\t\tquery = new WildcardQueryImpl(\n\t\t\t\tnew QueryTermImpl(field, String.valueOf(value)));\n\t\t}\n\t\telse {\n\t\t\tquery = new TermQueryImpl(\n\t\t\t\tnew QueryTermImpl(field, String.valueOf(value)));\n\t\t}\n\n\t\tadd(query, booleanClauseOccur);\n\t}","id":24523,"modified_method":"@Override\n\tpublic Query addTerm(\n\t\tString field, String value, boolean like,\n\t\tBooleanClauseOccur booleanClauseOccur) {\n\n\t\tQuery query = null;\n\n\t\tif (like) {\n\t\t\tquery = new WildcardQueryImpl(\n\t\t\t\tnew QueryTermImpl(field, String.valueOf(value)));\n\t\t}\n\t\telse {\n\t\t\tquery = new TermQueryImpl(\n\t\t\t\tnew QueryTermImpl(field, String.valueOf(value)));\n\t\t}\n\n\t\treturn add(query, booleanClauseOccur);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, boolean value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24524,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, boolean value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(\n\t\tString field, Integer startValue, Integer endValue) {\n\n\t\taddRangeTerm(field, startValue.intValue(), endValue.intValue());\n\t}","id":24525,"modified_method":"@Override\n\tpublic Query addRangeTerm(\n\t\tString field, Integer startValue, Integer endValue) {\n\n\t\treturn addRangeTerm(field, startValue.intValue(), endValue.intValue());\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void add(Query query, BooleanClauseOccur booleanClauseOccur) {\n\t\t_booleanClauses.add(new BooleanClauseImpl(query, booleanClauseOccur));\n\t}","id":24526,"modified_method":"@Override\n\tpublic Query add(Query query, BooleanClauseOccur booleanClauseOccur) {\n\t\t_booleanClauses.add(new BooleanClauseImpl(query, booleanClauseOccur));\n\n\t\treturn query;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, int startValue, int endValue) {\n\t\tTermRangeQuery termRangeQuery = new TermRangeQueryImpl(\n\t\t\tfield, String.valueOf(startValue), String.valueOf(endValue), true,\n\t\t\ttrue);\n\n\t\tadd(termRangeQuery, BooleanClauseOccur.SHOULD);\n\t}","id":24527,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, int startValue, int endValue) {\n\t\tTermRangeQuery termRangeQuery = new TermRangeQueryImpl(\n\t\t\tfield, String.valueOf(startValue), String.valueOf(endValue), true,\n\t\t\ttrue);\n\n\t\treturn add(termRangeQuery, BooleanClauseOccur.SHOULD);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, long value) {\n\t\taddRequiredTerm(field, String.valueOf(value), false);\n\t}","id":24528,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, long value) {\n\t\treturn addRequiredTerm(field, String.valueOf(value), false);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Boolean value) {\n\t\taddExactTerm(field, String.valueOf(value));\n\t}","id":24529,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Boolean value) {\n\t\treturn addExactTerm(field, String.valueOf(value));\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Boolean value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24530,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Boolean value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, double value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24531,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, double value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Integer value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24532,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Integer value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, Short startValue, Short endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24533,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, Short startValue, Short endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, long value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24534,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, long value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, int startValue, int endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24535,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, int startValue, int endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, String startValue, String endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24536,"modified_method":"@Override\n\tpublic Query addRangeTerm(\n\t\tString field, String startValue, String endValue) {\n\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, int value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24537,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, int value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, double value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24538,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, double value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(\n\t\tString field, Integer startValue, Integer endValue) {\n\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24539,"modified_method":"@Override\n\tpublic Query addRangeTerm(\n\t\tString field, Integer startValue, Integer endValue) {\n\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, Short startValue, Short endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24540,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, Short startValue, Short endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, Long startValue, Long endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24541,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, Long startValue, Long endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, boolean value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24542,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, boolean value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, boolean value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24543,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, boolean value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void add(Query query, String occur) throws ParseException {\n\t\tBooleanClauseOccur booleanClauseOccur = new BooleanClauseOccurImpl(\n\t\t\toccur);\n\n\t\tadd(query, booleanClauseOccur);\n\t}","id":24544,"modified_method":"@Override\n\tpublic Query add(Query query, String occur) throws ParseException {\n\t\tBooleanClauseOccur booleanClauseOccur = new BooleanClauseOccurImpl(\n\t\t\toccur);\n\n\t\treturn add(query, booleanClauseOccur);\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerm(String field, long value) {\n\t\t_luceneQueryHelper.addTerm(_booleanQuery, field, value);\n\t}","id":24545,"modified_method":"@Override\n\tpublic Query addTerm(String field, long value) {\n\t\t_luceneQueryHelper.addTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, short value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24546,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, short value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Short value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24547,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Short value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Double value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24548,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Double value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, int startValue, int endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24549,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, int startValue, int endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerm(String field, String value) {\n\t\t_luceneQueryHelper.addTerm(_booleanQuery, field, value);\n\t}","id":24550,"modified_method":"@Override\n\tpublic Query addTerm(String field, String value) {\n\t\t_luceneQueryHelper.addTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, String value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24551,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, String value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerm(\n\t\tString field, String value, boolean like,\n\t\tBooleanClauseOccur booleanClauseOccur) {\n\n\t\t_luceneQueryHelper.addTerm(\n\t\t\t_booleanQuery, field, value, like, booleanClauseOccur);\n\t}","id":24552,"modified_method":"@Override\n\tpublic Query addTerm(\n\t\tString field, String value, boolean like,\n\t\tBooleanClauseOccur booleanClauseOccur) {\n\n\t\t_luceneQueryHelper.addTerm(\n\t\t\t_booleanQuery, field, value, like, booleanClauseOccur);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, Long startValue, Long endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24553,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, Long startValue, Long endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Long value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24554,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Long value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Short value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24555,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Short value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, short value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24556,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, short value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, long startValue, long endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24557,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, long startValue, long endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Long value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24558,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Long value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Boolean value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24559,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Boolean value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, String value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24560,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, String value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, short startValue, short endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24561,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, short startValue, short endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void add(Query query, BooleanClauseOccur booleanClauseOccur)\n\t\tthrows ParseException {\n\n\t\t_booleanQuery.add(\n\t\t\t(org.apache.lucene.search.Query)_queryTranslator.translate(query),\n\t\t\tBooleanClauseOccurTranslator.translate(booleanClauseOccur));\n\t}","id":24562,"modified_method":"@Override\n\tpublic Query add(Query query, BooleanClauseOccur booleanClauseOccur)\n\t\tthrows ParseException {\n\n\t\t_booleanQuery.add(\n\t\t\t(org.apache.lucene.search.Query)_queryTranslator.translate(query),\n\t\t\tBooleanClauseOccurTranslator.translate(booleanClauseOccur));\n\n\t\treturn query;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, String value, boolean like) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value, like);\n\t}","id":24563,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, String value, boolean like) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value, like);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addTerm(String field, String value, boolean like) {\n\t\t_luceneQueryHelper.addTerm(_booleanQuery, field, value, like);\n\t}","id":24564,"modified_method":"@Override\n\tpublic Query addTerm(String field, String value, boolean like) {\n\t\t_luceneQueryHelper.addTerm(_booleanQuery, field, value, like);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, Integer value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24565,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, Integer value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, Double value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24566,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, Double value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addExactTerm(String field, int value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\t}","id":24567,"modified_method":"@Override\n\tpublic Query addExactTerm(String field, int value) {\n\t\t_luceneQueryHelper.addExactTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRequiredTerm(String field, long value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\t}","id":24568,"modified_method":"@Override\n\tpublic Query addRequiredTerm(String field, long value) {\n\t\t_luceneQueryHelper.addRequiredTerm(_booleanQuery, field, value);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, Integer startValue, Integer endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24569,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, Integer startValue, Integer endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addRangeTerm(String field, long startValue, long endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24570,"modified_method":"@Override\n\tpublic Query addRangeTerm(String field, long startValue, long endValue) {\n\t\t_luceneQueryHelper.addRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn this;\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void addNumericRangeTerm(\n\t\tString field, short startValue, short endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\t}","id":24571,"modified_method":"@Override\n\tpublic Collection<Query> addNumericRangeTerm(\n\t\tString field, short startValue, short endValue) {\n\n\t\t_luceneQueryHelper.addNumericRangeTerm(\n\t\t\t_booleanQuery, field, startValue, endValue);\n\n\t\treturn Collections.emptyList();\n\t}","commit_id":"41ec2e1fa03601b2edb2af8a373810fc6b4802f9","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int[] getUDPPortsNotForwarded() {\n\t\tOpennetManager om = node.getOpennet();\n\t\tif(om == null || om.crypto.definitelyPortForwarded()) {\n\t\t\tif(node.darknetCrypto.definitelyPortForwarded()) {\n\t\t\t\treturn new int[] { };\n\t\t\t} else {\n\t\t\t\treturn new int[] { node.getDarknetPortNumber() };\n\t\t\t}\n\t\t} else {\n\t\t\tif(node.darknetCrypto.definitelyPortForwarded()) {\n\t\t\t\treturn new int[] { om.crypto.portNumber };\n\t\t\t} else {\n\t\t\t\treturn new int[] { node.getDarknetPortNumber(), om.crypto.portNumber };\n\t\t\t}\n\t\t}\n\t}","id":24572,"modified_method":"public int[] getUDPPortsNotForwarded() {\n\t\tOpennetManager om = node.getOpennet();\n\t\tint darknetStatus = node.darknetCrypto.getDetectedConnectivityStatus();\n\t\tint opennetStatus = om == null ? AddressTracker.DONT_KNOW : om.crypto.getDetectedConnectivityStatus();\n\t\tif(om == null || opennetStatus == AddressTracker.DEFINITELY_PORT_FORWARDED) {\n\t\t\tif(darknetStatus == AddressTracker.DEFINITELY_PORT_FORWARDED) {\n\t\t\t\treturn new int[] { };\n\t\t\t} else {\n\t\t\t\treturn new int[] { (darknetStatus < AddressTracker.DONT_KNOW ? -1 : 1) * node.getDarknetPortNumber() };\n\t\t\t}\n\t\t} else {\n\t\t\tif(darknetStatus == AddressTracker.DEFINITELY_PORT_FORWARDED) {\n\t\t\t\treturn new int[] { (opennetStatus < AddressTracker.DONT_KNOW ? -1 : 1 ) * om.crypto.portNumber };\n\t\t\t} else {\n\t\t\t\treturn new int[] { (darknetStatus < AddressTracker.DONT_KNOW ? -1 : 1 ) * node.getDarknetPortNumber(), \n\t\t\t\t\t\t(opennetStatus < AddressTracker.DONT_KNOW ? -1 : 1 ) * om.crypto.portNumber };\n\t\t\t}\n\t\t}\n\t}","commit_id":"8a3daf7bed7e7c6c7b0bc71f3d122f2128f1c04f","url":"https://github.com/freenet/fred"},{"original_method":"public String getText() {\n\t\t\tif(!suggestPortForward) return super.getText();\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tsb.append(super.getText());\n\t\t\tif(portsNotForwarded.length == 1) {\n\t\t\t\tsb.append(l10n(\"suggestForwardPort\", \"port\", Integer.toString(portsNotForwarded[0])));\n\t\t\t} else if(portsNotForwarded.length >= 2) {\n\t\t\t\tsb.append(l10n(\"suggestForwardTwoPorts\", new String[] { \"port1\", \"port2\" }, \n\t\t\t\t\t\tnew String[] { Integer.toString(portsNotForwarded[0]), Integer.toString(portsNotForwarded[1]) }));\n\t\t\t\tif(portsNotForwarded.length > 2)\n\t\t\t\t\tLogger.error(this, \"Not able to tell user about more than 2 ports to forward! (\"+portsNotForwarded.length+\")\");\n\t\t\t}\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}","id":24573,"modified_method":"public String getText() {\n\t\t\tif(!suggestPortForward) return super.getText();\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tsb.append(super.getText());\n\t\t\tif(portsNotForwarded.length == 1) {\n\t\t\t\tsb.append(l10n(\"suggestForwardPort\", \"port\", Integer.toString(Math.abs(portsNotForwarded[0]))));\n\t\t\t} else if(portsNotForwarded.length >= 2) {\n\t\t\t\tsb.append(l10n(\"suggestForwardTwoPorts\", new String[] { \"port1\", \"port2\" }, \n\t\t\t\t\t\tnew String[] { Integer.toString(Math.abs(portsNotForwarded[0])), Integer.toString(Math.abs(portsNotForwarded[1])) }));\n\t\t\t\tif(portsNotForwarded.length > 2)\n\t\t\t\t\tLogger.error(this, \"Not able to tell user about more than 2 ports to forward! (\"+portsNotForwarded.length+\")\");\n\t\t\t}\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}","commit_id":"8a3daf7bed7e7c6c7b0bc71f3d122f2128f1c04f","url":"https://github.com/freenet/fred"},{"original_method":"public boolean userCanDismiss() {\n\t\t\treturn !suggestPortForward;\n\t\t}","id":24574,"modified_method":"public boolean userCanDismiss() {\n\t\t\t// If no ports need forwarding, make it dismissable immediately.\n\t\t\tif(!suggestPortForward) return true;\n\t\t\t// Prevent NPE.\n\t\t\tif(portsNotForwarded == null) return false;\n\t\t\t// If any port definitely does need forwarding, make it non-dismissable.\n\t\t\tfor(int i=0;i<portsNotForwarded.length;i++)\n\t\t\t\tif(portsNotForwarded[i] < 0) return false; // Port definitely needs to be forwarded\n\t\t\t// Otherwise it is dismissable.\n\t\t\treturn true;\n\t\t}","commit_id":"8a3daf7bed7e7c6c7b0bc71f3d122f2128f1c04f","url":"https://github.com/freenet/fred"},{"original_method":"public String getText() {\n\t\t\tif(!suggestPortForward) return text;\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tsb.append(text);\n\t\t\tsb.append(l10n(\"suggestForwardPort\", \"port\", Integer.toString(node.getDarknetPortNumber())));\n\t\t\treturn sb.toString();\n\t\t}","id":24575,"modified_method":"public String getText() {\n\t\t\tif(!suggestPortForward) return text;\n\t\t\tStringBuffer sb = new StringBuffer();\n\t\t\tsb.append(text);\n\t\t\t// FIXME we should support any number of ports, UDP or TCP, and pick them up from the node as we do with the forwarding plugin ... that would be a bit of a pain for L10n though ...\n\t\t\tint darknetPort = node.getDarknetPortNumber();\n\t\t\tint opennetPort = node.getOpennetFNPPort();\n\t\t\tsb.append(\" \");\n\t\t\tif(opennetPort <= 0) {\n\t\t\t\tsb.append(l10n(\"suggestForwardPort\", \"port\", Integer.toString(darknetPort)));\n\t\t\t} else {\n\t\t\t\tsb.append(l10n(\"suggestForwardTwoPorts\", new String[] { \"port1\", \"port2\" }, \n\t\t\t\t\t\tnew String[] { Integer.toString(darknetPort), Integer.toString(opennetPort) }));\n\t\t\t}\n\t\t\t\n\t\t\treturn sb.toString();\n\t\t}","commit_id":"b188be69e64ac2bc645fd1945be5c08c82d712d3","url":"https://github.com/freenet/fred"},{"original_method":"public static String staticStoredValueForKey(String key, boolean noCache) {\n            String value = null;\n            try {\n                privateEditingContext().lock();\n                value = staticStoredValueForKey(privateEditingContext(), key, noCache);\n            } finally {\n                privateEditingContext().unlock();\n            }\n            return value;\n        }","id":24576,"modified_method":"public static String staticStoredValueForKey(String key, boolean noCache) {\n            String value = null;\n            privateEditingContext().lock();\n            try {\n                value = staticStoredValueForKey(privateEditingContext(), key, noCache);\n            } finally {\n                privateEditingContext().unlock();\n            }\n            return value;\n        }","commit_id":"6315b642ab63f13dfd2a8cfab15e7e17077c72c5","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static int staticStoredIntValueForKey(String key, boolean noCache) {\n            int value = 0;\n            try {\n                privateEditingContext().lock();\n                value = staticStoredIntValueForKey(privateEditingContext(), key, noCache);\n            } finally {\n                privateEditingContext().unlock();\n            }\n            return value;\n        }","id":24577,"modified_method":"public static int staticStoredIntValueForKey(String key, boolean noCache) {\n            int value = 0;\n            privateEditingContext().lock();\n            try {\n                value = staticStoredIntValueForKey(privateEditingContext(), key, noCache);\n            } finally {\n                privateEditingContext().unlock();\n            }\n            return value;\n        }","commit_id":"6315b642ab63f13dfd2a8cfab15e7e17077c72c5","url":"https://github.com/wocommunity/wonder"},{"original_method":"public ERCStatic objectMatchingKey(EOEditingContext ec, String key, boolean noCache) {\n            // If noCache is true we always go to the database\n            Object result = noCache ? null : _staticsPerKey.objectForKey(key);\n            if (result == null) {\n                NSArray arr = preferencesWithKey(ec, key);\n                if (arr.count() > 1)\n                    throw new IllegalStateException(\"Found \" + arr.count() + \" rows for key \" + key);\n                result = arr.count() == 1 ? arr.objectAtIndex(0) : NSKeyValueCoding.NullValue;\n                _staticsPerKey.setObjectForKey(result, key);\n                result = result == NSKeyValueCoding.NullValue ? null : result;\n            }\n            result = result != null && !result.equals(NSKeyValueCoding.NullValue) ? ERXEOControlUtilities.localInstanceOfObject(ec,\n(ERCStatic)result) : null;\n            return (ERCStatic)result;\n        }","id":24578,"modified_method":"public ERCStatic objectMatchingKey(EOEditingContext ec, String key, boolean noCache) {\n            // If noCache is true we always go to the database\n            Object result = noCache ? null : _staticsPerKey.objectForKey(key);\n            if (result == null) {\n                NSArray arr = preferencesWithKey(ec, key);\n                if (arr.count() > 1)\n                    throw new IllegalStateException(\"Found \" + arr.count() + \" rows for key \" + key);\n                result = arr.count() == 1 ? arr.objectAtIndex(0) : NSKeyValueCoding.NullValue;\n                if (result instanceof EOEnterpriseObject) {\n                    privateEditingContext().lock();\n                    try {\n                        _staticsPerKey.setObjectForKey(ERXEOControlUtilities.localInstanceOfObject(privateEditingContext(),\n                                                                                                   (ERCStatic)result),\n                                                       key);                        \n                    } finally {\n                        privateEditingContext().unlock();\n                    }\n                }\n                result = result == NSKeyValueCoding.NullValue ? null : result;\n            } else if (result instanceof EOEnterpriseObject) {\n                privateEditingContext().lock();\n                try {\n                    result = ERXEOControlUtilities.localInstanceOfObject(ec, (ERCStatic)result);\n                } finally {\n                    privateEditingContext().unlock();\n                }                \n            } else if (result.equals(NSKeyValueCoding.NullValue)) {\n                result = null;\n            }\n            return (ERCStatic)result;\n        }","commit_id":"6315b642ab63f13dfd2a8cfab15e7e17077c72c5","url":"https://github.com/wocommunity/wonder"},{"original_method":"private static EOEditingContext privateEditingContext() {\n            if (_privateEditingContext == null) {\n                if (ERXProperties.booleanForKeyWithDefault(\"er.corebusinesslogic.ERCStatic.UseSeparateChannel\", true)) {\n                    _privateEditingContext = ERXEC.newEditingContext(new EOObjectStoreCoordinator());\n                    _privateEditingContext.setSharedEditingContext(null);\n                } else {\n                    _privateEditingContext = ERXEC.newEditingContext();\n                }                \n            }\n            return _privateEditingContext;\n        }","id":24579,"modified_method":"private static EOEditingContext privateEditingContext() {\n            if (_privateEditingContext == null) {\n                if (ERXProperties.booleanForKeyWithDefault(\"er.corebusinesslogic.ERCStatic.UseSeparateChannel\", true)) {\n                    _privateEditingContext = ERXEC.newEditingContext(new EOObjectStoreCoordinator());\n                    _privateEditingContext.lock();\n                    try {\n                        _privateEditingContext.setSharedEditingContext(null);\n                    } finally {\n                        _privateEditingContext.unlock();\n                    }\n                } else {\n                    _privateEditingContext = ERXEC.newEditingContext();\n                }                \n            }\n            return _privateEditingContext;\n        }","commit_id":"6315b642ab63f13dfd2a8cfab15e7e17077c72c5","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static void takeStaticStoredValueForKey(String value,\n                                                       String key) {\n            try {\n                privateEditingContext().lock();\n                takeStaticStoredValueForKey(privateEditingContext(), value, key);\n                // Clear out the stacks.\n                privateEditingContext().saveChanges();\n                privateEditingContext().revert();\n            } finally {\n                privateEditingContext().unlock();\n            }\n        }","id":24580,"modified_method":"public static void takeStaticStoredValueForKey(String value,\n                                                       String key) {\n            privateEditingContext().lock();\n            try {\n                takeStaticStoredValueForKey(privateEditingContext(), value, key);\n                // Clear out the stacks.\n                privateEditingContext().saveChanges();\n                privateEditingContext().revert();\n            } finally {\n                privateEditingContext().unlock();\n            }\n        }","commit_id":"6315b642ab63f13dfd2a8cfab15e7e17077c72c5","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent editAction() {\n        WOComponent returnPage = null;\n        if (previousPage() == null) {\n            EditPageInterface editPage=D2W.factory().editPageForEntityNamed(object().entityName(),session());\n            editPage.setObject(object());\n            editPage.setNextPage(nextPage());\n            returnPage = (WOComponent)editPage;\n        }\n        return returnPage != null ? returnPage : previousPage();\n    }","id":24581,"modified_method":"public WOComponent editAction() {\n        WOComponent returnPage = null;\n        if (previousPage() == null) {\n            EditPageInterface editPage=D2W.factory().editPageForEntityNamed(object().entityName(),session());\n            editPage.setObject(ERD2WUtilities.localInstanceFromObjectWithD2WContext(object(), d2wContext()));\n            editPage.setNextPage(nextPage());\n            returnPage = (WOComponent)editPage;\n        }\n        return returnPage != null ? returnPage : previousPage();\n    }","commit_id":"fa7a64a0f0bc9b459262e3d8af37dd41236b3ba7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent inspectObjectAction() {\n        WOComponent result = null;\n        String inspectConfigurationName=(String)d2wContext().valueForKey(\"inspectConfigurationName\");\n\n        if(inspectConfigurationName!=null) {\n            InspectPageInterface ipi=(InspectPageInterface)D2W.factory().pageForConfigurationNamed(inspectConfigurationName,session());\n            ipi.setObject(localInstance());\n            ipi.setNextPage(context().page());\n            return (WOComponent)ipi;\n        } else {\n            InspectPageInterface inspectpageinterface = D2W.factory().inspectPageForEntityNamed(localInstance().entityName(), session());\n            inspectpageinterface.setObject(localInstance());\n            inspectpageinterface.setNextPage(context().page());\n            return (WOComponent)inspectpageinterface;\n        }\n    }","id":24582,"modified_method":"public WOComponent inspectObjectAction() {\n        WOComponent result = null;\n        String inspectConfigurationName=(String)d2wContext().valueForKey(\"inspectConfigurationName\");\n\n        if(inspectConfigurationName!=null) {\n            InspectPageInterface ipi=(InspectPageInterface)D2W.factory().pageForConfigurationNamed(inspectConfigurationName,session());\n            ipi.setObject(object());\n            ipi.setNextPage(context().page());\n            return (WOComponent)ipi;\n        } else {\n            InspectPageInterface inspectpageinterface = D2W.factory().inspectPageForEntityNamed(object().entityName(), session());\n            inspectpageinterface.setObject(object());\n            inspectpageinterface.setNextPage(context().page());\n            return (WOComponent)inspectpageinterface;\n        }\n    }","commit_id":"fa7a64a0f0bc9b459262e3d8af37dd41236b3ba7","url":"https://github.com/wocommunity/wonder"},{"original_method":"private EOEnterpriseObject localInstance() {\n        return ERD2WUtilities.localInstanceFromObjectWithD2WContext(object(), d2wContext());\n    }","id":24583,"modified_method":"protected EOEnterpriseObject localInstanceOfObject() {\n        return ERD2WUtilities.localInstanceFromObjectWithD2WContext(object(), d2wContext());\n    }","commit_id":"fa7a64a0f0bc9b459262e3d8af37dd41236b3ba7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent editObjectAction() {\n        WOComponent result = null;\n        String editConfigurationName=(String)d2wContext().valueForKey(\"editConfigurationName\");\n\n        if(editConfigurationName != null){\n            EditPageInterface epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(editConfigurationName,session());\n\n            epi.setObject(localInstance());\n            epi.setNextPage(context().page());\n            result = (WOComponent)epi;\n        } else {\n            EditPageInterface editpageinterface = D2W.factory().editPageForEntityNamed(localInstance().entityName(), session());\n            editpageinterface.setObject(localInstance());\n            editpageinterface.setNextPage(context().page());\n            result = (WOComponent)editpageinterface;\n        }\n        return result;\n    }","id":24584,"modified_method":"public WOComponent editObjectAction() {\n        WOComponent result = null;\n        String editConfigurationName=(String)d2wContext().valueForKey(\"editConfigurationName\");\n\n        if(editConfigurationName != null){\n            EditPageInterface epi=(EditPageInterface)D2W.factory().pageForConfigurationNamed(editConfigurationName,session());\n\n            epi.setObject(localInstanceOfObject());\n            epi.setNextPage(context().page());\n            result = (WOComponent)epi;\n        } else {\n            EditPageInterface editpageinterface = D2W.factory().editPageForEntityNamed(object().entityName(), session());            \n            editpageinterface.setObject(localInstanceOfObject());\n            editpageinterface.setNextPage(context().page());\n            result = (WOComponent)editpageinterface;\n        }\n        return result;\n    }","commit_id":"fa7a64a0f0bc9b459262e3d8af37dd41236b3ba7","url":"https://github.com/wocommunity/wonder"},{"original_method":"/** This method faults the provied <code>EOEnterpriseObject<\/code> into a new <code>EOEditingContext<\/code>\n    * based on the current state:<br>\n    * 1. the <code>EOEnterpriseObject<\/code> is new: simply returns the <code>EOEnterpriseObject<\/code>,\n    * a new <code>EOEnterpriseObject<\/code> cannot be faulted into another <code>EOEditingContext<\/code><br>\n    *\n    * 2. if the d2wContext's task is 'edit' it creates a new -nested- <code>EOEditingContext<\/code> and\n    * faults the <code>EOEnterpriseObject<\/code> into it. Calls <code>setSharedEditingContext(false)<\/code> on\n    * the ec to ensure that this also works if one uses EOSharedEditingContexts.\n    * \n    * 3. otherwise it creates a new PeerEditingContext and faults the <code>EOEnterpriseObject<\/code> into it.\n    * Calls <code>setSharedEditingContext(false)<\/code> on the ec to ensure that this also works if\n    * one uses EOSharedEditingContexts.\n    *\n    * This method should be called whenever on returns a new Page for a D2W action. It should simply behave like\n    * one assumes and not like the WO implementation: no nested EC's, no SharedEditingContext support.\n    *\n    * @param eo The <code>EOEnterpriseObject<\/code> that should be faulted. If the current page is\n    * a List page then it would mostly be current list object. If the current page is a Edit page then\n    * it would be object() and NOT the relationship object or whatever. object() because its the main object\n    * that needs to be faulted, then one must not care about relationships and so on.\n    * \n    * @param d2wContext the current d2wContext\n    *\n    * @return\n    */\n    public static EOEnterpriseObject localInstanceFromObjectWithD2WContext(EOEnterpriseObject eo, D2WContext d2wContext) {\n        if (eo.editingContext() == null) {\n            throw new NullPointerException(\"localInstanceFromObjectWithD2WContext: the argument eo must have a valid EOEditingContext: eo.editingContext() != null\");\n        }\n        EOEnterpriseObject localObject = eo;\n        if (ERXExtensions.isNewObject(eo)) {\n            //do nothing, a newObject cannot be faulted into another EC!\n        } else if (\"edit\".equals(d2wContext.valueForKey(\"task\"))) {\n            //create a new nested EC and fault the object into it\n            EOEditingContext ec = ERXEC.newEditingContext(eo.editingContext());\n            //FIXME: we cannot use childEc's because if the EO is not saved to the DB\n            //then the EO is not displayed as EO if one uses for example a ERD2WEditToOneRelationship\n            //component: the new EO will not be displayed in the list\n            //EOEditingContext ec = ERXEC.newEditingContext();\n            ec.setSharedEditingContext(null);\n            localObject = EOUtilities.localInstanceOfObject(ec, eo);\n        } else {\n            //create a new Peer EC and fault the object into it\n            //this is done regardeless if the object's editingContext is\n            //a sharedec or not.\n            EOEditingContext ec = ERXEC.newEditingContext();\n            ec.setSharedEditingContext(null);\n            localObject = EOUtilities.localInstanceOfObject(ec, eo);\n        }\n        return localObject;\n    }","id":24585,"modified_method":"/** This method faults the provied <code>EOEnterpriseObject<\/code> into a new <code>EOEditingContext<\/code>\n    * based on the current state:<br>\n    * 1. the <code>EOEnterpriseObject<\/code> is new: simply returns the <code>EOEnterpriseObject<\/code>,\n    * a new <code>EOEnterpriseObject<\/code> cannot be faulted into another <code>EOEditingContext<\/code><br>\n    *\n    * 2. if the d2wContext's task is 'edit' it creates a new -nested- <code>EOEditingContext<\/code> and\n    * faults the <code>EOEnterpriseObject<\/code> into it. Calls <code>setSharedEditingContext(false)<\/code> on\n    * the ec to ensure that this also works if one uses EOSharedEditingContexts.\n    * \n    * 3. otherwise it creates a new PeerEditingContext and faults the <code>EOEnterpriseObject<\/code> into it.\n    * Calls <code>setSharedEditingContext(false)<\/code> on the ec to ensure that this also works if\n    * one uses EOSharedEditingContexts.\n    *\n    * This method should be called whenever on returns a new Page for a D2W action. It should simply behave like\n    * one assumes and not like the WO implementation: no nested EC's, no SharedEditingContext support.\n    *\n    * @param eo The <code>EOEnterpriseObject<\/code> that should be faulted. If the current page is\n    * a List page then it would mostly be current list object. If the current page is a Edit page then\n    * it would be object() and NOT the relationship object or whatever. object() because its the main object\n    * that needs to be faulted, then one must not care about relationships and so on.\n    * \n    * @param d2wContext the current d2wContext\n    *\n    * @return\n    */\n    public static EOEnterpriseObject localInstanceFromObjectWithD2WContext(EOEnterpriseObject eo, D2WContext d2wContext) {\n        EOEditingContext ec = eo.editingContext();\n        if(ec == null) throw new IllegalStateException(\"EC can't be null in localinstance\");\n        EOEnterpriseObject localObject = eo;\n        if(ERXProperties.webObjectsVersionAsDouble() < 5.21d && ERXExtensions.isNewObject(localObject)) {\n            // do nothing as we can't localInstance anything here\n        } else {\n            boolean nest = d2wContext != null && ERXValueUtilities.booleanValue(d2wContext.valueForKey(\"useNestedEditingContext\"));\n            EOEditingContext newEc = ERXEC.newEditingContext(nest ? ec : ec.parentObjectStore());\n            if(ec instanceof EOSharedEditingContext) {\n                newEc.setSharedEditingContext(null);\n            }\n            localObject = EOUtilities.localInstanceOfObject(newEc, eo);\n        }\n\n        return localObject;\n    }","commit_id":"fa7a64a0f0bc9b459262e3d8af37dd41236b3ba7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent edit() {\n        EOEditingContext context = er.extensions.ERXExtensions.newEditingContext();\n        EOEnterpriseObject localObject = EOUtilities.localInstanceOfObject(context, object());\n        String configuration = (String)d2wContext().valueForKey(\"editConfigurationNameForEntity\");\n        if(log.isDebugEnabled()){\n           log.debug(\"configuration = \"+configuration);\n        }\n        EditPageInterface epi = (EditPageInterface)D2W.factory().pageForConfigurationNamed(configuration, session());\n        epi.setObject(localObject);\n        epi.setNextPage(context().page());\n        context.hasChanges(); // Ensuring it survives.\n        return (WOComponent)epi;\n    }","id":24586,"modified_method":"public WOComponent edit() {\n        EOEnterpriseObject localObject = localInstanceOfObject();\n        String configuration = (String)d2wContext().valueForKey(\"editConfigurationNameForEntity\");\n        if(log.isDebugEnabled()){\n           log.debug(\"configuration = \"+configuration);\n        }\n        EditPageInterface epi = (EditPageInterface)D2W.factory().pageForConfigurationNamed(configuration, session());\n        epi.setObject(localObject);\n        epi.setNextPage(context().page());\n        localObject.editingContext().hasChanges(); // Ensuring it survives.\n        return (WOComponent)epi;\n    }","commit_id":"fa7a64a0f0bc9b459262e3d8af37dd41236b3ba7","url":"https://github.com/wocommunity/wonder"},{"original_method":"public EOEditingContext _newEditingContext(boolean validationEnabled) {\n            ObjectStoreCoordinator os = (ObjectStoreCoordinator)defaultPool.currentRootObjectStore();\n            EOEditingContext ec = _newEditingContext(os, validationEnabled);\n            EOSharedEditingContext sec = os.sharedEditingContext();\n            ec.setSharedEditingContext(sec);\n            return ec;\n        }","id":24587,"modified_method":"public EOEditingContext _newEditingContext(boolean validationEnabled) {\n            ObjectStoreCoordinator os = (ObjectStoreCoordinator)defaultPool.currentRootObjectStore();\n            EOEditingContext ec = _newEditingContext(os, validationEnabled);\n\n            if (useSharedEditingContext()) {\n                EOSharedEditingContext sec = os.sharedEditingContext();\n                ec.lock();\n                try {\n                    ec.setSharedEditingContext(sec);\n                } finally {\n                    ec.unlock();\n                }\n            }\n            return ec;\n        }","commit_id":"7be458b12b2a43669cbf3119aacd5468bdb7e86a","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void rebuildMenu(final JsArray<SharedProjectDetails> sharedProjects,\n         DynamicPopupMenuCallback callback)\n   {\n      clearItems();\n      boolean hasSharedProjects = sharedProjects != null && \n                                  sharedProjects.length() > 0;\n\n      addItem(commands_.newProject().createMenuItem(false));\n      addSeparator();\n      addItem(commands_.openProject().createMenuItem(false));\n      addItem(commands_.openProjectInNewWindow().createMenuItem(false));\n      addItem(commands_.shareProject().createMenuItem(false));\n      addItem(commands_.closeProject().createMenuItem(false));\n      if (hasSharedProjects)\n         addSeparator(\"My Projects\"); \n      else\n         addSeparator();\n      addItem(commands_.projectMru0().createMenuItem(false));\n      addItem(commands_.projectMru1().createMenuItem(false));\n      addItem(commands_.projectMru2().createMenuItem(false));\n      addItem(commands_.projectMru3().createMenuItem(false));\n      addItem(commands_.projectMru4().createMenuItem(false));\n      addItem(commands_.projectMru5().createMenuItem(false));\n      addItem(commands_.projectMru6().createMenuItem(false));\n      addItem(commands_.projectMru7().createMenuItem(false));\n      addItem(commands_.projectMru8().createMenuItem(false));\n      addItem(commands_.projectMru9().createMenuItem(false));\n      addItem(commands_.projectMru10().createMenuItem(false));\n      addItem(commands_.projectMru11().createMenuItem(false));\n      addItem(commands_.projectMru12().createMenuItem(false));\n      addItem(commands_.projectMru13().createMenuItem(false));\n      addItem(commands_.projectMru14().createMenuItem(false));\n      if (hasSharedProjects)\n      {\n         addSeparator(\"Shared with Me\"); \n         for (int i = 0; i < sharedProjects.length(); i ++)\n         {\n            final SharedProjectDetails details = sharedProjects.get(i);\n\n            String menuHtml = AppCommand.formatMenuLabel(\n                  null, details.getName(), false, null, \n                  commands_.openHtmlExternal().getImageResource(), \n                  ProjectMRUList.NEW_SESSION_DESC);\n            addItem(new MenuItem(menuHtml, true,\n                  new Scheduler.ScheduledCommand()\n                  {\n                     @Override\n                     public void execute()\n                     {\n                        ProjectMRUList.openProjectFromMru(events_, \n                              details.getProjectFile());\n                     }\n                  }));\n         }\n      }\n\n      addSeparator();\n      addItem(commands_.clearRecentProjects().createMenuItem(false));\n      addSeparator();\n      addItem(commands_.projectOptions().createMenuItem(false));\n      \n      callback.onPopupMenu(this);\n   }","id":24588,"modified_method":"private void rebuildMenu(final JsArray<SharedProjectDetails> sharedProjects,\n         DynamicPopupMenuCallback callback)\n   {\n      // clean out existing entries\n      clearItems();\n\n      boolean hasSharedProjects = sharedProjects != null && \n                                  sharedProjects.length() > 0;\n\n      // truncate the MRU list size for smaller client heights\n      int maxMruEntries = MAX_MRU_ENTRIES;\n      if (Window.getClientHeight() < 700)\n         maxMruEntries -= 5;\n      \n      // shared projects are always shown, and count against the MRU limit\n      if (hasSharedProjects)\n         maxMruEntries -= sharedProjects.length();\n      \n      addItem(commands_.newProject().createMenuItem(false));\n      addSeparator();\n      addItem(commands_.openProject().createMenuItem(false));\n      addItem(commands_.openProjectInNewWindow().createMenuItem(false));\n      addItem(commands_.shareProject().createMenuItem(false));\n      addItem(commands_.closeProject().createMenuItem(false));\n      if (hasSharedProjects)\n         addSeparator(\"My Projects\"); \n      else\n         addSeparator();\n\n      // add as many MRU items as is appropriate for our screen size and number\n      // of shared projects\n      AppCommand[] mruCommands = new AppCommand[] {\n         commands_.projectMru0(),\n         commands_.projectMru1(),\n         commands_.projectMru2(),\n         commands_.projectMru3(),\n         commands_.projectMru4(),\n         commands_.projectMru5(),\n         commands_.projectMru6(),\n         commands_.projectMru7(),\n         commands_.projectMru8(),\n         commands_.projectMru9(),\n         commands_.projectMru10(),\n         commands_.projectMru11(),\n         commands_.projectMru12(),\n         commands_.projectMru13(),\n         commands_.projectMru14()\n      };\n      \n      for (int i = 0; i < Math.min(maxMruEntries, mruCommands.length); i++)\n      {\n         addItem(mruCommands[i].createMenuItem(false));\n      }\n      \n      // show shared projects if enabled\n      if (hasSharedProjects)\n      {\n         addSeparator(\"Shared with Me\"); \n         for (int i = 0; i < sharedProjects.length(); i ++)\n         {\n            final SharedProjectDetails details = sharedProjects.get(i);\n\n            String menuHtml = AppCommand.formatMenuLabel(\n                  null, details.getName(), false, null, \n                  commands_.openHtmlExternal().getImageResource(), \n                  ProjectMRUList.NEW_SESSION_DESC);\n            addItem(new MenuItem(menuHtml, true,\n                  new Scheduler.ScheduledCommand()\n                  {\n                     @Override\n                     public void execute()\n                     {\n                        ProjectMRUList.openProjectFromMru(events_, \n                              details.getProjectFile());\n                     }\n                  }));\n         }\n      }\n\n      addSeparator();\n      addItem(commands_.clearRecentProjects().createMenuItem(false));\n      addSeparator();\n      addItem(commands_.projectOptions().createMenuItem(false));\n      \n      callback.onPopupMenu(this);\n   }","commit_id":"afdc5b59284a54c873bf3b122beb8f54afacbdad","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void getDynamicPopupMenu(final DynamicPopupMenuCallback callback)\n   {\n      // truncate the MRU list size for smaller client heights\n      if (Window.getClientHeight() < 700)\n      {\n         commands_.projectMru10().setVisible(false);\n         commands_.projectMru11().setVisible(false);\n         commands_.projectMru12().setVisible(false);\n         commands_.projectMru13().setVisible(false);\n         commands_.projectMru14().setVisible(false);\n      }\n      \n      ProjectMRUList.setOpenInNewWindow(false);\n      if (allowSharedProjects_)\n      {\n         // if shared projects are on, check for them every time the user drops\n         // the menu \n         server_.getSharedProjects(MAX_SHARED_PROJECTS, \n               new ServerRequestCallback<JsArray<SharedProjectDetails>>()\n         {\n            @Override\n            public void onResponseReceived(JsArray<SharedProjectDetails> result)\n            {\n               rebuildMenu(result, callback);\n            }\n\n            @Override\n            public void onError(ServerError error)\n            {\n               // if we can't get the shared projects, we can at least show\n               // the rest of the menu\n               rebuildMenu(null, callback);\n            }\n         });\n      }\n      else\n      {\n         // shared projects are off; build the menu only if it isn't built\n         // already\n         if (getItemCount() == 0)\n            rebuildMenu(null, callback);\n         else\n            callback.onPopupMenu(this);\n      }\n   }","id":24589,"modified_method":"@Override\n   public void getDynamicPopupMenu(final DynamicPopupMenuCallback callback)\n   {\n      ProjectMRUList.setOpenInNewWindow(false);\n      if (allowSharedProjects_)\n      {\n         // if shared projects are on, check for them every time the user drops\n         // the menu \n         server_.getSharedProjects(MAX_SHARED_PROJECTS, \n               new ServerRequestCallback<JsArray<SharedProjectDetails>>()\n         {\n            @Override\n            public void onResponseReceived(JsArray<SharedProjectDetails> result)\n            {\n               rebuildMenu(result, callback);\n            }\n\n            @Override\n            public void onError(ServerError error)\n            {\n               // if we can't get the shared projects, we can at least show\n               // the menu without them\n               rebuildMenu(null, callback);\n            }\n         });\n      }\n      else\n      {\n         rebuildMenu(null, callback);\n      }\n   }","commit_id":"afdc5b59284a54c873bf3b122beb8f54afacbdad","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void setSessionStatus(SessionStatus sessionStatus)\n    {\n        if (sessionStatus == this.sessionStatus)\n            return;\n\n        this.sessionStatus = sessionStatus;\n        this.rebuildMenu();\n    }","id":24590,"modified_method":"private void setSessionStatus(SessionStatus sessionStatus)\n    {\n        if (sessionStatus != this.sessionStatus)\n        {\n            this.sessionStatus = sessionStatus;\n\n            updateIcon();\n            if (isPopupMenuVisible())\n                rebuildMenu();\n        }\n    }","commit_id":"2ab3f3bf0259b33a6985e861b0309d0ce4e118b0","url":"https://github.com/jitsi/jitsi"},{"original_method":"public SessionStatus getSessionStatus()\n    {\n        return sessionStatus;\n    }","id":24591,"modified_method":"private SessionStatus getSessionStatus()\n    {\n        return sessionStatus;\n    }","commit_id":"2ab3f3bf0259b33a6985e861b0309d0ce4e118b0","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void setOtrPolicy(OtrPolicy otrPolicy)\n    {\n        if (otrPolicy.equals(this.otrPolicy))\n            return;\n\n        this.otrPolicy = otrPolicy;\n        this.rebuildMenu();\n    }","id":24592,"modified_method":"private void setOtrPolicy(OtrPolicy otrPolicy)\n    {\n        if (!otrPolicy.equals(this.otrPolicy))\n        {\n            this.otrPolicy = otrPolicy;\n\n            if (isPopupMenuVisible())\n                rebuildMenu();\n        }\n    }","commit_id":"2ab3f3bf0259b33a6985e861b0309d0ce4e118b0","url":"https://github.com/jitsi/jitsi"},{"original_method":"public OtrContactMenu(Contact contact)\n    {\n        this.contact = contact;\n        this.setText(contact.getDisplayName());\n        \n        OtrActivator.scOtrEngine.addListener(new ScOtrEngineListener()\n        {\n            public void sessionStatusChanged(Contact contact)\n            {\n                SessionStatus status =\n                    OtrActivator.scOtrEngine.getSessionStatus(contact);\n\n                if (contact.equals(OtrContactMenu.this.contact))\n                    setSessionStatus(status);\n            }\n\n            public void contactPolicyChanged(Contact contact)\n            {\n                // Update the corresponding to the contact menu.\n                OtrPolicy policy =\n                    OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n                if (contact.equals(OtrContactMenu.this.contact))\n                    setOtrPolicy(policy);\n            }\n\n            public void globalPolicyChanged()\n            {\n                OtrPolicy policy =\n                    OtrActivator.scOtrEngine\n                        .getContactPolicy(OtrContactMenu.this.contact);\n\n                setOtrPolicy(policy);\n            }\n        });\n\n        OtrActivator.scOtrKeyManager.addListener(new ScOtrKeyManagerListener()\n        {\n            public void contactVerificationStatusChanged(Contact contact)\n            {\n                SessionStatus status =\n                    OtrActivator.scOtrEngine.getSessionStatus(contact);\n\n                if (contact.equals(OtrContactMenu.this.contact))\n                    setSessionStatus(status);\n            }\n        });\n        \n        setSessionStatus(OtrActivator.scOtrEngine.getSessionStatus(contact));\n        setOtrPolicy(OtrActivator.scOtrEngine.getContactPolicy(contact));\n    }","id":24593,"modified_method":"public OtrContactMenu(Contact contact)\n    {\n        this.contact = contact;\n\n        this.setText(contact.getDisplayName());\n\n        /*\n         * Setup populating this JMenu on demand because it's not always\n         * necessary.\n         */\n        getPopupMenu().addPopupMenuListener(this);\n\n        OtrActivator.scOtrEngine.addListener(this);\n        OtrActivator.scOtrKeyManager.addListener(this);\n        \n        setSessionStatus(OtrActivator.scOtrEngine.getSessionStatus(contact));\n        setOtrPolicy(OtrActivator.scOtrEngine.getContactPolicy(contact));\n    }","commit_id":"2ab3f3bf0259b33a6985e861b0309d0ce4e118b0","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void rebuildMenu()\n    {\n        this.removeAll();\n\n        OtrPolicy policy = OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n        JMenuItem endOtr = new JMenuItem();\n        endOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.END_OTR\"));\n        endOtr.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                // End session.\n                OtrActivator.scOtrEngine.endSession(contact);\n            }\n        });\n\n        JMenuItem startOtr = new JMenuItem();\n        startOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.START_OTR\"));\n        startOtr.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                // Start session.\n                OtrActivator.scOtrEngine.startSession(contact);\n            }\n        });\n        startOtr.setEnabled(policy.getEnableManual());\n\n        switch (this.getSessionStatus())\n        {\n        case ENCRYPTED:\n            this\n                .setIcon(OtrActivator.resourceService\n                    .getImage((OtrActivator.scOtrKeyManager\n                        .isVerified(contact))\n                        ? \"plugin.otr.ENCRYPTED_ICON_16x16\"\n                        : \"plugin.otr.ENCRYPTED_UNVERIFIED_ICON_16x16\"));\n\n            this.add(endOtr);\n\n            JMenuItem refreshOtr = new JMenuItem();\n            refreshOtr.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.REFRESH_OTR\"));\n            refreshOtr.addActionListener(new ActionListener()\n            {\n                public void actionPerformed(ActionEvent e)\n                {\n                    // Refresh session.\n                    OtrActivator.scOtrEngine.refreshSession(contact);\n                }\n            });\n            refreshOtr.setEnabled(policy.getEnableManual());\n            this.add(refreshOtr);\n\n            JMenuItem authBuddy = new JMenuItem();\n            authBuddy.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.AUTHENTICATE_BUDDY\"));\n            authBuddy.addActionListener(new ActionListener()\n            {\n                public void actionPerformed(ActionEvent e)\n                {\n                    // Launch auth buddy dialog.\n                    OtrBuddyAuthenticationDialog authenticateBuddyDialog =\n                        new OtrBuddyAuthenticationDialog(contact);\n\n                    authenticateBuddyDialog.setLocation(Toolkit\n                        .getDefaultToolkit().getScreenSize().width\n                        / 2 - authenticateBuddyDialog.getWidth() / 2, Toolkit\n                        .getDefaultToolkit().getScreenSize().height\n                        / 2 - authenticateBuddyDialog.getHeight() / 2);\n\n                    authenticateBuddyDialog.setVisible(true);\n                }\n            });\n            this.add(authBuddy);\n            break;\n        case FINISHED:\n            this.setIcon(OtrActivator.resourceService\n                .getImage(\"plugin.otr.FINISHED_ICON_16x16\"));\n\n            this.add(endOtr);\n            this.add(startOtr);\n            break;\n        case PLAINTEXT:\n            this.setIcon(OtrActivator.resourceService\n                .getImage(\"plugin.otr.PLAINTEXT_ICON_16x16\"));\n\n            this.add(startOtr);\n            break;\n        }\n\n        this.addSeparator();\n\n        JCheckBoxMenuItem cbEnable = new JCheckBoxMenuItem();\n        cbEnable.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_ENABLE\"));\n\n        cbEnable.setState(policy.getEnableManual());\n\n        cbEnable.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                OtrPolicy policy =\n                    OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n                boolean state = ((JCheckBoxMenuItem) e.getSource()).getState();\n                policy.setEnableManual(state);\n                OtrActivator.scOtrEngine.setContactPolicy(contact, policy);\n            }\n        });\n        this.add(cbEnable);\n\n        JCheckBoxMenuItem cbAlways = new JCheckBoxMenuItem();\n        cbAlways.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_AUTO\"));\n\n        cbAlways.setEnabled(policy.getEnableManual());\n        cbAlways.setState(policy.getEnableAlways());\n\n        cbAlways.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                OtrPolicy policy =\n                    OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n                boolean state = ((JCheckBoxMenuItem) e.getSource()).getState();\n                policy.setEnableAlways(state);\n                OtrActivator.scOtrEngine.setContactPolicy(contact, policy);\n            }\n        });\n        this.add(cbAlways);\n\n        JCheckBoxMenuItem cbRequire = new JCheckBoxMenuItem();\n        cbRequire.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_REQUIRE\"));\n\n        cbRequire.setEnabled(policy.getEnableManual());\n        cbRequire.setState(policy.getRequireEncryption());\n\n        cbRequire.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                OtrPolicy policy =\n                    OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n                boolean state = ((JCheckBoxMenuItem) e.getSource()).getState();\n                policy.setEnableAlways(state);\n                OtrActivator.scOtrEngine.setContactPolicy(contact, policy);\n            }\n        });\n        this.add(cbRequire);\n\n        this.addSeparator();\n\n        JMenuItem cbReset = new JMenuItem();\n        cbReset.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_RESET\"));\n\n        cbReset.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                OtrActivator.scOtrEngine.setContactPolicy(contact, null);\n            }\n        });\n        this.add(cbReset);\n    }","id":24594,"modified_method":"private void rebuildMenu()\n    {\n        this.removeAll();\n\n        OtrPolicy policy = OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n        JMenuItem endOtr = new JMenuItem();\n        endOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.END_OTR\"));\n        endOtr.setActionCommand(ACTION_COMMAND_END_OTR);\n        endOtr.addActionListener(this);\n\n        JMenuItem startOtr = new JMenuItem();\n        startOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.START_OTR\"));\n        startOtr.setEnabled(policy.getEnableManual());\n        startOtr.setActionCommand(ACTION_COMMAND_START_OTR);\n        startOtr.addActionListener(this);\n\n        switch (getSessionStatus())\n        {\n        case ENCRYPTED:\n            JMenuItem refreshOtr = new JMenuItem();\n            refreshOtr.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.REFRESH_OTR\"));\n            refreshOtr.setEnabled(policy.getEnableManual());\n            refreshOtr.setActionCommand(ACTION_COMMAND_REFRESH_OTR);\n            refreshOtr.addActionListener(this);\n\n            JMenuItem authBuddy = new JMenuItem();\n            authBuddy.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.AUTHENTICATE_BUDDY\"));\n            authBuddy.setActionCommand(ACTION_COMMAND_AUTHENTICATE_BUDDY);\n            authBuddy.addActionListener(this);\n\n            this.add(endOtr);\n            this.add(refreshOtr);\n            this.add(authBuddy);\n            break;\n\n        case FINISHED:\n            this.add(endOtr);\n            this.add(startOtr);\n            break;\n\n        case PLAINTEXT:\n            this.add(startOtr);\n            break;\n        }\n\n        JCheckBoxMenuItem cbEnable = new JCheckBoxMenuItem();\n        cbEnable.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_ENABLE\"));\n        cbEnable.setState(policy.getEnableManual());\n        cbEnable.setActionCommand(ACTION_COMMAND_CB_ENABLE);\n        cbEnable.addActionListener(this);\n\n        JCheckBoxMenuItem cbAlways = new JCheckBoxMenuItem();\n        cbAlways.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_AUTO\"));\n        cbAlways.setEnabled(policy.getEnableManual());\n        cbAlways.setState(policy.getEnableAlways());\n        cbAlways.setActionCommand(ACTION_COMMAND_CB_AUTO);\n        cbAlways.addActionListener(this);\n\n        JCheckBoxMenuItem cbRequire = new JCheckBoxMenuItem();\n        cbRequire.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_REQUIRE\"));\n        cbRequire.setEnabled(policy.getEnableManual());\n        cbRequire.setState(policy.getRequireEncryption());\n        cbRequire.setActionCommand(ACTION_COMMAND_CB_REQUIRE);\n        cbRequire.addActionListener(this);\n\n        JMenuItem cbReset = new JMenuItem();\n        cbReset.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_RESET\"));\n        cbReset.setActionCommand(ACTION_COMMAND_CB_RESET);\n        cbReset.addActionListener(this);\n\n        this.addSeparator();\n        this.add(cbEnable);\n        this.add(cbAlways);\n        this.add(cbRequire);\n        this.addSeparator();\n        this.add(cbReset);\n    }","commit_id":"2ab3f3bf0259b33a6985e861b0309d0ce4e118b0","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Gets the <code>JMenu<\/code> which is the component of this plugin. If it\n     * still doesn't exist, it's created.\n     * \n     * @return the <code>JMenu<\/code> which is the component of this plugin\n     */\n    private JMenu getMenu()\n    {\n        if (menu == null)\n        {\n            menu = new JMenu();\n\n            if (Container.CONTAINER_CONTACT_RIGHT_BUTTON_MENU\n                    .equals(getContainer()))\n            {\n                Icon icon\n                    = OtrActivator\n                        .resourceService\n                            .getImage(\"plugin.otr.MENU_ITEM_ICON_16x16\");\n\n                if (icon != null)\n                    menu.setIcon(icon);\n            }\n            \n            menu.setText(getName());\n        }\n        return menu;\n    }","id":24595,"modified_method":"/**\n     * Gets the <code>JMenu<\/code> which is the component of this plugin. If it\n     * still doesn't exist, it's created.\n     * \n     * @return the <code>JMenu<\/code> which is the component of this plugin\n     */\n    private JMenu getMenu()\n    {\n        if (menu == null)\n        {\n            menu = new JMenu();\n            menu.setText(getName());\n\n            if (Container.CONTAINER_CONTACT_RIGHT_BUTTON_MENU\n                    .equals(getContainer()))\n            {\n                Icon icon\n                    = OtrActivator\n                        .resourceService\n                            .getImage(\"plugin.otr.MENU_ITEM_ICON_16x16\");\n\n                if (icon != null)\n                    menu.setIcon(icon);\n            }\n\n            menu.getPopupMenu().addPopupMenuListener(this);\n        }\n        return menu;\n    }","commit_id":"2ab3f3bf0259b33a6985e861b0309d0ce4e118b0","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void setCurrentContact(MetaContact metaContact)\n    {\n        // Rebuild menu.\n        if (menu != null)\n            menu.removeAll();\n\n        if (metaContact == null)\n            return;\n\n        JMenu menu = getMenu();\n\n        Iterator<Contact> contacts = metaContact.getContacts();\n        while (contacts.hasNext())\n        {\n            menu.add(new OtrContactMenu(contacts.next()));\n        }\n\n        menu.addSeparator();\n\n        JMenuItem whatsThis = new JMenuItem();\n        whatsThis.setIcon(OtrActivator.resourceService\n            .getImage(\"plugin.otr.HELP_ICON_15x15\"));\n        whatsThis.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.WHATS_THIS\"));\n        whatsThis.addActionListener(new ActionListener()\n        {\n            public void actionPerformed(ActionEvent e)\n            {\n                OtrActivator.scOtrEngine.launchHelp();\n            }\n        });\n        menu.add(whatsThis);\n    }","id":24596,"modified_method":"public void setCurrentContact(MetaContact metaContact)\n    {\n        if (this.currentContact != metaContact)\n        {\n            this.currentContact = metaContact;\n\n            if ((menu != null) && menu.isPopupMenuVisible())\n                createOtrContactMenus(currentContact);\n        }\n    }","commit_id":"2ab3f3bf0259b33a6985e861b0309d0ce4e118b0","url":"https://github.com/jitsi/jitsi"},{"original_method":"public static String html2unicode(final String text) {\n        if (text == null) return null;\n        int p = 0, p1, q;\n        final StringBuffer sb = new StringBuffer(text.length());\n        String s;\n        Character r;\n        while (p < text.length()) {\n            p1 = text.indexOf('&', p);\n            if (p1 < 0) p1 = text.length();\n            sb.append(text.subSequence(p, p1));\n            p = p1;\n            if (p >= text.length()) break;\n            q = text.indexOf(';', p);\n            if (q < 0) {\n                p++;\n                continue;\n            }\n            s = text.substring(p, q + 1);\n            p = q + 1;\n            if (s.equals(amp_html)) {\n                sb.append(amp_unicode);\n                continue;\n            }\n            if ((r = html2unicode4xml.get(s)) != null) {\n                sb.append(r.charValue());\n                continue;\n            }\n            if ((r = html2unicode4html.get(s)) != null) {\n                sb.append(r);\n                continue;\n            }\n            // the entity is unknown, skip it\n        }\n        return new String(sb);\n    }","id":24597,"modified_method":"public static String html2unicode(final String text) {\n        if (text == null) return null;\n        int p = 0, p1, q;\n        final StringBuffer sb = new StringBuffer(text.length());\n        String s;\n        Character r;\n        while (p < text.length()) {\n            p1 = text.indexOf('&', p);\n            if (p1 < 0) p1 = text.length();\n            sb.append(text.subSequence(p, p1));\n            p = p1;\n            if (p >= text.length()) break;\n            q = text.indexOf(';', p);\n            if (q < 0) {\n                p++;\n                continue;\n            }\n            s = text.substring(p, q + 1);\n            p = q + 1;\n            if (s.equals(amp_html)) {\n                sb.append(amp_unicode);\n                continue;\n            }\n            if ((r = html2unicode4xml.get(s)) != null) {\n                sb.append(r.charValue());\n                continue;\n            }\n            if ((r = html2unicode4html.get(s)) != null) {\n                sb.append(r);\n                continue;\n            }\n            if (s.charAt(1) == '#') {\n                if (s.charAt(2) == 'x' || s.charAt(2) == 'X') {\n                    sb.append(new char[] {(char) Integer.parseInt(s.substring(3, s.length() - 1), 16)});\n                    continue;\n                }\n                sb.append(new char[] {(char) Integer.parseInt(s.substring(2, s.length() - 1))});\n                continue;\n            }\n            // the entity is unknown, skip it\n        }\n        return new String(sb);\n    }","commit_id":"2f496669088c7e2b81e2b84fde32e161e970fac6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private static String cleanLine(String s) {\r\n        /*\r\n        // may contain too many funny symbols\r\n        for (int i = 0; i < s.length(); i++)\r\n            if (s.charAt(i) < ' ') s = s.substring(0, i) + \" \" + s.substring(i + 1);\r\n        */\r\n\r\n        int p;\r\n\r\n        // CR/LF entfernen, dabei koennen doppelte Leerzeichen enstehen die aber weiter unten entfernt werden - thq\r\n        while ((p = s.indexOf(\"\\n\")) >= 0) s = s.substring(0, p) + ((p + 1 == s.length()) ? \"\" : \" \" + s.substring(p + 1));\r\n       \r\n        // remove double-spaces\r\n        while ((p = s.indexOf(\"  \")) >= 0) s = s.substring(0, p) + s.substring(p + 1);\r\n\r\n        // we don't accept headlines that are too short\r\n        s = s.trim();\r\n        if (s.length() < 4) s = \"\";\r\n\r\n        // return result\r\n        return s;\r\n    }","id":24598,"modified_method":"private static String cleanLine(String s) {\r\n        // may contain too many funny symbols\r\n        for (int i = 0; i < s.length(); i++)\r\n            if (s.charAt(i) < ' ') s = s.substring(0, i) + \" \" + s.substring(i + 1);\r\n\r\n        // remove double-spaces\r\n        int p;\r\n        while ((p = s.indexOf(\"  \")) >= 0) s = s.substring(0, p) + s.substring(p + 1);\r\n\r\n        // return result\r\n        return s.trim();\r\n    }","commit_id":"2f496669088c7e2b81e2b84fde32e161e970fac6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void scrapeText(final char[] newtext, final String insideTag) {\r\n        // System.out.println(\"SCRAPE: \" + new String(newtext));\r\n        final serverCharBuffer b = super.stripAll(new serverCharBuffer(newtext, newtext.length + 1)).trim();\r\n        if ((insideTag != null) && (!(insideTag.equals(\"a\")))) {\r\n            // texts inside tags sometimes have no punctuation at the line end\r\n            // this is bad for the text sematics, because it is not possible for the\r\n            // condenser to distinguish headlines from text beginnings.\r\n            // to make it easier for the condenser, a dot ('.') is appended in case that\r\n            // no punctuation is part of the newtext line\r\n            if ((b.length() != 0) && (!(punctuation(b.charAt(b.length() - 1))))) b.append((int) '.');\r\n            //System.out.println(\"*** Appended dot: \" + b.toString());\r\n        }\r\n        if (b.length() != 0) content.append(b).append(32);\r\n    }","id":24599,"modified_method":"public void scrapeText(final char[] newtext, final String insideTag) {\r\n        // System.out.println(\"SCRAPE: \" + new String(newtext));\r\n        String b = super.stripAll(new String(newtext)).trim();\r\n        if ((insideTag != null) && (!(insideTag.equals(\"a\")))) {\r\n            // texts inside tags sometimes have no punctuation at the line end\r\n            // this is bad for the text sematics, because it is not possible for the\r\n            // condenser to distinguish headlines from text beginnings.\r\n            // to make it easier for the condenser, a dot ('.') is appended in case that\r\n            // no punctuation is part of the newtext line\r\n            if ((b.length() != 0) && (!(punctuation(b.charAt(b.length() - 1))))) b = b + '.';\r\n            //System.out.println(\"*** Appended dot: \" + b.toString());\r\n        }\r\n        if (b.length() != 0) content.append(b).append(32);\r\n    }","commit_id":"2f496669088c7e2b81e2b84fde32e161e970fac6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void scrapeTag1(final String tagname, final Properties tagopts, final char[] text) {\r\n        // System.out.println(\"ScrapeTag1: tagname=\" + tagname + \", opts=\" + tagopts.toString() + \", text=\" + new String(text));\r\n        if ((tagname.equalsIgnoreCase(\"a\")) && (text.length < 2048)) {\r\n            final String href = tagopts.getProperty(\"href\", \"\");\r\n            yacyURL url;\r\n            if ((href.length() > 0) && ((url = absolutePath(href)) != null)) {\r\n                final String f = url.getFile();\r\n                final int p = f.lastIndexOf('.');\r\n                final String type = (p < 0) ? \"\" : f.substring(p + 1);\r\n                if (type.equals(\"png\") || type.equals(\"gif\") || type.equals(\"jpg\") || type.equals(\"jpeg\")) {\r\n                    // special handling of such urls: put them to the image urls\r\n                    final htmlFilterImageEntry ie = new htmlFilterImageEntry(url, super.stripAll(new serverCharBuffer(text)).trim().toString(), -1, -1);\r\n                    addImage(images, ie);\r\n                } else {\r\n                    anchors.put(url, super.stripAll(new serverCharBuffer(text)).trim().toString());\r\n                }\r\n            }\r\n        }\r\n        String h;\r\n        if ((tagname.equalsIgnoreCase(\"h1\")) && (text.length < 1024)) {\r\n            h = cleanLine(super.stripAll(new serverCharBuffer(text)).toString());\r\n            if (h.length() > 0) headlines[0].add(h);\r\n        }\r\n        if ((tagname.equalsIgnoreCase(\"h2\")) && (text.length < 1024)) {\r\n            h = cleanLine(super.stripAll(new serverCharBuffer(text)).toString());\r\n            if (h.length() > 0) headlines[1].add(h);\r\n        }\r\n        if ((tagname.equalsIgnoreCase(\"h3\")) && (text.length < 1024)) {\r\n            h = cleanLine(super.stripAll(new serverCharBuffer(text)).toString());\r\n            if (h.length() > 0) headlines[2].add(h);\r\n        }\r\n        if ((tagname.equalsIgnoreCase(\"h4\")) && (text.length < 1024)) {\r\n            h = cleanLine(super.stripAll(new serverCharBuffer(text)).toString());\r\n            if (h.length() > 0) headlines[3].add(h);\r\n        }\r\n        if ((tagname.equalsIgnoreCase(\"title\")) && (text.length < 1024)) {\r\n            title = cleanLine(super.stripAll(new serverCharBuffer(text)).toString());\r\n        }\r\n\r\n        // fire event\r\n        fireScrapeTag1(tagname, tagopts, text);\r\n    }","id":24600,"modified_method":"public void scrapeTag1(final String tagname, final Properties tagopts, final char[] text) {\r\n        // System.out.println(\"ScrapeTag1: tagname=\" + tagname + \", opts=\" + tagopts.toString() + \", text=\" + new String(text));\r\n        if ((tagname.equalsIgnoreCase(\"a\")) && (text.length < 2048)) {\r\n            final String href = tagopts.getProperty(\"href\", \"\");\r\n            yacyURL url;\r\n            if ((href.length() > 0) && ((url = absolutePath(href)) != null)) {\r\n                final String f = url.getFile();\r\n                final int p = f.lastIndexOf('.');\r\n                final String type = (p < 0) ? \"\" : f.substring(p + 1);\r\n                if (type.equals(\"png\") || type.equals(\"gif\") || type.equals(\"jpg\") || type.equals(\"jpeg\")) {\r\n                    // special handling of such urls: put them to the image urls\r\n                    final htmlFilterImageEntry ie = new htmlFilterImageEntry(url, super.stripAll(new String(text)).trim(), -1, -1);\r\n                    addImage(images, ie);\r\n                } else {\r\n                    anchors.put(url, super.stripAll(new String(text)).trim());\r\n                }\r\n            }\r\n        }\r\n        String h;\r\n        if ((tagname.equalsIgnoreCase(\"h1\")) && (text.length < 1024)) {\r\n            h = cleanLine(super.stripAll(new String(text)));\r\n            if (h.length() > 0) headlines[0].add(h);\r\n        }\r\n        if ((tagname.equalsIgnoreCase(\"h2\")) && (text.length < 1024)) {\r\n            h = cleanLine(super.stripAll(new String(text)));\r\n            if (h.length() > 0) headlines[1].add(h);\r\n        }\r\n        if ((tagname.equalsIgnoreCase(\"h3\")) && (text.length < 1024)) {\r\n            h = cleanLine(super.stripAll(new String(text)));\r\n            if (h.length() > 0) headlines[2].add(h);\r\n        }\r\n        if ((tagname.equalsIgnoreCase(\"h4\")) && (text.length < 1024)) {\r\n            h = cleanLine(super.stripAll(new String(text)));\r\n            if (h.length() > 0) headlines[3].add(h);\r\n        }\r\n        if ((tagname.equalsIgnoreCase(\"title\")) && (text.length < 1024)) {\r\n            title = cleanLine(super.stripAll(new String(text)));\r\n        }\r\n\r\n        // fire event\r\n        fireScrapeTag1(tagname, tagopts, text);\r\n    }","commit_id":"2f496669088c7e2b81e2b84fde32e161e970fac6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n    public static TreeSet<String>[] cleanQuery(String querystring) {\r\n    \t// returns two sets: a query set and a exclude set\r\n    \tif ((querystring == null) || (querystring.length() == 0)) return new TreeSet[]{new TreeSet<String>(kelondroNaturalOrder.naturalComparator), new TreeSet<String>(kelondroNaturalOrder.naturalComparator)};\r\n        \r\n        // convert Umlaute\r\n        querystring = htmlFilterAbstractScraper.convertUmlaute(new serverCharBuffer(querystring.toCharArray())).toString().toLowerCase().trim();\r\n        int c;\r\n        for (int i = 0; i < seps.length(); i++) {\r\n            while ((c = querystring.indexOf(seps.charAt(i))) >= 0) { querystring = querystring.substring(0, c) + (((c + 1) < querystring.length()) ? (\" \" + querystring.substring(c + 1)) : \"\"); }\r\n        }\r\n        \r\n        // the string is clean now, but we must generate a set out of it\r\n        final TreeSet<String> query = new TreeSet<String>(kelondroNaturalOrder.naturalComparator);\r\n        final TreeSet<String> exclude = new TreeSet<String>(kelondroNaturalOrder.naturalComparator);\r\n        final String[] a = querystring.split(\" \");\r\n        for (int i = 0; i < a.length; i++) {\r\n        \tif (a[i].startsWith(\"-\")) {\r\n        \t\texclude.add(a[i].substring(1));\r\n        \t} else {\r\n        \t\twhile ((c = a[i].indexOf('-')) >= 0) {\r\n        \t\t\tquery.add(a[i].substring(0, c));\r\n        \t\t\ta[i] = a[i].substring(c + 1);\r\n        \t\t}\r\n        \t\tif (a[i].length() > 0) query.add(a[i]);\r\n        \t}\r\n        }\r\n        return new TreeSet[]{query, exclude};\r\n    }","id":24601,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n    public static TreeSet<String>[] cleanQuery(String querystring) {\r\n    \t// returns two sets: a query set and a exclude set\r\n    \tif ((querystring == null) || (querystring.length() == 0)) return new TreeSet[]{new TreeSet<String>(kelondroNaturalOrder.naturalComparator), new TreeSet<String>(kelondroNaturalOrder.naturalComparator)};\r\n        \r\n        // convert Umlaute\r\n        querystring = htmlFilterAbstractScraper.stripAll(querystring).toLowerCase().trim();\r\n        int c;\r\n        for (int i = 0; i < seps.length(); i++) {\r\n            while ((c = querystring.indexOf(seps.charAt(i))) >= 0) { querystring = querystring.substring(0, c) + (((c + 1) < querystring.length()) ? (\" \" + querystring.substring(c + 1)) : \"\"); }\r\n        }\r\n        \r\n        // the string is clean now, but we must generate a set out of it\r\n        final TreeSet<String> query = new TreeSet<String>(kelondroNaturalOrder.naturalComparator);\r\n        final TreeSet<String> exclude = new TreeSet<String>(kelondroNaturalOrder.naturalComparator);\r\n        final String[] a = querystring.split(\" \");\r\n        for (int i = 0; i < a.length; i++) {\r\n        \tif (a[i].startsWith(\"-\")) {\r\n        \t\texclude.add(a[i].substring(1));\r\n        \t} else {\r\n        \t\twhile ((c = a[i].indexOf('-')) >= 0) {\r\n        \t\t\tquery.add(a[i].substring(0, c));\r\n        \t\t\ta[i] = a[i].substring(c + 1);\r\n        \t\t}\r\n        \t\tif (a[i].length() > 0) query.add(a[i]);\r\n        \t}\r\n        }\r\n        return new TreeSet[]{query, exclude};\r\n    }","commit_id":"2f496669088c7e2b81e2b84fde32e161e970fac6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public plasmaParserDocument parse(final yacyURL location, final String mimeType, final String charset, final InputStream source) throws ParserException, InterruptedException {\r\n\r\n        try {\r\n            final LinkedList<String> feedSections = new LinkedList<String>();\r\n            final HashMap<yacyURL, String> anchors = new HashMap<yacyURL, String>();\r\n            final HashMap<String, htmlFilterImageEntry> images  = new HashMap<String, htmlFilterImageEntry>();\r\n            final serverByteBuffer text = new serverByteBuffer();\r\n            final serverCharBuffer authors = new serverCharBuffer();\r\n            \r\n            final RSSFeed feed = new RSSReader(source).getFeed();\r\n            if (feed == null) throw new ParserException(\"no feed in document\",location);\r\n            if (feed.getChannel() == null) throw new ParserException(\"no channel in document\",location);\r\n            \r\n            // getting the rss feed title and description\r\n            final String feedTitle = feed.getChannel().getTitle();\r\n\r\n            // getting feed creator\r\n\t\t\tfinal String feedCreator = feed.getChannel().getAuthor();\r\n\t\t\tif (feedCreator != null && feedCreator.length() > 0) authors.append(\",\").append(feedCreator);            \r\n            \r\n            // getting the feed description\r\n            final String feedDescription = feed.getChannel().getDescription();\r\n            \r\n            if (feed.getImage() != null) {\r\n                final yacyURL imgURL = new yacyURL(feed.getImage(), null);\r\n                images.put(imgURL.hash(), new htmlFilterImageEntry(imgURL, feedTitle, -1, -1));\r\n            }            \r\n            \r\n            // loop through the feed items\r\n            for (final RSSMessage item: feed) {\r\n                    // check for interruption\r\n                    checkInterruption();\r\n                    \r\n        \t\t\tfinal String itemTitle = item.getTitle();\r\n                    final yacyURL    itemURL   = new yacyURL(item.getLink(), null);\r\n        \t\t\tfinal String itemDescr = item.getDescription();\r\n        \t\t\tfinal String itemCreator = item.getCreator();\r\n        \t\t\tif (itemCreator != null && itemCreator.length() > 0) authors.append(\",\").append(itemCreator);\r\n                    \r\n                    feedSections.add(itemTitle);\r\n                    anchors.put(itemURL, itemTitle);\r\n                    \r\n                \tif ((text.length() != 0) && (text.byteAt(text.length() - 1) != 32)) text.append((byte) 32);\r\n                \tserverCharBuffer scb = new serverCharBuffer(htmlFilterAbstractScraper.stripAll(new serverCharBuffer(itemDescr.toCharArray())));\r\n                \ttext.append(scb.trim().toString()).append(' ');\r\n                \tscb.close();\r\n                    \r\n                    final String itemContent = item.getDescription();\r\n                    if ((itemContent != null) && (itemContent.length() > 0)) {\r\n                        \r\n                        final htmlFilterContentScraper scraper = new htmlFilterContentScraper(itemURL);\r\n                        final Writer writer = new htmlFilterWriter(null, null, scraper, null, false);\r\n                        serverFileUtils.copy(new ByteArrayInputStream(itemContent.getBytes(\"UTF-8\")), writer, Charset.forName(\"UTF-8\"));\r\n                        \r\n                        final String itemHeadline = scraper.getTitle();     \r\n                        if ((itemHeadline != null) && (itemHeadline.length() > 0)) {\r\n                            feedSections.add(itemHeadline);\r\n                        }\r\n                        \r\n                        final Map<yacyURL, String> itemLinks = scraper.getAnchors();\r\n                        if ((itemLinks != null) && (itemLinks.size() > 0)) {\r\n                            anchors.putAll(itemLinks);\r\n                        }\r\n                        \r\n                        final HashMap<String, htmlFilterImageEntry> itemImages = scraper.getImages();\r\n                        if ((itemImages != null) && (itemImages.size() > 0)) {\r\n                            htmlFilterContentScraper.addAllImages(images, itemImages);\r\n                        }\r\n                        \r\n                        final byte[] extractedText = scraper.getText();\r\n                        if ((extractedText != null) && (extractedText.length > 0)) {\r\n\t\t\t\t\t\t\tif ((text.length() != 0) && (text.byteAt(text.length() - 1) != 32)) text.append((byte) 32);\r\n\t\t\t\t\t\t\ttext.append(scraper.getText());\r\n                        }\r\n                        \r\n                    }\r\n            }\r\n            \r\n            final plasmaParserDocument theDoc = new plasmaParserDocument(\r\n                    location,\r\n                    mimeType,\r\n                    \"UTF-8\",\r\n                    null,\r\n                    null,\r\n                    feedTitle,\r\n                    (authors.length() > 0)?authors.toString(1,authors.length()):\"\",\r\n                    feedSections.toArray(new String[feedSections.size()]),\r\n                    feedDescription,\r\n                    text.getBytes(),\r\n                    anchors,\r\n                    images);            \r\n            // close streams\r\n            text.close();\r\n            authors.close();\r\n            \r\n            \r\n            return theDoc;\r\n            \r\n        } catch (final InterruptedException e) {\r\n        \tthrow e;\r\n        } catch (final IOException e) {\r\n            throw new ParserException(\"Unexpected error while parsing rss file.\" + e.getMessage(),location); \r\n        }\r\n\t}","id":24602,"modified_method":"public plasmaParserDocument parse(final yacyURL location, final String mimeType, final String charset, final InputStream source) throws ParserException, InterruptedException {\r\n\r\n        try {\r\n            final LinkedList<String> feedSections = new LinkedList<String>();\r\n            final HashMap<yacyURL, String> anchors = new HashMap<yacyURL, String>();\r\n            final HashMap<String, htmlFilterImageEntry> images  = new HashMap<String, htmlFilterImageEntry>();\r\n            final serverByteBuffer text = new serverByteBuffer();\r\n            final serverCharBuffer authors = new serverCharBuffer();\r\n            \r\n            final RSSFeed feed = new RSSReader(source).getFeed();\r\n            if (feed == null) throw new ParserException(\"no feed in document\",location);\r\n            if (feed.getChannel() == null) throw new ParserException(\"no channel in document\",location);\r\n            \r\n            // getting the rss feed title and description\r\n            final String feedTitle = feed.getChannel().getTitle();\r\n\r\n            // getting feed creator\r\n\t\t\tfinal String feedCreator = feed.getChannel().getAuthor();\r\n\t\t\tif (feedCreator != null && feedCreator.length() > 0) authors.append(\",\").append(feedCreator);            \r\n            \r\n            // getting the feed description\r\n            final String feedDescription = feed.getChannel().getDescription();\r\n            \r\n            if (feed.getImage() != null) {\r\n                final yacyURL imgURL = new yacyURL(feed.getImage(), null);\r\n                images.put(imgURL.hash(), new htmlFilterImageEntry(imgURL, feedTitle, -1, -1));\r\n            }            \r\n            \r\n            // loop through the feed items\r\n            for (final RSSMessage item: feed) {\r\n                    // check for interruption\r\n                    checkInterruption();\r\n                    \r\n        \t\t\tfinal String itemTitle = item.getTitle();\r\n                    final yacyURL    itemURL   = new yacyURL(item.getLink(), null);\r\n        \t\t\tfinal String itemDescr = item.getDescription();\r\n        \t\t\tfinal String itemCreator = item.getCreator();\r\n        \t\t\tif (itemCreator != null && itemCreator.length() > 0) authors.append(\",\").append(itemCreator);\r\n                    \r\n                    feedSections.add(itemTitle);\r\n                    anchors.put(itemURL, itemTitle);\r\n                    \r\n                \tif ((text.length() != 0) && (text.byteAt(text.length() - 1) != 32)) text.append((byte) 32);\r\n                \ttext.append(htmlFilterAbstractScraper.stripAll(itemDescr).trim()).append(' ');\r\n                    \r\n                    final String itemContent = item.getDescription();\r\n                    if ((itemContent != null) && (itemContent.length() > 0)) {\r\n                        \r\n                        final htmlFilterContentScraper scraper = new htmlFilterContentScraper(itemURL);\r\n                        final Writer writer = new htmlFilterWriter(null, null, scraper, null, false);\r\n                        serverFileUtils.copy(new ByteArrayInputStream(itemContent.getBytes(\"UTF-8\")), writer, Charset.forName(\"UTF-8\"));\r\n                        \r\n                        final String itemHeadline = scraper.getTitle();     \r\n                        if ((itemHeadline != null) && (itemHeadline.length() > 0)) {\r\n                            feedSections.add(itemHeadline);\r\n                        }\r\n                        \r\n                        final Map<yacyURL, String> itemLinks = scraper.getAnchors();\r\n                        if ((itemLinks != null) && (itemLinks.size() > 0)) {\r\n                            anchors.putAll(itemLinks);\r\n                        }\r\n                        \r\n                        final HashMap<String, htmlFilterImageEntry> itemImages = scraper.getImages();\r\n                        if ((itemImages != null) && (itemImages.size() > 0)) {\r\n                            htmlFilterContentScraper.addAllImages(images, itemImages);\r\n                        }\r\n                        \r\n                        final byte[] extractedText = scraper.getText();\r\n                        if ((extractedText != null) && (extractedText.length > 0)) {\r\n\t\t\t\t\t\t\tif ((text.length() != 0) && (text.byteAt(text.length() - 1) != 32)) text.append((byte) 32);\r\n\t\t\t\t\t\t\ttext.append(scraper.getText());\r\n                        }\r\n                        \r\n                    }\r\n            }\r\n            \r\n            final plasmaParserDocument theDoc = new plasmaParserDocument(\r\n                    location,\r\n                    mimeType,\r\n                    \"UTF-8\",\r\n                    null,\r\n                    null,\r\n                    feedTitle,\r\n                    (authors.length() > 0)?authors.toString(1,authors.length()):\"\",\r\n                    feedSections.toArray(new String[feedSections.size()]),\r\n                    feedDescription,\r\n                    text.getBytes(),\r\n                    anchors,\r\n                    images);            \r\n            // close streams\r\n            text.close();\r\n            authors.close();\r\n            \r\n            \r\n            return theDoc;\r\n            \r\n        } catch (final InterruptedException e) {\r\n        \tthrow e;\r\n        } catch (final IOException e) {\r\n            throw new ParserException(\"Unexpected error while parsing rss file.\" + e.getMessage(),location); \r\n        }\r\n\t}","commit_id":"2f496669088c7e2b81e2b84fde32e161e970fac6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void registerServlet(\n\t\t\tString urlPattern, Servlet servlet,\n\t\t\tDictionary<String, String> initParameters, HttpContext httpContext)\n\t\tthrows NamespaceException, ServletException {\n\n\t\tList<String> urlPatterns = Arrays.asList(urlPattern);\n\n\t\tregisterServlet(\n\t\t\turlPattern, urlPatterns, servlet, initParameters, httpContext);\n\t}","id":24603,"modified_method":"public void registerServlet(\n\t\t\tString servletName, String urlPattern, Servlet servlet,\n\t\t\tDictionary<String, String> initParameters, HttpContext httpContext)\n\t\tthrows NamespaceException, ServletException {\n\n\t\tList<String> urlPatterns = Arrays.asList(urlPattern);\n\n\t\tregisterServlet(\n\t\t\tservletName, urlPatterns, servlet, initParameters, httpContext);\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void registerFilter(\n\t\tString urlPattern, Filter filter,\n\t\tDictionary<String, String> initParameters, HttpContext httpContext) {\n\t}","id":24604,"modified_method":"public void registerFilter(\n\t\tString filterName, String urlPattern, Filter filter,\n\t\tDictionary<String, String> initParameters, HttpContext httpContext) {\n\n\t\tList<String> urlPatterns = Arrays.asList(urlPattern);\n\n\t\tregisterFilter(\n\t\t\tfilterName, urlPatterns, filter, initParameters, httpContext);\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void registerService(\n\t\t\tBundleServletContext bundleServletContext,\n\t\t\tServiceReference<Filter> serviceReference, Filter filter,\n\t\t\tDictionary<String, String> initParameters, HttpContext httpContext)\n\t\tthrows Exception {\n\n\t\tString pattern = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"pattern\"));\n\n\t\tbundleServletContext.registerFilter(\n\t\t\tpattern, filter, initParameters, httpContext);\n\t}","id":24605,"modified_method":"@Override\n\tprotected void registerService(\n\t\t\tBundleServletContext bundleServletContext,\n\t\t\tServiceReference<Filter> serviceReference, Filter filter,\n\t\t\tDictionary<String, String> initParameters, HttpContext httpContext)\n\t\tthrows Exception {\n\n\t\tString filterName = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"filterName\"));\n\t\tString urlPattern = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"urlPattern\"));\n\n\t\tbundleServletContext.registerFilter(\n\t\t\tfilterName, urlPattern, filter, initParameters, httpContext);\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void unregisterService(\n\t\tBundleServletContext bundleServletContext,\n\t\tServiceReference<Filter> serviceReference) {\n\n\t\tString pattern = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"pattern\"));\n\n\t\tbundleServletContext.unregisterFilter(pattern);\n\t}","id":24606,"modified_method":"@Override\n\tprotected void unregisterService(\n\t\tBundleServletContext bundleServletContext,\n\t\tServiceReference<Filter> serviceReference) {\n\n\t\tString filterName = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"filterName\"));\n\n\t\tbundleServletContext.unregisterFilter(filterName);\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initFilters(\n\t\tExtendedHttpService extendedHttpService, HttpContext httpContext) {\n\n\t\tMap<String, FilterDefinition> filterDefinitions =\n\t\t\t_webXML.getFilterDefinitions();\n\n\t\tfor (Map.Entry<String, FilterDefinition> entry :\n\t\t\t\tfilterDefinitions.entrySet()) {\n\n\t\t\tFilterDefinition filterDefinition = entry.getValue();\n\n\t\t\tList<String> urlPatterns = filterDefinition.getURLPatterns();\n\n\t\t\tfor (String urlPattern : urlPatterns) {\n\t\t\t\ttry {\n\t\t\t\t\textendedHttpService.registerFilter(\n\t\t\t\t\t\turlPattern, filterDefinition.getFilter(),\n\t\t\t\t\t\tfilterDefinition.getInitParameters(), httpContext);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":24607,"modified_method":"protected void initFilters(\n\t\tExtendedHttpService extendedHttpService, HttpContext httpContext) {\n\n\t\tMap<String, FilterDefinition> filterDefinitions =\n\t\t\t_webXML.getFilterDefinitions();\n\n\t\tfor (Map.Entry<String, FilterDefinition> entry :\n\t\t\t\tfilterDefinitions.entrySet()) {\n\n\t\t\tFilterDefinition filterDefinition = entry.getValue();\n\n\t\t\ttry {\n\t\t\t\textendedHttpService.registerFilter(\n\t\t\t\t\tfilterDefinition.getName(),\n\t\t\t\t\tfilterDefinition.getURLPatterns(),\n\t\t\t\t\tfilterDefinition.getFilter(),\n\t\t\t\t\tfilterDefinition.getInitParameters(), httpContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void destroyFilters(ExtendedHttpService extendedHttpService) {\n\t\tMap<String, FilterDefinition> filterDefinitions =\n\t\t\t_webXML.getFilterDefinitions();\n\n\t\tfor (String name : filterDefinitions.keySet()) {\n\t\t\ttry {\n\t\t\t\textendedHttpService.unregisterFilter(name);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\t}","id":24608,"modified_method":"protected void destroyFilters(ExtendedHttpService extendedHttpService) {\n\t\tMap<String, FilterDefinition> filterDefinitions =\n\t\t\t_webXML.getFilterDefinitions();\n\n\t\tfor (String filterName : filterDefinitions.keySet()) {\n\t\t\ttry {\n\t\t\t\textendedHttpService.unregisterFilter(filterName);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void destroyServlets(ExtendedHttpService extendedHttpService) {\n\t\tMap<String, ServletDefinition> servlets =\n\t\t\t_webXML.getServletDefinitions();\n\n\t\tfor (String name : servlets.keySet()) {\n\t\t\textendedHttpService.unregisterServlet(name);\n\t\t}\n\t}","id":24609,"modified_method":"protected void destroyServlets(ExtendedHttpService extendedHttpService) {\n\t\tMap<String, ServletDefinition> servlets =\n\t\t\t_webXML.getServletDefinitions();\n\n\t\tfor (String servletName : servlets.keySet()) {\n\t\t\textendedHttpService.unregisterServlet(servletName);\n\t\t}\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void registerFilter(\n\t\tString urlPattern, Filter filter, Map<String, String> initParameters,\n\t\tHttpContext httpContext) {\n\t}","id":24610,"modified_method":"public void registerFilter(\n\t\tString filterName, List<String> urlPatterns, Filter filter,\n\t\tMap<String, String> initParameters, HttpContext httpContext) {\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void registerFilter(\n\t\tString urlPattern, Filter filter, Map<String, String> initParameters,\n\t\tHttpContext httpContext) {\n\t}","id":24611,"modified_method":"public void registerFilter(\n\t\tString filterName, List<String> urlPatterns, Filter filter,\n\t\tMap<String, String> initParameters, HttpContext httpContext) {\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void registerService(\n\t\t\tBundleServletContext bundleServletContext,\n\t\t\tServiceReference<Servlet> serviceReference, Servlet servlet,\n\t\t\tDictionary<String, String> initParameters, HttpContext httpContext)\n\t\tthrows Exception {\n\n\t\tString alias = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"alias\"));\n\n\t\tbundleServletContext.registerServlet(\n\t\t\talias, servlet, initParameters, httpContext);\n\t}","id":24612,"modified_method":"@Override\n\tprotected void registerService(\n\t\t\tBundleServletContext bundleServletContext,\n\t\t\tServiceReference<Servlet> serviceReference, Servlet servlet,\n\t\t\tDictionary<String, String> initParameters, HttpContext httpContext)\n\t\tthrows Exception {\n\n\t\tString servletName = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"servletName\"));\n\t\tString urlPattern = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"urlPattern\"));\n\n\t\tbundleServletContext.registerServlet(\n\t\t\tservletName, urlPattern, servlet, initParameters, httpContext);\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void unregisterService(\n\t\tBundleServletContext bundleServletContext,\n\t\tServiceReference<Servlet> serviceReference) {\n\n\t\tString alias = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"alias\"));\n\n\t\tbundleServletContext.unregisterServlet(alias);\n\t}","id":24613,"modified_method":"@Override\n\tprotected void unregisterService(\n\t\tBundleServletContext bundleServletContext,\n\t\tServiceReference<Servlet> serviceReference) {\n\n\t\tString servletName = GetterUtil.getString(\n\t\t\tserviceReference.getProperty(\"servletName\"));\n\n\t\tbundleServletContext.unregisterServlet(servletName);\n\t}","commit_id":"01eceb4dda1cc358eaea7a04d62a9ae71d2a8783","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private URL getResource(String path) {\n\t\t\ttry {\n\t\t\t\tif (path.charAt(0) != '/') {\n\t\t\t\t\tpath = '/' + path;\n\t\t\t\t}\n\n\t\t\t\tURL url = getExtension(path);\n\n\t\t\t\tif (url != null) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\turl = _servletContext.getResource(path);\n\n\t\t\t\tif (url != null) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\turl = _servletContext.getClassLoader().getResource(path);\n\n\t\t\t\tif (url != null) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\tif (!path.startsWith(\"/META-INF/\")) {\n\t\t\t\t\turl = _servletContext.getResource(\n\t\t\t\t\t\t\"/META-INF/resources\".concat(path));\n\t\t\t\t}\n\n\t\t\t\tif (url != null) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 2; i < _allParticipatingBundles.length; i++) {\n\t\t\t\t\turl = _allParticipatingBundles[i].getEntry(path);\n\n\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\treturn url;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn _jspBundle.getEntry(path);\n\t\t\t}\n\t\t\tcatch (MalformedURLException murle) {\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}","id":24614,"modified_method":"private URL getResource(String path) {\n\t\t\ttry {\n\t\t\t\tif ((path == null) || path.equals(StringPool.BLANK)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (path.charAt(0) != '/') {\n\t\t\t\t\tpath = '/' + path;\n\t\t\t\t}\n\n\t\t\t\tURL url = getExtension(path);\n\n\t\t\t\tif (url != null) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\turl = _servletContext.getResource(path);\n\n\t\t\t\tif (url != null) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\turl = _servletContext.getClassLoader().getResource(path);\n\n\t\t\t\tif (url != null) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\tif (!path.startsWith(\"/META-INF/\")) {\n\t\t\t\t\turl = _servletContext.getResource(\n\t\t\t\t\t\t\"/META-INF/resources\".concat(path));\n\t\t\t\t}\n\n\t\t\t\tif (url != null) {\n\t\t\t\t\treturn url;\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 2; i < _allParticipatingBundles.length; i++) {\n\t\t\t\t\turl = _allParticipatingBundles[i].getEntry(path);\n\n\t\t\t\t\tif (url != null) {\n\t\t\t\t\t\treturn url;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn _jspBundle.getEntry(path);\n\t\t\t}\n\t\t\tcatch (MalformedURLException murle) {\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}","commit_id":"627d4b7cc4337fff42ff1a58a260e89720bb6938","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\t\tpublic void service(ServletRequest request, ServletResponse response)\n\t\t\tthrows IOException, ServletException {\n\n\t\t\t_servlet.service(request, response);\n\t\t}","id":24615,"modified_method":"@Override\n\t\tpublic void service(ServletRequest request, ServletResponse response)\n\t\t\tthrows IOException, ServletException {\n\n\t\t\tString curJspFile = (String)request.getAttribute(\n\t\t\t\torg.apache.jasper.Constants.JSP_FILE);\n\n\t\t\tif (jspFile != null) {\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\torg.apache.jasper.Constants.JSP_FILE, jspFile);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\t_servlet.service(request, response);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\torg.apache.jasper.Constants.JSP_FILE, curJspFile);\n\t\t\t}\n\t\t}","commit_id":"627d4b7cc4337fff42ff1a58a260e89720bb6938","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initServlets(WebXMLDefinition webXMLDefinition)\n\t\tthrows Exception {\n\n\t\tMap<String, ServletDefinition> servletDefinitions =\n\t\t\twebXMLDefinition.getServletDefinitions();\n\n\t\tfor (Entry<String, ServletDefinition> entry :\n\t\t\t\tservletDefinitions.entrySet()) {\n\n\t\t\tServletDefinition servletDefinition = entry.getValue();\n\n\t\t\tDictionary<String, Object> properties = new Hashtable<>();\n\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_SELECT,\n\t\t\t\t_contextName);\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_ASYNC_SUPPORTED,\n\t\t\t\tservletDefinition.isAsyncSupported());\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_ERROR_PAGE,\n\t\t\t\tservletDefinition.getErrorPages());\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_NAME,\n\t\t\t\tservletDefinition.getName());\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n\t\t\t\tservletDefinition.getURLPatterns());\n\n\t\t\tMap<String, String> initParameters =\n\t\t\t\tservletDefinition.getInitParameters();\n\n\t\t\tfor (Entry<String, String> initParametersEntry :\n\t\t\t\t\tinitParameters.entrySet()) {\n\n\t\t\t\tString key = initParametersEntry.getKey();\n\t\t\t\tString value = initParametersEntry.getValue();\n\n\t\t\t\tproperties.put(\n\t\t\t\t\tHttpWhiteboardConstants.\n\t\t\t\t\t\tHTTP_WHITEBOARD_SERVLET_INIT_PARAM_PREFIX + key,\n\t\t\t\t\tvalue);\n\t\t\t}\n\n\t\t\tServletExceptionAdapter servletExceptionAdaptor =\n\t\t\t\tnew ServletExceptionAdapter(servletDefinition.getServlet());\n\n\t\t\tServiceRegistration<Servlet> serviceRegistration =\n\t\t\t\t_bundleContext.registerService(\n\t\t\t\t\tServlet.class, servletExceptionAdaptor, properties);\n\n\t\t\tException exception = servletExceptionAdaptor.getException();\n\n\t\t\tif (exception != null) {\n\t\t\t\tserviceRegistration.unregister();\n\n\t\t\t\tthrow exception;\n\t\t\t}\n\n\t\t\t_servletRegistrations.add(serviceRegistration);\n\t\t}\n\t}","id":24616,"modified_method":"protected void initServlets(WebXMLDefinition webXMLDefinition)\n\t\tthrows Exception {\n\n\t\tMap<String, ServletDefinition> servletDefinitions =\n\t\t\twebXMLDefinition.getServletDefinitions();\n\n\t\tfor (Entry<String, ServletDefinition> entry :\n\t\t\t\tservletDefinitions.entrySet()) {\n\n\t\t\tServletDefinition servletDefinition = entry.getValue();\n\n\t\t\tDictionary<String, Object> properties = new Hashtable<>();\n\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_SELECT,\n\t\t\t\t_contextName);\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_ASYNC_SUPPORTED,\n\t\t\t\tservletDefinition.isAsyncSupported());\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_ERROR_PAGE,\n\t\t\t\tservletDefinition.getErrorPages());\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_NAME,\n\t\t\t\tservletDefinition.getName());\n\n\t\t\tString jspFile = servletDefinition.getJspFile();\n\t\t\tList<String> urlPatterns = servletDefinition.getURLPatterns();\n\n\t\t\tif (urlPatterns.isEmpty() && (jspFile != null)) {\n\t\t\t\turlPatterns.add(jspFile);\n\t\t\t}\n\n\t\t\tproperties.put(\n\t\t\t\tHttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n\t\t\t\turlPatterns);\n\n\t\t\tMap<String, String> initParameters =\n\t\t\t\tservletDefinition.getInitParameters();\n\n\t\t\tfor (Entry<String, String> initParametersEntry :\n\t\t\t\t\tinitParameters.entrySet()) {\n\n\t\t\t\tString key = initParametersEntry.getKey();\n\t\t\t\tString value = initParametersEntry.getValue();\n\n\t\t\t\tproperties.put(\n\t\t\t\t\tHttpWhiteboardConstants.\n\t\t\t\t\t\tHTTP_WHITEBOARD_SERVLET_INIT_PARAM_PREFIX + key,\n\t\t\t\t\tvalue);\n\t\t\t}\n\n\t\t\tServletExceptionAdapter servletExceptionAdaptor =\n\t\t\t\tnew ServletExceptionAdapter(servletDefinition.getServlet());\n\n\t\t\tServiceRegistration<Servlet> serviceRegistration =\n\t\t\t\t_bundleContext.registerService(\n\t\t\t\t\tServlet.class, servletExceptionAdaptor, properties);\n\n\t\t\tException exception = servletExceptionAdaptor.getException();\n\n\t\t\tif (exception != null) {\n\t\t\t\tserviceRegistration.unregister();\n\n\t\t\t\tthrow exception;\n\t\t\t}\n\n\t\t\t_servletRegistrations.add(serviceRegistration);\n\t\t}\n\t}","commit_id":"627d4b7cc4337fff42ff1a58a260e89720bb6938","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic void endElement(String uri, String localName, String qName) {\n\t\tif (qName.equals(\"async-supported\")) {\n\t\t\tboolean asyncSupported = GetterUtil.getBoolean(_stack.pop());\n\n\t\t\tif (_filterDefinition != null) {\n\t\t\t\t_filterDefinition.setAsyncSupported(asyncSupported);\n\t\t\t}\n\t\t\telse if (_servletDefinition != null) {\n\t\t\t\t_servletDefinition.setAsyncSupported(asyncSupported);\n\t\t\t}\n\t\t}\n\t\telse if (qName.equals(\"context-param\")) {\n\t\t\t_webXMLDefinition.setContextParameter(_paramName, _paramValue);\n\n\t\t\t_paramName = null;\n\t\t\t_paramValue = null;\n\t\t}\n\t\telse if (qName.equals(\"dispatcher\")) {\n\t\t\tString dispatcher = String.valueOf(_stack.pop());\n\n\t\t\tdispatcher = dispatcher.toUpperCase();\n\t\t\tdispatcher = dispatcher.trim();\n\n\t\t\t_filterMapping.dispatchers.add(dispatcher);\n\t\t}\n\t\telse if (qName.equals(\"filter\")) {\n\t\t\tif (_filterDefinition.getFilter() != null) {\n\t\t\t\t_webXMLDefinition.setFilterDefinition(\n\t\t\t\t\t_filterDefinition.getName(), _filterDefinition);\n\t\t\t}\n\n\t\t\t_filterDefinition = null;\n\t\t}\n\t\telse if (qName.equals(\"filter-class\")) {\n\t\t\tString filterClassName = String.valueOf(_stack.pop());\n\n\t\t\tFilter filter = _getFilterInstance(filterClassName.trim());\n\n\t\t\t_filterDefinition.setFilter(filter);\n\t\t}\n\t\telse if (qName.equals(\"filter-mapping\")) {\n\t\t\tMap<String, FilterDefinition> filterDefinitions =\n\t\t\t\t_webXMLDefinition.getFilterDefinitions();\n\n\t\t\tFilterDefinition filterDefinition = filterDefinitions.get(\n\t\t\t\t_filterMapping.filterName);\n\n\t\t\tif (filterDefinition != null) {\n\t\t\t\tfilterDefinition.setDispatchers(_filterMapping.dispatchers);\n\n\t\t\t\tif (_filterMapping.servletName != null) {\n\t\t\t\t\tList<String> servletNames =\n\t\t\t\t\t\tfilterDefinition.getServletNames();\n\n\t\t\t\t\tservletNames.add(_filterMapping.servletName);\n\t\t\t\t}\n\n\t\t\t\tfilterDefinition.setURLPatterns(_filterMapping.urlPatterns);\n\t\t\t}\n\n\t\t\t_filterMapping = null;\n\t\t}\n\t\telse if (qName.equals(\"filter-name\")) {\n\t\t\tif (_filterMapping != null) {\n\t\t\t\tString filterName = String.valueOf(_stack.pop());\n\n\t\t\t\t_filterMapping.filterName = filterName.trim();\n\t\t\t}\n\t\t\telse if (_filterDefinition != null) {\n\t\t\t\tString filterName = String.valueOf(_stack.pop());\n\n\t\t\t\t_filterDefinition.setName(filterName.trim());\n\t\t\t}\n\t\t}\n\t\telse if (qName.equals(\"init-param\")) {\n\t\t\tif (_filterDefinition != null) {\n\t\t\t\t_filterDefinition.setInitParameter(_paramName, _paramValue);\n\t\t\t}\n\t\t\telse if (_servletDefinition != null) {\n\t\t\t\t_servletDefinition.setInitParameter(_paramName, _paramValue);\n\t\t\t}\n\n\t\t\t_paramName = null;\n\t\t\t_paramValue = null;\n\t\t}\n\t\telse if (qName.equals(\"jsp-config\")) {\n\t\t\t_webXMLDefinition.setJspTaglibMappings(_jspConfig.mappings);\n\n\t\t\t_jspConfig = null;\n\t\t}\n\t\telse if (qName.equals(\"listener\")) {\n\t\t\tif (_listenerDefinition.getEventListener() != null) {\n\t\t\t\t_webXMLDefinition.addListenerDefinition(_listenerDefinition);\n\t\t\t}\n\n\t\t\t_listenerDefinition = null;\n\t\t}\n\t\telse if (qName.equals(\"listener-class\")) {\n\t\t\tString listenerClassName = String.valueOf(_stack.pop());\n\n\t\t\tEventListener eventListener = _getListenerInstance(\n\t\t\t\tlistenerClassName);\n\n\t\t\t_listenerDefinition.setEventListener(eventListener);\n\t\t}\n\t\telse if (qName.equals(\"param-name\")) {\n\t\t\t_paramName = String.valueOf(_stack.pop());\n\t\t\t_paramName = _paramName.trim();\n\t\t}\n\t\telse if (qName.equals(\"param-value\")) {\n\t\t\t_paramValue = String.valueOf(_stack.pop());\n\t\t\t_paramValue = _paramValue.trim();\n\t\t}\n\t\telse if (qName.equals(\"servlet\")) {\n\t\t\tif (_servletDefinition.getServlet() != null) {\n\t\t\t\t_webXMLDefinition.setServletDefinition(\n\t\t\t\t\t_servletDefinition.getName(), _servletDefinition);\n\t\t\t}\n\n\t\t\t_servletDefinition = null;\n\t\t}\n\t\telse if (qName.equals(\"servlet-class\")) {\n\t\t\tString servletClassName = String.valueOf(_stack.pop());\n\n\t\t\tServlet servlet = _getServletInstance(servletClassName.trim());\n\n\t\t\t_servletDefinition.setServlet(servlet);\n\t\t}\n\t\telse if (qName.equals(\"servlet-mapping\")) {\n\t\t\tMap<String, ServletDefinition> servletDefinitions =\n\t\t\t\t_webXMLDefinition.getServletDefinitions();\n\n\t\t\tServletDefinition servletDefinition = servletDefinitions.get(\n\t\t\t\t_servletMapping.servletName);\n\n\t\t\tif (servletDefinition != null) {\n\t\t\t\tservletDefinition.setURLPatterns(_servletMapping.urlPatterns);\n\t\t\t}\n\n\t\t\t_servletMapping = null;\n\t\t}\n\t\telse if (qName.equals(\"servlet-name\")) {\n\t\t\tif (_filterMapping != null) {\n\t\t\t\tString servletName = String.valueOf(_stack.pop());\n\n\t\t\t\t_filterMapping.servletName = servletName.trim();\n\t\t\t}\n\t\t\telse if (_servletDefinition != null) {\n\t\t\t\tString servletName = String.valueOf(_stack.pop());\n\n\t\t\t\t_servletDefinition.setName(servletName.trim());\n\t\t\t}\n\t\t\telse if (_servletMapping != null) {\n\t\t\t\tString servletName = String.valueOf(_stack.pop());\n\n\t\t\t\t_servletMapping.servletName = servletName.trim();\n\t\t\t}\n\t\t}\n\t\telse if (qName.equals(\"taglib\")) {\n\t\t\t_jspConfig.mappings.put(_taglibUri, _taglibLocation);\n\n\t\t\t_taglibUri = null;\n\t\t\t_taglibLocation = null;\n\t\t}\n\t\telse if (qName.equals(\"taglib-location\")) {\n\t\t\t_taglibLocation = String.valueOf(_stack.pop());\n\t\t}\n\t\telse if (qName.equals(\"taglib-uri\")) {\n\t\t\t_taglibUri = String.valueOf(_stack.pop());\n\t\t}\n\t\telse if (qName.equals(\"url-pattern\")) {\n\t\t\tif (_filterMapping != null) {\n\t\t\t\tString urlPattern = String.valueOf(_stack.pop());\n\n\t\t\t\t_filterMapping.urlPatterns.add(urlPattern.trim());\n\t\t\t}\n\t\t\telse if (_servletMapping != null) {\n\t\t\t\tString urlPattern = String.valueOf(_stack.pop());\n\n\t\t\t\t_servletMapping.urlPatterns.add(urlPattern.trim());\n\t\t\t}\n\t\t}\n\t}","id":24617,"modified_method":"@Override\n\tpublic void endElement(String uri, String localName, String qName) {\n\t\tif (qName.equals(\"async-supported\")) {\n\t\t\tboolean asyncSupported = GetterUtil.getBoolean(_stack.pop());\n\n\t\t\tif (_filterDefinition != null) {\n\t\t\t\t_filterDefinition.setAsyncSupported(asyncSupported);\n\t\t\t}\n\t\t\telse if (_servletDefinition != null) {\n\t\t\t\t_servletDefinition.setAsyncSupported(asyncSupported);\n\t\t\t}\n\t\t}\n\t\telse if (qName.equals(\"context-param\")) {\n\t\t\t_webXMLDefinition.setContextParameter(_paramName, _paramValue);\n\n\t\t\t_paramName = null;\n\t\t\t_paramValue = null;\n\t\t}\n\t\telse if (qName.equals(\"dispatcher\")) {\n\t\t\tString dispatcher = String.valueOf(_stack.pop());\n\n\t\t\tdispatcher = dispatcher.toUpperCase();\n\t\t\tdispatcher = dispatcher.trim();\n\n\t\t\t_filterMapping.dispatchers.add(dispatcher);\n\t\t}\n\t\telse if (qName.equals(\"filter\")) {\n\t\t\tif (_filterDefinition.getFilter() != null) {\n\t\t\t\t_webXMLDefinition.setFilterDefinition(\n\t\t\t\t\t_filterDefinition.getName(), _filterDefinition);\n\t\t\t}\n\n\t\t\t_filterDefinition = null;\n\t\t}\n\t\telse if (qName.equals(\"filter-class\")) {\n\t\t\tString filterClassName = String.valueOf(_stack.pop());\n\n\t\t\tFilter filter = _getFilterInstance(filterClassName.trim());\n\n\t\t\t_filterDefinition.setFilter(filter);\n\t\t}\n\t\telse if (qName.equals(\"filter-mapping\")) {\n\t\t\tMap<String, FilterDefinition> filterDefinitions =\n\t\t\t\t_webXMLDefinition.getFilterDefinitions();\n\n\t\t\tFilterDefinition filterDefinition = filterDefinitions.get(\n\t\t\t\t_filterMapping.filterName);\n\n\t\t\tif (filterDefinition != null) {\n\t\t\t\tfilterDefinition.setDispatchers(_filterMapping.dispatchers);\n\n\t\t\t\tif (_filterMapping.servletName != null) {\n\t\t\t\t\tList<String> servletNames =\n\t\t\t\t\t\tfilterDefinition.getServletNames();\n\n\t\t\t\t\tservletNames.add(_filterMapping.servletName);\n\t\t\t\t}\n\n\t\t\t\tfilterDefinition.setURLPatterns(_filterMapping.urlPatterns);\n\t\t\t}\n\n\t\t\t_filterMapping = null;\n\t\t}\n\t\telse if (qName.equals(\"filter-name\")) {\n\t\t\tif (_filterMapping != null) {\n\t\t\t\tString filterName = String.valueOf(_stack.pop());\n\n\t\t\t\t_filterMapping.filterName = filterName.trim();\n\t\t\t}\n\t\t\telse if (_filterDefinition != null) {\n\t\t\t\tString filterName = String.valueOf(_stack.pop());\n\n\t\t\t\t_filterDefinition.setName(filterName.trim());\n\t\t\t}\n\t\t}\n\t\telse if (qName.equals(\"init-param\")) {\n\t\t\tif (_filterDefinition != null) {\n\t\t\t\t_filterDefinition.setInitParameter(_paramName, _paramValue);\n\t\t\t}\n\t\t\telse if (_servletDefinition != null) {\n\t\t\t\t_servletDefinition.setInitParameter(_paramName, _paramValue);\n\t\t\t}\n\n\t\t\t_paramName = null;\n\t\t\t_paramValue = null;\n\t\t}\n\t\telse if (qName.equals(\"jsp-config\")) {\n\t\t\t_webXMLDefinition.setJspTaglibMappings(_jspConfig.mappings);\n\n\t\t\t_jspConfig = null;\n\t\t}\n\t\telse if (qName.equals(\"jsp-file\")) {\n\t\t\tString jspFile = String.valueOf(_stack.pop());\n\n\t\t\t_servletDefinition.setJSPFile(jspFile);\n\n\t\t\t_servletDefinition.setServlet(\n\t\t\t\tnew WabBundleProcessor.JspServletWrapper(jspFile));\n\t\t}\n\t\telse if (qName.equals(\"listener\")) {\n\t\t\tif (_listenerDefinition.getEventListener() != null) {\n\t\t\t\t_webXMLDefinition.addListenerDefinition(_listenerDefinition);\n\t\t\t}\n\n\t\t\t_listenerDefinition = null;\n\t\t}\n\t\telse if (qName.equals(\"listener-class\")) {\n\t\t\tString listenerClassName = String.valueOf(_stack.pop());\n\n\t\t\tEventListener eventListener = _getListenerInstance(\n\t\t\t\tlistenerClassName);\n\n\t\t\t_listenerDefinition.setEventListener(eventListener);\n\t\t}\n\t\telse if (qName.equals(\"param-name\")) {\n\t\t\t_paramName = String.valueOf(_stack.pop());\n\t\t\t_paramName = _paramName.trim();\n\t\t}\n\t\telse if (qName.equals(\"param-value\")) {\n\t\t\t_paramValue = String.valueOf(_stack.pop());\n\t\t\t_paramValue = _paramValue.trim();\n\t\t}\n\t\telse if (qName.equals(\"servlet\")) {\n\t\t\t_webXMLDefinition.setServletDefinition(\n\t\t\t\t_servletDefinition.getName(), _servletDefinition);\n\n\t\t\t_servletDefinition = null;\n\t\t}\n\t\telse if (qName.equals(\"servlet-class\")) {\n\t\t\tString servletClassName = String.valueOf(_stack.pop());\n\n\t\t\tServlet servlet = _getServletInstance(servletClassName.trim());\n\n\t\t\t_servletDefinition.setServlet(servlet);\n\t\t}\n\t\telse if (qName.equals(\"servlet-mapping\")) {\n\t\t\tMap<String, ServletDefinition> servletDefinitions =\n\t\t\t\t_webXMLDefinition.getServletDefinitions();\n\n\t\t\tServletDefinition servletDefinition = servletDefinitions.get(\n\t\t\t\t_servletMapping.servletName);\n\n\t\t\tif (servletDefinition != null) {\n\t\t\t\tservletDefinition.setURLPatterns(_servletMapping.urlPatterns);\n\t\t\t}\n\n\t\t\t_servletMapping = null;\n\t\t}\n\t\telse if (qName.equals(\"servlet-name\")) {\n\t\t\tif (_filterMapping != null) {\n\t\t\t\tString servletName = String.valueOf(_stack.pop());\n\n\t\t\t\t_filterMapping.servletName = servletName.trim();\n\t\t\t}\n\t\t\telse if (_servletDefinition != null) {\n\t\t\t\tString servletName = String.valueOf(_stack.pop());\n\n\t\t\t\t_servletDefinition.setName(servletName.trim());\n\t\t\t}\n\t\t\telse if (_servletMapping != null) {\n\t\t\t\tString servletName = String.valueOf(_stack.pop());\n\n\t\t\t\t_servletMapping.servletName = servletName.trim();\n\t\t\t}\n\t\t}\n\t\telse if (qName.equals(\"taglib\")) {\n\t\t\t_jspConfig.mappings.put(_taglibUri, _taglibLocation);\n\n\t\t\t_taglibUri = null;\n\t\t\t_taglibLocation = null;\n\t\t}\n\t\telse if (qName.equals(\"taglib-location\")) {\n\t\t\t_taglibLocation = String.valueOf(_stack.pop());\n\t\t}\n\t\telse if (qName.equals(\"taglib-uri\")) {\n\t\t\t_taglibUri = String.valueOf(_stack.pop());\n\t\t}\n\t\telse if (qName.equals(\"url-pattern\")) {\n\t\t\tif (_filterMapping != null) {\n\t\t\t\tString urlPattern = String.valueOf(_stack.pop());\n\n\t\t\t\t_filterMapping.urlPatterns.add(urlPattern.trim());\n\t\t\t}\n\t\t\telse if (_servletMapping != null) {\n\t\t\t\tString urlPattern = String.valueOf(_stack.pop());\n\n\t\t\t\t_servletMapping.urlPatterns.add(urlPattern.trim());\n\t\t\t}\n\t\t}\n\t}","commit_id":"627d4b7cc4337fff42ff1a58a260e89720bb6938","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void initServlets(\n\t\tHttpService httpService, HttpContext httpContext) {\n\n\t\tMap<String, ServletDefinition> servletDefinitions =\n\t\t\t_webXML.getServletDefinitions();\n\n\t\tfor (Map.Entry<String, ServletDefinition> entry :\n\t\t\t\tservletDefinitions.entrySet()) {\n\n\t\t\tServletDefinition servletDefinition = entry.getValue();\n\n\t\t\tList<String> urlPatterns = servletDefinition.getURLPatterns();\n\n\t\t\tfor (String urlPattern : urlPatterns) {\n\t\t\t\ttry {\n\t\t\t\t\thttpService.registerServlet(\n\t\t\t\t\t\turlPattern, servletDefinition.getServlet(),\n\t\t\t\t\t\tservletDefinition.getInitParameters(), httpContext);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(e, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":24618,"modified_method":"protected void initServlets(\n\t\tExtendedHttpService extendedHttpService, HttpContext httpContext) {\n\n\t\tMap<String, ServletDefinition> servletDefinitions =\n\t\t\t_webXML.getServletDefinitions();\n\n\t\tfor (Map.Entry<String, ServletDefinition> entry :\n\t\t\t\tservletDefinitions.entrySet()) {\n\n\t\t\tServletDefinition servletDefinition = entry.getValue();\n\n\t\t\ttry {\n\t\t\t\textendedHttpService.registerServlet(\n\t\t\t\t\tservletDefinition.getName(),\n\t\t\t\t\tservletDefinition.getURLPatterns(),\n\t\t\t\t\tservletDefinition.getServlet(),\n\t\t\t\t\tservletDefinition.getInitParameters(), httpContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t}\n\t}","commit_id":"60b59a209394bdb4e0dcb3d4bc4248a6eeb6311f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic HttpService addingService(\n\t\tServiceReference<HttpService> serviceReference) {\n\n\t\t_serviceReference = serviceReference;\n\n\t\tHttpService httpService = _bundleContext.getService(_serviceReference);\n\n\t\tif (httpService == null) {\n\t\t\treturn httpService;\n\t\t}\n\n\t\tHttpContext httpContext = httpService.createDefaultHttpContext();\n\n\t\treadConfiguration(_bundle);\n\n\t\tinitListeners((ExtendedHttpService)httpService, httpContext);\n\n\t\tinitServlets(httpService, httpContext);\n\n\t\tinitFilters((ExtendedHttpService)httpService, httpContext);\n\n\t\treturn httpService;\n\t}","id":24619,"modified_method":"@Override\n\tpublic HttpService addingService(\n\t\tServiceReference<HttpService> serviceReference) {\n\n\t\t_serviceReference = serviceReference;\n\n\t\tHttpService httpService = _bundleContext.getService(_serviceReference);\n\n\t\tif (httpService == null) {\n\t\t\treturn httpService;\n\t\t}\n\n\t\tHttpContext httpContext = httpService.createDefaultHttpContext();\n\n\t\treadConfiguration(_bundle);\n\n\t\tinitListeners((ExtendedHttpService)httpService, httpContext);\n\n\t\tinitServlets((ExtendedHttpService)httpService, httpContext);\n\n\t\tinitFilters((ExtendedHttpService)httpService, httpContext);\n\n\t\treturn httpService;\n\t}","commit_id":"60b59a209394bdb4e0dcb3d4bc4248a6eeb6311f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public NewActiveRule activate(RuleKey ruleKey) {\n    if (map.containsKey(ruleKey)) {\n      throw new IllegalStateException(String.format(\"Rule '%s' is already activated\", ruleKey));\n    }\n    NewActiveRule newActiveRule = new NewActiveRule(this, ruleKey);\n    map.put(ruleKey, newActiveRule);\n    return newActiveRule;\n  }","id":24620,"modified_method":"public NewActiveRule create(RuleKey ruleKey) {\n    return new NewActiveRule(this, ruleKey);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_add_twice_the_same_rule() throws Exception {\n    ActiveRulesBuilder builder = new ActiveRulesBuilder();\n    builder.activate(RuleKey.of(\"squid\", \"S0001\"));\n    try {\n      builder.activate(RuleKey.of(\"squid\", \"S0001\"));\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e).hasMessage(\"Rule 'squid:S0001' is already activated\");\n    }\n  }","id":24621,"modified_method":"@Test\n  public void fail_to_add_twice_the_same_rule() throws Exception {\n    ActiveRulesBuilder builder = new ActiveRulesBuilder();\n    builder.create(RuleKey.of(\"squid\", \"S0001\")).activate();\n    try {\n      builder.create(RuleKey.of(\"squid\", \"S0001\")).activate();\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e).hasMessage(\"Rule 'squid:S0001' is already activated\");\n    }\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void build_rules() throws Exception {\n    ActiveRules activeRules = new ActiveRulesBuilder()\n      .activate(RuleKey.of(\"squid\", \"S0001\"))\n      .setSeverity(Severity.CRITICAL)\n      .setInternalKey(\"__S0001__\")\n      .setParam(\"min\", \"20\")\n      .end()\n      // most simple rule\n      .activate(RuleKey.of(\"squid\", \"S0002\")).end()\n      .activate(RuleKey.of(\"findbugs\", \"NPE\")).setInternalKey(null).setSeverity(null).setParam(\"foo\", null).end()\n      .build();\n\n    assertThat(activeRules.findAll()).hasSize(3);\n    assertThat(activeRules.findByRepository(\"squid\")).hasSize(2);\n    assertThat(activeRules.findByRepository(\"findbugs\")).hasSize(1);\n    assertThat(activeRules.findByRepository(\"unknown\")).isEmpty();\n\n    ActiveRule squid1 = activeRules.find(RuleKey.of(\"squid\", \"S0001\"));\n    assertThat(squid1.ruleKey().repository()).isEqualTo(\"squid\");\n    assertThat(squid1.ruleKey().rule()).isEqualTo(\"S0001\");\n    assertThat(squid1.severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(squid1.internalKey()).isEqualTo(\"__S0001__\");\n    assertThat(squid1.params()).hasSize(1);\n    assertThat(squid1.param(\"min\")).isEqualTo(\"20\");\n\n    ActiveRule squid2 = activeRules.find(RuleKey.of(\"squid\", \"S0002\"));\n    assertThat(squid2.ruleKey().repository()).isEqualTo(\"squid\");\n    assertThat(squid2.ruleKey().rule()).isEqualTo(\"S0002\");\n    assertThat(squid2.severity()).isEqualTo(Severity.defaultSeverity());\n    assertThat(squid2.params()).isEmpty();\n\n    ActiveRule findbugsRule = activeRules.find(RuleKey.of(\"findbugs\", \"NPE\"));\n    assertThat(findbugsRule.severity()).isEqualTo(Severity.defaultSeverity());\n    assertThat(findbugsRule.internalKey()).isNull();\n    assertThat(findbugsRule.params()).isEmpty();\n  }","id":24622,"modified_method":"@Test\n  public void build_rules() throws Exception {\n    ActiveRules activeRules = new ActiveRulesBuilder()\n      .create(RuleKey.of(\"squid\", \"S0001\"))\n      .setSeverity(Severity.CRITICAL)\n      .setInternalKey(\"__S0001__\")\n      .setParam(\"min\", \"20\")\n      .activate()\n      // most simple rule\n      .create(RuleKey.of(\"squid\", \"S0002\")).activate()\n      .create(RuleKey.of(\"findbugs\", \"NPE\")).setInternalKey(null).setSeverity(null).setParam(\"foo\", null).activate()\n      .build();\n\n    assertThat(activeRules.findAll()).hasSize(3);\n    assertThat(activeRules.findByRepository(\"squid\")).hasSize(2);\n    assertThat(activeRules.findByRepository(\"findbugs\")).hasSize(1);\n    assertThat(activeRules.findByRepository(\"unknown\")).isEmpty();\n\n    ActiveRule squid1 = activeRules.find(RuleKey.of(\"squid\", \"S0001\"));\n    assertThat(squid1.ruleKey().repository()).isEqualTo(\"squid\");\n    assertThat(squid1.ruleKey().rule()).isEqualTo(\"S0001\");\n    assertThat(squid1.severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(squid1.internalKey()).isEqualTo(\"__S0001__\");\n    assertThat(squid1.params()).hasSize(1);\n    assertThat(squid1.param(\"min\")).isEqualTo(\"20\");\n\n    ActiveRule squid2 = activeRules.find(RuleKey.of(\"squid\", \"S0002\"));\n    assertThat(squid2.ruleKey().repository()).isEqualTo(\"squid\");\n    assertThat(squid2.ruleKey().rule()).isEqualTo(\"S0002\");\n    assertThat(squid2.severity()).isEqualTo(Severity.defaultSeverity());\n    assertThat(squid2.params()).isEmpty();\n\n    ActiveRule findbugsRule = activeRules.find(RuleKey.of(\"findbugs\", \"NPE\"));\n    assertThat(findbugsRule.severity()).isEqualTo(Severity.defaultSeverity());\n    assertThat(findbugsRule.internalKey()).isNull();\n    assertThat(findbugsRule.params()).isEmpty();\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private ActiveRules load(ModuleQProfiles qProfiles, ActiveRuleDao dao, RuleFinder ruleFinder) {\n    ActiveRulesBuilder builder = new ActiveRulesBuilder();\n    for (QProfile qProfile : qProfiles.findAll()) {\n      QProfileWithId qProfileWithId = (QProfileWithId) qProfile;\n      ListMultimap<Integer, ActiveRuleParamDto> paramDtosByActiveRuleId = ArrayListMultimap.create();\n      for (ActiveRuleParamDto dto : dao.selectParamsByProfileId(qProfileWithId.id())) {\n        paramDtosByActiveRuleId.put(dto.getActiveRuleId(), dto);\n      }\n\n      for (ActiveRuleDto activeDto : dao.selectByProfileId(qProfileWithId.id())) {\n        Rule rule = ruleFinder.findById(activeDto.getRulId());\n        if (rule != null) {\n          NewActiveRule newActiveRule = builder.activate(rule.ruleKey());\n          newActiveRule.setSeverity(activeDto.getSeverityString());\n          newActiveRule.setLanguage(rule.getLanguage());\n          Rule template = rule.getTemplate();\n          if (template != null) {\n            newActiveRule.setInternalKey(template.getConfigKey());\n          } else {\n            newActiveRule.setInternalKey(rule.getConfigKey());\n          }\n\n          // load parameter values\n          for (ActiveRuleParamDto paramDto : paramDtosByActiveRuleId.get(activeDto.getId())) {\n            newActiveRule.setParam(paramDto.getKey(), paramDto.getValue());\n          }\n\n          // load default values\n          for (RuleParam param : rule.getParams()) {\n            if (!newActiveRule.params().containsKey(param.getKey())) {\n              newActiveRule.setParam(param.getKey(), param.getDefaultValue());\n            }\n          }\n        }\n      }\n    }\n    return builder.build();\n  }","id":24623,"modified_method":"private ActiveRules load(ModuleQProfiles qProfiles, ActiveRuleDao dao, RuleFinder ruleFinder) {\n    ActiveRulesBuilder builder = new ActiveRulesBuilder();\n    for (QProfile qProfile : qProfiles.findAll()) {\n      QProfileWithId qProfileWithId = (QProfileWithId) qProfile;\n      ListMultimap<Integer, ActiveRuleParamDto> paramDtosByActiveRuleId = ArrayListMultimap.create();\n      for (ActiveRuleParamDto dto : dao.selectParamsByProfileId(qProfileWithId.id())) {\n        paramDtosByActiveRuleId.put(dto.getActiveRuleId(), dto);\n      }\n\n      for (ActiveRuleDto activeDto : dao.selectByProfileId(qProfileWithId.id())) {\n        Rule rule = ruleFinder.findById(activeDto.getRulId());\n        if (rule != null) {\n          NewActiveRule newActiveRule = builder.create(rule.ruleKey());\n          newActiveRule.setSeverity(activeDto.getSeverityString());\n          newActiveRule.setLanguage(rule.getLanguage());\n          Rule template = rule.getTemplate();\n          if (template != null) {\n            newActiveRule.setInternalKey(template.getConfigKey());\n          } else {\n            newActiveRule.setInternalKey(rule.getConfigKey());\n          }\n\n          // load parameter values\n          for (ActiveRuleParamDto paramDto : paramDtosByActiveRuleId.get(activeDto.getId())) {\n            newActiveRule.setParam(paramDto.getKey(), paramDto.getValue());\n          }\n\n          // load default values\n          for (RuleParam param : rule.getParams()) {\n            if (!newActiveRule.params().containsKey(param.getKey())) {\n              newActiveRule.setParam(param.getKey(), param.getDefaultValue());\n            }\n          }\n          newActiveRule.activate();\n        }\n      }\n    }\n    return builder.build();\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_optimize_on_repository() throws Exception {\n    DefaultAnalyzerDescriptor descriptor = new DefaultAnalyzerDescriptor()\n      .createIssuesForRuleRepositories(\"squid\");\n    assertThat(optimizer.shouldExecute(descriptor)).isFalse();\n\n    ActiveRules activeRules = new ActiveRulesBuilder()\n      .activate(RuleKey.of(\"repo1\", \"foo\"))\n      .end()\n      .build();\n    optimizer = new AnalyzerOptimizer(fs, activeRules);\n\n    assertThat(optimizer.shouldExecute(descriptor)).isFalse();\n\n    activeRules = new ActiveRulesBuilder()\n      .activate(RuleKey.of(\"repo1\", \"foo\"))\n      .end()\n      .activate(RuleKey.of(\"squid\", \"rule\"))\n      .end()\n      .build();\n    optimizer = new AnalyzerOptimizer(fs, activeRules);\n    assertThat(optimizer.shouldExecute(descriptor)).isTrue();\n  }","id":24624,"modified_method":"@Test\n  public void should_optimize_on_repository() throws Exception {\n    DefaultAnalyzerDescriptor descriptor = new DefaultAnalyzerDescriptor()\n      .createIssuesForRuleRepositories(\"squid\");\n    assertThat(optimizer.shouldExecute(descriptor)).isFalse();\n\n    ActiveRules activeRules = new ActiveRulesBuilder()\n      .create(RuleKey.of(\"repo1\", \"foo\"))\n      .activate()\n      .build();\n    optimizer = new AnalyzerOptimizer(fs, activeRules);\n\n    assertThat(optimizer.shouldExecute(descriptor)).isFalse();\n\n    activeRules = new ActiveRulesBuilder()\n      .create(RuleKey.of(\"repo1\", \"foo\"))\n      .activate()\n      .create(RuleKey.of(\"squid\", \"rule\"))\n      .activate()\n      .build();\n    optimizer = new AnalyzerOptimizer(fs, activeRules);\n    assertThat(optimizer.shouldExecute(descriptor)).isTrue();\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_missing_field() {\n    thrown.expect(IllegalStateException.class);\n    thrown.expectMessage(\"The field 'unknown' does not exist or is not annotated with @RuleProperty in the class org.sonar.api.batch.rule.CheckWithStringProperty\");\n\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithStringProperty\");\n    builder.activate(ruleKey).setParam(\"unknown\", \"foo\");\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithStringProperty.class);\n  }","id":24625,"modified_method":"@Test\n  public void fail_if_missing_field() {\n    thrown.expect(IllegalStateException.class);\n    thrown.expectMessage(\"The field 'unknown' does not exist or is not annotated with @RuleProperty in the class org.sonar.api.batch.rule.CheckWithStringProperty\");\n\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithStringProperty\");\n    builder.create(ruleKey).setParam(\"unknown\", \"foo\").activate();\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithStringProperty.class);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void param_as_primitive_fields() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithPrimitiveProperties\");\n    builder.activate(ruleKey).setParam(\"max\", \"300\").setParam(\"ignore\", \"true\");\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithPrimitiveProperties.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithPrimitiveProperties.class);\n    assertThat(((CheckWithPrimitiveProperties) check).getMax()).isEqualTo(300);\n    assertThat(((CheckWithPrimitiveProperties) check).isIgnore()).isTrue();\n  }","id":24626,"modified_method":"@Test\n  public void param_as_primitive_fields() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithPrimitiveProperties\");\n    builder.create(ruleKey).setParam(\"max\", \"300\").setParam(\"ignore\", \"true\").activate();\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithPrimitiveProperties.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithPrimitiveProperties.class);\n    assertThat(((CheckWithPrimitiveProperties) check).getMax()).isEqualTo(300);\n    assertThat(((CheckWithPrimitiveProperties) check).isIgnore()).isTrue();\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * SONAR-2900\n   */\n  @Test\n  public void checks_as_objects() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithStringProperty\");\n    builder.activate(ruleKey).setParam(\"pattern\", \"foo\");\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n\n    CheckWithStringProperty check = new CheckWithStringProperty();\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(check);\n\n    Object createdCheck = checks.of(ruleKey);\n    assertThat(createdCheck).isSameAs(check);\n    assertThat(((CheckWithStringProperty) createdCheck).getPattern()).isEqualTo(\"foo\");\n  }","id":24627,"modified_method":"/**\n   * SONAR-2900\n   */\n  @Test\n  public void checks_as_objects() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithStringProperty\");\n    builder.create(ruleKey).setParam(\"pattern\", \"foo\").activate();\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n\n    CheckWithStringProperty check = new CheckWithStringProperty();\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(check);\n\n    Object createdCheck = checks.of(ruleKey);\n    assertThat(createdCheck).isSameAs(check);\n    assertThat(((CheckWithStringProperty) createdCheck).getPattern()).isEqualTo(\"foo\");\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void class_name_as_check_key() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithoutProperties\");\n    builder.activate(ruleKey);\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithoutProperties.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithoutProperties.class);\n    assertThat(checks.all()).containsOnly(check);\n    assertThat(checks.ruleKey(check)).isEqualTo(ruleKey);\n  }","id":24628,"modified_method":"@Test\n  public void class_name_as_check_key() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithoutProperties\");\n    builder.create(ruleKey).activate();\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithoutProperties.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithoutProperties.class);\n    assertThat(checks.all()).containsOnly(check);\n    assertThat(checks.ruleKey(check)).isEqualTo(ruleKey);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_field_type_is_not_supported() {\n    thrown.expect(SonarException.class);\n\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithUnsupportedPropertyType\");\n    builder.activate(ruleKey).setParam(\"max\", \"300\");\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithUnsupportedPropertyType.class);\n  }","id":24629,"modified_method":"@Test\n  public void fail_if_field_type_is_not_supported() {\n    thrown.expect(SonarException.class);\n\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithUnsupportedPropertyType\");\n    builder.create(ruleKey).setParam(\"max\", \"300\").activate();\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithUnsupportedPropertyType.class);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void override_field_key() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithOverriddenPropertyKey\");\n    builder.activate(ruleKey).setParam(\"maximum\", \"300\");\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithOverriddenPropertyKey.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithOverriddenPropertyKey.class);\n    assertThat(((CheckWithOverriddenPropertyKey) check).getMax()).isEqualTo(300);\n  }","id":24630,"modified_method":"@Test\n  public void override_field_key() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithOverriddenPropertyKey\");\n    builder.create(ruleKey).setParam(\"maximum\", \"300\").activate();\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithOverriddenPropertyKey.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithOverriddenPropertyKey.class);\n    assertThat(((CheckWithOverriddenPropertyKey) check).getMax()).isEqualTo(300);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void use_engine_key() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"One\");\n    builder.activate(ruleKey).setInternalKey(\"S0001\");\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithKey.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithKey.class);\n    assertThat(checks.of(ruleKey)).isSameAs(check);\n    assertThat(checks.ruleKey(check)).isEqualTo(ruleKey);\n    assertThat(checks.all()).containsOnly(check);\n  }","id":24631,"modified_method":"@Test\n  public void use_engine_key() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"One\");\n    builder.create(ruleKey).setInternalKey(\"S0001\").activate();\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithKey.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithKey.class);\n    assertThat(checks.of(ruleKey)).isSameAs(check);\n    assertThat(checks.ruleKey(check)).isEqualTo(ruleKey);\n    assertThat(checks.all()).containsOnly(check);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void param_as_string_field() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithStringProperty\");\n    builder.activate(ruleKey).setParam(\"pattern\", \"foo\");\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithStringProperty.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithStringProperty.class);\n\n    assertThat(((CheckWithStringProperty) check).getPattern()).isEqualTo(\"foo\");\n  }","id":24632,"modified_method":"@Test\n  public void param_as_string_field() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithStringProperty\");\n    builder.create(ruleKey).setParam(\"pattern\", \"foo\").activate();\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithStringProperty.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithStringProperty.class);\n\n    assertThat(((CheckWithStringProperty) check).getPattern()).isEqualTo(\"foo\");\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * SONAR-3164\n   */\n  @Test\n  public void param_as_inherited_field() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithPrimitiveProperties\");\n    builder.activate(ruleKey).setParam(\"max\", \"300\");\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithPrimitiveProperties.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithPrimitiveProperties.class);\n    assertThat(((CheckWithPrimitiveProperties) check).getMax()).isEqualTo(300);\n  }","id":24633,"modified_method":"/**\n   * SONAR-3164\n   */\n  @Test\n  public void param_as_inherited_field() {\n    RuleKey ruleKey = RuleKey.of(\"squid\", \"org.sonar.api.batch.rule.CheckWithPrimitiveProperties\");\n    builder.create(ruleKey).setParam(\"max\", \"300\").activate();\n\n    CheckFactory checkFactory = new CheckFactory(builder.build());\n    Checks checks = checkFactory.create(\"squid\").addAnnotatedChecks(CheckWithPrimitiveProperties.class);\n\n    Object check = checks.of(ruleKey);\n    assertThat(check).isInstanceOf(CheckWithPrimitiveProperties.class);\n    assertThat(((CheckWithPrimitiveProperties) check).getMax()).isEqualTo(300);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public DefaultAnalyzerContext(ProjectDefinition def, AnalyzerMeasureCache measureCache,\n    ModuleIssues moduleIssues, Settings settings, FileSystem fs, ActiveRules activeRules) {\n    this.def = def;\n    this.measureCache = measureCache;\n    this.moduleIssues = moduleIssues;\n    this.settings = settings;\n    this.fs = fs;\n    this.activeRules = activeRules;\n  }","id":24634,"modified_method":"public DefaultAnalyzerContext(ProjectDefinition def, AnalyzerMeasureCache measureCache, AnalyzerIssueCache issueCache,\n    Settings settings, FileSystem fs, ActiveRules activeRules) {\n    this.def = def;\n    this.measureCache = measureCache;\n    this.issueCache = issueCache;\n    this.settings = settings;\n    this.fs = fs;\n    this.activeRules = activeRules;\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void addIssue(AnalyzerIssue issue) {\n    DefaultIssueBuilder builder = new DefaultIssueBuilder()\n      .projectKey(def.getKey());\n    if (issue.inputFile() != null) {\n      builder.componentKey(ComponentKeys.createEffectiveKey(def.getKey(), issue.inputFile()));\n    } else {\n      builder.componentKey(def.getKey());\n    }\n\n    moduleIssues.initAndAddIssue((DefaultIssue) builder\n      .ruleKey(RuleKey.of(issue.ruleKey().repository(), issue.ruleKey().rule()))\n      .message(issue.message())\n      .line(issue.line())\n      .effortToFix(issue.effortToFix())\n      .build());\n  }","id":24635,"modified_method":"@Override\n  public void addIssue(AnalyzerIssue issue) {\n    String resourceKey;\n    if (issue.inputFile() != null) {\n      resourceKey = ComponentKeys.createEffectiveKey(def.getKey(), issue.inputFile());\n    } else {\n      resourceKey = def.getKey();\n    }\n\n    issueCache.put(resourceKey, (DefaultAnalyzerIssue) issue);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"DefaultAnalyzerIssue(DefaultAnalyzerIssueBuilder builder) {\n    Preconditions.checkNotNull(builder.ruleKey, \"ruleKey is mandatory on issue\");\n    this.inputFile = builder.file;\n    this.ruleKey = builder.ruleKey;\n    this.message = builder.message;\n    this.line = builder.line;\n    this.effortToFix = builder.effortToFix;\n  }","id":24636,"modified_method":"DefaultAnalyzerIssue(DefaultAnalyzerIssueBuilder builder) {\n    Preconditions.checkNotNull(builder.ruleKey, \"ruleKey is mandatory on issue\");\n    this.inputFile = builder.file;\n    this.ruleKey = builder.ruleKey;\n    this.message = builder.message;\n    this.line = builder.line;\n    this.effortToFix = builder.effortToFix;\n    this.key = builder.key == null ? UUID.randomUUID().toString() : builder.key;\n    Preconditions.checkState(!Strings.isNullOrEmpty(key), \"Fail to generate issue key\");\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof DefaultAnalyzerMeasure)) {\n      return false;\n    }\n    DefaultAnalyzerMeasure<?> other = (DefaultAnalyzerMeasure<?>) obj;\n    return metric.equals(other.metric)\n      && value.equals(other.value)\n      && (inputFile == null ? other.inputFile == null : inputFile.equals(other.inputFile));\n  }","id":24637,"modified_method":"@Override\n  public boolean equals(Object obj) {\n    if (obj == null) {\n      return false;\n    }\n    if (obj == this) {\n      return true;\n    }\n    if (obj.getClass() != getClass()) {\n      return false;\n    }\n    DefaultAnalyzerMeasure rhs = (DefaultAnalyzerMeasure) obj;\n    return new EqualsBuilder()\n      .append(inputFile, rhs.inputFile)\n      .append(metric, rhs.metric)\n      .append(value, rhs.value)\n      .isEquals();\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public int hashCode() {\n    return metric.hashCode()\n      + value.hashCode()\n      + (inputFile != null ? inputFile.hashCode() : 0);\n  }","id":24638,"modified_method":"@Override\n  public int hashCode() {\n    return new HashCodeBuilder(27, 45).\n      append(inputFile).\n      append(metric).\n      append(value).\n      toHashCode();\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public String toString() {\n    return \"AnalyzerMeasure[\" + (inputFile != null ? \"inputFile=\" + inputFile.toString() : \"onProject\")\n      + \",metric=\" + metric + \",value=\" + value + \"]\";\n  }","id":24639,"modified_method":"@Override\n  public String toString() {\n    return ToStringBuilder.reflectionToString(this, ToStringStyle.SHORT_PREFIX_STYLE);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_issue() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL);\n\n    when(filters.accept(issue, null)).thenReturn(false);\n\n    boolean added = moduleIssues.initAndAddIssue(issue);\n\n    assertThat(added).isFalse();\n    verifyZeroInteractions(cache);\n  }","id":24640,"modified_method":"@Test\n  public void filter_issue() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL);\n\n    when(filters.accept(issue, null)).thenReturn(false);\n\n    boolean added = moduleIssues.initAndAddIssue(issue);\n\n    assertThat(added).isFalse();\n    verifyZeroInteractions(cache);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void add_issue_to_cache() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL);\n    when(filters.accept(issue, null)).thenReturn(true);\n\n    boolean added = moduleIssues.initAndAddIssue(issue);\n\n    assertThat(added).isTrue();\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(argument.getValue().creationDate()).isEqualTo(DateUtils.truncate(analysisDate, Calendar.SECOND));\n  }","id":24641,"modified_method":"@Test\n  public void add_issue_to_cache() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL);\n    when(filters.accept(issue, null)).thenReturn(true);\n\n    boolean added = moduleIssues.initAndAddIssue(issue);\n\n    assertThat(added).isTrue();\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(argument.getValue().creationDate()).isEqualTo(DateUtils.truncate(analysisDate, Calendar.SECOND));\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void use_rule_name_if_no_message() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setMessage(\"\");\n    when(filters.accept(issue, null)).thenReturn(true);\n\n    boolean added = moduleIssues.initAndAddIssue(issue);\n\n    assertThat(added).isTrue();\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().message()).isEqualTo(\"Avoid Cycle\");\n  }","id":24642,"modified_method":"@Test\n  public void use_rule_name_if_no_message() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setMessage(\"\");\n    when(filters.accept(issue, null)).thenReturn(true);\n\n    boolean added = moduleIssues.initAndAddIssue(issue);\n\n    assertThat(added).isTrue();\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().message()).isEqualTo(\"Avoid Cycle\");\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void ignore_null_rule_of_active_rule() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.activate(SQUID_RULE_KEY);\n    initModuleIssues();\n\n    DefaultIssue issue = new DefaultIssue().setRuleKey(SQUID_RULE_KEY);\n    boolean added = moduleIssues.initAndAddIssue(issue);\n\n    assertThat(added).isFalse();\n    verifyZeroInteractions(cache);\n  }","id":24643,"modified_method":"@Test\n  public void ignore_null_rule_of_active_rule() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.create(SQUID_RULE_KEY).activate();\n    initModuleIssues();\n\n    DefaultIssue issue = new DefaultIssue().setRuleKey(SQUID_RULE_KEY);\n    boolean added = moduleIssues.initAndAddIssue(issue);\n\n    assertThat(added).isFalse();\n    verifyZeroInteractions(cache);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void set_debt_with_constant_issue_function() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY)\n      .setName(SQUID_RULE_NAME)\n      .setDebtSubCharacteristic(\"COMPILER_RELATED_PORTABILITY\")\n      .setDebtRemediationFunction(DebtRemediationFunction.createConstantPerIssue(Duration.create(10L)));\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setEffortToFix(null);\n\n    when(filters.accept(issue, null)).thenReturn(true);\n    moduleIssues.initAndAddIssue(issue);\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().debt()).isEqualTo(Duration.create(10L));\n  }","id":24644,"modified_method":"@Test\n  public void set_debt_with_constant_issue_function() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY)\n      .setName(SQUID_RULE_NAME)\n      .setDebtSubCharacteristic(\"COMPILER_RELATED_PORTABILITY\")\n      .setDebtRemediationFunction(DebtRemediationFunction.createConstantPerIssue(Duration.create(10L)));\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setEffortToFix(null);\n\n    when(filters.accept(issue, null)).thenReturn(true);\n    moduleIssues.initAndAddIssue(issue);\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().debt()).isEqualTo(Duration.create(10L));\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void set_debt_with_linear_function() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY)\n      .setName(SQUID_RULE_NAME)\n      .setDebtSubCharacteristic(\"COMPILER_RELATED_PORTABILITY\")\n      .setDebtRemediationFunction(DebtRemediationFunction.createLinear(Duration.create(10L)));\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setEffortToFix(2d);\n\n    when(filters.accept(issue, null)).thenReturn(true);\n    moduleIssues.initAndAddIssue(issue);\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().debt()).isEqualTo(Duration.create(20L));\n  }","id":24645,"modified_method":"@Test\n  public void set_debt_with_linear_function() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY)\n      .setName(SQUID_RULE_NAME)\n      .setDebtSubCharacteristic(\"COMPILER_RELATED_PORTABILITY\")\n      .setDebtRemediationFunction(DebtRemediationFunction.createLinear(Duration.create(10L)));\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setEffortToFix(2d);\n\n    when(filters.accept(issue, null)).thenReturn(true);\n    moduleIssues.initAndAddIssue(issue);\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().debt()).isEqualTo(Duration.create(20L));\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_to_set_debt_with_constant_issue_function_when_effort_to_fix_is_set() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY)\n      .setName(SQUID_RULE_NAME)\n      .setDebtSubCharacteristic(\"COMPILER_RELATED_PORTABILITY\")\n      .setDebtRemediationFunction(DebtRemediationFunction.createConstantPerIssue(Duration.create(25L)));\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setEffortToFix(2d);\n\n    when(filters.accept(issue, null)).thenReturn(true);\n\n    try {\n      moduleIssues.initAndAddIssue(issue);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class)\n        .hasMessage(\"Rule 'squid:AvoidCycle' can not use 'Constant/issue' remediation function because this rule does not have a fixed remediation cost.\");\n    }\n  }","id":24646,"modified_method":"@Test\n  public void fail_to_set_debt_with_constant_issue_function_when_effort_to_fix_is_set() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY)\n      .setName(SQUID_RULE_NAME)\n      .setDebtSubCharacteristic(\"COMPILER_RELATED_PORTABILITY\")\n      .setDebtRemediationFunction(DebtRemediationFunction.createConstantPerIssue(Duration.create(25L)));\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setEffortToFix(2d);\n\n    when(filters.accept(issue, null)).thenReturn(true);\n\n    try {\n      moduleIssues.initAndAddIssue(issue);\n      fail();\n    } catch (Exception e) {\n      assertThat(e).isInstanceOf(IllegalArgumentException.class)\n        .hasMessage(\"Rule 'squid:AvoidCycle' can not use 'Constant/issue' remediation function because this rule does not have a fixed remediation cost.\");\n    }\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void add_deprecated_violation() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    org.sonar.api.rules.Rule rule = org.sonar.api.rules.Rule.create(\"squid\", \"AvoidCycle\", \"Avoid Cycle\");\n    Resource resource = new File(\"org/struts/Action.java\").setEffectiveKey(\"struts:src/org/struts/Action.java\");\n    Violation violation = new Violation(rule, resource);\n    violation.setLineId(42);\n    violation.setSeverity(RulePriority.CRITICAL);\n    violation.setMessage(\"the message\");\n\n    when(filters.accept(any(DefaultIssue.class), eq(violation))).thenReturn(true);\n\n    boolean added = moduleIssues.initAndAddViolation(violation);\n    assertThat(added).isTrue();\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    DefaultIssue issue = argument.getValue();\n    assertThat(issue.severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(issue.line()).isEqualTo(42);\n    assertThat(issue.message()).isEqualTo(\"the message\");\n    assertThat(issue.key()).isNotEmpty();\n    assertThat(issue.ruleKey().toString()).isEqualTo(\"squid:AvoidCycle\");\n    assertThat(issue.componentKey()).isEqualTo(\"struts:src/org/struts/Action.java\");\n    assertThat(issue.projectKey()).isEqualTo(\"org.apache:struts-core\");\n  }","id":24647,"modified_method":"@Test\n  public void add_deprecated_violation() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    org.sonar.api.rules.Rule rule = org.sonar.api.rules.Rule.create(\"squid\", \"AvoidCycle\", \"Avoid Cycle\");\n    Resource resource = new File(\"org/struts/Action.java\").setEffectiveKey(\"struts:src/org/struts/Action.java\");\n    Violation violation = new Violation(rule, resource);\n    violation.setLineId(42);\n    violation.setSeverity(RulePriority.CRITICAL);\n    violation.setMessage(\"the message\");\n\n    when(filters.accept(any(DefaultIssue.class), eq(violation))).thenReturn(true);\n\n    boolean added = moduleIssues.initAndAddViolation(violation);\n    assertThat(added).isTrue();\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    DefaultIssue issue = argument.getValue();\n    assertThat(issue.severity()).isEqualTo(Severity.CRITICAL);\n    assertThat(issue.line()).isEqualTo(42);\n    assertThat(issue.message()).isEqualTo(\"the message\");\n    assertThat(issue.key()).isNotEmpty();\n    assertThat(issue.ruleKey().toString()).isEqualTo(\"squid:AvoidCycle\");\n    assertThat(issue.componentKey()).isEqualTo(\"struts:src/org/struts/Action.java\");\n    assertThat(issue.projectKey()).isEqualTo(\"org.apache:struts-core\");\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void set_debt_with_linear_with_offset_function() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY)\n      .setName(SQUID_RULE_NAME)\n      .setDebtSubCharacteristic(\"COMPILER_RELATED_PORTABILITY\")\n      .setDebtRemediationFunction(DebtRemediationFunction.createLinearWithOffset(Duration.create(10L), Duration.create(25L)));\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setEffortToFix(2d);\n\n    when(filters.accept(issue, null)).thenReturn(true);\n    moduleIssues.initAndAddIssue(issue);\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().debt()).isEqualTo(Duration.create(45L));\n  }","id":24648,"modified_method":"@Test\n  public void set_debt_with_linear_with_offset_function() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY)\n      .setName(SQUID_RULE_NAME)\n      .setDebtSubCharacteristic(\"COMPILER_RELATED_PORTABILITY\")\n      .setDebtRemediationFunction(DebtRemediationFunction.createLinearWithOffset(Duration.create(10L), Duration.create(25L)));\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue()\n      .setKey(\"ABCDE\")\n      .setRuleKey(SQUID_RULE_KEY)\n      .setSeverity(Severity.CRITICAL)\n      .setEffortToFix(2d);\n\n    when(filters.accept(issue, null)).thenReturn(true);\n    moduleIssues.initAndAddIssue(issue);\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().debt()).isEqualTo(Duration.create(45L));\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void use_severity_from_active_rule_if_no_severity_on_issue() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.activate(SQUID_RULE_KEY).setSeverity(Severity.INFO);\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue().setRuleKey(SQUID_RULE_KEY).setSeverity(null);\n    when(filters.accept(issue, null)).thenReturn(true);\n    moduleIssues.initAndAddIssue(issue);\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().severity()).isEqualTo(Severity.INFO);\n    assertThat(argument.getValue().creationDate()).isEqualTo(DateUtils.truncate(analysisDate, Calendar.SECOND));\n  }","id":24649,"modified_method":"@Test\n  public void use_severity_from_active_rule_if_no_severity_on_issue() throws Exception {\n    ruleBuilder.add(SQUID_RULE_KEY).setName(SQUID_RULE_NAME);\n    activeRulesBuilder.create(SQUID_RULE_KEY).setSeverity(Severity.INFO).activate();\n    initModuleIssues();\n\n    Date analysisDate = new Date();\n    when(project.getAnalysisDate()).thenReturn(analysisDate);\n\n    DefaultIssue issue = new DefaultIssue().setRuleKey(SQUID_RULE_KEY).setSeverity(null);\n    when(filters.accept(issue, null)).thenReturn(true);\n    moduleIssues.initAndAddIssue(issue);\n\n    ArgumentCaptor<DefaultIssue> argument = ArgumentCaptor.forClass(DefaultIssue.class);\n    verify(cache).put(argument.capture());\n    assertThat(argument.getValue().severity()).isEqualTo(Severity.INFO);\n    assertThat(argument.getValue().creationDate()).isEqualTo(DateUtils.truncate(analysisDate, Calendar.SECOND));\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void addBatchComponents() {\n    add(\n      Caches.class,\n      SnapshotCache.class,\n      ResourceCache.class,\n      ComponentDataCache.class,\n      ComponentDataPersister.class,\n      AnalyzerMeasureCache.class,\n\n      // file system\n      InputFileCache.class,\n      PathResolver.class,\n\n      // issues\n      IssueUpdater.class,\n      FunctionExecutor.class,\n      IssueWorkflow.class,\n      DeprecatedViolations.class,\n      IssueCache.class,\n      ScanIssueStorage.class,\n      IssuePersister.class,\n      IssueNotifications.class,\n      DefaultProjectIssues.class,\n      IssueChangelogDebtCalculator.class,\n\n      // tests\n      TestPlanPerspectiveLoader.class,\n      TestablePerspectiveLoader.class,\n      TestPlanBuilder.class,\n      TestableBuilder.class,\n      ScanGraph.create(),\n      GraphPersister.class,\n\n      // lang\n      HighlightableBuilder.class,\n      SymbolizableBuilder.class,\n\n      ScanTaskObservers.class);\n  }","id":24650,"modified_method":"private void addBatchComponents() {\n    add(\n      Caches.class,\n\n      // Measures\n      AnalyzerMeasureCache.class,\n\n      // file system\n      InputFileCache.class,\n      PathResolver.class,\n\n      // issues\n      AnalyzerIssueCache.class,\n\n      ScanTaskObservers.class);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void projectBootstrap() {\n    ProjectReactor reactor;\n    ProjectBootstrapper bootstrapper = getComponentByType(ProjectBootstrapper.class);\n    Settings settings = getComponentByType(Settings.class);\n    if (bootstrapper == null\n      // Starting from Maven plugin 2.3 then only DefaultProjectBootstrapper should be used.\n      || \"true\".equals(settings.getString(\"sonar.mojoUseRunner\"))) {\n      // Use default SonarRunner project bootstrapper\n      ProjectReactorBuilder builder = getComponentByType(ProjectReactorBuilder.class);\n      reactor = builder.execute();\n    } else {\n      reactor = bootstrapper.bootstrap();\n    }\n    if (reactor == null) {\n      throw new SonarException(bootstrapper + \" has returned null as ProjectReactor\");\n    }\n    add(reactor);\n  }","id":24651,"modified_method":"private void projectBootstrap() {\n    ProjectReactor reactor;\n    ProjectBootstrapper bootstrapper = getComponentByType(ProjectBootstrapper.class);\n    Settings settings = getComponentByType(Settings.class);\n    if (bootstrapper == null\n      // Starting from Maven plugin 2.3 then only DefaultProjectBootstrapper should be used.\n      || \"true\".equals(settings.getString(\"sonar.mojoUseRunner\"))) {\n      // Use default SonarRunner project bootstrapper\n      ProjectReactorBuilder builder = getComponentByType(ProjectReactorBuilder.class);\n      reactor = builder.execute();\n    } else {\n      reactor = bootstrapper.bootstrap();\n    }\n    if (reactor == null) {\n      throw new IllegalStateException(bootstrapper + \" has returned null as ProjectReactor\");\n    }\n    add(reactor);\n  }","commit_id":"3bd4ce6a6c0010e272b55656ae62cc2f0f20b9f7","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n     * A repeated handler may call this 1 or more times to start handling the captured body.\n     *\n     * @throws SAXException\n     */\n    public void repeatBody() throws SAXException {\n        // Replay content of current SAXStore\n        currentHandlerInfo.saxStore.replay(this);\n        if (this.locator != null) {\n            // This means that the SAXStore sent out setDocumentLocator() as well\n            this.locator.popLocator();\n        }\n    }","id":24652,"modified_method":"/**\n     * A repeated handler may call this 1 or more times to start handling the captured body.\n     *\n     * @throws SAXException\n     */\n    public void repeatBody() throws SAXException {\n        // Replay content of current SAXStore\n\n        final int beforeLocatorCount = (this.locator != null) ? this.locator.getSize() : 0;\n        currentHandlerInfo.saxStore.replay(this);\n        final int afterLocatorCount = (this.locator != null) ? this.locator.getSize() : 0;\n        if (beforeLocatorCount != afterLocatorCount) {\n            // This means that the SAXStore replay called setDocumentLocator()\n            assert afterLocatorCount == beforeLocatorCount + 1 : \"incorrect locator stack state\";\n            this.locator.popLocator();\n        }\n    }","commit_id":"9e658a41b86c24f172fe30970445bfb395d733c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public HandlerInfo(int level, String explodedQName, ElementHandler elementHandler) {\n            this.level = level;\n            this.explodedQName = explodedQName;\n            this.elementHandler = elementHandler;\n        }","id":24653,"modified_method":"public HandlerInfo(int level, String explodedQName, ElementHandler elementHandler) {\n            this.level = level;\n            this.explodedQName = explodedQName;\n            this.elementHandler = elementHandler;\n            this.attributes = null;\n            this.saxStore = null;\n        }","commit_id":"9e658a41b86c24f172fe30970445bfb395d733c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private Locator getCurrentLocator() {\n            return (locators.size() == 0) ? null : (Locator) locators.peek();\n        }","id":24654,"modified_method":"private Locator getCurrentLocator() {\n            return (locators.size() == 0) ? null : locators.peek();\n        }","commit_id":"9e658a41b86c24f172fe30970445bfb395d733c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        final ElementHandlerController controller = handlerContext.getController();\n        final ContentHandler contentHandler = controller.getOutput();\n\n        final String staticId = handlerContext.getId(attributes);\n        final String prefixedId = handlerContext.getIdPrefix() + staticId;\n        final String effectiveId = handlerContext.getEffectiveId(attributes);\n\n        final String elementName = \"div\";\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String elementQName = XMLUtils.buildQName(xhtmlPrefix, elementName);\n\n        // Produce class of the form xbl-foo-bar\n        final String classes = \"xbl-component xbl-\" + qName.replace(':', '-');\n\n        // Start xhtml:span element\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, elementName, elementQName, getAttributes(attributes, classes, effectiveId));\n\n        // Push context\n        handlerContext.pushComponentContext(prefixedId);\n\n        // Process shadow content if present\n        final Element shadowTree = containingDocument.getStaticState().getXBLBindings().getFullShadowTree(prefixedId);\n        if (shadowTree != null) {\n            // Tell the controller we are providing a new body\n            controller.startBody();\n\n            // Forward shadow content to handler\n            // TODO: would be better to handle inclusion and namespaces using XIncludeProcessor facilities instead of custom code\n            TransformerUtils.writeDom4j(shadowTree, new EmbeddedDocumentContentHandler(controller) {\n\n                private int level = 0;\n\n                public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n                    if (level != 0)\n                        super.startElement(uri, localname, qName, attributes);\n\n                    level++;\n                }\n\n                public void endElement(String uri, String localname, String qName) throws SAXException {\n\n                    level--;\n\n                    if (level != 0)\n                        super.endElement(uri, localname, qName);\n                }\n            });\n\n            // Tell the controller we are done with the new body\n            controller.endBody();\n        }\n    }","id":24655,"modified_method":"public void start(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n        final ElementHandlerController controller = handlerContext.getController();\n        final ContentHandler contentHandler = controller.getOutput();\n\n        final String staticId = handlerContext.getId(attributes);\n        final String prefixedId = handlerContext.getIdPrefix() + staticId;\n        final String effectiveId = handlerContext.getEffectiveId(attributes);\n\n        final String elementName = \"div\";\n        final String xhtmlPrefix = handlerContext.findXHTMLPrefix();\n        final String elementQName = XMLUtils.buildQName(xhtmlPrefix, elementName);\n\n        // Produce class of the form xbl-foo-bar\n        final String classes = \"xbl-component xbl-\" + qName.replace(':', '-');\n\n        // Start xhtml:span element\n        contentHandler.startElement(XMLConstants.XHTML_NAMESPACE_URI, elementName, elementQName, getAttributes(attributes, classes, effectiveId));\n\n        // Push context\n        handlerContext.pushComponentContext(prefixedId);\n\n        // Process shadow content if present\n        final Element shadowTree = containingDocument.getStaticState().getXBLBindings().getFullShadowTree(prefixedId);\n        if (shadowTree != null) {\n            // Tell the controller we are providing a new body\n            controller.startBody();\n\n            // Forward shadow content to handler\n            // TODO: would be better to handle inclusion and namespaces using XIncludeProcessor facilities instead of custom code\n            TransformerUtils.writeDom4j(shadowTree, new EmbeddedDocumentContentHandler(controller) {\n\n                private int level = 0;\n\n                public void startElement(String uri, String localname, String qName, Attributes attributes) throws SAXException {\n\n                    if (level != 0)\n                        super.startElement(uri, localname, qName, attributes);\n\n                    level++;\n                }\n\n                public void endElement(String uri, String localname, String qName) throws SAXException {\n\n                    level--;\n\n                    if (level != 0)\n                        super.endElement(uri, localname, qName);\n                }\n\n                @Override\n                public void setDocumentLocator(Locator locator) {\n                    // NOP for now. In the future, we should push/pop the locator on ElementHandlerController\n                }\n            });\n\n            // Tell the controller we are done with the new body\n            controller.endBody();\n        }\n    }","commit_id":"9e658a41b86c24f172fe30970445bfb395d733c1","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * The main method of the scheduler. This method is responsible for checking\n     * the runnable queues for ready objects and then enqueuing them into the\n     * thread pool for execution.\n     * \n     */\n    public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        synchronized (this) {\n            m_status = RUNNING;\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"run: scheduler running\");\n\n        // Loop until a fatal exception occurs or until\n        // the thread is interrupted.\n        //\n        for (;;) {\n            // block if there is nothing in the queue(s)\n            // When something is added to the queue it\n            // signals us to wakeup\n            //\n            synchronized (this) {\n                \n                if (m_status != RUNNING && m_status != PAUSED && m_status != PAUSE_PENDING && m_status != RESUME_PENDING) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"run: status = \" + m_status + \", time to exit\");\n                    break;\n                }\n\n                // if paused or pause pending then block\n                while (m_status == PAUSE_PENDING || m_status == PAUSED) {\n                    if (m_status == PAUSE_PENDING && log.isDebugEnabled())\n                        log.debug(\"run: pausing.\");\n                    m_status = PAUSED;\n                    try {\n                        wait();\n                    } catch (InterruptedException ex) {\n                        // exit\n                        break;\n                    }\n                }\n\n                // if resume pending then change to running\n\n                if (m_status == RESUME_PENDING) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"run: resuming.\");\n                    \n                    m_status = RUNNING;\n                }\n\n                if (m_scheduled == 0) {\n                    try {\n                        if (log.isDebugEnabled())\n                            log.debug(\"run: no ready runnables scheduled, waiting...\");\n                        wait();\n                    } catch (InterruptedException ex) {\n                        break;\n                    }\n                }\n            }\n\n            // cycle through the queues checking for\n            // what's ready to run. The queues are keyed\n            // by the interval, but the mapped elements\n            // are peekable fifo queues.\n            //\n            int runned = 0;\n            FifoQueue out = m_runner.getRunQueue();\n            synchronized (m_queues) {\n                // get an iterator so that we can cycle\n                // through the queue elements.\n                //\n                Iterator iter = m_queues.entrySet().iterator();\n                while (iter.hasNext()) {\n                    // Peak for Runnable objects until\n                    // there are no more ready runnables\n                    //\n                    // Also, only go through each queue once!\n                    // if we didn't add a count then it would\n                    // be possible to starve other queues.\n                    //\n                    PeekableFifoQueue in = (PeekableFifoQueue) ((Map.Entry) iter.next()).getValue();\n                    ReadyRunnable readyRun = null;\n                    int maxLoops = in.size();\n                    do {\n                        try {\n                            readyRun = (ReadyRunnable) in.peek();\n                            if (readyRun != null && readyRun.isReady()) {\n                                if (log.isDebugEnabled()) {\n                                    log.debug(\"run: found ready runnable \"+readyRun);\n                                }\n\n                                // Pop the interface/readyRunnable from the\n                                // queue for execution.\n                                //\n                                in.remove();\n\n                                // Add runnable to the execution queue\n                                out.add(readyRun);\n                                ++runned;\n                            }\n                        } catch (InterruptedException ex) {\n                            return; // jump all the way out\n                        } catch (FifoQueueException qe) {\n                            throw new UndeclaredThrowableException(qe);\n                        }\n\n                    } while (readyRun != null && readyRun.isReady() && --maxLoops > 0);\n                }\n            }\n\n            // Wait for 1 second if there were no runnables\n            // executed during this loop, otherwise just\n            // start over.\n            //\n            synchronized (this) {\n                m_scheduled -= runned;\n                if (runned == 0) {\n                    try {\n                        wait(1000);\n                    } catch (InterruptedException ex) {\n                        break; // exit for loop\n                    }\n                }\n            }\n\n        } // end for(;;)\n\n        if (log.isDebugEnabled())\n            log.debug(\"run: scheduler exiting, state = STOPPED\");\n        synchronized (this) {\n            m_status = STOPPED;\n        }\n\n    }","id":24656,"modified_method":"/**\n     * The main method of the scheduler. This method is responsible for checking\n     * the runnable queues for ready objects and then enqueuing them into the\n     * thread pool for execution.\n     */\n    public void run() {\n        synchronized (this) {\n            m_status = RUNNING;\n        }\n\n        log().debug(\"run: scheduler running\");\n\n        /*\n         * Loop until a fatal exception occurs or until\n         * the thread is interrupted.\n         */\n        for (;;) {\n            /*\n             * Block if there is nothing in the queue(s).\n             * When something is added to the queue it\n             * signals us to wakeup.\n             */\n            synchronized (this) {\n                \n                if (m_status != RUNNING && m_status != PAUSED && m_status != PAUSE_PENDING && m_status != RESUME_PENDING) {\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"run: status = \" + m_status + \", time to exit\");\n                    }\n                    break;\n                }\n\n                // if paused or pause pending then block\n                while (m_status == PAUSE_PENDING || m_status == PAUSED) {\n                    if (m_status == PAUSE_PENDING) {\n                        log().debug(\"run: pausing.\");\n                    }\n                    m_status = PAUSED;\n                    try {\n                        wait();\n                    } catch (InterruptedException ex) {\n                        // exit\n                        break;\n                    }\n                }\n\n                // if resume pending then change to running\n\n                if (m_status == RESUME_PENDING) {\n                    log().debug(\"run: resuming.\");\n                    \n                    m_status = RUNNING;\n                }\n\n                if (m_scheduled == 0) {\n                    try {\n                        log().debug(\"run: no ready runnables scheduled, waiting...\");\n                        wait();\n                    } catch (InterruptedException ex) {\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * Cycle through the queues checking for\n             * what's ready to run.  The queues are keyed\n             * by the interval, but the mapped elements\n             * are peekable fifo queues.\n             */\n            int runned = 0;\n            FifoQueue<Runnable> out = m_runner.getRunQueue();\n            synchronized (m_queues) {\n                /*\n                 * Get an iterator so that we can cycle\n                 * through the queue elements.\n                 */\n                for (Entry<Long, PeekableFifoQueue<ReadyRunnable>> entry : m_queues.entrySet()) {\n                    /*\n                     * Peak for Runnable objects until\n                     * there are no more ready runnables.\n                     *\n                     * Also, only go through each queue once!\n                     * if we didn't add a count then it would\n                     * be possible to starve other queues.\n                     */\n                    PeekableFifoQueue<ReadyRunnable> in = entry.getValue();\n                    ReadyRunnable readyRun = null;\n                    int maxLoops = in.size();\n                    do {\n                        try {\n                            readyRun = in.peek();\n                            if (readyRun != null && readyRun.isReady()) {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"run: found ready runnable \"+readyRun);\n                                }\n\n                                /*\n                                 * Pop the interface/readyRunnable from the\n                                 * queue for execution.\n                                 */\n                                in.remove();\n\n                                // Add runnable to the execution queue\n                                out.add(readyRun);\n                                ++runned;\n                            }\n                        } catch (InterruptedException e) {\n                            return; // jump all the way out\n                        } catch (FifoQueueException e) {\n                            throw new UndeclaredThrowableException(e);\n                        }\n\n                    } while (readyRun != null && readyRun.isReady() && --maxLoops > 0);\n                }\n            }\n\n            /*\n             * Wait for 1 second if there were no runnables\n             * executed during this loop, otherwise just\n             * start over.\n             */\n            synchronized (this) {\n                m_scheduled -= runned;\n                if (runned == 0) {\n                    try {\n                        wait(1000);\n                    } catch (InterruptedException ex) {\n                        break; // exit for loop\n                    }\n                }\n            }\n\n        }\n\n        log().debug(\"run: scheduler exiting, state = STOPPED\");\n        synchronized (this) {\n            m_status = STOPPED;\n        }\n\n    }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n         * Removes the next element from the queue and returns it to the caller.\n         * If there is no objects available then the caller is blocked until an\n         * item is available.\n         * \n         * @return The next element in the queue.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized Object remove() throws InterruptedException, FifoQueueException {\n            Object rval = null;\n            if (m_hold != null) {\n                rval = m_hold;\n                m_hold = null;\n            } else {\n                rval = super.remove();\n            }\n\n            return rval;\n        }","id":24657,"modified_method":"/**\n         * Removes the next element from the queue and returns it to the caller.\n         * If there is no objects available then the caller is blocked until an\n         * item is available.\n         * \n         * @return The next element in the queue.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized T remove() throws InterruptedException, FifoQueueException {\n            T rval = null;\n            if (m_hold != null) {\n                rval = m_hold;\n                m_hold = null;\n            } else {\n                rval = super.remove();\n            }\n\n            return rval;\n        }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void stop() {\n        if (m_worker == null)\n            throw new IllegalStateException(\"The fiber has never been started\");\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        m_status = STOP_PENDING;\n        m_worker.interrupt();\n        m_runner.stop();\n\n        log.info(\"stop: scheduler stopped\");\n    }","id":24658,"modified_method":"public synchronized void stop() {\n        Assert.state(m_worker != null, \"The fiber has never been started\");\n\n        m_status = STOP_PENDING;\n        m_worker.interrupt();\n        m_runner.stop();\n\n        log().info(\"stop: scheduler stopped\");\n    }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n         * Removes the next element from the queue and returns it to the caller.\n         * If there is no objects available then the caller is blocked until an\n         * item is available. If an object is not available within the time\n         * frame specified by <code>timeout<\/code>.\n         * \n         * @param timeout\n         *            The maximum time to wait.\n         * \n         * @return The next element in the queue.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized Object remove(long timeout) throws InterruptedException, FifoQueueException {\n            Object rval = null;\n            if (m_hold != null) {\n                rval = m_hold;\n                m_hold = null;\n            } else {\n                rval = super.remove(timeout);\n            }\n\n            return rval;\n        }","id":24659,"modified_method":"/**\n         * Removes the next element from the queue and returns it to the caller.\n         * If there is no objects available then the caller is blocked until an\n         * item is available. If an object is not available within the time\n         * frame specified by <code>timeout<\/code>.\n         * \n         * @param timeout\n         *            The maximum time to wait.\n         * \n         * @return The next element in the queue.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized T remove(long timeout) throws InterruptedException, FifoQueueException {\n            T rval = null;\n            if (m_hold != null) {\n                rval = m_hold;\n                m_hold = null;\n            } else {\n                rval = super.remove(timeout);\n            }\n\n            return rval;\n        }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to schedule a ready runnable in the system. The\n     * interval is used as the key for determining which queue to add the\n     * runnable.\n     * \n     * @param runnable\n     *            The element to run when interval expires.\n     * @param interval\n     *            The queue to add the runnable to.\n     * \n     * @throws java.lang.RuntimeException\n     *             Thrown if an error occurs adding the element to the queue.\n     */\n    public synchronized void schedule(ReadyRunnable runnable, long interval) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"schedule: Adding ready runnable \"+runnable+\" at interval \" + interval);\n        }\n\n        Long key = new Long(interval);\n        if (!m_queues.containsKey(key)) {\n            if (log.isDebugEnabled())\n                log.debug(\"schedule: interval queue did not exist, a new one has been created\");\n            m_queues.put(key, new PeekableFifoQueue());\n        }\n\n        try {\n            ((FifoQueue) m_queues.get(key)).add(runnable);\n            if (m_scheduled++ == 0) {\n                if (log.isDebugEnabled())\n                    log.debug(\"schedule: queue element added, calling notify all since none were scheduled\");\n                notifyAll();\n            } else if (log.isDebugEnabled()) {\n                log.debug(\"schedule: queue element added, notification not performed\");\n            }\n        } catch (InterruptedException ie) {\n            if (log.isInfoEnabled())\n                log.info(\"schedule: failed to add new ready runnable instance \"+runnable+\" to scheduler\", ie);\n            Thread.currentThread().interrupt();\n        } catch (FifoQueueException ex) {\n            if (log.isInfoEnabled())\n                log.info(\"schedule: failed to add new ready runnable instance \"+runnable+\" to scheduler\", ex);\n            throw new UndeclaredThrowableException(ex);\n        }\n    }","id":24660,"modified_method":"/**\n     * This method is used to schedule a ready runnable in the system. The\n     * interval is used as the key for determining which queue to add the\n     * runnable.\n     * \n     * @param runnable\n     *            The element to run when interval expires.\n     * @param interval\n     *            The queue to add the runnable to.\n     * \n     * @throws java.lang.RuntimeException\n     *             Thrown if an error occurs adding the element to the queue.\n     */\n    public synchronized void schedule(ReadyRunnable runnable, long interval) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"schedule: Adding ready runnable \"+runnable+\" at interval \" + interval);\n        }\n\n        Long key = new Long(interval);\n        if (!m_queues.containsKey(key)) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"schedule: interval queue did not exist, a new one has been created\");\n            }\n            m_queues.put(key, new PeekableFifoQueue<ReadyRunnable>());\n        }\n\n        try {\n            m_queues.get(key).add(runnable);\n            if (m_scheduled++ == 0) {\n                log().debug(\"schedule: queue element added, calling notify all since none were scheduled\");\n                notifyAll();\n            } else if (log().isDebugEnabled()) {\n                log().debug(\"schedule: queue element added, notification not performed\");\n            }\n        } catch (InterruptedException e) {\n            log().info(\"schedule: failed to add new ready runnable instance \" + runnable + \" to scheduler: \" + e, e);\n            Thread.currentThread().interrupt();\n        } catch (FifoQueueException e) {\n            log().info(\"schedule: failed to add new ready runnable instance \" + runnable + \" to scheduler: \" + e, e);\n            throw new UndeclaredThrowableException(e);\n        }\n    }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n         * This method allows the caller to peek at the next object that would\n         * be returned on a <code>remove<\/code> call. If the queue is\n         * currently empty then the caller is blocked until an object is put\n         * into the queue.\n         * \n         * @return The object that would be returned on the next call to\n         *         <code>remove<\/code>.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized Object peek() throws InterruptedException, FifoQueueException {\n            if (m_hold == null)\n                m_hold = super.remove(1L);\n\n            return m_hold;\n        }","id":24661,"modified_method":"/**\n         * This method allows the caller to peek at the next object that would\n         * be returned on a <code>remove<\/code> call. If the queue is\n         * currently empty then the caller is blocked until an object is put\n         * into the queue.\n         * \n         * @return The object that would be returned on the next call to\n         *         <code>remove<\/code>.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized T peek() throws InterruptedException, FifoQueueException {\n            if (m_hold == null) {\n                m_hold = super.remove(1L);\n            }\n\n            return m_hold;\n        }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void start() {\n        if (m_worker != null)\n            throw new IllegalStateException(\"The fiber has already run or is running\");\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        m_runner.start();\n        m_worker = new Thread(this, getName());\n        m_worker.start();\n        m_status = STARTING;\n\n        log.info(\"start: scheduler started\");\n    }","id":24662,"modified_method":"public synchronized void start() {\n        Assert.state(m_worker == null, \"The fiber has already run or is running\");\n\n        m_runner.start();\n        m_worker = new Thread(this, getName());\n        m_worker.start();\n        m_status = STARTING;\n\n        log().info(\"start: scheduler started\");\n    }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void pause() {\n        if (m_worker == null)\n            throw new IllegalStateException(\"The fiber has never been started\");\n\n        if (m_status == STOPPED || m_status == STOP_PENDING)\n            throw new IllegalStateException(\"The fiber is not running or a stop is pending\");\n\n        if (m_status == PAUSED)\n            return;\n\n        m_status = PAUSE_PENDING;\n        notifyAll();\n    }","id":24663,"modified_method":"public synchronized void pause() {\n        Assert.state(m_worker != null, \"The fiber has never been started\");\n        Assert.state(m_status != STOPPED && m_status != STOP_PENDING, \"The fiber is not running or a stop is pending\");\n\n        if (m_status == PAUSED) {\n            return;\n        }\n\n        m_status = PAUSE_PENDING;\n        notifyAll();\n    }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructs a new instance of the scheduler. The maximum number of\n     * executable threads is specified in the constructor. The executable\n     * threads are part of a runnable thread pool where the scheduled runnables\n     * are executed.\n     * \n     * @param parent\n     *            String prepended to \"Scheduler\" to create fiber name\n     * @param maxSize\n     *            The maximum size of the thread pool.\n     * @param lowMark\n     *            The low water mark ratios of thread size to threads when\n     *            threads are stopped.\n     * @param hiMark\n     *            The high water mark ratio of thread size to threads when\n     *            threads are started.\n     * \n     */\n    public LegacyScheduler(String parent, int maxSize, float lowMark, float hiMark) {\n        m_name = parent + \"Scheduler-\" + maxSize;\n        m_status = START_PENDING;\n        m_runner = new RunnableConsumerThreadPool(m_name + \" Pool\", lowMark, hiMark, maxSize);\n        m_queues = Collections.synchronizedMap(new TreeMap());\n        m_scheduled = 0;\n        m_worker = null;\n    }","id":24664,"modified_method":"/**\n     * Constructs a new instance of the scheduler. The maximum number of\n     * executable threads is specified in the constructor. The executable\n     * threads are part of a runnable thread pool where the scheduled runnables\n     * are executed.\n     * \n     * @param parent\n     *            String prepended to \"Scheduler\" to create fiber name\n     * @param maxSize\n     *            The maximum size of the thread pool.\n     * @param lowMark\n     *            The low water mark ratios of thread size to threads when\n     *            threads are stopped.\n     * @param hiMark\n     *            The high water mark ratio of thread size to threads when\n     *            threads are started.\n     * \n     */\n    public LegacyScheduler(String parent, int maxSize, float lowMark, float hiMark) {\n        String name = parent + \"Scheduler-\" + maxSize;\n        m_status = START_PENDING;\n        m_runner = new RunnableConsumerThreadPool(name + \" Pool\", lowMark, hiMark, maxSize);\n        m_queues = Collections.synchronizedMap(new TreeMap<Long, PeekableFifoQueue<ReadyRunnable>>());\n        m_scheduled = 0;\n        m_worker = null;\n    }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void resume() {\n        if (m_worker == null)\n            throw new IllegalStateException(\"The fiber has never been started\");\n\n        if (m_status == STOPPED || m_status == STOP_PENDING)\n            throw new IllegalStateException(\"The fiber is not running or a stop is pending\");\n\n        if (m_status == RUNNING)\n            return;\n\n        m_status = RESUME_PENDING;\n        notifyAll();\n    }","id":24665,"modified_method":"public synchronized void resume() {\n        Assert.state(m_worker != null, \"The fiber has never been started\");\n        Assert.state(m_status != STOPPED && m_status != STOP_PENDING, \"The fiber is not running or a stop is pending\");\n\n        if (m_status == RUNNING) {\n            return;\n        }\n\n        m_status = RESUME_PENDING;\n        notifyAll();\n    }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructs a new instance of the scheduler. The maximum number of\n     * executable threads is specified in the constructor. The executable\n     * threads are part of a runnable thread pool where the scheduled runnables\n     * are executed.\n     * \n     * @param parent\n     *            String prepended to \"Scheduler\" to create fiber name\n     * @param maxSize\n     *            The maximum size of the thread pool.\n     * \n     */\n    public LegacyScheduler(String parent, int maxSize) {\n        m_name = parent + \"Scheduler-\" + maxSize;\n        m_status = START_PENDING;\n        m_runner = new RunnableConsumerThreadPool(m_name + \" Pool\", 0.6f, 1.0f, maxSize);\n        m_queues = Collections.synchronizedMap(new TreeMap());\n        m_scheduled = 0;\n        m_worker = null;\n    }","id":24666,"modified_method":"/**\n     * Constructs a new instance of the scheduler. The maximum number of\n     * executable threads is specified in the constructor. The executable\n     * threads are part of a runnable thread pool where the scheduled runnables\n     * are executed.\n     * \n     * @param parent\n     *            String prepended to \"Scheduler\" to create fiber name\n     * @param maxSize\n     *            The maximum size of the thread pool.\n     * \n     */\n    public LegacyScheduler(String parent, int maxSize) {\n        String name = parent + \"Scheduler-\" + maxSize;\n        m_status = START_PENDING;\n        m_runner = new RunnableConsumerThreadPool(name + \" Pool\", 0.6f, 1.0f, maxSize);\n        m_queues = Collections.synchronizedMap(new TreeMap<Long, PeekableFifoQueue<ReadyRunnable>>());\n        m_scheduled = 0;\n        m_worker = null;\n    }","commit_id":"a0b0004ce0f125592d33164c8d84ed5a1fbbde26","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public ElementFrame(Document doc) {\n            this.element = doc;\n            parent = null;\n            started = true;\n            attributes = Collections.emptyList();\n            prefixes = Collections.emptyList();\n            uris = Collections.emptyList();\n            allAttributes = Collections.emptyList();\n        }","id":24667,"modified_method":"public ElementFrame(T doc) {\n            this.element = doc;\n            parent = null;\n            started = true;\n            attributes = Collections.emptyList();\n            prefixes = Collections.emptyList();\n            uris = Collections.emptyList();\n            allAttributes = Collections.emptyList();\n        }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"protected void newFrame(ElementFrame newFrame) {\n    }","id":24668,"modified_method":"protected void newFrame(ElementFrame<T, I> newFrame) {\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"protected abstract ElementFrame getChildFrame(int currentChild);","id":24669,"modified_method":"protected abstract ElementFrame<T, I> getChildFrame();","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"public Object getElement() {\n            return element;\n        }","id":24670,"modified_method":"public T getElement() {\n            return element;\n        }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * @param element\n     */\n    public AbstractDOMStreamReader(ElementFrame frame) {\n        this.frame = frame;\n        frames.push(this.frame);\n    }","id":24671,"modified_method":"/**\n     * @param element\n     */\n    public AbstractDOMStreamReader(ElementFrame<T, I> frame) {\n        this.frame = frame;\n        frames.push(this.frame);\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"public int next() throws XMLStreamException {\n        if (frame.ended) {\n            frames.pop();\n            if (!frames.empty()) {\n                frame = (ElementFrame)frames.peek();\n            } else {\n                currentEvent = END_DOCUMENT;\n                return currentEvent;\n            }\n        }\n\n        if (!frame.started) {\n            frame.started = true;\n            currentEvent = START_ELEMENT;\n        } else if (frame.currentAttribute < getAttributeCount() - 1) {\n            frame.currentAttribute++;\n            currentEvent = ATTRIBUTE;\n        } else if (frame.currentNamespace < getNamespaceCount() - 1) {\n            frame.currentNamespace++;\n            currentEvent = NAMESPACE;\n        } else if (frame.currentChild < getChildCount() - 1) {\n            frame.currentChild++;\n\n            currentEvent = moveToChild(frame.currentChild);\n\n            if (currentEvent == START_ELEMENT) {\n                ElementFrame newFrame = getChildFrame(frame.currentChild);\n                newFrame.started = true;\n                frame = newFrame;\n                frames.push(this.frame);\n                currentEvent = START_ELEMENT;\n\n                newFrame(newFrame);\n            }\n        } else {\n            frame.ended = true;\n            currentEvent = END_ELEMENT;\n            endElement();\n        }\n        return currentEvent;\n    }","id":24672,"modified_method":"public int next() throws XMLStreamException {\n        if (frame.ended) {\n            frames.pop();\n            if (!frames.empty()) {\n                frame = frames.peek();\n            } else {\n                currentEvent = END_DOCUMENT;\n                return currentEvent;\n            }\n        }\n\n        if (!frame.started) {\n            frame.started = true;\n            currentEvent = START_ELEMENT;\n        } else if (frame.currentAttribute < getAttributeCount() - 1) {\n            frame.currentAttribute++;\n            currentEvent = ATTRIBUTE;\n        } else if (frame.currentNamespace < getNamespaceCount() - 1) {\n            frame.currentNamespace++;\n            currentEvent = NAMESPACE;\n        } else if (hasMoreChildren()) {\n            currentEvent = nextChild();\n\n            if (currentEvent == START_ELEMENT) {\n                ElementFrame<T, I> newFrame = getChildFrame();\n                newFrame.started = true;\n                frame = newFrame;\n                frames.push(this.frame);\n                currentEvent = START_ELEMENT;\n\n                newFrame(newFrame);\n            }\n        } else {\n            frame.ended = true;\n            currentEvent = END_ELEMENT;\n            endElement();\n        }\n        return currentEvent;\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"public ElementFrame(Object element, ElementFrame parent) {\n            this.element = element;\n            this.parent = parent;\n        }","id":24673,"modified_method":"public ElementFrame(T element, ElementFrame<T, I> parent) {\n            this.element = element;\n            this.parent = parent;\n        }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected ElementFrame getChildFrame(int currentChild) {\n        return new ElementFrame(getCurrentElement().getContent(currentChild), getCurrentFrame());\n    }","id":24674,"modified_method":"@Override\n    protected ElementFrame<Element, Integer> getChildFrame() {\n        int currentChild = getCurrentFrame().getCurrentChild();\n        return new ElementFrame<Element, Integer>((Element)getCurrentElement().getContent(currentChild),\n                                                  getCurrentFrame(),\n                                                  -1);\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"public Element getCurrentElement() {\n        return (Element)getCurrentFrame().getElement();\n    }","id":24675,"modified_method":"public Element getCurrentElement() {\n        return getCurrentFrame().getElement();\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * @param element\n     */\n    public JDOMStreamReader(Element element) {\n        super(new ElementFrame(element, null));\n\n        namespaceContext = new JDOMNamespaceContext();\n        setupNamespaces(element);\n    }","id":24676,"modified_method":"/**\n     * @param element\n     */\n    public JDOMStreamReader(Element element) {\n        super(new ElementFrame<Element, Integer>(element, null, -1));\n\n        namespaceContext = new JDOMNamespaceContext();\n        setupNamespaces(element);\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public String getNamespaceURI(String prefix) {\n        ElementFrame frame = getCurrentFrame();\n\n        while (null != frame) {\n            int index = frame.prefixes.indexOf(prefix);\n            if (index != -1) {\n                return frame.uris.get(index);\n            }\n\n            if (frame.parent == null) {\n                return ((Element)frame.getElement()).lookupNamespaceURI(prefix);\n            }\n            frame = frame.parent;\n        }\n\n        return null;\n    }","id":24677,"modified_method":"@Override\n    public String getNamespaceURI(String prefix) {\n        ElementFrame<Node, Node> frame = getCurrentFrame();\n\n        while (null != frame) {\n            int index = frame.prefixes.indexOf(prefix);\n            if (index != -1) {\n                return frame.uris.get(index);\n            }\n\n            if (frame.parent == null) {\n                return ((Element)frame.getElement()).lookupNamespaceURI(prefix);\n            }\n            frame = frame.parent;\n        }\n\n        return null;\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"public W3CDOMStreamReader(Document doc) {\n        super(new ElementFrame(doc));\n        this.document = doc;\n    }","id":24678,"modified_method":"public W3CDOMStreamReader(Document doc) {\n        super(new ElementFrame<Node, Node>(doc));\n        this.document = doc;\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public String getElementText() throws XMLStreamException {\n        String result = DOMUtils.getContent(content);\n\n        ElementFrame frame = getCurrentFrame();\n        frame.ended = true;\n        currentEvent = END_ELEMENT;\n        endElement();\n\n        // we should not return null according to the StAx API javadoc\n        return result != null ? result : \"\";\n    }","id":24679,"modified_method":"@Override\n    public String getElementText() throws XMLStreamException {\n        String result = DOMUtils.getContent(content);\n\n        ElementFrame<Node, Node> frame = getCurrentFrame();\n        frame.ended = true;\n        currentEvent = END_ELEMENT;\n        endElement();\n\n        // we should not return null according to the StAx API javadoc\n        return result != null ? result : \"\";\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected ElementFrame getChildFrame(int currentChild) {\n        return new ElementFrame(getCurrentNode().getChildNodes().item(currentChild), getCurrentFrame());\n    }","id":24680,"modified_method":"@Override\n    protected ElementFrame<Node, Node> getChildFrame() {\n        return new ElementFrame<Node, Node>(getCurrentFrame().currentChild, \n                                getCurrentFrame());\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Find name spaces declaration in atrributes and move them to separate\n     * collection.\n     */\n    @Override\n    protected final void newFrame(ElementFrame frame) {\n        Node element = getCurrentNode();\n        frame.uris = new ArrayList<String>();\n        frame.prefixes = new ArrayList<String>();\n        frame.attributes = new ArrayList<Object>();\n\n        if (context == null) {\n            context = new W3CNamespaceContext();\n        }\n        if (element instanceof Element) {\n            context.setElement((Element)element);\n        }\n\n        NamedNodeMap nodes = element.getAttributes();\n\n        String ePrefix = element.getPrefix();\n        if (ePrefix == null) {\n            ePrefix = \"\";\n        }\n\n        if (nodes != null) {\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                String prefix = node.getPrefix();\n                String localName = node.getLocalName();\n                String value = node.getNodeValue();\n                String name = node.getNodeName();\n\n                if (prefix == null) {\n                    prefix = \"\";\n                }\n\n                if (name != null && \"xmlns\".equals(name)) {\n                    frame.uris.add(value);\n                    frame.prefixes.add(\"\");\n                } else if (prefix.length() > 0 && \"xmlns\".equals(prefix)) {\n                    frame.uris.add(value);\n                    frame.prefixes.add(localName);\n                } else if (name.startsWith(\"xmlns:\")) {\n                    prefix = name.substring(6);\n                    frame.uris.add(value);\n                    frame.prefixes.add(prefix);\n                } else {\n                    frame.attributes.add(node);\n                }\n            }\n        }\n    }","id":24681,"modified_method":"/**\n     * Find name spaces declaration in atrributes and move them to separate\n     * collection.\n     */\n    @Override\n    protected final void newFrame(ElementFrame<Node, Node> frame) {\n        Node element = getCurrentNode();\n        frame.uris = new ArrayList<String>();\n        frame.prefixes = new ArrayList<String>();\n        frame.attributes = new ArrayList<Object>();\n\n        if (context == null) {\n            context = new W3CNamespaceContext();\n        }\n        if (element instanceof Element) {\n            context.setElement((Element)element);\n        }\n\n        NamedNodeMap nodes = element.getAttributes();\n\n        String ePrefix = element.getPrefix();\n        if (ePrefix == null) {\n            ePrefix = \"\";\n        }\n\n        if (nodes != null) {\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                String prefix = node.getPrefix();\n                String localName = node.getLocalName();\n                String value = node.getNodeValue();\n                String name = node.getNodeName();\n\n                if (prefix == null) {\n                    prefix = \"\";\n                }\n\n                if (name != null && \"xmlns\".equals(name)) {\n                    frame.uris.add(value);\n                    frame.prefixes.add(\"\");\n                } else if (prefix.length() > 0 && \"xmlns\".equals(prefix)) {\n                    frame.uris.add(value);\n                    frame.prefixes.add(localName);\n                } else if (name.startsWith(\"xmlns:\")) {\n                    prefix = name.substring(6);\n                    frame.uris.add(value);\n                    frame.prefixes.add(prefix);\n                } else {\n                    frame.attributes.add(node);\n                }\n            }\n        }\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * @param element\n     */\n    public W3CDOMStreamReader(Element element) {\n        super(new ElementFrame(element, null));\n        newFrame(getCurrentFrame());\n                \n        this.document = element.getOwnerDocument();\n    }","id":24682,"modified_method":"/**\n     * @param element\n     */\n    public W3CDOMStreamReader(Element element) {\n        super(new ElementFrame<Node, Node>(element, null));\n        newFrame(getCurrentFrame());\n                \n        this.document = element.getOwnerDocument();\n    }","commit_id":"ab5a4d141dc3e7f20d1bb39ef40c8ddf99fbf312","url":"https://github.com/apache/cxf"},{"original_method":"/**\n\t * @see org.apache.wicket.request.IRequestCycleProcessor#resolve(org.apache.wicket.RequestCycle,\n\t *      org.apache.wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget resolve(final RequestCycle requestCycle,\n\t\tfinal RequestParameters requestParameters)\n\t{\n\t\tIRequestCodingStrategy requestCodingStrategy = requestCycle.getProcessor()\n\t\t\t.getRequestCodingStrategy();\n\n\t\tfinal String path = requestParameters.getPath();\n\t\tIRequestTarget target = null;\n\n\t\t// See whether this request points to a bookmarkable page\n\t\tif (requestParameters.getBookmarkablePageClass() != null)\n\t\t{\n\t\t\ttarget = resolveBookmarkablePage(requestCycle, requestParameters);\n\t\t}\n\t\t// See whether this request points to a rendered page\n\t\telse if (requestParameters.getComponentPath() != null)\n\t\t{\n\t\t\t// marks whether or not we will be processing this request\n\t\t\tboolean processRequest = true;\n\t\t\tsynchronized (requestCycle.getSession())\n\t\t\t{\n\t\t\t\t// we need to check if this request has been flagged as\n\t\t\t\t// process-only-if-path-is-active and if so make sure this\n\t\t\t\t// condition is met\n\t\t\t\tif (requestParameters.isOnlyProcessIfPathActive())\n\t\t\t\t{\n\t\t\t\t\t// this request has indeed been flagged as\n\t\t\t\t\t// process-only-if-path-is-active\n\n\t\t\t\t\tSession session = Session.get();\n\t\t\t\t\tIPageMap pageMap = session.pageMapForName(requestParameters.getPageMapName(),\n\t\t\t\t\t\tfalse);\n\t\t\t\t\tif (pageMap == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// requested pagemap no longer exists - ignore this\n\t\t\t\t\t\t// request\n\t\t\t\t\t\tprocessRequest = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if (pageMap instanceof AccessStackPageMap)\n\t\t\t\t\t{\n\t\t\t\t\t\tAccessStackPageMap accessStackPageMap = (AccessStackPageMap)pageMap;\n\t\t\t\t\t\tif (accessStackPageMap.getAccessStack().size() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfinal Access access = (Access)accessStackPageMap.getAccessStack()\n\t\t\t\t\t\t\t\t.peek();\n\n\t\t\t\t\t\t\tfinal int pageId = Integer.parseInt(Strings.firstPathComponent(\n\t\t\t\t\t\t\t\trequestParameters.getComponentPath(), Component.PATH_SEPARATOR));\n\n\t\t\t\t\t\t\tif (pageId != access.getId())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// the page is no longer the active page\n\t\t\t\t\t\t\t\t// - ignore this request\n\t\t\t\t\t\t\t\tprocessRequest = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfinal int version = requestParameters.getVersionNumber();\n\t\t\t\t\t\t\t\tif (version != Page.LATEST_VERSION &&\n\t\t\t\t\t\t\t\t\tversion != access.getVersion())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// version is no longer the active version -\n\t\t\t\t\t\t\t\t\t// ignore this request\n\t\t\t\t\t\t\t\t\tprocessRequest = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO also this should work..\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (processRequest)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttarget = resolveRenderedPage(requestCycle, requestParameters);\n\t\t\t\t}\n\t\t\t\tcatch (IgnoreAjaxRequestException e)\n\t\t\t\t{\n\t\t\t\t\ttarget = EmptyAjaxRequestTarget.getInstance();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRequest request = requestCycle.getRequest();\n\t\t\t\tif (request instanceof WebRequest && ((WebRequest)request).isAjax())\n\t\t\t\t{\n\t\t\t\t\t// if processRequest is false in an ajax request just have an empty ajax target\n\t\t\t\t\ttarget = EmptyAjaxRequestTarget.getInstance();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new PageExpiredException(\"Request cannot be processed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// See whether this request points to a shared resource\n\t\telse if (requestParameters.getResourceKey() != null)\n\t\t{\n\t\t\ttarget = resolveSharedResource(requestCycle, requestParameters);\n\t\t}\n\t\t// See whether this request points to the home page\n\t\telse if (Strings.isEmpty(path) || (\"/\".equals(path)))\n\t\t{\n\t\t\ttarget = resolveHomePageTarget(requestCycle, requestParameters);\n\t\t}\n\n\t\t// NOTE we are doing the mount check as the last item, so that it will\n\t\t// only be executed when everything else fails. This enables URLs like\n\t\t// /foo/bar/?wicket:bookmarkablePage=my.Page to be resolved, where\n\t\t// is either a valid mount or a non-valid mount. I (Eelco) am not\n\t\t// absolutely sure this is a great way to go, but it seems to have been\n\t\t// established as the default way of doing things. If we ever want to\n\t\t// tighten the algorithm up, it should be combined by going back to\n\t\t// unmounted paths so that requests with Wicket parameters like\n\t\t// 'bookmarkablePage' are always created and resolved in the same\n\t\t// fashion. There is a test for this in UrlMountingTest.\n\t\tif (target == null)\n\t\t{\n\t\t\t// still null? check for a mount\n\t\t\ttarget = requestCodingStrategy.targetForRequest(requestParameters);\n\n\t\t\tif (target == null && requestParameters.getComponentPath() != null)\n\t\t\t{\n\t\t\t\t// If the target is still null and there was a component path\n\t\t\t\t// then the Page could not be located in the session\n\t\t\t\tthrow new PageExpiredException(\n\t\t\t\t\t\"Cannot find the rendered page in session [pagemap=\" +\n\t\t\t\t\t\trequestParameters.getPageMapName() + \",componentPath=\" +\n\t\t\t\t\t\trequestParameters.getComponentPath() + \",versionNumber=\" +\n\t\t\t\t\t\trequestParameters.getVersionNumber() + \"]\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// a target was found, but not by looking up a mount. check whether\n\t\t\t// this is allowed\n\t\t\tif (Application.get().getSecuritySettings().getEnforceMounts() &&\n\t\t\t\trequestCodingStrategy.pathForTarget(target) != null)\n\t\t\t{\n\t\t\t\tString msg = \"Direct access not allowed for mounted targets\";\n\t\t\t\t// the target was mounted, but we got here via another path\n\t\t\t\t// : deny the request\n\t\t\t\tlog.error(msg + \" [request=\" + requestCycle.getRequest() + \",target=\" + target +\n\t\t\t\t\t\",session=\" + Session.get() + \"]\");\n\t\t\t\tthrow new AbortWithWebErrorCodeException(HttpServletResponse.SC_FORBIDDEN, msg);\n\t\t\t}\n\t\t}\n\n\t\t// (WICKET-1356) in case no target was found, return null here. RequestCycle will deal with\n\t\t// it\n\t\t// possible letting wicket filter to pass the request down the filter chain\n\t\t/*\n\t\t * if (target == null) { // if we get here, we have no recognized Wicket target, and thus //\n\t\t * regard this as a external (non-wicket) resource request on // this server return\n\t\t * resolveExternalResource(requestCycle); }\n\t\t */\n\n\t\treturn target;\n\t}","id":24683,"modified_method":"/**\n\t * @see org.apache.wicket.request.IRequestCycleProcessor#resolve(org.apache.wicket.RequestCycle,\n\t *      org.apache.wicket.request.RequestParameters)\n\t */\n\tpublic IRequestTarget resolve(final RequestCycle requestCycle,\n\t\tfinal RequestParameters requestParameters)\n\t{\n\t\tIRequestCodingStrategy requestCodingStrategy = requestCycle.getProcessor()\n\t\t\t.getRequestCodingStrategy();\n\n\t\tfinal String path = requestParameters.getPath();\n\t\tIRequestTarget target = null;\n\n\t\t// See whether this request points to a bookmarkable page\n\t\tif (requestParameters.getBookmarkablePageClass() != null)\n\t\t{\n\t\t\ttarget = resolveBookmarkablePage(requestCycle, requestParameters);\n\t\t}\n\t\t// See whether this request points to a rendered page\n\t\telse if (requestParameters.getComponentPath() != null)\n\t\t{\n\t\t\t// marks whether or not we will be processing this request\n\t\t\tboolean processRequest = true;\n\t\t\tsynchronized (requestCycle.getSession())\n\t\t\t{\n\t\t\t\t// we need to check if this request has been flagged as\n\t\t\t\t// process-only-if-path-is-active and if so make sure this\n\t\t\t\t// condition is met\n\t\t\t\tif (requestParameters.isOnlyProcessIfPathActive())\n\t\t\t\t{\n\t\t\t\t\t// this request has indeed been flagged as\n\t\t\t\t\t// process-only-if-path-is-active\n\n\t\t\t\t\tSession session = Session.get();\n\t\t\t\t\tIPageMap pageMap = session.pageMapForName(requestParameters.getPageMapName(),\n\t\t\t\t\t\tfalse);\n\t\t\t\t\tif (pageMap == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// requested pagemap no longer exists - ignore this\n\t\t\t\t\t\t// request\n\t\t\t\t\t\tprocessRequest = false;\n\t\t\t\t\t}\n\t\t\t\t\telse if (pageMap instanceof AccessStackPageMap)\n\t\t\t\t\t{\n\t\t\t\t\t\tAccessStackPageMap accessStackPageMap = (AccessStackPageMap)pageMap;\n\t\t\t\t\t\tif (accessStackPageMap.getAccessStack().size() > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfinal Access access = accessStackPageMap.getAccessStack().peek();\n\n\t\t\t\t\t\t\tfinal int pageId = Integer.parseInt(Strings.firstPathComponent(\n\t\t\t\t\t\t\t\trequestParameters.getComponentPath(), Component.PATH_SEPARATOR));\n\n\t\t\t\t\t\t\tif (pageId != access.getId())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// the page is no longer the active page\n\t\t\t\t\t\t\t\t// - ignore this request\n\t\t\t\t\t\t\t\tprocessRequest = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfinal int version = requestParameters.getVersionNumber();\n\t\t\t\t\t\t\t\tif (version != Page.LATEST_VERSION &&\n\t\t\t\t\t\t\t\t\tversion != access.getVersion())\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// version is no longer the active version -\n\t\t\t\t\t\t\t\t\t// ignore this request\n\t\t\t\t\t\t\t\t\tprocessRequest = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO also this should work..\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (processRequest)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttarget = resolveRenderedPage(requestCycle, requestParameters);\n\t\t\t\t}\n\t\t\t\tcatch (IgnoreAjaxRequestException e)\n\t\t\t\t{\n\t\t\t\t\ttarget = EmptyAjaxRequestTarget.getInstance();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tRequest request = requestCycle.getRequest();\n\t\t\t\tif (request instanceof WebRequest && ((WebRequest)request).isAjax())\n\t\t\t\t{\n\t\t\t\t\t// if processRequest is false in an ajax request just have an empty ajax target\n\t\t\t\t\ttarget = EmptyAjaxRequestTarget.getInstance();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new PageExpiredException(\"Request cannot be processed\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// See whether this request points to a shared resource\n\t\telse if (requestParameters.getResourceKey() != null)\n\t\t{\n\t\t\ttarget = resolveSharedResource(requestCycle, requestParameters);\n\t\t}\n\t\t// See whether this request points to the home page\n\t\telse if (Strings.isEmpty(path) || (\"/\".equals(path)))\n\t\t{\n\t\t\ttarget = resolveHomePageTarget(requestCycle, requestParameters);\n\t\t}\n\n\t\t// NOTE we are doing the mount check as the last item, so that it will\n\t\t// only be executed when everything else fails. This enables URLs like\n\t\t// /foo/bar/?wicket:bookmarkablePage=my.Page to be resolved, where\n\t\t// is either a valid mount or a non-valid mount. I (Eelco) am not\n\t\t// absolutely sure this is a great way to go, but it seems to have been\n\t\t// established as the default way of doing things. If we ever want to\n\t\t// tighten the algorithm up, it should be combined by going back to\n\t\t// unmounted paths so that requests with Wicket parameters like\n\t\t// 'bookmarkablePage' are always created and resolved in the same\n\t\t// fashion. There is a test for this in UrlMountingTest.\n\t\tif (target == null)\n\t\t{\n\t\t\t// still null? check for a mount\n\t\t\ttarget = requestCodingStrategy.targetForRequest(requestParameters);\n\n\t\t\tif (target == null && requestParameters.getComponentPath() != null)\n\t\t\t{\n\t\t\t\t// If the target is still null and there was a component path\n\t\t\t\t// then the Page could not be located in the session\n\t\t\t\tthrow new PageExpiredException(\n\t\t\t\t\t\"Cannot find the rendered page in session [pagemap=\" +\n\t\t\t\t\t\trequestParameters.getPageMapName() + \",componentPath=\" +\n\t\t\t\t\t\trequestParameters.getComponentPath() + \",versionNumber=\" +\n\t\t\t\t\t\trequestParameters.getVersionNumber() + \"]\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// a target was found, but not by looking up a mount. check whether\n\t\t\t// this is allowed\n\t\t\tif (Application.get().getSecuritySettings().getEnforceMounts() &&\n\t\t\t\trequestCodingStrategy.pathForTarget(target) != null)\n\t\t\t{\n\n\t\t\t\t// we make an excepion if the homepage itself was mounted, see WICKET-1898\n\t\t\t\tboolean homepage = false;\n\t\t\t\tif (target instanceof BookmarkablePageRequestTarget)\n\t\t\t\t{\n\t\t\t\t\tfinal BookmarkablePageRequestTarget bt = (BookmarkablePageRequestTarget)target;\n\t\t\t\t\tif (bt.getPageClass().equals(Application.get().getHomePage()))\n\t\t\t\t\t{\n\t\t\t\t\t\thomepage = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!homepage)\n\t\t\t\t{\n\t\t\t\t\tString msg = \"Direct access not allowed for mounted targets\";\n\t\t\t\t\t// the target was mounted, but we got here via another path\n\t\t\t\t\t// : deny the request\n\t\t\t\t\tlog.error(msg + \" [request=\" + requestCycle.getRequest() + \",target=\" + target +\n\t\t\t\t\t\t\",session=\" + Session.get() + \"]\");\n\t\t\t\t\tthrow new AbortWithWebErrorCodeException(HttpServletResponse.SC_FORBIDDEN, msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// (WICKET-1356) in case no target was found, return null here. RequestCycle will deal with\n\t\t// it\n\t\t// possible letting wicket filter to pass the request down the filter chain\n\t\t/*\n\t\t * if (target == null) { // if we get here, we have no recognized Wicket target, and thus //\n\t\t * regard this as a external (non-wicket) resource request on // this server return\n\t\t * resolveExternalResource(requestCycle); }\n\t\t */\n\n\t\treturn target;\n\t}","commit_id":"d8154899bf1f2194664bc6a487546c6715409c67","url":"https://github.com/apache/wicket"},{"original_method":"/**\r\n   * Optimizes the condition tree.\r\n   * \r\n   * @return\r\n   */\r\n  protected void optimize() {\r\n    if (compiledFilter != null)\r\n      optimizeBranch(null, compiledFilter.getRootCondition());\r\n  }","id":24684,"modified_method":"/**\r\n   * Optimizes the condition tree.\r\n   */\r\n  protected void optimize() {\r\n    if (compiledFilter != null)\r\n      optimizeBranch(null, compiledFilter.getRootCondition());\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean handleResult(final OIdentifiable iRecord, boolean iCloneIt) {\r\n    if (iRecord != null) {\r\n      resultCount++;\r\n\r\n      OIdentifiable recordCopy = iRecord instanceof ORecord<?> ? ((ORecord<?>) iRecord).copy() : iRecord.getIdentity().copy();\r\n\r\n      if (recordCopy != null)\r\n        // CALL THE LISTENER NOW\r\n        if (request.getResultListener() != null) {\r\n          final boolean result = request.getResultListener().result(recordCopy);\r\n          if (!result)\r\n            return false;\r\n        }\r\n\r\n      if (limit > -1 && resultCount >= limit)\r\n        // BREAK THE EXECUTION\r\n        return false;\r\n    }\r\n    return true;\r\n  }","id":24685,"modified_method":"protected boolean handleResult(final OIdentifiable iRecord, boolean iCloneIt) {\r\n    if (iRecord != null) {\r\n      resultCount++;\r\n\r\n      OIdentifiable recordCopy = iRecord instanceof ORecord<?> ? ((ORecord<?>) iRecord).copy() : iRecord.getIdentity().copy();\r\n\r\n      // CALL THE LISTENER NOW\r\n      if (recordCopy != null && request.getResultListener() != null) {\r\n        final boolean result = request.getResultListener().result(recordCopy);\r\n        if (!result)\r\n          return false;\r\n      }\r\n\r\n      if (limit > -1 && resultCount >= limit)\r\n        // BREAK THE EXECUTION\r\n        return false;\r\n    }\r\n    return true;\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void searchInClasses() {\r\n    final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n\r\n    final ODatabaseRecord database = getDatabase();\r\n    database.checkSecurity(ODatabaseSecurityResources.CLASS, ORole.PERMISSION_READ, cls.getName().toLowerCase());\r\n\r\n    // NO INDEXES: SCAN THE ENTIRE CLUSTER\r\n\r\n    OStorage.LOCKING_STRATEGY locking = context != null && context.getVariable(\"$locking\") != null ? (OStorage.LOCKING_STRATEGY) context\r\n        .getVariable(\"$locking\") : OStorage.LOCKING_STRATEGY.DEFAULT;\r\n\r\n    final ORID[] range = getRange();\r\n    target = new ORecordIteratorClass<ORecordInternal<?>>(database, (ODatabaseRecordAbstract) database, cls.getName(), true,\r\n        request.isUseCache(), false, locking).setRange(range[0], range[1]);\r\n  }","id":24686,"modified_method":"protected void searchInClasses() {\r\n    final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n\r\n    final ODatabaseRecord database = getDatabase();\r\n    database.checkSecurity(ODatabaseSecurityResources.CLASS, ORole.PERMISSION_READ, cls.getName().toLowerCase());\r\n\r\n    // NO INDEXES: SCAN THE ENTIRE CLUSTER\r\n\r\n    OStorage.LOCKING_STRATEGY locking = context != null && context.getVariable(\"$locking\") != null ? (OStorage.LOCKING_STRATEGY) context\r\n        .getVariable(\"$locking\") : OStorage.LOCKING_STRATEGY.DEFAULT;\r\n\r\n    final ORID[] range = getRange();\r\n    target = new ORecordIteratorClass<ORecordInternal<?>>(database, database, cls.getName(), true, request.isUseCache(), false,\r\n        locking).setRange(range[0], range[1]);\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Parses the strategy keyword if found.\r\n   */\r\n  protected boolean parseStrategy(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_STRATEGY))\r\n      return false;\r\n\r\n    parserNextWord(true);\r\n    final String strategyWord = parserGetLastWord();\r\n\r\n    try {\r\n      traverse.setStrategy(OTraverse.STRATEGY.valueOf(strategyWord.toUpperCase()));\r\n    } catch (IllegalArgumentException e) {\r\n      throwParsingException(\"Invalid \" + KEYWORD_STRATEGY + \". Use one between \" + OTraverse.STRATEGY.values());\r\n    }\r\n    return true;\r\n  }","id":24687,"modified_method":"/**\r\n   * Parses the strategy keyword if found.\r\n   */\r\n  protected boolean parseStrategy(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_STRATEGY))\r\n      return false;\r\n\r\n    parserNextWord(true);\r\n    final String strategyWord = parserGetLastWord();\r\n\r\n    try {\r\n      traverse.setStrategy(OTraverse.STRATEGY.valueOf(strategyWord.toUpperCase()));\r\n    } catch (IllegalArgumentException e) {\r\n      throwParsingException(\"Invalid \" + KEYWORD_STRATEGY + \". Use one between \" + Arrays.toString(OTraverse.STRATEGY.values()));\r\n    }\r\n    return true;\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected int parseFields() {\r\n    int currentPos = 0;\r\n    final StringBuilder word = new StringBuilder();\r\n\r\n    currentPos = nextWord(parserText, parserTextUpperCase, currentPos, word, true);\r\n    if (!word.toString().equals(KEYWORD_TRAVERSE))\r\n      return -1;\r\n\r\n    int fromPosition = parserTextUpperCase.indexOf(KEYWORD_FROM_2FIND, currentPos);\r\n    if (fromPosition == -1)\r\n      throw new OQueryParsingException(\"Missed \" + KEYWORD_FROM, parserText, currentPos);\r\n\r\n    Set<Object> fields = new HashSet<Object>();\r\n\r\n    final String fieldString = parserText.substring(currentPos, fromPosition).trim();\r\n    if (fieldString.length() > 0) {\r\n      // EXTRACT PROJECTIONS\r\n      final List<String> items = OStringSerializerHelper.smartSplit(fieldString, ',');\r\n\r\n      for (String field : items) {\r\n        final String fieldName = field.trim();\r\n\r\n        if (fieldName.contains(\"(\"))\r\n          fields.add(OSQLHelper.parseValue((OBaseParser) null, fieldName, context));\r\n        else\r\n          fields.add(fieldName);\r\n      }\r\n    } else\r\n      throw new OQueryParsingException(\"Missed field list to cross in TRAVERSE. Use \" + getSyntax(), parserText, currentPos);\r\n\r\n    currentPos = fromPosition + KEYWORD_FROM.length() + 1;\r\n\r\n    traverse.fields(fields);\r\n\r\n    return currentPos;\r\n  }","id":24688,"modified_method":"protected int parseFields() {\r\n    int currentPos = 0;\r\n    final StringBuilder word = new StringBuilder();\r\n\r\n    currentPos = nextWord(parserText, parserTextUpperCase, currentPos, word, true);\r\n    if (!word.toString().equals(KEYWORD_TRAVERSE))\r\n      return -1;\r\n\r\n    int fromPosition = parserTextUpperCase.indexOf(KEYWORD_FROM_2FIND, currentPos);\r\n    if (fromPosition == -1)\r\n      throw new OQueryParsingException(\"Missed \" + KEYWORD_FROM, parserText, currentPos);\r\n\r\n    Set<Object> fields = new HashSet<Object>();\r\n\r\n    final String fieldString = parserText.substring(currentPos, fromPosition).trim();\r\n    if (fieldString.length() > 0) {\r\n      // EXTRACT PROJECTIONS\r\n      final List<String> items = OStringSerializerHelper.smartSplit(fieldString, ',');\r\n\r\n      for (String field : items) {\r\n        final String fieldName = field.trim();\r\n\r\n        if (fieldName.contains(\"(\"))\r\n          fields.add(OSQLHelper.parseValue(null, fieldName, context));\r\n        else\r\n          fields.add(fieldName);\r\n      }\r\n    } else\r\n      throw new OQueryParsingException(\"Missed field list to cross in TRAVERSE. Use \" + getSyntax(), parserText, currentPos);\r\n\r\n    currentPos = fromPosition + KEYWORD_FROM.length() + 1;\r\n\r\n    traverse.fields(fields);\r\n\r\n    return currentPos;\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Object execute(final Map<Object, Object> iArgs) {\r\n    if (!assignTarget(iArgs))\r\n      throw new OQueryParsingException(\"No source found in query: specify class, cluster(s) or single record(s)\");\r\n\r\n    context = traverse.getContext();\r\n    context.beginExecution(timeoutMs, timeoutStrategy);\r\n\r\n    // BROWSE ALL THE RECORDS AND COLLECTS RESULT\r\n    final List<OIdentifiable> result = (List<OIdentifiable>) traverse.execute();\r\n    for (OIdentifiable r : result)\r\n      handleResult(r, true);\r\n\r\n    return getResult();\r\n  }","id":24689,"modified_method":"public Object execute(final Map<Object, Object> iArgs) {\r\n    if (!assignTarget(iArgs))\r\n      throw new OQueryParsingException(\"No source found in query: specify class, cluster(s) or single record(s)\");\r\n\r\n    context = traverse.getContext();\r\n    context.beginExecution(timeoutMs, timeoutStrategy);\r\n\r\n    // BROWSE ALL THE RECORDS AND COLLECTS RESULT\r\n    final List<OIdentifiable> result = traverse.execute();\r\n    for (OIdentifiable r : result)\r\n      handleResult(r, true);\r\n\r\n    return getResult();\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Compile the filter conditions only the first time.\r\n   */\r\n  public OCommandExecutorSQLTraverse parse(final OCommandRequest iRequest) {\r\n    super.parse(iRequest);\r\n\r\n    final int pos = parseFields();\r\n    if (pos == -1)\r\n      throw new OCommandSQLParsingException(\"Traverse must have the field list. Use \" + getSyntax());\r\n\r\n    int endPosition = parserText.length();\r\n    int endP = parserTextUpperCase.indexOf(\" \" + OCommandExecutorSQLTraverse.KEYWORD_LIMIT, parserGetCurrentPosition());\r\n    if (endP > -1 && endP < endPosition)\r\n      endPosition = endP;\r\n\r\n    parsedTarget = OSQLEngine.getInstance().parseTarget(parserText.substring(pos, endPosition), getContext(), KEYWORD_WHILE);\r\n\r\n    if (!parsedTarget.parserIsEnded()) {\r\n      parserSetCurrentPosition(parsedTarget.parserGetCurrentPosition() + pos);\r\n\r\n      parserNextWord(true);\r\n\r\n      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE))\r\n        // // TODO Remove the additional management of WHERE for TRAVERSE after a while\r\n        warnDeprecatedWhere();\r\n\r\n      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE) || parserGetLastWord().equalsIgnoreCase(KEYWORD_WHILE)) {\r\n\r\n        compiledFilter = OSQLEngine.getInstance().parseCondition(parserText.substring(parserGetCurrentPosition(), endPosition),\r\n            getContext(), KEYWORD_WHILE);\r\n\r\n        traverse.predicate(compiledFilter);\r\n        optimize();\r\n        parserSetCurrentPosition(compiledFilter.parserIsEnded() ? endPosition : compiledFilter.parserGetCurrentPosition()\r\n            + parserGetCurrentPosition());\r\n      } else\r\n        parserGoBack();\r\n\r\n    } else\r\n      parserSetCurrentPosition(-1);\r\n\r\n    parserSkipWhiteSpaces();\r\n\r\n    if (!parserIsEnded()) {\r\n      if (parserOptionalKeyword(KEYWORD_LIMIT, KEYWORD_SKIP, KEYWORD_OFFSET, KEYWORD_TIMEOUT, KEYWORD_STRATEGY)) {\r\n        final String w = parserGetLastWord();\r\n        if (w.equals(KEYWORD_LIMIT))\r\n          parseLimit(w);\r\n        else if (w.equals(KEYWORD_SKIP) || w.equals(KEYWORD_OFFSET))\r\n          parseSkip(w);\r\n        else if (w.equals(KEYWORD_TIMEOUT))\r\n          parseTimeout(w);\r\n        else if (w.equals(KEYWORD_STRATEGY))\r\n          parseStrategy(w);\r\n      }\r\n    }\r\n\r\n    if (limit == 0 || limit < -1)\r\n      throw new IllegalArgumentException(\"Limit must be > 0 or = -1 (no limit)\");\r\n    else\r\n      traverse.limit(limit);\r\n\r\n    ((OCommandRequestText) iRequest).getContext().setChild(traverse.getContext());\r\n\r\n    return this;\r\n  }","id":24690,"modified_method":"/**\r\n   * Compile the filter conditions only the first time.\r\n   */\r\n  public OCommandExecutorSQLTraverse parse(final OCommandRequest iRequest) {\r\n    super.parse(iRequest);\r\n\r\n    final int pos = parseFields();\r\n    if (pos == -1)\r\n      throw new OCommandSQLParsingException(\"Traverse must have the field list. Use \" + getSyntax());\r\n\r\n    int endPosition = parserText.length();\r\n    int endP = parserTextUpperCase.indexOf(\" \" + OCommandExecutorSQLTraverse.KEYWORD_LIMIT, parserGetCurrentPosition());\r\n    if (endP > -1 && endP < endPosition)\r\n      endPosition = endP;\r\n\r\n    parsedTarget = OSQLEngine.getInstance().parseTarget(parserText.substring(pos, endPosition), getContext(), KEYWORD_WHILE);\r\n\r\n    if (!parsedTarget.parserIsEnded()) {\r\n      parserSetCurrentPosition(parsedTarget.parserGetCurrentPosition() + pos);\r\n\r\n      parserNextWord(true);\r\n\r\n      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE))\r\n        // // TODO Remove the additional management of WHERE for TRAVERSE after a while\r\n        warnDeprecatedWhere();\r\n\r\n      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE) || parserGetLastWord().equalsIgnoreCase(KEYWORD_WHILE)) {\r\n\r\n        compiledFilter = OSQLEngine.getInstance().parseCondition(parserText.substring(parserGetCurrentPosition(), endPosition),\r\n            getContext(), KEYWORD_WHILE);\r\n\r\n        traverse.predicate(compiledFilter);\r\n        optimize();\r\n        parserSetCurrentPosition(compiledFilter.parserIsEnded() ? endPosition : compiledFilter.parserGetCurrentPosition()\r\n            + parserGetCurrentPosition());\r\n      } else\r\n        parserGoBack();\r\n\r\n    } else\r\n      parserSetCurrentPosition(-1);\r\n\r\n    parserSkipWhiteSpaces();\r\n\r\n    if (!parserIsEnded()) {\r\n      if (parserOptionalKeyword(KEYWORD_LIMIT, KEYWORD_SKIP, KEYWORD_OFFSET, KEYWORD_TIMEOUT, KEYWORD_STRATEGY)) {\r\n        final String w = parserGetLastWord();\r\n        if (w.equals(KEYWORD_LIMIT))\r\n          parseLimit(w);\r\n        else if (w.equals(KEYWORD_SKIP) || w.equals(KEYWORD_OFFSET))\r\n          parseSkip(w);\r\n        else if (w.equals(KEYWORD_TIMEOUT))\r\n          parseTimeout(w);\r\n        else if (w.equals(KEYWORD_STRATEGY))\r\n          parseStrategy(w);\r\n      }\r\n    }\r\n\r\n    if (limit == 0 || limit < -1)\r\n      throw new IllegalArgumentException(\"Limit must be > 0 or = -1 (no limit)\");\r\n    else\r\n      traverse.limit(limit);\r\n\r\n    iRequest.getContext().setChild(traverse.getContext());\r\n\r\n    return this;\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OTraverseAbstractProcess<?> currentProcess() {\r\n    return (OTraverseAbstractProcess<?>) context.peek();\r\n  }","id":24691,"modified_method":"public OTraverseAbstractProcess<?> currentProcess() {\r\n    return context.peek();\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OTraverse target(final OIdentifiable... iRecords) {\r\n    final List<OIdentifiable> list = new ArrayList<OIdentifiable>();\r\n    for (OIdentifiable id : iRecords)\r\n      list.add(id);\r\n    return target(list.iterator());\r\n  }","id":24692,"modified_method":"public OTraverse target(final OIdentifiable... iRecords) {\r\n    final List<OIdentifiable> list = new ArrayList<OIdentifiable>();\r\n    Collections.addAll(list, iRecords);\r\n    return target(list.iterator());\r\n  }","commit_id":"8dc39354bcbe4455494f01ffc1069759c5b51089","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void searchInClasses() {\r\n    final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n\r\n    final ODatabaseRecord database = getDatabase();\r\n    database.checkSecurity(ODatabaseSecurityResources.CLASS, ORole.PERMISSION_READ, cls.getName().toLowerCase());\r\n\r\n    // NO INDEXES: SCAN THE ENTIRE CLUSTER\r\n\r\n    OStorage.LOCKING_STRATEGY locking = context != null && context.getVariable(\"$locking\") != null ? (OStorage.LOCKING_STRATEGY) context\r\n        .getVariable(\"$locking\") : OStorage.LOCKING_STRATEGY.DEFAULT;\r\n\r\n    final ORID[] range = getRange();\r\n    target = new ORecordIteratorClass<ORecordInternal<?>>(database, (ODatabaseRecordAbstract) database, cls.getName(), true,\r\n        request.isUseCache(), false, locking).setRange(range[0], range[1]);\r\n  }","id":24693,"modified_method":"protected void searchInClasses() {\r\n    final OClass cls = parsedTarget.getTargetClasses().keySet().iterator().next();\r\n\r\n    final ODatabaseRecord database = getDatabase();\r\n    database.checkSecurity(ODatabaseSecurityResources.CLASS, ORole.PERMISSION_READ, cls.getName().toLowerCase());\r\n\r\n    // NO INDEXES: SCAN THE ENTIRE CLUSTER\r\n\r\n    OStorage.LOCKING_STRATEGY locking = context != null && context.getVariable(\"$locking\") != null ? (OStorage.LOCKING_STRATEGY) context\r\n        .getVariable(\"$locking\") : OStorage.LOCKING_STRATEGY.DEFAULT;\r\n\r\n    final ORID[] range = getRange();\r\n    target = new ORecordIteratorClass<ORecordInternal<?>>(database, database, cls.getName(), true, request.isUseCache(), false,\r\n        locking).setRange(range[0], range[1]);\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Optimizes the condition tree.\r\n   * \r\n   * @return\r\n   */\r\n  protected void optimize() {\r\n    if (compiledFilter != null)\r\n      optimizeBranch(null, compiledFilter.getRootCondition());\r\n  }","id":24694,"modified_method":"/**\r\n   * Optimizes the condition tree.\r\n   */\r\n  protected void optimize() {\r\n    if (compiledFilter != null)\r\n      optimizeBranch(null, compiledFilter.getRootCondition());\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected boolean handleResult(final OIdentifiable iRecord, boolean iCloneIt) {\r\n    if (iRecord != null) {\r\n      resultCount++;\r\n\r\n      OIdentifiable recordCopy = iRecord instanceof ORecord<?> ? ((ORecord<?>) iRecord).copy() : iRecord.getIdentity().copy();\r\n\r\n      if (recordCopy != null)\r\n        // CALL THE LISTENER NOW\r\n        if (request.getResultListener() != null) {\r\n          final boolean result = request.getResultListener().result(recordCopy);\r\n          if (!result)\r\n            return false;\r\n        }\r\n\r\n      if (limit > -1 && resultCount >= limit)\r\n        // BREAK THE EXECUTION\r\n        return false;\r\n    }\r\n    return true;\r\n  }","id":24695,"modified_method":"protected boolean handleResult(final OIdentifiable iRecord, boolean iCloneIt) {\r\n    if (iRecord != null) {\r\n      resultCount++;\r\n\r\n      OIdentifiable recordCopy = iRecord instanceof ORecord<?> ? ((ORecord<?>) iRecord).copy() : iRecord.getIdentity().copy();\r\n\r\n      // CALL THE LISTENER NOW\r\n      if (recordCopy != null && request.getResultListener() != null) {\r\n        final boolean result = request.getResultListener().result(recordCopy);\r\n        if (!result)\r\n          return false;\r\n      }\r\n\r\n      if (limit > -1 && resultCount >= limit)\r\n        // BREAK THE EXECUTION\r\n        return false;\r\n    }\r\n    return true;\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected int parseFields() {\r\n    int currentPos = 0;\r\n    final StringBuilder word = new StringBuilder();\r\n\r\n    currentPos = nextWord(parserText, parserTextUpperCase, currentPos, word, true);\r\n    if (!word.toString().equals(KEYWORD_TRAVERSE))\r\n      return -1;\r\n\r\n    int fromPosition = parserTextUpperCase.indexOf(KEYWORD_FROM_2FIND, currentPos);\r\n    if (fromPosition == -1)\r\n      throw new OQueryParsingException(\"Missed \" + KEYWORD_FROM, parserText, currentPos);\r\n\r\n    Set<Object> fields = new HashSet<Object>();\r\n\r\n    final String fieldString = parserText.substring(currentPos, fromPosition).trim();\r\n    if (fieldString.length() > 0) {\r\n      // EXTRACT PROJECTIONS\r\n      final List<String> items = OStringSerializerHelper.smartSplit(fieldString, ',');\r\n\r\n      for (String field : items) {\r\n        final String fieldName = field.trim();\r\n\r\n        if (fieldName.contains(\"(\"))\r\n          fields.add(OSQLHelper.parseValue((OBaseParser) null, fieldName, context));\r\n        else\r\n          fields.add(fieldName);\r\n      }\r\n    } else\r\n      throw new OQueryParsingException(\"Missed field list to cross in TRAVERSE. Use \" + getSyntax(), parserText, currentPos);\r\n\r\n    currentPos = fromPosition + KEYWORD_FROM.length() + 1;\r\n\r\n    traverse.fields(fields);\r\n\r\n    return currentPos;\r\n  }","id":24696,"modified_method":"protected int parseFields() {\r\n    int currentPos = 0;\r\n    final StringBuilder word = new StringBuilder();\r\n\r\n    currentPos = nextWord(parserText, parserTextUpperCase, currentPos, word, true);\r\n    if (!word.toString().equals(KEYWORD_TRAVERSE))\r\n      return -1;\r\n\r\n    int fromPosition = parserTextUpperCase.indexOf(KEYWORD_FROM_2FIND, currentPos);\r\n    if (fromPosition == -1)\r\n      throw new OQueryParsingException(\"Missed \" + KEYWORD_FROM, parserText, currentPos);\r\n\r\n    Set<Object> fields = new HashSet<Object>();\r\n\r\n    final String fieldString = parserText.substring(currentPos, fromPosition).trim();\r\n    if (fieldString.length() > 0) {\r\n      // EXTRACT PROJECTIONS\r\n      final List<String> items = OStringSerializerHelper.smartSplit(fieldString, ',');\r\n\r\n      for (String field : items) {\r\n        final String fieldName = field.trim();\r\n\r\n        if (fieldName.contains(\"(\"))\r\n          fields.add(OSQLHelper.parseValue(null, fieldName, context));\r\n        else\r\n          fields.add(fieldName);\r\n      }\r\n    } else\r\n      throw new OQueryParsingException(\"Missed field list to cross in TRAVERSE. Use \" + getSyntax(), parserText, currentPos);\r\n\r\n    currentPos = fromPosition + KEYWORD_FROM.length() + 1;\r\n\r\n    traverse.fields(fields);\r\n\r\n    return currentPos;\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Compile the filter conditions only the first time.\r\n   */\r\n  public OCommandExecutorSQLTraverse parse(final OCommandRequest iRequest) {\r\n    super.parse(iRequest);\r\n\r\n    final int pos = parseFields();\r\n    if (pos == -1)\r\n      throw new OCommandSQLParsingException(\"Traverse must have the field list. Use \" + getSyntax());\r\n\r\n    int endPosition = parserText.length();\r\n    int endP = parserTextUpperCase.indexOf(\" \" + OCommandExecutorSQLTraverse.KEYWORD_LIMIT, parserGetCurrentPosition());\r\n    if (endP > -1 && endP < endPosition)\r\n      endPosition = endP;\r\n\r\n    parsedTarget = OSQLEngine.getInstance().parseTarget(parserText.substring(pos, endPosition), getContext(), KEYWORD_WHILE);\r\n\r\n    if (!parsedTarget.parserIsEnded()) {\r\n      parserSetCurrentPosition(parsedTarget.parserGetCurrentPosition() + pos);\r\n\r\n      parserNextWord(true);\r\n\r\n      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE))\r\n        // // TODO Remove the additional management of WHERE for TRAVERSE after a while\r\n        warnDeprecatedWhere();\r\n\r\n      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE) || parserGetLastWord().equalsIgnoreCase(KEYWORD_WHILE)) {\r\n\r\n        compiledFilter = OSQLEngine.getInstance().parseCondition(parserText.substring(parserGetCurrentPosition(), endPosition),\r\n            getContext(), KEYWORD_WHILE);\r\n\r\n        traverse.predicate(compiledFilter);\r\n        optimize();\r\n        parserSetCurrentPosition(compiledFilter.parserIsEnded() ? endPosition : compiledFilter.parserGetCurrentPosition()\r\n            + parserGetCurrentPosition());\r\n      } else\r\n        parserGoBack();\r\n\r\n    } else\r\n      parserSetCurrentPosition(-1);\r\n\r\n    parserSkipWhiteSpaces();\r\n\r\n    if (!parserIsEnded()) {\r\n      if (parserOptionalKeyword(KEYWORD_LIMIT, KEYWORD_SKIP, KEYWORD_OFFSET, KEYWORD_TIMEOUT, KEYWORD_STRATEGY)) {\r\n        final String w = parserGetLastWord();\r\n        if (w.equals(KEYWORD_LIMIT))\r\n          parseLimit(w);\r\n        else if (w.equals(KEYWORD_SKIP) || w.equals(KEYWORD_OFFSET))\r\n          parseSkip(w);\r\n        else if (w.equals(KEYWORD_TIMEOUT))\r\n          parseTimeout(w);\r\n        else if (w.equals(KEYWORD_STRATEGY))\r\n          parseStrategy(w);\r\n      }\r\n    }\r\n\r\n    if (limit == 0 || limit < -1)\r\n      throw new IllegalArgumentException(\"Limit must be > 0 or = -1 (no limit)\");\r\n    else\r\n      traverse.limit(limit);\r\n\r\n    ((OCommandRequestText) iRequest).getContext().setChild(traverse.getContext());\r\n\r\n    return this;\r\n  }","id":24697,"modified_method":"/**\r\n   * Compile the filter conditions only the first time.\r\n   */\r\n  public OCommandExecutorSQLTraverse parse(final OCommandRequest iRequest) {\r\n    super.parse(iRequest);\r\n\r\n    final int pos = parseFields();\r\n    if (pos == -1)\r\n      throw new OCommandSQLParsingException(\"Traverse must have the field list. Use \" + getSyntax());\r\n\r\n    int endPosition = parserText.length();\r\n    int endP = parserTextUpperCase.indexOf(\" \" + OCommandExecutorSQLTraverse.KEYWORD_LIMIT, parserGetCurrentPosition());\r\n    if (endP > -1 && endP < endPosition)\r\n      endPosition = endP;\r\n\r\n    parsedTarget = OSQLEngine.getInstance().parseTarget(parserText.substring(pos, endPosition), getContext(), KEYWORD_WHILE);\r\n\r\n    if (!parsedTarget.parserIsEnded()) {\r\n      parserSetCurrentPosition(parsedTarget.parserGetCurrentPosition() + pos);\r\n\r\n      parserNextWord(true);\r\n\r\n      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE))\r\n        // // TODO Remove the additional management of WHERE for TRAVERSE after a while\r\n        warnDeprecatedWhere();\r\n\r\n      if (parserGetLastWord().equalsIgnoreCase(KEYWORD_WHERE) || parserGetLastWord().equalsIgnoreCase(KEYWORD_WHILE)) {\r\n\r\n        compiledFilter = OSQLEngine.getInstance().parseCondition(parserText.substring(parserGetCurrentPosition(), endPosition),\r\n            getContext(), KEYWORD_WHILE);\r\n\r\n        traverse.predicate(compiledFilter);\r\n        optimize();\r\n        parserSetCurrentPosition(compiledFilter.parserIsEnded() ? endPosition : compiledFilter.parserGetCurrentPosition()\r\n            + parserGetCurrentPosition());\r\n      } else\r\n        parserGoBack();\r\n\r\n    } else\r\n      parserSetCurrentPosition(-1);\r\n\r\n    parserSkipWhiteSpaces();\r\n\r\n    if (!parserIsEnded()) {\r\n      if (parserOptionalKeyword(KEYWORD_LIMIT, KEYWORD_SKIP, KEYWORD_OFFSET, KEYWORD_TIMEOUT, KEYWORD_STRATEGY)) {\r\n        final String w = parserGetLastWord();\r\n        if (w.equals(KEYWORD_LIMIT))\r\n          parseLimit(w);\r\n        else if (w.equals(KEYWORD_SKIP) || w.equals(KEYWORD_OFFSET))\r\n          parseSkip(w);\r\n        else if (w.equals(KEYWORD_TIMEOUT))\r\n          parseTimeout(w);\r\n        else if (w.equals(KEYWORD_STRATEGY))\r\n          parseStrategy(w);\r\n      }\r\n    }\r\n\r\n    if (limit == 0 || limit < -1)\r\n      throw new IllegalArgumentException(\"Limit must be > 0 or = -1 (no limit)\");\r\n    else\r\n      traverse.limit(limit);\r\n\r\n    iRequest.getContext().setChild(traverse.getContext());\r\n\r\n    return this;\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Parses the strategy keyword if found.\r\n   */\r\n  protected boolean parseStrategy(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_STRATEGY))\r\n      return false;\r\n\r\n    parserNextWord(true);\r\n    final String strategyWord = parserGetLastWord();\r\n\r\n    try {\r\n      traverse.setStrategy(OTraverse.STRATEGY.valueOf(strategyWord.toUpperCase()));\r\n    } catch (IllegalArgumentException e) {\r\n      throwParsingException(\"Invalid \" + KEYWORD_STRATEGY + \". Use one between \" + OTraverse.STRATEGY.values());\r\n    }\r\n    return true;\r\n  }","id":24698,"modified_method":"/**\r\n   * Parses the strategy keyword if found.\r\n   */\r\n  protected boolean parseStrategy(final String w) throws OCommandSQLParsingException {\r\n    if (!w.equals(KEYWORD_STRATEGY))\r\n      return false;\r\n\r\n    parserNextWord(true);\r\n    final String strategyWord = parserGetLastWord();\r\n\r\n    try {\r\n      traverse.setStrategy(OTraverse.STRATEGY.valueOf(strategyWord.toUpperCase()));\r\n    } catch (IllegalArgumentException e) {\r\n      throwParsingException(\"Invalid \" + KEYWORD_STRATEGY + \". Use one between \" + Arrays.toString(OTraverse.STRATEGY.values()));\r\n    }\r\n    return true;\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Object execute(final Map<Object, Object> iArgs) {\r\n    if (!assignTarget(iArgs))\r\n      throw new OQueryParsingException(\"No source found in query: specify class, cluster(s) or single record(s)\");\r\n\r\n    context = traverse.getContext();\r\n    context.beginExecution(timeoutMs, timeoutStrategy);\r\n\r\n    // BROWSE ALL THE RECORDS AND COLLECTS RESULT\r\n    final List<OIdentifiable> result = (List<OIdentifiable>) traverse.execute();\r\n    for (OIdentifiable r : result)\r\n      handleResult(r, true);\r\n\r\n    return getResult();\r\n  }","id":24699,"modified_method":"public Object execute(final Map<Object, Object> iArgs) {\r\n    if (!assignTarget(iArgs))\r\n      throw new OQueryParsingException(\"No source found in query: specify class, cluster(s) or single record(s)\");\r\n\r\n    context = traverse.getContext();\r\n    context.beginExecution(timeoutMs, timeoutStrategy);\r\n\r\n    // BROWSE ALL THE RECORDS AND COLLECTS RESULT\r\n    final List<OIdentifiable> result = traverse.execute();\r\n    for (OIdentifiable r : result)\r\n      handleResult(r, true);\r\n\r\n    return getResult();\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OTraverse target(final OIdentifiable... iRecords) {\r\n    final List<OIdentifiable> list = new ArrayList<OIdentifiable>();\r\n    for (OIdentifiable id : iRecords)\r\n      list.add(id);\r\n    return target(list.iterator());\r\n  }","id":24700,"modified_method":"public OTraverse target(final OIdentifiable... iRecords) {\r\n    final List<OIdentifiable> list = new ArrayList<OIdentifiable>();\r\n    Collections.addAll(list, iRecords);\r\n    return target(list.iterator());\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OTraverseAbstractProcess<?> currentProcess() {\r\n    return (OTraverseAbstractProcess<?>) context.peek();\r\n  }","id":24701,"modified_method":"public OTraverseAbstractProcess<?> currentProcess() {\r\n    return context.peek();\r\n  }","commit_id":"cf182ccdb0f1cbd5c81e3e6ee1b4f17c84997efb","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Constructs a new instance of the scheduler. The maximum number of\n     * executable threads is specified in the constructor. The executable\n     * threads are part of a runnable thread pool where the scheduled runnables\n     * are executed.\n     * \n     * @param parent\n     *            String prepended to \"Scheduler\" to create fiber name\n     * @param maxSize\n     *            The maximum size of the thread pool.\n     * @param lowMark\n     *            The low water mark ratios of thread size to threads when\n     *            threads are stopped.\n     * @param hiMark\n     *            The high water mark ratio of thread size to threads when\n     *            threads are started.\n     * \n     */\n    public LegacyScheduler(String parent, int maxSize, float lowMark, float hiMark) {\n        m_name = parent + \"Scheduler-\" + maxSize;\n        m_status = START_PENDING;\n        m_runner = new RunnableConsumerThreadPool(m_name + \" Pool\", lowMark, hiMark, maxSize);\n        m_queues = Collections.synchronizedMap(new TreeMap());\n        m_scheduled = 0;\n        m_worker = null;\n    }","id":24702,"modified_method":"/**\n     * Constructs a new instance of the scheduler. The maximum number of\n     * executable threads is specified in the constructor. The executable\n     * threads are part of a runnable thread pool where the scheduled runnables\n     * are executed.\n     * \n     * @param parent\n     *            String prepended to \"Scheduler\" to create fiber name\n     * @param maxSize\n     *            The maximum size of the thread pool.\n     * @param lowMark\n     *            The low water mark ratios of thread size to threads when\n     *            threads are stopped.\n     * @param hiMark\n     *            The high water mark ratio of thread size to threads when\n     *            threads are started.\n     * \n     */\n    public LegacyScheduler(String parent, int maxSize, float lowMark, float hiMark) {\n        String name = parent + \"Scheduler-\" + maxSize;\n        m_status = START_PENDING;\n        m_runner = new RunnableConsumerThreadPool(name + \" Pool\", lowMark, hiMark, maxSize);\n        m_queues = Collections.synchronizedMap(new TreeMap<Long, PeekableFifoQueue<ReadyRunnable>>());\n        m_scheduled = 0;\n        m_worker = null;\n    }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Constructs a new instance of the scheduler. The maximum number of\n     * executable threads is specified in the constructor. The executable\n     * threads are part of a runnable thread pool where the scheduled runnables\n     * are executed.\n     * \n     * @param parent\n     *            String prepended to \"Scheduler\" to create fiber name\n     * @param maxSize\n     *            The maximum size of the thread pool.\n     * \n     */\n    public LegacyScheduler(String parent, int maxSize) {\n        m_name = parent + \"Scheduler-\" + maxSize;\n        m_status = START_PENDING;\n        m_runner = new RunnableConsumerThreadPool(m_name + \" Pool\", 0.6f, 1.0f, maxSize);\n        m_queues = Collections.synchronizedMap(new TreeMap());\n        m_scheduled = 0;\n        m_worker = null;\n    }","id":24703,"modified_method":"/**\n     * Constructs a new instance of the scheduler. The maximum number of\n     * executable threads is specified in the constructor. The executable\n     * threads are part of a runnable thread pool where the scheduled runnables\n     * are executed.\n     * \n     * @param parent\n     *            String prepended to \"Scheduler\" to create fiber name\n     * @param maxSize\n     *            The maximum size of the thread pool.\n     * \n     */\n    public LegacyScheduler(String parent, int maxSize) {\n        String name = parent + \"Scheduler-\" + maxSize;\n        m_status = START_PENDING;\n        m_runner = new RunnableConsumerThreadPool(name + \" Pool\", 0.6f, 1.0f, maxSize);\n        m_queues = Collections.synchronizedMap(new TreeMap<Long, PeekableFifoQueue<ReadyRunnable>>());\n        m_scheduled = 0;\n        m_worker = null;\n    }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void pause() {\n        if (m_worker == null)\n            throw new IllegalStateException(\"The fiber has never been started\");\n\n        if (m_status == STOPPED || m_status == STOP_PENDING)\n            throw new IllegalStateException(\"The fiber is not running or a stop is pending\");\n\n        if (m_status == PAUSED)\n            return;\n\n        m_status = PAUSE_PENDING;\n        notifyAll();\n    }","id":24704,"modified_method":"public synchronized void pause() {\n        Assert.state(m_worker != null, \"The fiber has never been started\");\n        Assert.state(m_status != STOPPED && m_status != STOP_PENDING, \"The fiber is not running or a stop is pending\");\n\n        if (m_status == PAUSED) {\n            return;\n        }\n\n        m_status = PAUSE_PENDING;\n        notifyAll();\n    }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n         * This method allows the caller to peek at the next object that would\n         * be returned on a <code>remove<\/code> call. If the queue is\n         * currently empty then the caller is blocked until an object is put\n         * into the queue.\n         * \n         * @return The object that would be returned on the next call to\n         *         <code>remove<\/code>.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized Object peek() throws InterruptedException, FifoQueueException {\n            if (m_hold == null)\n                m_hold = super.remove(1L);\n\n            return m_hold;\n        }","id":24705,"modified_method":"/**\n         * This method allows the caller to peek at the next object that would\n         * be returned on a <code>remove<\/code> call. If the queue is\n         * currently empty then the caller is blocked until an object is put\n         * into the queue.\n         * \n         * @return The object that would be returned on the next call to\n         *         <code>remove<\/code>.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized T peek() throws InterruptedException, FifoQueueException {\n            if (m_hold == null) {\n                m_hold = super.remove(1L);\n            }\n\n            return m_hold;\n        }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n         * Removes the next element from the queue and returns it to the caller.\n         * If there is no objects available then the caller is blocked until an\n         * item is available.\n         * \n         * @return The next element in the queue.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized Object remove() throws InterruptedException, FifoQueueException {\n            Object rval = null;\n            if (m_hold != null) {\n                rval = m_hold;\n                m_hold = null;\n            } else {\n                rval = super.remove();\n            }\n\n            return rval;\n        }","id":24706,"modified_method":"/**\n         * Removes the next element from the queue and returns it to the caller.\n         * If there is no objects available then the caller is blocked until an\n         * item is available.\n         * \n         * @return The next element in the queue.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized T remove() throws InterruptedException, FifoQueueException {\n            T rval = null;\n            if (m_hold != null) {\n                rval = m_hold;\n                m_hold = null;\n            } else {\n                rval = super.remove();\n            }\n\n            return rval;\n        }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void start() {\n        if (m_worker != null)\n            throw new IllegalStateException(\"The fiber has already run or is running\");\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        m_runner.start();\n        m_worker = new Thread(this, getName());\n        m_worker.start();\n        m_status = STARTING;\n\n        log.info(\"start: scheduler started\");\n    }","id":24707,"modified_method":"public synchronized void start() {\n        Assert.state(m_worker == null, \"The fiber has already run or is running\");\n\n        m_runner.start();\n        m_worker = new Thread(this, getName());\n        m_worker.start();\n        m_status = STARTING;\n\n        log().info(\"start: scheduler started\");\n    }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * This method is used to schedule a ready runnable in the system. The\n     * interval is used as the key for determining which queue to add the\n     * runnable.\n     * \n     * @param runnable\n     *            The element to run when interval expires.\n     * @param interval\n     *            The queue to add the runnable to.\n     * \n     * @throws java.lang.RuntimeException\n     *             Thrown if an error occurs adding the element to the queue.\n     */\n    public synchronized void schedule(ReadyRunnable runnable, long interval) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"schedule: Adding ready runnable \"+runnable+\" at interval \" + interval);\n        }\n\n        Long key = new Long(interval);\n        if (!m_queues.containsKey(key)) {\n            if (log.isDebugEnabled())\n                log.debug(\"schedule: interval queue did not exist, a new one has been created\");\n            m_queues.put(key, new PeekableFifoQueue());\n        }\n\n        try {\n            ((FifoQueue) m_queues.get(key)).add(runnable);\n            if (m_scheduled++ == 0) {\n                if (log.isDebugEnabled())\n                    log.debug(\"schedule: queue element added, calling notify all since none were scheduled\");\n                notifyAll();\n            } else if (log.isDebugEnabled()) {\n                log.debug(\"schedule: queue element added, notification not performed\");\n            }\n        } catch (InterruptedException ie) {\n            if (log.isInfoEnabled())\n                log.info(\"schedule: failed to add new ready runnable instance \"+runnable+\" to scheduler\", ie);\n            Thread.currentThread().interrupt();\n        } catch (FifoQueueException ex) {\n            if (log.isInfoEnabled())\n                log.info(\"schedule: failed to add new ready runnable instance \"+runnable+\" to scheduler\", ex);\n            throw new UndeclaredThrowableException(ex);\n        }\n    }","id":24708,"modified_method":"/**\n     * This method is used to schedule a ready runnable in the system. The\n     * interval is used as the key for determining which queue to add the\n     * runnable.\n     * \n     * @param runnable\n     *            The element to run when interval expires.\n     * @param interval\n     *            The queue to add the runnable to.\n     * \n     * @throws java.lang.RuntimeException\n     *             Thrown if an error occurs adding the element to the queue.\n     */\n    public synchronized void schedule(ReadyRunnable runnable, long interval) {\n        if (log().isDebugEnabled()) {\n            log().debug(\"schedule: Adding ready runnable \"+runnable+\" at interval \" + interval);\n        }\n\n        Long key = new Long(interval);\n        if (!m_queues.containsKey(key)) {\n            if (log().isDebugEnabled()) {\n                log().debug(\"schedule: interval queue did not exist, a new one has been created\");\n            }\n            m_queues.put(key, new PeekableFifoQueue<ReadyRunnable>());\n        }\n\n        try {\n            m_queues.get(key).add(runnable);\n            if (m_scheduled++ == 0) {\n                log().debug(\"schedule: queue element added, calling notify all since none were scheduled\");\n                notifyAll();\n            } else if (log().isDebugEnabled()) {\n                log().debug(\"schedule: queue element added, notification not performed\");\n            }\n        } catch (InterruptedException e) {\n            log().info(\"schedule: failed to add new ready runnable instance \" + runnable + \" to scheduler: \" + e, e);\n            Thread.currentThread().interrupt();\n        } catch (FifoQueueException e) {\n            log().info(\"schedule: failed to add new ready runnable instance \" + runnable + \" to scheduler: \" + e, e);\n            throw new UndeclaredThrowableException(e);\n        }\n    }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n         * Removes the next element from the queue and returns it to the caller.\n         * If there is no objects available then the caller is blocked until an\n         * item is available. If an object is not available within the time\n         * frame specified by <code>timeout<\/code>.\n         * \n         * @param timeout\n         *            The maximum time to wait.\n         * \n         * @return The next element in the queue.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized Object remove(long timeout) throws InterruptedException, FifoQueueException {\n            Object rval = null;\n            if (m_hold != null) {\n                rval = m_hold;\n                m_hold = null;\n            } else {\n                rval = super.remove(timeout);\n            }\n\n            return rval;\n        }","id":24709,"modified_method":"/**\n         * Removes the next element from the queue and returns it to the caller.\n         * If there is no objects available then the caller is blocked until an\n         * item is available. If an object is not available within the time\n         * frame specified by <code>timeout<\/code>.\n         * \n         * @param timeout\n         *            The maximum time to wait.\n         * \n         * @return The next element in the queue.\n         * \n         * @throws java.lang.InterruptedException\n         *             Thrown if the thread is interrupted.\n         * @throws org.opennms.core.queue.FifoQueueException\n         *             Thrown if an error occurs removing an item from the\n         *             queue.\n         */\n        public synchronized T remove(long timeout) throws InterruptedException, FifoQueueException {\n            T rval = null;\n            if (m_hold != null) {\n                rval = m_hold;\n                m_hold = null;\n            } else {\n                rval = super.remove(timeout);\n            }\n\n            return rval;\n        }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void stop() {\n        if (m_worker == null)\n            throw new IllegalStateException(\"The fiber has never been started\");\n\n        Category log = ThreadCategory.getInstance(getClass());\n\n        m_status = STOP_PENDING;\n        m_worker.interrupt();\n        m_runner.stop();\n\n        log.info(\"stop: scheduler stopped\");\n    }","id":24710,"modified_method":"public synchronized void stop() {\n        Assert.state(m_worker != null, \"The fiber has never been started\");\n\n        m_status = STOP_PENDING;\n        m_worker.interrupt();\n        m_runner.stop();\n\n        log().info(\"stop: scheduler stopped\");\n    }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public synchronized void resume() {\n        if (m_worker == null)\n            throw new IllegalStateException(\"The fiber has never been started\");\n\n        if (m_status == STOPPED || m_status == STOP_PENDING)\n            throw new IllegalStateException(\"The fiber is not running or a stop is pending\");\n\n        if (m_status == RUNNING)\n            return;\n\n        m_status = RESUME_PENDING;\n        notifyAll();\n    }","id":24711,"modified_method":"public synchronized void resume() {\n        Assert.state(m_worker != null, \"The fiber has never been started\");\n        Assert.state(m_status != STOPPED && m_status != STOP_PENDING, \"The fiber is not running or a stop is pending\");\n\n        if (m_status == RUNNING) {\n            return;\n        }\n\n        m_status = RESUME_PENDING;\n        notifyAll();\n    }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * The main method of the scheduler. This method is responsible for checking\n     * the runnable queues for ready objects and then enqueuing them into the\n     * thread pool for execution.\n     * \n     */\n    public void run() {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        synchronized (this) {\n            m_status = RUNNING;\n        }\n\n        if (log.isDebugEnabled())\n            log.debug(\"run: scheduler running\");\n\n        // Loop until a fatal exception occurs or until\n        // the thread is interrupted.\n        //\n        for (;;) {\n            // block if there is nothing in the queue(s)\n            // When something is added to the queue it\n            // signals us to wakeup\n            //\n            synchronized (this) {\n                \n                if (m_status != RUNNING && m_status != PAUSED && m_status != PAUSE_PENDING && m_status != RESUME_PENDING) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"run: status = \" + m_status + \", time to exit\");\n                    break;\n                }\n\n                // if paused or pause pending then block\n                while (m_status == PAUSE_PENDING || m_status == PAUSED) {\n                    if (m_status == PAUSE_PENDING && log.isDebugEnabled())\n                        log.debug(\"run: pausing.\");\n                    m_status = PAUSED;\n                    try {\n                        wait();\n                    } catch (InterruptedException ex) {\n                        // exit\n                        break;\n                    }\n                }\n\n                // if resume pending then change to running\n\n                if (m_status == RESUME_PENDING) {\n                    if (log.isDebugEnabled())\n                        log.debug(\"run: resuming.\");\n                    \n                    m_status = RUNNING;\n                }\n\n                if (m_scheduled == 0) {\n                    try {\n                        if (log.isDebugEnabled())\n                            log.debug(\"run: no ready runnables scheduled, waiting...\");\n                        wait();\n                    } catch (InterruptedException ex) {\n                        break;\n                    }\n                }\n            }\n\n            // cycle through the queues checking for\n            // what's ready to run. The queues are keyed\n            // by the interval, but the mapped elements\n            // are peekable fifo queues.\n            //\n            int runned = 0;\n            FifoQueue out = m_runner.getRunQueue();\n            synchronized (m_queues) {\n                // get an iterator so that we can cycle\n                // through the queue elements.\n                //\n                Iterator iter = m_queues.entrySet().iterator();\n                while (iter.hasNext()) {\n                    // Peak for Runnable objects until\n                    // there are no more ready runnables\n                    //\n                    // Also, only go through each queue once!\n                    // if we didn't add a count then it would\n                    // be possible to starve other queues.\n                    //\n                    PeekableFifoQueue in = (PeekableFifoQueue) ((Map.Entry) iter.next()).getValue();\n                    ReadyRunnable readyRun = null;\n                    int maxLoops = in.size();\n                    do {\n                        try {\n                            readyRun = (ReadyRunnable) in.peek();\n                            if (readyRun != null && readyRun.isReady()) {\n                                if (log.isDebugEnabled()) {\n                                    log.debug(\"run: found ready runnable \"+readyRun);\n                                }\n\n                                // Pop the interface/readyRunnable from the\n                                // queue for execution.\n                                //\n                                in.remove();\n\n                                // Add runnable to the execution queue\n                                out.add(readyRun);\n                                ++runned;\n                            }\n                        } catch (InterruptedException ex) {\n                            return; // jump all the way out\n                        } catch (FifoQueueException qe) {\n                            throw new UndeclaredThrowableException(qe);\n                        }\n\n                    } while (readyRun != null && readyRun.isReady() && --maxLoops > 0);\n                }\n            }\n\n            // Wait for 1 second if there were no runnables\n            // executed during this loop, otherwise just\n            // start over.\n            //\n            synchronized (this) {\n                m_scheduled -= runned;\n                if (runned == 0) {\n                    try {\n                        wait(1000);\n                    } catch (InterruptedException ex) {\n                        break; // exit for loop\n                    }\n                }\n            }\n\n        } // end for(;;)\n\n        if (log.isDebugEnabled())\n            log.debug(\"run: scheduler exiting, state = STOPPED\");\n        synchronized (this) {\n            m_status = STOPPED;\n        }\n\n    }","id":24712,"modified_method":"/**\n     * The main method of the scheduler. This method is responsible for checking\n     * the runnable queues for ready objects and then enqueuing them into the\n     * thread pool for execution.\n     */\n    public void run() {\n        synchronized (this) {\n            m_status = RUNNING;\n        }\n\n        log().debug(\"run: scheduler running\");\n\n        /*\n         * Loop until a fatal exception occurs or until\n         * the thread is interrupted.\n         */\n        for (;;) {\n            /*\n             * Block if there is nothing in the queue(s).\n             * When something is added to the queue it\n             * signals us to wakeup.\n             */\n            synchronized (this) {\n                \n                if (m_status != RUNNING && m_status != PAUSED && m_status != PAUSE_PENDING && m_status != RESUME_PENDING) {\n                    if (log().isDebugEnabled()) {\n                        log().debug(\"run: status = \" + m_status + \", time to exit\");\n                    }\n                    break;\n                }\n\n                // if paused or pause pending then block\n                while (m_status == PAUSE_PENDING || m_status == PAUSED) {\n                    if (m_status == PAUSE_PENDING) {\n                        log().debug(\"run: pausing.\");\n                    }\n                    m_status = PAUSED;\n                    try {\n                        wait();\n                    } catch (InterruptedException ex) {\n                        // exit\n                        break;\n                    }\n                }\n\n                // if resume pending then change to running\n\n                if (m_status == RESUME_PENDING) {\n                    log().debug(\"run: resuming.\");\n                    \n                    m_status = RUNNING;\n                }\n\n                if (m_scheduled == 0) {\n                    try {\n                        log().debug(\"run: no ready runnables scheduled, waiting...\");\n                        wait();\n                    } catch (InterruptedException ex) {\n                        break;\n                    }\n                }\n            }\n\n            /*\n             * Cycle through the queues checking for\n             * what's ready to run.  The queues are keyed\n             * by the interval, but the mapped elements\n             * are peekable fifo queues.\n             */\n            int runned = 0;\n            FifoQueue<Runnable> out = m_runner.getRunQueue();\n            synchronized (m_queues) {\n                /*\n                 * Get an iterator so that we can cycle\n                 * through the queue elements.\n                 */\n                for (Entry<Long, PeekableFifoQueue<ReadyRunnable>> entry : m_queues.entrySet()) {\n                    /*\n                     * Peak for Runnable objects until\n                     * there are no more ready runnables.\n                     *\n                     * Also, only go through each queue once!\n                     * if we didn't add a count then it would\n                     * be possible to starve other queues.\n                     */\n                    PeekableFifoQueue<ReadyRunnable> in = entry.getValue();\n                    ReadyRunnable readyRun = null;\n                    int maxLoops = in.size();\n                    do {\n                        try {\n                            readyRun = in.peek();\n                            if (readyRun != null && readyRun.isReady()) {\n                                if (log().isDebugEnabled()) {\n                                    log().debug(\"run: found ready runnable \"+readyRun);\n                                }\n\n                                /*\n                                 * Pop the interface/readyRunnable from the\n                                 * queue for execution.\n                                 */\n                                in.remove();\n\n                                // Add runnable to the execution queue\n                                out.add(readyRun);\n                                ++runned;\n                            }\n                        } catch (InterruptedException e) {\n                            return; // jump all the way out\n                        } catch (FifoQueueException e) {\n                            throw new UndeclaredThrowableException(e);\n                        }\n\n                    } while (readyRun != null && readyRun.isReady() && --maxLoops > 0);\n                }\n            }\n\n            /*\n             * Wait for 1 second if there were no runnables\n             * executed during this loop, otherwise just\n             * start over.\n             */\n            synchronized (this) {\n                m_scheduled -= runned;\n                if (runned == 0) {\n                    try {\n                        wait(1000);\n                    } catch (InterruptedException ex) {\n                        break; // exit for loop\n                    }\n                }\n            }\n\n        }\n\n        log().debug(\"run: scheduler exiting, state = STOPPED\");\n        synchronized (this) {\n            m_status = STOPPED;\n        }\n\n    }","commit_id":"488882538994c0a07bff8c24d074af79fa1c13e6","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n\t * Schedules a cache synchronization for the database instance. If the database instance is idle,\n\t * the cache synchronization will be run immediately. Otherwise, the task will be deffered \n\t * until all running threads have returned.\n\t * @param syncEvent One of {@link org.exist.storage.sync.Sync#MINOR_SYNC} or \n         * {@link org.exist.storage.sync.Sync#MINOR_SYNC}   \n\t */\n\tpublic void triggerSync(int syncEvent) {\n\t\t//TOUNDERSTAND (pb) : synchronized, so... \"schedules\" or, rather, \"executes\" ? \"schedules\" (WM)\n        if (status == SHUTDOWN)\n            return;\n        synchronized (this) {\n\t\t\t//Are there available brokers ?\n\t\t    // TOUNDERSTAND (pb) : the trigger is ignored !\n            // WM: yes, it seems wrong!!\n//\t\t\tif(inactiveBrokers.size() == 0)\n//\t\t\t\treturn;\n\t\t\t//TODO : switch on syncEvent and throw an exception if it is inaccurate ?\n\t\t\t//Is the database instance idle ?\n\t\t\tif (inactiveBrokers.size() == brokersCount) {\n\t\t\t\t//Borrow a broker\n\t\t\t\t//TODO : this broker is *not* marked as active and may be reused by another process !\n                // No other brokers are running at this time, so there's no risk.\n\t\t\t\t//TODO : use get() then release the broker ?\n                // No, might lead to a deadlock.\n\t\t\t\tDBBroker broker = (DBBroker) inactiveBrokers.pop();\n\t\t\t\t//Do the synchonization job\n\t\t\t\tsync(broker, syncEvent);\n            inactiveBrokers.push(broker);\n\t\t\t\tsyncRequired = false;\n\t\t\t} else {\n\t\t\t\t//Put the synchonization job into the queue\n\t\t\t\t//TODO : check that we don't replace high priority Sync.MAJOR_SYNC by a lesser priority sync !\n\t\t\t\tthis.syncEvent = syncEvent;\n\t\t\t\tsyncRequired = true;\n\t\t\t}\n\t\t}\n\t}","id":24713,"modified_method":"/**\n\t * Schedules a cache synchronization for the database instance. If the database instance is idle,\n\t * the cache synchronization will be run immediately. Otherwise, the task will be deffered \n\t * until all running threads have returned.\n\t * @param syncEvent One of {@link org.exist.storage.sync.Sync#MINOR_SYNC} or \n         * {@link org.exist.storage.sync.Sync#MINOR_SYNC}   \n\t */\n\tpublic void triggerSync(int syncEvent) {\n\t\t//TOUNDERSTAND (pb) : synchronized, so... \"schedules\" or, rather, \"executes\" ? \"schedules\" (WM)\n        if (status == SHUTDOWN)\n            return;\n        synchronized (this) {\n\t\t\t//Are there available brokers ?\n\t\t    // TOUNDERSTAND (pb) : the trigger is ignored !\n            // WM: yes, it seems wrong!!\n//\t\t\tif(inactiveBrokers.size() == 0)\n//\t\t\t\treturn;\n\t\t\t//TODO : switch on syncEvent and throw an exception if it is inaccurate ?\n\t\t\t//Is the database instance idle ?\n\t\t\tif (inactiveBrokers.size() == brokersCount) {\n\t\t\t\t//Borrow a broker\n\t\t\t\t//TODO : this broker is *not* marked as active and may be reused by another process !\n                // No other brokers are running at this time, so there's no risk.\n\t\t\t\t//TODO : use get() then release the broker ?\n                // No, might lead to a deadlock.\n\t\t\t\tDBBroker broker = inactiveBrokers.pop();\n\t\t\t\t//Do the synchonization job\n\t\t\t\tsync(broker, syncEvent);\n            inactiveBrokers.push(broker);\n\t\t\t\tsyncRequired = false;\n\t\t\t} else {\n\t\t\t\t//Put the synchonization job into the queue\n\t\t\t\t//TODO : check that we don't replace high priority Sync.MAJOR_SYNC by a lesser priority sync !\n\t\t\t\tthis.syncEvent = syncEvent;\n\t\t\t\tsyncRequired = true;\n\t\t\t}\n\t\t}\n\t}","commit_id":"fae37e9c982da36836a142282029b0c2d89fe156","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * Shuts downs the database instance\n\t * @param killed <code>true<\/code> when the JVM is (cleanly) exiting\n\t */\n\tpublic void shutdown(boolean killed) {\n        if (status == SHUTDOWN)\n            // we are already shut down\n            return;\n\n        LOG.info(\"Database is shutting down ...\");\n\n        status = SHUTDOWN;\n        processMonitor.stopRunningJobs();\n        java.util.concurrent.locks.Lock lock = transactionManager.getLock();\n        try {\n            // wait for currently running system tasks before we shutdown\n            // they will have a lock on the transactionManager\n            lock.lock();\n\n            synchronized (this) {\n\n                // release transaction log to allow remaining brokers to complete\n                // their job\n                lock.unlock();\n\n                notificationService.debug();\n\n                //Notify all running tasks that we are shutting down\n\n                //Shutdown the scheduler\n                scheduler.shutdown(false); \t//asynchronous\n\n                while(!scheduler.isShutdown()) \t//wait for shutdown\n                {\n                    try\n                    {\n                        wait(250);\n                    }\n                    catch(InterruptedException e) {}\n                    signalSystemStatus(SIGNAL_SHUTDOWN);\n                }\n\n                //Notify all running XQueries that we are shutting down\n                processMonitor.killAll(500);\n                //TODO : close other objects using varying methods ? set them to null ?\n                //cacheManager.something();\n                //xQueryPool.something();\n                //collectionConfigurationManager.something();\n                //collectionCache.something();\n                //xmlReaderPool.close();\n\n                if (isTransactional())\n                    transactionManager.getJournal().flushToLog(true, true);\n\n                boolean hangingThreads = false;\n                long waitStart = System.currentTimeMillis();\n                //Are there active brokers ?\n                if (activeBrokers.size() > 0) {\n                    LOG.info(\"Waiting \" + maxShutdownWait + \"ms for remaining threads to shut down...\");\n                    while (activeBrokers.size() > 0) {\n                        try {\n                            //Wait until they become inactive...\n                            this.wait(1000);\n                        } catch (InterruptedException e) {\n                        }\n                        signalSystemStatus(SIGNAL_SHUTDOWN);\n                        //...or force the shutdown\n                        if(maxShutdownWait > -1 && System.currentTimeMillis() - waitStart > maxShutdownWait) {\n                            LOG.warn(\"Not all threads returned. Forcing shutdown ...\");\n                            hangingThreads = true;\n                            break;\n                        }\n                    }\n                }\n                LOG.debug(\"Calling shutdown ...\");\n                \n                // closing down external indexes\n                try {\n                    indexManager.shutdown();\n                } catch (DBException e) {\n                    LOG.warn(\"Error during index shutdown: \" + e.getMessage(), e);\n                }\n\n                //TODO : replace the following code by get()/release() statements ?\n                // WM: deadlock risk if not all brokers returned properly.\n                DBBroker broker = null;\n                if (inactiveBrokers.isEmpty())\n                    try {\n                        broker = createBroker();\n                    } catch (EXistException e) {\n                        LOG.warn(\"could not create instance for shutdown. Giving up.\");\n                    }\n                else\n                    //TODO : this broker is *not* marked as active and may be reused by another process !\n                    //TODO : use get() then release the broker ?\n                    // WM: deadlock risk if not all brokers returned properly.\n                    broker = (DBBroker)inactiveBrokers.peek();\n\n                //TOUNDERSTAND (pb) : shutdown() is called on only *one* broker ?\n                // WM: yes, the database files are shared, so only one broker is needed to close them for all\n                if (broker != null) {\n                    broker.setUser(SecurityManager.SYSTEM_USER);\n                    broker.shutdown();\n                }\n                collectionCacheMgr.deregisterCache(collectionCache);\n\n                signalSystemStatus(SIGNAL_SHUTDOWN);\n\n                if (hangingThreads)\n                    // do not write a checkpoint if some threads did not return before shutdown\n                    // there might be dirty transactions\n                    transactionManager.shutdown(false);\n                else\n                    transactionManager.shutdown(true);\n\n                // deregister JMX MBeans\n                AgentFactory.getInstance().closeDBInstance(this);\n\n                //Invalidate the configuration\n                conf = null;\n                //Clear the living instances container\n                instances.remove(instanceName);\n\n                if (!isReadOnly)\n                    // release the lock on the data directory\n                    dataLock.release();\n\n                LOG.info(\"shutdown complete !\");\n\n                //Last instance closes the house...\n                //TOUNDERSTAND (pb) : !killed or, rather, killed ?\n                // TODO: WM: check usage of killed!\n                if(instances.size() == 0 && !killed) {\n                    LOG.debug(\"removing shutdown hook\");\n                    Runtime.getRuntime().removeShutdownHook(shutdownHook);\n                }\n                if (shutdownListener != null)\n                    shutdownListener.shutdown(instanceName, instances.size());\n            }\n        } finally {\n            // clear instance variables, just to be sure they will be garbage collected\n            // the test suite restarts the db a few hundred times\n            transactionManager = null;\n            collectionCache = null;\n            collectionCacheMgr = null;\n            xQueryPool = null;\n            processMonitor = null;\n            collectionConfigurationManager = null;\n            notificationService = null;\n            indexManager = null;\n            scheduler = null;\n            xmlReaderPool = null;\n            shutdownListener = null;\n            securityManager = null;\n            notificationService = null;\n        }\n\t}","id":24714,"modified_method":"/**\n\t * Shuts downs the database instance\n\t * @param killed <code>true<\/code> when the JVM is (cleanly) exiting\n\t */\n\tpublic void shutdown(boolean killed) {\n        if (status == SHUTDOWN)\n            // we are already shut down\n            return;\n\n        LOG.info(\"Database is shutting down ...\");\n\n        status = SHUTDOWN;\n        processMonitor.stopRunningJobs();\n        java.util.concurrent.locks.Lock lock = transactionManager.getLock();\n        try {\n            // wait for currently running system tasks before we shutdown\n            // they will have a lock on the transactionManager\n            lock.lock();\n\n            synchronized (this) {\n\n                // release transaction log to allow remaining brokers to complete\n                // their job\n                lock.unlock();\n\n                notificationService.debug();\n\n                //Notify all running tasks that we are shutting down\n\n                //Shutdown the scheduler\n                scheduler.shutdown(false); \t//asynchronous\n\n                while(!scheduler.isShutdown()) \t//wait for shutdown\n                {\n                    try\n                    {\n                        wait(250);\n                    }\n                    catch(InterruptedException e) {}\n                    signalSystemStatus(SIGNAL_SHUTDOWN);\n                }\n\n                //Notify all running XQueries that we are shutting down\n                processMonitor.killAll(500);\n                //TODO : close other objects using varying methods ? set them to null ?\n                //cacheManager.something();\n                //xQueryPool.something();\n                //collectionConfigurationManager.something();\n                //collectionCache.something();\n                //xmlReaderPool.close();\n\n                if (isTransactional())\n                    transactionManager.getJournal().flushToLog(true, true);\n\n                boolean hangingThreads = false;\n                long waitStart = System.currentTimeMillis();\n                //Are there active brokers ?\n                if (!activeBrokers.isEmpty()) {\n                    LOG.info(\"Waiting \" + maxShutdownWait + \"ms for remaining threads to shut down...\");\n                    while (!activeBrokers.isEmpty()) {\n                        try {\n                            //Wait until they become inactive...\n                            this.wait(1000);\n                        } catch (InterruptedException e) {\n                        }\n                        signalSystemStatus(SIGNAL_SHUTDOWN);\n                        //...or force the shutdown\n                        if(maxShutdownWait > -1 && System.currentTimeMillis() - waitStart > maxShutdownWait) {\n                            LOG.warn(\"Not all threads returned. Forcing shutdown ...\");\n                            hangingThreads = true;\n                            break;\n                        }\n                    }\n                }\n                LOG.debug(\"Calling shutdown ...\");\n                \n                // closing down external indexes\n                try {\n                    indexManager.shutdown();\n                } catch (DBException e) {\n                    LOG.warn(\"Error during index shutdown: \" + e.getMessage(), e);\n                }\n\n                //TODO : replace the following code by get()/release() statements ?\n                // WM: deadlock risk if not all brokers returned properly.\n                DBBroker broker = null;\n                if (inactiveBrokers.isEmpty())\n                    try {\n                        broker = createBroker();\n                    } catch (EXistException e) {\n                        LOG.warn(\"could not create instance for shutdown. Giving up.\");\n                    }\n                else\n                    //TODO : this broker is *not* marked as active and may be reused by another process !\n                    //TODO : use get() then release the broker ?\n                    // WM: deadlock risk if not all brokers returned properly.\n                    broker = inactiveBrokers.peek();\n\n                //TOUNDERSTAND (pb) : shutdown() is called on only *one* broker ?\n                // WM: yes, the database files are shared, so only one broker is needed to close them for all\n                if (broker != null) {\n                    broker.setUser(SecurityManager.SYSTEM_USER);\n                    broker.shutdown();\n                }\n                collectionCacheMgr.deregisterCache(collectionCache);\n\n                signalSystemStatus(SIGNAL_SHUTDOWN);\n\n                if (hangingThreads)\n                    // do not write a checkpoint if some threads did not return before shutdown\n                    // there might be dirty transactions\n                    transactionManager.shutdown(false);\n                else\n                    transactionManager.shutdown(true);\n\n                // deregister JMX MBeans\n                AgentFactory.getInstance().closeDBInstance(this);\n\n                //Invalidate the configuration\n                conf = null;\n                //Clear the living instances container\n                instances.remove(instanceName);\n\n                if (!isReadOnly)\n                    // release the lock on the data directory\n                    dataLock.release();\n\n                LOG.info(\"shutdown complete !\");\n\n                //Last instance closes the house...\n                //TOUNDERSTAND (pb) : !killed or, rather, killed ?\n                // TODO: WM: check usage of killed!\n                if(instances.size() == 0 && !killed) {\n                    LOG.debug(\"removing shutdown hook\");\n                    Runtime.getRuntime().removeShutdownHook(shutdownHook);\n                }\n                if (shutdownListener != null)\n                    shutdownListener.shutdown(instanceName, instances.size());\n            }\n        } finally {\n            // clear instance variables, just to be sure they will be garbage collected\n            // the test suite restarts the db a few hundred times\n            transactionManager = null;\n            collectionCache = null;\n            collectionCacheMgr = null;\n            xQueryPool = null;\n            processMonitor = null;\n            collectionConfigurationManager = null;\n            notificationService = null;\n            indexManager = null;\n            scheduler = null;\n            xmlReaderPool = null;\n            shutdownListener = null;\n            securityManager = null;\n            notificationService = null;\n        }\n\t}","commit_id":"fae37e9c982da36836a142282029b0c2d89fe156","url":"https://github.com/eXist-db/exist"},{"original_method":"/** Returns an active broker for the database instance.\n\t * @return The broker\n\t * @throws EXistException If the instance is not available (stopped or not configured)\n\t */\n    //TODO : rename as getBroker ? getInstance (when refactored) ?\n\tpublic DBBroker get(User user) throws EXistException {\n\t\tif (!isInstanceConfigured()) {\t\t\n\t\t\tthrow new EXistException(\"database instance '\" + instanceName + \"' is not available\");\n\t\t}\n\n\t\tsynchronized(this) {\n\t\t\t//Try to get an active broker\n\t\t\tDBBroker broker = (DBBroker)activeBrokers.get(Thread.currentThread());\n\t\t\t//Use it...\n\t\t\t//TOUNDERSTAND (pb) : why not pop a broker from the inactive ones rather than maintaining reference counters ?\n\t        // WM: a thread may call this more than once in the sequence of operations, i.e. calls to get/release can\n\t        // be nested. Returning a new broker every time would lead to a deadlock condition if two threads have\n\t        // to wait for a broker to become available. We thus use reference counts and return\n\t        // the same broker instance for each thread.\n\t\t\tif(broker != null) {\n\t\t\t\t//increase its number of uses\n\t\t\t\tbroker.incReferenceCount();\n\t            if (user != null)\n\t                broker.setUser(user);\n\t            return broker;\n\t\t\t\t//TODO : share the code with what is below (including notifyAll) ?\n\t            // WM: notifyAll is not necessary if we don't have to wait for a broker.\n\t\t\t}\n\t\t\t\n\t\t\t//No active broker : get one ASAP\n\t\t\n            while (serviceModeUser != null && user != null && !user.equals(serviceModeUser)) {\n                try {\n                    LOG.debug(\"Db instance is in service mode. Waiting for db to become available again ...\");\n                    wait();\n                } catch (InterruptedException e) {\n                }\n            }\n            //Are there any available brokers ?\n\t\t\tif (inactiveBrokers.isEmpty()) {\n\t\t\t\t//There are no available brokers. If allowed... \n\t\t\t\tif (brokersCount < maxBrokers)\n\t\t\t\t\t//... create one\n\t\t\t\t\tcreateBroker();\n\t\t\t\telse\n\t\t\t\t\t//... or wait until there is one available\n\t\t\t\t\twhile (inactiveBrokers.isEmpty()) {\n\t\t\t\t\t\tLOG.debug(\"waiting for a broker to become available\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tbroker = (DBBroker) inactiveBrokers.pop();\n\t\t\t//activate the broker\n\t\t\tactiveBrokers.put(Thread.currentThread(), broker);\n\t\t\tbroker.incReferenceCount();\n            if (user != null)\n                broker.setUser(user);\n            //Inform the other threads that we have a new-comer\n            // TODO: do they really need to be informed here???????\n            this.notifyAll();\n\t\t\treturn broker;\n\t\t}\n\t}","id":24715,"modified_method":"/** Returns an active broker for the database instance.\n\t * @return The broker\n\t * @throws EXistException If the instance is not available (stopped or not configured)\n\t */\n    //TODO : rename as getBroker ? getInstance (when refactored) ?\n\tpublic DBBroker get(User user) throws EXistException {\n\t\tif (!isInstanceConfigured()) {\t\t\n\t\t\tthrow new EXistException(\"database instance '\" + instanceName + \"' is not available\");\n\t\t}\n\n\t\tsynchronized(this) {\n\t\t\t//Try to get an active broker\n\t\t\tDBBroker broker = activeBrokers.get(Thread.currentThread());\n\t\t\t//Use it...\n\t\t\t//TOUNDERSTAND (pb) : why not pop a broker from the inactive ones rather than maintaining reference counters ?\n\t        // WM: a thread may call this more than once in the sequence of operations, i.e. calls to get/release can\n\t        // be nested. Returning a new broker every time would lead to a deadlock condition if two threads have\n\t        // to wait for a broker to become available. We thus use reference counts and return\n\t        // the same broker instance for each thread.\n\t\t\tif(broker != null) {\n\t\t\t\t//increase its number of uses\n\t\t\t\tbroker.incReferenceCount();\n\t            if (user != null)\n\t                broker.setUser(user);\n\t            return broker;\n\t\t\t\t//TODO : share the code with what is below (including notifyAll) ?\n\t            // WM: notifyAll is not necessary if we don't have to wait for a broker.\n\t\t\t}\n\t\t\t\n\t\t\t//No active broker : get one ASAP\n\t\t\n            while (serviceModeUser != null && user != null && !user.equals(serviceModeUser)) {\n                try {\n                    LOG.debug(\"Db instance is in service mode. Waiting for db to become available again ...\");\n                    wait();\n                } catch (InterruptedException e) {\n                }\n            }\n            //Are there any available brokers ?\n\t\t\tif (inactiveBrokers.isEmpty()) {\n\t\t\t\t//There are no available brokers. If allowed... \n\t\t\t\tif (brokersCount < maxBrokers)\n\t\t\t\t\t//... create one\n\t\t\t\t\tcreateBroker();\n\t\t\t\telse\n\t\t\t\t\t//... or wait until there is one available\n\t\t\t\t\twhile (inactiveBrokers.isEmpty()) {\n\t\t\t\t\t\tLOG.debug(\"waiting for a broker to become available\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tthis.wait();\n\t\t\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tbroker = inactiveBrokers.pop();\n\t\t\t//activate the broker\n\t\t\tactiveBrokers.put(Thread.currentThread(), broker);\n\t\t\tbroker.incReferenceCount();\n            if (user != null)\n                broker.setUser(user);\n            //Inform the other threads that we have a new-comer\n            // TODO: do they really need to be informed here???????\n            this.notifyAll();\n\t\t\treturn broker;\n\t\t}\n\t}","commit_id":"fae37e9c982da36836a142282029b0c2d89fe156","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n\t * Releases a broker for the database instance. If it is no more used, make if invactive.\n\t * If there are pending system maintenance tasks,\n\t * the method will block until these tasks have finished. \n\t * \n\t *@param  broker  The broker to be released\n\t */\n\t//TODO : rename as releaseBroker ? releaseInstance (when refactored) ?\n\tpublic void release(DBBroker broker) {\n\t\t//TODO : Is this test accurate ?\n        // might be null as release() is often called within a finally block\n\t\tif (broker == null)\n\t\t\treturn;\n\t\t\n\t\tsynchronized (this) {\n\t\t\t//TOUNDERSTAND (pb) : why maintain reference counters rather than pushing the brokers to the stack ?\n\t\t\t//TODO : first check that the broker is active ! If not, return immediately.\n\t\t\tbroker.decReferenceCount();\n\t\t\tif(broker.getReferenceCount() > 0) {\n\t\t\t\t//it is still in use and thus can't be marked as inactive\n\t\t\t\treturn;  \n\t\t\t}\n\t\t\t\n\t        //Broker is no more used : inactivate it\n\t\t\n            for (int i = 0; i < inactiveBrokers.size(); i++) {\n                if (broker == inactiveBrokers.get(i)) {\n                    LOG.error(\"Broker is already in the inactive list!!!\");\n                    return;\n                }\n            }\n\t\t\t\n\t        if (activeBrokers.remove(Thread.currentThread())==null) {\n\t             LOG.error(\"release() has been called from the wrong thread for broker \"+broker.getId());\n\t             // Cleanup the state of activeBrokers\n\t             for (Object t : activeBrokers.keySet()) {\n\t                if (activeBrokers.get(t)==broker) {\n\t                     activeBrokers.remove(t);\n\t                     break;\n\t                }\n\t             }\n\t         }\n\t\t\tinactiveBrokers.push(broker);\n\t\t\t//If the database is now idle, do some useful stuff\n\t\t\tif(activeBrokers.size() == 0) {\n\t\t\t\t//TODO : use a \"clean\" dedicated method (we have some below) ?\n\t\t\t\tif (syncRequired) {\n\t\t\t\t\t//Note that the broker is not yet really inactive ;-)\n\t\t\t\t\tsync(broker, syncEvent);\n\t\t\t\t\tthis.syncRequired = false;\n                    this.checkpoint = false;\n\t\t\t\t}\t\t\t\t\n                if (serviceModeUser != null && !broker.getUser().equals(serviceModeUser)) {\n                    inServiceMode = true;\n                }\n            }\n\t\t\t//Inform the other threads that someone is gone\n\t\t\tthis.notifyAll();\n\t\t}\n\t}","id":24716,"modified_method":"/**\n\t * Releases a broker for the database instance. If it is no more used, make if invactive.\n\t * If there are pending system maintenance tasks,\n\t * the method will block until these tasks have finished. \n\t * \n\t *@param  broker  The broker to be released\n\t */\n\t//TODO : rename as releaseBroker ? releaseInstance (when refactored) ?\n\tpublic void release(DBBroker broker) {\n\t\t//TODO : Is this test accurate ?\n        // might be null as release() is often called within a finally block\n\t\tif (broker == null)\n\t\t\treturn;\n\t\t\n\t\tsynchronized (this) {\n\t\t\t//TOUNDERSTAND (pb) : why maintain reference counters rather than pushing the brokers to the stack ?\n\t\t\t//TODO : first check that the broker is active ! If not, return immediately.\n\t\t\tbroker.decReferenceCount();\n\t\t\tif(broker.getReferenceCount() > 0) {\n\t\t\t\t//it is still in use and thus can't be marked as inactive\n\t\t\t\treturn;  \n\t\t\t}\n\t\t\t\n\t        //Broker is no more used : inactivate it\n\t\t\n            for (DBBroker inactiveBroker : inactiveBrokers) {\n                if (broker == inactiveBroker) {\n                    LOG.error(\"Broker is already in the inactive list!!!\");\n                    return;\n                }\n            }\n\t\t\t\n\t        if (activeBrokers.remove(Thread.currentThread())==null) {\n\t             LOG.error(\"release() has been called from the wrong thread for broker \"+broker.getId());\n\t             // Cleanup the state of activeBrokers\n\t             for (Thread t : activeBrokers.keySet()) {\n\t                if (activeBrokers.get(t)==broker) {\n\t                     activeBrokers.remove(t);\n\t                     break;\n\t                }\n\t             }\n\t         }\n\t\t\tinactiveBrokers.push(broker);\n\t\t\t//If the database is now idle, do some useful stuff\n\t\t\tif(activeBrokers.isEmpty()) {\n\t\t\t\t//TODO : use a \"clean\" dedicated method (we have some below) ?\n\t\t\t\tif (syncRequired) {\n\t\t\t\t\t//Note that the broker is not yet really inactive ;-)\n\t\t\t\t\tsync(broker, syncEvent);\n\t\t\t\t\tthis.syncRequired = false;\n                    this.checkpoint = false;\n\t\t\t\t}\t\t\t\t\n                if (serviceModeUser != null && !broker.getUser().equals(serviceModeUser)) {\n                    inServiceMode = true;\n                }\n            }\n\t\t\t//Inform the other threads that someone is gone\n\t\t\tthis.notifyAll();\n\t\t}\n\t}","commit_id":"fae37e9c982da36836a142282029b0c2d89fe156","url":"https://github.com/eXist-db/exist"},{"original_method":"public Map getActiveBrokers() {\n        return new HashMap(activeBrokers);\n    }","id":24717,"modified_method":"public Map<Thread, DBBroker> getActiveBrokers() {\n        return new HashMap<Thread, DBBroker>(activeBrokers);\n    }","commit_id":"fae37e9c982da36836a142282029b0c2d89fe156","url":"https://github.com/eXist-db/exist"},{"original_method":"/**Initializes the database instance.\n\t * @throws EXistException\n\t */\n\tprotected void initialize() throws EXistException, DatabaseConfigurationException {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"initializing database instance '\" + instanceName + \"'...\");\n        \n        //Flag to indicate that we are initializing\n        status = INITIALIZING;\n\n        signalSystemStatus(SIGNAL_STARTUP);\n\n\t\t//REFACTOR : construct then configure\n        cacheManager = new DefaultCacheManager(this);\n\n        //REFACTOR : construct then configure\n        xQueryPool = new XQueryPool(conf);\n        //REFACTOR : construct then... configure\n        processMonitor = new ProcessMonitor();\n        xqueryStats = new PerformanceStats(this);\n\n        //REFACTOR : construct then... configure\n        xmlReaderPool = new XMLReaderPool(conf, new XMLReaderObjectFactory(this), 5, 0);\n        //REFACTOR : construct then... configure\n        int bufferSize = conf.getInteger(PROPERTY_COLLECTION_CACHE_SIZE);\n        if(bufferSize == -1)\n        \tbufferSize = DEFAULT_COLLECTION_BUFFER_SIZE;\n        collectionCache = new CollectionCache(this, bufferSize, 0.0001);\n        collectionCacheMgr = new CollectionCacheManager(this, collectionCache);\n\n        // compute how much memory should be reserved for caches to grow\n        Runtime rt = Runtime.getRuntime();\n        long maxMem = rt.maxMemory();\n        long minFree = maxMem / 5;\n        reservedMem = cacheManager.getTotalMem() + collectionCacheMgr.getMaxTotal() + minFree;\n        LOG.debug(\"Reserved memory: \" + reservedMem + \"; max: \" + maxMem + \"; min: \" + minFree);\n        notificationService = new NotificationService();\n\n        //REFACTOR : construct then... configure\n        //TODO : journal directory *may* be different from BrokerPool.PROPERTY_DATA_DIR\n        transactionManager = new TransactionManager(this, new File((String) conf.getProperty(BrokerPool.PROPERTY_DATA_DIR)), isTransactional());\t\t\n        try {\n            transactionManager.initialize();\n        } catch (ReadOnlyException e) {\n            LOG.warn(e.getMessage() + \". Switching to read-only mode!!!\");\n            isReadOnly = true;\n        }\n\n        symbols = new SymbolTable(this, conf);\n        if (!symbols.getFile().canWrite()) {\n            LOG.warn(\"Cannot write to \" + symbols.getFile().getName() + \". Switching to read-only mode.\");\n            isReadOnly = true;\n        }\n        \n        indexManager = new IndexManager(this, conf);\n\n        //TODO : replace the following code by get()/release() statements ?\n        // WM: I would rather tend to keep this broker reserved as a system broker.\n        // create a first broker to initialize the security manager\n\t\tcreateBroker();\n\t\t//TODO : this broker is *not* marked as active and *might* be reused by another process ! Is it intended ?\n        // at this stage, the database is still single-threaded, so reusing the broker later is not a problem.\n\t\tDBBroker broker = (DBBroker) inactiveBrokers.peek();\n        \n        if (broker.isReadOnly()) {\n            transactionManager.setEnabled(false);\n            isReadOnly = true;\n        }\n        \n\t\t//Run the recovery process\n        //TODO : assume \n        boolean recovered = false;\n\t\tif (isTransactional()) {\n\t\t\trecovered = transactionManager.runRecovery(broker);\n            //TODO : extract the following from this block ? What if we ware not transactional ? -pb \n            if (!recovered) {\n            \tif (broker.getCollection(XmldbURI.ROOT_COLLECTION_URI) == null) {\n            \t\tTxn txn = transactionManager.beginTransaction();\n            \t\ttry {\n            \t\t\t//TODO : use a root collection final member\n            \t\t\tbroker.getOrCreateCollection(txn, XmldbURI.ROOT_COLLECTION_URI);\n            \t\t\ttransactionManager.commit(txn);\n            \t\t} catch (IOException e) {\n            \t\t\ttransactionManager.abort(txn);\n\t        \t\t} catch (PermissionDeniedException e) {\n\t        \t\t\ttransactionManager.abort(txn);\n\t        \t\t}\n            \t}\n            }\n        }\n\n        /* initialise required collections if they dont exist yet */\n        initialiseSystemCollections(broker);\n\n        //TODO : from there, rethink the sequence of calls.\n        // WM: attention: a small change in the sequence of calls can break\n        // either normal startup or recovery.\n        \n        //create the security manager\n\t\t//TODO : why only the first broker has a security manager ? Global or attached to each broker ?\n        // WM: there's only one security manager per BrokerPool, but it needs a DBBroker instance to read\n        // the system collection.\n\t\tSecurityManager localSecurityManager = newSecurityManager();\n\t\tsecurityManager = null;\n\t\tlocalSecurityManager.attach(this, broker);\n\t\tsecurityManager = localSecurityManager;\n\t\tstatus = OPERATING;\n\t\t//have to do this after initializing = false\n\t\t// so that the policies collection is saved\n\t\tif(securityManager.isXACMLEnabled())\n\t\t\tsecurityManager.getPDP().initializePolicyCollection();\n\t\t//Get a manager to handle further collectios configuration\n        try {\n            collectionConfigurationManager = new CollectionConfigurationManager(broker);\n        } catch (Exception e) {\n            LOG.error(\"Found an error while initializing database: \" + e.getMessage(), e);\n        }\n        //If necessary, launch a task to repair the DB\n        //TODO : merge this with the recovery process ?\n        if (recovered) {\n            try {\n                broker.setUser(SecurityManager.SYSTEM_USER);\n                broker.repair();\n            } catch (PermissionDeniedException e) {\n                LOG.warn(\"Error during recovery: \" + e.getMessage(), e);\n            }\n            if (((Boolean)conf.getProperty(PROPERTY_RECOVERY_CHECK)).booleanValue()) {\n                ConsistencyCheckTask task = new ConsistencyCheckTask();\n                Properties props = new Properties();\n                props.setProperty(\"backup\", \"no\");\n                props.setProperty(\"output\", \"sanity\");\n                task.configure(conf, props);\n                task.execute(broker);\n            }\n        }\n\n        //OK : the DB is repaired; let's make a few RW operations\n\t\t\n        // remove temporary docs\n\t\tbroker.cleanUpTempResources(true);\n\n        sync(broker, Sync.MAJOR_SYNC);\n        \n\t\t//Create a default configuration file for the root collection\n\t\t//TODO : why can't we call this from within CollectionConfigurationManager ?\n\t\t//TODO : understand why we get a test suite failure\n        //collectionConfigurationManager.checkRootCollectionConfigCollection(broker);\n        //collectionConfigurationManager.checkRootCollectionConfig(broker);\t\t\n\n\n/* TODO: start adam */\n\t\t\n\t\t//Schedule the system tasks\t            \n\t    /*for (int i = 0; i < systemTasks.size(); i++) {\n\t    \t//TODO : remove first argument when SystemTask has a getPeriodicity() method\n\t        initSystemTask((SingleInstanceConfiguration.SystemTaskConfig) systemTasksPeriods.get(i), (SystemTask)systemTasks.get(i));\n\t    }\t\t\n\t\tsystemTasksPeriods = null;*/\n\t\t\n/* TODO: end adam */\t\t\n\n\t\t//Create the minimal number of brokers required by the configuration \n\t\tfor (int i = 1; i < minBrokers; i++)\n\t\t\tcreateBroker();        \n\n        // register some MBeans to provide access to this instance\n        AgentFactory.getInstance().initDBInstance(this);\n        \n        if (LOG.isDebugEnabled())\n            LOG.debug(\"database instance '\" + instanceName + \"' initialized\");\n        \n\t\t\n        //setup any configured jobs\n        //scheduler.setupConfiguredJobs();\n        \n        //execute any startup jobs\n        //scheduler.executeStartupJobs();\n        \n        scheduler.run();\n\t}","id":24718,"modified_method":"/**Initializes the database instance.\n\t * @throws EXistException\n\t */\n\tprotected void initialize() throws EXistException, DatabaseConfigurationException {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"initializing database instance '\" + instanceName + \"'...\");\n        \n        //Flag to indicate that we are initializing\n        status = INITIALIZING;\n\n        signalSystemStatus(SIGNAL_STARTUP);\n\n\t\t//REFACTOR : construct then configure\n        cacheManager = new DefaultCacheManager(this);\n\n        //REFACTOR : construct then configure\n        xQueryPool = new XQueryPool(conf);\n        //REFACTOR : construct then... configure\n        processMonitor = new ProcessMonitor();\n        xqueryStats = new PerformanceStats(this);\n\n        //REFACTOR : construct then... configure\n        xmlReaderPool = new XMLReaderPool(conf, new XMLReaderObjectFactory(this), 5, 0);\n        //REFACTOR : construct then... configure\n        int bufferSize = conf.getInteger(PROPERTY_COLLECTION_CACHE_SIZE);\n        if(bufferSize == -1)\n        \tbufferSize = DEFAULT_COLLECTION_BUFFER_SIZE;\n        collectionCache = new CollectionCache(this, bufferSize, 0.0001);\n        collectionCacheMgr = new CollectionCacheManager(this, collectionCache);\n\n        // compute how much memory should be reserved for caches to grow\n        Runtime rt = Runtime.getRuntime();\n        long maxMem = rt.maxMemory();\n        long minFree = maxMem / 5;\n        reservedMem = cacheManager.getTotalMem() + collectionCacheMgr.getMaxTotal() + minFree;\n        LOG.debug(\"Reserved memory: \" + reservedMem + \"; max: \" + maxMem + \"; min: \" + minFree);\n        notificationService = new NotificationService();\n\n        //REFACTOR : construct then... configure\n        //TODO : journal directory *may* be different from BrokerPool.PROPERTY_DATA_DIR\n        transactionManager = new TransactionManager(this, new File((String) conf.getProperty(BrokerPool.PROPERTY_DATA_DIR)), isTransactional());\t\t\n        try {\n            transactionManager.initialize();\n        } catch (ReadOnlyException e) {\n            LOG.warn(e.getMessage() + \". Switching to read-only mode!!!\");\n            isReadOnly = true;\n        }\n\n        symbols = new SymbolTable(this, conf);\n        if (!symbols.getFile().canWrite()) {\n            LOG.warn(\"Cannot write to \" + symbols.getFile().getName() + \". Switching to read-only mode.\");\n            isReadOnly = true;\n        }\n        \n        indexManager = new IndexManager(this, conf);\n\n        //TODO : replace the following code by get()/release() statements ?\n        // WM: I would rather tend to keep this broker reserved as a system broker.\n        // create a first broker to initialize the security manager\n\t\tcreateBroker();\n\t\t//TODO : this broker is *not* marked as active and *might* be reused by another process ! Is it intended ?\n        // at this stage, the database is still single-threaded, so reusing the broker later is not a problem.\n\t\tDBBroker broker = inactiveBrokers.peek();\n        \n        if (broker.isReadOnly()) {\n            transactionManager.setEnabled(false);\n            isReadOnly = true;\n        }\n        \n\t\t//Run the recovery process\n        //TODO : assume \n        boolean recovered = false;\n\t\tif (isTransactional()) {\n\t\t\trecovered = transactionManager.runRecovery(broker);\n            //TODO : extract the following from this block ? What if we ware not transactional ? -pb \n            if (!recovered) {\n            \tif (broker.getCollection(XmldbURI.ROOT_COLLECTION_URI) == null) {\n            \t\tTxn txn = transactionManager.beginTransaction();\n            \t\ttry {\n            \t\t\t//TODO : use a root collection final member\n            \t\t\tbroker.getOrCreateCollection(txn, XmldbURI.ROOT_COLLECTION_URI);\n            \t\t\ttransactionManager.commit(txn);\n            \t\t} catch (IOException e) {\n            \t\t\ttransactionManager.abort(txn);\n\t        \t\t} catch (PermissionDeniedException e) {\n\t        \t\t\ttransactionManager.abort(txn);\n\t        \t\t}\n            \t}\n            }\n        }\n\n        /* initialise required collections if they dont exist yet */\n        initialiseSystemCollections(broker);\n\n        //TODO : from there, rethink the sequence of calls.\n        // WM: attention: a small change in the sequence of calls can break\n        // either normal startup or recovery.\n        \n        //create the security manager\n\t\t//TODO : why only the first broker has a security manager ? Global or attached to each broker ?\n        // WM: there's only one security manager per BrokerPool, but it needs a DBBroker instance to read\n        // the system collection.\n\t\tSecurityManager localSecurityManager = newSecurityManager();\n\t\tsecurityManager = null;\n\t\tlocalSecurityManager.attach(this, broker);\n\t\tsecurityManager = localSecurityManager;\n\t\tstatus = OPERATING;\n\t\t//have to do this after initializing = false\n\t\t// so that the policies collection is saved\n\t\tif(securityManager.isXACMLEnabled())\n\t\t\tsecurityManager.getPDP().initializePolicyCollection();\n\t\t//Get a manager to handle further collectios configuration\n        try {\n            collectionConfigurationManager = new CollectionConfigurationManager(broker);\n        } catch (Exception e) {\n            LOG.error(\"Found an error while initializing database: \" + e.getMessage(), e);\n        }\n        //If necessary, launch a task to repair the DB\n        //TODO : merge this with the recovery process ?\n        if (recovered) {\n            try {\n                broker.setUser(SecurityManager.SYSTEM_USER);\n                broker.repair();\n            } catch (PermissionDeniedException e) {\n                LOG.warn(\"Error during recovery: \" + e.getMessage(), e);\n            }\n            if (((Boolean)conf.getProperty(PROPERTY_RECOVERY_CHECK)).booleanValue()) {\n                ConsistencyCheckTask task = new ConsistencyCheckTask();\n                Properties props = new Properties();\n                props.setProperty(\"backup\", \"no\");\n                props.setProperty(\"output\", \"sanity\");\n                task.configure(conf, props);\n                task.execute(broker);\n            }\n        }\n\n        //OK : the DB is repaired; let's make a few RW operations\n\t\t\n        // remove temporary docs\n\t\tbroker.cleanUpTempResources(true);\n\n        sync(broker, Sync.MAJOR_SYNC);\n        \n\t\t//Create a default configuration file for the root collection\n\t\t//TODO : why can't we call this from within CollectionConfigurationManager ?\n\t\t//TODO : understand why we get a test suite failure\n        //collectionConfigurationManager.checkRootCollectionConfigCollection(broker);\n        //collectionConfigurationManager.checkRootCollectionConfig(broker);\t\t\n\n\n/* TODO: start adam */\n\t\t\n\t\t//Schedule the system tasks\t            \n\t    /*for (int i = 0; i < systemTasks.size(); i++) {\n\t    \t//TODO : remove first argument when SystemTask has a getPeriodicity() method\n\t        initSystemTask((SingleInstanceConfiguration.SystemTaskConfig) systemTasksPeriods.get(i), (SystemTask)systemTasks.get(i));\n\t    }\t\t\n\t\tsystemTasksPeriods = null;*/\n\t\t\n/* TODO: end adam */\t\t\n\n\t\t//Create the minimal number of brokers required by the configuration \n\t\tfor (int i = 1; i < minBrokers; i++)\n\t\t\tcreateBroker();        \n\n        // register some MBeans to provide access to this instance\n        AgentFactory.getInstance().initDBInstance(this);\n        \n        if (LOG.isDebugEnabled())\n            LOG.debug(\"database instance '\" + instanceName + \"' initialized\");\n        \n\t\t\n        //setup any configured jobs\n        //scheduler.setupConfiguredJobs();\n        \n        //execute any startup jobs\n        //scheduler.executeStartupJobs();\n        \n        scheduler.run();\n\t}","commit_id":"fae37e9c982da36836a142282029b0c2d89fe156","url":"https://github.com/eXist-db/exist"},{"original_method":"public DBBroker enterServiceMode(User user) throws PermissionDeniedException {\n        if (!user.hasDbaRole())\n            throw new PermissionDeniedException(\"Only users of group dba can switch the db to service mode\");\n        serviceModeUser = user;\n        synchronized (this) {\n            if (activeBrokers.size() != 0) {\n                while(!inServiceMode) {\n                    try {\n                        wait();\n                    } catch (InterruptedException e) {\n                    }\n                }\n            }\n        }\n        inServiceMode = true;\n        DBBroker broker = (DBBroker) inactiveBrokers.peek();\n        checkpoint = true;\n        sync(broker, Sync.MAJOR_SYNC);\n        checkpoint = false;\n        // Return a broker that can be used to perform system tasks\n        return broker;\n    }","id":24719,"modified_method":"public DBBroker enterServiceMode(User user) throws PermissionDeniedException {\n        if (!user.hasDbaRole())\n            throw new PermissionDeniedException(\"Only users of group dba can switch the db to service mode\");\n        serviceModeUser = user;\n        synchronized (this) {\n            if (!activeBrokers.isEmpty()) {\n                while(!inServiceMode) {\n                    try {\n                        wait();\n                    } catch (InterruptedException e) {\n                    }\n                }\n            }\n        }\n        inServiceMode = true;\n        DBBroker broker = inactiveBrokers.peek();\n        checkpoint = true;\n        sync(broker, Sync.MAJOR_SYNC);\n        checkpoint = false;\n        // Return a broker that can be used to perform system tasks\n        return broker;\n    }","commit_id":"fae37e9c982da36836a142282029b0c2d89fe156","url":"https://github.com/eXist-db/exist"},{"original_method":"public void startElement(String namespace, String name, String qname,\n\t\t\t     Attributes attributes) throws SAXException {\n\t// calculate number of real attributes:\n\t// don't store namespace declarations\n\tint attrLength = attributes.getLength();\n\tString attrQName;\n\tString attrNS;\n\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t    attrNS = attributes.getURI(i);\n\t    attrQName = attributes.getQName(i);\n\t    if (attrQName.startsWith(\"xmlns\") || attrNS.equals(Namespaces.EXIST_NS))\n            --attrLength;\n\t}\n\n\tElementImpl last;\n\tElementImpl node;\n\tint p = qname.indexOf(':');\n\tString prefix = (p != Constants.STRING_NOT_FOUND) ? qname.substring(0, p) : \"\";\n\tQName qn = broker.getBrokerPool().getSymbols().getQName(Node.ELEMENT_NODE, namespace, name, prefix);\n\tif (!stack.empty()) {\n\t    last = (ElementImpl) stack.peek();\n\t    if (charBuf != null) {\n\t\tif(charBuf.isWhitespaceOnly()) {\n\t\t    if (suppressWSmixed) {\n\t\t\tif(charBuf.length() > 0 && last.getChildCount() > 0) {\n\t\t\t    text.setData(charBuf);\n\t\t\t    text.setOwnerDocument(document);\n\t\t\t    last.appendChildInternal(prevNode, text);\n\t\t\t    if (!validate)\n\t\t\t\tstoreText();\n                            setPrevious(text);\n\t\t\t}\n\t\t    }\n\n\t\t} else if(charBuf.length() > 0) {\n\t\t    // mixed element content: don't normalize the text node, just check\n\t\t    // if there is any text at all\n\t\t    text.setData(charBuf);\n\t\t    text.setOwnerDocument(document);\n\t\t    last.appendChildInternal(prevNode, text);\n\t\t    if (!validate)\n\t\t\tstoreText();\n                    setPrevious(text);\n\t\t}\n\t\tcharBuf.reset();\n\t    }\n\t    if (!usedElements.isEmpty()) {\n\t\tnode = (ElementImpl) usedElements.pop();\n\t\tnode.setNodeName(qn);\n\t    } else\n\t\tnode = new ElementImpl(qn);\n\t    // copy xml:space setting\n\t    node.setPreserveSpace(last.preserveSpace());\n\t    // append the node to its parent \n\t    // (computes the node id and updates the parent's child count)\n\t    last.appendChildInternal(prevNode, node);\n            setPrevious(null);\n\t    node.setOwnerDocument(document);\n\t    node.setAttributes((short) attrLength);\n\t    if (nsMappings != null && nsMappings.size() > 0) {\n\t\tnode.setNamespaceMappings(nsMappings);\n\t\tnsMappings.clear();\n\t    }\n\n\t    stack.push(node);\n\t    currentPath.addComponent(qn);\n\n            node.setPosition(elementCnt++);\n\t    if (!validate) {\n                if (childCnt != null) {\n                    node.setChildCount(childCnt[node.getPosition()]);\n\t\t}\n\t\tstoreElement(node);\n\t    }\n\t} else {\n\t    if (validate) {\n\t\tnode = new ElementImpl(qn);\n\t    }\n\t    else {\n\t\tnode = new ElementImpl(qn);\n\t    }\n\t    rootNode = node;\n\t    setPrevious(null);\n\t    node.setOwnerDocument(document);\n\t    node.setNodeId(broker.getBrokerPool().getNodeFactory().createInstance(nodeFactoryInstanceCnt++));\n\n\t    node.setAttributes((short) attrLength);\n\t    if (nsMappings != null && nsMappings.size() > 0) {\n\t\tnode.setNamespaceMappings(nsMappings);\n\t\tnsMappings.clear();\n\t    }\n\n\t    stack.push(node);\n\t    currentPath.addComponent(qn);\n\n            node.setPosition(elementCnt++);\n\t    if (!validate) {\n                if (childCnt != null) {\n                    node.setChildCount(childCnt[node.getPosition()]);\n\t\t}\n\t\tstoreElement(node);\n            }\n\t    document.appendChild(node);\n\t}\n\tlevel++;\n\n\tString attrPrefix;\n\tString attrLocalName;\n\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t    attrNS = attributes.getURI(i);\n\t    attrLocalName = attributes.getLocalName(i);\n\t    attrQName = attributes.getQName(i);\n\t    // skip xmlns-attributes and attributes in eXist's namespace\n\t    if (attrQName.startsWith(\"xmlns\") || attrNS.equals(Namespaces.EXIST_NS))\n\t\t--attrLength;\n\t    else {\n\t\tp = attrQName.indexOf(':');\n\t\tattrPrefix = (p != Constants.STRING_NOT_FOUND) ? attrQName.substring(0, p) : null;\n        final AttrImpl attr = (AttrImpl) NodePool.getInstance().borrowNode(Node.ATTRIBUTE_NODE);\n\t\tattr.setNodeName(broker.getBrokerPool().getSymbols().getQName(Node.ATTRIBUTE_NODE, attrNS, attrLocalName, attrPrefix));\n\t\tattr.setValue(attributes.getValue(i));\n\t\tattr.setOwnerDocument(document);\n\t\tif (attributes.getType(i).equals(ATTR_ID_TYPE)) {\n\t\t    attr.setType(AttrImpl.ID);\n\t\t} else if (attributes.getType(i).equals(ATTR_IDREF_TYPE)) {\n\t\t\t    attr.setType(AttrImpl.IDREF);\n\t\t} else if (attributes.getType(i).equals(ATTR_IDREFS_TYPE)) {\n\t\t\t    attr.setType(AttrImpl.IDREFS);\n\t\t} else if (attr.getQName().equalsSimple(Namespaces.XML_ID_QNAME)) {\n\t\t    // an xml:id attribute. Normalize the attribute and set its type to ID\n\t\t    attr.setValue(StringValue.trimWhitespace(StringValue.collapseWhitespace(attr.getValue())));\n\t\t    if (!XMLChar.isValidNCName(attr.getValue()))\n\t\t\tthrow new SAXException(\"Value of xml:id attribute is not a valid NCName: \" + attr.getValue());\n\t\t    attr.setType(AttrImpl.ID);\n\t\t} else if (attr.getQName().equalsSimple(Namespaces.XML_SPACE_QNAME)) {\n\t\t    node.setPreserveSpace(\"preserve\".equals(attr.getValue()));\n\t\t}\n\t\tnode.appendChildInternal(prevNode, attr);\n\t\tsetPrevious(attr);\n\t\tif (!validate) {\n                    broker.storeNode(transaction, attr, currentPath, indexSpec);\n                    if (indexListener != null)\n                        indexListener.attribute(transaction, attr, currentPath);\n                }\n            }\n\t}\n\tif (attrLength > 0)\n\t    node.setAttributes((short) attrLength);\n\t// notify observers about progress every 100 lines\n\tif (locator != null) {\n\t    currentLine = locator.getLineNumber();\n\t    if (!validate) {\n\t\tprogress.setValue(currentLine);\n\t\tif (progress.changed()) {\n\t\t    setChanged();\n\t\t    notifyObservers(progress);\n\t\t}\n\t    }\n\t}\n        ++docSize;\n    }","id":24720,"modified_method":"public void startElement(String namespace, String name, String qname,\n\t\t\tAttributes attributes) throws SAXException {\n\t\t// calculate number of real attributes:\n\t\t// don't store namespace declarations\n\t\tint attrLength = attributes.getLength();\n\t\tString attrQName;\n\t\tString attrNS;\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tattrNS = attributes.getURI(i);\n\t\t\tattrQName = attributes.getQName(i);\n\t\t\tif (attrQName.startsWith(\"xmlns\")\n\t\t\t\t\t|| attrNS.equals(Namespaces.EXIST_NS))\n\t\t\t\t--attrLength;\n\t\t}\n\n\t\tElementImpl last;\n\t\tElementImpl node;\n\t\tint p = qname.indexOf(':');\n\t\tString prefix = (p != Constants.STRING_NOT_FOUND) ? qname.substring(0,\n\t\t\t\tp) : \"\";\n\t\tQName qn = broker.getBrokerPool().getSymbols().getQName(\n\t\t\t\tNode.ELEMENT_NODE, namespace, name, prefix);\n\t\tif (!stack.empty()) {\n\t\t\tlast = stack.peek();\n\t\t\tif (charBuf != null) {\n\t\t\t\tif (charBuf.isWhitespaceOnly()) {\n\t\t\t\t\tif (suppressWSmixed) {\n\t\t\t\t\t\tif (charBuf.length() > 0 && last.getChildCount() > 0) {\n\t\t\t\t\t\t\ttext.setData(charBuf);\n\t\t\t\t\t\t\ttext.setOwnerDocument(document);\n\t\t\t\t\t\t\tlast.appendChildInternal(prevNode, text);\n\t\t\t\t\t\t\tif (!validate)\n\t\t\t\t\t\t\t\tstoreText();\n\t\t\t\t\t\t\tsetPrevious(text);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else if (charBuf.length() > 0) {\n\t\t\t\t\t// mixed element content: don't normalize the text node,\n\t\t\t\t\t// just check\n\t\t\t\t\t// if there is any text at all\n\t\t\t\t\ttext.setData(charBuf);\n\t\t\t\t\ttext.setOwnerDocument(document);\n\t\t\t\t\tlast.appendChildInternal(prevNode, text);\n\t\t\t\t\tif (!validate)\n\t\t\t\t\t\tstoreText();\n\t\t\t\t\tsetPrevious(text);\n\t\t\t\t}\n\t\t\t\tcharBuf.reset();\n\t\t\t}\n\t\t\tif (!usedElements.isEmpty()) {\n\t\t\t\tnode = usedElements.pop();\n\t\t\t\tnode.setNodeName(qn);\n\t\t\t} else\n\t\t\t\tnode = new ElementImpl(qn);\n\t\t\t// copy xml:space setting\n\t\t\tnode.setPreserveSpace(last.preserveSpace());\n\t\t\t// append the node to its parent\n\t\t\t// (computes the node id and updates the parent's child count)\n\t\t\tlast.appendChildInternal(prevNode, node);\n\t\t\tsetPrevious(null);\n\t\t\tnode.setOwnerDocument(document);\n\t\t\tnode.setAttributes((short) attrLength);\n\t\t\tif (nsMappings != null && nsMappings.size() > 0) {\n\t\t\t\tnode.setNamespaceMappings(nsMappings);\n\t\t\t\tnsMappings.clear();\n\t\t\t}\n\n\t\t\tstack.push(node);\n\t\t\tcurrentPath.addComponent(qn);\n\n\t\t\tnode.setPosition(elementCnt++);\n\t\t\tif (!validate) {\n\t\t\t\tif (childCnt != null) {\n\t\t\t\t\tnode.setChildCount(childCnt[node.getPosition()]);\n\t\t\t\t}\n\t\t\t\tstoreElement(node);\n\t\t\t}\n\t\t} else {\n\t\t\tif (validate) {\n\t\t\t\tnode = new ElementImpl(qn);\n\t\t\t} else {\n\t\t\t\tnode = new ElementImpl(qn);\n\t\t\t}\n\t\t\trootNode = node;\n\t\t\tsetPrevious(null);\n\t\t\tnode.setOwnerDocument(document);\n\t\t\tnode.setNodeId(broker.getBrokerPool().getNodeFactory()\n\t\t\t\t\t.createInstance(nodeFactoryInstanceCnt++));\n\n\t\t\tnode.setAttributes((short) attrLength);\n\t\t\tif (nsMappings != null && nsMappings.size() > 0) {\n\t\t\t\tnode.setNamespaceMappings(nsMappings);\n\t\t\t\tnsMappings.clear();\n\t\t\t}\n\n\t\t\tstack.push(node);\n\t\t\tcurrentPath.addComponent(qn);\n\n\t\t\tnode.setPosition(elementCnt++);\n\t\t\tif (!validate) {\n\t\t\t\tif (childCnt != null) {\n\t\t\t\t\tnode.setChildCount(childCnt[node.getPosition()]);\n\t\t\t\t}\n\t\t\t\tstoreElement(node);\n\t\t\t}\n\t\t\tdocument.appendChild(node);\n\t\t}\n\t\tlevel++;\n\n\t\tString attrPrefix;\n\t\tString attrLocalName;\n\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\tattrNS = attributes.getURI(i);\n\t\t\tattrLocalName = attributes.getLocalName(i);\n\t\t\tattrQName = attributes.getQName(i);\n\t\t\t// skip xmlns-attributes and attributes in eXist's namespace\n\t\t\tif (attrQName.startsWith(\"xmlns\")\n\t\t\t\t\t|| attrNS.equals(Namespaces.EXIST_NS))\n\t\t\t\t--attrLength;\n\t\t\telse {\n\t\t\t\tp = attrQName.indexOf(':');\n\t\t\t\tattrPrefix = (p != Constants.STRING_NOT_FOUND) ? attrQName\n\t\t\t\t\t\t.substring(0, p) : null;\n\t\t\t\tfinal AttrImpl attr = (AttrImpl) NodePool.getInstance()\n\t\t\t\t\t\t.borrowNode(Node.ATTRIBUTE_NODE);\n\t\t\t\tattr\n\t\t\t\t\t\t.setNodeName(broker.getBrokerPool().getSymbols()\n\t\t\t\t\t\t\t\t.getQName(Node.ATTRIBUTE_NODE, attrNS,\n\t\t\t\t\t\t\t\t\t\tattrLocalName, attrPrefix));\n\t\t\t\tattr.setValue(attributes.getValue(i));\n\t\t\t\tattr.setOwnerDocument(document);\n\t\t\t\tif (attributes.getType(i).equals(ATTR_ID_TYPE)) {\n\t\t\t\t\tattr.setType(AttrImpl.ID);\n\t\t\t\t} else if (attributes.getType(i).equals(ATTR_IDREF_TYPE)) {\n\t\t\t\t\tattr.setType(AttrImpl.IDREF);\n\t\t\t\t} else if (attributes.getType(i).equals(ATTR_IDREFS_TYPE)) {\n\t\t\t\t\tattr.setType(AttrImpl.IDREFS);\n\t\t\t\t} else if (attr.getQName()\n\t\t\t\t\t\t.equalsSimple(Namespaces.XML_ID_QNAME)) {\n\t\t\t\t\t// an xml:id attribute. Normalize the attribute and set its\n\t\t\t\t\t// type to ID\n\t\t\t\t\tattr.setValue(StringValue.trimWhitespace(StringValue\n\t\t\t\t\t\t\t.collapseWhitespace(attr.getValue())));\n\t\t\t\t\tif (!XMLChar.isValidNCName(attr.getValue()))\n\t\t\t\t\t\tthrow new SAXException(\n\t\t\t\t\t\t\t\t\"Value of xml:id attribute is not a valid NCName: \"\n\t\t\t\t\t\t\t\t\t\t+ attr.getValue());\n\t\t\t\t\tattr.setType(AttrImpl.ID);\n\t\t\t\t} else if (attr.getQName().equalsSimple(\n\t\t\t\t\t\tNamespaces.XML_SPACE_QNAME)) {\n\t\t\t\t\tnode.setPreserveSpace(\"preserve\".equals(attr.getValue()));\n\t\t\t\t}\n\t\t\t\tnode.appendChildInternal(prevNode, attr);\n\t\t\t\tsetPrevious(attr);\n\t\t\t\tif (!validate) {\n\t\t\t\t\tbroker.storeNode(transaction, attr, currentPath, indexSpec);\n\t\t\t\t\tif (indexListener != null)\n\t\t\t\t\t\tindexListener.attribute(transaction, attr, currentPath);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (attrLength > 0)\n\t\t\tnode.setAttributes((short) attrLength);\n\t\t// notify observers about progress every 100 lines\n\t\tif (locator != null) {\n\t\t\tcurrentLine = locator.getLineNumber();\n\t\t\tif (!validate) {\n\t\t\t\tprogress.setValue(currentLine);\n\t\t\t\tif (progress.changed()) {\n\t\t\t\t\tsetChanged();\n\t\t\t\t\tnotifyObservers(progress);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++docSize;\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void endCDATA() {\n        if (!stack.isEmpty()) {\n            ElementImpl last = (ElementImpl) stack.peek();\n            if (charBuf != null && charBuf.length() > 0) {\n                CDATASectionImpl cdata = new CDATASectionImpl(charBuf);\n                cdata.setOwnerDocument(document);\n                last.appendChildInternal(prevNode, cdata);\n                if (!validate) {\n                    broker.storeNode(transaction, cdata, currentPath, indexSpec);\n                    if (indexListener != null) {\n                        indexListener.characters(transaction, cdata, currentPath);\n                    }\n                }\n                setPrevious(cdata);\n                \n                if (!nodeContentStack.isEmpty()) {\n                    for (int i = 0; i < nodeContentStack.size(); i++) {\n                        XMLString next = (XMLString) nodeContentStack.get(i);\n                        next.append(charBuf);\n                    }\n                }\n                charBuf.reset();\n            }\n        }\n        inCDATASection = false;\n    }","id":24721,"modified_method":"public void endCDATA() {\n\t\tif (!stack.isEmpty()) {\n\t\t\tElementImpl last = stack.peek();\n\t\t\tif (charBuf != null && charBuf.length() > 0) {\n\t\t\t\tCDATASectionImpl cdata = new CDATASectionImpl(charBuf);\n\t\t\t\tcdata.setOwnerDocument(document);\n\t\t\t\tlast.appendChildInternal(prevNode, cdata);\n\t\t\t\tif (!validate) {\n\t\t\t\t\tbroker\n\t\t\t\t\t\t\t.storeNode(transaction, cdata, currentPath,\n\t\t\t\t\t\t\t\t\tindexSpec);\n\t\t\t\t\tif (indexListener != null) {\n\t\t\t\t\t\tindexListener.characters(transaction, cdata,\n\t\t\t\t\t\t\t\tcurrentPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetPrevious(cdata);\n\n\t\t\t\tif (!nodeContentStack.isEmpty()) {\n\t\t\t\t\tfor (XMLString next : nodeContentStack) {\n\t\t\t\t\t\tnext.append(charBuf);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcharBuf.reset();\n\t\t\t}\n\t\t}\n\t\tinCDATASection = false;\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void comment(char[] ch, int start, int length) {\n\tif (insideDTD)\n\t    return;\n\tCommentImpl comment = new CommentImpl(ch, start, length);\n\tcomment.setOwnerDocument(document);\n\tif (stack.empty()) {\n            comment.setNodeId(broker.getBrokerPool().getNodeFactory().createInstance(nodeFactoryInstanceCnt++));\n            if (!validate) {\n\t\tbroker.storeNode(transaction, comment, currentPath, indexSpec);\n\t    }\n\t    document.appendChild(comment);\n\t} else {\n\t    ElementImpl last = (ElementImpl) stack.peek();\n            if (charBuf != null && charBuf.length() > 0) {\n                text.setData(charBuf);\n                text.setOwnerDocument(document);\n                last.appendChildInternal(prevNode, text);\n                if (!validate) {\n                    storeText();\n\t\t}\n                setPrevious(text);\n                charBuf.reset();\n            }\n\t    last.appendChildInternal(prevNode, comment);\n            setPrevious(comment);\n\t    if (!validate) {\n\t\tbroker.storeNode(transaction, comment, currentPath, indexSpec);\n\t    }\n\t}\n    }","id":24722,"modified_method":"public void comment(char[] ch, int start, int length) {\n\t\tif (insideDTD)\n\t\t\treturn;\n\t\tCommentImpl comment = new CommentImpl(ch, start, length);\n\t\tcomment.setOwnerDocument(document);\n\t\tif (stack.empty()) {\n\t\t\tcomment.setNodeId(broker.getBrokerPool().getNodeFactory()\n\t\t\t\t\t.createInstance(nodeFactoryInstanceCnt++));\n\t\t\tif (!validate) {\n\t\t\t\tbroker.storeNode(transaction, comment, currentPath, indexSpec);\n\t\t\t}\n\t\t\tdocument.appendChild(comment);\n\t\t} else {\n\t\t\tElementImpl last = stack.peek();\n\t\t\tif (charBuf != null && charBuf.length() > 0) {\n\t\t\t\ttext.setData(charBuf);\n\t\t\t\ttext.setOwnerDocument(document);\n\t\t\t\tlast.appendChildInternal(prevNode, text);\n\t\t\t\tif (!validate) {\n\t\t\t\t\tstoreText();\n\t\t\t\t}\n\t\t\t\tsetPrevious(text);\n\t\t\t\tcharBuf.reset();\n\t\t\t}\n\t\t\tlast.appendChildInternal(prevNode, comment);\n\t\t\tsetPrevious(comment);\n\t\t\tif (!validate) {\n\t\t\t\tbroker.storeNode(transaction, comment, currentPath, indexSpec);\n\t\t\t}\n\t\t}\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void processingInstruction(String target, String data) {\n\tProcessingInstructionImpl pi =\n\t    new ProcessingInstructionImpl(target, data);\n\tpi.setOwnerDocument(document);\n\tif (stack.isEmpty()) {\n\t    pi.setNodeId(broker.getBrokerPool().getNodeFactory().createInstance(nodeFactoryInstanceCnt++));\n            if (!validate) {\n\t\tbroker.storeNode(transaction, pi, currentPath, indexSpec);\n\t    }\n\t    document.appendChild(pi);\n\t} else {\n\t    ElementImpl last = (ElementImpl) stack.peek();\n\t    if (charBuf != null && charBuf.length() > 0) {\n\t\tXMLString normalized = charBuf.normalize(normalize);\n\t\tif (normalized.length() > 0) {\n\t\t    //TextImpl text =\n\t\t    //    new TextImpl( normalized );\n\t\t    text.setData(normalized);\n\t\t    text.setOwnerDocument(document);\n\t\t    last.appendChildInternal(prevNode, text);\n\t\t    if (!validate) {\n\t\t\tstoreText();\n\t\t    }\n                    setPrevious(text);\n\t\t}\n\t\tcharBuf.reset();\n\t    }\n\t    last.appendChildInternal(prevNode, pi);\n            setPrevious(pi);\n\t    if (!validate) {\n\t\tbroker.storeNode(transaction, pi, currentPath, indexSpec);\n\t    }\n\t}\n    }","id":24723,"modified_method":"public void processingInstruction(String target, String data) {\n\t\tProcessingInstructionImpl pi = new ProcessingInstructionImpl(target,\n\t\t\t\tdata);\n\t\tpi.setOwnerDocument(document);\n\t\tif (stack.isEmpty()) {\n\t\t\tpi.setNodeId(broker.getBrokerPool().getNodeFactory()\n\t\t\t\t\t.createInstance(nodeFactoryInstanceCnt++));\n\t\t\tif (!validate) {\n\t\t\t\tbroker.storeNode(transaction, pi, currentPath, indexSpec);\n\t\t\t}\n\t\t\tdocument.appendChild(pi);\n\t\t} else {\n\t\t\tElementImpl last = stack.peek();\n\t\t\tif (charBuf != null && charBuf.length() > 0) {\n\t\t\t\tXMLString normalized = charBuf.normalize(normalize);\n\t\t\t\tif (normalized.length() > 0) {\n\t\t\t\t\t// TextImpl text =\n\t\t\t\t\t// new TextImpl( normalized );\n\t\t\t\t\ttext.setData(normalized);\n\t\t\t\t\ttext.setOwnerDocument(document);\n\t\t\t\t\tlast.appendChildInternal(prevNode, text);\n\t\t\t\t\tif (!validate) {\n\t\t\t\t\t\tstoreText();\n\t\t\t\t\t}\n\t\t\t\t\tsetPrevious(text);\n\t\t\t\t}\n\t\t\t\tcharBuf.reset();\n\t\t\t}\n\t\t\tlast.appendChildInternal(prevNode, pi);\n\t\t\tsetPrevious(pi);\n\t\t\tif (!validate) {\n\t\t\t\tbroker.storeNode(transaction, pi, currentPath, indexSpec);\n\t\t\t}\n\t\t}\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"private void setPrevious(StoredNode previous) {\n        if (prevNode != null) {\n            switch (prevNode.getNodeType()) {\n                case Node.ATTRIBUTE_NODE :\n                    prevNode.release();\n                    break;\n                case Node.ELEMENT_NODE :\n                    if (prevNode != rootNode) {\n                        prevNode.clear();\n                        usedElements.push(prevNode);\n                    }\n                    break;\n                case Node.TEXT_NODE :\n                    prevNode.clear();\n                    break;\n            }\n        }\n        prevNode = previous;\n    }","id":24724,"modified_method":"private void setPrevious(StoredNode previous) {\n\t\tif (prevNode != null) {\n\t\t\tswitch (prevNode.getNodeType()) {\n\t\t\tcase Node.ATTRIBUTE_NODE:\n\t\t\t\tprevNode.release();\n\t\t\t\tbreak;\n\t\t\tcase Node.ELEMENT_NODE:\n\t\t\t\tif (prevNode != rootNode) {\n\t\t\t\t\tprevNode.clear();\n\t\t\t\t\tusedElements.push((ElementImpl) prevNode);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase Node.TEXT_NODE:\n\t\t\t\tprevNode.clear();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprevNode = previous;\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void startCDATA() {\n        if (!stack.isEmpty()) {\n            ElementImpl last = (ElementImpl) stack.peek();\n            if (charBuf != null && charBuf.length() > 0) {\n                text.setData(charBuf);\n                text.setOwnerDocument(document);\n                last.appendChildInternal(prevNode, text);\n                if (!validate)\n                    storeText();\n                setPrevious(text);\n                charBuf.reset();\n            }\n        }\n        inCDATASection = true;        \n    }","id":24725,"modified_method":"public void startCDATA() {\n\t\tif (!stack.isEmpty()) {\n\t\t\tElementImpl last = stack.peek();\n\t\t\tif (charBuf != null && charBuf.length() > 0) {\n\t\t\t\ttext.setData(charBuf);\n\t\t\t\ttext.setOwnerDocument(document);\n\t\t\t\tlast.appendChildInternal(prevNode, text);\n\t\t\t\tif (!validate)\n\t\t\t\t\tstoreText();\n\t\t\t\tsetPrevious(text);\n\t\t\t\tcharBuf.reset();\n\t\t\t}\n\t\t}\n\t\tinCDATASection = true;\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Prepare the indexer for parsing a new document. This will\n     * reset the internal state of the Indexer object.\n     *\n     * @param doc\n     */\n    public void setDocument(DocumentImpl doc, CollectionConfiguration collectionConfig) {\n        document = doc;\n        if (collectionConfig != null)\n            indexSpec = collectionConfig.getIndexConfiguration();\n        // reset internal fields\n        level = 0;\n        currentPath.reset();\n        stack = new Stack();\n        docSize = 0;\n        nsMappings.clear();\n        indexListener = null;\n        rootNode = null;\n        setPrevious(null);\n    }","id":24726,"modified_method":"/**\n\t * Prepare the indexer for parsing a new document. This will reset the\n\t * internal state of the Indexer object.\n\t * \n\t * @param doc\n\t */\n\tpublic void setDocument(DocumentImpl doc,\n\t\t\tCollectionConfiguration collectionConfig) {\n\t\tdocument = doc;\n\t\tif (collectionConfig != null)\n\t\t\tindexSpec = collectionConfig.getIndexConfiguration();\n\t\t// reset internal fields\n\t\tlevel = 0;\n\t\tcurrentPath.reset();\n\t\tstack = new Stack<ElementImpl>();\n\t\tdocSize = 0;\n\t\tnsMappings.clear();\n\t\tindexListener = null;\n\t\trootNode = null;\n\t\tsetPrevious(null);\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"public void endElement(String namespace, String name, String qname) {\n\tfinal ElementImpl last = (ElementImpl) stack.peek();\n\tif (last.getNodeName().equals(qname)) {\n\t    if (charBuf != null && charBuf.length() > 0) {\n\t\t// remove whitespace if the node has just a single text child,\n\t\t// keep whitespace for mixed content.\n\t\tfinal XMLString normalized;\n                if((charBuf.isWhitespaceOnly() && suppressWSmixed) || last.preserveSpace()) {\n                    normalized = charBuf;\n                } else {\n\t\t    normalized = last.getChildCount() == 0 ? charBuf.normalize(normalize) : \n\t\t\t(charBuf.isWhitespaceOnly() ? null : charBuf);\n\t\t}\n\t\tif (normalized != null && normalized.length() > 0) {\n\t\t    text.setData(normalized);\n\t\t    text.setOwnerDocument(document);\n\t\t    last.appendChildInternal(prevNode, text);\n\t\t    if (!validate)\n\t\t\tstoreText();\n                    setPrevious(text);\n\t\t}\n\t\tcharBuf.reset();\n\t    }\n\t    stack.pop();\n\t\t\t\n\t    XMLString elemContent = null;\n\t    if (!validate && GeneralRangeIndexSpec.hasQNameOrValueIndex(last.getIndexType())) {\n            elemContent = (XMLString) nodeContentStack.pop();\n        }\n\n        if (!validate) {\n            final String content = elemContent == null ? null : elemContent.toString();\n            broker.endElement(last, currentPath, content);\n            if (indexListener != null)\n                indexListener.endElement(transaction, last, currentPath);\n        }\n\n        currentPath.removeLastComponent();\n        if (validate) {\n            if (childCnt != null)\n                setChildCount(last);\n        } else {\n            document.setOwnerDocument(document);\n            if ((childCnt == null && last.getChildCount() > 0) ||\n                (childCnt != null && childCnt[last.getPosition()] != last.getChildCount())) {\n                broker.updateNode(transaction, last, false);\n            }\n        }\n        setPrevious(last);\n        level--;\n    }\n    }","id":24727,"modified_method":"public void endElement(String namespace, String name, String qname) {\n\t\tfinal ElementImpl last = stack.peek();\n\t\tif (last.getNodeName().equals(qname)) {\n\t\t\tif (charBuf != null && charBuf.length() > 0) {\n\t\t\t\t// remove whitespace if the node has just a single text child,\n\t\t\t\t// keep whitespace for mixed content.\n\t\t\t\tfinal XMLString normalized;\n\t\t\t\tif ((charBuf.isWhitespaceOnly() && suppressWSmixed)\n\t\t\t\t\t\t|| last.preserveSpace()) {\n\t\t\t\t\tnormalized = charBuf;\n\t\t\t\t} else {\n\t\t\t\t\tnormalized = last.getChildCount() == 0 ? charBuf\n\t\t\t\t\t\t\t.normalize(normalize)\n\t\t\t\t\t\t\t: (charBuf.isWhitespaceOnly() ? null : charBuf);\n\t\t\t\t}\n\t\t\t\tif (normalized != null && normalized.length() > 0) {\n\t\t\t\t\ttext.setData(normalized);\n\t\t\t\t\ttext.setOwnerDocument(document);\n\t\t\t\t\tlast.appendChildInternal(prevNode, text);\n\t\t\t\t\tif (!validate)\n\t\t\t\t\t\tstoreText();\n\t\t\t\t\tsetPrevious(text);\n\t\t\t\t}\n\t\t\t\tcharBuf.reset();\n\t\t\t}\n\t\t\tstack.pop();\n\n\t\t\tXMLString elemContent = null;\n\t\t\tif (!validate\n\t\t\t\t\t&& GeneralRangeIndexSpec.hasQNameOrValueIndex(last\n\t\t\t\t\t\t\t.getIndexType())) {\n\t\t\t\telemContent = nodeContentStack.pop();\n\t\t\t}\n\n\t\t\tif (!validate) {\n\t\t\t\tfinal String content = elemContent == null ? null : elemContent\n\t\t\t\t\t\t.toString();\n\t\t\t\tbroker.endElement(last, currentPath, content);\n\t\t\t\tif (indexListener != null)\n\t\t\t\t\tindexListener.endElement(transaction, last, currentPath);\n\t\t\t}\n\n\t\t\tcurrentPath.removeLastComponent();\n\t\t\tif (validate) {\n\t\t\t\tif (childCnt != null)\n\t\t\t\t\tsetChildCount(last);\n\t\t\t} else {\n\t\t\t\tdocument.setOwnerDocument(document);\n\t\t\t\tif ((childCnt == null && last.getChildCount() > 0)\n\t\t\t\t\t\t|| (childCnt != null && childCnt[last.getPosition()] != last\n\t\t\t\t\t\t\t\t.getChildCount())) {\n\t\t\t\t\tbroker.updateNode(transaction, last, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsetPrevious(last);\n\t\t\tlevel--;\n\t\t}\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"private void storeText() {\n\tif (!nodeContentStack.isEmpty()) {\n\t    for (int i = 0; i < nodeContentStack.size(); i++) {\n\t\tXMLString next = (XMLString) nodeContentStack.get(i);\n\t\tnext.append(charBuf);\n\t    }\n\t}\n\tbroker.storeNode(transaction, text, currentPath, indexSpec);\n        if (indexListener != null) {\n            indexListener.characters(transaction, text, currentPath);\n        }\n    }","id":24728,"modified_method":"private void storeText() {\n\t\tif (!nodeContentStack.isEmpty()) {\n\t\t\tfor (XMLString next : nodeContentStack) {\n\t\t\t\tnext.append(charBuf);\n\t\t\t}\n\t\t}\n\t\tbroker.storeNode(transaction, text, currentPath, indexSpec);\n\t\tif (indexListener != null) {\n\t\t\tindexListener.characters(transaction, text, currentPath);\n\t\t}\n\t}","commit_id":"98a0660ac7de3da3d0d1d9cb5697ad8222d138e3","url":"https://github.com/eXist-db/exist"},{"original_method":"public String toDetailString()\n    {\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"[\");\n        buf.append(super.hashCode());\n        buf.append(\",\");\n        buf.append(this.buffer().hashCode());\n        buf.append(\",m=\");\n        buf.append(markIndex());\n        buf.append(\",g=\");\n        buf.append(getIndex());\n        buf.append(\",p=\");\n        buf.append(putIndex());\n        buf.append(\",c=\");\n        buf.append(capacity());\n        buf.append(\"]={\");\n        if (markIndex() >= 0)\n        {\n            for (int i = markIndex(); i < getIndex(); i++)\n            {\n                char c = (char) peek(i);\n                if (Character.isISOControl(c))\n                {\n                    buf.append(c < 16 ? \"\\\\0\" : \"\\\\\");\n                    buf.append(Integer.toString(c, 16));\n                }\n                else\n                    buf.append(c);\n            }\n            buf.append(\"}{\");\n        }\n        int count = 0;\n        for (int i = getIndex(); i < putIndex(); i++)\n        {\n            char c = (char) peek(i);\n            if (Character.isISOControl(c))\n            {\n                buf.append(c < 16 ? \"\\\\0\" : \"\\\\\");\n                buf.append(Integer.toString(c, 16));\n            }\n            else\n                buf.append(c);\n            if (count++ == 50)\n            {\n                if (putIndex() - i > 20)\n                {\n                    buf.append(\" ... \");\n                    i = putIndex() - 20;\n                }\n            }\n        }\n        buf.append('}');\n        return buf.toString();\n    }","id":24729,"modified_method":"public String toDetailString()\n    {\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"[\");\n        buf.append(super.hashCode());\n        buf.append(\",\");\n        buf.append(this.buffer().hashCode());\n        buf.append(\",m=\");\n        buf.append(markIndex());\n        buf.append(\",g=\");\n        buf.append(getIndex());\n        buf.append(\",p=\");\n        buf.append(putIndex());\n        buf.append(\",c=\");\n        buf.append(capacity());\n        buf.append(\"]={\");\n        if (markIndex() >= 0)\n        {\n            for (int i = markIndex(); i < getIndex(); i++)\n            {\n                byte b =  peek(i);\n                TypeUtil.toHex(b,buf);\n            }\n            buf.append(\"}{\");\n        }\n        int count = 0;\n        for (int i = getIndex(); i < putIndex(); i++)\n        {\n            byte b =  peek(i);\n            TypeUtil.toHex(b,buf);\n            if (count++ == 50)\n            {\n                if (putIndex() - i > 20)\n                {\n                    buf.append(\" ... \");\n                    i = putIndex() - 20;\n                }\n            }\n        }\n        buf.append('}');\n        return buf.toString();\n    }","commit_id":"80a56c31a2b3a1b371d6b2c3bc871a0781ad2e2f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public TestClient(String host, int port,String protocol, int timeoutMS) throws IOException\n    {\n        _host=host;\n        _port=port;\n        _protocol=protocol;\n        _socket = new Socket(host, port);\n        _socket.setSoTimeout(timeoutMS);\n        _output = new BufferedWriter(new OutputStreamWriter(_socket.getOutputStream(), \"ISO-8859-1\"));\n        _input = new BufferedReader(new InputStreamReader(_socket.getInputStream(), \"ISO-8859-1\"));\n\n        _endp=new SocketEndPoint(_socket);\n        _generator = new WebSocketGeneratorD06(new WebSocketBuffers(32*1024),_endp,new WebSocketGeneratorD06.FixedMaskGen());\n        _parser = new WebSocketParserD06(new WebSocketBuffers(32*1024),_endp,_handler,false);\n    }","id":24730,"modified_method":"public TestClient(String host, int port,String protocol, int timeoutMS) throws IOException\n    {\n        _host=host;\n        _port=port;\n        _protocol=protocol;\n        _socket = new Socket(host, port);\n        _socket.setSoTimeout(timeoutMS);\n        _output = new BufferedWriter(new OutputStreamWriter(_socket.getOutputStream(), \"ISO-8859-1\"));\n        _input = new BufferedReader(new InputStreamReader(_socket.getInputStream(), \"ISO-8859-1\"));\n\n        _endp=new SocketEndPoint(_socket);\n        _generator = new WebSocketGeneratorD06(new WebSocketBuffers(32*1024),_endp,new WebSocketGeneratorD06.FixedMaskGen(new byte[4]));\n        _parser = new WebSocketParserD06(new WebSocketBuffers(32*1024),_endp,_handler,false);\n    }","commit_id":"80a56c31a2b3a1b371d6b2c3bc871a0781ad2e2f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void open() throws IOException\n    {\n        System.out.println(\"Jetty WebSocket PING \"+_host+\":\"+_port+\n                \" (\"+_socket.getRemoteSocketAddress()+\") \" +_size+\" bytes of data.\");\n        byte[] key = new byte[16];\n        __random.nextBytes(key);\n        \n        \n        _output.write(\"GET /chat HTTP/1.1\\r\\n\"+\n                \"Host: \"+_host+\":\"+_port+\"\\r\\n\"+\n                \"Upgrade: websocket\\r\\n\"+\n                \"Connection: Upgrade\\r\\n\"+\n                \"Sec-WebSocket-Key: \"+new String(B64Code.encode(key))+\"\\r\\n\"+\n                \"Sec-WebSocket-Origin: http://example.com\\r\\n\"+\n                \"Sec-WebSocket-Protocol: \"+_protocol+\"\\r\\n\" +\n                \"Sec-WebSocket-Version: 6\\r\\n\"+\n        \"\\r\\n\");\n        _output.flush();\n\n        String responseLine = _input.readLine();\n        if(!responseLine.startsWith(\"HTTP/1.1 101 Switching Protocols\"))\n            throw new IOException(responseLine);\n        // Read until we find Response key\n        String line;\n        boolean accepted=false;\n        String protocol=\"\";\n        while ((line = _input.readLine()) != null)\n        {\n            if (line.length() == 0)\n                break;\n            if (line.startsWith(\"Sec-WebSocket-Accept:\"))\n            {\n                String accept=line.substring(21).trim();\n                accepted=accept.equals(WebSocketConnectionD06.hashKey(new String(B64Code.encode(key))));\n            }\n            else if (line.startsWith(\"Sec-WebSocket-Protocol:\"))\n            {\n                protocol=line.substring(24).trim();\n            }\n        }\n        \n        if (!accepted)\n            throw new IOException(\"Bad Sec-WebSocket-Accept\");\n        System.out.println(\"handshake OK for protocol '\"+protocol+\"'\");\n        \n        new Thread()\n        {\n            public void run()\n            {\n                while (_endp.isOpen())\n                    _parser.parseNext();\n            }\n        }.start();\n    }","id":24731,"modified_method":"private void open() throws IOException\n    {\n        System.out.println(\"Jetty WebSocket PING \"+_host+\":\"+_port+\n                \" (\"+_socket.getRemoteSocketAddress()+\") \" +_size+\" bytes of data.\");\n        byte[] key = new byte[16];\n        __random.nextBytes(key);\n        \n        \n        _output.write(\"GET /chat HTTP/1.1\\r\\n\"+\n                \"Host: \"+_host+\":\"+_port+\"\\r\\n\"+\n                \"Upgrade: websocket\\r\\n\"+\n                \"Connection: Upgrade\\r\\n\"+\n                \"Sec-WebSocket-Key: \"+new String(B64Code.encode(key))+\"\\r\\n\"+\n                \"Sec-WebSocket-Origin: http://example.com\\r\\n\"+\n                \"Sec-WebSocket-Protocol: \"+_protocol+\"\\r\\n\" +\n                \"Sec-WebSocket-Version: 6\\r\\n\"+\n        \"\\r\\n\");\n        _output.flush();\n\n        String responseLine = _input.readLine();\n        if(!responseLine.startsWith(\"HTTP/1.1 101 Switching Protocols\"))\n            throw new IOException(responseLine);\n        // Read until we find Response key\n        String line;\n        boolean accepted=false;\n        String protocol=\"\";\n        while ((line = _input.readLine()) != null)\n        {\n            if (line.length() == 0)\n                break;\n            if (line.startsWith(\"Sec-WebSocket-Accept:\"))\n            {\n                String accept=line.substring(21).trim();\n                accepted=accept.equals(WebSocketConnectionD06.hashKey(new String(B64Code.encode(key))));\n            }\n            else if (line.startsWith(\"Sec-WebSocket-Protocol:\"))\n            {\n                protocol=line.substring(24).trim();\n            }\n        }\n        \n        if (!accepted)\n            throw new IOException(\"Bad Sec-WebSocket-Accept\");\n        System.out.println(\"handshake OK for protocol '\"+protocol+\"'\");\n        \n        new Thread()\n        {\n            public void run()\n            {\n                while (_endp.isOpen())\n                {\n                    _parser.parseNext();\n                }\n            }\n        }.start();\n    }","commit_id":"80a56c31a2b3a1b371d6b2c3bc871a0781ad2e2f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public static void main(String[] args)\n    {\n        try\n        {\n            String host=\"localhost\";\n            int port=8080;\n            boolean verbose=false;\n            String protocol=null;\n            int count=10;\n            int size=64;\n            int fragment=4000;\n            boolean binary=false;\n            \n            for (int i=0;i<args.length;i++)\n            {\n                String a=args[i];\n                if (\"-p\".equals(a)||\"--port\".equals(a))\n                    port=Integer.parseInt(args[++i]);\n                else if (\"-h\".equals(a)||\"--host\".equals(a))\n                    port=Integer.parseInt(args[++i]);\n                else if (\"-c\".equals(a)||\"--count\".equals(a))\n                    count=Integer.parseInt(args[++i]);\n                else if (\"-s\".equals(a)||\"--size\".equals(a))\n                    size=Integer.parseInt(args[++i]);\n                else if (\"-f\".equals(a)||\"--fragment\".equals(a))\n                    fragment=Integer.parseInt(args[++i]);\n                else if (\"-P\".equals(a)||\"--protocol\".equals(a))\n                    protocol=args[++i];\n                else if (\"-v\".equals(a)||\"--verbose\".equals(a))\n                    verbose=true;\n                else if (\"-b\".equals(a)||\"--binary\".equals(a))\n                    binary=true;\n                else if (a.startsWith(\"-\"))\n                    usage(args);\n            }\n            \n\n            TestClient client = new TestClient(host,port,protocol==null?null:(\"org.ietf.websocket.test-\"+protocol),10000);\n            client.setSize(size);\n\n            try\n            {\n                client.open();\n                if (protocol.startsWith(\"echo\"))\n                    client.ping(count,binary?WebSocketConnectionD06.OP_BINARY:WebSocketConnectionD06.OP_TEXT,fragment);\n                else\n                    client.ping(count,WebSocketConnectionD06.OP_PING,-1);\n            }\n            finally\n            {\n                client.dump();\n            }\n            \n        }\n        catch (Exception e)\n        {\n            Log.warn(e);\n        }\n    }","id":24732,"modified_method":"public static void main(String[] args)\n    {\n        try\n        {\n            String host=\"localhost\";\n            int port=8080;\n            String protocol=null;\n            int count=10;\n            int size=64;\n            int fragment=4000;\n            boolean binary=false;\n            \n            for (int i=0;i<args.length;i++)\n            {\n                String a=args[i];\n                if (\"-p\".equals(a)||\"--port\".equals(a))\n                    port=Integer.parseInt(args[++i]);\n                else if (\"-h\".equals(a)||\"--host\".equals(a))\n                    port=Integer.parseInt(args[++i]);\n                else if (\"-c\".equals(a)||\"--count\".equals(a))\n                    count=Integer.parseInt(args[++i]);\n                else if (\"-s\".equals(a)||\"--size\".equals(a))\n                    size=Integer.parseInt(args[++i]);\n                else if (\"-f\".equals(a)||\"--fragment\".equals(a))\n                    fragment=Integer.parseInt(args[++i]);\n                else if (\"-P\".equals(a)||\"--protocol\".equals(a))\n                    protocol=args[++i];\n                else if (\"-v\".equals(a)||\"--verbose\".equals(a))\n                    _verbose=true;\n                else if (\"-b\".equals(a)||\"--binary\".equals(a))\n                    binary=true;\n                else if (a.startsWith(\"-\"))\n                    usage(args);\n            }\n            \n\n            TestClient client = new TestClient(host,port,protocol==null?null:(\"org.ietf.websocket.test-\"+protocol),10000);\n            client.setSize(size);\n\n            try\n            {\n                client.open();\n                if (protocol!=null && protocol.startsWith(\"echo\"))\n                    client.ping(count,binary?WebSocketConnectionD06.OP_BINARY:WebSocketConnectionD06.OP_TEXT,fragment);\n                else\n                    client.ping(count,WebSocketConnectionD06.OP_PING,-1);\n            }\n            finally\n            {\n                client.dump();\n            }\n            \n        }\n        catch (Exception e)\n        {\n            Log.warn(e);\n        }\n    }","commit_id":"80a56c31a2b3a1b371d6b2c3bc871a0781ad2e2f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void dump() throws IOException\n    {\n        _socket.close();\n        long duration=System.currentTimeMillis()-_start;\n        System.out.println(\"--- \"+_host+\" websocket ping statistics using 1 connection ---\");\n        System.out.println(_framesSent+\" frames transmitted, \"+_framesReceived+\" received, \"+\n                _messagesSent+\" messages transmitted, \"+_messagesReceived+\" received, \"+\n                \"time \"+duration+\"ms\");\n        System.out.printf(\"rtt min/ave/max = %.3f/%.3f/%.3f ms\\n\",_minDuration/1000000.0,_messagesReceived==0?0.0:(_totalTime/_messagesReceived/1000000.0),_maxDuration/1000000.0);\n    }","id":24733,"modified_method":"public void dump() throws Exception\n    {\n        for (int i=0;i<25;i++)\n        {\n            if (_messagesSent==_messagesReceived)\n                break;\n            Thread.sleep(100);\n        }\n        \n        _socket.close();\n        long duration=System.currentTimeMillis()-_start;\n        System.out.println(\"--- \"+_host+\" websocket ping statistics using 1 connection ---\");\n        System.out.println(_framesSent+\" frames transmitted, \"+_framesReceived+\" received, \"+\n                _messagesSent+\" messages transmitted, \"+_messagesReceived+\" received, \"+\n                \"time \"+duration+\"ms\");\n        System.out.printf(\"rtt min/ave/max = %.3f/%.3f/%.3f ms\\n\",_minDuration/1000000.0,_messagesReceived==0?0.0:(_totalTime/_messagesReceived/1000000.0),_maxDuration/1000000.0);\n    }","commit_id":"80a56c31a2b3a1b371d6b2c3bc871a0781ad2e2f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void ping(int count,byte opcode,int fragment)\n    {\n        _start=System.currentTimeMillis();\n        for (int i=0;i<count && !_socket.isClosed();i++)\n        {\n            if (_socket.isClosed())\n                break;\n            try\n            {\n                byte data[]=null;\n                \n                if (opcode==WebSocketConnectionD06.OP_TEXT)\n                {\n                    StringBuilder b = new StringBuilder();\n                    while (b.length()<_size)\n                        b.append('A'+__random.nextInt(26));\n                    data=b.toString().getBytes(StringUtil.__UTF8);\n                }\n                else\n                {             \n                    data= new byte[_size];\n                    __random.nextBytes(data);\n                }\n                _starts.add(System.nanoTime());\n                \n                int off=0;\n                int len=data.length;\n                if (fragment>0&& len>fragment)\n                    len=fragment;\n                _messagesSent++;\n                while(off<data.length)\n                {                    \n                    _framesSent++;\n                    _generator.addFrame((byte)(off+len==data.length?0x8:0),(byte)(off==0?opcode:WebSocketConnectionD06.OP_CONTINUATION),data,off,len,_socket.getSoTimeout());\n                    off+=len;\n                    if(data.length-off>len)\n                        len=data.length-off;\n                    if (fragment>0&& len>fragment)\n                        len=fragment;\n                }\n                _generator.flush(_socket.getSoTimeout());\n\n                Thread.sleep(1000);\n               \n            }\n            catch (Exception x)\n            {\n                throw new RuntimeException(x);\n            }\n        }\n    }","id":24734,"modified_method":"public void ping(int count,byte opcode,int fragment)\n    {\n        try\n        {\n            _start=System.currentTimeMillis();\n            for (int i=0;i<count && !_socket.isClosed();i++)\n            {\n                if (_socket.isClosed())\n                    break;\n                byte data[]=null;\n\n                if (opcode==WebSocketConnectionD06.OP_TEXT)\n                {\n                    StringBuilder b = new StringBuilder();\n                    while (b.length()<_size)\n                        b.append('A'+__random.nextInt(26));\n                    data=b.toString().getBytes(StringUtil.__UTF8);\n                }\n                else\n                {             \n                    data= new byte[_size];\n                    __random.nextBytes(data);\n                }\n                _starts.add(System.nanoTime());\n\n                int off=0;\n                int len=data.length;\n                if (fragment>0&& len>fragment)\n                    len=fragment;\n                _messagesSent++;\n                while(off<data.length)\n                {                    \n                    _framesSent++;\n                    byte flags= (byte)(off+len==data.length?0x8:0);\n                    byte op=(byte)(off==0?opcode:WebSocketConnectionD06.OP_CONTINUATION);\n\n                    if (_verbose)                \n                        System.err.printf(\"%s#addFrame %s|%s %s\\n\",this.getClass().getSimpleName(),TypeUtil.toHexString(flags),TypeUtil.toHexString(op),TypeUtil.toHexString(data,off,len));\n                    _generator.addFrame(flags,op,data,off,len,_socket.getSoTimeout());\n\n                    off+=len;\n                    if(data.length-off>len)\n                        len=data.length-off;\n                    if (fragment>0&& len>fragment)\n                        len=fragment;\n                }\n\n                _generator.flush(_socket.getSoTimeout());\n\n                Thread.sleep(1000);\n            }\n        }\n        catch (Exception x)\n        {\n            throw new RuntimeException(x);\n        }\n    }","commit_id":"80a56c31a2b3a1b371d6b2c3bc871a0781ad2e2f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private synchronized int flushBuffer() throws IOException\n    {\n        if (!_endp.isOpen())\n            throw new EofException();\n\n        if (_buffer!=null)\n            return _endp.flush(_buffer);\n\n        return 0;\n    }","id":24735,"modified_method":"private synchronized int flushBuffer() throws IOException\n    {\n        try\n        {\n            if (!_endp.isOpen())\n                throw new EofException();\n\n            if (_buffer!=null)\n                return _endp.flush(_buffer);\n\n            return 0;\n        }\n        catch(IOException e)\n        {\n            System.err.println(\"FAILED to flush: \"+_buffer.toDetailString());\n            throw e;\n        }\n    }","commit_id":"80a56c31a2b3a1b371d6b2c3bc871a0781ad2e2f","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n\t * Sets the request target as the current.\n\t * \n\t * @param requestTarget\n\t *            the request target to set as current\n\t */\n\tpublic final void setRequestTarget(IRequestTarget requestTarget)\n\t{\n\t\t// FIXME post 1.2 Robustness: This has to be done after the unit tests are fixed\n\t\t// // if we are already responding, we can't change the request target\n\t\t// // as that would either have no effect, or - in case we would set\n\t\t// // the currentStep back to PROCESS_EVENTS, we would have double\n\t\t// // output (and it is not Wicket's intention to work as Servlet\n\t\t// filters)\n\t\t// if (currentStep >= RESPOND)\n\t\t// {\n\t\t// throw new WicketRuntimeException(\n\t\t// \"you cannot change the request cycle after rendering has commenced\");\n\t\t// }\n\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tif (!requestTargets.isEmpty())\n\t\t\t{\n\t\t\t\tIRequestTarget former = (IRequestTarget)requestTargets.peek();\n\t\t\t\tlog.debug(\"replacing request target \" + former + \" with \" + requestTarget);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.debug(\"setting request target to \" + requestTarget);\n\t\t\t}\n\t\t}\n\n\t\t// change the current step to a step that will handle the\n\t\t// new target if need be\n\t\tif (currentStep >= RESPOND)\n\t\t{\n\t\t\tif (log.isDebugEnabled())\n\t\t\t{\n\t\t\t\tlog.debug(\"rewinding request processing to PROCESS_EVENTS\");\n\t\t\t}\n\n\t\t\t// we are not actually doing event processing again,\n\t\t\t// but since we are still in the loop here, the next\n\t\t\t// actual value will be RESPOND again\n\t\t\tcurrentStep = PROCESS_EVENTS;\n\t\t}\n\t\t// NOTE: if we are at PROCESS_EVENTS, leave it as we don't\n\t\t// want to re-execute that step again\n\n\t\trequestTargets.push(requestTarget);\n\t}","id":24736,"modified_method":"/**\n\t * Sets the request target as the current.\n\t * \n\t * @param requestTarget\n\t *            the request target to set as current\n\t */\n\tpublic final void setRequestTarget(IRequestTarget requestTarget)\n\t{\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tif (!requestTargets.isEmpty())\n\t\t\t{\n\t\t\t\tIRequestTarget former = requestTargets.peek();\n\t\t\t\tlog.debug(\"replacing request target \" + former + \" with \" + requestTarget);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlog.debug(\"setting request target to \" + requestTarget);\n\t\t\t}\n\t\t}\n\n\t\t// change the current step to a step that will handle the\n\t\t// new target if need be\n\t\tif (currentStep >= RESPOND)\n\t\t{\n\t\t\tif (log.isDebugEnabled())\n\t\t\t{\n\t\t\t\tlog.debug(\"rewinding request processing to PROCESS_EVENTS\");\n\t\t\t}\n\n\t\t\t// we are not actually doing event processing again,\n\t\t\t// but since we are still in the loop here, the next\n\t\t\t// actual value will be RESPOND again\n\t\t\tcurrentStep = PROCESS_EVENTS;\n\t\t}\n\t\t// NOTE: if we are at PROCESS_EVENTS, leave it as we don't\n\t\t// want to re-execute that step again\n\n\t\trequestTargets.push(requestTarget);\n\t}","commit_id":"2151fd62603c234613ee84410e05aa4d421079a4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the current request target. May be null.\n\t * \n\t * @return the current request target, null if none was set yet.\n\t */\n\tpublic final IRequestTarget getRequestTarget()\n\t{\n\t\treturn (!requestTargets.isEmpty()) ? (IRequestTarget)requestTargets.peek() : null;\n\t}","id":24737,"modified_method":"/**\n\t * Gets the current request target. May be null.\n\t * \n\t * @return the current request target, null if none was set yet.\n\t */\n\tpublic final IRequestTarget getRequestTarget()\n\t{\n\t\treturn (!requestTargets.isEmpty()) ? requestTargets.peek() : null;\n\t}","commit_id":"2151fd62603c234613ee84410e05aa4d421079a4","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * In case of inherited markup, the base and the extended markups are merged and the information\n\t * about the tags origin is lost. In some cases like wicket:head and wicket:link this\n\t * information however is required.\n\t * \n\t * @return wicketHeaderClass\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class< ? extends Component< ? >> getMarkupClass()\n\t{\n\t\treturn (markupClassRef == null ? null : markupClassRef.get());\n\t}","id":24738,"modified_method":"/**\n\t * In case of inherited markup, the base and the extended markups are merged and the information\n\t * about the tags origin is lost. In some cases like wicket:head and wicket:link this\n\t * information however is required.\n\t * \n\t * @return wicketHeaderClass\n\t */\n\tpublic Class<? extends Component<?>> getMarkupClass()\n\t{\n\t\treturn (markupClassRef == null ? null : markupClassRef.get());\n\t}","commit_id":"a3c3ecaa0b984ad16116db1c9c1b1b13542396ed","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Get the next MarkupElement from the parent MarkupFilter and handle it if the specific filter\n\t * criteria are met. Depending on the filter, it may return the MarkupElement unchanged,\n\t * modified or it remove by asking the parent handler for the next tag.\n\t * \n\t * @see org.apache.wicket.markup.parser.IMarkupFilter#nextTag()\n\t * @return Return the next eligible MarkupElement\n\t */\n\tpublic MarkupElement nextTag() throws ParseException\n\t{\n\t\t// Get the next tag. If null, no more tags are available\n\t\tfinal ComponentTag tag = (ComponentTag)getParent().nextTag();\n\t\tif (tag == null)\n\t\t{\n\t\t\t// No more tags from the markup.\n\t\t\t// If there's still a non-simple tag left, it's an error\n\t\t\twhile (stack.size() > 0)\n\t\t\t{\n\t\t\t\tfinal ComponentTag top = (ComponentTag)stack.peek();\n\n\t\t\t\tif (!requiresCloseTag(top.getName()))\n\t\t\t\t{\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new ParseException(\"Tag \" + top + \" at \" + top.getPos() +\n\t\t\t\t\t\t\" did not have a close tag\", top.getPos());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tag;\n\t\t}\n\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"tag: \" + tag.toUserDebugString() + \", stack: \" + stack);\n\t\t}\n\n\t\t// Check tag type\n\t\tif (tag.isOpen())\n\t\t{\n\t\t\t// Push onto stack\n\t\t\tstack.push(tag);\n\t\t}\n\t\telse if (tag.isClose())\n\t\t{\n\t\t\t// Check that there is something on the stack\n\t\t\tif (stack.size() > 0)\n\t\t\t{\n\t\t\t\t// Pop the top tag off the stack\n\t\t\t\tComponentTag top = (ComponentTag)stack.pop();\n\n\t\t\t\t// If the name of the current close tag does not match the\n\t\t\t\t// tag on the stack then we may have a mismatched close tag\n\t\t\t\tboolean mismatch = !top.hasEqualTagName(tag);\n\n\t\t\t\tif (mismatch)\n\t\t\t\t{\n\t\t\t\t\ttop.setHasNoCloseTag(true);\n\n\t\t\t\t\t// Pop any simple tags off the top of the stack\n\t\t\t\t\twhile (mismatch && !requiresCloseTag(top.getName()))\n\t\t\t\t\t{\n\t\t\t\t\t\ttop.setHasNoCloseTag(true);\n\n\t\t\t\t\t\t// Pop simple tag\n\t\t\t\t\t\tif (stack.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttop = (ComponentTag)stack.pop();\n\n\t\t\t\t\t\t// Does new top of stack mismatch too?\n\t\t\t\t\t\tmismatch = !top.hasEqualTagName(tag);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If adjusting for simple tags did not fix the problem,\n\t\t\t\t\t// it must be a real mismatch.\n\t\t\t\t\tif (mismatch)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ParseException(\"Tag \" + top.toUserDebugString() +\n\t\t\t\t\t\t\t\" has a mismatched close tag at \" + tag.toUserDebugString(),\n\t\t\t\t\t\t\ttop.getPos());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tag matches, so add pointer to matching tag\n\t\t\t\ttag.setOpenTag(top);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new ParseException(\"Tag \" + tag.toUserDebugString() +\n\t\t\t\t\t\" does not have a matching open tag\", tag.getPos());\n\t\t\t}\n\t\t}\n\t\telse if (tag.isOpenClose())\n\t\t{\n\t\t\t// Tag closes itself\n\t\t\ttag.setOpenTag(tag);\n\t\t}\n\n\t\treturn tag;\n\t}","id":24739,"modified_method":"/**\n\t * Get the next MarkupElement from the parent MarkupFilter and handle it if the specific filter\n\t * criteria are met. Depending on the filter, it may return the MarkupElement unchanged,\n\t * modified or it remove by asking the parent handler for the next tag.\n\t * \n\t * @see org.apache.wicket.markup.parser.IMarkupFilter#nextTag()\n\t * @return Return the next eligible MarkupElement\n\t */\n\tpublic MarkupElement nextTag() throws ParseException\n\t{\n\t\t// Get the next tag. If null, no more tags are available\n\t\tfinal ComponentTag tag = (ComponentTag)getParent().nextTag();\n\t\tif (tag == null)\n\t\t{\n\t\t\t// No more tags from the markup.\n\t\t\t// If there's still a non-simple tag left, it's an error\n\t\t\twhile (stack.size() > 0)\n\t\t\t{\n\t\t\t\tfinal ComponentTag top = stack.peek();\n\n\t\t\t\tif (!requiresCloseTag(top.getName()))\n\t\t\t\t{\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new ParseException(\"Tag \" + top + \" at \" + top.getPos() +\n\t\t\t\t\t\t\" did not have a close tag\", top.getPos());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn tag;\n\t\t}\n\n\t\tif (log.isDebugEnabled())\n\t\t{\n\t\t\tlog.debug(\"tag: \" + tag.toUserDebugString() + \", stack: \" + stack);\n\t\t}\n\n\t\t// Check tag type\n\t\tif (tag.isOpen())\n\t\t{\n\t\t\t// Push onto stack\n\t\t\tstack.push(tag);\n\t\t}\n\t\telse if (tag.isClose())\n\t\t{\n\t\t\t// Check that there is something on the stack\n\t\t\tif (stack.size() > 0)\n\t\t\t{\n\t\t\t\t// Pop the top tag off the stack\n\t\t\t\tComponentTag top = stack.pop();\n\n\t\t\t\t// If the name of the current close tag does not match the\n\t\t\t\t// tag on the stack then we may have a mismatched close tag\n\t\t\t\tboolean mismatch = !top.hasEqualTagName(tag);\n\n\t\t\t\tif (mismatch)\n\t\t\t\t{\n\t\t\t\t\ttop.setHasNoCloseTag(true);\n\n\t\t\t\t\t// Pop any simple tags off the top of the stack\n\t\t\t\t\twhile (mismatch && !requiresCloseTag(top.getName()))\n\t\t\t\t\t{\n\t\t\t\t\t\ttop.setHasNoCloseTag(true);\n\n\t\t\t\t\t\t// Pop simple tag\n\t\t\t\t\t\tif (stack.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttop = stack.pop();\n\n\t\t\t\t\t\t// Does new top of stack mismatch too?\n\t\t\t\t\t\tmismatch = !top.hasEqualTagName(tag);\n\t\t\t\t\t}\n\n\t\t\t\t\t// If adjusting for simple tags did not fix the problem,\n\t\t\t\t\t// it must be a real mismatch.\n\t\t\t\t\tif (mismatch)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new ParseException(\"Tag \" + top.toUserDebugString() +\n\t\t\t\t\t\t\t\" has a mismatched close tag at \" + tag.toUserDebugString(),\n\t\t\t\t\t\t\ttop.getPos());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tag matches, so add pointer to matching tag\n\t\t\t\ttag.setOpenTag(top);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new ParseException(\"Tag \" + tag.toUserDebugString() +\n\t\t\t\t\t\" does not have a matching open tag\", tag.getPos());\n\t\t\t}\n\t\t}\n\t\telse if (tag.isOpenClose())\n\t\t{\n\t\t\t// Tag closes itself\n\t\t\ttag.setOpenTag(tag);\n\t\t}\n\n\t\treturn tag;\n\t}","commit_id":"a3c3ecaa0b984ad16116db1c9c1b1b13542396ed","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Get the next MarkupElement from the parent MarkupFilter and handle it if the specific filter\n\t * criteria are met. Depending on the filter, it may return the MarkupElement unchanged,\n\t * modified or it remove by asking the parent handler for the next tag.\n\t * \n\t * @see org.apache.wicket.markup.parser.IMarkupFilter#nextTag()\n\t * @return Return the next eligible MarkupElement\n\t */\n\tpublic MarkupElement nextTag() throws ParseException\n\t{\n\t\t// If there is something in the stack, ...\n\t\twhile (stack.size() > 0)\n\t\t{\n\t\t\tfinal ComponentTag top = (ComponentTag)stack.pop();\n\t\t\treturn top;\n\t\t}\n\n\t\t// Get the next tag. If null, no more tags are available\n\t\t// in the markup\n\t\tfinal ComponentTag tag = (ComponentTag)getParent().nextTag();\n\t\tif (tag == null)\n\t\t{\n\t\t\treturn tag;\n\t\t}\n\n\t\tif (tag.isOpenClose())\n\t\t{\n\t\t\tString name = tag.getName();\n\t\t\tif (tag.getNamespace() != null)\n\t\t\t{\n\t\t\t\tname = tag.getNamespace() + \":\" + tag.getName();\n\t\t\t}\n\n\t\t\t// Pop any simple tags off the top of the stack\n\t\t\tif (requiresOpenBodyCloseTag(name))\n\t\t\t{\n\t\t\t\ttag.setType(XmlTag.OPEN);\n\t\t\t\tXmlTag closeTag = new XmlTag();\n\t\t\t\tcloseTag.setType(XmlTag.CLOSE);\n\t\t\t\tcloseTag.setName(tag.getName());\n\t\t\t\tcloseTag.setNamespace(tag.getNamespace());\n\t\t\t\tcloseTag.closes(tag);\n\n\t\t\t\tstack.push(new ComponentTag(closeTag));\n\t\t\t}\n\t\t}\n\n\t\treturn tag;\n\t}","id":24740,"modified_method":"/**\n\t * Get the next MarkupElement from the parent MarkupFilter and handle it if the specific filter\n\t * criteria are met. Depending on the filter, it may return the MarkupElement unchanged,\n\t * modified or it remove by asking the parent handler for the next tag.\n\t * \n\t * @see org.apache.wicket.markup.parser.IMarkupFilter#nextTag()\n\t * @return Return the next eligible MarkupElement\n\t */\n\tpublic MarkupElement nextTag() throws ParseException\n\t{\n\t\t// If there is something in the stack, ...\n\t\twhile (stack.size() > 0)\n\t\t{\n\t\t\tfinal ComponentTag top = stack.pop();\n\t\t\treturn top;\n\t\t}\n\n\t\t// Get the next tag. If null, no more tags are available\n\t\t// in the markup\n\t\tfinal ComponentTag tag = (ComponentTag)getParent().nextTag();\n\t\tif (tag == null)\n\t\t{\n\t\t\treturn tag;\n\t\t}\n\n\t\tif (tag.isOpenClose())\n\t\t{\n\t\t\tString name = tag.getName();\n\t\t\tif (tag.getNamespace() != null)\n\t\t\t{\n\t\t\t\tname = tag.getNamespace() + \":\" + tag.getName();\n\t\t\t}\n\n\t\t\t// Pop any simple tags off the top of the stack\n\t\t\tif (requiresOpenBodyCloseTag(name))\n\t\t\t{\n\t\t\t\ttag.setType(XmlTag.OPEN);\n\t\t\t\tXmlTag closeTag = new XmlTag();\n\t\t\t\tcloseTag.setType(XmlTag.CLOSE);\n\t\t\t\tcloseTag.setName(tag.getName());\n\t\t\t\tcloseTag.setNamespace(tag.getNamespace());\n\t\t\t\tcloseTag.closes(tag);\n\n\t\t\t\tstack.push(new ComponentTag(closeTag));\n\t\t\t}\n\t\t}\n\n\t\treturn tag;\n\t}","commit_id":"a3c3ecaa0b984ad16116db1c9c1b1b13542396ed","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Get the next MarkupElement from the parent MarkupFilter and handles it if the specific filter\n\t * criteria are met. Depending on the filter, it may return the MarkupElement unchanged,\n\t * modified or it remove by asking the parent handler for the next tag.\n\t * \n\t * @see org.apache.wicket.markup.parser.IMarkupFilter#nextTag()\n\t * @return Return the next eligible MarkupElement\n\t */\n\tpublic final MarkupElement nextTag() throws ParseException\n\t{\n\t\t// Get next tag. Null, if no more tag available\n\t\tfinal ComponentTag tag = (ComponentTag)getParent().nextTag();\n\t\tif (tag == null)\n\t\t{\n\t\t\treturn tag;\n\t\t}\n\n\t\t// Only xml tags not already identified as Wicket components will be\n\t\t// considered for autolinking. This is because it is assumed that Wicket\n\t\t// components like images or all other kind of Wicket Links will handle\n\t\t// it themselves.\n\t\t// Subclass analyzeAutolinkCondition() to implement you own\n\t\t// implementation and register the new tag handler with the markup\n\t\t// parser through Application.newMarkupParser().\n\t\tif ((autolinking == true) && (analyzeAutolinkCondition(tag) == true))\n\t\t{\n\t\t\t// Mark it as autolink enabled\n\t\t\ttag.enableAutolink(true);\n\n\t\t\t// Just a dummy name. The ComponentTag will not be forwarded.\n\t\t\ttag.setId(AUTOLINK_ID);\n\t\t\ttag.setAutoComponentTag(true);\n\t\t\ttag.setModified(true);\n\t\t\treturn tag;\n\t\t}\n\n\t\t// For all <wicket:link ..> tags which probably change the\n\t\t// current autolink status.\n\t\tif (tag instanceof WicketTag)\n\t\t{\n\t\t\tfinal WicketTag wtag = (WicketTag)tag;\n\t\t\tif (wtag.isLinkTag())\n\t\t\t{\n\t\t\t\t// Beginning of the region\n\t\t\t\tif (tag.isOpen() || tag.isOpenClose())\n\t\t\t\t{\n\t\t\t\t\tif (tag.isOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (autolinkStatus == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tautolinkStatus = new ArrayListStack();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remember the current setting to be reset after the\n\t\t\t\t\t\t// region\n\t\t\t\t\t\tautolinkStatus.push(Boolean.valueOf(autolinking));\n\t\t\t\t\t}\n\n\t\t\t\t\t// html allows to represent true in different ways\n\t\t\t\t\tfinal String autolink = tag.getAttributes().getString(\"autolink\");\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tautolinking = Strings.isEmpty(autolink) || Strings.isTrue(autolink);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (StringValueConversionException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\"Invalid autolink attribute value \\\"\" +\n\t\t\t\t\t\t\t\tautolink + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (tag.isClose())\n\t\t\t\t{\n\t\t\t\t\t// restore the autolink setting from before the region\n\t\t\t\t\tautolinking = ((Boolean)autolinkStatus.pop()).booleanValue();\n\t\t\t\t}\n\n\t\t\t\treturn wtag;\n\t\t\t}\n\t\t}\n\n\t\treturn tag;\n\t}","id":24741,"modified_method":"/**\n\t * Get the next MarkupElement from the parent MarkupFilter and handles it if the specific filter\n\t * criteria are met. Depending on the filter, it may return the MarkupElement unchanged,\n\t * modified or it remove by asking the parent handler for the next tag.\n\t * \n\t * @see org.apache.wicket.markup.parser.IMarkupFilter#nextTag()\n\t * @return Return the next eligible MarkupElement\n\t */\n\tpublic final MarkupElement nextTag() throws ParseException\n\t{\n\t\t// Get next tag. Null, if no more tag available\n\t\tfinal ComponentTag tag = (ComponentTag)getParent().nextTag();\n\t\tif (tag == null)\n\t\t{\n\t\t\treturn tag;\n\t\t}\n\n\t\t// Only xml tags not already identified as Wicket components will be\n\t\t// considered for autolinking. This is because it is assumed that Wicket\n\t\t// components like images or all other kind of Wicket Links will handle\n\t\t// it themselves.\n\t\t// Subclass analyzeAutolinkCondition() to implement you own\n\t\t// implementation and register the new tag handler with the markup\n\t\t// parser through Application.newMarkupParser().\n\t\tif ((autolinking == true) && (analyzeAutolinkCondition(tag) == true))\n\t\t{\n\t\t\t// Mark it as autolink enabled\n\t\t\ttag.enableAutolink(true);\n\n\t\t\t// Just a dummy name. The ComponentTag will not be forwarded.\n\t\t\ttag.setId(AUTOLINK_ID);\n\t\t\ttag.setAutoComponentTag(true);\n\t\t\ttag.setModified(true);\n\t\t\treturn tag;\n\t\t}\n\n\t\t// For all <wicket:link ..> tags which probably change the\n\t\t// current autolink status.\n\t\tif (tag instanceof WicketTag)\n\t\t{\n\t\t\tfinal WicketTag wtag = (WicketTag)tag;\n\t\t\tif (wtag.isLinkTag())\n\t\t\t{\n\t\t\t\t// Beginning of the region\n\t\t\t\tif (tag.isOpen() || tag.isOpenClose())\n\t\t\t\t{\n\t\t\t\t\tif (tag.isOpen())\n\t\t\t\t\t{\n\t\t\t\t\t\tif (autolinkStatus == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tautolinkStatus = new ArrayListStack<Boolean>();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remember the current setting to be reset after the\n\t\t\t\t\t\t// region\n\t\t\t\t\t\tautolinkStatus.push(autolinking);\n\t\t\t\t\t}\n\n\t\t\t\t\t// html allows to represent true in different ways\n\t\t\t\t\tfinal String autolink = tag.getAttributes().getString(\"autolink\");\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tautolinking = Strings.isEmpty(autolink) || Strings.isTrue(autolink);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (StringValueConversionException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new WicketRuntimeException(\"Invalid autolink attribute value \\\"\" +\n\t\t\t\t\t\t\tautolink + \"\\\"\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (tag.isClose())\n\t\t\t\t{\n\t\t\t\t\t// restore the autolink setting from before the region\n\t\t\t\t\tautolinking = autolinkStatus.pop();\n\t\t\t\t}\n\n\t\t\t\treturn wtag;\n\t\t\t}\n\t\t}\n\n\t\treturn tag;\n\t}","commit_id":"a3c3ecaa0b984ad16116db1c9c1b1b13542396ed","url":"https://github.com/apache/wicket"},{"original_method":"private Scheduler createScheduler() throws SchedulerException {\n    SchedulerFactory factory = new StdSchedulerFactory(withFactoryProperties());\n\n    return factory.getScheduler();\n  }","id":24742,"modified_method":"private Scheduler createScheduler() throws SchedulerException {\n    SchedulerFactory factory = new StdSchedulerFactory(withFactoryProperties());\n\n    final Scheduler scheduler;\n    final ClassLoader contextClassLoader = currentThread().getContextClassLoader();\n    try {\n      // Quartz factory uses Thread's context classLoader to load the scheduler class. At this point the Mule application\n      // classloader is configured, so it must changed to use the container's.\n      currentThread().setContextClassLoader(getClass().getClassLoader());\n      scheduler = factory.getScheduler();\n    } finally {\n      currentThread().setContextClassLoader(contextClassLoader);\n    }\n    return scheduler;\n  }","commit_id":"d00d366523a226ca9b9857f75f9ffac3223b0efc","url":"https://github.com/mulesoft/mule"},{"original_method":"protected Scheduler createScheduler() throws SchedulerException {\n        return getFactory().getScheduler();\n    }","id":24743,"modified_method":"protected Scheduler createScheduler() throws SchedulerException {\n    \tScheduler scheduler = getFactory().getScheduler();\n    \tscheduler.getContext().put(QuartzEndpoint.CONTEXT_KEY, getCamelContext());\n        return scheduler;\n    }","commit_id":"c8b41f947ea5425e72ccca077e9a569dc1cf4bdb","url":"https://github.com/apache/camel"},{"original_method":"public void addTrigger(Trigger trigger, JobDetail detail) throws SchedulerException {\n        // lets default the trigger name to the job name\n        if (trigger.getName() == null) {\n            trigger.setName(detail.getName());\n        }\n        // lets default the trigger group to the job group\n        if (trigger.getGroup() == null) {\n            trigger.setGroup(detail.getGroup());\n        }\n        // default start time to now if not specified\n        if (trigger.getStartTime() == null) {\n            trigger.setStartTime(new Date());\n        }\n        detail.getJobDataMap().put(ENDPOINT_KEY, this);\n        Class jobClass = detail.getJobClass();\n        if (jobClass == null) {\n            detail.setJobClass(CamelJob.class);\n        }\n        if (detail.getName() == null) {\n            detail.setName(getEndpointUri());\n        }\n        getScheduler().scheduleJob(detail, trigger);\n    }","id":24744,"modified_method":"public void addTrigger(final Trigger trigger, final JobDetail detail) throws SchedulerException {\n        // lets default the trigger name to the job name\n        if (trigger.getName() == null) {\n            trigger.setName(detail.getName());\n        }\n        // lets default the trigger group to the job group\n        if (trigger.getGroup() == null) {\n            trigger.setGroup(detail.getGroup());\n        }\n        // default start time to now if not specified\n        if (trigger.getStartTime() == null) {\n            trigger.setStartTime(new Date());\n        }\n        detail.getJobDataMap().put(ENDPOINT_KEY, isStateful() ? getEndpointUri() : this);\n        if (null == detail.getJobClass()) {\n            detail.setJobClass(isStateful() ? StatefulCamelJob.class : CamelJob.class);\n        }\n        if (detail.getName() == null) {\n            detail.setName(getEndpointUri());\n        }\n        getScheduler().scheduleJob(detail, trigger);\n    }","commit_id":"c8b41f947ea5425e72ccca077e9a569dc1cf4bdb","url":"https://github.com/apache/camel"},{"original_method":"public void connect(InetSocketAddress address, Session.Listener listener, Promise<Session> promise)\n    {\n        try\n        {\n            SocketChannel channel = SocketChannel.open();\n            channel.socket().setTcpNoDelay(true);\n            channel.configureBlocking(false);\n            channel.connect(address);\n            selector.connect(channel, new Context(listener, promise));\n        }\n        catch (Throwable x)\n        {\n            promise.failed(x);\n        }\n    }","id":24745,"modified_method":"public void connect(InetSocketAddress address, Session.Listener listener, Promise<Session> promise)\n    {\n        connect(null, address, listener, promise);\n    }","commit_id":"51e4885911a57779e195ddf9a71faed519784875","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public Connection newConnection(SocketChannel channel, EndPoint endpoint, Object attachment) throws IOException\n        {\n            Context context = (Context)attachment;\n            Generator generator = new Generator(byteBufferPool, 4096);\n            HTTP2Session session = new HTTP2ClientSession(getScheduler(), endpoint, generator, context.listener, new HTTP2FlowControl(65535));\n            Parser parser = new Parser(byteBufferPool, session, 4096, 8192);\n            return new HTTP2ClientConnection(byteBufferPool, getExecutor(), endpoint, parser, session, 8192, context.promise);\n        }","id":24746,"modified_method":"@Override\n        public Connection newConnection(SocketChannel channel, EndPoint endpoint, Object attachment) throws IOException\n        {\n            @SuppressWarnings(\"unchecked\")\n            Map<String, Object> context = (Map<String, Object>)attachment;\n            context.put(HTTP2ClientConnectionFactory.BYTE_BUFFER_POOL_CONTEXT_KEY, byteBufferPool);\n            context.put(HTTP2ClientConnectionFactory.EXECUTOR_CONTEXT_KEY, getExecutor());\n            context.put(HTTP2ClientConnectionFactory.SCHEDULER_CONTEXT_KEY, getScheduler());\n\n            ClientConnectionFactory factory = new HTTP2ClientConnectionFactory();\n\n            SslContextFactory sslContextFactory = (SslContextFactory)context.get(SslClientConnectionFactory.SSL_CONTEXT_FACTORY_CONTEXT_KEY);\n            if (sslContextFactory != null)\n            {\n                ALPNClientConnectionFactory alpn = new ALPNClientConnectionFactory(getExecutor(), factory, \"h2-14\");\n                factory = new SslClientConnectionFactory(sslContextFactory, byteBufferPool, getExecutor(), alpn);\n            }\n\n            return factory.newConnection(endpoint, context);\n        }","commit_id":"51e4885911a57779e195ddf9a71faed519784875","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Creates a publish resource bean from the target information of a relation object.<p>\n     * \n     * @param relation the relation to use\n     *  \n     * @return the publish resource bean for the relation target \n     */\n    public CmsPublishResource relationToBean(CmsRelation relation) {\n\n        return new CmsPublishResource(\n            relation.getTargetId(),\n            relation.getTargetPath(),\n            relation.getTargetPath(),\n            CmsResourceTypePlain.getStaticTypeName(),\n            CmsResourceState.STATE_UNCHANGED,\n            CmsResource.isFolder(relation.getTargetPath()),\n            false,\n            null,\n            null);\n    }","id":24747,"modified_method":"/**\n     * Creates a publish resource bean from the target information of a relation object.<p>\n     * \n     * @param relation the relation to use\n     *  \n     * @return the publish resource bean for the relation target \n     */\n    public CmsPublishResource relationToBean(CmsRelation relation) {\n\n        return new CmsPublishResource(\n            relation.getTargetId(),\n            relation.getTargetPath(),\n            relation.getTargetPath(),\n            CmsResourceTypePlain.getStaticTypeName(),\n            CmsResourceState.STATE_UNCHANGED,\n            0,\n            CmsResource.isFolder(relation.getTargetPath()),\n            false,\n            null,\n            null);\n    }","commit_id":"28e97877ecaee792efe6130984857b39734b6b54","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Creates a publish resource bean instance from the given parameters.<p>\n     * \n     * @param resource the resource\n     * @param info the publish information, if any\n     * @param removable if removable\n     * @param related the list of related resources\n     * \n     * @return the publish resource bean\n     */\n    protected CmsPublishResource resourceToBean(\n        CmsResource resource,\n        CmsPublishResourceInfo info,\n        boolean removable,\n        List<CmsPublishResource> related) {\n\n        CmsResourceUtil resUtil = new CmsResourceUtil(m_cms, resource);\n\n        CmsPublishResource pubResource = new CmsPublishResource(\n            resource.getStructureId(),\n            resUtil.getFullPath(),\n            resUtil.getTitle(),\n            resUtil.getResourceTypeName(),\n            resource.getState(),\n            resource.isFolder(),\n            removable,\n            info,\n            related);\n        return pubResource;\n    }","id":24748,"modified_method":"/**\n     * Creates a publish resource bean instance from the given parameters.<p>\n     * \n     * @param resource the resource\n     * @param info the publish information, if any\n     * @param removable if removable\n     * @param related the list of related resources\n     * \n     * @return the publish resource bean\n     */\n    protected CmsPublishResource resourceToBean(\n        CmsResource resource,\n        CmsPublishResourceInfo info,\n        boolean removable,\n        List<CmsPublishResource> related) {\n\n        CmsResourceUtil resUtil = new CmsResourceUtil(m_cms, resource);\n\n        CmsPublishResource pubResource = new CmsPublishResource(\n            resource.getStructureId(),\n            resUtil.getFullPath(),\n            resUtil.getTitle(),\n            resUtil.getResourceTypeName(),\n            resource.getState(),\n            resource.getDateLastModified(),\n            resource.isFolder(),\n            removable,\n            info,\n            related);\n        return pubResource;\n    }","commit_id":"28e97877ecaee792efe6130984857b39734b6b54","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Returns the list of publish groups with resources that can be published.<p>\n     * \n     * @return the list of publish groups with resources that can be published\n     */\n    public List<CmsPublishGroup> getPublishGroups() {\n\n        // first look for already published resources\n        Set<CmsResource> published = getAlreadyPublishedResources();\n\n        // then for resources without permission\n        Set<CmsResource> exclude = new HashSet<CmsResource>(published);\n\n        ResourcesAndRelated permissions = getResourcesWithoutPermissions(exclude);\n\n        // and finally for locked resources\n        exclude.addAll(permissions.getResources());\n        exclude.addAll(permissions.getRelatedResources());\n\n        ResourcesAndRelated locked = getBlockingLockedResources(exclude);\n\n        // collect all direct resources that can not be published\n        exclude.clear();\n        exclude.addAll(published);\n        exclude.addAll(permissions.getResources());\n        exclude.addAll(locked.getResources());\n\n        // update the publish list\n        ResourcesAndRelated pubResources = new ResourcesAndRelated();\n        pubResources.getResources().addAll(getPublishResources().getResources());\n        pubResources.getResources().removeAll(exclude);\n        pubResources.getRelatedResources().addAll(getPublishResources().getRelatedResources());\n        pubResources.getRelatedResources().removeAll(permissions.getRelatedResources());\n        pubResources.getRelatedResources().removeAll(locked.getRelatedResources());\n\n        if (getPublishResources().getResources().isEmpty()) {\n            // nothing to do\n            return new ArrayList<CmsPublishGroup>();\n        }\n\n        List<CmsResource> resourcesWithoutTempfiles = new ArrayList<CmsResource>();\n        for (CmsResource res : getPublishResources().getResources()) {\n            if (!CmsResource.isTemporaryFileName(res.getRootPath())) {\n                resourcesWithoutTempfiles.add(res);\n            }\n        }\n\n        // the resources the user can really publish\n        Set<CmsResource> allPubRes = new HashSet<CmsResource>(pubResources.getRelatedResources());\n        allPubRes.addAll(pubResources.getResources());\n\n        List<CmsResource> pubList = new ArrayList<CmsResource>();\n        try {\n            pubList = OpenCms.getPublishManager().getUsersPubList(m_cms);\n        } catch (CmsException e) {\n            // should never happen\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n\n        CmsPublishGroupHelper groupHelper = new CmsPublishGroupHelper(m_workplaceLocale);\n        List<CmsResourceGroup> resourceGroups = groupHelper.getGroups(resourcesWithoutTempfiles);\n        List<CmsPublishGroup> resultGroups = new ArrayList<CmsPublishGroup>();\n        for (CmsResourceGroup resGroup : resourceGroups) {\n            CmsPublishGroup publishGroup = convertResourceGroup(\n                resGroup,\n                pubList,\n                allPubRes,\n                published,\n                permissions,\n                locked);\n            resultGroups.add(publishGroup);\n        }\n        return resultGroups;\n    }","id":24749,"modified_method":"/**\n     * Returns the list of publish groups with resources that can be published.<p>\n     * \n     * @return the list of publish groups with resources that can be published\n     */\n    public List<CmsPublishGroup> getPublishGroups() {\n\n        // first look for already published resources\n        Set<CmsResource> published = getAlreadyPublishedResources();\n\n        // then for resources without permission\n        Set<CmsResource> exclude = new HashSet<CmsResource>(published);\n\n        ResourcesAndRelated permissions = getResourcesWithoutPermissions(exclude);\n\n        // and finally for locked resources\n        exclude.addAll(permissions.getResources());\n        exclude.addAll(permissions.getRelatedResources());\n\n        ResourcesAndRelated locked = getBlockingLockedResources(exclude);\n\n        // collect all direct resources that can not be published\n        exclude.clear();\n        exclude.addAll(published);\n        exclude.addAll(permissions.getResources());\n        exclude.addAll(locked.getResources());\n\n        // update the publish list\n        ResourcesAndRelated pubResources = new ResourcesAndRelated();\n        pubResources.getResources().addAll(getPublishResources().getResources());\n        pubResources.getResources().removeAll(exclude);\n        pubResources.getRelatedResources().addAll(getPublishResources().getRelatedResources());\n        pubResources.getRelatedResources().removeAll(permissions.getRelatedResources());\n        pubResources.getRelatedResources().removeAll(locked.getRelatedResources());\n\n        if (getPublishResources().getResources().isEmpty()) {\n            // nothing to do\n            return new ArrayList<CmsPublishGroup>();\n        }\n\n        List<CmsResource> resourcesWithoutTempfiles = new ArrayList<CmsResource>();\n        for (CmsResource res : getPublishResources().getResources()) {\n            if (!CmsResource.isTemporaryFileName(res.getRootPath())) {\n                resourcesWithoutTempfiles.add(res);\n            }\n        }\n\n        // the resources the user can really publish\n        Set<CmsResource> allPubRes = new HashSet<CmsResource>(pubResources.getRelatedResources());\n        allPubRes.addAll(pubResources.getResources());\n\n        List<CmsResource> pubList = new ArrayList<CmsResource>();\n        try {\n            pubList = OpenCms.getPublishManager().getUsersPubList(m_cms);\n        } catch (CmsException e) {\n            // should never happen\n            LOG.error(e.getLocalizedMessage(), e);\n        }\n\n        List<CmsPublishResource> publishResources = new ArrayList<CmsPublishResource>();\n        for (CmsResource resource : resourcesWithoutTempfiles) {\n            CmsPublishResource pubRes = createPublishResource(\n                resource,\n                pubList,\n                allPubRes,\n                published,\n                permissions,\n                locked);\n            publishResources.add(pubRes);\n        }\n\n        A_CmsPublishGroupHelper<CmsPublishResource, CmsPublishGroup> groupHelper = new CmsDefaultPublishGroupHelper(\n            m_workplaceLocale);\n        List<CmsPublishGroup> resultGroups = groupHelper.getGroups(publishResources);\n        return resultGroups;\n    }","commit_id":"28e97877ecaee792efe6130984857b39734b6b54","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/** \n     * Creates a new publish group bean.<p> \n     * \n     * @param id the resource id\n     * @param name the resource name\n     * @param title the resource title\n     * @param resourceType the resource type name\n     * @param state the resource state\n     * @param isFolder flag indicating if this resource is a folder\n     * @param removable to indicate if the resource can be removed from the user's publish list\n     * @param info the additional information, if any\n     * @param related the related resources\n     **/\n    public CmsPublishResource(\n        CmsUUID id,\n        String name,\n        String title,\n        String resourceType,\n        CmsResourceState state,\n        boolean isFolder,\n        boolean removable,\n        CmsPublishResourceInfo info,\n        List<CmsPublishResource> related) {\n\n        m_resourceType = resourceType;\n        m_id = id;\n        m_name = name;\n        m_isFolder = isFolder;\n        m_related = ((related == null) ? new ArrayList<CmsPublishResource>() : related);\n        m_state = state;\n        m_title = title;\n        m_removable = removable;\n        m_info = info;\n    }","id":24750,"modified_method":"/** \n     * Creates a new publish group bean.<p> \n     * \n     * @param id the resource id\n     * @param name the resource name\n     * @param title the resource title\n     * @param resourceType the resource type name\n     * @param state the resource state\n     * @param dateLastModified the last modification date \n     * @param isFolder flag indicating if this resource is a folder\n     * @param removable to indicate if the resource can be removed from the user's publish list\n     * @param info the additional information, if any\n     * @param related the related resources\n     **/\n    public CmsPublishResource(\n        CmsUUID id,\n        String name,\n        String title,\n        String resourceType,\n        CmsResourceState state,\n        long dateLastModified,\n        boolean isFolder,\n        boolean removable,\n        CmsPublishResourceInfo info,\n        List<CmsPublishResource> related) {\n\n        m_resourceType = resourceType;\n        m_id = id;\n        m_name = name;\n        m_isFolder = isFolder;\n        m_related = ((related == null) ? new ArrayList<CmsPublishResource>() : related);\n        m_state = state;\n        m_title = title;\n        m_removable = removable;\n        m_info = info;\n        m_dateLastModified = dateLastModified;\n    }","commit_id":"28e97877ecaee792efe6130984857b39734b6b54","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n   * Get the group memberships of a given user.\n   * @param user User's name\n   * @return the group memberships of the user\n   * @throws IOException\n   */\n  public List<String> getGroups(String user) throws IOException {\n    // Return cached value if available\n    CachedGroups groups = userToGroupsMap.get(user);\n    long now = Time.now();\n    // if cache has a value and it hasn't expired\n    if (groups != null && (groups.getTimestamp() + cacheTimeout > now)) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Returning cached groups for '\" + user + \"'\");\n      }\n      return groups.getGroups();\n    }\n    \n    // Create and cache user's groups\n    groups = new CachedGroups(impl.getGroups(user));\n    if (groups.getGroups().isEmpty()) {\n      throw new IOException(\"No groups found for user \" + user);\n    }\n    userToGroupsMap.put(user, groups);\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Returning fetched groups for '\" + user + \"'\");\n    }\n    return groups.getGroups();\n  }","id":24751,"modified_method":"/**\n   * Get the group memberships of a given user.\n   * @param user User's name\n   * @return the group memberships of the user\n   * @throws IOException\n   */\n  public List<String> getGroups(String user) throws IOException {\n    // Return cached value if available\n    CachedGroups groups = userToGroupsMap.get(user);\n    long startMs = Time.monotonicNow();\n    // if cache has a value and it hasn't expired\n    if (groups != null && (groups.getTimestamp() + cacheTimeout > startMs)) {\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(\"Returning cached groups for '\" + user + \"'\");\n      }\n      return groups.getGroups();\n    }\n\n    // Create and cache user's groups\n    List<String> groupList = impl.getGroups(user);\n    long endMs = Time.monotonicNow();\n    long deltaMs = endMs - startMs ;\n    if (deltaMs > warningDeltaMs) {\n      LOG.warn(\"Potential performance problem: getGroups(user=\" + user +\") \" +\n          \"took \" + deltaMs + \" milliseconds.\");\n    }\n    groups = new CachedGroups(groupList, endMs);\n    if (groups.getGroups().isEmpty()) {\n      throw new IOException(\"No groups found for user \" + user);\n    }\n    userToGroupsMap.put(user, groups);\n    if(LOG.isDebugEnabled()) {\n      LOG.debug(\"Returning fetched groups for '\" + user + \"'\");\n    }\n    return groups.getGroups();\n  }","commit_id":"b7aca6bd909eb3033e8b614de8275f9246ca44bc","url":"https://github.com/apache/hadoop"},{"original_method":"public Groups(Configuration conf) {\n    impl = \n      ReflectionUtils.newInstance(\n          conf.getClass(CommonConfigurationKeys.HADOOP_SECURITY_GROUP_MAPPING, \n                        ShellBasedUnixGroupsMapping.class, \n                        GroupMappingServiceProvider.class), \n          conf);\n    \n    cacheTimeout = \n      conf.getLong(CommonConfigurationKeys.HADOOP_SECURITY_GROUPS_CACHE_SECS, 5*60) * 1000;\n    \n    if(LOG.isDebugEnabled())\n      LOG.debug(\"Group mapping impl=\" + impl.getClass().getName() + \n          \"; cacheTimeout=\" + cacheTimeout);\n  }","id":24752,"modified_method":"public Groups(Configuration conf) {\n    impl = \n      ReflectionUtils.newInstance(\n          conf.getClass(CommonConfigurationKeys.HADOOP_SECURITY_GROUP_MAPPING, \n                        ShellBasedUnixGroupsMapping.class, \n                        GroupMappingServiceProvider.class), \n          conf);\n    \n    cacheTimeout = \n      conf.getLong(CommonConfigurationKeys.HADOOP_SECURITY_GROUPS_CACHE_SECS, \n          CommonConfigurationKeys.HADOOP_SECURITY_GROUPS_CACHE_SECS_DEFAULT) * 1000;\n    warningDeltaMs =\n      conf.getLong(CommonConfigurationKeys.HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS,\n        CommonConfigurationKeys.HADOOP_SECURITY_GROUPS_CACHE_WARN_AFTER_MS_DEFAULT);\n    \n    if(LOG.isDebugEnabled())\n      LOG.debug(\"Group mapping impl=\" + impl.getClass().getName() + \n          \"; cacheTimeout=\" + cacheTimeout + \"; warningDeltaMs=\" +\n          warningDeltaMs);\n  }","commit_id":"b7aca6bd909eb3033e8b614de8275f9246ca44bc","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * Create and initialize group cache\n     */\n    CachedGroups(List<String> groups) {\n      this.groups = groups;\n      this.timestamp = Time.now();\n    }","id":24753,"modified_method":"/**\n     * Create and initialize group cache\n     */\n    CachedGroups(List<String> groups, long timestamp) {\n      this.groups = groups;\n      this.timestamp = timestamp;\n    }","commit_id":"b7aca6bd909eb3033e8b614de8275f9246ca44bc","url":"https://github.com/apache/hadoop"},{"original_method":"protected void importFromLDAPByGroup(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.getGroups(\n\t\t\tldapServerId, companyId, ldapContext, 0);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\ttry {\n\t\t\t\tAttributes attributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, searchResult),\n\t\t\t\t\ttrue);\n\n\t\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\t\tcompanyId, attributes, groupMappings);\n\n\t\t\t\tAttribute usersAttribute = getUsers(\n\t\t\t\t\tldapServerId, companyId, ldapContext, attributes, userGroup,\n\t\t\t\t\tgroupMappings);\n\n\t\t\t\tif (usersAttribute == null) {\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\"No users found in \" + userGroup.getName());\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\timportUsers(\n\t\t\t\t\tldapServerId, companyId, ldapContext, userMappings,\n\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\tcontactExpandoMappings, userGroup.getUserGroupId(),\n\t\t\t\t\tusersAttribute);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to import group \" + searchResult, e);\n\t\t\t}\n\t\t}\n\t}","id":24754,"modified_method":"protected void importFromLDAPByGroup(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tcookie = PortalLDAPUtil.getGroups(\n\t\t\t\tldapServerId, companyId, ldapContext, cookie, 0, searchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\ttry {\n\t\t\t\t\tAttributes attributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\t\tldapServerId, companyId, searchResult),\n\t\t\t\t\t\ttrue);\n\n\t\t\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\t\t\tcompanyId, attributes, groupMappings);\n\n\t\t\t\t\tAttribute usersAttribute = getUsers(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, attributes,\n\t\t\t\t\t\tuserGroup, groupMappings);\n\n\t\t\t\t\tif (usersAttribute == null) {\n\t\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\t\t\"No users found in \" + userGroup.getName());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\timportUsers(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, userMappings,\n\t\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\t\tcontactExpandoMappings, userGroup.getUserGroupId(),\n\t\t\t\t\t\tusersAttribute);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(\"Unable to import group \" + searchResult, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importFromLDAPByUser(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.getUsers(\n\t\t\tldapServerId, companyId, ldapContext, 0);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\ttry {\n\t\t\t\tAttributes userAttributes = PortalLDAPUtil.getUserAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, searchResult));\n\n\t\t\t\tUser user = importUser(\n\t\t\t\t\tcompanyId, userAttributes, userMappings,\n\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\tcontactExpandoMappings, StringPool.BLANK);\n\n\t\t\t\timportGroups(\n\t\t\t\t\tldapServerId, companyId, ldapContext, userAttributes, user,\n\t\t\t\t\tuserMappings, groupMappings);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to import user \" + searchResult, e);\n\t\t\t}\n\t\t}\n\t}","id":24755,"modified_method":"protected void importFromLDAPByUser(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tcookie = PortalLDAPUtil.getUsers(\n\t\t\t\tldapServerId, companyId, ldapContext, cookie, 0, searchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\ttry {\n\t\t\t\t\tAttributes userAttributes = PortalLDAPUtil.getUserAttributes(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\t\tldapServerId, companyId, searchResult));\n\n\t\t\t\t\tUser user = importUser(\n\t\t\t\t\t\tcompanyId, userAttributes, userMappings,\n\t\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\t\tcontactExpandoMappings, StringPool.BLANK);\n\n\t\t\t\t\timportGroups(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, userAttributes, user,\n\t\t\t\t\t\tuserMappings, groupMappings);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(\"Unable to import user \" + searchResult, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tAttributes attributes, User user, Properties userMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tString userMappingsGroup = userMappings.getProperty(\"group\");\n\n\t\tif (Validator.isNull(userMappingsGroup)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAttribute attribute = attributes.get(userMappingsGroup);\n\n\t\tif (attribute == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tattribute.clear();\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\tldapServerId, companyId, user.getScreenName());\n\n\t\tString fullUserDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\tldapServerId, companyId, binding);\n\n\t\tStringBundler sb = new StringBundler(9);\n\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(StringPool.AMPERSAND);\n\t\tsb.append(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix));\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(groupMappings.getProperty(\"user\"));\n\t\tsb.append(StringPool.EQUAL);\n\t\tsb.append(fullUserDN);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.searchLDAP(\n\t\t\tcompanyId, ldapContext, 0, baseDN, sb.toString(), null);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\tString fullGroupDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\tldapServerId, companyId, searchResult);\n\n\t\t\tattribute.add(fullGroupDN);\n\t\t}\n\n\t\tList<Long> newUserGroupIds = new ArrayList<Long>(attribute.size());\n\n\t\tfor (int i = 0; i < attribute.size(); i++) {\n\t\t\tString fullGroupDN = (String) attribute.get(i);\n\n\t\t\tAttributes groupAttributes = null;\n\n\t\t\ttry {\n\t\t\t\tgroupAttributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN);\n\t\t\t}\n\t\t\tcatch (NameNotFoundException nnfe) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"LDAP group not found with fullGroupDN \" + fullGroupDN,\n\t\t\t\t\tnnfe);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\tcompanyId, groupAttributes, groupMappings);\n\n\t\t\tif (userGroup != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Adding \" + user.getUserId() + \" to group \" +\n\t\t\t\t\t\t\tuserGroup.getUserGroupId());\n\t\t\t\t}\n\n\t\t\t\tnewUserGroupIds.add(userGroup.getUserGroupId());\n\t\t\t}\n\t\t}\n\n\t\tUserGroupLocalServiceUtil.setUserUserGroups(\n\t\t\tuser.getUserId(),\n\t\t\tArrayUtil.toArray(\n\t\t\t\tnewUserGroupIds.toArray(new Long[newUserGroupIds.size()])));\n\t}","id":24756,"modified_method":"protected void importGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tAttributes attributes, User user, Properties userMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tString userMappingsGroup = userMappings.getProperty(\"group\");\n\n\t\tif (Validator.isNull(userMappingsGroup)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAttribute attribute = attributes.get(userMappingsGroup);\n\n\t\tif (attribute == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tattribute.clear();\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\tldapServerId, companyId, user.getScreenName());\n\n\t\tString fullUserDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\tldapServerId, companyId, binding);\n\n\t\tStringBundler sb = new StringBundler(9);\n\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(StringPool.AMPERSAND);\n\t\tsb.append(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix));\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(groupMappings.getProperty(\"user\"));\n\t\tsb.append(StringPool.EQUAL);\n\t\tsb.append(fullUserDN);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tPortalLDAPUtil.searchLDAP(\n\t\t\t\tcompanyId, ldapContext, cookie, 0, baseDN, sb.toString(), null,\n\t\t\t\tsearchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\tString fullGroupDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\tldapServerId, companyId, searchResult);\n\n\t\t\t\tattribute.add(fullGroupDN);\n\t\t\t}\n\t\t}\n\n\t\tList<Long> newUserGroupIds = new ArrayList<Long>(attribute.size());\n\n\t\tfor (int i = 0; i < attribute.size(); i++) {\n\t\t\tString fullGroupDN = (String)attribute.get(i);\n\n\t\t\tAttributes groupAttributes = null;\n\n\t\t\ttry {\n\t\t\t\tgroupAttributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN);\n\t\t\t}\n\t\t\tcatch (NameNotFoundException nnfe) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"LDAP group not found with fullGroupDN \" + fullGroupDN,\n\t\t\t\t\tnnfe);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\tcompanyId, groupAttributes, groupMappings);\n\n\t\t\tif (userGroup != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Adding \" + user.getUserId() + \" to group \" +\n\t\t\t\t\t\t\tuserGroup.getUserGroupId());\n\t\t\t\t}\n\n\t\t\t\tnewUserGroupIds.add(userGroup.getUserGroupId());\n\t\t\t}\n\t\t}\n\n\t\tUserGroupLocalServiceUtil.setUserUserGroups(\n\t\t\tuser.getUserId(),\n\t\t\tArrayUtil.toArray(\n\t\t\t\tnewUserGroupIds.toArray(new Long[newUserGroupIds.size()])));\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> getUsers(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String userFilter)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, userFilter, null);\n\t}","id":24757,"modified_method":"public static byte[] getUsers(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String userFilter,\n\t\t\tList<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, userFilter,\n\t\t\tnull, searchResults);\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Attribute getMultivaluedAttribute(\n\t\t\tlong companyId, LdapContext ldapContext, String baseDN,\n\t\t\tString filter, Attribute attribute)\n\t\tthrows Exception {\n\n\t\tif (attribute.size() > 0) {\n\t\t\treturn attribute;\n\t\t}\n\n\t\tString[] attributeIds = {_getNextRange(attribute.getID())};\n\n\t\twhile (true) {\n\t\t\tList<SearchResult> searchResults = searchLDAP(\n\t\t\t\tcompanyId, ldapContext, 0, baseDN, filter, attributeIds);\n\n\t\t\tif (searchResults.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSearchResult searchResult = searchResults.get(0);\n\n\t\t\tAttributes attributes = searchResult.getAttributes();\n\n\t\t\tif (attributes.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNamingEnumeration<? extends Attribute> enu = attributes.getAll();\n\n\t\t\tif (!enu.hasMoreElements()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tAttribute curAttribute = enu.nextElement();\n\n\t\t\tfor (int i = 0; i < curAttribute.size(); i++) {\n\t\t\t\tattribute.add(curAttribute.get(i));\n\t\t\t}\n\n\t\t\tif (StringUtil.endsWith(curAttribute.getID(), StringPool.STAR) ||\n\t\t\t\t(curAttribute.size() < PropsValues.LDAP_RANGE_SIZE)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tattributeIds[0] = _getNextRange(attributeIds[0]);\n\t\t}\n\n\t\treturn attribute;\n\t}","id":24758,"modified_method":"public static Attribute getMultivaluedAttribute(\n\t\t\tlong companyId, LdapContext ldapContext, String baseDN,\n\t\t\tString filter, Attribute attribute)\n\t\tthrows Exception {\n\n\t\tif (attribute.size() > 0) {\n\t\t\treturn attribute;\n\t\t}\n\n\t\tString[] attributeIds = {_getNextRange(attribute.getID())};\n\n\t\twhile (true) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tsearchLDAP(\n\t\t\t\tcompanyId, ldapContext, new byte[0], 0, baseDN, filter,\n\t\t\t\tattributeIds, searchResults);\n\n\t\t\tif (searchResults.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSearchResult searchResult = searchResults.get(0);\n\n\t\t\tAttributes attributes = searchResult.getAttributes();\n\n\t\t\tif (attributes.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNamingEnumeration<? extends Attribute> enu = attributes.getAll();\n\n\t\t\tif (!enu.hasMoreElements()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tAttribute curAttribute = enu.nextElement();\n\n\t\t\tfor (int i = 0; i < curAttribute.size(); i++) {\n\t\t\t\tattribute.add(curAttribute.get(i));\n\t\t\t}\n\n\t\t\tif (StringUtil.endsWith(curAttribute.getID(), StringPool.STAR) ||\n\t\t\t\t(curAttribute.size() < PropsValues.LDAP_RANGE_SIZE)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tattributeIds[0] = _getNextRange(attributeIds[0]);\n\t\t}\n\n\t\treturn attribute;\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> getUsers(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tint maxResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString userFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_USER_SEARCH_FILTER + postfix);\n\n\t\treturn getUsers(companyId, ldapContext, maxResults, baseDN, userFilter);\n\t}","id":24759,"modified_method":"public static byte[] getUsers(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tbyte[] cookie, int maxResults, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString userFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_USER_SEARCH_FILTER + postfix);\n\n\t\treturn getUsers(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, userFilter,\n\t\t\tsearchResults);\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> searchLDAP(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String filter, String[] attributeIds)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\tSearchControls searchControls = new SearchControls(\n\t\t\tSearchControls.SUBTREE_SCOPE, maxResults, 0, attributeIds, false,\n\t\t\tfalse);\n\n\t\ttry {\n\t\t\tbyte[] cookie = new byte[0];\n\n\t\t\twhile (cookie != null) {\n\t\t\t\tif (cookie.length == 0) {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, Control.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, cookie,\n\t\t\t\t\t\t\t\tControl.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t\t}\n\n\t\t\t\tenu.close();\n\n\t\t\t\tcookie = _getCookie(ldapContext.getResponseControls());\n\t\t\t}\n\t\t}\n\t\tcatch (OperationNotSupportedException onse) {\n\t\t\tldapContext.setRequestControls(null);\n\n\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t}\n\n\t\t\tenu.close();\n\t\t}\n\t\tfinally {\n\t\t\tldapContext.setRequestControls(null);\n\t\t}\n\n\t\treturn searchResults;\n\t}","id":24760,"modified_method":"public static byte[] searchLDAP(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String filter,\n\t\t\tString[] attributeIds, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tSearchControls searchControls = new SearchControls(\n\t\t\tSearchControls.SUBTREE_SCOPE, maxResults, 0, attributeIds, false,\n\t\t\tfalse);\n\n\t\ttry {\n\t\t\tif (cookie != null) {\n\t\t\t\tif (cookie.length == 0) {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, Control.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, cookie,\n\t\t\t\t\t\t\t\tControl.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t\t}\n\n\t\t\t\tenu.close();\n\n\t\t\t\treturn _getCookie(ldapContext.getResponseControls());\n\t\t\t}\n\t\t}\n\t\tcatch (OperationNotSupportedException onse) {\n\t\t\tldapContext.setRequestControls(null);\n\n\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t}\n\n\t\t\tenu.close();\n\t\t}\n\t\tfinally {\n\t\t\tldapContext.setRequestControls(null);\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> getGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tint maxResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString groupFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix);\n\n\t\treturn getGroups(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, groupFilter);\n\t}","id":24761,"modified_method":"public static byte[] getGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tbyte[] cookie, int maxResults, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString groupFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix);\n\n\t\treturn getGroups(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, groupFilter,\n\t\t\tsearchResults);\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> getGroups(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String groupFilter)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, groupFilter, null);\n\t}","id":24762,"modified_method":"public static byte[] getGroups(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String groupFilter,\n\t\t\tList<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, groupFilter,\n\t\t\tnull, searchResults);\n\t}","commit_id":"348706e660a9dc001d538c9bed1224e6fc5b4942","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importFromLDAPByGroup(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.getGroups(\n\t\t\tldapServerId, companyId, ldapContext, 0);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\ttry {\n\t\t\t\tAttributes attributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, searchResult),\n\t\t\t\t\ttrue);\n\n\t\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\t\tcompanyId, attributes, groupMappings);\n\n\t\t\t\tAttribute usersAttribute = getUsers(\n\t\t\t\t\tldapServerId, companyId, ldapContext, attributes, userGroup,\n\t\t\t\t\tgroupMappings);\n\n\t\t\t\tif (usersAttribute == null) {\n\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t_log.info(\"No users found in \" + userGroup.getName());\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\timportUsers(\n\t\t\t\t\tldapServerId, companyId, ldapContext, userMappings,\n\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\tcontactExpandoMappings, userGroup.getUserGroupId(),\n\t\t\t\t\tusersAttribute);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to import group \" + searchResult, e);\n\t\t\t}\n\t\t}\n\t}","id":24763,"modified_method":"protected void importFromLDAPByGroup(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tcookie = PortalLDAPUtil.getGroups(\n\t\t\t\tldapServerId, companyId, ldapContext, cookie, 0, searchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\ttry {\n\t\t\t\t\tAttributes attributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\t\tldapServerId, companyId, searchResult),\n\t\t\t\t\t\ttrue);\n\n\t\t\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\t\t\tcompanyId, attributes, groupMappings);\n\n\t\t\t\t\tAttribute usersAttribute = getUsers(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, attributes,\n\t\t\t\t\t\tuserGroup, groupMappings);\n\n\t\t\t\t\tif (usersAttribute == null) {\n\t\t\t\t\t\tif (_log.isInfoEnabled()) {\n\t\t\t\t\t\t\t_log.info(\n\t\t\t\t\t\t\t\t\"No users found in \" + userGroup.getName());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\timportUsers(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, userMappings,\n\t\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\t\tcontactExpandoMappings, userGroup.getUserGroupId(),\n\t\t\t\t\t\tusersAttribute);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(\"Unable to import group \" + searchResult, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importFromLDAPByUser(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.getUsers(\n\t\t\tldapServerId, companyId, ldapContext, 0);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\ttry {\n\t\t\t\tAttributes userAttributes = PortalLDAPUtil.getUserAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\tldapServerId, companyId, searchResult));\n\n\t\t\t\tUser user = importUser(\n\t\t\t\t\tcompanyId, userAttributes, userMappings,\n\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\tcontactExpandoMappings, StringPool.BLANK);\n\n\t\t\t\timportGroups(\n\t\t\t\t\tldapServerId, companyId, ldapContext, userAttributes, user,\n\t\t\t\t\tuserMappings, groupMappings);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to import user \" + searchResult, e);\n\t\t\t}\n\t\t}\n\t}","id":24764,"modified_method":"protected void importFromLDAPByUser(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tProperties userMappings, Properties userExpandoMappings,\n\t\t\tProperties contactMappings, Properties contactExpandoMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tcookie = PortalLDAPUtil.getUsers(\n\t\t\t\tldapServerId, companyId, ldapContext, cookie, 0, searchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\ttry {\n\t\t\t\t\tAttributes userAttributes = PortalLDAPUtil.getUserAttributes(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext,\n\t\t\t\t\t\tPortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\t\t\tldapServerId, companyId, searchResult));\n\n\t\t\t\t\tUser user = importUser(\n\t\t\t\t\t\tcompanyId, userAttributes, userMappings,\n\t\t\t\t\t\tuserExpandoMappings, contactMappings,\n\t\t\t\t\t\tcontactExpandoMappings, StringPool.BLANK);\n\n\t\t\t\t\timportGroups(\n\t\t\t\t\t\tldapServerId, companyId, ldapContext, userAttributes, user,\n\t\t\t\t\t\tuserMappings, groupMappings);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t_log.error(\"Unable to import user \" + searchResult, e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tAttributes attributes, User user, Properties userMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tString userMappingsGroup = userMappings.getProperty(\"group\");\n\n\t\tif (Validator.isNull(userMappingsGroup)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAttribute attribute = attributes.get(userMappingsGroup);\n\n\t\tif (attribute == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tattribute.clear();\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\tldapServerId, companyId, user.getScreenName());\n\n\t\tString fullUserDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\tldapServerId, companyId, binding);\n\n\t\tStringBundler sb = new StringBundler(9);\n\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(StringPool.AMPERSAND);\n\t\tsb.append(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix));\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(groupMappings.getProperty(\"user\"));\n\t\tsb.append(StringPool.EQUAL);\n\t\tsb.append(fullUserDN);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\tList<SearchResult> searchResults = PortalLDAPUtil.searchLDAP(\n\t\t\tcompanyId, ldapContext, 0, baseDN, sb.toString(), null);\n\n\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\tString fullGroupDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\tldapServerId, companyId, searchResult);\n\n\t\t\tattribute.add(fullGroupDN);\n\t\t}\n\n\t\tList<Long> newUserGroupIds = new ArrayList<Long>(attribute.size());\n\n\t\tfor (int i = 0; i < attribute.size(); i++) {\n\t\t\tString fullGroupDN = (String) attribute.get(i);\n\n\t\t\tAttributes groupAttributes = null;\n\n\t\t\ttry {\n\t\t\t\tgroupAttributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN);\n\t\t\t}\n\t\t\tcatch (NameNotFoundException nnfe) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"LDAP group not found with fullGroupDN \" + fullGroupDN,\n\t\t\t\t\tnnfe);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\tcompanyId, groupAttributes, groupMappings);\n\n\t\t\tif (userGroup != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Adding \" + user.getUserId() + \" to group \" +\n\t\t\t\t\t\t\tuserGroup.getUserGroupId());\n\t\t\t\t}\n\n\t\t\t\tnewUserGroupIds.add(userGroup.getUserGroupId());\n\t\t\t}\n\t\t}\n\n\t\tUserGroupLocalServiceUtil.setUserUserGroups(\n\t\t\tuser.getUserId(),\n\t\t\tArrayUtil.toArray(\n\t\t\t\tnewUserGroupIds.toArray(new Long[newUserGroupIds.size()])));\n\t}","id":24765,"modified_method":"protected void importGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tAttributes attributes, User user, Properties userMappings,\n\t\t\tProperties groupMappings)\n\t\tthrows Exception {\n\n\t\tString userMappingsGroup = userMappings.getProperty(\"group\");\n\n\t\tif (Validator.isNull(userMappingsGroup)) {\n\t\t\treturn;\n\t\t}\n\n\t\tAttribute attribute = attributes.get(userMappingsGroup);\n\n\t\tif (attribute == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tattribute.clear();\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\n\t\tBinding binding = PortalLDAPUtil.getUser(\n\t\t\tldapServerId, companyId, user.getScreenName());\n\n\t\tString fullUserDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\tldapServerId, companyId, binding);\n\n\t\tStringBundler sb = new StringBundler(9);\n\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(StringPool.AMPERSAND);\n\t\tsb.append(\n\t\t\tPrefsPropsUtil.getString(\n\t\t\t\tcompanyId,\n\t\t\t\tPropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix));\n\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\tsb.append(groupMappings.getProperty(\"user\"));\n\t\tsb.append(StringPool.EQUAL);\n\t\tsb.append(fullUserDN);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\tbyte[] cookie = new byte[0];\n\n\t\twhile (cookie != null) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tPortalLDAPUtil.searchLDAP(\n\t\t\t\tcompanyId, ldapContext, cookie, 0, baseDN, sb.toString(), null,\n\t\t\t\tsearchResults);\n\n\t\t\tfor (SearchResult searchResult : searchResults) {\n\t\t\t\tString fullGroupDN = PortalLDAPUtil.getNameInNamespace(\n\t\t\t\t\tldapServerId, companyId, searchResult);\n\n\t\t\t\tattribute.add(fullGroupDN);\n\t\t\t}\n\t\t}\n\n\t\tList<Long> newUserGroupIds = new ArrayList<Long>(attribute.size());\n\n\t\tfor (int i = 0; i < attribute.size(); i++) {\n\t\t\tString fullGroupDN = (String)attribute.get(i);\n\n\t\t\tAttributes groupAttributes = null;\n\n\t\t\ttry {\n\t\t\t\tgroupAttributes = PortalLDAPUtil.getGroupAttributes(\n\t\t\t\t\tldapServerId, companyId, ldapContext, fullGroupDN);\n\t\t\t}\n\t\t\tcatch (NameNotFoundException nnfe) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"LDAP group not found with fullGroupDN \" + fullGroupDN,\n\t\t\t\t\tnnfe);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tUserGroup userGroup = importUserGroup(\n\t\t\t\tcompanyId, groupAttributes, groupMappings);\n\n\t\t\tif (userGroup != null) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Adding \" + user.getUserId() + \" to group \" +\n\t\t\t\t\t\t\tuserGroup.getUserGroupId());\n\t\t\t\t}\n\n\t\t\t\tnewUserGroupIds.add(userGroup.getUserGroupId());\n\t\t\t}\n\t\t}\n\n\t\tUserGroupLocalServiceUtil.setUserUserGroups(\n\t\t\tuser.getUserId(),\n\t\t\tArrayUtil.toArray(\n\t\t\t\tnewUserGroupIds.toArray(new Long[newUserGroupIds.size()])));\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> getUsers(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String userFilter)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, userFilter, null);\n\t}","id":24766,"modified_method":"public static byte[] getUsers(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String userFilter,\n\t\t\tList<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, userFilter,\n\t\t\tnull, searchResults);\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Attribute getMultivaluedAttribute(\n\t\t\tlong companyId, LdapContext ldapContext, String baseDN,\n\t\t\tString filter, Attribute attribute)\n\t\tthrows Exception {\n\n\t\tif (attribute.size() > 0) {\n\t\t\treturn attribute;\n\t\t}\n\n\t\tString[] attributeIds = {_getNextRange(attribute.getID())};\n\n\t\twhile (true) {\n\t\t\tList<SearchResult> searchResults = searchLDAP(\n\t\t\t\tcompanyId, ldapContext, 0, baseDN, filter, attributeIds);\n\n\t\t\tif (searchResults.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSearchResult searchResult = searchResults.get(0);\n\n\t\t\tAttributes attributes = searchResult.getAttributes();\n\n\t\t\tif (attributes.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNamingEnumeration<? extends Attribute> enu = attributes.getAll();\n\n\t\t\tif (!enu.hasMoreElements()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tAttribute curAttribute = enu.nextElement();\n\n\t\t\tfor (int i = 0; i < curAttribute.size(); i++) {\n\t\t\t\tattribute.add(curAttribute.get(i));\n\t\t\t}\n\n\t\t\tif (StringUtil.endsWith(curAttribute.getID(), StringPool.STAR) ||\n\t\t\t\t(curAttribute.size() < PropsValues.LDAP_RANGE_SIZE)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tattributeIds[0] = _getNextRange(attributeIds[0]);\n\t\t}\n\n\t\treturn attribute;\n\t}","id":24767,"modified_method":"public static Attribute getMultivaluedAttribute(\n\t\t\tlong companyId, LdapContext ldapContext, String baseDN,\n\t\t\tString filter, Attribute attribute)\n\t\tthrows Exception {\n\n\t\tif (attribute.size() > 0) {\n\t\t\treturn attribute;\n\t\t}\n\n\t\tString[] attributeIds = {_getNextRange(attribute.getID())};\n\n\t\twhile (true) {\n\t\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\t\tsearchLDAP(\n\t\t\t\tcompanyId, ldapContext, new byte[0], 0, baseDN, filter,\n\t\t\t\tattributeIds, searchResults);\n\n\t\t\tif (searchResults.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tSearchResult searchResult = searchResults.get(0);\n\n\t\t\tAttributes attributes = searchResult.getAttributes();\n\n\t\t\tif (attributes.size() != 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tNamingEnumeration<? extends Attribute> enu = attributes.getAll();\n\n\t\t\tif (!enu.hasMoreElements()) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tAttribute curAttribute = enu.nextElement();\n\n\t\t\tfor (int i = 0; i < curAttribute.size(); i++) {\n\t\t\t\tattribute.add(curAttribute.get(i));\n\t\t\t}\n\n\t\t\tif (StringUtil.endsWith(curAttribute.getID(), StringPool.STAR) ||\n\t\t\t\t(curAttribute.size() < PropsValues.LDAP_RANGE_SIZE)) {\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tattributeIds[0] = _getNextRange(attributeIds[0]);\n\t\t}\n\n\t\treturn attribute;\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> getGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tint maxResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString groupFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix);\n\n\t\treturn getGroups(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, groupFilter);\n\t}","id":24768,"modified_method":"public static byte[] getGroups(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tbyte[] cookie, int maxResults, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString groupFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_GROUP_SEARCH_FILTER + postfix);\n\n\t\treturn getGroups(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, groupFilter,\n\t\t\tsearchResults);\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> getGroups(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String groupFilter)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, maxResults, baseDN, groupFilter, null);\n\t}","id":24769,"modified_method":"public static byte[] getGroups(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String groupFilter,\n\t\t\tList<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\treturn searchLDAP(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, groupFilter,\n\t\t\tnull, searchResults);\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> searchLDAP(\n\t\t\tlong companyId, LdapContext ldapContext, int maxResults,\n\t\t\tString baseDN, String filter, String[] attributeIds)\n\t\tthrows Exception {\n\n\t\tList<SearchResult> searchResults = new ArrayList<SearchResult>();\n\n\t\tSearchControls searchControls = new SearchControls(\n\t\t\tSearchControls.SUBTREE_SCOPE, maxResults, 0, attributeIds, false,\n\t\t\tfalse);\n\n\t\ttry {\n\t\t\tbyte[] cookie = new byte[0];\n\n\t\t\twhile (cookie != null) {\n\t\t\t\tif (cookie.length == 0) {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, Control.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, cookie,\n\t\t\t\t\t\t\t\tControl.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t\t}\n\n\t\t\t\tenu.close();\n\n\t\t\t\tcookie = _getCookie(ldapContext.getResponseControls());\n\t\t\t}\n\t\t}\n\t\tcatch (OperationNotSupportedException onse) {\n\t\t\tldapContext.setRequestControls(null);\n\n\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t}\n\n\t\t\tenu.close();\n\t\t}\n\t\tfinally {\n\t\t\tldapContext.setRequestControls(null);\n\t\t}\n\n\t\treturn searchResults;\n\t}","id":24770,"modified_method":"public static byte[] searchLDAP(\n\t\t\tlong companyId, LdapContext ldapContext, byte[] cookie,\n\t\t\tint maxResults, String baseDN, String filter,\n\t\t\tString[] attributeIds, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tSearchControls searchControls = new SearchControls(\n\t\t\tSearchControls.SUBTREE_SCOPE, maxResults, 0, attributeIds, false,\n\t\t\tfalse);\n\n\t\ttry {\n\t\t\tif (cookie != null) {\n\t\t\t\tif (cookie.length == 0) {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, Control.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tldapContext.setRequestControls(\n\t\t\t\t\t\tnew Control[] {\n\t\t\t\t\t\t\tnew PagedResultsControl(\n\t\t\t\t\t\t\t\tPropsValues.LDAP_PAGE_SIZE, cookie,\n\t\t\t\t\t\t\t\tControl.CRITICAL)\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t\t}\n\n\t\t\t\tenu.close();\n\n\t\t\t\treturn _getCookie(ldapContext.getResponseControls());\n\t\t\t}\n\t\t}\n\t\tcatch (OperationNotSupportedException onse) {\n\t\t\tldapContext.setRequestControls(null);\n\n\t\t\tNamingEnumeration<SearchResult> enu = ldapContext.search(\n\t\t\t\tbaseDN, filter, searchControls);\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tsearchResults.add(enu.nextElement());\n\t\t\t}\n\n\t\t\tenu.close();\n\t\t}\n\t\tfinally {\n\t\t\tldapContext.setRequestControls(null);\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static List<SearchResult> getUsers(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tint maxResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString userFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_USER_SEARCH_FILTER + postfix);\n\n\t\treturn getUsers(companyId, ldapContext, maxResults, baseDN, userFilter);\n\t}","id":24771,"modified_method":"public static byte[] getUsers(\n\t\t\tlong ldapServerId, long companyId, LdapContext ldapContext,\n\t\t\tbyte[] cookie, int maxResults, List<SearchResult> searchResults)\n\t\tthrows Exception {\n\n\t\tString postfix = LDAPSettingsUtil.getPropertyPostfix(ldapServerId);\n\n\t\tString baseDN = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_BASE_DN + postfix);\n\t\tString userFilter = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.LDAP_IMPORT_USER_SEARCH_FILTER + postfix);\n\n\t\treturn getUsers(\n\t\t\tcompanyId, ldapContext, cookie, maxResults, baseDN, userFilter,\n\t\t\tsearchResults);\n\t}","commit_id":"138bfc89f61204c4975642d1993391cd92cddc6e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    protected String getQueueForApp(String requestedQueue, String user,\n        Groups groups, Map<FSQueueType, Set<String>> configuredQueues)\n        throws IOException {\n      return \"root.\" + cleanName(groups.getGroups(user).get(0));\n    }","id":24772,"modified_method":"@Override\n    protected String getQueueForApp(String requestedQueue, String user,\n        Groups groups, Map<FSQueueType, Set<String>> configuredQueues)\n        throws IOException {\n      final List<String> groupList = groups.getGroups(user);\n      if (groupList.isEmpty()) {\n        throw new IOException(\"No groups returned for user \" + user);\n      }\n      return \"root.\" + cleanName(groupList.get(0));\n    }","commit_id":"8f195387a4a4a5a278119bf4c2f15cad61f0e2c7","url":"https://github.com/apache/hadoop"},{"original_method":"public void getDDLForOther() {\r\n\r\n\t\tif (databases != null) {\r\n\t\t\tDatabase db = new Database(null, this.model.getDatabaseMeta());\r\n\t\t\ttry {\r\n\t\t\t\tdb.connect();\r\n\r\n\t\t\t\tRowMetaInterface r = db.getTableFields(this.model.getTable());\r\n\r\n\t\t\t\t// Now select the other connection...\r\n\r\n\t\t\t\t// Only take non-SAP R/3 connections....\r\n\t\t\t\tList<DatabaseMeta> dbs = new ArrayList<DatabaseMeta>();\r\n\t\t\t\tfor (int i = 0; i < databases.size(); i++) {\r\n\t\t\t\t\tif (((databases.get(i)).getDatabaseInterface().isExplorable())) {\r\n\t\t\t\t\t\tdbs.add(databases.get(i));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tString conn[] = new String[dbs.size()];\r\n\t\t\t\tfor (int i = 0; i < conn.length; i++)\r\n\t\t\t\t\tconn[i] = (dbs.get(i)).getName();\r\n\r\n\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(this.dbExplorerDialog.getShell(), conn, BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.TargetDatabase.Title\"), BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.TargetDatabase.Message\"));\r\n\t\t\t\tString target = esd.open();\r\n\t\t\t\tif (target != null) {\r\n\t\t\t\t\tDatabaseMeta targetdbi = DatabaseMeta.findDatabase(dbs, target);\r\n\t\t\t\t\tDatabase targetdb = new Database(null, targetdbi);\r\n\r\n\t\t\t\t\tString sql = targetdb.getCreateTableStatement(this.model.getTable(), r, null, false, null, true);\r\n\t\t\t\t\tSQLEditor se = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, sql);\r\n\t\t\t\t\tse.open();\r\n\t\t\t\t}\r\n\t\t\t} catch (KettleDatabaseException dbe) {\r\n\t\t\t\tnew ErrorDialog(this.dbExplorerDialog.getShell(), BaseMessages.getString(PKG, \"Dialog.Error.Header\"), BaseMessages.getString(PKG, \"DatabaseExplorerDialog.Error.GenDDL\"), dbe);\r\n\t\t\t} finally {\r\n\t\t\t\tdb.disconnect();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tMessageBox mb = new MessageBox(this.dbExplorerDialog.getShell(), SWT.NONE | SWT.ICON_INFORMATION);\r\n\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"DatabaseExplorerDialog.NoConnectionsKnown.Message\"));\r\n\t\t\tmb.setText(BaseMessages.getString(PKG, \"DatabaseExplorerDialog.NoConnectionsKnown.Title\"));\r\n\t\t\tmb.open();\r\n\t\t}\r\n\t}","id":24773,"modified_method":"public void getDDLForOther() {\r\n\r\n\t\tif (databases != null) {\r\n\t\t\tDatabase db = new Database(null, this.model.getDatabaseMeta());\r\n\t\t\ttry {\r\n\t\t\t\tdb.connect();\r\n\r\n\t\t\t\tRowMetaInterface r = db.getTableFields(this.model.getTable().getName());\r\n\r\n\t\t\t\t// Now select the other connection...\r\n\r\n\t\t\t\t// Only take non-SAP R/3 connections....\r\n\t\t\t\tList<DatabaseMeta> dbs = new ArrayList<DatabaseMeta>();\r\n\t\t\t\tfor (int i = 0; i < databases.size(); i++) {\r\n\t\t\t\t\tif (((databases.get(i)).getDatabaseInterface().isExplorable())) {\r\n\t\t\t\t\t\tdbs.add(databases.get(i));\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tString conn[] = new String[dbs.size()];\r\n\t\t\t\tfor (int i = 0; i < conn.length; i++)\r\n\t\t\t\t\tconn[i] = (dbs.get(i)).getName();\r\n\r\n\t\t\t\tEnterSelectionDialog esd = new EnterSelectionDialog(this.dbExplorerDialog.getShell(), conn, BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.TargetDatabase.Title\"), BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.TargetDatabase.Message\"));\r\n\t\t\t\tString target = esd.open();\r\n\t\t\t\tif (target != null) {\r\n\t\t\t\t\tDatabaseMeta targetdbi = DatabaseMeta.findDatabase(dbs, target);\r\n\t\t\t\t\tDatabase targetdb = new Database(null, targetdbi);\r\n\r\n\t\t\t\t\tString sql = targetdb.getCreateTableStatement(this.model.getTable().getName(), r, null, false, null, true);\r\n\t\t\t\t\tSQLEditor se = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, sql);\r\n\t\t\t\t\tse.open();\r\n\t\t\t\t}\r\n\t\t\t} catch (KettleDatabaseException dbe) {\r\n\t\t\t\tnew ErrorDialog(this.dbExplorerDialog.getShell(), BaseMessages.getString(PKG, \"Dialog.Error.Header\"), BaseMessages.getString(PKG, \"DatabaseExplorerDialog.Error.GenDDL\"), dbe);\r\n\t\t\t} finally {\r\n\t\t\t\tdb.disconnect();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tMessageBox mb = new MessageBox(this.dbExplorerDialog.getShell(), SWT.NONE | SWT.ICON_INFORMATION);\r\n\t\t\tmb.setMessage(BaseMessages.getString(PKG, \"DatabaseExplorerDialog.NoConnectionsKnown.Message\"));\r\n\t\t\tmb.setText(BaseMessages.getString(PKG, \"DatabaseExplorerDialog.NoConnectionsKnown.Title\"));\r\n\t\t\tmb.open();\r\n\t\t}\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getSelectedSchema() {\r\n\t\treturn this.model.getSchema();\r\n\t}","id":24774,"modified_method":"public String getSelectedSchema() {\r\n\t\treturn (model.getSchema() != null)? model.getSchema().getName() : null;\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void createDatabaseNodes() {\r\n\t\ttry {\r\n\t\t\tDatabase theDatabase = new Database(null, this.model.getDatabaseMeta());\r\n\t\t\ttheDatabase.connect();\r\n\r\n\t\t\t// Adds the main database node.\r\n\t\t\tDatabaseExplorerNode theDatabaseNode = new DatabaseExplorerNode();\r\n\t\t\ttheDatabaseNode.setName(this.model.getDatabaseMeta().getName());\r\n\t\t\ttheDatabaseNode.setImage(DATABASE_IMAGE);\r\n\t\t\tthis.model.getDatabase().add(theDatabaseNode);\r\n\t\t\t\r\n\t\t\t// Adds the Schema database node.\r\n\t\t\tDatabaseExplorerNode theSchemasNode = new DatabaseExplorerNode();\r\n\t\t\ttheSchemasNode.setName(STRING_SCHEMAS);\r\n\t\t\ttheSchemasNode.setImage(FOLDER_IMAGE);\r\n\t\t\ttheDatabaseNode.addChild(theSchemasNode);\r\n\r\n\t\t\t// Adds the Tables database node.\r\n\t\t\tDatabaseExplorerNode theTablesNode = new DatabaseExplorerNode();\r\n\t\t\ttheTablesNode.setName(STRING_TABLES);\r\n\t\t\ttheTablesNode.setImage(FOLDER_IMAGE);\r\n\t\t\ttheDatabaseNode.addChild(theTablesNode);\r\n\r\n\t\t\t// Adds the Views database node.\r\n\t\t\tDatabaseExplorerNode theViewsNode = new DatabaseExplorerNode();\r\n\t\t\ttheViewsNode.setName(STRING_VIEWS);\r\n\t\t\ttheViewsNode.setImage(FOLDER_IMAGE);\r\n\t\t\ttheDatabaseNode.addChild(theViewsNode);\r\n\t\t\t\r\n\t\t\t// Adds the database schemas.\r\n\t\t\tString[] theSchemaNames = theDatabase.getSchemas();\r\n      DatabaseExplorerNode theSchemaNode = null;\r\n      for (int i = 0; i < theSchemaNames.length; i++) {\r\n        theSchemaNode = new DatabaseExplorerNode();\r\n        theSchemaNode.setName(theSchemaNames[i]);\r\n        theSchemaNode.setImage(FOLDER_IMAGE);\r\n        theSchemasNode.addChild(theSchemaNode);\r\n        \r\n        // Adds the database tables for the given schema.\r\n        String[] theTableNames = theDatabase.getTablenames(theSchemaNames[i], false);\r\n        DatabaseExplorerNode theTableNode = null;\r\n        for (int i2 = 0; i2 < theTableNames.length; i2++) {\r\n          theTableNode = new DatabaseExplorerNode();\r\n          theTableNode.setIsTable(true);\r\n          theTableNode.setSchema(theSchemaNames[i]);\r\n          theTableNode.setName(theTableNames[i2]);\r\n          theTableNode.setImage(TABLE_IMAGE);\r\n          theSchemaNode.addChild(theTableNode);\r\n        }\r\n        \r\n      }\t\t\t\r\n\t\t\t\r\n\t\t\t// Adds the database tables.\r\n\t\t\tString[] theTableNames = theDatabase.getTablenames(\"\", false); //$NON-NLS-1$\r\n\t\t\tDatabaseExplorerNode theTableNode = null;\r\n\t\t\tfor (int i = 0; i < theTableNames.length; i++) {\r\n\t\t\t\ttheTableNode = new DatabaseExplorerNode();\r\n\t\t\t\ttheTableNode.setIsTable(true);\r\n\t\t\t\ttheTableNode.setName(theTableNames[i]);\r\n\t\t\t\ttheTableNode.setImage(TABLE_IMAGE);\r\n\t\t\t\ttheTablesNode.addChild(theTableNode);\r\n\t\t\t}\r\n\r\n\t\t\t// Adds the database views.\r\n\t\t\tString[] theViewNames = theDatabase.getViews();\r\n\t\t\tDatabaseExplorerNode theViewNode = null;\r\n\t\t\tfor (int i = 0; i < theViewNames.length; i++) {\r\n\t\t\t\ttheViewNode = new DatabaseExplorerNode();\r\n\t\t\t\ttheViewNode.setIsTable(true);\r\n\t\t\t\ttheViewNode.setName(theViewNames[i]);\r\n\t\t\t\ttheViewNode.setImage(TABLE_IMAGE);\r\n\t\t\t\ttheViewsNode.addChild(theViewNode);\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.info(e);\r\n\t\t}\r\n\t}","id":24775,"modified_method":"private void createDatabaseNodes() {\r\n\t\ttry {\r\n\t\t\tDatabase theDatabase = new Database(null, this.model.getDatabaseMeta());\r\n\t\t\ttheDatabase.connect();\r\n\r\n\t\t\t// Adds the main database node.\r\n\t\t\tDatabaseExplorerNode theDatabaseNode = new DatabaseExplorerNode();\r\n\t\t\ttheDatabaseNode.setName(this.model.getDatabaseMeta().getName());\r\n\t\t\ttheDatabaseNode.setImage(DATABASE_IMAGE);\r\n\t\t\tthis.model.getDatabase().add(theDatabaseNode);\r\n\t\t\t\r\n\t\t\t// Adds the Schema database node.\r\n\t\t\tDatabaseExplorerNode theSchemasNode = new DatabaseExplorerNode();\r\n\t\t\ttheSchemasNode.setName(STRING_SCHEMAS);\r\n\t\t\ttheSchemasNode.setImage(FOLDER_IMAGE);\r\n\t\t\ttheDatabaseNode.add(theSchemasNode);\r\n\r\n\t\t\t// Adds the Tables database node.\r\n\t\t\tDatabaseExplorerNode theTablesNode = new DatabaseExplorerNode();\r\n\t\t\ttheTablesNode.setName(STRING_TABLES);\r\n\t\t\ttheTablesNode.setImage(FOLDER_IMAGE);\r\n\t\t\ttheDatabaseNode.add(theTablesNode);\r\n\r\n\t\t\t// Adds the Views database node.\r\n\t\t\tDatabaseExplorerNode theViewsNode = new DatabaseExplorerNode();\r\n\t\t\ttheViewsNode.setName(STRING_VIEWS);\r\n\t\t\ttheViewsNode.setImage(FOLDER_IMAGE);\r\n\t\t\ttheDatabaseNode.add(theViewsNode);\r\n\t\t\t\r\n\t\t\t// Adds the database schemas.\r\n\t\t\tString[] theSchemaNames = theDatabase.getSchemas();\r\n      DatabaseExplorerNode theSchemaNode = null;\r\n      for (int i = 0; i < theSchemaNames.length; i++) {\r\n        theSchemaNode = new DatabaseExplorerNode();\r\n        theSchemaNode.setName(theSchemaNames[i]);\r\n        theSchemaNode.setImage(SCHEMA_IMAGE);\r\n        theSchemaNode.setIsSchema(true);\r\n        theSchemasNode.add(theSchemaNode);\r\n        \r\n        // Adds the database tables for the given schema.\r\n        String[] theTableNames = theDatabase.getTablenames(theSchemaNames[i], false);\r\n        DatabaseExplorerNode theTableNode = null;\r\n        for (int i2 = 0; i2 < theTableNames.length; i2++) {\r\n          theTableNode = new DatabaseExplorerNode();\r\n          theTableNode.setIsTable(true);\r\n          theTableNode.setSchema(theSchemaNames[i]);\r\n          theTableNode.setName(theTableNames[i2]);\r\n          theTableNode.setImage(TABLE_IMAGE);\r\n          theSchemaNode.add(theTableNode);\r\n          theTableNode.setParent(theSchemaNode);\r\n        }\r\n        \r\n      }\t\t\t\r\n\t\t\t\r\n\t\t\t// Adds the database tables.\r\n\t\t\tString[] theTableNames = theDatabase.getTablenames(\"\", false); //$NON-NLS-1$\r\n\t\t\tDatabaseExplorerNode theTableNode = null;\r\n\t\t\tfor (int i = 0; i < theTableNames.length; i++) {\r\n\t\t\t\ttheTableNode = new DatabaseExplorerNode();\r\n\t\t\t\ttheTableNode.setIsTable(true);\r\n\t\t\t\ttheTableNode.setName(theTableNames[i]);\r\n\t\t\t\ttheTableNode.setImage(TABLE_IMAGE);\r\n\t\t\t\ttheTablesNode.add(theTableNode);\r\n\t\t\t}\r\n\r\n\t\t\t// Adds the database views.\r\n\t\t\tString[] theViewNames = theDatabase.getViews();\r\n\t\t\tDatabaseExplorerNode theViewNode = null;\r\n\t\t\tfor (int i = 0; i < theViewNames.length; i++) {\r\n\t\t\t\ttheViewNode = new DatabaseExplorerNode();\r\n\t\t\t\ttheViewNode.setIsTable(true);\r\n\t\t\t\ttheViewNode.setName(theViewNames[i]);\r\n\t\t\t\ttheViewNode.setImage(TABLE_IMAGE);\r\n\t\t\t\ttheViewsNode.add(theViewNode);\r\n\t\t\t}\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.info(e);\r\n\t\t}\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void showLayout() {\r\n\t\tXulStepFieldsDialog theStepFieldsDialog = new XulStepFieldsDialog(this.shell, SWT.NONE, this.model.getDatabaseMeta(), this.model.getTable(), null);\r\n\t\ttheStepFieldsDialog.open(false);\r\n\t}","id":24776,"modified_method":"public void showLayout() {\r\n\t\tXulStepFieldsDialog theStepFieldsDialog = new XulStepFieldsDialog(this.shell, SWT.NONE, this.model.getDatabaseMeta(), this.model.getTable().getName(), null);\r\n\t\ttheStepFieldsDialog.open(false);\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setSelectedTable(String aTable) {\r\n\t\tthis.model.setTable(aTable);\r\n\t}","id":24777,"modified_method":"public void setSelectedTable(String aTable) {\r\n    this.model.setTable(model.findBy(aTable));\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void accept() {\r\n\t\tthis.dbExplorerDialog.setVisible(false);\r\n\t}","id":24778,"modified_method":"public void accept() {\r\n\t  if(this.model.getTable() != null){\r\n\t    this.dbExplorerDialog.setVisible(false);\r\n\t  }\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void displayRowCount() {\r\n\r\n\t\ttry {\r\n\t\t\tGetTableSizeProgressDialog pd = new GetTableSizeProgressDialog(this.shell, this.model.getDatabaseMeta(), this.model.getTable());\r\n\t\t\tLong theCount = pd.open();\r\n\t\t\tif (theCount != null) {\r\n\t\t\t\tXulMessageBox theMessageBox = (XulMessageBox) document.createElement(\"messagebox\");\r\n\t\t\t\ttheMessageBox.setModalParent(this.dbExplorerDialog.getShell());\r\n\t\t\t\ttheMessageBox.setTitle(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Title\"));\r\n\t\t\t\ttheMessageBox.setMessage(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Message\", this.model.getTable(), theCount.toString()));\r\n\t\t\t\ttheMessageBox.open();\r\n\t\t\t}\r\n\t\t} catch (XulException e) {\r\n\t\t\tlogger.error(e);\r\n\t\t}\r\n\t}","id":24779,"modified_method":"public void displayRowCount() {\r\n\r\n\t\ttry {\r\n\t\t\tGetTableSizeProgressDialog pd = new GetTableSizeProgressDialog(this.shell, this.model.getDatabaseMeta(), this.model.getTable().getName());\r\n\t\t\tLong theCount = pd.open();\r\n\t\t\tif (theCount != null) {\r\n\t\t\t\tXulMessageBox theMessageBox = (XulMessageBox) document.createElement(\"messagebox\");\r\n\t\t\t\ttheMessageBox.setModalParent(this.dbExplorerDialog.getShell());\r\n\t\t\t\ttheMessageBox.setTitle(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Title\"));\r\n\t\t\t\ttheMessageBox.setMessage(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Message\", this.model.getTable(), theCount.toString()));\r\n\t\t\t\ttheMessageBox.open();\r\n\t\t\t}\r\n\t\t} catch (XulException e) {\r\n\t\t\tlogger.error(e);\r\n\t\t}\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void init() {\r\n\r\n\t\tif (this.isJustLook) {\r\n\t\t\tSwtButton theAcceptButton = (SwtButton) this.document.getElementById(\"databaseExplorerDialog_accept\");\r\n\t\t\ttheAcceptButton.setVisible(false);\r\n\t\t}\r\n\r\n\t\tcreateDatabaseNodes();\r\n\t\tthis.dbExplorerDialog = (SwtDialog) this.document.getElementById(\"databaseExplorerDialog\");\r\n\t\tthis.actionLabel = (XulLabel) document.getElementById(\"action_label\");\r\n\t\tthis.bf.setDocument(super.document);\r\n\t\tthis.bf.setBindingType(Type.ONE_WAY);\r\n\r\n\t\tthis.expandCollapseButton = (XulButton) document.getElementById(\"expandCollapseButton\");\r\n\t\tthis.databaseTree = (XulTree) document.getElementById(\"databaseTree\");\r\n\t\tthis.databaseTreeBinding = bf.createBinding(this.model, \"database\", this.databaseTree, \"elements\");\r\n\r\n\t\tBindingConvertor<DatabaseExplorerNode, String> theTableNameConvertor = new BindingConvertor<DatabaseExplorerNode, String>() {\r\n\r\n\t\t\tpublic String sourceToTarget(DatabaseExplorerNode aValue) {\r\n\t\t\t\tString theTable = null;\r\n\t\t\t\tif (aValue != null && aValue.isTable()) {\r\n\t\t\t\t\ttheTable = aValue.getName();\r\n\t\t\t\t}\r\n\t\t\t\treturn theTable;\r\n\t\t\t}\r\n\r\n\t\t\tpublic DatabaseExplorerNode targetToSource(String aValue) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\t\tBindingConvertor<DatabaseExplorerNode, String> theTableSchemaConvertor = new BindingConvertor<DatabaseExplorerNode, String>() {\r\n\r\n      public String sourceToTarget(DatabaseExplorerNode aValue) {\r\n        String theSchema = null;\r\n        if (aValue != null && aValue.isTable()) {\r\n          theSchema = aValue.getSchema();\r\n        }\r\n        return theSchema;\r\n      }\r\n\r\n      public DatabaseExplorerNode targetToSource(String aValue) {\r\n        return null;\r\n      }\r\n    };\r\n\t\t\r\n\t\tthis.bf.createBinding(this.databaseTree, \"selectedItem\", this.model, \"table\", theTableNameConvertor);\r\n\t\tthis.bf.createBinding(this.databaseTree, \"selectedItem\", this.model, \"schema\", theTableSchemaConvertor);\r\n\r\n\t\tBindingConvertor<String, List<DatabaseExplorerNode>> theSelectedItemsConvertor = new BindingConvertor<String, List<DatabaseExplorerNode>>() {\r\n\r\n\t\t\tpublic String targetToSource(List<DatabaseExplorerNode> aValue) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\tpublic List<DatabaseExplorerNode> sourceToTarget(String aValue) {\r\n\t\t\t\tDatabaseExplorerNode theNode = XulDatabaseExplorerController.this.model.findBy(aValue);\r\n\t\t\t\tList<DatabaseExplorerNode> theResult = new ArrayList<DatabaseExplorerNode>();\r\n\t\t\t\ttheResult.add(theNode);\r\n\t\t\t\treturn theResult;\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.selectedTableBinding = this.bf.createBinding(this.model, \"table\", this.databaseTree, \"selectedItems\", theSelectedItemsConvertor);\r\n\t\t// this.selectedSchemaBinding = this.bf.createBinding(this.model, \"schema\",\r\n\t\t// this.databaseTree, \"selectedItems\", theSelectedItemsConvertor);\r\n\r\n\t\tBindingConvertor<DatabaseExplorerNode, Boolean> isDisabledConvertor = new BindingConvertor<DatabaseExplorerNode, Boolean>() {\r\n\t\t\tpublic Boolean sourceToTarget(DatabaseExplorerNode value) {\r\n\t\t\t\treturn !(value != null && value.isTable());\r\n\t\t\t}\r\n\r\n\t\t\tpublic DatabaseExplorerNode targetToSource(Boolean value) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n\t\tthis.bf.createBinding(this.databaseTree, \"selectedItem\", \"buttonMenuPopUp\", \"disabled\", isDisabledConvertor);\r\n\t\tthis.bf.createBinding(this.databaseTree, \"selectedItem\", actionLabel, \"disabled\", isDisabledConvertor);\r\n\t\tfireBindings();\r\n\t}","id":24780,"modified_method":"public void init() {\r\n\r\n    SwtButton theAcceptButton = (SwtButton) this.document.getElementById(\"databaseExplorerDialog_accept\");\r\n    SwtButton theCancelButton = (SwtButton) this.document.getElementById(\"databaseExplorerDialog_cancel\");\r\n\t\tif (this.isJustLook) {\r\n\t\t\ttheAcceptButton.setVisible(false);\r\n\t\t\ttheCancelButton.setLabel(BaseMessages.getString(getClass(), \"DatabaseExplorer.Button.Ok\"));\r\n\t\t\ttheAcceptButton.setDisabled(false);\r\n      \r\n\t\t} else {\r\n\t\t  theCancelButton.setLabel(BaseMessages.getString(getClass(), \"DatabaseExplorer.Button.Cancel\"));\r\n\t\t  theAcceptButton.setDisabled(true);\r\n\t\t}\r\n    \r\n\r\n\t\tcreateDatabaseNodes();\r\n\t\tthis.dbExplorerDialog = (SwtDialog) this.document.getElementById(\"databaseExplorerDialog\");\r\n\t\tthis.bf.setDocument(super.document);\r\n\t\tthis.bf.setBindingType(Type.ONE_WAY);\r\n\r\n\t\tthis.expandCollapseButton = (XulButton) document.getElementById(\"expandCollapseButton\");\r\n\t\tthis.databaseTree = (XulTree) document.getElementById(\"databaseTree\");\r\n\t\tthis.databaseTreeBinding = bf.createBinding(this.model, \"database\", this.databaseTree, \"elements\");\r\n\r\n\t\tbf.createBinding(model, \"table\", theAcceptButton, \"disabled\", new BindingConvertor<DatabaseExplorerNode, Boolean>(){\r\n\r\n      @Override\r\n      public Boolean sourceToTarget(DatabaseExplorerNode arg0) {\r\n        return (!isJustLook && arg0 == null);\r\n        \r\n      }\r\n\r\n      @Override\r\n      public DatabaseExplorerNode targetToSource(Boolean arg0) {\r\n        // TODO Auto-generated method stub\r\n        return null;\r\n      }\r\n\t\t  \r\n\t\t});\r\n\t\t\r\n\t\t\r\n\t\tBindingConvertor<DatabaseExplorerNode, String> theTableNameConvertor = new BindingConvertor<DatabaseExplorerNode, String>() {\r\n\r\n\t\t\tpublic String sourceToTarget(DatabaseExplorerNode aValue) {\r\n\t\t\t\tString theTable = null;\r\n\t\t\t\tif (aValue != null && aValue.isTable()) {\r\n\t\t\t\t\ttheTable = aValue.getName();\r\n\t\t\t\t}\r\n\t\t\t\treturn theTable;\r\n\t\t\t}\r\n\r\n\t\t\tpublic DatabaseExplorerNode targetToSource(String aValue) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n\t\t\r\n\r\n    \r\n    bf.setBindingType(Binding.Type.BI_DIRECTIONAL);\r\n\t\tthis.bf.createBinding(this.databaseTree, \"selectedItems\", this.model, \"table\", new BindingConvertor<List<DatabaseExplorerNode>, DatabaseExplorerNode>(){\r\n\r\n      @Override\r\n      public DatabaseExplorerNode sourceToTarget(List<DatabaseExplorerNode> arg0) {\r\n        if(arg0 == null || arg0.size() == 0){\r\n          return null; \r\n        }\r\n        DatabaseExplorerNode node = arg0.get(0);\r\n        if(node.isTable()){\r\n          return node;\r\n        }\r\n        return null;\r\n      }\r\n\r\n      @Override\r\n      public List<DatabaseExplorerNode> targetToSource(DatabaseExplorerNode arg0) {\r\n        return Collections.singletonList(arg0);\r\n      }\r\n      \r\n    });\r\n\r\n\t\tthis.bf.createBinding(this.databaseTree, \"selectedItems\", this.model, \"schema\", new BindingConvertor<List<DatabaseExplorerNode>, DatabaseExplorerNode>(){\r\n\r\n      @Override\r\n      public DatabaseExplorerNode sourceToTarget(List<DatabaseExplorerNode> arg0) {\r\n        if(arg0 == null || arg0.size() == 0){\r\n          return null; \r\n        }\r\n        DatabaseExplorerNode node = arg0.get(0);\r\n        if(node.isSchema()){\r\n          return node;\r\n        } else if(node.isTable()){\r\n          return (DatabaseExplorerNode) node.getParent();\r\n        }\r\n        return null;\r\n      }\r\n\r\n      @Override\r\n      public List<DatabaseExplorerNode> targetToSource(DatabaseExplorerNode arg0) {\r\n        return Collections.singletonList(arg0);\r\n      }\r\n      \r\n    });\r\n\t\t// this.selectedSchemaBinding = this.bf.createBinding(this.model, \"schema\",\r\n\t\t// this.databaseTree, \"selectedItems\", theSelectedItemsConvertor);\r\n\r\n\t\tBindingConvertor<DatabaseExplorerNode, Boolean> isDisabledConvertor = new BindingConvertor<DatabaseExplorerNode, Boolean>() {\r\n\t\t\tpublic Boolean sourceToTarget(DatabaseExplorerNode value) {\r\n\t\t\t\treturn !(value != null && value.isTable());\r\n\t\t\t}\r\n\r\n\t\t\tpublic DatabaseExplorerNode targetToSource(Boolean value) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t};\r\n    bf.setBindingType(Binding.Type.ONE_WAY);\r\n\t\tthis.bf.createBinding(this.databaseTree, \"selectedItem\", \"buttonMenuPopUp\", \"disabled\", isDisabledConvertor);\r\n    this.bf.createBinding(this.databaseTree, \"selectedItem\", \"buttonMenuPopUpImg\", \"disabled\", isDisabledConvertor);\r\n\t\tfireBindings();\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void preview(boolean askLimit) {\r\n\t\ttry {\r\n\t\t\tPromptCallback theCallback = new PromptCallback();\r\n\t\t\t@SuppressWarnings(\"unused\")\r\n      boolean execute = true;\r\n\t\t\tif (askLimit) {\r\n\t\t\t\tXulPromptBox thePromptBox = (XulPromptBox) this.document.createElement(\"promptbox\");\r\n\t\t\t\tthePromptBox.setModalParent(this.dbExplorerDialog.getShell());\r\n\t\t\t\tthePromptBox.setTitle(\"Enter Max Rows\");\r\n\t\t\t\tthePromptBox.setMessage(\"Max Rows:\");\r\n\t\t\t\tthePromptBox.addDialogCallback(theCallback);\r\n\t\t\t\tthePromptBox.open();\r\n\t\t\t\texecute = theCallback.getLimit() != -1;\r\n\t\t\t}\r\n\r\n//\t\t\tif (execute) {\r\n//\t\t\t\tXulPreviewRowsDialog thePreviewRowsDialog = new XulPreviewRowsDialog(this.shell, SWT.NONE, this.model.getDatabaseMeta(), this.model.getTable(), theCallback.getLimit());\r\n//\t\t\t\tthePreviewRowsDialog.open();\r\n//\t\t\t}\r\n\t\t\t\r\n\t\t\tGetPreviewTableProgressDialog pd = new GetPreviewTableProgressDialog(shell, this.model.getDatabaseMeta(), this.model.getSchema(), this.model.getTable(), theCallback.getLimit());\r\n      List<Object[]> rows = pd.open();\r\n      if (rows!=null) // otherwise an already shown error...\r\n      {\r\n      if (rows.size()>0)\r\n      {\r\n        PreviewRowsDialog prd = new PreviewRowsDialog(shell, this.model.getDatabaseMeta(), SWT.None, this.model.getTable(), pd.getRowMeta(), rows);\r\n        prd.open();\r\n      }\r\n      else\r\n      {\r\n        MessageBox mb = new MessageBox(shell, SWT.ICON_INFORMATION | SWT.OK);\r\n        mb.setMessage(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.NoRows.Message\"));\r\n        mb.setText(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.NoRows.Title\"));\r\n        mb.open();\r\n      }\r\n      }\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e);\r\n\t\t}\r\n\t}","id":24781,"modified_method":"public void preview(boolean askLimit) {\r\n\t  if(model.getTable() == null){\r\n\t    return;\r\n\t  }\r\n\t\ttry {\r\n\t\t\tPromptCallback theCallback = new PromptCallback();\r\n\t\t\t@SuppressWarnings(\"unused\")\r\n      boolean execute = true;\r\n\t\t\tint limit = 100;\r\n\t\t\tif (askLimit) {\r\n\t\t\t\tXulPromptBox thePromptBox = (XulPromptBox) this.document.createElement(\"promptbox\");\r\n\t\t\t\tthePromptBox.setModalParent(this.dbExplorerDialog.getShell());\r\n\t\t\t\tthePromptBox.setTitle(\"Enter Max Rows\");\r\n\t\t\t\tthePromptBox.setMessage(\"Max Rows:\");\r\n\t\t\t\tthePromptBox.addDialogCallback(theCallback);\r\n\t\t\t\tthePromptBox.open();\r\n\t\t\t\texecute = theCallback.getLimit() != -1;\r\n\t\t\t\tlimit = theCallback.getLimit();\r\n\t\t\t}\r\n\r\n//\t\t\tif (execute) {\r\n//\t\t\t\tXulPreviewRowsDialog thePreviewRowsDialog = new XulPreviewRowsDialog(this.shell, SWT.NONE, this.model.getDatabaseMeta(), this.model.getTable(), theCallback.getLimit());\r\n//\t\t\t\tthePreviewRowsDialog.open();\r\n//\t\t\t}\r\n\t\t\t\r\n\t\t\tGetPreviewTableProgressDialog pd = new GetPreviewTableProgressDialog(shell, this.model.getDatabaseMeta(), (model.getSchema() != null)? model.getSchema().getName():null, (model.getTable() != null)? model.getTable().getName():null, limit);\r\n      List<Object[]> rows = pd.open();\r\n      if (rows!=null) // otherwise an already shown error...\r\n      {\r\n      if (rows.size()>0)\r\n      {\r\n        PreviewRowsDialog prd = new PreviewRowsDialog(shell, this.model.getDatabaseMeta(), SWT.None, this.model.getTable().getName(), pd.getRowMeta(), rows);\r\n        prd.open();\r\n      }\r\n      else\r\n      {\r\n        MessageBox mb = new MessageBox(shell, SWT.ICON_INFORMATION | SWT.OK);\r\n        mb.setMessage(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.NoRows.Message\"));\r\n        mb.setText(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.NoRows.Title\"));\r\n        mb.open();\r\n      }\r\n      }\r\n\t\t\t\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.error(e);\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setSelectedSchema(String aSchema) {\r\n\t\tthis.model.setSchema(aSchema);\r\n\t}","id":24782,"modified_method":"public void setSelectedSchema(String aSchema) {\r\n\t  this.model.setSchema(model.findBy(aSchema));\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getSelectedTable() {\r\n\t\treturn this.model.getTable();\r\n\t}","id":24783,"modified_method":"public String getSelectedTable() {\r\n\t\treturn (model.getTable() == null)? null : model.getTable().getName();\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void getDDL() {\r\n\t\tDatabase db = new Database(null, this.model.getDatabaseMeta());\r\n\t\ttry {\r\n\t\t\tdb.connect();\r\n\t\t\tRowMetaInterface r = db.getTableFields(this.model.getTable());\r\n\t\t\tString sql = db.getCreateTableStatement(this.model.getTable(), r, null, false, null, true);\r\n\t\t\tSQLEditor se = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, sql);\r\n\t\t\tse.open();\r\n\t\t} catch (KettleDatabaseException dbe) {\r\n\t\t\tnew ErrorDialog(this.dbExplorerDialog.getShell(), BaseMessages.getString(PKG, \"Dialog.Error.Header\"), BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.Error.RetrieveLayout\"), dbe);\r\n\t\t} finally {\r\n\t\t\tdb.disconnect();\r\n\t\t}\r\n\t}","id":24784,"modified_method":"public void getDDL() {\r\n\t\tDatabase db = new Database(null, this.model.getDatabaseMeta());\r\n\t\ttry {\r\n\t\t\tdb.connect();\r\n\t\t\tRowMetaInterface r = db.getTableFields(this.model.getTable().getName());\r\n\t\t\tString sql = db.getCreateTableStatement(this.model.getTable().getName(), r, null, false, null, true);\r\n\t\t\tSQLEditor se = new SQLEditor(this.dbExplorerDialog.getShell(), SWT.NONE, this.model.getDatabaseMeta(), this.dbcache, sql);\r\n\t\t\tse.open();\r\n\t\t} catch (KettleDatabaseException dbe) {\r\n\t\t\tnew ErrorDialog(this.dbExplorerDialog.getShell(), BaseMessages.getString(PKG, \"Dialog.Error.Header\"), BaseMessages.getString(PKG,  \"DatabaseExplorerDialog.Error.RetrieveLayout\"), dbe);\r\n\t\t} finally {\r\n\t\t\tdb.disconnect();\r\n\t\t}\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Object open() {\r\n\t\ttry {\r\n\r\n\t\t\tSwtXulLoader theLoader = new SwtXulLoader();\r\n\t\t\ttheLoader.setOuterContext(this.shell);\r\n\r\n\t\t\tthis.container = theLoader.loadXul(XUL, new XulDatabaseExplorerResourceBundle());\r\n\r\n      XulDialog theExplorerDialog = (XulDialog) this.container.getDocumentRoot().getElementById(\"databaseExplorerDialog\");\r\n      \r\n\t\t\tSpoonPluginManager.getInstance().applyPluginsForContainer(\"database_dialog\", container);\r\n\r\n\r\n\t    this.controller = new XulDatabaseExplorerController((Shell) theExplorerDialog.getRootObject(), this.databaseMeta, this.databases, look);\r\n\t    \r\n\t    this.controller.setSplitSchemaAndTable(splitSchemaAndTable);\r\n\t    this.controller.setSelectedSchema(schemaName);\r\n\t    this.controller.setSelectedTable(selectedTable);\r\n\t    \r\n\t\t\tthis.container.addEventHandler(this.controller);\r\n\r\n\t\t\tthis.runner = new SwtXulRunner();\r\n\t\t\tthis.runner.addContainer(this.container);\r\n\t\t\tthis.runner.initialize();\r\n\r\n\t\t\ttheExplorerDialog.show();\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.info(e);\r\n\t\t}\r\n\t\treturn this.controller.getSelectedTable();\r\n\t}","id":24785,"modified_method":"public Object open() {\r\n\t\ttry {\r\n\r\n\t\t\tSwtXulLoader theLoader = new SwtXulLoader();\r\n\t\t\ttheLoader.setOuterContext(this.shell);\r\n\r\n\t\t\tthis.container = theLoader.loadXul(XUL, new XulDatabaseExplorerResourceBundle());\r\n\r\n      XulDialog theExplorerDialog = (XulDialog) this.container.getDocumentRoot().getElementById(\"databaseExplorerDialog\");\r\n      \r\n\t\t\tSpoonPluginManager.getInstance().applyPluginsForContainer(\"database_dialog\", container);\r\n\r\n\r\n\t    this.controller = new XulDatabaseExplorerController((Shell) theExplorerDialog.getRootObject(), this.databaseMeta, this.databases, look);\r\n\t    \r\n\t    \r\n\t\t\tthis.container.addEventHandler(this.controller);\r\n\r\n\t\t\tthis.runner = new SwtXulRunner();\r\n\t\t\tthis.runner.addContainer(this.container);\r\n\t\t\tthis.runner.initialize();\r\n\t\t\t\r\n      this.controller.setSplitSchemaAndTable(splitSchemaAndTable);\r\n      this.controller.setSelectedSchema(schemaName);\r\n      this.controller.setSelectedTable(selectedTable);\r\n\r\n\t\t\ttheExplorerDialog.show();\r\n\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.info(e);\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\treturn this.controller.getSelectedTable();\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getTable() {\r\n\t\treturn this.table;\r\n\t}","id":24786,"modified_method":"public DatabaseExplorerNode getTable() {\r\n\t\treturn this.table;\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private DatabaseExplorerNode drillDown(ListIterator<DatabaseExplorerNode> aNodes, String aName) {\r\n\t\tDatabaseExplorerNode theNode = null;\r\n\t\twhile (aNodes.hasNext()) {\r\n\t\t\ttheNode = aNodes.next();\r\n\t\t\tif (theNode.getName().equals(aName)) {\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\ttheNode = drillDown(theNode.getChildren().listIterator(), aName);\r\n\t\t\t\tif (theNode != null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn theNode;\r\n\t}","id":24787,"modified_method":"private DatabaseExplorerNode drillDown(ListIterator<DatabaseExplorerNode> aNodes, String aName) {\r\n\t\tDatabaseExplorerNode theNode = null;\r\n\t\twhile (aNodes.hasNext()) {\r\n\t\t\ttheNode = aNodes.next();\r\n\t\t\tif (theNode.getName().equals(aName)) {\r\n\t\t\t\tbreak;\r\n\t\t\t} else {\r\n\t\t\t\ttheNode = drillDown(theNode.listIterator(), aName);\r\n\t\t\t\tif (theNode != null) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn theNode;\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getSchema() {\r\n\t\treturn this.schema;\r\n\t}","id":24788,"modified_method":"public DatabaseExplorerNode getSchema() {\r\n\t\treturn this.schema;\r\n\t}","commit_id":"3c6552e22c9091a9dfe2805e85acd3166af648d6","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\r\n\t * Creates a new dialog that will handle the wait while we're doing the hard work.\r\n\t */\r\n\tpublic GetPreviewTableProgressDialog(Shell shell, DatabaseMeta dbInfo, String schemaName, String tableName, int limit)\r\n\t{\r\n\t\tthis.shell = shell;\r\n\t\tthis.dbMeta = dbInfo;\r\n\t\tif(schemaName != null) {\r\n\t\t  this.tableName = dbInfo.getSchemaTableCombination(schemaName, tableName);\r\n\t\t} else {\r\n\t\t  this.tableName = tableName;\r\n\t\t}\r\n\t\tthis.limit = limit;\r\n    }","id":24789,"modified_method":"/**\r\n\t * Creates a new dialog that will handle the wait while we're doing the hard work.\r\n\t */\r\n\tpublic GetPreviewTableProgressDialog(Shell shell, DatabaseMeta dbInfo, String schemaName, String tableName, int limit)\r\n\t{\r\n\t\tthis.shell = shell;\r\n\t\tthis.dbMeta = dbInfo;\r\n\t\tthis.tableName = dbInfo.getQuotedSchemaTableCombination(schemaName, tableName);\r\n\t\tthis.limit = limit;\r\n    }","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public GetTableSizeProgressDialog(Shell shell, DatabaseMeta dbInfo, String tableName, String schemaName)\r\n\t{\r\n\t\tthis.shell = shell;\r\n\t\tthis.dbMeta = dbInfo;\r\n\t\tif (StringUtils.isEmpty(schemaName)) {\r\n      this.tableName = tableName;\r\n    } else {\r\n      this.tableName = dbInfo.getQuotedSchemaTableCombination(schemaName, tableName);\r\n    }\r\n\t}","id":24790,"modified_method":"public GetTableSizeProgressDialog(Shell shell, DatabaseMeta dbInfo, String tableName, String schemaName)\r\n\t{\r\n\t\tthis.shell = shell;\r\n\t\tthis.dbMeta = dbInfo;\r\n\t\tthis.tableName = dbInfo.getQuotedSchemaTableCombination(schemaName, tableName);\r\n\t}","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void displayRowCount() {\r\n\t\tif (this.model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tString schema = this.model.getSchema() != null ? this.model.getSchema().getName() : null;\r\n      GetTableSizeProgressDialog pd = new GetTableSizeProgressDialog(this.shell, this.model.getDatabaseMeta(), this.model.getTable().getName(), schema);\r\n\t\t\tLong theCount = pd.open();\r\n\t\t\tif (theCount != null) {\r\n\t\t\t\tXulMessageBox theMessageBox = (XulMessageBox) document.createElement(\"messagebox\");\r\n\t\t\t\ttheMessageBox.setModalParent(this.dbExplorerDialog.getShell());\r\n\t\t\t\ttheMessageBox.setTitle(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Title\"));\r\n\t\t\t\ttheMessageBox.setMessage(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Message\", this.model.getTable(), theCount.toString()));\r\n\t\t\t\ttheMessageBox.open();\r\n\t\t\t}\r\n\t\t} catch (XulException e) {\r\n\t\t\tlogger.error(e);\r\n\t\t}\r\n\t}","id":24791,"modified_method":"public void displayRowCount() {\r\n\t\tif (this.model.getTable() == null) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tString schema = this.model.getSchema() != null ? this.model.getSchema().getName() : null;\r\n\t\t\tGetTableSizeProgressDialog pd = new GetTableSizeProgressDialog(this.shell, this.model.getDatabaseMeta(), this.model.getTable().getName(), schema);\r\n\t\t\tLong theCount = pd.open();\r\n\t\t\tif (theCount != null) {\r\n\t\t\t\tXulMessageBox theMessageBox = (XulMessageBox) document.createElement(\"messagebox\");\r\n\t\t\t\ttheMessageBox.setModalParent(this.dbExplorerDialog.getShell());\r\n\t\t\t\ttheMessageBox.setTitle(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Title\"));\r\n\t\t\t\ttheMessageBox.setMessage(BaseMessages.getString(PKG,\"DatabaseExplorerDialog.TableSize.Message\", this.model.getTable().getName(), theCount.toString()));\r\n\t\t\t\ttheMessageBox.open();\r\n\t\t\t}\r\n\t\t} catch (XulException e) {\r\n\t\t\tlogger.error(e);\r\n\t\t}\r\n\t}","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private String getSchemaAndTable(XulDatabaseExplorerModel model, DatabaseMeta meta) {\r\n    if (model.getSchema() != null) {\r\n      return meta.getQuotedSchemaTableCombination(model.getSchema().getName(), model.getTable().getName());\r\n    } else {\r\n      return model.getTable().getName();\r\n    }\r\n  }","id":24792,"modified_method":"private String getSchemaAndTable(XulDatabaseExplorerModel model, DatabaseMeta meta) {\r\n    if (model.getSchema() != null) {\r\n      return meta.getQuotedSchemaTableCombination(model.getSchema().getName(), model.getTable().getName());\r\n    } else {\r\n      return meta.getQuotedSchemaTableCombination(null, model.getTable().getName());\r\n    }\r\n  }","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void createStepFieldNodes() {\r\n\r\n\t\tif (this.rowMetaInterface == null) {\r\n\t\t\tString theSql = this.databaseMeta.getSQLQueryFields(this.table);\r\n\t\t\tGetQueryFieldsProgressDialog theProgressDialog = new GetQueryFieldsProgressDialog(this.shell, this.databaseMeta, theSql);\r\n\t\t\tthis.rowMetaInterface = theProgressDialog.open();\r\n\t\t}\r\n\r\n\t\tthis.model.setStepName(\"Step name:\" + this.table);\r\n\r\n\t\tif (this.rowMetaInterface != null) {\r\n\t\t\tStepFieldNode theStep = null;\r\n\t\t\tfor (int i = 0; i < this.rowMetaInterface.size(); i++) {\r\n\t\t\t\ttheStep = new StepFieldNode();\r\n\t\t\t\tValueMetaInterface theMetaInterface = this.rowMetaInterface.getValueMeta(i);\r\n\t\t\t\ttheStep.setFieldName(theMetaInterface.getName());\r\n\t\t\t\ttheStep.setType(theMetaInterface.getTypeDesc());\r\n\t\t\t\ttheStep.setLength(Integer.toString(theMetaInterface.getLength()));\r\n\t\t\t\ttheStep.setPrecision(Integer.toString(theMetaInterface.getPrecision()));\r\n\t\t\t\ttheStep.setOrigin(theMetaInterface.getOrigin());\r\n\t\t\t\ttheStep.setStorageType(Integer.toString(theMetaInterface.getStorageType()));\r\n\t\t\t\ttheStep.setConversionMask(theMetaInterface.getConversionMask());\r\n\t\t\t\ttheStep.setDecimalSymbol(theMetaInterface.getDecimalSymbol());\r\n\t\t\t\ttheStep.setGroupingSymbol(theMetaInterface.getGroupingSymbol());\r\n\t\t\t\ttheStep.setTrimType(Integer.toString(theMetaInterface.getTrimType()));\r\n\t\t\t\ttheStep.setComments(theMetaInterface.getComments());\r\n\t\t\t\tthis.model.addStepField(theStep);\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":24793,"modified_method":"private void createStepFieldNodes() {\r\n\r\n\t\tif (this.rowMetaInterface == null) {\r\n\t\t\tString theSql = this.databaseMeta.getSQLQueryFields(this.schemaTableCombo);\r\n\t\t\tGetQueryFieldsProgressDialog theProgressDialog = new GetQueryFieldsProgressDialog(this.shell, this.databaseMeta, theSql);\r\n\t\t\tthis.rowMetaInterface = theProgressDialog.open();\r\n\t\t}\r\n\r\n\t\tthis.model.setStepName(\"Step name:\" + this.schemaTableCombo);\r\n\r\n\t\tif (this.rowMetaInterface != null) {\r\n\t\t\tStepFieldNode theStep = null;\r\n\t\t\tfor (int i = 0; i < this.rowMetaInterface.size(); i++) {\r\n\t\t\t\ttheStep = new StepFieldNode();\r\n\t\t\t\tValueMetaInterface theMetaInterface = this.rowMetaInterface.getValueMeta(i);\r\n\t\t\t\ttheStep.setFieldName(theMetaInterface.getName());\r\n\t\t\t\ttheStep.setType(theMetaInterface.getTypeDesc());\r\n\t\t\t\ttheStep.setLength(Integer.toString(theMetaInterface.getLength()));\r\n\t\t\t\ttheStep.setPrecision(Integer.toString(theMetaInterface.getPrecision()));\r\n\t\t\t\ttheStep.setOrigin(theMetaInterface.getOrigin());\r\n\t\t\t\ttheStep.setStorageType(Integer.toString(theMetaInterface.getStorageType()));\r\n\t\t\t\ttheStep.setConversionMask(theMetaInterface.getConversionMask());\r\n\t\t\t\ttheStep.setDecimalSymbol(theMetaInterface.getDecimalSymbol());\r\n\t\t\t\ttheStep.setGroupingSymbol(theMetaInterface.getGroupingSymbol());\r\n\t\t\t\ttheStep.setTrimType(Integer.toString(theMetaInterface.getTrimType()));\r\n\t\t\t\ttheStep.setComments(theMetaInterface.getComments());\r\n\t\t\t\tthis.model.addStepField(theStep);\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getSelectedStep() {\r\n\t\treturn this.table;\r\n\t}","id":24794,"modified_method":"public String getSelectedStep() {\r\n\t\treturn this.schemaTableCombo;\r\n\t}","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public XulStepFieldsController(Shell aShell, DatabaseMeta aDatabaseMeta, String aTable, RowMetaInterface anInput) {\r\n\t\tthis.shell = aShell;\r\n\t\tthis.databaseMeta = aDatabaseMeta;\r\n\t\tthis.table = aTable;\r\n\t\tthis.bf = new DefaultBindingFactory();\r\n\t\tthis.model = new XulStepFieldsModel();\r\n\t\tthis.rowMetaInterface = anInput;\r\n\t}","id":24795,"modified_method":"public XulStepFieldsController(Shell aShell, DatabaseMeta aDatabaseMeta, String schemaTableCombo, RowMetaInterface anInput) {\r\n\t\tthis.shell = aShell;\r\n\t\tthis.databaseMeta = aDatabaseMeta;\r\n\t\tthis.schemaTableCombo = schemaTableCombo;\r\n\t\tthis.bf = new DefaultBindingFactory();\r\n\t\tthis.model = new XulStepFieldsModel();\r\n\t\tthis.rowMetaInterface = anInput;\r\n\t}","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void open(boolean isAcceptButtonHidden) {\r\n\t\ttry {\r\n\t\t\tSwtXulLoader theLoader = new SwtXulLoader();\r\n\t\t\ttheLoader.setOuterContext(this.shell);\r\n      theLoader.setSettingsManager(XulSpoonSettingsManager.getInstance());\r\n\t\t\tthis.container = theLoader.loadXul(XUL);\r\n\r\n\t\t\tthis.controller = new XulStepFieldsController(this.shell, this.databaseMeta, this.table, this.rowMeta);\r\n\t\t\tthis.controller.setShowAcceptButton(isAcceptButtonHidden);\r\n\t\t\tthis.container.addEventHandler(this.controller);\r\n\r\n\t\t\tthis.runner = new SwtXulRunner();\r\n\t\t\tthis.runner.addContainer(this.container);\r\n\t\t\tthis.runner.initialize();\r\n\r\n\t\t\tXulDialog thePreviewDialog = (XulDialog) this.container.getDocumentRoot().getElementById(\"stepFieldsDialog\");\r\n\t\t\tthePreviewDialog.show();\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.info(e);\r\n\t\t}\r\n\t}","id":24796,"modified_method":"public void open(boolean isAcceptButtonHidden) {\r\n\t\ttry {\r\n\t\t\tSwtXulLoader theLoader = new SwtXulLoader();\r\n\t\t\ttheLoader.setOuterContext(this.shell);\r\n\t\t\ttheLoader.setSettingsManager(XulSpoonSettingsManager.getInstance());\r\n\t\t\tthis.container = theLoader.loadXul(XUL);\r\n\r\n\t\t\tthis.controller = new XulStepFieldsController(this.shell, this.databaseMeta, this.schemaTableCombo, this.rowMeta);\r\n\t\t\tthis.controller.setShowAcceptButton(isAcceptButtonHidden);\r\n\t\t\tthis.container.addEventHandler(this.controller);\r\n\r\n\t\t\tthis.runner = new SwtXulRunner();\r\n\t\t\tthis.runner.addContainer(this.container);\r\n\t\t\tthis.runner.initialize();\r\n\r\n\t\t\tXulDialog thePreviewDialog = (XulDialog) this.container.getDocumentRoot().getElementById(\"stepFieldsDialog\");\r\n\t\t\tthePreviewDialog.show();\r\n\t\t} catch (Exception e) {\r\n\t\t\tlogger.info(e);\r\n\t\t}\r\n\t}","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public XulStepFieldsDialog(Shell aShell, int aStyle, DatabaseMeta aDatabaseMeta, String aTableName, RowMetaInterface anInput, String schemaName) {\r\n    this.shell = aShell;\r\n    if (StringUtils.isEmpty(schemaName)) {\r\n      this.table = aTableName;\r\n    } else {\r\n      this.table = aDatabaseMeta.getQuotedSchemaTableCombination(schemaName, aTableName);\r\n    }\r\n    this.databaseMeta = aDatabaseMeta;\r\n    this.rowMeta = anInput;\r\n  }","id":24797,"modified_method":"public XulStepFieldsDialog(Shell aShell, int aStyle, DatabaseMeta aDatabaseMeta, String aTableName, RowMetaInterface anInput, String schemaName) {\r\n      this.shell = aShell;\r\n      this.schemaTableCombo = aDatabaseMeta.getQuotedSchemaTableCombination(schemaName, aTableName);\r\n      this.databaseMeta = aDatabaseMeta;\r\n      this.rowMeta = anInput;\r\n    }","commit_id":"972e7fe264a168f96f30a945aa9504b1b889efc7","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  public void ack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    ackInternal(entryPointer, consumer, readPointer);\n    if(consumer.isStateful()) {\n      getQueueStateImpl(consumer.getQueueState()).setActiveEntryId(INVALID_ENTRY_ID);\n    }\n  }","id":24798,"modified_method":"@Override\n  public void ack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    ackInternal(entryPointer, consumer, readPointer);\n    if(consumer.isStateful()) {\n      QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n      queueState.setActiveEntryId(INVALID_ENTRY_ID);\n      queueState.setActiveEntryTries(0);\n    }\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"private static QueueStateImpl getQueueStateImpl(QueueState queueState) {\n    if(queueState == null) {\n      return null;\n    }\n    if(! (queueState instanceof QueueStateImpl)) {\n      throw new IllegalArgumentException(String.format(\"Don't know how to use QueueState %s\", queueState.getClass()));\n    }\n    return (QueueStateImpl) queueState;\n  }","id":24799,"modified_method":"private static QueueStateImpl getQueueStateImpl(QueueState queueState) throws OperationException {\n    if(queueState == null) {\n      return null;\n    }\n    if(! (queueState instanceof QueueStateImpl)) {\n      throw new OperationException(StatusCode.INTERNAL_ERROR,\n                                   String.format(\"Don't know how to use QueueState class %s\", queueState.getClass()));\n    }\n    return (QueueStateImpl) queueState;\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void unack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Ack gets rolled back with tries=0. Need to fix this by fixing point 2 above.\n    this.table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n      new byte[][] {makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId()), ACTIVE_ENTRY}, readPointer.getMaximum(),\n      new byte[][] {new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes(),\n                                                                        Bytes.toBytes(entryPointer.getEntryId())});\n    if(consumer.isStateful()) {\n      getQueueStateImpl(consumer.getQueueState()).setActiveEntryId(entryPointer.getEntryId());\n    }\n  }","id":24800,"modified_method":"@Override\n  public void unack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Ack gets rolled back with tries=0. Need to fix this by fixing point 2 above.\n    this.table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n      new byte[][] {makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId()), ACTIVE_ENTRY, ACTIVE_ENTRY_CRASH_TRIES},\n      readPointer.getMaximum(),\n      new byte[][] {new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes(),\n                                                         Bytes.toBytes(entryPointer.getEntryId()), Bytes.toBytes(0)});\n    if(consumer.isStateful()) {\n      getQueueStateImpl(consumer.getQueueState()).setActiveEntryId(entryPointer.getEntryId());\n    }\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void saveDequeueState(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      // Persist the entryId this consumer will be working on\n      // TODO: Later when active entry can saved in memory, there is no need to write it into HBase -> (not true for FIFO!)\n      long entryId = queueState.getActiveEntryId();\n\n      table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                     new byte[][]{\n                       CONSUMER_READ_POINTER,\n                       ACTIVE_ENTRY,\n                       makeColumnName(META_ENTRY_PREFIX, entryId)\n                     },\n                     readPointer.getMaximum(),\n                     new byte[][]{\n                       Bytes.toBytes(queueState.getConsumerReadPointer()),\n                       Bytes.toBytes(queueState.getActiveEntryId()),\n                       new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes()\n                     }\n      );\n    }","id":24801,"modified_method":"@Override\n    public void saveDequeueState(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      // Persist the entryId this consumer will be working on\n      // TODO: Later when active entry can saved in memory, there is no need to write it into HBase -> (not true for FIFO!)\n      long entryId = queueState.getActiveEntryId();\n\n      table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                     new byte[][]{\n                       CONSUMER_READ_POINTER,\n                       ACTIVE_ENTRY, ACTIVE_ENTRY_CRASH_TRIES,\n                       makeColumnName(META_ENTRY_PREFIX, entryId)\n                     },\n                     readPointer.getMaximum(),\n                     new byte[][]{\n                       Bytes.toBytes(queueState.getConsumerReadPointer()),\n                       Bytes.toBytes(queueState.getActiveEntryId()),\n                       Bytes.toBytes(queueState.getActiveEntryTries()),\n                       new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes()\n                     }\n      );\n    }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public QueueStateImpl constructQueueState(QueueConsumer consumer, QueueConfig config, ReadPointer readPointer)\n                                                       throws OperationException {\n      // ACTIVE_ENTRY contains the entry if any that is dequeued, but not acked\n      // CONSUMER_READ_POINTER + 1 points to the next entry that can be read by this queue consuemr\n      QueueStateImpl queueState = new QueueStateImpl();\n      OperationResult<Map<byte[], byte[]>> stateBytes =\n        table.get(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                       new byte[][] {ACTIVE_ENTRY, CONSUMER_READ_POINTER}, readPointer);\n      if(!stateBytes.isEmpty()) {\n        long activeEntryId = Bytes.toLong(stateBytes.getValue().get(ACTIVE_ENTRY));\n        // TODO: check max tries\n        queueState.setActiveEntryId(activeEntryId);\n\n        byte[] consumerReadPointerBytes = stateBytes.getValue().get(CONSUMER_READ_POINTER);\n        if(consumerReadPointerBytes != null) {\n          queueState.setConsumerReadPointer(Bytes.toLong(consumerReadPointerBytes));\n        }\n      }\n\n      // Read queue write pointer\n      // TODO: use raw Get instead of the workaround of incrementing zero\n      long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n      queueState.setQueueWritePointer(queueWritePointer);\n\n      // If active entry is present, read that from storage\n      if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n        readEntries(consumer, config, queueState, readPointer, Collections.singletonList(queueState.getActiveEntryId()));\n        // Set the active entry as the current entry\n        queueState.getCachedEntries().getNext();\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(String.format(\"Constructed new QueueState - %s\", queueState));\n      }\n      return queueState;\n    }","id":24802,"modified_method":"@Override\n    public QueueStateImpl constructQueueState(QueueConsumer consumer, QueueConfig config, ReadPointer readPointer)\n                                                       throws OperationException {\n      // ACTIVE_ENTRY contains the entry if any that is dequeued, but not acked\n      // CONSUMER_READ_POINTER + 1 points to the next entry that can be read by this queue consuemr\n      QueueStateImpl queueState = new QueueStateImpl();\n      OperationResult<Map<byte[], byte[]>> stateBytes =\n        table.get(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                       new byte[][] {ACTIVE_ENTRY, ACTIVE_ENTRY_CRASH_TRIES, CONSUMER_READ_POINTER}, readPointer);\n      if(!stateBytes.isEmpty()) {\n        queueState.setActiveEntryId(Bytes.toLong(stateBytes.getValue().get(ACTIVE_ENTRY)));\n        queueState.setActiveEntryTries(Bytes.toInt(stateBytes.getValue().get(ACTIVE_ENTRY_CRASH_TRIES)));\n\n        byte[] consumerReadPointerBytes = stateBytes.getValue().get(CONSUMER_READ_POINTER);\n        if(consumerReadPointerBytes != null) {\n          queueState.setConsumerReadPointer(Bytes.toLong(consumerReadPointerBytes));\n        }\n      }\n\n      // Read queue write pointer\n      // TODO: use raw Get instead of the workaround of incrementing zero\n      long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n      queueState.setQueueWritePointer(queueWritePointer);\n\n      // If active entry is present, read that from storage\n      // This is the crash recovery case, the consumer has stopped processing before acking the previous dequeue\n      if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n        if(queueState.getActiveEntryTries() < MAX_CRASH_DEQUEUE_TRIES) {\n          queueState.setActiveEntryTries(queueState.getActiveEntryTries() + 1);\n          readEntries(consumer, config, queueState, readPointer, Collections.singletonList(queueState.getActiveEntryId()));\n          // Set the active entry as the current entry\n          queueState.getCachedEntries().getNext();\n        } else {\n          // TODO: what do we do with the active entry?\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"Ignoring dequeue of entry %d after %d tries\", queueState.getActiveEntryId(), MAX_CRASH_DEQUEUE_TRIES));\n          }\n          queueState.setActiveEntryId(INVALID_ENTRY_ID);\n          queueState.setActiveEntryTries(0);\n        }\n      }\n      if(LOG.isDebugEnabled()) {\n        LOG.debug(String.format(\"Constructed new QueueState - %s\", queueState));\n      }\n      return queueState;\n    }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isDebugEnabled())\n      LOG.debug(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\");\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final QueuePartitioner queuePartitioner = config.getPartitionerType().getPartitioner();\n    DequeueStrategy dequeueStrategy;\n    if(queuePartitioner instanceof QueuePartitioner.HashPartitioner) {\n      dequeueStrategy = new HashDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.RoundRobinPartitioner) {\n      dequeueStrategy = new RoundRobinDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.FifoPartitioner) {\n      dequeueStrategy = new FifoDequeueStrategy();\n    } else {\n      throw new IllegalStateException(\n        String.format(\"Cannot figure out the dequeue strategy to use for partitioner %s\", queuePartitioner.getClass()));\n    }\n\n    // If QueueState is null, read the queue state from underlying storage.\n    QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, config, readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // If the previous entry was not acked, return the same one (Note: will need to change for async mode)\n    if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n      if(!queueState.getCachedEntries().hasCurrent()) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, \"Queue state error - cannot fetch active entry id from cached entries\");\n      }\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getCurrent();\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                      new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getCachedEntries().hasNext()) {\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getCachedEntries().hasNext()) {\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getNext();\n      this.dequeueReturns.incrementAndGet();\n      queueState.setActiveEntryId(cachedEntry.getEntryId());\n      queueState.setConsumerReadPointer(cachedEntry.getEntryId());\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"End of queue reached using \" + \"read pointer \" + readPointer);\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","id":24803,"modified_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isDebugEnabled())\n      LOG.debug(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\");\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final QueuePartitioner queuePartitioner = config.getPartitionerType().getPartitioner();\n    DequeueStrategy dequeueStrategy;\n    if(queuePartitioner instanceof QueuePartitioner.HashPartitioner) {\n      dequeueStrategy = new HashDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.RoundRobinPartitioner) {\n      dequeueStrategy = new RoundRobinDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.FifoPartitioner) {\n      dequeueStrategy = new FifoDequeueStrategy();\n    } else {\n      throw new OperationException(StatusCode.INTERNAL_ERROR,\n        String.format(\"Cannot figure out the dequeue strategy to use for partitioner %s\", queuePartitioner.getClass()));\n    }\n\n    // If QueueState is null, read the queue state from underlying storage.\n    QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, config, readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // If the previous entry was not acked, return the same one (Note: will need to change for async mode)\n    if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n      if(!queueState.getCachedEntries().hasCurrent()) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, \"Queue state error - cannot fetch active entry id from cached entries\");\n      }\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getCurrent();\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                      new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getCachedEntries().hasNext()) {\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getCachedEntries().hasNext()) {\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getNext();\n      this.dequeueReturns.incrementAndGet();\n      queueState.setActiveEntryId(cachedEntry.getEntryId());\n      queueState.setConsumerReadPointer(cachedEntry.getEntryId());\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"End of queue reached using \" + \"read pointer \" + readPointer);\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"public void ackInternal(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Use Transaction.getWriteVersion instead ReadPointer\n    QueuePartitioner partitioner=consumer.getQueueConfig().getPartitionerType().getPartitioner();\n\n    if (partitioner.isDisjoint()) {\n      this.table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                     new byte[][] {makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId()), ACTIVE_ENTRY},\n                     readPointer.getMaximum(),\n                     new byte[][] {new EntryConsumerMeta(EntryConsumerMeta.EntryState.ACKED, 0).getBytes(), INVALID_ENTRY_ID_BYTES});\n    } else {\n\n      byte[] rowKey = makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId());\n      byte[] colKey = makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId());\n      byte[] acked = new EntryConsumerMeta(EntryConsumerMeta.EntryState.ACKED, 0).getBytes();\n\n      // verify it is not acked yet\n      OperationResult<byte[]> result = this.table.get(rowKey, colKey, readPointer);\n      if (result.isEmpty()) {\n        throw new OperationException(StatusCode.ILLEGAL_ACK, \"Entry has never been claimed. \");\n      }\n      EntryConsumerMeta meta = EntryConsumerMeta.fromBytes(result.getValue());\n      if (!meta.isClaimed()) {\n        throw new OperationException(StatusCode.ILLEGAL_ACK, \"Entry is \" + meta.getState().name());\n      }\n      // now put the new value\n      this.table.put(rowKey,\n                     new byte[][] { colKey, ACTIVE_ENTRY },\n                     readPointer.getMaximum(),\n                     new byte[][] { acked, INVALID_ENTRY_ID_BYTES} );\n    }\n  }","id":24804,"modified_method":"public void ackInternal(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Use Transaction.getWriteVersion instead ReadPointer\n    QueuePartitioner partitioner=consumer.getQueueConfig().getPartitionerType().getPartitioner();\n\n    if (partitioner.isDisjoint()) {\n      this.table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                     new byte[][] {makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId()), ACTIVE_ENTRY, ACTIVE_ENTRY_CRASH_TRIES},\n                     readPointer.getMaximum(),\n                     new byte[][] {new EntryConsumerMeta(EntryConsumerMeta.EntryState.ACKED, 0).getBytes(), INVALID_ENTRY_ID_BYTES, Bytes.toBytes(0)});\n    } else {\n\n      byte[] rowKey = makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId());\n      byte[] colKey = makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId());\n      byte[] acked = new EntryConsumerMeta(EntryConsumerMeta.EntryState.ACKED, 0).getBytes();\n\n      // verify it is not acked yet\n      OperationResult<byte[]> result = this.table.get(rowKey, colKey, readPointer);\n      if (result.isEmpty()) {\n        throw new OperationException(StatusCode.ILLEGAL_ACK, \"Entry has never been claimed. \");\n      }\n      EntryConsumerMeta meta = EntryConsumerMeta.fromBytes(result.getValue());\n      if (!meta.isClaimed()) {\n        throw new OperationException(StatusCode.ILLEGAL_ACK, \"Entry is \" + meta.getState().name());\n      }\n      // now put the new value\n      this.table.put(rowKey,\n                     new byte[][] { colKey, ACTIVE_ENTRY },\n                     readPointer.getMaximum(),\n                     new byte[][] { acked, INVALID_ENTRY_ID_BYTES} );\n    }\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public List<Long> fetchNextEntries(\n      QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      outerLoop:\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"New queueWritePointer = %d\", queueWritePointer));\n          }\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        long startEntryId = entryId + 1;\n        long endEntryId =\n                startEntryId + (config.getBatchSize() * consumer.getGroupSize()) < queueState.getQueueWritePointer() ?\n                    startEntryId + (config.getBatchSize() * consumer.getGroupSize()) : queueState.getQueueWritePointer();\n\n        // Read  header data from underlying storage, if any\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n        final String partitioningKey = consumer.getPartitioningKey();\n        if(partitioningKey == null || partitioningKey.isEmpty()) {\n          throw new IllegalStateException(String.format(\"Using Hash Partitioning with null/empty partitioningKey!\"));\n        }\n        final byte [][] rowKeys = new byte[cacheSize][];\n        for(int id = 0; id < cacheSize; ++id) {\n          rowKeys[id] = makeRowKey(GLOBAL_DATA_PREFIX, startEntryId + id);\n        }\n        final byte[][] columnKeys = new byte[1][];\n        columnKeys[0] = makeColumnName(ENTRY_HEADER, partitioningKey);\n        OperationResult<Map<byte[], Map<byte[], byte[]>>> headerResult = table.get(rowKeys, columnKeys, readPointer);\n\n        // Determine which entries  need to be read from storage\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if (!headerResult.isEmpty()) {\n            Map<byte[], Map<byte[], byte[]>> headerValue = headerResult.getValue();\n            Map<byte[], byte[]> headerMap = headerValue.get(rowKeys[id]);\n            if(headerMap == null) {\n              break outerLoop;\n            }\n            byte[] hashBytes = headerMap.get(columnKeys[0]);\n            if(hashBytes == null) {\n              break outerLoop;\n            }\n            int hashValue = Bytes.toInt(hashBytes);\n            if(partitioner.shouldEmit(consumer, currentEntryId, hashValue)) {\n              newEntryIds.add(currentEntryId);\n            }\n          } else {\n            // Not able to read header\n            break outerLoop;\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","id":24805,"modified_method":"@Override\n    public List<Long> fetchNextEntries(\n      QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      long entryId = queueState.getConsumerReadPointer();\n      QueuePartitioner partitioner=config.getPartitionerType().getPartitioner();\n      List<Long> newEntryIds = new ArrayList<Long>();\n\n      outerLoop:\n      while (newEntryIds.isEmpty()) {\n        if(entryId >= queueState.getQueueWritePointer()) {\n          // Reached the end of queue as per cached QueueWritePointer,\n          // read it again to see if there is any progress made by producers\n          // TODO: use raw Get instead of the workaround of incrementing zero\n          long queueWritePointer = table.incrementAtomicDirtily(makeRowName(GLOBAL_ENTRY_ID_PREFIX), GLOBAL_ENTRYID_COUNTER, 0);\n          queueState.setQueueWritePointer(queueWritePointer);\n          if(LOG.isDebugEnabled()) {\n            LOG.debug(String.format(\"New queueWritePointer = %d\", queueWritePointer));\n          }\n          // If still no progress, return empty queue\n          if(entryId >= queueState.getQueueWritePointer()) {\n            return Collections.EMPTY_LIST;\n          }\n        }\n\n        long startEntryId = entryId + 1;\n        long endEntryId =\n                startEntryId + (config.getBatchSize() * consumer.getGroupSize()) < queueState.getQueueWritePointer() ?\n                    startEntryId + (config.getBatchSize() * consumer.getGroupSize()) : queueState.getQueueWritePointer();\n\n        // Read  header data from underlying storage, if any\n        final int cacheSize = (int)(endEntryId - startEntryId + 1);\n        final String partitioningKey = consumer.getPartitioningKey();\n        if(partitioningKey == null || partitioningKey.isEmpty()) {\n          throw new OperationException(StatusCode.INTERNAL_ERROR, String.format(\"Using Hash Partitioning with null/empty partitioningKey!\"));\n        }\n        final byte [][] rowKeys = new byte[cacheSize][];\n        for(int id = 0; id < cacheSize; ++id) {\n          rowKeys[id] = makeRowKey(GLOBAL_DATA_PREFIX, startEntryId + id);\n        }\n        final byte[][] columnKeys = new byte[1][];\n        columnKeys[0] = makeColumnName(ENTRY_HEADER, partitioningKey);\n        OperationResult<Map<byte[], Map<byte[], byte[]>>> headerResult = table.get(rowKeys, columnKeys, readPointer);\n\n        // Determine which entries  need to be read from storage\n        for(int id = 0; id < cacheSize; ++id) {\n          final long currentEntryId = startEntryId + id;\n          if (!headerResult.isEmpty()) {\n            Map<byte[], Map<byte[], byte[]>> headerValue = headerResult.getValue();\n            Map<byte[], byte[]> headerMap = headerValue.get(rowKeys[id]);\n            if(headerMap == null) {\n              break outerLoop;\n            }\n            byte[] hashBytes = headerMap.get(columnKeys[0]);\n            if(hashBytes == null) {\n              break outerLoop;\n            }\n            int hashValue = Bytes.toInt(hashBytes);\n            if(partitioner.shouldEmit(consumer, currentEntryId, hashValue)) {\n              newEntryIds.add(currentEntryId);\n            }\n          } else {\n            // Not able to read header\n            break outerLoop;\n          }\n        }\n        entryId = endEntryId;\n      }\n      return newEntryIds;\n    }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSingleConsumerWithHashPartitioning() throws Exception {\n    final String HASH_KEY = \"hashKey\";\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = 1;\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(\"value\" + i % numConsumers));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue it with HASH partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.HASH, singleEntry);\n\n    QueueConsumer[] consumers = new QueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new QueueConsumer(i, consumerGroupId, numConsumers, \"group1\", HASH_KEY, config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(\"value\" + i % numConsumers));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries);\n  }","id":24806,"modified_method":"@Test\n  public void testSingleConsumerWithHashPartitioning() throws Exception {\n    final String HASH_KEY = \"hashKey\";\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = getDirtyWriteVersion();\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(\"value\" + i % numConsumers));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue it with HASH partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.HASH, singleEntry);\n\n    QueueConsumer[] consumers = new QueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new QueueConsumer(i, consumerGroupId, numConsumers, \"group1\", HASH_KEY, config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(\"value\" + i % numConsumers));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries);\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSingleStatefulConsumerWithRoundRobinPartitioning() throws Exception {\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = 1;\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i + 1));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue it with ROUND_ROBIN partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.ROUND_ROBIN, singleEntry);\n\n    StatefulQueueConsumer[] consumers = new StatefulQueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new StatefulQueueConsumer(i, consumerGroupId, numConsumers, \"group1\", config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, 0, QueuePartitioner.PartitionerType.ROUND_ROBIN);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i + 1));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, numQueueEntries, QueuePartitioner.PartitionerType.ROUND_ROBIN);\n  }","id":24807,"modified_method":"@Test\n  public void testSingleStatefulConsumerWithRoundRobinPartitioning() throws Exception {\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = getDirtyWriteVersion();\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i + 1));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue it with ROUND_ROBIN partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.ROUND_ROBIN, singleEntry);\n\n    StatefulQueueConsumer[] consumers = new StatefulQueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new StatefulQueueConsumer(i, consumerGroupId, numConsumers, \"group1\", config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, 0, QueuePartitioner.PartitionerType.ROUND_ROBIN);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i + 1));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, numQueueEntries, QueuePartitioner.PartitionerType.ROUND_ROBIN);\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSingleStatefulConsumerWithHashPartitioning() throws Exception {\n    final String HASH_KEY = \"hashKey\";\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = 1;\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue it with HASH partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.HASH, singleEntry);\n\n    StatefulQueueConsumer[] consumers = new StatefulQueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new StatefulQueueConsumer(i, consumerGroupId, numConsumers, \"group1\", HASH_KEY, config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, 0, QueuePartitioner.PartitionerType.HASH);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, numQueueEntries, QueuePartitioner.PartitionerType.HASH);\n  }","id":24808,"modified_method":"@Test\n  public void testSingleStatefulConsumerWithHashPartitioning() throws Exception {\n    final String HASH_KEY = \"hashKey\";\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = getDirtyWriteVersion();\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue it with HASH partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.HASH, singleEntry);\n\n    StatefulQueueConsumer[] consumers = new StatefulQueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new StatefulQueueConsumer(i, consumerGroupId, numConsumers, \"group1\", HASH_KEY, config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, 0, QueuePartitioner.PartitionerType.HASH);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, numQueueEntries, QueuePartitioner.PartitionerType.HASH);\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSingleConsumerWithRoundRobinPartitioning() throws Exception {\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = 1;\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(\"value\" + (i + 1) % numConsumers));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue it with ROUND_ROBIN partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.ROUND_ROBIN, singleEntry);\n\n    QueueConsumer[] consumers = new QueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new QueueConsumer(i, consumerGroupId, numConsumers, \"group1\", config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(\"value\" + (i + 1) % numConsumers));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries);\n  }","id":24809,"modified_method":"@Test\n  public void testSingleConsumerWithRoundRobinPartitioning() throws Exception {\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = getDirtyWriteVersion();\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(\"value\" + (i + 1) % numConsumers));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue it with ROUND_ROBIN partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.ROUND_ROBIN, singleEntry);\n\n    QueueConsumer[] consumers = new QueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new QueueConsumer(i, consumerGroupId, numConsumers, \"group1\", config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(\"value\" + (i + 1) % numConsumers));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries);\n  }","commit_id":"881f124196fee305eaf1322500c8c98e8667355d","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isDebugEnabled())\n      LOG.debug(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\");\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final QueuePartitioner queuePartitioner = config.getPartitionerType().getPartitioner();\n    DequeueStrategy dequeueStrategy;\n    if(queuePartitioner instanceof QueuePartitioner.HashPartitioner) {\n      dequeueStrategy = new HashDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.RoundRobinPartitioner) {\n      dequeueStrategy = new RoundRobinDequeueStrategy();\n    } else if(queuePartitioner instanceof QueuePartitioner.FifoPartitioner) {\n      dequeueStrategy = new FifoDequeueStrategy();\n    } else {\n      throw new OperationException(StatusCode.INTERNAL_ERROR,\n        String.format(\"Cannot figure out the dequeue strategy to use for partitioner %s\", queuePartitioner.getClass()));\n    }\n\n    // If QueueState is null, read the queue state from underlying storage.\n    QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, config, readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // If the previous entry was not acked, return the same one (Note: will need to change for async mode)\n    if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n      if(!queueState.getCachedEntries().hasCurrent()) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, \"Queue state error - cannot fetch active entry id from cached entries\");\n      }\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getCurrent();\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                      new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getCachedEntries().hasNext()) {\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getCachedEntries().hasNext()) {\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getNext();\n      this.dequeueReturns.incrementAndGet();\n      queueState.setActiveEntryId(cachedEntry.getEntryId());\n      queueState.setConsumerReadPointer(cachedEntry.getEntryId());\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"End of queue reached using \" + \"read pointer \" + readPointer);\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","id":24810,"modified_method":"@Override\n  public DequeueResult dequeue(QueueConsumer consumer, ReadPointer readPointer) throws OperationException {\n    final QueueConfig config = consumer.getQueueConfig();\n    if (LOG.isDebugEnabled())\n      LOG.debug(\"Attempting dequeue [curNumDequeues=\" + this.dequeueReturns.get() +\n                  \"] (\" + consumer + \", \" + config + \", \" + readPointer + \")\");\n\n    // Determine what dequeue strategy to use based on the partitioner\n    final DequeueStrategy dequeueStrategy = getDequeueStrategy(config.getPartitionerType().getPartitioner());\n\n    // If QueueState is null, read the queue state from underlying storage.\n    QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, config, readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // If the previous entry was not acked, return the same one (Note: will need to change for async mode)\n    if(queueState.getActiveEntryId() != INVALID_ENTRY_ID) {\n      if(!queueState.getCachedEntries().hasCurrent()) {\n        throw new OperationException(StatusCode.INTERNAL_ERROR, \"Queue state error - cannot fetch active entry id from cached entries\");\n      }\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getCurrent();\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                                                      new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    }\n\n    // If no more cached entries, read entries from storage\n    if(!queueState.getCachedEntries().hasNext()) {\n      List<Long> entryIds = dequeueStrategy.fetchNextEntries(consumer, config, queueState, readPointer);\n      readEntries(consumer, config, queueState, readPointer, entryIds);\n    }\n\n    if(queueState.getCachedEntries().hasNext()) {\n      QueueStateEntry cachedEntry = queueState.getCachedEntries().getNext();\n      this.dequeueReturns.incrementAndGet();\n      queueState.setActiveEntryId(cachedEntry.getEntryId());\n      queueState.setConsumerReadPointer(cachedEntry.getEntryId());\n      QueueEntry entry = new QueueEntry(cachedEntry.getData());\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.SUCCESS,\n                               new QueueEntryPointer(this.queueName, cachedEntry.getEntryId()), entry);\n      return dequeueResult;\n    } else {\n      // No queue entries available to dequue, return queue empty\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"End of queue reached using \" + \"read pointer \" + readPointer);\n      }\n      dequeueStrategy.saveDequeueState(consumer, config, queueState, readPointer);\n      DequeueResult dequeueResult = new DequeueResult(DequeueResult.DequeueStatus.EMPTY);\n      return dequeueResult;\n    }\n  }","commit_id":"261cb3577d094c3c3a3cf74829e84608249b4034","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void unack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Ack gets rolled back with tries=0. Need to fix this by fixing point 2 above.\n    this.table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n      new byte[][] {makeColumnName(META_ENTRY_PREFIX, entryPointer.getEntryId()), ACTIVE_ENTRY, ACTIVE_ENTRY_CRASH_TRIES},\n      readPointer.getMaximum(),\n      new byte[][] {new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes(),\n                                                         Bytes.toBytes(entryPointer.getEntryId()), Bytes.toBytes(0)});\n    if(consumer.isStateful()) {\n      getQueueStateImpl(consumer.getQueueState()).setActiveEntryId(entryPointer.getEntryId());\n    }\n  }","id":24811,"modified_method":"@Override\n  public void unack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Ack gets rolled back with tries=0. Need to fix this by fixing point 2 above.\n\n    QueuePartitioner partitioner = consumer.getQueueConfig().getPartitionerType().getPartitioner();\n    final DequeueStrategy dequeueStrategy = getDequeueStrategy(partitioner);\n\n    // Get queue state\n    QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, consumer.getQueueConfig(), readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // Set unack state\n    queueState.setActiveEntryId(entryPointer.getEntryId());\n    queueState.setActiveEntryTries(0);\n\n    // Write unack state\n    dequeueStrategy.saveDequeueState(consumer, consumer.getQueueConfig(), queueState, readPointer);\n  }","commit_id":"261cb3577d094c3c3a3cf74829e84608249b4034","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    public void saveDequeueState(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      // Persist the entryId this consumer will be working on\n      // TODO: Later when active entry can saved in memory, there is no need to write it into HBase -> (not true for FIFO!)\n      long entryId = queueState.getActiveEntryId();\n\n      table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                     new byte[][]{\n                       CONSUMER_READ_POINTER,\n                       ACTIVE_ENTRY, ACTIVE_ENTRY_CRASH_TRIES,\n                       makeColumnName(META_ENTRY_PREFIX, entryId)\n                     },\n                     readPointer.getMaximum(),\n                     new byte[][]{\n                       Bytes.toBytes(queueState.getConsumerReadPointer()),\n                       Bytes.toBytes(queueState.getActiveEntryId()),\n                       Bytes.toBytes(queueState.getActiveEntryTries()),\n                       new EntryConsumerMeta(EntryConsumerMeta.EntryState.CLAIMED, 0).getBytes()\n                     }\n      );\n    }","id":24812,"modified_method":"@Override\n    public void saveDequeueState(QueueConsumer consumer, QueueConfig config, QueueStateImpl queueState, ReadPointer readPointer) throws OperationException {\n      // Persist the entryId this consumer will be working on\n      // TODO: Later when active entry can saved in memory, there is no need to write it into HBase -> (not true for FIFO!)\n      long entryId = queueState.getActiveEntryId();\n\n      table.put(makeRowKey(CONSUMER_META_PREFIX, consumer.getGroupId(), consumer.getInstanceId()),\n                     new byte[][]{\n                       CONSUMER_READ_POINTER,\n                       ACTIVE_ENTRY,\n                       ACTIVE_ENTRY_CRASH_TRIES\n                     },\n                     readPointer.getMaximum(),\n                     new byte[][]{\n                       Bytes.toBytes(queueState.getConsumerReadPointer()),\n                       Bytes.toBytes(queueState.getActiveEntryId()),\n                       Bytes.toBytes(queueState.getActiveEntryTries())\n                     }\n      );\n    }","commit_id":"261cb3577d094c3c3a3cf74829e84608249b4034","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void ack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    ackInternal(entryPointer, consumer, readPointer);\n    if(consumer.isStateful()) {\n      QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n      queueState.setActiveEntryId(INVALID_ENTRY_ID);\n      queueState.setActiveEntryTries(0);\n    }\n  }","id":24813,"modified_method":"@Override\n  public void ack(QueueEntryPointer entryPointer, QueueConsumer consumer, ReadPointer readPointer)\n    throws OperationException {\n    // TODO: 1. Later when active entry can saved in memory, there is no need to write it into HBase\n    // TODO: 2. Need to treat Ack as a simple write operation so that it can use a simple write rollback for unack\n    // TODO: 3. Use Transaction.getWriteVersion instead ReadPointer\n\n    QueuePartitioner partitioner = consumer.getQueueConfig().getPartitionerType().getPartitioner();\n    final DequeueStrategy dequeueStrategy = getDequeueStrategy(partitioner);\n\n    // Get queue state\n    QueueStateImpl queueState = getQueueStateImpl(consumer.getQueueState());\n    if(queueState == null) {\n      queueState = dequeueStrategy.constructQueueState(consumer, consumer.getQueueConfig(), readPointer);\n      consumer.setQueueState(queueState);\n    }\n\n    // Only the entry that has been dequeued (active entry) can be acked\n    if(queueState.getActiveEntryId() != entryPointer.getEntryId()) {\n      throw new OperationException(StatusCode.ILLEGAL_ACK, String.format(\n        \"Entry %d is not the active entry. Current active entry is %d\",\n        entryPointer.getEntryId(), queueState.getActiveEntryId()));\n    }\n\n    // Set ack state\n    queueState.setActiveEntryId(INVALID_ENTRY_ID);\n    queueState.setActiveEntryTries(0);\n\n    // Write ack state\n    dequeueStrategy.saveDequeueState(consumer, consumer.getQueueConfig(), queueState, readPointer);\n  }","commit_id":"261cb3577d094c3c3a3cf74829e84608249b4034","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSingleStatefulConsumerWithHashPartitioning() throws Exception {\n    final String HASH_KEY = \"hashKey\";\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = getDirtyWriteVersion();\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue it with HASH partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.HASH, singleEntry);\n\n    StatefulQueueConsumer[] consumers = new StatefulQueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new StatefulQueueConsumer(i, consumerGroupId, numConsumers, \"group1\", HASH_KEY, config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, 0, QueuePartitioner.PartitionerType.HASH);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, numQueueEntries, QueuePartitioner.PartitionerType.HASH);\n  }","id":24814,"modified_method":"@Test\n  public void testSingleStatefulConsumerWithHashPartitioning() throws Exception {\n    final String HASH_KEY = \"hashKey\";\n    final boolean singleEntry = true;\n    final int numQueueEntries = 264;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = getDirtyWriteVersion();\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue it with HASH partitioner\n    // TODO: test with more batch sizes\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.HASH, singleEntry, 29);\n\n    StatefulQueueConsumer[] consumers = new StatefulQueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new StatefulQueueConsumer(i, consumerGroupId, numConsumers, \"group1\", HASH_KEY, config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, 0, QueuePartitioner.PartitionerType.HASH);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i));\n      queueEntry.addPartitioningKey(HASH_KEY, i);\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, numQueueEntries, QueuePartitioner.PartitionerType.HASH);\n  }","commit_id":"261cb3577d094c3c3a3cf74829e84608249b4034","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testSingleStatefulConsumerWithRoundRobinPartitioning() throws Exception {\n    final boolean singleEntry = true;\n    final int numQueueEntries = 88;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = getDirtyWriteVersion();\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i + 1));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue it with ROUND_ROBIN partitioner\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.ROUND_ROBIN, singleEntry);\n\n    StatefulQueueConsumer[] consumers = new StatefulQueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new StatefulQueueConsumer(i, consumerGroupId, numConsumers, \"group1\", config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, 0, QueuePartitioner.PartitionerType.ROUND_ROBIN);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i + 1));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, numQueueEntries, QueuePartitioner.PartitionerType.ROUND_ROBIN);\n  }","id":24815,"modified_method":"@Test\n  public void testSingleStatefulConsumerWithRoundRobinPartitioning() throws Exception {\n    final boolean singleEntry = true;\n    final int numQueueEntries = 264;\n    final int numConsumers = 4;\n    final int consumerGroupId = 0;\n    TTQueue queue = createQueue();\n    long dirtyVersion = getDirtyWriteVersion();\n\n    // enqueue some entries\n    for (int i = 0; i < numQueueEntries; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i + 1));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue it with ROUND_ROBIN partitioner\n    // TODO: test with more batch sizes\n    QueueConfig config = new QueueConfig(QueuePartitioner.PartitionerType.ROUND_ROBIN, singleEntry, 11);\n\n    StatefulQueueConsumer[] consumers = new StatefulQueueConsumer[numConsumers];\n    for (int i = 0; i < numConsumers; i++) {\n      consumers[i] = new StatefulQueueConsumer(i, consumerGroupId, numConsumers, \"group1\", config);\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, 0, QueuePartitioner.PartitionerType.ROUND_ROBIN);\n\n    // enqueue some more entries\n    for (int i = numQueueEntries; i < numQueueEntries * 2; i++) {\n      QueueEntry queueEntry = new QueueEntry(Bytes.toBytes(i + 1));\n      assertTrue(queue.enqueue(queueEntry, dirtyVersion).isSuccess());\n    }\n\n    // dequeue and verify\n    dequeuePartitionedEntries(queue, consumers, numConsumers, numQueueEntries, numQueueEntries, QueuePartitioner.PartitionerType.ROUND_ROBIN);\n  }","commit_id":"261cb3577d094c3c3a3cf74829e84608249b4034","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n    protected String getKey()\n    {\n        EntityReference reference = getCurrentReference();\n\n        return reference != null ? reference.getType().toString().toLowerCase() + \":\"\n            + this.serializer.serialize(reference) : null;\n    }","id":24816,"modified_method":"@Override\n    protected String getKey()\n    {\n        EntityReference reference = getCurrentReference();\n\n        return reference != null ? reference.getType().getLowerCase() + ':' + this.serializer.serialize(reference)\n            : null;\n    }","commit_id":"b2fcae807986846c7a102652da5badf1b97fbf6e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param entityReference the reference of the entity\n     * @return the Solr resolver associated to the entity type\n     * @throws SolrIndexerException if any error\n     */\n    protected SolrReferenceResolver getResolver(EntityReference entityReference) throws SolrIndexerException\n    {\n        try {\n            return this.componentManager.getInstance(SolrReferenceResolver.class, entityReference.getType().toString()\n                .toLowerCase());\n        } catch (ComponentLookupException e) {\n            throw new SolrIndexerException(\"Faile to find solr reference resolver for type reference [\"\n                + entityReference + \"]\");\n        }\n    }","id":24817,"modified_method":"/**\n     * @param entityReference the reference of the entity\n     * @return the Solr resolver associated to the entity type\n     * @throws SolrIndexerException if any error\n     */\n    protected SolrReferenceResolver getResolver(EntityReference entityReference) throws SolrIndexerException\n    {\n        try {\n            return this.componentManager.getInstance(SolrReferenceResolver.class, entityReference.getType()\n                .getLowerCase());\n        } catch (ComponentLookupException e) {\n            throw new SolrIndexerException(\"Faile to find solr reference resolver for type reference [\"\n                + entityReference + \"]\");\n        }\n    }","commit_id":"b2fcae807986846c7a102652da5badf1b97fbf6e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * @param reference the reference\n     * @return the resolver associated to the reference type\n     * @throws SolrIndexerException when failed to find a resolve associated to the passed reference\n     */\n    private SolrReferenceResolver getResover(EntityReference reference) throws SolrIndexerException\n    {\n        EntityType type = reference.getType();\n\n        SolrReferenceResolver resolver;\n        try {\n            resolver = this.componentManager.getInstance(SolrReferenceResolver.class, type.name().toLowerCase());\n        } catch (ComponentLookupException e) {\n            throw new SolrIndexerException(\"Failed to get SolrDocumentReferenceResolver corresponding to entity type [\"\n                + type + \"]\", e);\n        }\n\n        return resolver;\n    }","id":24818,"modified_method":"/**\n     * @param reference the reference\n     * @return the resolver associated to the reference type\n     * @throws SolrIndexerException when failed to find a resolve associated to the passed reference\n     */\n    private SolrReferenceResolver getResover(EntityReference reference) throws SolrIndexerException\n    {\n        EntityType type = reference.getType();\n\n        SolrReferenceResolver resolver;\n        try {\n            resolver = this.componentManager.getInstance(SolrReferenceResolver.class, type.getLowerCase());\n        } catch (ComponentLookupException e) {\n            throw new SolrIndexerException(\"Failed to get SolrDocumentReferenceResolver corresponding to entity type [\"\n                + type + \"]\", e);\n        }\n\n        return resolver;\n    }","commit_id":"b2fcae807986846c7a102652da5badf1b97fbf6e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(64);\n        sb.append(StringUtils.capitalize(StringUtils.lowerCase(getType().toString())));\n        sb.append(' ');\n        sb.append(TOSTRING_SERIALIZER.serialize(this));\n        return sb.toString();\n    }","id":24819,"modified_method":"@Override\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder(64);\n        sb.append(StringUtils.capitalize(getType().getLowerCase()));\n        sb.append(' ');\n        sb.append(TOSTRING_SERIALIZER.serialize(this));\n        return sb.toString();\n    }","commit_id":"b2fcae807986846c7a102652da5badf1b97fbf6e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    protected String convertToString(EntityReference value)\n    {\n        if (value == null) {\n            return null;\n        }\n\n        return value.getType().toString().toLowerCase() + ':' + this.serialier.serialize(value);\n    }","id":24820,"modified_method":"@Override\n    protected String convertToString(EntityReference value)\n    {\n        if (value == null) {\n            return null;\n        }\n\n        return value.getType().getLowerCase() + ':' + this.serialier.serialize(value);\n    }","commit_id":"b2fcae807986846c7a102652da5badf1b97fbf6e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Set the value of the loopback property on the transport layer.\n     * \n     * @param ch\n     * @param loopback\n     * @throws Exception\n     */\n    private void setLoopbackProperty(JChannel ch, boolean loopback) throws Exception {\n\n    \tTP transport =  (TP) ch.getProtocolStack().getTransport() ;\n    \tif (transport == null) {\n    \t\tthrow new Exception(\"transport layer is not present - check default stack configuration\") ;\n    \t}\n\n    \t// check if already set correctly\n    \tif ((loopback && transport.isLoopback()) || (!loopback && !transport.isLoopback()))\n    \t\treturn ;\n\n    \t// otherwise, set it\n    \ttransport.setLoopback(loopback);\n    }","id":24821,"modified_method":"/**\n     * Set the value of the loopback property on the transport layer.\n     * \n     * @param ch\n     * @param loopback\n     * @throws Exception\n     */\n    private static void setLoopbackProperty(JChannel ch, boolean loopback) throws Exception {\n\n    \tTP transport =ch.getProtocolStack().getTransport();\n    \tif (transport == null) {\n    \t\tthrow new Exception(\"transport layer is not present - check default stack configuration\") ;\n    \t}\n\n    \t// check if already set correctly\n    \tif ((loopback && transport.isLoopback()) || (!loopback && !transport.isLoopback()))\n    \t\treturn ;\n\n    \t// otherwise, set it\n    \ttransport.setLoopback(loopback);\n    }","commit_id":"f02fb9a89207e30a2dc5eaec9fdaa39c49909523","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Tests that when UNICAST messages are sent with TP.loopback == true, the following \n     * conditions hold:\n     * (i) no messages touch the network\n     * (ii) all messages are correctly received\n     * \n     * @throws ChannelException\n     * @throws ChannelClosedException\n     * @throws ChannelNotConnectedException\n     * @throws TimeoutException\n     * @throws Exception\n     */\n    @Test\n    public void testUnicastMsgsWithLoopback() throws ChannelException, ChannelClosedException, ChannelNotConnectedException, TimeoutException, Exception {\n\n    \tfinal long TIMEOUT = 2 * 1000 ;\n    \tfinal int NUM=1000;\n    \tlong num_msgs_sent_before = 0 ;\n    \tlong num_msgs_sent_after = 0 ;\n\n    \tPromise<Boolean> p = new Promise<Boolean>() ;\n    \tMyReceiver receiver = new MyReceiver(NUM, p) ;\n    \tchannel.setReceiver(receiver) ;\n    \tchannel.connect(\"demo-group\") ;\n\n    \tAddress local_addr=channel.getLocalAddress();\n\n    \t// set the loopback property on transport\n    \tsetLoopbackProperty(channel, true) ;\n\n    \tnum_msgs_sent_before = getNumMessagesSentViaNetwork(channel) ;\n\n    \t// send NUM UNICAST messages to ourself \n    \tfor(int i=1; i <= NUM; i++) {\n    \t\tchannel.send(new Message(local_addr, null, new Integer(i)));\n//  \t\ttry {\n//  \t\tThread.sleep(1);\n//  \t\t}\n//  \t\tcatch(InterruptedException e) {\n//  \t\te.printStackTrace();\n//  \t\t}\n    \t\tif(i % 100 == 0)\n    \t\t\tSystem.out.println(\"-- sent \" + i);\n    \t}\n\n    \tnum_msgs_sent_after = getNumMessagesSentViaNetwork(channel) ;\n\n    \t// when loopback == true, messages should not touch the network\n    \tAssert.assertEquals(num_msgs_sent_before, num_msgs_sent_after, \"Messages are (incorrectly) being sent via network\") ;\n\n    \ttry { \n    \t\t// wait for all messages to be received\n    \t\tBoolean result = p.getResultWithTimeout(TIMEOUT) ;\n    \t}\n    \tcatch(TimeoutException te) {\n    \t\t// timeout exception occurred \n    \t\tAssert.fail(\"Test timed out before all messages were received\") ;\n    \t}\n\n    }","id":24822,"modified_method":"/**\n     * Tests that when UNICAST messages are sent with TP.loopback == true, the following \n     * conditions hold:\n     * (i) no messages touch the network\n     * (ii) all messages are correctly received\n     * \n     * @throws ChannelException\n     * @throws ChannelClosedException\n     * @throws ChannelNotConnectedException\n     * @throws TimeoutException\n     * @throws Exception\n     */\n    public void testUnicastMsgsWithLoopback() throws Exception {\n    \tfinal long TIMEOUT = 2 * 1000 ;\n    \tfinal int NUM=1000;\n    \tlong num_msgs_sent_before = 0 ;\n    \tlong num_msgs_sent_after = 0 ;\n\n    \tPromise<Boolean> p = new Promise<Boolean>() ;\n    \tMyReceiver receiver = new MyReceiver(NUM, p) ;\n    \tchannel.setReceiver(receiver) ;\n    \tchannel.connect(\"demo-group\") ;\n\n    \tAddress local_addr=channel.getLocalAddress();\n\n    \t// set the loopback property on transport\n    \tsetLoopbackProperty(channel, true) ;\n\n    \tnum_msgs_sent_before = getNumMessagesSentViaNetwork(channel) ;\n\n    \t// send NUM UNICAST messages to ourself \n    \tfor(int i=1; i <= NUM; i++) {\n    \t\tchannel.send(new Message(local_addr, null, new Integer(i)));\n    \t\tif(i % 100 == 0)\n    \t\t\tSystem.out.println(\"-- sent \" + i);\n    \t}\n\n    \tnum_msgs_sent_after = getNumMessagesSentViaNetwork(channel) ;\n\n    \t// when loopback == true, messages should not touch the network\n        System.out.println(\"num msgs before: \" + num_msgs_sent_before + \", num msgs after: \" + num_msgs_sent_after);\n        assert num_msgs_sent_before <= num_msgs_sent_after;\n        assert num_msgs_sent_after < NUM/10;\n\n        try {\n    \t\t// wait for all messages to be received\n    \t\tp.getResultWithTimeout(TIMEOUT) ;\n    \t}\n    \tcatch(TimeoutException te) {\n    \t\t// timeout exception occurred \n    \t\tAssert.fail(\"Test timed out before all messages were received\") ;\n    \t}\n\n    }","commit_id":"f02fb9a89207e30a2dc5eaec9fdaa39c49909523","url":"https://github.com/belaban/JGroups"},{"original_method":"@BeforeMethod\n    protected void setUp() throws Exception {\n        channel=createChannel();\n    }","id":24823,"modified_method":"@BeforeMethod\n    protected void setUp() throws Exception {\n        channel=createChannel(true, 1);\n    }","commit_id":"f02fb9a89207e30a2dc5eaec9fdaa39c49909523","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the number of messages sent across the network.\n     * \n     * @param ch \n     * @return the number of messages sent across the network\n     * @throws Exception\n     */\n    private long getNumMessagesSentViaNetwork(JChannel ch) throws Exception {\n\n    \tTP transport = (TP) ch.getProtocolStack().getTransport();\n    \tif (transport == null) {\n    \t\tthrow new Exception(\"transport layer is not present - check default stack configuration\") ;\n    \t}\n\n    \treturn transport.getNumMessagesSent();\n    }","id":24824,"modified_method":"/**\n     * Returns the number of messages sent across the network.\n     * \n     * @param ch \n     * @return the number of messages sent across the network\n     * @throws Exception\n     */\n    private static long getNumMessagesSentViaNetwork(JChannel ch) throws Exception {\n\n    \tTP transport = ch.getProtocolStack().getTransport();\n    \tif (transport == null) {\n    \t\tthrow new Exception(\"transport layer is not present - check default stack configuration\") ;\n    \t}\n\n    \treturn transport.getNumMessagesSent();\n    }","commit_id":"f02fb9a89207e30a2dc5eaec9fdaa39c49909523","url":"https://github.com/belaban/JGroups"},{"original_method":"@AfterMethod\n    protected void tearDown() throws Exception {\n        if(channel != null) {\n            channel.close();\n            channel=null;\n        }\n    }","id":24825,"modified_method":"@AfterMethod\n    protected void tearDown() throws Exception {\n        Util.close(channel);\n    }","commit_id":"f02fb9a89207e30a2dc5eaec9fdaa39c49909523","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Set the value of the loopback property on the transport layer.\n     * \n     * @param ch\n     * @param loopback\n     * @throws Exception\n     */\n    private void setLoopbackProperty(JChannel ch, boolean loopback) throws Exception {\n\n    \tTP transport =  (TP) ch.getProtocolStack().getTransport() ;\n    \tif (transport == null) {\n    \t\tthrow new Exception(\"transport layer is not present - check default stack configuration\") ;\n    \t}\n\n    \t// check if already set correctly\n    \tif ((loopback && transport.isLoopback()) || (!loopback && !transport.isLoopback()))\n    \t\treturn ;\n\n    \t// otherwise, set it\n    \ttransport.setLoopback(loopback);\n    }","id":24826,"modified_method":"/**\n     * Set the value of the loopback property on the transport layer.\n     * \n     * @param ch\n     * @param loopback\n     * @throws Exception\n     */\n    private static void setLoopbackProperty(JChannel ch, boolean loopback) throws Exception {\n\n    \tTP transport =ch.getProtocolStack().getTransport();\n    \tif (transport == null) {\n    \t\tthrow new Exception(\"transport layer is not present - check default stack configuration\") ;\n    \t}\n\n    \t// check if already set correctly\n    \tif ((loopback && transport.isLoopback()) || (!loopback && !transport.isLoopback()))\n    \t\treturn ;\n\n    \t// otherwise, set it\n    \ttransport.setLoopback(loopback);\n    }","commit_id":"8210dee408663783b2020304e84c97e0b2ab79bd","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Tests that when UNICAST messages are sent with TP.loopback == true, the following \n     * conditions hold:\n     * (i) no messages touch the network\n     * (ii) all messages are correctly received\n     * \n     * @throws ChannelException\n     * @throws ChannelClosedException\n     * @throws ChannelNotConnectedException\n     * @throws TimeoutException\n     * @throws Exception\n     */\n    @Test\n    public void testUnicastMsgsWithLoopback() throws ChannelException, ChannelClosedException, ChannelNotConnectedException, TimeoutException, Exception {\n\n    \tfinal long TIMEOUT = 2 * 1000 ;\n    \tfinal int NUM=1000;\n    \tlong num_msgs_sent_before = 0 ;\n    \tlong num_msgs_sent_after = 0 ;\n\n    \tPromise<Boolean> p = new Promise<Boolean>() ;\n    \tMyReceiver receiver = new MyReceiver(NUM, p) ;\n    \tchannel.setReceiver(receiver) ;\n    \tchannel.connect(\"demo-group\") ;\n\n    \tAddress local_addr=channel.getLocalAddress();\n\n    \t// set the loopback property on transport\n    \tsetLoopbackProperty(channel, true) ;\n\n    \tnum_msgs_sent_before = getNumMessagesSentViaNetwork(channel) ;\n\n    \t// send NUM UNICAST messages to ourself \n    \tfor(int i=1; i <= NUM; i++) {\n    \t\tchannel.send(new Message(local_addr, null, new Integer(i)));\n//  \t\ttry {\n//  \t\tThread.sleep(1);\n//  \t\t}\n//  \t\tcatch(InterruptedException e) {\n//  \t\te.printStackTrace();\n//  \t\t}\n    \t\tif(i % 100 == 0)\n    \t\t\tSystem.out.println(\"-- sent \" + i);\n    \t}\n\n    \tnum_msgs_sent_after = getNumMessagesSentViaNetwork(channel) ;\n\n    \t// when loopback == true, messages should not touch the network\n    \tAssert.assertEquals(num_msgs_sent_before, num_msgs_sent_after, \"Messages are (incorrectly) being sent via network\") ;\n\n    \ttry { \n    \t\t// wait for all messages to be received\n    \t\tBoolean result = p.getResultWithTimeout(TIMEOUT) ;\n    \t}\n    \tcatch(TimeoutException te) {\n    \t\t// timeout exception occurred \n    \t\tAssert.fail(\"Test timed out before all messages were received\") ;\n    \t}\n\n    }","id":24827,"modified_method":"/**\n     * Tests that when UNICAST messages are sent with TP.loopback == true, the following \n     * conditions hold:\n     * (i) no messages touch the network\n     * (ii) all messages are correctly received\n     * \n     * @throws ChannelException\n     * @throws ChannelClosedException\n     * @throws ChannelNotConnectedException\n     * @throws TimeoutException\n     * @throws Exception\n     */\n    public void testUnicastMsgsWithLoopback() throws Exception {\n    \tfinal long TIMEOUT = 2 * 1000 ;\n    \tfinal int NUM=1000;\n    \tlong num_msgs_sent_before = 0 ;\n    \tlong num_msgs_sent_after = 0 ;\n\n    \tPromise<Boolean> p = new Promise<Boolean>() ;\n    \tMyReceiver receiver = new MyReceiver(NUM, p) ;\n    \tchannel.setReceiver(receiver) ;\n    \tchannel.connect(\"demo-group\") ;\n\n    \tAddress local_addr=channel.getLocalAddress();\n\n    \t// set the loopback property on transport\n    \tsetLoopbackProperty(channel, true) ;\n\n    \tnum_msgs_sent_before = getNumMessagesSentViaNetwork(channel) ;\n\n    \t// send NUM UNICAST messages to ourself \n    \tfor(int i=1; i <= NUM; i++) {\n    \t\tchannel.send(new Message(local_addr, null, new Integer(i)));\n    \t\tif(i % 100 == 0)\n    \t\t\tSystem.out.println(\"-- sent \" + i);\n    \t}\n\n    \tnum_msgs_sent_after = getNumMessagesSentViaNetwork(channel) ;\n\n    \t// when loopback == true, messages should not touch the network\n        System.out.println(\"num msgs before: \" + num_msgs_sent_before + \", num msgs after: \" + num_msgs_sent_after);\n        assert num_msgs_sent_before <= num_msgs_sent_after;\n        assert num_msgs_sent_after < NUM/10;\n\n        try {\n    \t\t// wait for all messages to be received\n    \t\tp.getResultWithTimeout(TIMEOUT) ;\n    \t}\n    \tcatch(TimeoutException te) {\n    \t\t// timeout exception occurred \n    \t\tAssert.fail(\"Test timed out before all messages were received\") ;\n    \t}\n\n    }","commit_id":"8210dee408663783b2020304e84c97e0b2ab79bd","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the number of messages sent across the network.\n     * \n     * @param ch \n     * @return the number of messages sent across the network\n     * @throws Exception\n     */\n    private long getNumMessagesSentViaNetwork(JChannel ch) throws Exception {\n\n    \tTP transport = (TP) ch.getProtocolStack().getTransport();\n    \tif (transport == null) {\n    \t\tthrow new Exception(\"transport layer is not present - check default stack configuration\") ;\n    \t}\n\n    \treturn transport.getNumMessagesSent();\n    }","id":24828,"modified_method":"/**\n     * Returns the number of messages sent across the network.\n     * \n     * @param ch \n     * @return the number of messages sent across the network\n     * @throws Exception\n     */\n    private static long getNumMessagesSentViaNetwork(JChannel ch) throws Exception {\n\n    \tTP transport = ch.getProtocolStack().getTransport();\n    \tif (transport == null) {\n    \t\tthrow new Exception(\"transport layer is not present - check default stack configuration\") ;\n    \t}\n\n    \treturn transport.getNumMessagesSent();\n    }","commit_id":"8210dee408663783b2020304e84c97e0b2ab79bd","url":"https://github.com/belaban/JGroups"},{"original_method":"@AfterMethod\n    protected void tearDown() throws Exception {\n        if(channel != null) {\n            channel.close();\n            channel=null;\n        }\n    }","id":24829,"modified_method":"@AfterMethod\n    protected void tearDown() throws Exception {\n        Util.close(channel);\n    }","commit_id":"8210dee408663783b2020304e84c97e0b2ab79bd","url":"https://github.com/belaban/JGroups"},{"original_method":"@BeforeMethod\n    protected void setUp() throws Exception {\n        channel=createChannel();\n    }","id":24830,"modified_method":"@BeforeMethod\n    protected void setUp() throws Exception {\n        channel=createChannel(true, 1);\n    }","commit_id":"8210dee408663783b2020304e84c97e0b2ab79bd","url":"https://github.com/belaban/JGroups"},{"original_method":"public boolean isScript() {\n        PsiJetFileStub stub = (PsiJetFileStub) getStub();\n        if (stub != null) {\n            return stub.isScript();\n        }\n\n        return getScript() != null;\n    }","id":24831,"modified_method":"public boolean isScript() {\n        PsiJetFileStub stub = getStub();\n        if (stub != null) {\n            return stub.isScript();\n        }\n\n        return getScript() != null;\n    }","commit_id":"78c1717eed852449459c3e973abcd44b0f76ef86","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public FqName getPackageFqName() {\n        PsiJetFileStub stub = (PsiJetFileStub) getStub();\n        if (stub != null) {\n            return stub.getPackageFqName();\n        }\n\n        JetPackageDirective packageDirective = getPackageDirective();\n        if (packageDirective == null) {\n            return FqName.ROOT;\n        }\n        return packageDirective.getFqName();\n    }","id":24832,"modified_method":"@NotNull\n    public FqName getPackageFqName() {\n        PsiJetFileStub stub = getStub();\n        if (stub != null) {\n            return stub.getPackageFqName();\n        }\n\n        JetPackageDirective packageDirective = getPackageDirective();\n        if (packageDirective == null) {\n            return FqName.ROOT;\n        }\n        return packageDirective.getFqName();\n    }","commit_id":"78c1717eed852449459c3e973abcd44b0f76ef86","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public JetImportList getImportList() {\n        return findChildByClass(JetImportList.class);\n    }","id":24833,"modified_method":"@Nullable\n    public JetImportList getImportList() {\n        PsiJetFileStub stub = getStub();\n        if (stub != null) {\n            StubElement<JetImportList> importListStub = stub.findChildStubByType(JetStubElementTypes.IMPORT_LIST);\n            return importListStub != null ? importListStub.getPsi() : null;\n        }\n        return findChildByClass(JetImportList.class);\n    }","commit_id":"78c1717eed852449459c3e973abcd44b0f76ef86","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public List<JetImportDirective> getImports() {\n        return PsiTreeUtil.getChildrenOfTypeAsList(this, JetImportDirective.class);\n    }","id":24834,"modified_method":"@NotNull\n    public List<JetImportDirective> getImports() {\n        return Arrays.asList(getStubOrPsiChildren(JetStubElementTypes.IMPORT_DIRECTIVE, JetImportDirective.ARRAY_FACTORY));\n    }","commit_id":"78c1717eed852449459c3e973abcd44b0f76ef86","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n  public LanguageLevel getLanguageLevel() {\n    return getManager().getCachedValuesManager().getParameterizedCachedValue(this, LANGUAGE_LEVEL, myLanguageLevelProvider, false, this);\n  }","id":24835,"modified_method":"@NotNull\n  public LanguageLevel getLanguageLevel() {\n    return getManager().getCachedValuesManager().getParameterizedCachedValue(this, LANGUAGE_LEVEL_KEY, LANGUAGE_LEVEL_PROVIDER, false, this);\n  }","commit_id":"9ef9b708f872a409e0ea0b35880d0ec7c93f4421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getPackageName() {\n    PsiJavaFileStub stub = (PsiJavaFileStub)getStub();\n    if (stub != null) {\n      return stub.getPackageName();\n    }\n\n    PsiPackageStatement statement = getPackageStatement();\n    if (statement == null) {\n      return \"\";\n    }\n    else {\n      return statement.getPackageName();\n    }\n  }","id":24836,"modified_method":"@NotNull\n  public String getPackageName() {\n    PsiJavaFileStub stub = (PsiJavaFileStub)getStub();\n    if (stub != null) {\n      return stub.getPackageName();\n    }\n\n    PsiPackageStatement statement = getPackageStatement();\n    return statement == null ? \"\" : statement.getPackageName();\n  }","commit_id":"9ef9b708f872a409e0ea0b35880d0ec7c93f4421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processDeclarationsNoGuess(PsiScopeProcessor processor, ResolveState state, PsiElement lastParent, PsiElement place){\n    processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, this);\n    final ElementClassHint classHint = processor.getHint(ElementClassHint.class);\n    final NameHint nameHint = processor.getHint(NameHint.class);\n    final String name = nameHint != null ? nameHint.getName(state) : null;\n    if (classHint == null || classHint.shouldProcess(PsiClass.class)){\n      if(processor instanceof ClassResolverProcessor){\n        // Some speedup\n        final JavaResolveResult[] guessClass = getGuess(name);\n        if(guessClass != null){\n          ((ClassResolverProcessor) processor).forceResult(guessClass);\n          return false;\n        }\n      }\n\n      final PsiClass[] classes = getClasses();\n      for (PsiClass aClass : classes) {\n        if (!processor.execute(aClass, state)) return false;\n      }\n\n      PsiImportList importList = getImportList();\n      PsiImportStatement[] importStatements = importList.getImportStatements();\n\n      //Single-type processing\n      for (PsiImportStatement statement : importStatements) {\n        if (!statement.isOnDemand()) {\n          if (nameHint != null) {\n            String refText = statement.getQualifiedName();\n            if (refText == null || !refText.endsWith(name)) continue;\n          }\n\n          PsiElement resolved = statement.resolve();\n          if (resolved instanceof PsiClass) {\n            processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, statement);\n            if (!processor.execute(resolved, state)) return false;\n          }\n        }\n      }\n      processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, null);\n\n      // check in current package\n      String packageName = getPackageName();\n      PsiPackage aPackage = JavaPsiFacade.getInstance(myManager.getProject()).findPackage(packageName);\n      if (aPackage != null){\n        if (!aPackage.processDeclarations(processor, state, null, place)) {\n          return false;\n        }\n      }\n\n      //On demand processing\n      for (PsiImportStatement statement : importStatements) {\n        if (statement.isOnDemand()) {\n          PsiElement resolved = statement.resolve();\n          if (resolved != null) {\n            processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, statement);\n            processOnDemandTarget(resolved, processor, state, place);\n          }\n        }\n      }\n    }\n\n    if(classHint == null || classHint.shouldProcess(PsiPackage.class)){\n      final PsiPackage rootPackage = JavaPsiFacade.getInstance(getProject()).findPackage(\"\");\n      processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, rootPackage);\n      if(rootPackage != null) rootPackage.processDeclarations(processor, state, null, place);\n    }\n\n    // todo[dsl] class processing\n    final PsiImportList importList = getImportList();\n    final PsiImportStaticStatement[] importStaticStatements = importList.getImportStaticStatements();\n    if (importStaticStatements.length > 0) {\n      final StaticImportFilteringProcessor staticImportProcessor = new StaticImportFilteringProcessor(processor, null);\n\n      // single member processing\n      for (PsiImportStaticStatement importStaticStatement : importStaticStatements) {\n        if (!importStaticStatement.isOnDemand()) {\n          final String referenceName = importStaticStatement.getReferenceName();\n          final PsiClass targetElement = importStaticStatement.resolveTargetClass();\n          if (targetElement != null) {\n            staticImportProcessor.setNameToFilter(referenceName);\n            staticImportProcessor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, importStaticStatement);\n            final boolean result = targetElement.processDeclarations(staticImportProcessor, state, lastParent, place);\n            if (!result) return false;\n          }\n        }\n      }\n\n      // on-demand processing\n      for (PsiImportStaticStatement importStaticStatement : importStaticStatements) {\n        if (importStaticStatement.isOnDemand()) {\n          final PsiClass targetElement = importStaticStatement.resolveTargetClass();\n          if (targetElement != null) {\n            staticImportProcessor.setNameToFilter(null);\n            staticImportProcessor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, importStaticStatement);\n            final boolean result = targetElement.processDeclarations(staticImportProcessor, state, lastParent, place);\n            if (!result) return false;\n          }\n        }\n      }\n\n      staticImportProcessor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, null);\n    }\n\n    if (classHint == null || classHint.shouldProcess(PsiClass.class)){\n      processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, null);\n\n      PsiJavaCodeReferenceElement[] implicitlyImported = getImplicitlyImportedPackageReferences();\n      for (PsiJavaCodeReferenceElement aImplicitlyImported : implicitlyImported) {\n        PsiElement resolved = aImplicitlyImported.resolve();\n        if (resolved != null) {\n          if (!processOnDemandTarget(resolved, processor, state, place)) return false;\n        }\n      }\n    }\n\n    return true;\n  }","id":24837,"modified_method":"private boolean processDeclarationsNoGuess(PsiScopeProcessor processor, ResolveState state, PsiElement lastParent, PsiElement place){\n    processor.handleEvent(PsiScopeProcessor.Event.SET_DECLARATION_HOLDER, this);\n    final ElementClassHint classHint = processor.getHint(ElementClassHint.class);\n    final NameHint nameHint = processor.getHint(NameHint.class);\n    final String name = nameHint != null ? nameHint.getName(state) : null;\n    if (classHint == null || classHint.shouldProcess(PsiClass.class)){\n      if(processor instanceof ClassResolverProcessor){\n        // Some speedup\n        final JavaResolveResult[] guessClass = getGuess(name);\n        if(guessClass != null){\n          ((ClassResolverProcessor) processor).forceResult(guessClass);\n          return false;\n        }\n      }\n\n      final PsiClass[] classes = getClasses();\n      for (PsiClass aClass : classes) {\n        if (!processor.execute(aClass, state)) return false;\n      }\n\n      PsiImportList importList = getImportList();\n      PsiImportStatement[] importStatements = importList.getImportStatements();\n\n      //Single-type processing\n      for (PsiImportStatement statement : importStatements) {\n        if (!statement.isOnDemand()) {\n          if (name != null) {\n            String refText = statement.getQualifiedName();\n            if (refText == null || !refText.endsWith(name)) continue;\n          }\n\n          PsiElement resolved = statement.resolve();\n          if (resolved instanceof PsiClass) {\n            processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, statement);\n            if (!processor.execute(resolved, state)) return false;\n          }\n        }\n      }\n      processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, null);\n\n      // check in current package\n      String packageName = getPackageName();\n      PsiPackage aPackage = JavaPsiFacade.getInstance(myManager.getProject()).findPackage(packageName);\n      if (aPackage != null) {\n        if (!aPackage.processDeclarations(processor, state, null, place)) {\n          return false;\n        }\n      }\n\n      //On demand processing\n      for (PsiImportStatement statement : importStatements) {\n        if (statement.isOnDemand()) {\n          PsiElement resolved = statement.resolve();\n          if (resolved != null) {\n            processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, statement);\n            processOnDemandTarget(resolved, processor, state, place);\n          }\n        }\n      }\n    }\n\n    if(classHint == null || classHint.shouldProcess(PsiPackage.class)){\n      final PsiPackage rootPackage = JavaPsiFacade.getInstance(getProject()).findPackage(\"\");\n      processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, rootPackage);\n      if(rootPackage != null) rootPackage.processDeclarations(processor, state, null, place);\n    }\n\n    // todo[dsl] class processing\n    final PsiImportList importList = getImportList();\n    final PsiImportStaticStatement[] importStaticStatements = importList.getImportStaticStatements();\n    if (importStaticStatements.length > 0) {\n      final StaticImportFilteringProcessor staticImportProcessor = new StaticImportFilteringProcessor(processor, null);\n\n      // single member processing\n      for (PsiImportStaticStatement importStaticStatement : importStaticStatements) {\n        if (!importStaticStatement.isOnDemand()) {\n          final String referenceName = importStaticStatement.getReferenceName();\n          final PsiClass targetElement = importStaticStatement.resolveTargetClass();\n          if (targetElement != null) {\n            staticImportProcessor.setNameToFilter(referenceName);\n            staticImportProcessor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, importStaticStatement);\n            final boolean result = targetElement.processDeclarations(staticImportProcessor, state, lastParent, place);\n            if (!result) return false;\n          }\n        }\n      }\n\n      // on-demand processing\n      for (PsiImportStaticStatement importStaticStatement : importStaticStatements) {\n        if (importStaticStatement.isOnDemand()) {\n          final PsiClass targetElement = importStaticStatement.resolveTargetClass();\n          if (targetElement != null) {\n            staticImportProcessor.setNameToFilter(null);\n            staticImportProcessor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, importStaticStatement);\n            final boolean result = targetElement.processDeclarations(staticImportProcessor, state, lastParent, place);\n            if (!result) return false;\n          }\n        }\n      }\n\n      staticImportProcessor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, null);\n    }\n\n    if (classHint == null || classHint.shouldProcess(PsiClass.class)){\n      processor.handleEvent(JavaScopeProcessorEvent.SET_CURRENT_FILE_CONTEXT, null);\n\n      PsiJavaCodeReferenceElement[] implicitlyImported = getImplicitlyImportedPackageReferences();\n      for (PsiJavaCodeReferenceElement aImplicitlyImported : implicitlyImported) {\n        PsiElement resolved = aImplicitlyImported.resolve();\n        if (resolved != null) {\n          if (!processOnDemandTarget(resolved, processor, state, place)) return false;\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"9ef9b708f872a409e0ea0b35880d0ec7c93f4421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiClass[] getClasses() {\n    final PsiJavaFileStub stub = (PsiJavaFileStub)getStub();\n    if (stub != null) {\n      return stub.getChildrenByType(JavaStubElementTypes.CLASS, PsiClass.ARRAY_FACTORY);\n    }\n\n    return calcTreeElement().getChildrenAsPsiElements(Constants.CLASS_BIT_SET, Constants.PSI_CLASS_ARRAY_CONSTRUCTOR);\n  }","id":24838,"modified_method":"@NotNull\n  public PsiClass[] getClasses() {\n    final StubElement<?> stub = getStub();\n    if (stub != null) {\n      return stub.getChildrenByType(JavaStubElementTypes.CLASS, PsiClass.ARRAY_FACTORY);\n    }\n\n    return calcTreeElement().getChildrenAsPsiElements(Constants.CLASS_BIT_SET, Constants.PSI_CLASS_ARRAY_CONSTRUCTOR);\n  }","commit_id":"9ef9b708f872a409e0ea0b35880d0ec7c93f4421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiImportList getImportList() {\n    final PsiJavaFileStub stub = (PsiJavaFileStub)getStub();\n    if (stub != null) {\n      return stub.getChildrenByType(JavaStubElementTypes.IMPORT_LIST, PsiImportList.ARRAY_FACTORY)[0];\n    }\n\n    return (PsiImportList)calcTreeElement().findChildByRoleAsPsiElement(ChildRole.IMPORT_LIST);\n  }","id":24839,"modified_method":"@NotNull\n  public PsiImportList getImportList() {\n    final StubElement<?> stub = getStub();\n    if (stub != null) {\n      return stub.getChildrenByType(JavaStubElementTypes.IMPORT_LIST, PsiImportList.ARRAY_FACTORY)[0];\n    }\n\n    return (PsiImportList)calcTreeElement().findChildByRoleAsPsiElement(ChildRole.IMPORT_LIST);\n  }","commit_id":"9ef9b708f872a409e0ea0b35880d0ec7c93f4421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StaticImportFilteringProcessor(PsiScopeProcessor delegate, String nameToFilter) {\n      myDelegate = delegate;\n      myNameToFilter = nameToFilter;\n    }","id":24840,"modified_method":"private StaticImportFilteringProcessor(PsiScopeProcessor delegate, String nameToFilter) {\n      myDelegate = delegate;\n      myNameToFilter = nameToFilter;\n    }","commit_id":"9ef9b708f872a409e0ea0b35880d0ec7c93f4421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ChangeSetSemanticModule() {\r\n        super( \"http://drools.org/drools-5.0/change-set\" );\r\n\r\n        addHandler( \"change-set\",\r\n                    new ChangeSetHandler() );\r\n        \r\n        addHandler( \"add\",\r\n                    new AddHandler() ); \r\n        \r\n        addHandler( \"removed\",\r\n                    new RemoveHandler() );\r\n        \r\n        addHandler( \"modified\",\r\n                    new ModifyHandler() );        \r\n        \r\n        addHandler( \"resource\",\r\n                    new ResourceHandler() );  \r\n        \r\n        addHandler( \"decisiontable-conf\",\r\n                    new DecisionTableConfigurationHandler() );             \r\n    }","id":24841,"modified_method":"public ChangeSetSemanticModule() {\r\n        super( \"http://drools.org/drools-5.0/change-set\" );\r\n\r\n        addHandler( \"change-set\",\r\n                    new ChangeSetHandler() );\r\n        \r\n        addHandler( \"add\",\r\n                    new AddHandler() ); \r\n        \r\n        addHandler( \"remove\",\r\n                    new RemoveHandler() );\r\n        \r\n        addHandler( \"modify\",\r\n                    new ModifyHandler() );        \r\n        \r\n        addHandler( \"resource\",\r\n                    new ResourceHandler() );  \r\n        \r\n        addHandler( \"decisiontable-conf\",\r\n                    new DecisionTableConfigurationHandler() );             \r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void rebuildResources(ChangeSetState changeSetState) {\r\n        this.listener.debug( \"KnowledgeAgent rebuilding KnowledgeBase using ChangeSet\" );\r\n        synchronized ( this.resources ) {\r\n            for ( Resource child : changeSetState.pkgs ) {\r\n\r\n                try {\r\n                    InputStream is = child.getInputStream();\r\n                    Package pkg = (Package) DroolsStreamUtils.streamIn( is );\r\n                    this.listener.debug( \"KnowledgeAgent adding KnowledgeDefinitionsPackage \" + pkg.getName() );\r\n                    ((KnowledgeBaseImpl) this.kbase).ruleBase.addPackage( pkg );\r\n                    is.close();\r\n                } catch ( Exception e ) {\r\n                    this.listener.exception( new RuntimeException( \"KnowledgeAgent exception while trying to serialize and KnowledgeDefinitionsPackage  \" ) );\r\n                }\r\n            }\r\n\r\n            if ( changeSetState.needsKnowledgeBuilder ) {\r\n                // modified we already know is in the map, so no need to process those\r\n\r\n                // now make a copy of the resource keys, as we are about to reset it, but need the keys to rebuild the kbase\r\n                Resource[] resourcesClone = this.resources.keySet().toArray( new Resource[this.resources.size()] );\r\n\r\n                // reset the resources map, so it can now be rebuilt\r\n                this.resources.clear();\r\n\r\n                // rebuild the kbase\r\n                KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n\r\n                for ( Resource resource : resourcesClone ) {\r\n                    this.listener.debug( \"KnowledgeAgent building resource=\" + resource );\r\n                    if ( ((InternalResource) resource).getResourceType() != ResourceType.PKG ) {\r\n                        // .pks are handled as a special case.\r\n                        kbuilder.add( resource,\r\n                                      ((InternalResource) resource).getResourceType() );\r\n                    }\r\n                }\r\n\r\n                if ( kbuilder.hasErrors() ) {\r\n                    this.listener.warning( \"KnowledgeAgent has KnowledgeBuilder errors \",\r\n                                           kbuilder.getErrors() );\r\n                }\r\n\r\n                this.kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n                this.kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\r\n                this.listener.info( \"KnowledgeAgent new KnowledgeBase now built and in use\" );\r\n            }\r\n        }\r\n\r\n        // code commented out to try and do incremental kbase changes\r\n        // @TODO get this working for incremental changes\r\n        //        synchronized ( this.resources ) {\r\n        //            // first deal with removals\r\n        //            for ( Resource resource : changeSet.getResourcesRemoved() ) {\r\n        //                ResourceMapping mapping = this.resources.remove(resource );\r\n        //                if ( !this.newInstance  ) {\r\n        //                    // we are keeping the current instance, so we need remove the individual knowledge definitions           \r\n        //                    for ( KnowledgeDefinition kd : mapping.getKnowledgeDefinitions() ) {\r\n        //                        if ( kd instanceof Rule ) {\r\n        //                            Rule rule = ( Rule ) kd;\r\n        //                            this.kbase.removeRule( rule.getPackageName(), rule.getName() );\r\n        //                        } else if ( kd instanceof Process ) {\r\n        //                            Process process = ( Process ) kd;\r\n        //                            this.kbase.removeProcess( process.getId() );\r\n        //                        }\r\n        //                        // @TODO functions and type declarations\r\n        //                    }\r\n        //                }\r\n        //            }\r\n        //            \r\n        //            // now deal with additions\r\n        //            for ( Resource resource : changeSet.getResourcesAdded() ) {\r\n        //                \r\n        //            }\r\n        //            \r\n        //            // final deal with modifies\r\n        //        }        \r\n    }","id":24842,"modified_method":"private void rebuildResources(ChangeSetState changeSetState) {\r\n        this.listener.debug( \"KnowledgeAgent rebuilding KnowledgeBase using ChangeSet\" );\r\n        synchronized ( this.resources ) {\r\n            // modified we already know is in the map, so no need to process those\r\n\r\n            //            // now make a copy of the resource keys, as we are about to reset it, but need the keys to rebuild the kbase\r\n            //            Resource[] resourcesClone = this.resources.keySet().toArray( new Resource[this.resources.size()] );\r\n            //\r\n            //            // reset the resources map, so it can now be rebuilt\r\n            //            this.resources.clear();\r\n\r\n            this.kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n            if ( changeSetState.needsKnowledgeBuilder ) {\r\n\r\n                // rebuild the kbase\r\n                KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n\r\n                for ( Resource resource : this.resources.keySet() ) {\r\n                    this.listener.debug( \"KnowledgeAgent building resource=\" + resource );\r\n                    if ( ((InternalResource) resource).getResourceType() != ResourceType.PKG ) {\r\n                        // .pks are handled as a special case.\r\n                        kbuilder.add( resource,\r\n                                      ((InternalResource) resource).getResourceType() );\r\n                    }\r\n                }\r\n\r\n                if ( kbuilder.hasErrors() ) {\r\n                    this.listener.warning( \"KnowledgeAgent has KnowledgeBuilder errors \",\r\n                                           kbuilder.getErrors() );\r\n                }\r\n\r\n                this.kbase.addKnowledgePackages( kbuilder.getKnowledgePackages() );\r\n            }\r\n\r\n            for ( Resource resource : this.resources.keySet() ) {\r\n\r\n                if ( ((InternalResource) resource).getResourceType() == ResourceType.PKG ) {\r\n                    this.listener.debug( \"KnowledgeAgent building resource=\" + resource );\r\n\r\n                    InputStream is = null;\r\n                    try {\r\n                        // .pks are handled as a special case.\r\n                        is = resource.getInputStream();\r\n                        Object object = DroolsStreamUtils.streamIn( is );\r\n                        Package pkg = null;\r\n                        if ( object instanceof KnowledgePackage ) {\r\n                            pkg = ((KnowledgePackageImp) object).pkg;\r\n                        } else {\r\n                            pkg = (Package) pkg;\r\n                        }\r\n                        this.listener.debug( \"KnowledgeAgent adding KnowledgeDefinitionsPackage \" + pkg.getName() );\r\n                        ((KnowledgeBaseImpl) this.kbase).ruleBase.addPackage( pkg );\r\n                    } catch ( Exception e ) {\r\n                        this.listener.exception( new RuntimeException( \"KnowledgeAgent exception while trying to serialize KnowledgeDefinitionsPackage  \" ) );\r\n                    } finally {\r\n                        try {\r\n                            is.close();\r\n                        } catch ( IOException e ) {\r\n                            this.listener.exception( new RuntimeException( \"KnowledgeAgent exception while trying to close KnowledgeDefinitionsPackage  \" ) );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            //            for ( Resource child : changeSetState.pkgs ) {\r\n            //                try {\r\n            //                    this.listener.debug( \"child : \" + ((InternalResource) child).getLastRead() + \" : \" + ((InternalResource) child).getLastModified() );\r\n            //                    InputStream is = child.getInputStream();\r\n            //                    Object object = DroolsStreamUtils.streamIn( is );\r\n            //                    Package pkg = null;\r\n            //                    if ( object instanceof KnowledgePackage ) {\r\n            //                        pkg = ((KnowledgePackageImp)object).pkg;\r\n            //                    } else {\r\n            //                        pkg = ( Package ) pkg;\r\n            //                    }\r\n            //                    this.listener.debug( \"KnowledgeAgent adding KnowledgeDefinitionsPackage \" + pkg.getName() );\r\n            //                    ((KnowledgeBaseImpl) this.kbase).ruleBase.addPackage( pkg );\r\n            //                    is.close();\r\n            //                } catch ( Exception e ) {\r\n            //                    this.listener.exception( new RuntimeException( \"KnowledgeAgent exception while trying to serialize and KnowledgeDefinitionsPackage  \" ) );\r\n            //                }\r\n            //            }        \r\n\r\n            this.listener.info( \"KnowledgeAgent new KnowledgeBase now built and in use\" );\r\n        }\r\n\r\n        // code commented out to try and do incremental kbase changes\r\n        // @TODO get this working for incremental changes\r\n        //        synchronized ( this.resources ) {\r\n        //            // first deal with removals\r\n        //            for ( Resource resource : changeSet.getResourcesRemoved() ) {\r\n        //                ResourceMapping mapping = this.resources.remove(resource );\r\n        //                if ( !this.newInstance  ) {\r\n        //                    // we are keeping the current instance, so we need remove the individual knowledge definitions           \r\n        //                    for ( KnowledgeDefinition kd : mapping.getKnowledgeDefinitions() ) {\r\n        //                        if ( kd instanceof Rule ) {\r\n        //                            Rule rule = ( Rule ) kd;\r\n        //                            this.kbase.removeRule( rule.getPackageName(), rule.getName() );\r\n        //                        } else if ( kd instanceof Process ) {\r\n        //                            Process process = ( Process ) kd;\r\n        //                            this.kbase.removeProcess( process.getId() );\r\n        //                        }\r\n        //                        // @TODO functions and type declarations\r\n        //                    }\r\n        //                }\r\n        //            }\r\n        //            \r\n        //            // now deal with additions\r\n        //            for ( Resource resource : changeSet.getResourcesAdded() ) {\r\n        //                \r\n        //            }\r\n        //            \r\n        //            // final deal with modifies\r\n        //        }        \r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void buildResourceMapping(KnowledgeBase kbase) {\r\n        RuleBase rbase = ((KnowledgeBaseImpl) kbase).ruleBase;\r\n        this.listener.debug( \"KnowledgeAgent building resource map\" );\r\n        synchronized ( this.resources ) {\r\n\r\n            for ( Package pkg : rbase.getPackages() ) {\r\n                for ( Rule rule : pkg.getRules() ) {\r\n                    Resource resource = rule.getResource();\r\n                    if ( resource == null || !((InternalResource) resource).hasURL() ) {\r\n                        continue;\r\n                    }\r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                    this.listener.debug( \"KnowledgeAgent mapping resource=\" + resource + \" to rule=\" + rule );\r\n                    mapping.getKnowledgeDefinitions().add( rule );\r\n                }\r\n\r\n                for ( Process process : pkg.getRuleFlows().values() ) {\r\n                    Resource resource = ((org.drools.process.core.Process) process).getResource();\r\n                    if ( resource == null || !((InternalResource) resource).hasURL() ) {\r\n                        continue;\r\n                    }\r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                    this.listener.debug( \"KnowledgeAgent mapping resource=\" + resource + \" to process=\" + process );\r\n                    mapping.getKnowledgeDefinitions().add( process );\r\n                }\r\n\r\n                for ( TypeDeclaration typeDeclaration : pkg.getTypeDeclarations().values() ) {\r\n                    Resource resource = typeDeclaration.getResource();\r\n                    if ( resource == null || !((InternalResource) resource).hasURL() ) {\r\n                        continue;\r\n                    }\r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                    this.listener.debug( \"KnowledgeAgent mapping resource=\" + resource + \" to TypeDeclaration=\" + typeDeclaration );\r\n                    mapping.getKnowledgeDefinitions().add( typeDeclaration );\r\n                }\r\n\r\n                for ( Function function : pkg.getFunctions().values() ) {\r\n                    Resource resource = function.getResource();\r\n                    if ( resource == null || !((InternalResource) resource).hasURL() ) {\r\n                        continue;\r\n                    }\r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                    this.listener.debug( \"KnowledgeAgent mapping resource=\" + resource + \" to function=\" + function );\r\n                    mapping.getKnowledgeDefinitions().add( function );\r\n                }\r\n            }\r\n        }\r\n    }","id":24843,"modified_method":"/**\r\n     * This indexes the rules and flows against their respective urls, to allow more fine grained removal and not just removing of an entire package\r\n     * @param kbase\r\n     */\r\n    public void buildResourceMapping(KnowledgeBase kbase) {\r\n        RuleBase rbase = ((KnowledgeBaseImpl) kbase).ruleBase;\r\n        this.listener.debug( \"KnowledgeAgent building resource map\" );\r\n        synchronized ( this.resources ) {\r\n\r\n            for ( Package pkg : rbase.getPackages() ) {\r\n                for ( Rule rule : pkg.getRules() ) {\r\n                    Resource resource = rule.getResource();\r\n                    if ( resource == null || !((InternalResource) resource).hasURL() ) {\r\n                        continue;\r\n                    }\r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                    this.listener.debug( \"KnowledgeAgent mapping resource=\" + resource + \" to rule=\" + rule );\r\n                    mapping.getKnowledgeDefinitions().add( rule );\r\n                }\r\n\r\n                for ( Process process : pkg.getRuleFlows().values() ) {\r\n                    Resource resource = ((org.drools.process.core.Process) process).getResource();\r\n                    if ( resource == null || !((InternalResource) resource).hasURL() ) {\r\n                        continue;\r\n                    }\r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                    this.listener.debug( \"KnowledgeAgent mapping resource=\" + resource + \" to process=\" + process );\r\n                    mapping.getKnowledgeDefinitions().add( process );\r\n                }\r\n\r\n                for ( TypeDeclaration typeDeclaration : pkg.getTypeDeclarations().values() ) {\r\n                    Resource resource = typeDeclaration.getResource();\r\n                    if ( resource == null || !((InternalResource) resource).hasURL() ) {\r\n                        continue;\r\n                    }\r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                    this.listener.debug( \"KnowledgeAgent mapping resource=\" + resource + \" to TypeDeclaration=\" + typeDeclaration );\r\n                    mapping.getKnowledgeDefinitions().add( typeDeclaration );\r\n                }\r\n\r\n                for ( Function function : pkg.getFunctions().values() ) {\r\n                    Resource resource = function.getResource();\r\n                    if ( resource == null || !((InternalResource) resource).hasURL() ) {\r\n                        continue;\r\n                    }\r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                    this.listener.debug( \"KnowledgeAgent mapping resource=\" + resource + \" to function=\" + function );\r\n                    mapping.getKnowledgeDefinitions().add( function );\r\n                }\r\n            }\r\n        }\r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public KnowledgeAgentImpl(String name,\r\n                              KnowledgeBase kbase,\r\n                              KnowledgeAgentConfiguration configuration) {\r\n        this.kbase = kbase;\r\n        this.resources = new HashMap<Resource, ResourceMapping>();\r\n        this.resourceDirectories = new HashSet<Resource>();\r\n        //this.listener = listener;\r\n        this.listener = SystemEventListenerFactory.getSystemEventListener();\r\n        this.newInstance = true; // we hard code this for now as incremental kbase changes don't work.\r\n        this.queue = new LinkedBlockingQueue<ChangeSet>();\r\n        boolean scanResources = false;\r\n        boolean monitor = false;\r\n        if ( configuration != null ) {\r\n            //this.newInstance = ((KnowledgeAgentConfigurationImpl) configuration).isNewInstance();\r\n            this.notifier = (ResourceChangeNotifierImpl) ResourceFactory.getResourceChangeNotifierService();\r\n            if ( ((KnowledgeAgentConfigurationImpl) configuration).isMonitorChangeSetEvents() ) {\r\n                monitor = true;\r\n            }\r\n\r\n            if ( ((KnowledgeAgentConfigurationImpl) configuration).isScanDirectories() ) {\r\n                this.scanDirectories = true;\r\n            }\r\n\r\n            scanResources = ((KnowledgeAgentConfigurationImpl) configuration).isScanResources();\r\n            if ( scanResources ) {\r\n                this.notifier.addResourceChangeMonitor( ResourceFactory.getResourceChangeScannerService() );\r\n                monitor = true; // if scanning, monitor must be true;\r\n            }\r\n        }\r\n\r\n        monitorResourceChangeEvents( monitor );\r\n\r\n        buildResourceMapping( kbase );\r\n\r\n        this.listener.info( \"KnowledgAgent created, with configuration:\\nmonitorChangeSetEvents=\" + monitor + \" scanResources=\" + scanResources + \" scanDirectories=\" + this.scanDirectories );\r\n    }","id":24844,"modified_method":"public KnowledgeAgentImpl(String name,\r\n                              KnowledgeBase kbase,\r\n                              KnowledgeAgentConfiguration configuration) {\r\n        this.kbase = kbase;\r\n        this.resources = new HashMap<Resource, ResourceMapping>();\r\n        this.resourceDirectories = new HashSet<Resource>();\r\n        //this.listener = listener;\r\n        this.listener = SystemEventListenerFactory.getSystemEventListener();\r\n        this.newInstance = true; // we hard code this for now as incremental kbase changes don't work.\r\n        this.queue = new LinkedBlockingQueue<ChangeSet>();\r\n        boolean scanResources = false;\r\n        boolean monitor = false;\r\n        if ( configuration != null ) {\r\n            //this.newInstance = ((KnowledgeAgentConfigurationImpl) configuration).isNewInstance();\r\n            this.notifier = (ResourceChangeNotifierImpl) ResourceFactory.getResourceChangeNotifierService();\r\n            if ( ((KnowledgeAgentConfigurationImpl) configuration).isMonitorChangeSetEvents() ) {\r\n                monitor = true;\r\n            }\r\n\r\n            if ( ((KnowledgeAgentConfigurationImpl) configuration).isScanDirectories() ) {\r\n                this.scanDirectories = true;\r\n            }\r\n\r\n            scanResources = ((KnowledgeAgentConfigurationImpl) configuration).isScanResources();\r\n            if ( scanResources ) {\r\n                this.notifier.addResourceChangeMonitor( ResourceFactory.getResourceChangeScannerService() );\r\n                monitor = true; // if scanning, monitor must be true;\r\n            }\r\n        }\r\n\r\n        monitorResourceChangeEvents( monitor );\r\n\r\n        //buildResourceMapping( kbase );\r\n\r\n        this.listener.info( \"KnowledgAgent created, with configuration:\\nmonitorChangeSetEvents=\" + monitor + \" scanResources=\" + scanResources + \" scanDirectories=\" + this.scanDirectories );\r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void applyChangeSet(ChangeSet changeSet) {\r\n        this.listener.info( \"KnowledgAgent applying ChangeSet\" );\r\n        ChangeSetState changeSetState = new ChangeSetState();\r\n        changeSetState.scanDirectories = this.scanDirectories;\r\n        processChangeSet( changeSet,\r\n                          changeSetState );\r\n\r\n        rebuildResources( changeSetState );\r\n        buildResourceMapping( this.kbase );\r\n    }","id":24845,"modified_method":"public void applyChangeSet(ChangeSet changeSet) {\r\n        this.listener.info( \"KnowledgAgent applying ChangeSet\" );\r\n        ChangeSetState changeSetState = new ChangeSetState();\r\n        changeSetState.scanDirectories = this.scanDirectories;\r\n        processChangeSet( changeSet,\r\n                          changeSetState );\r\n\r\n        rebuildResources( changeSetState );\r\n        //buildResourceMapping( this.kbase );\r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void run() {\r\n            if ( this.monitor ) {\r\n                this.listener.info( \"KnowledegAgent has started listening for ChangeSet notifications\" );\r\n            }\r\n            while ( this.monitor ) {\r\n                try {\r\n                    kagent.applyChangeSet( this.queue.take() );\r\n                } catch ( InterruptedException e ) {\r\n                    this.listener.exception( new RuntimeException( \"KnowledgeAgent ChangeSet notification thread has been interrupted\",\r\n                                                                   e ) );\r\n                }\r\n                Thread.yield();\r\n            }\r\n\r\n            this.listener.info( \"KnowledegAgent has stopped listening for ChangeSet notifications\" );\r\n        }","id":24846,"modified_method":"public void run() {\r\n            if ( this.monitor ) {\r\n                this.listener.info( \"KnowledegAgent has started listening for ChangeSet notifications\" );\r\n            }\r\n            while ( this.monitor ) {\r\n                Exception exception = null;\r\n                try {\r\n                    kagent.applyChangeSet( this.queue.take() );\r\n                } catch ( InterruptedException e ) {\r\n                    exception = e;\r\n                }\r\n                Thread.yield();\r\n                if ( this.monitor && exception != null) {\r\n                    this.listener.exception( new RuntimeException( \"KnowledgeAgent ChangeSet notification thread has been interrupted, but shutdown was not scheduled\",\r\n                                                                   exception ) );\r\n                }\r\n            }\r\n\r\n            this.listener.info( \"KnowledegAgent has stopped listening for ChangeSet notifications\" );\r\n        }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testModifyUrl() throws Exception {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        File f1 = fileManager.newFile( \"rule1.drl\" );\r\n        f1.deleteOnExit();\r\n        Writer output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n\r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n        File f2 = fileManager.newFile( \"rule2.drl\" );\r\n        f2.deleteOnExit();\r\n        output = new BufferedWriter( new FileWriter( f2 ) );\r\n        output.write( rule2 );\r\n        output.close();\r\n\r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='http://localhost:9000/rule1.drl' type='DRL' />\";\r\n        xml += \"        <resource source='http://localhost:9000/rule2.drl' type='DRL' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        fxml.deleteOnExit();\r\n        output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                           \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n\r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                           \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                                                                         kbase,\r\n                                                                         aconf );\r\n\r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n\r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n\r\n        list.clear();\r\n\r\n        // have to sleep here as linux lastModified does not do milliseconds http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=1&t=019789\r\n        Thread.sleep( 2000 );\r\n\r\n        rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule3\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n        Thread.sleep( 3000 );\r\n\r\n        ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n\r\n        assertTrue( list.contains( \"rule3\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n        kagent.monitorResourceChangeEvents( false );\r\n    }","id":24847,"modified_method":"public void testModifyFileUrl() throws Exception {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        File f1 = fileManager.newFile( \"rule1.drl\" );\r\n        f1.deleteOnExit();\r\n        Writer output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n\r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n        File f2 = fileManager.newFile( \"rule2.drl\" );\r\n        f2.deleteOnExit();\r\n        output = new BufferedWriter( new FileWriter( f2 ) );\r\n        output.write( rule2 );\r\n        output.close();\r\n\r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='http://localhost:9000/rule1.drl' type='DRL' />\";\r\n        xml += \"        <resource source='http://localhost:9000/rule2.drl' type='DRL' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        fxml.deleteOnExit();\r\n        output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                           \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n\r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                           \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                                                                         kbase,\r\n                                                                         aconf );\r\n\r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n\r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n\r\n        list.clear();\r\n\r\n        // have to sleep here as linux lastModified does not do milliseconds http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=1&t=019789\r\n        Thread.sleep( 2000 );\r\n\r\n        rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule3\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n        Thread.sleep( 3000 );\r\n\r\n        ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n\r\n        assertTrue( list.contains( \"rule3\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n        kagent.monitorResourceChangeEvents( false );        \r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"protected void tearDown() throws Exception {\r\n        fileManager.tearDown();\r\n        ResourceFactory.getResourceChangeNotifierService().stop();\r\n        ResourceFactory.getResourceChangeScannerService().stop();\r\n        ((ResourceChangeScannerImpl) ResourceFactory.getResourceChangeScannerService()).reset();\r\n    }","id":24848,"modified_method":"protected void tearDown() throws Exception {\r\n        fileManager.tearDown();\r\n        ResourceFactory.getResourceChangeNotifierService().stop();\r\n        ResourceFactory.getResourceChangeScannerService().stop();\r\n        ((ResourceChangeScannerImpl) ResourceFactory.getResourceChangeScannerService()).reset();\r\n        \r\n        server.stop();\r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void run() {\r\n            if ( this.notify ) {\r\n                this.listener.info( \"ResourceChangeNotification has started listening for ChangeSet publications\" );\r\n            }\r\n            while ( this.notify ) {\r\n                try {\r\n                    this.listener.debug( \"ResourceChangeNotification notifier thread is waiting for queue update\" );\r\n                    this.notifier.processChangeSet( this.queue.take() );\r\n                } catch ( InterruptedException e ) {\r\n                    this.listener.exception( new RuntimeException( \"ResourceChangeNotification ChangeSet publication thread was interrupted\",\r\n                                                                   e ) );\r\n                }\r\n                Thread.yield();\r\n            }\r\n            this.listener.info( \"ResourceChangeNotification has stopped listening for ChangeSet publications\" );\r\n        }","id":24849,"modified_method":"public void run() {\r\n            if ( this.notify ) {\r\n                this.listener.info( \"ResourceChangeNotification has started listening for ChangeSet publications\" );\r\n            }\r\n            while ( this.notify ) {\r\n                Exception exception = null;\r\n                try {\r\n                    this.listener.debug( \"ResourceChangeNotification thread is waiting for queue update\" );\r\n                    this.notifier.processChangeSet( this.queue.take() );\r\n                } catch ( InterruptedException e ) {\r\n                    exception = e;\r\n                }\r\n                Thread.yield();\r\n                if ( this.notify && exception != null) {\r\n                    this.listener.exception( new RuntimeException( \"ResourceChangeNotification ChangeSet publication thread was interrupted, but shutdown was not scheduled\",\r\n                                                                   exception ) );\r\n                }\r\n            }\r\n            this.listener.info( \"ResourceChangeNotification has stopped listening for ChangeSet publications\" );\r\n        }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setInterval(int interval) {\r\n        this.interval = interval * 1000;\r\n    }","id":24850,"modified_method":"public void setInterval(int interval) {\r\n        this.interval = interval;\r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void configure(ResourceChangeScannerConfiguration configuration) {\r\n        setInterval( ((ResourceChangeScannerConfigurationImpl) configuration).getInterval() );\r\n        this.listener.info( \"ResourceChangeScanner reconfigured with interval=\" + ( getInterval() / 1000 ) );\r\n        synchronized ( this.resources ) {\r\n            this.resources.notify(); // notify wait, so that it will wait again\r\n        }\r\n    }","id":24851,"modified_method":"public void configure(ResourceChangeScannerConfiguration configuration) {\r\n        setInterval( ((ResourceChangeScannerConfigurationImpl) configuration).getInterval() );\r\n        this.listener.info( \"ResourceChangeScanner reconfigured with interval=\" + ( getInterval() ) );\r\n        \r\n        // restart it if it's already running.\r\n        if ( this.scannerScheduler.isRunning() ) {\r\n            stop();\r\n            start();           \r\n        }\r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void run() {\r\n            synchronized ( this ) {\r\n                if ( this.scan ) {\r\n                    this.listener.info( \"ResourceChangeNotification scanner has started\" );\r\n                }\r\n                while ( this.scan ) {\r\n                    System.out.println( \"BEFORE : sync this.resources\" );\r\n                    synchronized ( this.resources ) {      \r\n                        System.out.println( \"DURING : sync this.resources\" );\r\n                        // lock the resources, as we don't want this modified while processing\r\n                        this.scanner.scan();\r\n                    }\r\n                    System.out.println( \"AFTER : SCAN\" );\r\n                    try {\r\n                        this.listener.debug( \"ResourceChangeNotification scanner thread is waiting for \" + ( this.interval / 1000 ) );\r\n                        wait( this.interval );\r\n                    } catch ( InterruptedException e ) {\r\n                        this.listener.exception( new RuntimeException( \"ResourceChangeNotification ChangeSet scanning thread was interrupted\",\r\n                                                                       e ) );\r\n                    }\r\n                }\r\n                this.listener.info( \"ResourceChangeNotification scanner has stopped\" );\r\n            }\r\n        }","id":24852,"modified_method":"public void run() {\r\n            synchronized ( this ) {\r\n                if ( this.scan ) {\r\n                    this.listener.info( \"ResourceChangeNotification scanner has started\" );\r\n                }\r\n                while ( this.scan ) {\r\n                    Exception exception = null;\r\n                    //System.out.println( \"BEFORE : sync this.resources\" );\r\n                    synchronized ( this.resources ) {      \r\n                        //System.out.println( \"DURING : sync this.resources\" );\r\n                        // lock the resources, as we don't want this modified while processing\r\n                        this.scanner.scan();\r\n                    }\r\n                    //System.out.println( \"AFTER : SCAN\" );\r\n                    try {\r\n                        this.listener.debug( \"ResourceChangeScanner thread is waiting for \" + this.interval );\r\n                        wait( this.interval * 1000 );\r\n                    } catch ( InterruptedException e ) {\r\n                        exception = e;\r\n                    }\r\n                    \r\n                    if ( this.scan && exception != null) {\r\n                        this.listener.exception( new RuntimeException( \"ResourceChangeNotification ChangeSet scanning thread was interrupted, but shutdown was not scheduled\",\r\n                                                                       exception ) );                        \r\n                    }\r\n                }\r\n                this.listener.info( \"ResourceChangeNotification scanner has stopped\" );\r\n            }\r\n        }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public int getInterval() {\r\n            return (int) this.interval / 1000;\r\n        }","id":24853,"modified_method":"public int getInterval() {\r\n            return (int) this.interval;\r\n        }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setInterval(int interval) {\r\n        this.scannerScheduler.setInterval( interval );\r\n        if ( this.scannerScheduler.isRunning() ) {\r\n            // need to interrupt so it will iterate the run() and the new interval will take effect\r\n            this.thread.interrupt();            \r\n        }\r\n    }","id":24854,"modified_method":"public void setInterval(int interval) {\r\n        this.scannerScheduler.setInterval( interval );\r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void scan() {\r\n        this.listener.debug( \"ResourceChangeScanner attempt to scan \" + this.resources.size() + \" resources\" );\r\n\r\n        synchronized ( this.resources ) {\r\n            Map<ResourceChangeNotifier, ChangeSet> notifications = new HashMap<ResourceChangeNotifier, ChangeSet>();\r\n\r\n            List<Resource> removed = new ArrayList<Resource>();\r\n\r\n            // detect modified and added\r\n            for ( Resource resource : this.directories ) {\r\n                this.listener.debug( \"ResourceChangeScanner scanning directory=\" + resource );\r\n                for ( Resource child : ((InternalResource) resource).listResources() ) {\r\n                    if ( ((InternalResource) child).isDirectory() ) {\r\n                        continue; // ignore sub directories\r\n                    }\r\n                    if ( !this.resources.containsKey( child ) ) {\r\n\r\n                        this.listener.debug( \"ResourceChangeScanner new resource=\" + child );\r\n                        // child is new\r\n                        ((InternalResource) child).setResourceType( ((InternalResource) resource).getResourceType() );\r\n                        Set<ResourceChangeNotifier> notifiers = this.resources.get( resource ); // get notifiers for this directory\r\n                        for ( ResourceChangeNotifier notifier : notifiers ) {\r\n                            ChangeSetImpl changeSet = (ChangeSetImpl) notifications.get( notifier );\r\n                            if ( changeSet == null ) {\r\n                                // lazy initialise changeSet\r\n                                changeSet = new ChangeSetImpl();\r\n                                notifications.put( notifier,\r\n                                                   changeSet );\r\n                            }\r\n                            if ( changeSet.getResourcesAdded().isEmpty() ) {\r\n                                changeSet.setResourcesAdded( new ArrayList<Resource>() );\r\n                            }\r\n                            changeSet.getResourcesAdded().add( child );\r\n                            notifier.subscribeChildResource( resource,\r\n                                                             child );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            for ( Entry<Resource, Set<ResourceChangeNotifier>> entry : this.resources.entrySet() ) {\r\n                Resource resource = entry.getKey();\r\n                Set<ResourceChangeNotifier> notifiers = entry.getValue();\r\n\r\n                if ( !((InternalResource) resource).isDirectory() ) {\r\n                    // detect if Resource has been removed\r\n                    long lastModified = ((InternalResource) resource).getLastModified();\r\n                    if ( lastModified == 0 ) {\r\n                        this.listener.debug( \"ResourceChangeScanner removed resource=\" + resource );\r\n                        removed.add( resource );\r\n                        // resource is no longer present\r\n                        // iterate notifiers for this resource and add to each removed\r\n                        for ( ResourceChangeNotifier notifier : notifiers ) {\r\n                            ChangeSetImpl changeSet = (ChangeSetImpl) notifications.get( notifier );\r\n                            if ( changeSet == null ) {\r\n                                // lazy initialise changeSet\r\n                                changeSet = new ChangeSetImpl();\r\n                                notifications.put( notifier,\r\n                                                   changeSet );\r\n                            }\r\n                            if ( changeSet.getResourcesRemoved().isEmpty() ) {\r\n                                changeSet.setResourcesRemoved( new ArrayList<Resource>() );\r\n                            }\r\n                            changeSet.getResourcesRemoved().add( resource );\r\n                        }\r\n                    } else if ( ((InternalResource) resource).getLastRead() < lastModified ) {\r\n                        this.listener.debug( \"ResourceChangeScanner modified resource=\" + resource );\r\n                        // it's modified\r\n                        // iterate notifiers for this resource and add to each modified\r\n                        for ( ResourceChangeNotifier notifier : notifiers ) {\r\n                            ChangeSetImpl changeSet = (ChangeSetImpl) notifications.get( notifier );\r\n                            if ( changeSet == null ) {\r\n                                // lazy initialise changeSet\r\n                                changeSet = new ChangeSetImpl();\r\n                                notifications.put( notifier,\r\n                                                   changeSet );\r\n                            }\r\n                            if ( changeSet.getResourcesModified().isEmpty() ) {\r\n                                changeSet.setResourcesModified( new ArrayList<Resource>() );\r\n                            }\r\n                            changeSet.getResourcesModified().add( resource );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now iterate and removed the removed resources, we do this so as not to mutate the foreach loop while iterating\r\n            for ( Resource resource : removed ) {\r\n                this.resources.remove( resource );\r\n            }\r\n\r\n            for ( Entry<ResourceChangeNotifier, ChangeSet> entry : notifications.entrySet() ) {\r\n                ResourceChangeNotifier notifier = entry.getKey();\r\n                ChangeSet changeSet = entry.getValue();\r\n                notifier.publishChangeSet( changeSet );\r\n            }\r\n        }\r\n    }","id":24855,"modified_method":"public void scan() {\r\n        this.listener.debug( \"ResourceChangeScanner attempt to scan \" + this.resources.size() + \" resources\" );\r\n\r\n        synchronized ( this.resources ) {\r\n            Map<ResourceChangeNotifier, ChangeSet> notifications = new HashMap<ResourceChangeNotifier, ChangeSet>();\r\n\r\n            List<Resource> removed = new ArrayList<Resource>();\r\n\r\n            // detect modified and added\r\n            for ( Resource resource : this.directories ) {\r\n                this.listener.debug( \"ResourceChangeScanner scanning directory=\" + resource );\r\n                for ( Resource child : ((InternalResource) resource).listResources() ) {\r\n                    if ( ((InternalResource) child).isDirectory() ) {\r\n                        continue; // ignore sub directories\r\n                    }\r\n                    if ( !this.resources.containsKey( child ) ) {\r\n\r\n                        this.listener.debug( \"ResourceChangeScanner new resource=\" + child );\r\n                        // child is new\r\n                        ((InternalResource) child).setResourceType( ((InternalResource) resource).getResourceType() );\r\n                        Set<ResourceChangeNotifier> notifiers = this.resources.get( resource ); // get notifiers for this directory\r\n                        for ( ResourceChangeNotifier notifier : notifiers ) {\r\n                            ChangeSetImpl changeSet = (ChangeSetImpl) notifications.get( notifier );\r\n                            if ( changeSet == null ) {\r\n                                // lazy initialise changeSet\r\n                                changeSet = new ChangeSetImpl();\r\n                                notifications.put( notifier,\r\n                                                   changeSet );\r\n                            }\r\n                            if ( changeSet.getResourcesAdded().isEmpty() ) {\r\n                                changeSet.setResourcesAdded( new ArrayList<Resource>() );\r\n                            }\r\n                            changeSet.getResourcesAdded().add( child );\r\n                            notifier.subscribeChildResource( resource,\r\n                                                             child );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            for ( Entry<Resource, Set<ResourceChangeNotifier>> entry : this.resources.entrySet() ) {\r\n                Resource resource = entry.getKey();\r\n                Set<ResourceChangeNotifier> notifiers = entry.getValue();\r\n\r\n                if ( !((InternalResource) resource).isDirectory() ) {\r\n                    // detect if Resource has been removed\r\n                    long lastModified = ((InternalResource) resource).getLastModified();\r\n                    if ( lastModified == 0 ) {\r\n                        this.listener.debug( \"ResourceChangeScanner removed resource=\" + resource );\r\n                        removed.add( resource );\r\n                        // resource is no longer present\r\n                        // iterate notifiers for this resource and add to each removed\r\n                        for ( ResourceChangeNotifier notifier : notifiers ) {\r\n                            ChangeSetImpl changeSet = (ChangeSetImpl) notifications.get( notifier );\r\n                            if ( changeSet == null ) {\r\n                                // lazy initialise changeSet\r\n                                changeSet = new ChangeSetImpl();\r\n                                notifications.put( notifier,\r\n                                                   changeSet );\r\n                            }\r\n                            if ( changeSet.getResourcesRemoved().isEmpty() ) {\r\n                                changeSet.setResourcesRemoved( new ArrayList<Resource>() );\r\n                            }\r\n                            changeSet.getResourcesRemoved().add( resource );\r\n                        }\r\n                    } else if ( ((InternalResource) resource).getLastRead() < lastModified ) {\r\n                        this.listener.debug( \"ResourceChangeScanner modified resource=\" + resource + \" : \" + ((InternalResource) resource).getLastRead() + \" : \" + lastModified );\r\n                        // it's modified\r\n                        // iterate notifiers for this resource and add to each modified\r\n                        for ( ResourceChangeNotifier notifier : notifiers ) {\r\n                            ChangeSetImpl changeSet = (ChangeSetImpl) notifications.get( notifier );\r\n                            if ( changeSet == null ) {\r\n                                // lazy initialise changeSet\r\n                                changeSet = new ChangeSetImpl();\r\n                                notifications.put( notifier,\r\n                                                   changeSet );\r\n                            }\r\n                            if ( changeSet.getResourcesModified().isEmpty() ) {\r\n                                changeSet.setResourcesModified( new ArrayList<Resource>() );\r\n                            }\r\n                            changeSet.getResourcesModified().add( resource );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // now iterate and removed the removed resources, we do this so as not to mutate the foreach loop while iterating\r\n            for ( Resource resource : removed ) {\r\n                this.resources.remove( resource );\r\n            }\r\n\r\n            for ( Entry<ResourceChangeNotifier, ChangeSet> entry : notifications.entrySet() ) {\r\n                ResourceChangeNotifier notifier = entry.getKey();\r\n                ChangeSet changeSet = entry.getValue();\r\n                notifier.publishChangeSet( changeSet );\r\n            }\r\n        }\r\n    }","commit_id":"7950866057df14aa74904281746a247a1a1b2714","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void processChangeSet(ChangeSet changeSet,\r\n                                 ChangeSetState changeSetState) {\r\n        for ( Resource resource : changeSet.getResourcesAdded() ) {\r\n            if ( ((InternalResource) resource).isDirectory() ) {\r\n                this.resourceDirectories.add( resource );\r\n                this.listener.debug( \"KnowledgeAgent subscribing to directory=\" + resource );\r\n                this.notifier.subscribeResourceChangeListener( this,\r\n                                                               resource );\r\n                // if it's a dir, subscribe it's children first\r\n                for ( Resource child : ((InternalResource) resource).listResources() ) {\r\n                    if ( ((InternalResource) child).isDirectory() ) {\r\n                        continue; // ignore sub directories\r\n                    }\r\n                    ((InternalResource) child).setResourceType( ((InternalResource) resource).getResourceType() );\r\n                    ResourceMapping mapping = this.resources.get( child );\r\n                    if ( mapping == null ) {\r\n                        this.listener.debug( \"KnowledgeAgent subscribing to directory content resource=\" + child );\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       child );\r\n                        mapping = new ResourceMapping( child );\r\n                        this.resources.put( child,\r\n                                            mapping );\r\n                    }\r\n                }\r\n            } else {\r\n                if ( ((InternalResource) resource).getResourceType() == ResourceType.PKG ) {\r\n                    changeSetState.pkgs.add( resource );\r\n                } else if ( ((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET ) {\r\n                    // @TODO\r\n                    continue;\r\n                }\r\n\r\n                ResourceMapping mapping = this.resources.get( resource );\r\n                if ( mapping == null ) {\r\n                    this.listener.debug( \"KnowledgeAgent subscribing to resource=\" + resource );\r\n                    this.notifier.subscribeResourceChangeListener( this,\r\n                                                                   resource );\r\n                    mapping = new ResourceMapping( resource );\r\n                    this.resources.put( resource,\r\n                                        mapping );\r\n                }\r\n            }\r\n        }\r\n\r\n        for ( Resource resource : changeSet.getResourcesRemoved() ) {\r\n            if ( ((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET ) {\r\n                processChangeSet( resource,\r\n                                  changeSetState );\r\n            } else if ( changeSetState.scanDirectories && ((InternalResource) resource).isDirectory() ) {\r\n                this.listener.debug( \"KnowledgeAgent unsubscribing from directory resource=\" + resource );\r\n                this.resourceDirectories.remove( resource );\r\n                this.notifier.unsubscribeResourceChangeListener( this,\r\n                                                                 resource );\r\n            } else {\r\n                this.listener.debug( \"KnowledgeAgent unsubscribing from resource=\" + resource );\r\n                this.resources.remove( resource );\r\n                this.notifier.unsubscribeResourceChangeListener( this,\r\n                                                                 resource );\r\n            }\r\n        }\r\n\r\n        // are we going to need kbuilder to build these resources?\r\n        for ( Resource resource : this.resources.keySet() ) {\r\n            this.listener.debug( \"KnowledgeAgent ChangeSet requires KnowledgeBuilder\" );\r\n            if ( ((InternalResource) resource).getResourceType() != ResourceType.CHANGE_SET && ((InternalResource) resource).getResourceType() != ResourceType.PKG ) {\r\n                changeSetState.needsKnowledgeBuilder = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n    }","id":24856,"modified_method":"public void processChangeSet(ChangeSet changeSet,\r\n                                 ChangeSetState changeSetState) {\r\n        synchronized ( this.resources ) {\r\n            \r\n            for ( Resource resource : changeSet.getResourcesAdded() ) {\r\n                if ( ((InternalResource) resource).isDirectory() ) {\r\n                    this.resourceDirectories.add( resource );\r\n                    this.listener.debug( \"KnowledgeAgent subscribing to directory=\" + resource );\r\n                    this.notifier.subscribeResourceChangeListener( this,\r\n                                                                   resource );\r\n                    // if it's a dir, subscribe it's children first\r\n                    for ( Resource child : ((InternalResource) resource).listResources() ) {\r\n                        if ( ((InternalResource) child).isDirectory() ) {\r\n                            continue; // ignore sub directories\r\n                        }\r\n                        ((InternalResource) child).setResourceType( ((InternalResource) resource).getResourceType() );\r\n                        ResourceMapping mapping = this.resources.get( child );\r\n                        if ( mapping == null ) {\r\n                            this.listener.debug( \"KnowledgeAgent subscribing to directory content resource=\" + child );\r\n                            this.notifier.subscribeResourceChangeListener( this,\r\n                                                                           child );\r\n                            mapping = new ResourceMapping( child );\r\n                            this.resources.put( child,\r\n                                                mapping );\r\n                        }\r\n                    }\r\n                } else {\r\n                    if ( ((InternalResource) resource).getResourceType() == ResourceType.PKG ) {\r\n                        changeSetState.pkgs.add( resource );\r\n                    } else if ( ((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET ) {\r\n                        // @TODO\r\n                        continue;\r\n                    }\r\n    \r\n                    ResourceMapping mapping = this.resources.get( resource );\r\n                    if ( mapping == null ) {\r\n                        this.listener.debug( \"KnowledgeAgent subscribing to resource=\" + resource );\r\n                        this.notifier.subscribeResourceChangeListener( this,\r\n                                                                       resource );\r\n                        mapping = new ResourceMapping( resource );\r\n                        this.resources.put( resource,\r\n                                            mapping );\r\n                    }\r\n                }\r\n            }\r\n    \r\n            for ( Resource resource : changeSet.getResourcesRemoved() ) {\r\n                if ( ((InternalResource) resource).getResourceType() == ResourceType.CHANGE_SET ) {\r\n                    processChangeSet( resource,\r\n                                      changeSetState );\r\n                } else if ( changeSetState.scanDirectories && ((InternalResource) resource).isDirectory() ) {\r\n                    this.listener.debug( \"KnowledgeAgent unsubscribing from directory resource=\" + resource );\r\n                    this.resourceDirectories.remove( resource );\r\n                    this.notifier.unsubscribeResourceChangeListener( this,\r\n                                                                     resource );\r\n                } else {\r\n                    this.listener.debug( \"KnowledgeAgent unsubscribing from resource=\" + resource );\r\n                    this.resources.remove( resource );\r\n                    this.notifier.unsubscribeResourceChangeListener( this,\r\n                                                                     resource );\r\n                }\r\n            }\r\n    \r\n            // are we going to need kbuilder to build these resources?\r\n            for ( Resource resource : this.resources.keySet() ) {\r\n                this.listener.debug( \"KnowledgeAgent ChangeSet requires KnowledgeBuilder\" );\r\n                if ( ((InternalResource) resource).getResourceType() != ResourceType.CHANGE_SET && ((InternalResource) resource).getResourceType() != ResourceType.PKG ) {\r\n                    changeSetState.needsKnowledgeBuilder = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void  testModifyFileUrl() throws Exception {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        File f1 = fileManager.newFile( \"rule1.drl\" );\r\n        f1.deleteOnExit();\r\n        Writer output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n\r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n        File f2 = fileManager.newFile( \"rule2.drl\" );\r\n        f2.deleteOnExit();\r\n        output = new BufferedWriter( new FileWriter( f2 ) );\r\n        output.write( rule2 );\r\n        output.close();\r\n\r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='http://localhost:9000/rule1.drl' type='DRL' />\";\r\n        xml += \"        <resource source='http://localhost:9000/rule2.drl' type='DRL' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        fxml.deleteOnExit();\r\n        output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                           \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n\r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                           \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                                                                         kbase,\r\n                                                                         aconf );\r\n\r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n\r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n\r\n        list.clear();\r\n\r\n        // have to sleep here as linux lastModified does not do milliseconds http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=1&t=019789\r\n        Thread.sleep( 2000 );\r\n\r\n        rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule3\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n        Thread.sleep( 3000 );\r\n\r\n        ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n\r\n        assertTrue( list.contains( \"rule3\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n        kagent.monitorResourceChangeEvents( false );        \r\n    }","id":24857,"modified_method":"public void  testModifyFileUrl() throws Exception {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        File f1 = fileManager.newFile( \"rule1.drl\" );\r\n        Writer output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n\r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n        File f2 = fileManager.newFile( \"rule2.drl\" );\r\n        output = new BufferedWriter( new FileWriter( f2 ) );\r\n        output.write( rule2 );\r\n        output.close();\r\n\r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='http://localhost:9000/rule1.drl' type='DRL' />\";\r\n        xml += \"        <resource source='http://localhost:9000/rule2.drl' type='DRL' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                           \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n\r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                           \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                                                                         kbase,\r\n                                                                         aconf );\r\n\r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n\r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n\r\n        list.clear();\r\n\r\n        // have to sleep here as linux lastModified does not do milliseconds http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=1&t=019789\r\n        Thread.sleep( 2000 );\r\n\r\n        rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule3\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n        Thread.sleep( 3000 );\r\n\r\n        ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n\r\n        assertTrue( list.contains( \"rule3\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n        kagent.monitorResourceChangeEvents( false );        \r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void  testOldSchoolPackageUrl() throws Exception {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n\r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n\r\n\r\n\r\n\r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule1.getBytes() ), ResourceType.DRL );\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule2.getBytes() ), ResourceType.DRL );\r\n        if ( kbuilder.hasErrors() ) {\r\n            fail( kbuilder.getErrors().toString() );\r\n        }\r\n\r\n        KnowledgeBuilderImpl kbi = (KnowledgeBuilderImpl) kbuilder;\r\n\r\n        //KnowledgePackage pkg = ( KnowledgePackage ) kbuilder.getKnowledgePackages().iterator().next();\r\n        writePackage( kbi.getPackageBuilder().getPackage(), fileManager.newFile( \"pkgold.pkg\" ) );\r\n\r\n\r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='http://localhost:9000/pkgold.pkg' type='PKG' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        fxml.deleteOnExit();\r\n        Writer output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n\r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                kbase,\r\n                aconf );\r\n\r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n\r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n\r\n\r\n    }","id":24858,"modified_method":"public void  testOldSchoolPackageUrl() throws Exception {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n\r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n\r\n\r\n\r\n\r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule1.getBytes() ), ResourceType.DRL );\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule2.getBytes() ), ResourceType.DRL );\r\n        if ( kbuilder.hasErrors() ) {\r\n            fail( kbuilder.getErrors().toString() );\r\n        }\r\n\r\n        KnowledgeBuilderImpl kbi = (KnowledgeBuilderImpl) kbuilder;\r\n\r\n        //KnowledgePackage pkg = ( KnowledgePackage ) kbuilder.getKnowledgePackages().iterator().next();\r\n        writePackage( kbi.getPackageBuilder().getPackage(), fileManager.newFile( \"pkgold.pkg\" ) );\r\n\r\n\r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='http://localhost:9000/pkgold.pkg' type='PKG' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        Writer output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n\r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                kbase,\r\n                aconf );\r\n\r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n\r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n\r\n\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void  testModifyFile() throws IOException,\r\n                                InterruptedException {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        File f1 = fileManager.newFile( \"rule1.drl\" );\r\n        f1.deleteOnExit();\r\n        Writer output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n\r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n        File f2 = fileManager.newFile( \"rule2.drl\" );\r\n        f2.deleteOnExit();\r\n        output = new BufferedWriter( new FileWriter( f2 ) );\r\n        output.write( rule2 );\r\n        output.close();\r\n\r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='\" + f1.toURI().toURL() + \"' type='DRL' />\";\r\n        xml += \"        <resource source='\" + f2.toURI().toURL() + \"' type='DRL' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        fxml.deleteOnExit();\r\n        output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                           \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n\r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                           \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                                                                         kbase,\r\n                                                                         aconf );\r\n\r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n\r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n\r\n        list.clear();\r\n\r\n        // have to sleep here as linux lastModified does not do milliseconds http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=1&t=019789\r\n        Thread.sleep( 2000 );\r\n\r\n        rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule3\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n        Thread.sleep( 3000 );\r\n\r\n        ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n\r\n        assertTrue( list.contains( \"rule3\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n        kagent.monitorResourceChangeEvents( false );\r\n    }","id":24859,"modified_method":"public void  testModifyFile() throws IOException,\r\n                                InterruptedException {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        File f1 = fileManager.newFile( \"rule1.drl\" );\r\n        Writer output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n\r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n        File f2 = fileManager.newFile( \"rule2.drl\" );\r\n        output = new BufferedWriter( new FileWriter( f2 ) );\r\n        output.write( rule2 );\r\n        output.close();\r\n\r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='\" + f1.toURI().toURL() + \"' type='DRL' />\";\r\n        xml += \"        <resource source='\" + f2.toURI().toURL() + \"' type='DRL' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n\r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n\r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                           \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n\r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                           \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                                                                         kbase,\r\n                                                                         aconf );\r\n\r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n\r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n\r\n        list.clear();\r\n\r\n        // have to sleep here as linux lastModified does not do milliseconds http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=1&t=019789\r\n        Thread.sleep( 2000 );\r\n\r\n        rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule3\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n        output = new BufferedWriter( new FileWriter( f1 ) );\r\n        output.write( rule1 );\r\n        output.close();\r\n        Thread.sleep( 3000 );\r\n\r\n        ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n\r\n        assertEquals( 2,\r\n                      list.size() );\r\n\r\n        assertTrue( list.contains( \"rule3\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n        kagent.monitorResourceChangeEvents( false );\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void  testModifyPackageUrl() throws Exception {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n    \r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n        \r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule1.getBytes() ), ResourceType.DRL );\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule2.getBytes() ), ResourceType.DRL );\r\n        if ( kbuilder.hasErrors() ) {\r\n            fail( kbuilder.getErrors().toString() );\r\n        }\r\n        KnowledgePackage pkg = ( KnowledgePackage ) kbuilder.getKnowledgePackages().iterator().next();\r\n        writePackage( pkg, fileManager.newFile( \"pkg1.pkg\" ) );\r\n        \r\n    \r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='http://localhost:9000/pkg1.pkg' type='PKG' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        fxml.deleteOnExit();\r\n        Writer output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n    \r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n    \r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                           \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n    \r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                           \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                                                                         kbase,\r\n                                                                         aconf );\r\n    \r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n    \r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n    \r\n        assertEquals( 2,\r\n                      list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n    \r\n        list.clear();\r\n    \r\n        // have to sleep here as linux lastModified does not do milliseconds http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=1&t=019789\r\n        Thread.sleep( 2000 );\r\n    \r\n        rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule3\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n    \r\n        kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule1.getBytes() ), ResourceType.DRL );\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule2.getBytes() ), ResourceType.DRL );\r\n        if ( kbuilder.hasErrors() ) {\r\n            fail( kbuilder.getErrors().toString() );\r\n        }\r\n        pkg = ( KnowledgePackage ) kbuilder.getKnowledgePackages().iterator().next();\r\n        writePackage( pkg, fileManager.newFile( \"pkg1.pkg\" ) );  \r\n        \r\n        //KnowledgePackage pkg2 = ( KnowledgePackage ) DroolsStreamUtils.streamIn( new FileInputStream( fileManager.newFile( \"pkg1.pkg\" ) ) );\r\n        \r\n        \r\n        Thread.sleep( 3000 );\r\n        \r\n        ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n    \r\n        assertEquals( 2,\r\n                      list.size() );\r\n    \r\n        assertTrue( list.contains( \"rule3\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n        kagent.monitorResourceChangeEvents( false );\r\n    }","id":24860,"modified_method":"public void  testModifyPackageUrl() throws Exception {\r\n        String rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule1\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n    \r\n        String rule2 = \"\";\r\n        rule2 += \"package org.drools.test\\n\";\r\n        rule2 += \"global java.util.List list\\n\";\r\n        rule2 += \"rule rule2\\n\";\r\n        rule2 += \"when\\n\";\r\n        rule2 += \"then\\n\";\r\n        rule2 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule2 += \"end\\n\";\r\n        \r\n        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule1.getBytes() ), ResourceType.DRL );\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule2.getBytes() ), ResourceType.DRL );\r\n        if ( kbuilder.hasErrors() ) {\r\n            fail( kbuilder.getErrors().toString() );\r\n        }\r\n        KnowledgePackage pkg = ( KnowledgePackage ) kbuilder.getKnowledgePackages().iterator().next();\r\n        writePackage( pkg, fileManager.newFile( \"pkg1.pkg\" ) );\r\n        \r\n    \r\n        String xml = \"\";\r\n        xml += \"<change-set xmlns='http://drools.org/drools-5.0/change-set'\";\r\n        xml += \"    xmlns:xs='http://www.w3.org/2001/XMLSchema-instance'\";\r\n        xml += \"    xs:schemaLocation='http://drools.org/drools-5.0/change-set drools-change-set-5.0.xsd' >\";\r\n        xml += \"    <add> \";\r\n        xml += \"        <resource source='http://localhost:9000/pkg1.pkg' type='PKG' />\";\r\n        xml += \"    <\/add> \";\r\n        xml += \"<\/change-set>\";\r\n        File fxml = fileManager.newFile( \"changeset.xml\" );\r\n        Writer output = new BufferedWriter( new FileWriter( fxml ) );\r\n        output.write( xml );\r\n        output.close();\r\n    \r\n        KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();\r\n    \r\n        ResourceChangeScannerConfiguration sconf = ResourceFactory.getResourceChangeScannerService().newResourceChangeScannerConfiguration();\r\n        sconf.setProperty( \"drools.resource.scanner.interval\",\r\n                           \"2\" );\r\n        ResourceFactory.getResourceChangeScannerService().configure( sconf );\r\n    \r\n        KnowledgeAgentConfiguration aconf = KnowledgeAgentFactory.newKnowledgeAgentConfiguration();\r\n        aconf.setProperty( \"drools.agent.scanDirectories\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.scanResources\",\r\n                           \"true\" );\r\n        aconf.setProperty( \"drools.agent.newInstance\",\r\n                           \"true\" );\r\n        KnowledgeAgent kagent = KnowledgeAgentFactory.newKnowledgeAgent( \"test agent\",\r\n                                                                         kbase,\r\n                                                                         aconf );\r\n    \r\n        kagent.applyChangeSet( ResourceFactory.newUrlResource( fxml.toURI().toURL() ) );\r\n    \r\n        StatefulKnowledgeSession ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        List list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n    \r\n        assertEquals( 2,\r\n                      list.size() );\r\n        assertTrue( list.contains( \"rule1\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n    \r\n        list.clear();\r\n    \r\n        // have to sleep here as linux lastModified does not do milliseconds http://saloon.javaranch.com/cgi-bin/ubb/ultimatebb.cgi?ubb=get_topic&f=1&t=019789\r\n        Thread.sleep( 2000 );\r\n    \r\n        rule1 = \"\";\r\n        rule1 += \"package org.drools.test\\n\";\r\n        rule1 += \"global java.util.List list\\n\";\r\n        rule1 += \"rule rule3\\n\";\r\n        rule1 += \"when\\n\";\r\n        rule1 += \"then\\n\";\r\n        rule1 += \"list.add( drools.getRule().getName() );\\n\";\r\n        rule1 += \"end\\n\";\r\n    \r\n        kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule1.getBytes() ), ResourceType.DRL );\r\n        kbuilder.add( ResourceFactory.newByteArrayResource( rule2.getBytes() ), ResourceType.DRL );\r\n        if ( kbuilder.hasErrors() ) {\r\n            fail( kbuilder.getErrors().toString() );\r\n        }\r\n        pkg = ( KnowledgePackage ) kbuilder.getKnowledgePackages().iterator().next();\r\n        writePackage( pkg, fileManager.newFile( \"pkg1.pkg\" ) );  \r\n        \r\n        //KnowledgePackage pkg2 = ( KnowledgePackage ) DroolsStreamUtils.streamIn( new FileInputStream( fileManager.newFile( \"pkg1.pkg\" ) ) );\r\n        \r\n        \r\n        Thread.sleep( 3000 );\r\n        \r\n        ksession = kagent.getKnowledgeBase().newStatefulKnowledgeSession();\r\n        list = new ArrayList();\r\n        ksession.setGlobal( \"list\",\r\n                            list );\r\n        ksession.fireAllRules();\r\n        ksession.dispose();\r\n    \r\n        assertEquals( 2,\r\n                      list.size() );\r\n    \r\n        assertTrue( list.contains( \"rule3\" ) );\r\n        assertTrue( list.contains( \"rule2\" ) );\r\n        kagent.monitorResourceChangeEvents( false );\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"ProcessChangeSet(LinkedBlockingQueue<ChangeSet> queue,\r\n                         ResourceChangeNotifierImpl notifier,\r\n                         SystemEventListener listener) {\r\n            this.queue = queue;\r\n            this.notifier = notifier;\r\n            this.listener = listener;\r\n        }","id":24861,"modified_method":"ProcessChangeSet(LinkedBlockingQueue<ChangeSet> queue,\r\n                         ResourceChangeNotifierImpl notifier,\r\n                         SystemEventListener listener) {\r\n            this.queue = queue;\r\n            this.notifier = notifier;\r\n            this.listener = listener;\r\n            this.notify = true;\r\n        }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void stop() {\r\n        this.processChangeSet.setNotify( false );\r\n        this.thread.interrupt();\r\n    }","id":24862,"modified_method":"public void stop() {\r\n        this.processChangeSet.stop();\r\n        this.thread.interrupt();\r\n        this.processChangeSet = null;\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void start() {\r\n        if ( this.processChangeSet == null ) {\r\n            this.processChangeSet = new ProcessChangeSet( this.queue,\r\n                                                          this,\r\n                                                          this.listener );\r\n        }\r\n\r\n        if ( !this.processChangeSet.isRunning() ) {\r\n            this.processChangeSet.setNotify( true );\r\n            this.thread = new Thread( this.processChangeSet );\r\n            this.thread.start();\r\n        }\r\n    }","id":24863,"modified_method":"public void start() {\r\n        this.processChangeSet = new ProcessChangeSet( this.queue,\r\n                                                      this,\r\n                                                      this.listener );\r\n\r\n        this.thread = new Thread( this.processChangeSet );\r\n        this.thread.start();\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void setInterval(int interval) {\r\n        this.scannerScheduler.setInterval( interval );\r\n    }","id":24864,"modified_method":"public void setInterval(int interval) {\r\n        this.interval = interval;\r\n        this.listener.info( \"ResourceChangeScanner reconfigured with interval=\" + getInterval() );\r\n\r\n        if ( this.scannerScheduler != null && this.scannerScheduler.isRunning() ) {\r\n            stop();\r\n            start();\r\n        }\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void stop() {\r\n        this.scannerScheduler.setScan( false );\r\n        this.thread.interrupt();\r\n    }","id":24865,"modified_method":"public void stop() {\r\n        if ( this.scannerScheduler != null && this.scannerScheduler.isRunning() ) {\r\n            this.scannerScheduler.stop();\r\n            this.thread.interrupt();\r\n            this.scannerScheduler = null;\r\n        }\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void configure(ResourceChangeScannerConfiguration configuration) {\r\n        setInterval( ((ResourceChangeScannerConfigurationImpl) configuration).getInterval() );\r\n        this.listener.info( \"ResourceChangeScanner reconfigured with interval=\" + ( getInterval() ) );\r\n        \r\n        // restart it if it's already running.\r\n        if ( this.scannerScheduler.isRunning() ) {\r\n            stop();\r\n            start();           \r\n        }\r\n    }","id":24866,"modified_method":"public void configure(ResourceChangeScannerConfiguration configuration) {\r\n        this.interval = ((ResourceChangeScannerConfigurationImpl) configuration).getInterval();\r\n        this.listener.info( \"ResourceChangeScanner reconfigured with interval=\" + getInterval() );\r\n\r\n        // restart it if it's already running.\r\n        if ( this.scannerScheduler != null && this.scannerScheduler.isRunning() ) {\r\n            stop();\r\n            start();\r\n        }\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"ProcessChangeSet(Map<Resource, Set<ResourceChangeNotifier>> resources,\r\n                         ResourceChangeScannerImpl scanner,\r\n                         SystemEventListener listener) {\r\n            this.resources = resources;\r\n            this.scanner = scanner;\r\n            this.listener = listener;\r\n        }","id":24867,"modified_method":"ProcessChangeSet(Map<Resource, Set<ResourceChangeNotifier>> resources,\r\n                         ResourceChangeScannerImpl scanner,\r\n                         SystemEventListener listener,\r\n                         int interval) {\r\n            this.resources = resources;\r\n            this.scanner = scanner;\r\n            this.listener = listener;\r\n            this.interval = interval;\r\n            this.scan = true;\r\n        }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public int getInterval() {\r\n        return this.scannerScheduler.getInterval();\r\n    }","id":24868,"modified_method":"public int getInterval() {\r\n        return this.interval;\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public ResourceChangeScannerImpl() {\r\n        this.listener = SystemEventListenerFactory.getSystemEventListener();\r\n        this.resources = new HashMap<Resource, Set<ResourceChangeNotifier>>();\r\n        this.directories = new HashSet<Resource>();\r\n        this.scannerScheduler = new ProcessChangeSet( this.resources,\r\n                                                      this,\r\n                                                      this.listener );\r\n        setInterval( 60 );\r\n        this.listener.info( \"ResourceChangeScanner created with default interval=60\" );\r\n    }","id":24869,"modified_method":"public ResourceChangeScannerImpl() {\r\n        this.listener = SystemEventListenerFactory.getSystemEventListener();\r\n        this.resources = new HashMap<Resource, Set<ResourceChangeNotifier>>();\r\n        this.directories = new HashSet<Resource>();\r\n        this.interval = 60;\r\n        this.listener.info( \"ResourceChangeScanner created with default interval=60\" );\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void run() {\r\n            synchronized ( this ) {\r\n                if ( this.scan ) {\r\n                    this.listener.info( \"ResourceChangeNotification scanner has started\" );\r\n                }\r\n                while ( this.scan ) {\r\n                    Exception exception = null;\r\n                    //System.out.println( \"BEFORE : sync this.resources\" );\r\n                    synchronized ( this.resources ) {      \r\n                        //System.out.println( \"DURING : sync this.resources\" );\r\n                        // lock the resources, as we don't want this modified while processing\r\n                        this.scanner.scan();\r\n                    }\r\n                    //System.out.println( \"AFTER : SCAN\" );\r\n                    try {\r\n                        this.listener.debug( \"ResourceChangeScanner thread is waiting for \" + this.interval );\r\n                        wait( this.interval * 1000 );\r\n                    } catch ( InterruptedException e ) {\r\n                        exception = e;\r\n                    }\r\n                    \r\n                    if ( this.scan && exception != null) {\r\n                        this.listener.exception( new RuntimeException( \"ResourceChangeNotification ChangeSet scanning thread was interrupted, but shutdown was not scheduled\",\r\n                                                                       exception ) );                        \r\n                    }\r\n                }\r\n                this.listener.info( \"ResourceChangeNotification scanner has stopped\" );\r\n            }\r\n        }","id":24870,"modified_method":"public void run() {\r\n            synchronized ( this ) {\r\n                if ( this.scan ) {\r\n                    this.listener.info( \"ResourceChangeNotification scanner has started\" );\r\n                }\r\n                while ( this.scan ) {\r\n                    Exception exception = null;\r\n                    //System.out.println( \"BEFORE : sync this.resources\" );\r\n                    synchronized ( this.resources ) {\r\n                        //System.out.println( \"DURING : sync this.resources\" );\r\n                        // lock the resources, as we don't want this modified while processing\r\n                        this.scanner.scan();\r\n                    }\r\n                    //System.out.println( \"AFTER : SCAN\" );\r\n                    try {\r\n                        this.listener.debug( \"ResourceChangeScanner thread is waiting for \" + this.interval );\r\n                        wait( this.interval * 1000 );\r\n                    } catch ( InterruptedException e ) {\r\n                        exception = e;\r\n                    }\r\n\r\n                    if ( this.scan && exception != null ) {\r\n                        this.listener.exception( new RuntimeException( \"ResourceChangeNotification ChangeSet scanning thread was interrupted, but shutdown was not requested\",\r\n                                                                       exception ) );\r\n                    }\r\n                }\r\n                this.listener.info( \"ResourceChangeNotification scanner has stopped\" );\r\n            }\r\n        }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void start() {\r\n        if ( !this.scannerScheduler.isRunning() ) {\r\n            this.scannerScheduler.setScan( true );\r\n            thread = new Thread( this.scannerScheduler );\r\n            thread.start();\r\n        }\r\n    }","id":24871,"modified_method":"public void start() {\r\n        this.scannerScheduler = new ProcessChangeSet( this.resources,\r\n                                                      this,\r\n                                                      this.listener,\r\n                                                      this.interval );\r\n        thread = new Thread( this.scannerScheduler );\r\n        thread.start();\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public long getLastModified() {\r\n        try {\r\n            // use File, as http rounds milliseconds on some machines, this fine level of granularity is only really an issue for testing\r\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4504473\r\n            if ( \"file\".equals( url.getProtocol() ) ) {\r\n                File file = getFile();\r\n                return file.lastModified();\r\n            } else {\r\n                URLConnection conn = getURL().openConnection();\r\n                if ( conn instanceof HttpURLConnection ) {\r\n                    ((HttpURLConnection) conn).setRequestMethod( \"HEAD\" );\r\n                }\r\n                long date = conn.getLastModified();\r\n                return date;\r\n            }\r\n        } catch ( IOException e ) {\r\n            throw new RuntimeException( \"Unable to get LastMofified for ClasspathResource\",\r\n                                        e );\r\n        }\r\n    }","id":24872,"modified_method":"public long getLastModified() {\r\n        try {\r\n            // use File, as http rounds milliseconds on some machines, this fine level of granularity is only really an issue for testing\r\n            // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4504473\r\n            if ( \"file\".equals( url.getProtocol() ) ) {\r\n                File file = getFile();\r\n                return file.lastModified();\r\n            } else {\r\n                URLConnection conn = getURL().openConnection();\r\n                if ( conn instanceof HttpURLConnection ) {\r\n                    ((HttpURLConnection) conn).setRequestMethod( \"HEAD\" );\r\n                }\r\n                long date =  conn.getHeaderFieldDate(\"Last-Modified\", 0); //conn.getLastModified(); to keep mic happy :)\r\n                return date;\r\n            }\r\n        } catch ( IOException e ) {\r\n            throw new RuntimeException( \"Unable to get LastMofified for ClasspathResource\",\r\n                                        e );\r\n        }\r\n    }","commit_id":"2e86a1b25472a4ce385c91f20bc1d0d4a9e47c4b","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public static boolean isCompiledKotlinClass(@NotNull JavaClass javaClass) {\n        if (javaClass.getOriginKind() == JavaClass.OriginKind.COMPILED) {\n            return javaClass.findAnnotation(JvmAnnotationNames.KOTLIN_CLASS.getFqName().asString()) != null;\n        }\n        return false;\n    }","id":24873,"modified_method":"public static boolean isCompiledKotlinClass(@NotNull JavaClass javaClass) {\n        if (javaClass.getOriginKind() == JavaClass.OriginKind.COMPILED) {\n            return javaClass.findAnnotation(JvmAnnotationNames.KOTLIN_CLASS.getFqName()) != null;\n        }\n        return false;\n    }","commit_id":"2191073761e5cd61d8eaf65191071737c6b1010b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static boolean isCompiledKotlinPackageClass(@NotNull JavaClass javaClass) {\n        if (javaClass.getOriginKind() == JavaClass.OriginKind.COMPILED) {\n            FqName fqName = javaClass.getFqName();\n            if (fqName != null && PackageClassUtils.isPackageClassFqName(fqName)) {\n                return javaClass.findAnnotation(JvmAnnotationNames.KOTLIN_PACKAGE.getFqName().asString()) != null;\n            }\n        }\n        return false;\n    }","id":24874,"modified_method":"public static boolean isCompiledKotlinPackageClass(@NotNull JavaClass javaClass) {\n        if (javaClass.getOriginKind() == JavaClass.OriginKind.COMPILED) {\n            FqName fqName = javaClass.getFqName();\n            if (fqName != null && PackageClassUtils.isPackageClassFqName(fqName)) {\n                return javaClass.findAnnotation(JvmAnnotationNames.KOTLIN_PACKAGE.getFqName()) != null;\n            }\n        }\n        return false;\n    }","commit_id":"2191073761e5cd61d8eaf65191071737c6b1010b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private ClassDescriptor doResolveClass(@NotNull FqName qualifiedName, @NotNull PostponedTasks tasks) {\n        //TODO: correct scope\n        VirtualFile file = virtualFileFinder.find(qualifiedName);\n        if (file != null) {\n            //TODO: code duplication\n            //TODO: it is a hackish way to determine whether it is inner class or not\n            boolean isInnerClass = file.getName().contains(\"$\");\n            ClassOrNamespaceDescriptor containingDeclaration = resolveParentDescriptor(qualifiedName, isInnerClass);\n            // class may be resolved during resolution of parent\n            ClassDescriptor cachedDescriptor = classDescriptorCache.get(javaClassToKotlinFqName(qualifiedName));\n            if (cachedDescriptor != null) {\n                return cachedDescriptor;\n            }\n            assert !unresolvedCache.contains(qualifiedName.toUnsafe())\n                    : \"We can resolve the class, so it can't be 'unresolved' during parent resolution\";\n\n            ClassId id = ClassId.fromFqNameAndContainingDeclaration(qualifiedName, containingDeclaration);\n            ClassDescriptor deserializedDescriptor = deserializedDescriptorResolver.resolveClass(id, file);\n            if (deserializedDescriptor != null) {\n                cache(javaClassToKotlinFqName(qualifiedName), deserializedDescriptor);\n                return deserializedDescriptor;\n            }\n        }\n\n        JavaClass javaClass = javaClassFinder.findClass(qualifiedName);\n        if (javaClass == null) {\n            cacheNegativeValue(javaClassToKotlinFqName(qualifiedName));\n            return null;\n        }\n\n        if (KotlinBuiltIns.BUILT_INS_PACKAGE_FQ_NAME.equals(qualifiedName.parent())) {\n            if (javaClass.findAnnotation(JvmAnnotationNames.ASSERT_INVISIBLE_IN_RESOLVER.getFqName().asString()) != null) {\n                if (ApplicationManager.getApplication().isInternal()) {\n                    LOG.error(\"classpath is configured incorrectly:\" +\n                              \" class \" + qualifiedName + \" from runtime must not be loaded by compiler\");\n                }\n                return null;\n            }\n        }\n\n        // Class may have been resolved previously by different Java resolver instance, and we are reusing its trace\n        ClassDescriptor alreadyResolved = cache.getClass(javaClass);\n        if (alreadyResolved != null) {\n            return alreadyResolved;\n        }\n\n        //TODO: code duplication\n        ClassOrNamespaceDescriptor containingDeclaration = resolveParentDescriptor(qualifiedName, javaClass.getOuterClass() != null);\n        // class may be resolved during resolution of parent\n        ClassDescriptor cachedDescriptor = classDescriptorCache.get(javaClassToKotlinFqName(qualifiedName));\n        if (cachedDescriptor != null) {\n            return cachedDescriptor;\n        }\n        assert !unresolvedCache.contains(qualifiedName.toUnsafe())\n                : \"We can resolve the class, so it can't be 'unresolved' during parent resolution\";\n\n        checkFqNamesAreConsistent(javaClass, qualifiedName);\n\n        assert javaClass.getOriginKind() != JavaClass.OriginKind.KOTLIN_LIGHT_CLASS :\n                \"Trying to resolve a light class as a regular PsiClass: \" + javaClass.getFqName();\n\n        return doCreateClassDescriptor(qualifiedName, javaClass, tasks, containingDeclaration);\n    }","id":24875,"modified_method":"private ClassDescriptor doResolveClass(@NotNull FqName qualifiedName, @NotNull PostponedTasks tasks) {\n        //TODO: correct scope\n        VirtualFile file = virtualFileFinder.find(qualifiedName);\n        if (file != null) {\n            //TODO: code duplication\n            //TODO: it is a hackish way to determine whether it is inner class or not\n            boolean isInnerClass = file.getName().contains(\"$\");\n            ClassOrNamespaceDescriptor containingDeclaration = resolveParentDescriptor(qualifiedName, isInnerClass);\n            // class may be resolved during resolution of parent\n            ClassDescriptor cachedDescriptor = classDescriptorCache.get(javaClassToKotlinFqName(qualifiedName));\n            if (cachedDescriptor != null) {\n                return cachedDescriptor;\n            }\n            assert !unresolvedCache.contains(qualifiedName.toUnsafe())\n                    : \"We can resolve the class, so it can't be 'unresolved' during parent resolution\";\n\n            ClassId id = ClassId.fromFqNameAndContainingDeclaration(qualifiedName, containingDeclaration);\n            ClassDescriptor deserializedDescriptor = deserializedDescriptorResolver.resolveClass(id, file);\n            if (deserializedDescriptor != null) {\n                cache(javaClassToKotlinFqName(qualifiedName), deserializedDescriptor);\n                return deserializedDescriptor;\n            }\n        }\n\n        JavaClass javaClass = javaClassFinder.findClass(qualifiedName);\n        if (javaClass == null) {\n            cacheNegativeValue(javaClassToKotlinFqName(qualifiedName));\n            return null;\n        }\n\n        if (KotlinBuiltIns.BUILT_INS_PACKAGE_FQ_NAME.equals(qualifiedName.parent())) {\n            if (javaClass.findAnnotation(JvmAnnotationNames.ASSERT_INVISIBLE_IN_RESOLVER.getFqName()) != null) {\n                if (ApplicationManager.getApplication().isInternal()) {\n                    LOG.error(\"classpath is configured incorrectly:\" +\n                              \" class \" + qualifiedName + \" from runtime must not be loaded by compiler\");\n                }\n                return null;\n            }\n        }\n\n        // Class may have been resolved previously by different Java resolver instance, and we are reusing its trace\n        ClassDescriptor alreadyResolved = cache.getClass(javaClass);\n        if (alreadyResolved != null) {\n            return alreadyResolved;\n        }\n\n        //TODO: code duplication\n        ClassOrNamespaceDescriptor containingDeclaration = resolveParentDescriptor(qualifiedName, javaClass.getOuterClass() != null);\n        // class may be resolved during resolution of parent\n        ClassDescriptor cachedDescriptor = classDescriptorCache.get(javaClassToKotlinFqName(qualifiedName));\n        if (cachedDescriptor != null) {\n            return cachedDescriptor;\n        }\n        assert !unresolvedCache.contains(qualifiedName.toUnsafe())\n                : \"We can resolve the class, so it can't be 'unresolved' during parent resolution\";\n\n        checkFqNamesAreConsistent(javaClass, qualifiedName);\n\n        assert javaClass.getOriginKind() != JavaClass.OriginKind.KOTLIN_LIGHT_CLASS :\n                \"Trying to resolve a light class as a regular PsiClass: \" + javaClass.getFqName();\n\n        return doCreateClassDescriptor(qualifiedName, javaClass, tasks, containingDeclaration);\n    }","commit_id":"2191073761e5cd61d8eaf65191071737c6b1010b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public Object getValueAt(int row, int column)\n         {\n             \n             categoryIncluded.trimToSize();\n             \n             if(current == null && currentMultiples == null)\n                 return \"null\";\n             else if(currentMultiples != null)\n             {\n               java.util.List<VueMetadataElement> list = currentMultiples.getMetadataList().getMetadata();\n             \n               if(list.size() == 0)\n                 addNewRow();\n               else\n               if(list.size() < row + 1)\n                 return null;\n               //while(list.size() < row + 1)\n               //  addNewRow();\n             \n               return currentMultiples.getMetadataList().getCategoryListElement(row);\n               //return current.getMetadataList().getMetadata().get(row);                 \n             }\n             \n               java.util.List<VueMetadataElement> list = current.getMetadataList().getMetadata();\n             \n             if(list.size() == 0)\n                 addNewRow();\n             else\n             if(list.size() < row + 1)\n                 return null;\n             //while(list.size() < row + 1)\n             //  addNewRow();\n             \n             return current.getMetadataList().getCategoryListElement(row);\n             //return current.getMetadataList().getMetadata().get(row);\n         }","id":24876,"modified_method":"public Object getValueAt(int row, int column)\n         {\n             \n             categoryIncluded.trimToSize();\n             \n             if(current == null && currentMultiples == null)\n                 return \"null\";\n             else if(currentMultiples != null)\n             {\n               /*java.util.List<VueMetadataElement> list = currentMultiples.getMetadataList().getMetadata();\n             \n               if(list.size() == 0)\n                 addNewRow();\n               else\n               if(list.size() < row + 1)\n                 return null;*/\n                 \n               if(currentMultiples.getMetadataList().getCategoryListSize() == 0)\n                 addNewRow();\n               else\n                 if(currentMultiples.getMetadataList().getCategoryListSize() < row + 1)\n                   return null;\n                 \n               //while(list.size() < row + 1)\n               //  addNewRow();\n             \n               return currentMultiples.getMetadataList().getCategoryListElement(row);\n               //return current.getMetadataList().getMetadata().get(row);                 \n             }\n             \n             /*java.util.List<VueMetadataElement> list = current.getMetadataList().getMetadata();\n             \n             if(list.size() == 0)\n                 addNewRow();\n             else\n             if(list.size() < row + 1)\n                 return null; */\n             \n             if(current.getMetadataList().getCategoryListSize() == 0)\n                 addNewRow();\n             else\n                 if(current.getMetadataList().getCategoryListSize() < row + 1)\n                   return null;\n             \n             //while(list.size() < row + 1)\n             //  addNewRow();\n             \n             return current.getMetadataList().getCategoryListElement(row);\n             //return current.getMetadataList().getMetadata().get(row);\n         }","commit_id":"f9c446de80a916f4bfd07b7ffb29b4bd1a1d3352","url":"https://github.com/VUE/VUE"},{"original_method":"public java.awt.Component getTableCellRendererComponent(JTable table, Object value,boolean isSelected,boolean hasFocus,int row,int col)\n       {\n           JPanel comp = new JPanel();\n           //JComboBox categories = new JComboBox();\n           categories.setFont(GUI.LabelFace);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           \n           comp.setLayout(new BorderLayout());\n           if(col == buttonColumn-2)\n           {\n               int n = categories.getModel().getSize();\n               \n               Object currObject = null;\n               if(current != null)\n                       currObject = current.getMetadataList().getMetadata().get(row).getObject();//table.getModel().getValueAt(row,col);\n               else if(currentMultiples!=null)\n                       currObject = currentMultiples.getMetadataList().getMetadata().get(row).getObject();//table.getModel().getValueAt(row,col);\n               Object currValue = (((String[])currObject)[0]);\n               boolean found = findCategory(currValue,row,col,n,categories); \n              \n               MetadataTableModel model = (MetadataTableModel)table.getModel();\n               \n               if((found) || !model.getIsSaved(row))\n               {    \n                 model.setCategoryFound(row,true);  \n                   \n                 if(!model.getIsSaved(row) )\n                  comp.add(categories);\n                 else\n                 {\n                   String customName = currValue.toString();\n                   int ontSeparatorLocation = customName.indexOf(edu.tufts.vue.rdf.RDFIndex.ONT_SEPARATOR);\n                   if( ontSeparatorLocation != -1 && ontSeparatorLocation != customName.length() - 1)\n                   {\n                       customName = customName.substring(ontSeparatorLocation + 1,customName.length());\n                   }\n                   JLabel custom = new JLabel(customName);\n                   custom.setFont(GUI.LabelFace);\n                   comp.add(custom);\n                 }\n               }\n               else\n               {\n                 model.setCategoryFound(row,false);  \n                 String customName = currValue.toString();\n                 int ontSeparatorLocation = customName.indexOf(edu.tufts.vue.rdf.RDFIndex.ONT_SEPARATOR);\n                 if( ontSeparatorLocation != -1 && ontSeparatorLocation != customName.length() - 1)\n                 {\n                     customName = customName.substring(ontSeparatorLocation + 1,customName.length());\n                 }\n                 JLabel custom = new JLabel(customName+\"*\");\n                 custom.setFont(GUI.LabelFace);\n                 comp.add(custom);\n                 JLabel addLabel = new JLabel(\"[+]\");\n                 comp.add(addLabel,BorderLayout.EAST);\n               }\n               \n           }\n           else if(col == buttonColumn-1)\n           {\n               \n               boolean saved = ((MetadataTableModel)metadataTable.getModel()).getIsSaved(row);\n               \n               if(value instanceof VueMetadataElement)\n               {\n                   VueMetadataElement vme = (VueMetadataElement)value;\n                   if(saved == true)\n                   {\n                     JLabel custom = new JLabel(vme.getValue());\n                     custom.setFont(GUI.LabelFace);\n                     comp.add(custom);\n                   }\n                   else \n                   if(saved == false)\n                   {\n                     JTextField field = new JTextField(vme.getValue());\n                     field.setFont(GUI.LabelFace);\n                     comp.add(field);\n                   }\n               } \n               else\n               {\n                   if(DEBUG_LOCAL && value != null)\n                   {\n                       System.out.println(\"MetadataEditor -- renderer for field not vme: \" + value.getClass());\n                   }\n               }\n                 \n           }\n           else if(col == buttonColumn)               \n           {\n               //JLabel buttonLabel = new JLabel();\n               \n               // VUE-912, put delete button back -- also add back mouselistener\n               //if(row!=0)\n               //{    \n                 //buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               //}\n               //comp.add(buttonLabel);\n               \n               //$\n                 //comp.setOpaque(true);\n                 //comp.setBackground(java.awt.Color.RED);\n               //$\n               \n               //JPanel holder = new JPanel();\n               holder.add(deleteButton);\n               comp.add(holder);\n           }\n           \n           comp.setOpaque(false);\n           \n           comp.setBorder(getMetadataCellBorder(row,col));\n           \n           return comp;\n       }","id":24877,"modified_method":"public java.awt.Component getTableCellRendererComponent(JTable table, Object value,boolean isSelected,boolean hasFocus,int row,int col)\n       {\n           JPanel comp = new JPanel();\n           //JComboBox categories = new JComboBox();\n           categories.setFont(GUI.LabelFace);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           \n           comp.setLayout(new BorderLayout());\n           if(col == buttonColumn-2)\n           {\n               int n = categories.getModel().getSize();\n               \n               Object currObject = null;\n               if(current != null)\n                       currObject = current.getMetadataList().getCategoryList().get(row).getObject();//table.getModel().getValueAt(row,col);\n               else if(currentMultiples!=null)\n                       currObject = currentMultiples.getMetadataList().getCategoryList().get(row).getObject();//table.getModel().getValueAt(row,col);\n               Object currValue = (((String[])currObject)[0]);\n               boolean found = findCategory(currValue,row,col,n,categories); \n              \n               MetadataTableModel model = (MetadataTableModel)table.getModel();\n               \n               if((found) || !model.getIsSaved(row))\n               {    \n                 model.setCategoryFound(row,true);  \n                   \n                 if(!model.getIsSaved(row) )\n                  comp.add(categories);\n                 else\n                 {\n                   String customName = currValue.toString();\n                   int ontSeparatorLocation = customName.indexOf(edu.tufts.vue.rdf.RDFIndex.ONT_SEPARATOR);\n                   if( ontSeparatorLocation != -1 && ontSeparatorLocation != customName.length() - 1)\n                   {\n                       customName = customName.substring(ontSeparatorLocation + 1,customName.length());\n                   }\n                   JLabel custom = new JLabel(customName);\n                   custom.setFont(GUI.LabelFace);\n                   comp.add(custom);\n                 }\n               }\n               else\n               {\n                 model.setCategoryFound(row,false);  \n                 String customName = currValue.toString();\n                 int ontSeparatorLocation = customName.indexOf(edu.tufts.vue.rdf.RDFIndex.ONT_SEPARATOR);\n                 if( ontSeparatorLocation != -1 && ontSeparatorLocation != customName.length() - 1)\n                 {\n                     customName = customName.substring(ontSeparatorLocation + 1,customName.length());\n                 }\n                 JLabel custom = new JLabel(customName+\"*\");\n                 custom.setFont(GUI.LabelFace);\n                 comp.add(custom);\n                 JLabel addLabel = new JLabel(\"[+]\");\n                 comp.add(addLabel,BorderLayout.EAST);\n               }\n               \n           }\n           else if(col == buttonColumn-1)\n           {\n               \n               boolean saved = ((MetadataTableModel)metadataTable.getModel()).getIsSaved(row);\n               \n               if(value instanceof VueMetadataElement)\n               {\n                   VueMetadataElement vme = (VueMetadataElement)value;\n                   if(saved == true)\n                   {\n                     JLabel custom = new JLabel(vme.getValue());\n                     custom.setFont(GUI.LabelFace);\n                     comp.add(custom);\n                   }\n                   else \n                   if(saved == false)\n                   {\n                     JTextField field = new JTextField(vme.getValue());\n                     field.setFont(GUI.LabelFace);\n                     comp.add(field);\n                   }\n               } \n               else\n               {\n                   if(DEBUG_LOCAL && value != null)\n                   {\n                       System.out.println(\"MetadataEditor -- renderer for field not vme: \" + value.getClass());\n                   }\n               }\n                 \n           }\n           else if(col == buttonColumn)               \n           {\n               //JLabel buttonLabel = new JLabel();\n               \n               // VUE-912, put delete button back -- also add back mouselistener\n               //if(row!=0)\n               //{    \n                 //buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               //}\n               //comp.add(buttonLabel);\n               \n               //$\n                 //comp.setOpaque(true);\n                 //comp.setBackground(java.awt.Color.RED);\n               //$\n               \n               //JPanel holder = new JPanel();\n               holder.add(deleteButton);\n               comp.add(holder);\n           }\n           \n           comp.setOpaque(false);\n           \n           comp.setBorder(getMetadataCellBorder(row,col));\n           \n           return comp;\n       }","commit_id":"f9c446de80a916f4bfd07b7ffb29b4bd1a1d3352","url":"https://github.com/VUE/VUE"},{"original_method":"public java.awt.Component getTableCellEditorComponent(final JTable table,final Object value,boolean isSelected,final int row,final int col)\n       {\n           final JTextField field = new JTextField();\n           final JComboBox categories = new JComboBox();\n           categories.setFont(GUI.LabelFace);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           final JLabel categoryLabel = new JLabel();\n           final JLabel notEditable = new JLabel();\n           final JPanel comp = new JPanel();\n           \n           //edu.tufts.vue.metadata.gui.MetaButton deleteButton = new \n           //                       edu.tufts.vue.metadata.gui.MetaButton(MetadataEditor.this,\"delete\");\n           \n           comp.addMouseListener(new MouseAdapter(){\n              public void mousePressed(MouseEvent e)\n              {\n                  ((MetadataTableModel)metadataTable.getModel()).setSaved(row,true);\n                  stopCellEditing();\n              }\n           });\n           \n           currentRow = row;\n           \n           notEditable.setFont(GUI.LabelFace);\n           field.setFont(GUI.LabelFace);\n           \n           categories.addItemListener(new ItemListener() \n           {\n               public void itemStateChanged(ItemEvent e) \n               {\n                   if(DEBUG_LOCAL)\n                   {    \n                      System.out.println(\"MetdataEditor categories item listener itemStateChanged: \" + e);\n                   }\n                   \n                   \n                   if(e.getStateChange() == ItemEvent.SELECTED)\n                   {   \n                       if(e.getItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem)\n                       {                           \n                           JDialog ecd = new JDialog(VUE.getApplicationFrame(),\"Edit Categories\");\n                           ecd.setModal(true);\n                           ecd.add(new CategoryEditor(ecd,categories,MetadataEditor.this,current,row,col));\n                           ecd.setBounds(475,300,300,250);\n                           ecd.setVisible(true);\n                           \n                           metadataTable.getCellEditor().stopCellEditing();\n                           ((MetadataTableModel)metadataTable.getModel()).refresh();\n                       }\n                   }\n               }\n           });\n           \n           categories.addFocusListener(new FocusAdapter(){\n               public void focusLost(java.awt.event.FocusEvent fe)\n               {      \n                   MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n                   if(model.lastSavedRow != row)\n                   {    \n                     model.setSaved(row,true);\n                   }\n               }\n           });\n           \n           categories.addItemListener(new java.awt.event.ItemListener(){\n              public void itemStateChanged(java.awt.event.ItemEvent ie)\n              {\n                  \n                  if(ie.getStateChange()==java.awt.event.ItemEvent.SELECTED)\n                  {\n                      \n                    if(categories.getSelectedItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem)\n                    {\n                        return;\n                    }\n                      \n                    VueMetadataElement vme = new VueMetadataElement();\n                    \n                    String[] keyValuePair = {((OntType)categories.getSelectedItem()).getBase()+\"#\"+((OntType)categories.getSelectedItem()).getLabel(),\n                                               ((VueMetadataElement)table.getModel().getValueAt(row,buttonColumn - 1)).getValue()};\n                    \n                    vme.setObject(keyValuePair);\n                    vme.setType(VueMetadataElement.CATEGORY);\n                    if(currentMultiples != null)\n                    {\n                      // also need to add/set for individuals in group.. todo: subclass LWGroup to do this?\n                      // in the meantime just set these by hand\n                      if(currentMultiples.getMetadataList().getMetadata().size() > (row))\n                      {\n                        VueMetadataElement oldVME = currentMultiples.getMetadataList().getMetadata().get(row);  \n                          \n                        currentMultiples.getMetadataList().getMetadata().set(row,vme);\n                        \n                        java.util.Iterator<LWComponent> multiples = currentMultiples.getAllDescendents().iterator();\n                        while(multiples.hasNext())\n                        {\n                          LWComponent multiple = multiples.next();\n                          java.util.List<VueMetadataElement> md = multiple.getMetadataList().getMetadata();\n                          if(md.contains(oldVME))\n                          {\n                              md.set(md.indexOf(oldVME),vme);\n                          }\n                          else\n                          {\n                              md.add(vme);\n                          }\n                        }\n                        \n                      }\n                      else\n                      {\n                        currentMultiples.getMetadataList().getMetadata().add(vme); \n                        \n                        java.util.Iterator<LWComponent> multiples = currentMultiples.getAllDescendents().iterator();\n                        while(multiples.hasNext())\n                        {\n                          LWComponent multiple = multiples.next();\n                          java.util.List<VueMetadataElement> md = multiple.getMetadataList().getMetadata();\n                          if(md.contains(vme))\n                          {\n                              md.set(md.indexOf(vme),vme);\n                          }\n                          else\n                          {\n                              md.add(vme);\n                          }\n                        }\n                      }  \n                    }\n                    else if(current !=null)\n                    {    \n                      if(current.getMetadataList().getMetadata().size() > (row))\n                      {\n                        current.getMetadataList().getMetadata().set(row,vme);\n                      }\n                      else\n                      {\n                        current.getMetadataList().getMetadata().add(vme); \n                      }\n                    }\n                  }\n              }\n           });\n           \n           field.addKeyListener(new java.awt.event.KeyAdapter(){\n              public void keyPressed(java.awt.event.KeyEvent e)\n              {\n                  if(e.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER)\n                  {\n                      ((MetadataTableModel)metadataTable.getModel()).setSaved(row,true);\n                  }\n              }\n           });\n           \n           field.addFocusListener(new FocusAdapter(){\n              public void focusLost(java.awt.event.FocusEvent fe)\n              {  \n                  if( ( current == null && currentMultiples == null) )\n                          //|| VUE.getActiveMap() == null || VUE.getActiveViewer() == null)\n                  {\n                      return;\n                  }\n                  \n                    if(DEBUG_LOCAL)\n                    {\n                      Object editor = metadataTable.getCellEditor();\n                      \n                      MetadataTableEditor mte = null;\n                      \n                      System.out.println(\"MetadataEditor -- field focus lost -- CellEditor: \" + \n                                           editor);\n                      \n                      if(editor != null)\n                      {\n                          mte = (MetadataTableEditor)editor;\n                          System.out.println(\"MetadataEditor -- field focus lost -- CellEditor row: \" + \n                                           mte.getRow());\n                      }\n                      \n                      \n                    }\n                  \n                  \n                   MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n                   if(model.lastSavedRow != row)\n                   {    \n                     model.setSaved(row,true);\n                   }\n                  \n                  VUE.getActiveMap().markAsModified();\n                  \n                  if(DEBUG_LOCAL && fe != null)\n                  {    \n                     System.out.println(\"MDE field focus lost -- opposite component: \" + fe.getOppositeComponent());\n                  }\n                  \n                  /*if(currentMultiples != null)\n                  {\n                      return;\n                  }*/\n                                    \n                  /*if(fe!= null && fe.getOppositeComponent() == categories)\n                  {\n                      return;\n                  }*/\n                  \n                  // note: fix for currentMultiples != null and focus lost off bottom of info window (not\n                  // as likely in the multiple selection case?)\n                  if(fe.getOppositeComponent() instanceof tufts.vue.gui.DockWindow && currentMultiples == null)\n                  {\n                      model.setSaved(row,true);\n                      TableCellEditor tce = metadataTable.getCellEditor();\n                      \n                      if(tce != null)\n                      {    \n                        metadataTable.getCellEditor().stopCellEditing();\n                      }\n                  }\n                  \n                  java.util.List<VueMetadataElement> metadata = null;\n                  \n                  if(previousCurrent == null && current == null &&\n                       previousMultiples == null && currentMultiples ==  null)\n                  {\n                      return;\n                  }\n                  else\n                  if(previousCurrent != null && !focusToggle)\n                  {\n                     metadata = previousCurrent.getMetadataList().getMetadata();\n                  } \n                  else if(previousCurrent != null && !focusToggle)\n                  {\n                     metadata = previousCurrent.getMetadataList().getMetadata();\n                  }   \n                  else \n                  {\n                     if( currentMultiples!=null )\n                     {    \n                       metadata = currentMultiples.getMetadataList().getMetadata();\n                     }\n                     else if( current!=null )\n                     {\n                       //going in this order should mean current == null is not\n                       // needed on selection of more than one component..\n                         \n                       metadata = current.getMetadataList().getMetadata();   \n                     }\n                  }\n                  \n                  VueMetadataElement currentVME = null;\n                  \n                  if( (current != null && current.getMetadataList().getCategoryListSize() > 0 ) ||\n                          \n                      (currentMultiples != null && currentMultiples.getMetadataList().getCategoryListSize() > 0 )      \n                    )\n                  {\n                   currentVME = metadata.get(row);\n                  }\n                  \n                  VueMetadataElement vme = new VueMetadataElement();\n                  \n                  if(currentVME==null)\n                  {\n                     String[] emptyEntry = {NONE_ONT,field.getText()};\n                     vme.setObject(emptyEntry);\n                     vme.setType(VueMetadataElement.CATEGORY);  \n                  }\n                  else\n                  {\n                    String[] obj = (String[])currentVME.getObject();  \n                    String[] pairedValue = {obj[0],field.getText()};\n                    vme.setObject(pairedValue);\n                  }\n                  if( (current != null && current.getMetadataList().getCategoryListSize() > (row)) ||\n                     (currentMultiples != null && currentMultiples.getMetadataList().getCategoryListSize() > row) )\n                  {\n                    if(DEBUG_LOCAL)\n                    {\n                        System.out.println(\"ME: setting value from field -- \" + row + \":\" + vme.getObject() +\n                                            \" \" + metadata);\n                    }\n                    \n                    VueMetadataElement old = metadata.get(row);\n                    \n                    metadata.set(row,vme);\n                    \n                    if(currentMultiples != null) // !! must make sure there is more than one in group -- other\n                                                 // wise is back to base case of single selection.\n                    {\n                        java.util.Collection selection = currentMultiples.getAllDescendents();\n                        java.util.Iterator children = selection.iterator();\n                        while(children.hasNext())\n                        {\n                            LWComponent child = (LWComponent)children.next();\n                            java.util.List<VueMetadataElement> cMeta = child.getMetadataList().getMetadata();\n                            int size = cMeta.size();\n                            if(size > 0 && cMeta.get(size-1).getValue().equals(\"\"))\n                            {\n                                cMeta.set(size-1,vme);\n                            }\n                            // also need to set in condition where already in all the sub components?\n                            // somehow need to detect edit here.. but condition in line above this\n                            // one is not neccesarily equivalent..\n                            else\n                              if(cMeta.contains(old))\n                              {\n                                // should it always be the first index?\n                                cMeta.set(cMeta.indexOf(old),vme);\n                              }\n                              else\n                                cMeta.add(vme);\n                            child.layout();\n                            // also might need VUE activelistener repaint\n                        }\n                    }\n                    \n                  }\n                  else\n                  {\n                    metadata.add(vme); \n                  }\n                  \n                  // done earlier for multiples.  // may also  need active viewer repaint\n                  if(current !=null)\n                     current.layout();\n                  \n                  \n                  VUE.getActiveViewer().repaint();\n                  \n                  metadataTable.repaint();\n              }\n              \n              public void focusGained(java.awt.event.FocusEvent fe)\n              {\n                  focusToggle = true;\n              }\n           });\n           comp.setLayout(new BorderLayout());\n           if(col == buttonColumn - 2)\n           {\n               final int n = categories.getModel().getSize();\n \n               Object currObject = null;\n               \n               if(currentMultiples != null)\n               {\n                 currObject = currentMultiples.getMetadataList().getMetadata().get(row).getObject();  \n               }\n               else if(current != null)\n               {    \n                 currObject = current.getMetadataList().getMetadata().get(row).getObject();\n               }\n               final Object currValue = (((String[])currObject)[0]);\n               Object currFieldValue = (((String[])currObject)[1]);\n               \n               /*if(false) /// with new isCellEditable() logic on cell editor...\n               {\n                   String displayString = currValue.toString();\n                   int nameIndex = displayString.indexOf(\"#\");\n                   if(nameIndex != -1 && ( (nameIndex + 1)< displayString.length()) ) \n                   {\n                     displayString = displayString.substring(nameIndex + 1);\n                   }\n                   categoryLabel.setText(displayString);\n                   \n                   categoryLabel.setFont(GUI.LabelFace);\n                   \n                   boolean found = findCategory(currValue,row,col,n,categories);\n                   \n                   if(found)\n                   {    \n                     comp.add(categoryLabel);\n                   }\n                   else\n                   {\n                     categoryLabel.setText(categoryLabel.getText() + \"*\"); \n                     comp.add(categoryLabel);\n                   }    \n                   comp.setBorder(getMetadataCellBorder(row,col));\n                   \n                   ((MetadataTableModel)table.getModel()).refresh();\n                   metadataTable.repaint();\n                   \n                   return comp;\n               }*/\n               findCategory(currValue,row,col,n,categories); \n               \n\n               comp.add(categories);\n               \n               comp.setBorder(getMetadataCellBorder(row,col));\n               ((MetadataTableModel)table.getModel()).refresh();\n               metadataTable.repaint();\n           }\n           else\n           if(col == (buttonColumn - 1))\n           {\n               if(value instanceof String)\n                 field.setText(value.toString());\n               if(value instanceof VueMetadataElement)\n               {\n                 VueMetadataElement vme = (VueMetadataElement)value;\n                 field.setText(vme.getValue());\n               }\n               if(true) // new isCellEditable stuff\n               {\n                 comp.add(field);\n               }\n               else\n               {\n                 notEditable.setText(field.getText());\n                 comp.add(notEditable);\n               }\n           }\n           else if(col ==  buttonColumn)               \n           {\n               //JLabel buttonLabel = new JLabel();\n               //buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               //comp.add(buttonLabel);\n               \n               //$\n                 //JPanel tempPanel = new JPanel();\n                 //tempPanel.setOpaque(true);\n                 //tempPanel.setBackground(java.awt.Color.BLUE);\n                 //tempPanel.add(deleteButton);\n                 //tempPanel.addActionListener(deleteButton);\n                 \n                 \n               //$\n               \n               metaButtonPanel.setRow(row);\n               //deleteButton.setRow(row);\n               //comp.add(deleteButton);\n               //comp = metaButtonPanel;\n               comp.add(metaButtonPanel);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(getMetadataCellBorder(row,col));\n           \n           if(LIMITED_FOCUS)\n           {\n             field.addMouseListener(new MouseAdapter() {\n                 public void mouseExited(MouseEvent me)\n                 {\n                       stopCellEditing();\n                 }\n             });\n           }\n           \n           comp.setBorder(getMetadataCellBorder(row,col));\n           return comp;\n       }","id":24878,"modified_method":"public java.awt.Component getTableCellEditorComponent(final JTable table,final Object value,boolean isSelected,final int row,final int col)\n       {\n           final JTextField field = new JTextField();\n           final JComboBox categories = new JComboBox();\n           categories.setFont(GUI.LabelFace);\n           categories.setModel(new CategoryComboBoxModel());\n           categories.setRenderer(new CategoryComboBoxRenderer());\n           final JLabel categoryLabel = new JLabel();\n           final JLabel notEditable = new JLabel();\n           final JPanel comp = new JPanel();\n           \n           //edu.tufts.vue.metadata.gui.MetaButton deleteButton = new \n           //                       edu.tufts.vue.metadata.gui.MetaButton(MetadataEditor.this,\"delete\");\n           \n           comp.addMouseListener(new MouseAdapter(){\n              public void mousePressed(MouseEvent e)\n              {\n                  ((MetadataTableModel)metadataTable.getModel()).setSaved(row,true);\n                  stopCellEditing();\n              }\n           });\n           \n           currentRow = row;\n           \n           notEditable.setFont(GUI.LabelFace);\n           field.setFont(GUI.LabelFace);\n           \n           categories.addItemListener(new ItemListener() \n           {\n               public void itemStateChanged(ItemEvent e) \n               {\n                   if(DEBUG_LOCAL)\n                   {    \n                      System.out.println(\"MetdataEditor categories item listener itemStateChanged: \" + e);\n                   }\n                   \n                   \n                   if(e.getStateChange() == ItemEvent.SELECTED)\n                   {   \n                       if(e.getItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem)\n                       {                           \n                           JDialog ecd = new JDialog(VUE.getApplicationFrame(),\"Edit Categories\");\n                           ecd.setModal(true);\n                           ecd.add(new CategoryEditor(ecd,categories,MetadataEditor.this,current,row,col));\n                           ecd.setBounds(475,300,300,250);\n                           ecd.setVisible(true);\n                           \n                           metadataTable.getCellEditor().stopCellEditing();\n                           ((MetadataTableModel)metadataTable.getModel()).refresh();\n                       }\n                   }\n               }\n           });\n           \n           categories.addFocusListener(new FocusAdapter(){\n               public void focusLost(java.awt.event.FocusEvent fe)\n               {      \n                   MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n                   if(model.lastSavedRow != row)\n                   {    \n                     model.setSaved(row,true);\n                   }\n               }\n           });\n           \n           categories.addItemListener(new java.awt.event.ItemListener(){\n              public void itemStateChanged(java.awt.event.ItemEvent ie)\n              {\n                  \n                  if(ie.getStateChange()==java.awt.event.ItemEvent.SELECTED)\n                  {\n                      \n                    if(categories.getSelectedItem() instanceof edu.tufts.vue.metadata.gui.EditCategoryItem)\n                    {\n                        return;\n                    }\n                      \n                    VueMetadataElement vme = new VueMetadataElement();\n                    \n                    String[] keyValuePair = {((OntType)categories.getSelectedItem()).getBase()+\"#\"+((OntType)categories.getSelectedItem()).getLabel(),\n                                               ((VueMetadataElement)table.getModel().getValueAt(row,buttonColumn - 1)).getValue()};\n                    \n                    vme.setObject(keyValuePair);\n                    vme.setType(VueMetadataElement.CATEGORY);\n                    if(currentMultiples != null)\n                    {\n                      // also need to add/set for individuals in group.. todo: subclass LWGroup to do this?\n                      // in the meantime just set these by hand\n                      if(currentMultiples.getMetadataList().getCategoryListSize() > (row))\n                      {\n                        VueMetadataElement oldVME = currentMultiples.getMetadataList().getCategoryList().get(row);  \n                          \n                        currentMultiples.getMetadataList().getCategoryList().set(row,vme);\n                        \n                        java.util.Iterator<LWComponent> multiples = currentMultiples.getAllDescendents().iterator();\n                        while(multiples.hasNext())\n                        {\n                          LWComponent multiple = multiples.next();\n                          MetadataList.SubsetList md = multiple.getMetadataList().getCategoryList();\n                          if(md.contains(oldVME))\n                          {\n                              md.set(md.indexOf(oldVME),vme);\n                          }\n                          else\n                          {\n                              multiple.getMetadataList().getMetadata().add(vme);\n                          }\n                        }\n                        \n                      }\n                      else\n                      {\n                        currentMultiples.getMetadataList().getMetadata().add(vme); \n                        \n                        java.util.Iterator<LWComponent> multiples = currentMultiples.getAllDescendents().iterator();\n                        while(multiples.hasNext())\n                        {\n                          LWComponent multiple = multiples.next();\n                          MetadataList.SubsetList md = multiple.getMetadataList().getCategoryList();\n                          if(md.contains(vme))\n                          {\n                              md.set(md.indexOf(vme),vme);\n                          }\n                          else\n                          {\n                              multiple.getMetadataList().getMetadata().add(vme);\n                          }\n                        }\n                      }  \n                    }\n                    else if(current !=null)\n                    {    \n                      if(current.getMetadataList().getCategoryListSize() > (row))\n                      {\n                        current.getMetadataList().getCategoryList().set(row,vme);\n                      }\n                      else\n                      {\n                        current.getMetadataList().getMetadata().add(vme); \n                      }\n                    }\n                  }\n              }\n           });\n           \n           field.addKeyListener(new java.awt.event.KeyAdapter(){\n              public void keyPressed(java.awt.event.KeyEvent e)\n              {\n                  if(e.getKeyCode() == java.awt.event.KeyEvent.VK_ENTER)\n                  {\n                      ((MetadataTableModel)metadataTable.getModel()).setSaved(row,true);\n                  }\n              }\n           });\n           \n           field.addFocusListener(new FocusAdapter(){\n              public void focusLost(java.awt.event.FocusEvent fe)\n              {  \n                  if( ( current == null && currentMultiples == null) )\n                          //|| VUE.getActiveMap() == null || VUE.getActiveViewer() == null)\n                  {\n                      return;\n                  }\n                  \n                    if(DEBUG_LOCAL)\n                    {\n                      Object editor = metadataTable.getCellEditor();\n                      \n                      MetadataTableEditor mte = null;\n                      \n                      System.out.println(\"MetadataEditor -- field focus lost -- CellEditor: \" + \n                                           editor);\n                      \n                      if(editor != null)\n                      {\n                          mte = (MetadataTableEditor)editor;\n                          System.out.println(\"MetadataEditor -- field focus lost -- CellEditor row: \" + \n                                           mte.getRow());\n                      }\n                      \n                      \n                    }\n                  \n                  \n                   MetadataTableModel model = (MetadataTableModel)metadataTable.getModel();\n                   if(model.lastSavedRow != row)\n                   {    \n                     model.setSaved(row,true);\n                   }\n                  \n                  VUE.getActiveMap().markAsModified();\n                  \n                  if(DEBUG_LOCAL && fe != null)\n                  {    \n                     System.out.println(\"MDE field focus lost -- opposite component: \" + fe.getOppositeComponent());\n                  }\n                  \n                  /*if(currentMultiples != null)\n                  {\n                      return;\n                  }*/\n                                    \n                  /*if(fe!= null && fe.getOppositeComponent() == categories)\n                  {\n                      return;\n                  }*/\n                  \n                  // note: fix for currentMultiples != null and focus lost off bottom of info window (not\n                  // as likely in the multiple selection case?)\n                  if(fe.getOppositeComponent() instanceof tufts.vue.gui.DockWindow && currentMultiples == null)\n                  {\n                      model.setSaved(row,true);\n                      TableCellEditor tce = metadataTable.getCellEditor();\n                      \n                      if(tce != null)\n                      {    \n                        metadataTable.getCellEditor().stopCellEditing();\n                      }\n                  }\n                  \n                  //java.util.List<VueMetadataElement> metadata = null;\n                  MetadataList.SubsetList metadata = null;\n                  \n                  if(previousCurrent == null && current == null &&\n                       previousMultiples == null && currentMultiples ==  null)\n                  {\n                      return;\n                  }\n                  else\n                  if(previousCurrent != null && !focusToggle)\n                  {\n                     metadata = previousCurrent.getMetadataList().getCategoryList();\n                  } \n                  else if(previousCurrent != null && !focusToggle)\n                  {\n                     metadata = previousCurrent.getMetadataList().getCategoryList();\n                  }   \n                  else \n                  {\n                     if( currentMultiples!=null )\n                     {    \n                       metadata = currentMultiples.getMetadataList().getCategoryList();\n                     }\n                     else if( current!=null )\n                     {\n                       //going in this order should mean current == null is not\n                       // needed on selection of more than one component..\n                         \n                       metadata = current.getMetadataList().getCategoryList();   \n                     }\n                  }\n                  \n                  VueMetadataElement currentVME = null;\n                  \n                  if( (current != null && current.getMetadataList().getCategoryListSize() > 0 ) ||\n                          \n                      (currentMultiples != null && currentMultiples.getMetadataList().getCategoryListSize() > 0 )      \n                    )\n                  {\n                   currentVME = metadata.get(row);\n                  }\n                  \n                  VueMetadataElement vme = new VueMetadataElement();\n                  \n                  if(currentVME==null)\n                  {\n                     String[] emptyEntry = {NONE_ONT,field.getText()};\n                     vme.setObject(emptyEntry);\n                     vme.setType(VueMetadataElement.CATEGORY);  \n                  }\n                  else\n                  {\n                    String[] obj = (String[])currentVME.getObject();  \n                    String[] pairedValue = {obj[0],field.getText()};\n                    vme.setObject(pairedValue);\n                  }\n                  if( (current != null && current.getMetadataList().getCategoryListSize() > (row)) ||\n                     (currentMultiples != null && currentMultiples.getMetadataList().getCategoryListSize() > row) )\n                  {\n                    if(DEBUG_LOCAL)\n                    {\n                        System.out.println(\"ME: setting value from field -- \" + row + \":\" + vme.getObject() +\n                                            \" \" + metadata);\n                    }\n                    \n                    VueMetadataElement old = metadata.get(row);\n                    \n                    metadata.set(row,vme);\n                    \n                    if(currentMultiples != null) // !! must make sure there is more than one in group -- other\n                                                 // wise is back to base case of single selection.\n                    {\n                        java.util.Collection selection = currentMultiples.getAllDescendents();\n                        java.util.Iterator children = selection.iterator();\n                        while(children.hasNext())\n                        {\n                            LWComponent child = (LWComponent)children.next();\n                            MetadataList.SubsetList cMeta = child.getMetadataList().getCategoryList();\n                            int size = cMeta.size();\n                            if(size > 0 && cMeta.get(size-1).getValue().equals(\"\"))\n                            {\n                                cMeta.set(size-1,vme);\n                            }\n                            // also need to set in condition where already in all the sub components?\n                            // somehow need to detect edit here.. but condition in line above this\n                            // one is not neccesarily equivalent..\n                            else\n                              if(cMeta.contains(old))\n                              {\n                                // should it always be the first index?\n                                cMeta.set(cMeta.indexOf(old),vme);\n                              }\n                              else\n                                child.getMetadataList().getMetadata().add(vme);\n                            child.layout();\n                            // also might need VUE activelistener repaint\n                        }\n                    }\n                    \n                  }\n                  else\n                  {\n                    metadata.add(vme); \n                  }\n                  \n                  // done earlier for multiples.  // may also  need active viewer repaint\n                  if(current !=null)\n                     current.layout();\n                  \n                  \n                  VUE.getActiveViewer().repaint();\n                  \n                  metadataTable.repaint();\n              }\n              \n              public void focusGained(java.awt.event.FocusEvent fe)\n              {\n                  focusToggle = true;\n              }\n           });\n           comp.setLayout(new BorderLayout());\n           if(col == buttonColumn - 2)\n           {\n               final int n = categories.getModel().getSize();\n \n               Object currObject = null;\n               \n               if(currentMultiples != null)\n               {\n                 currObject = currentMultiples.getMetadataList().getCategoryListElement(row).getObject();  \n               }\n               else if(current != null)\n               {    \n                 currObject = current.getMetadataList().getCategoryListElement(row).getObject();\n               }\n               final Object currValue = (((String[])currObject)[0]);\n               Object currFieldValue = (((String[])currObject)[1]);\n               \n               /*if(false) /// with new isCellEditable() logic on cell editor...\n               {\n                   String displayString = currValue.toString();\n                   int nameIndex = displayString.indexOf(\"#\");\n                   if(nameIndex != -1 && ( (nameIndex + 1)< displayString.length()) ) \n                   {\n                     displayString = displayString.substring(nameIndex + 1);\n                   }\n                   categoryLabel.setText(displayString);\n                   \n                   categoryLabel.setFont(GUI.LabelFace);\n                   \n                   boolean found = findCategory(currValue,row,col,n,categories);\n                   \n                   if(found)\n                   {    \n                     comp.add(categoryLabel);\n                   }\n                   else\n                   {\n                     categoryLabel.setText(categoryLabel.getText() + \"*\"); \n                     comp.add(categoryLabel);\n                   }    \n                   comp.setBorder(getMetadataCellBorder(row,col));\n                   \n                   ((MetadataTableModel)table.getModel()).refresh();\n                   metadataTable.repaint();\n                   \n                   return comp;\n               }*/\n               findCategory(currValue,row,col,n,categories); \n               \n\n               comp.add(categories);\n               \n               comp.setBorder(getMetadataCellBorder(row,col));\n               ((MetadataTableModel)table.getModel()).refresh();\n               metadataTable.repaint();\n           }\n           else\n           if(col == (buttonColumn - 1))\n           {\n               if(value instanceof String)\n                 field.setText(value.toString());\n               if(value instanceof VueMetadataElement)\n               {\n                 VueMetadataElement vme = (VueMetadataElement)value;\n                 field.setText(vme.getValue());\n               }\n               if(true) // new isCellEditable stuff\n               {\n                 comp.add(field);\n               }\n               else\n               {\n                 notEditable.setText(field.getText());\n                 comp.add(notEditable);\n               }\n           }\n           else if(col ==  buttonColumn)               \n           {\n               //JLabel buttonLabel = new JLabel();\n               //buttonLabel.setIcon(tufts.vue.VueResources.getImageIcon(\"metadata.editor.delete.up\"));\n               //comp.add(buttonLabel);\n               \n               //$\n                 //JPanel tempPanel = new JPanel();\n                 //tempPanel.setOpaque(true);\n                 //tempPanel.setBackground(java.awt.Color.BLUE);\n                 //tempPanel.add(deleteButton);\n                 //tempPanel.addActionListener(deleteButton);\n                 \n                 \n               //$\n               \n               metaButtonPanel.setRow(row);\n               //deleteButton.setRow(row);\n               //comp.add(deleteButton);\n               //comp = metaButtonPanel;\n               comp.add(metaButtonPanel);\n           }\n           \n           comp.setOpaque(false);\n           comp.setBorder(getMetadataCellBorder(row,col));\n           \n           if(LIMITED_FOCUS)\n           {\n             field.addMouseListener(new MouseAdapter() {\n                 public void mouseExited(MouseEvent me)\n                 {\n                       stopCellEditing();\n                 }\n             });\n           }\n           \n           comp.setBorder(getMetadataCellBorder(row,col));\n           return comp;\n       }","commit_id":"f9c446de80a916f4bfd07b7ffb29b4bd1a1d3352","url":"https://github.com/VUE/VUE"},{"original_method":"public void activeChanged(ActiveEvent e)\n    {\n       if(e!=null)\n       {\n         focusToggle = false;  \n           \n         //if(DEBUG_LOCAL)\n         //{\n         //    System.out.println(\"MetadataEditor: active changed - \" + e + \",\" + this);\n         //}\n           \n         LWComponent active = (LWComponent)e.active;\n         \n         metadataTable.removeEditor();\n         \n         previousCurrent = current;\n         \n         current = active;\n         \n         \n         if(current!=null && MetadataEditor.this.current.getMetadataList().getMetadata().size() == 0)\n         {\n           VueMetadataElement vme = new VueMetadataElement();\n           String[] emptyEntry = {NONE_ONT,\"\"};\n           vme.setObject(emptyEntry);\n           vme.setType(VueMetadataElement.CATEGORY);\n\n           MetadataEditor.this.current.getMetadataList().getMetadata().add(vme);\n         }\n        \n\n         \n         // clear focus and saved information\n         ((MetadataTableModel)metadataTable.getModel()).clearGUIInfo();\n         \n         ((MetadataTableModel)metadataTable.getModel()).refresh();\n         //((OntologyTypeListModel)ontologyTypeList.getModel()).refresh();\n        \n         \n         //adjustColumnModel();\n       }\n    }","id":24879,"modified_method":"public void activeChanged(ActiveEvent e)\n    {\n       if(e!=null)\n       {\n         focusToggle = false;  \n           \n         //if(DEBUG_LOCAL)\n         //{\n         //    System.out.println(\"MetadataEditor: active changed - \" + e + \",\" + this);\n         //}\n           \n         LWComponent active = (LWComponent)e.active;\n         \n         metadataTable.removeEditor();\n         \n         previousCurrent = current;\n         \n         current = active;\n         \n         \n         if(current!=null && MetadataEditor.this.current.getMetadataList().getCategoryListSize() == 0)\n         {\n           VueMetadataElement vme = new VueMetadataElement();\n           String[] emptyEntry = {NONE_ONT,\"\"};\n           vme.setObject(emptyEntry);\n           vme.setType(VueMetadataElement.CATEGORY);\n\n           MetadataEditor.this.current.getMetadataList().getMetadata().add(vme);\n         }\n        \n\n         \n         // clear focus and saved information\n         ((MetadataTableModel)metadataTable.getModel()).clearGUIInfo();\n         \n         ((MetadataTableModel)metadataTable.getModel()).refresh();\n         //((OntologyTypeListModel)ontologyTypeList.getModel()).refresh();\n        \n         \n         //adjustColumnModel();\n       }\n    }","commit_id":"f9c446de80a916f4bfd07b7ffb29b4bd1a1d3352","url":"https://github.com/VUE/VUE"},{"original_method":"/******\n\t * Installs an service.\n\t * \n\t * @param appName\n\t *            the application name.\n\t * @param serviceName\n\t *            the service name.\n\t * @param request\n\t *            the install-service request.\n\t * @return {@link InstallServiceResponse} contains the lifecycleEventContainerID.\n\t * @throws RestErrorException .\n\t */\n\t@RequestMapping(value = \"/{appName}/services/{serviceName}\", method = RequestMethod.POST)\n\tpublic InstallServiceResponse installService(\n\t\t\t@PathVariable final String appName,\n\t\t\t@PathVariable final String serviceName,\n\t\t\tfinal InstallServiceRequest request) throws RestErrorException {\n\n\t\tfinal String absolutePuName = ServiceUtils.getAbsolutePUName(appName, serviceName);\n\n\t\tfinal File srcFile = repo.get(request.getUploadKey());\n\t\tFile serviceDir = null;\n\t\ttry {\n\t\t\t// unzip srcFile into a new directory named absolutePuName under baseDir.\n\t\t\tserviceDir = ServiceReader.extractProjectFileToDir(srcFile, absolutePuName, repo.getBaseDir());\n\t\t} catch (final IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\tFile editSrcFile = srcFile;\n\t\t\n\t\tmergeOverridesWithProperties(request, serviceDir);\n\t\n\t\ttry {\n\t\t\teditSrcFile = Packager.createZipFile(\"temp\", serviceDir);\n\t\t} catch (IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\t\n\t\t// Use service reader to read the service\n\t\tService service = null;\n\t\ttry {\n\t\t\tservice = ServiceReader.readService(editSrcFile);\n\t\t} catch (final DSLException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t} catch (final PackagingException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\t// update template name\n\t\tString templateName = getTempalteNameFromService(service);\n\n\t\t// TODO update/create props file\n\t\t\n\t\t// validate\n\t\tvalidateInstallService(absolutePuName, request, service, templateName);\n\n\t\t// TODO call doDeploy\n\t\t\n\t\tInstallServiceResponse installServiceResponse = new InstallServiceResponse();\n\t\tString lifecycleEventContainerID = \"\";\n\t\t// TODO update lifecycleEventContainerID\n\t\tinstallServiceResponse.setLifecycleEventContainerID(lifecycleEventContainerID);\n\t\treturn installServiceResponse;\n\n\t}","id":24880,"modified_method":"/******\n\t * Installs an service.\n\t * \n\t * @param appName\n\t *            the application name.\n\t * @param serviceName\n\t *            the service name.\n\t * @param request\n\t *            the install-service request.\n\t * @return {@link InstallServiceResponse} contains the lifecycleEventContainerID.\n\t * @throws RestErrorException .\n\t */\n\t@RequestMapping(value = \"/{appName}/services/{serviceName}\", method = RequestMethod.POST)\n\tpublic InstallServiceResponse installService(\n\t\t\t@PathVariable final String appName,\n\t\t\t@PathVariable final String serviceName,\n\t\t\tfinal InstallServiceRequest request) throws RestErrorException {\n\n\t\tfinal String absolutePuName = ServiceUtils.getAbsolutePUName(appName, serviceName);\n\n\t\tfinal File srcFile = repo.get(request.getUploadKey());\n\t\tFile serviceDir = null;\n\t\ttry {\n\t\t\t// unzip srcFile into a new directory named absolutePuName under baseDir.\n\t\t\tserviceDir = ServiceReader.extractProjectFileToDir(srcFile, absolutePuName, repo.getBaseDir());\n\t\t} catch (final IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\tFile editSrcFile = srcFile;\n\t\t\n\t\ttry {\n\t\t\tmergeOverridesWithProperties(request, serviceDir);\n\t\t} catch (IOException e2) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\n\t\ttry {\n\t\t\teditSrcFile = Packager.createZipFile(\"temp\", serviceDir);\n\t\t} catch (IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\t\n\t\t// Use service reader to read the service\n\t\tService service = null;\n\t\ttry {\n\t\t\tservice = ServiceReader.readService(editSrcFile);\n\t\t} catch (final DSLException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t} catch (final PackagingException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\t// update template name\n\t\tString templateName = getTempalteNameFromService(service);\n\n\t\t// validate\n\t\tvalidateInstallService(absolutePuName, request, service, templateName);\n\t\t\n\t\t// TODO update/create props file\n\t\t\n\t\t// TODO use repo to get cloudOverrides\n\t\t\n\t\t// update effective authGroups\n\t\tString effectiveAuthGroups = request.getAuthGroups();\n\t\tif (StringUtils.isBlank(effectiveAuthGroups)) {\n\t\t\tif (permissionEvaluator != null) {\n\t\t\t\teffectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();\n\t\t\t} else {\n\t\t\t\teffectiveAuthGroups = \"\";\n\t\t\t}\n\t\t}\n\n\t\t// TODO call doDeploy\n\t\t\n\t\tInstallServiceResponse installServiceResponse = new InstallServiceResponse();\n\t\tString lifecycleEventContainerID = \"\";\n\t\t// TODO update lifecycleEventContainerID\n\t\tinstallServiceResponse.setLifecycleEventContainerID(lifecycleEventContainerID);\n\t\treturn installServiceResponse;\n\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void mergeOverridesWithProperties(final InstallServiceRequest request, final File serviceDir) \n\t\t\tthrows RestErrorException {\n\t\tString serviceOverrides = request.getServiceOverrides();\n\t\t// check if merge is necessary\n\t\tif (StringUtils.notEmpty(serviceOverrides)) {\n\t\t\t// get properties file from working directory\n\t\t\tfinal File workingProjectDir = new File(serviceDir, \"ext\");\n\t\t\tfinal String propertiesFileName = \n\t\t\t\t\tDSLUtils.getPropertiesFileName(workingProjectDir, DSLUtils.SERVICE_DSL_FILE_NAME_SUFFIX);\n\t\t\tfinal File servicePropertiesFile = new File(workingProjectDir, propertiesFileName);\n\t\t\t// load properties\n\t\t\tProperties serviceProperties = new Properties();\n\t\t\tFileInputStream inStream;\n\t\t\ttry {\n\t\t\t\t// create new properties file if needed\n\t\t\t\tif (!servicePropertiesFile.exists()) {\n\t\t\t\t\tservicePropertiesFile.createNewFile();\n\t\t\t\t}\n\t\t\t\tinStream = new FileInputStream(servicePropertiesFile);\n\t\t\t\tserviceProperties.load(inStream);\n\t\t\t\t// add/update properties from overrides\n\t\t\t\tString[] serviceOverridesProeprties = serviceOverrides.split(\",\");\n\t\t\t\tfor (String keyValuePairStr : serviceOverridesProeprties) {\n\t\t\t\t\tString[] keyValuePair = keyValuePairStr.split(\"=\");\n\t\t\t\t\tserviceProperties.setProperty(keyValuePair[0].trim(), keyValuePair[1].trim());\n\t\t\t\t}\n\t\t\t\t// store\n\t\t\t\tserviceProperties.store(new FileOutputStream(servicePropertiesFile), null);\n\t\t\t} catch (FileNotFoundException e2) {\n\t\t\t\t// TODO Add error massage. \n\t\t\t\tthrow new RestErrorException(\"\");\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Add error massage. \n\t\t\t\tthrow new RestErrorException(\"\");\n\t\t\t}\n\t\t}\n\t}","id":24881,"modified_method":"private void mergeOverridesWithProperties(final InstallServiceRequest request, final File serviceDir) \n\t\t\tthrows RestErrorException, IOException {\n\t\tString serviceOverrides = request.getServiceOverrides();\n\t\tFile applicationProeprtiesFile = request.getApplicationPropertiesFile();\n\t\t// check if merge is necessary\n\t\tif (!StringUtils.isBlank(serviceOverrides) || applicationProeprtiesFile != null) {\n\t\t\t// get properties file from working directory\n\t\t\tfinal File workingProjectDir = new File(serviceDir, \"ext\");\n\t\t\tfinal String propertiesFileName = \n\t\t\t\t\tDSLUtils.getPropertiesFileName(workingProjectDir, DSLUtils.SERVICE_DSL_FILE_NAME_SUFFIX);\n\t\t\tfinal File servicePropertiesFile = new File(workingProjectDir, propertiesFileName);\n\t\t\tfinal File finalPropertiesFile = File.createTempFile(\"finalPropertiesFile\", \".properties\");\n\t\t\ttry {\n\t\t\t\tFileAppender appender = new FileAppender(finalPropertiesFile);\n\t\t\t\tif (applicationProeprtiesFile != null && applicationProeprtiesFile.exists()) {\n\t\t\t\t\tappender.append(\"application proeprties file\", applicationProeprtiesFile);\n\t\t\t\t}\n\t\t\t\tif (servicePropertiesFile.exists()) {\n\t\t\t\t\tappender.append(\"service proeprties file\", servicePropertiesFile);\n\t\t\t\t}\n\t\t\t\tif (!StringUtils.isBlank(serviceOverrides)) {\n\t\t\t\t\tserviceOverrides = serviceOverrides.replaceAll(\",\", FileAppender.LINE_SEPARATOR);\n\t\t\t\t\tappender.append(\"service overrides file\", serviceOverrides);\n\t\t\t\t}\n\t\t\t\tappender.flush();\n\t\t\t\tFileUtils.copyFile(finalPropertiesFile, servicePropertiesFile);\n\t\t\t} finally {\n\t\t\t\tfinalPropertiesFile.delete();\n\t\t\t}\n\t\t}\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * @param comment - this comment will be appended to the beginning of the file to merge.\n\t * @param fileToMerge - the file to merge with\n\t * @return .\n\t * @throws IOException \n\t */\n\tpublic FileAppender append(final String comment, final File fileToMerge) throws IOException {\n\t\twriter.append(\"//\").append(comment).append(\" Generated By \").append(FileAppender.class.getName())\n            .append(\" On : \").append(new Date(System.currentTimeMillis()).toString())\n\t\t    .append(LINE_SEPARATOR)\n\t\t    .append(LINE_SEPARATOR)\n\t\t    .append(FileUtils.readFileToString(fileToMerge))\n\t\t    .append(LINE_SEPARATOR)\n\t\t    .append(LINE_SEPARATOR);\n\t\treturn this;\n\t}","id":24882,"modified_method":"/**\n\t * @param comment - this comment will be appended to the beginning of the file to merge.\n\t * @param fileToMerge - the file to merge with\n\t * @return .\n\t * @throws IOException \n\t */\n\tpublic FileAppender append(final String comment, final File fileToMerge) throws IOException {\n\t\treturn append(comment, FileUtils.readFileToString(fileToMerge));\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final InstallServiceRequest request, final Cloud cloud, final Service service,\n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause, \n\t\t\tfinal CustomPermissionEvaluator permissionEvaluator, final Object optionalValidatorParam) {\n\t\t\n\t\tfinal InstallServiceValidator validator = getValidatorInstance(optionalValidatorParam);\n\t\tInstallServiceValidationContext validationContext = new InstallServiceValidationContext();\n\t\tvalidationContext.setRequest(request);\n\t\tvalidationContext.setCloud(cloud);\n\t\tvalidationContext.setService(service);\n\t\ttry {\n\t\t\tvalidator.validate(validationContext);\n\t\t\tif (shouldFail) {\n\t\t\t\tAssert.fail(exceptionCause + \" didn't yield the expected RestErrorException.\");\n\t\t\t}\n\t\t} catch (final RestErrorException e) {\n\t\t\tif (!shouldFail) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tAssert.assertEquals(exceptionCause.getName(), e.getMessage());\n\t\t}\n\t}","id":24883,"modified_method":"public void testValidator(final InstallServiceRequest request, final Cloud cloud, final Service service, \n\t\t\tfinal String templateName, final File cloudOverridesFile, \n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\t\n\t\tfinal InstallServiceValidator validator = getValidatorInstance();\n\t\tInstallServiceValidationContext validationContext = new InstallServiceValidationContext();\n\t\tvalidationContext.setRequest(request);\n\t\tvalidationContext.setCloud(cloud);\n\t\tvalidationContext.setService(service);\n\t\tvalidationContext.setCloudConfiguration(cloudOverridesFile);\n\t\tvalidationContext.setTemplateName(templateName);\n\t\ttry {\n\t\t\tvalidator.validate(validationContext);\n\t\t\tif (shouldFail) {\n\t\t\t\tAssert.fail(exceptionCause + \" didn't yield the expected RestErrorException.\");\n\t\t\t}\n\t\t} catch (final RestErrorException e) {\n\t\t\tif (!shouldFail) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tAssert.assertEquals(exceptionCause.getName(), e.getMessage());\n\t\t}\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final Cloud cloud, final Service service, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, true, exceptionCause);\n\t}","id":24884,"modified_method":"public void testValidator(final Cloud cloud, final Service service, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, null, null, true, exceptionCause);\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public abstract InstallServiceValidator getValidatorInstance(Object optionalValidatorParam);","id":24885,"modified_method":"public abstract InstallServiceValidator getValidatorInstance();","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final InstallServiceRequest request, final Cloud cloud, final Service service,\n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(request, cloud, service, shouldFail, exceptionCause, null, null);\n\t}","id":24886,"modified_method":"public void testValidator(final InstallServiceRequest request, final Cloud cloud, final Service service,\n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(request, cloud, service, null, null, shouldFail, exceptionCause);\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final Cloud cloud, final Service service, \n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, shouldFail, exceptionCause);\n\t}","id":24887,"modified_method":"public void testValidator(final Cloud cloud, final Service service, \n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, null, null, shouldFail, exceptionCause);\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final InstallServiceRequest request, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(request, null, null, true, exceptionCause);\n\t}","id":24888,"modified_method":"public void testValidator(final InstallServiceRequest request, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(request, null, null, null, null, true, exceptionCause);\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final InstallServiceRequest request, final CloudifyMessageKeys exceptionCause, \n\t\t\tfinal Object optionalValidatorParam) {\n\t\ttestValidator(request, null, null, true, exceptionCause, null, optionalValidatorParam);\n\t}","id":24889,"modified_method":"public void testValidator(final Cloud cloud, final Service service, final String templateName, \n\t\t\tfinal CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, templateName, null, true, exceptionCause);\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void validate(final InstallServiceValidationContext validationContext) throws RestErrorException {\n\t\tString absolutePuName = validationContext.getAbsolutePuName();\n\t\tInstallServiceRequest request = validationContext.getRequest();\n\t\tif (request == null) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.VALIDATOR_REQUEST_MISSING.getName(), absolutePuName);\n\t\t}\n\t\tString uploadKey = request.getUploadKey();\n\t\tif (!StringUtils.notEmpty(uploadKey)) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.UPLOAD_KEY_PARAMETER_MISSING.getName(), absolutePuName);\n\t\t}\n\n\t\tString cloudOverrides = request.getCloudOverrides();\n\t\tif (cloudOverrides.length() > overrdiesMaxLength) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.OVERRIDES_LENGTH_LIMIT_EXCEEDED.getName(), absolutePuName);\n\t\t}\n\t\tString serviceOverrides = request.getServiceOverrides();\n\t\tif (serviceOverrides.length() > overrdiesMaxLength) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.OVERRIDES_LENGTH_LIMIT_EXCEEDED.getName(), absolutePuName);\n\t\t}\n\n\t\tString authGroups = request.getAuthGroups();\n\t\t\n\t}","id":24890,"modified_method":"@Override\n\tpublic void validate(final InstallServiceValidationContext validationContext) throws RestErrorException {\n\t\tString absolutePuName = validationContext.getAbsolutePuName();\n\t\tInstallServiceRequest request = validationContext.getRequest();\n\t\tif (request == null) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.VALIDATOR_REQUEST_MISSING.getName(), absolutePuName);\n\t\t}\n\t\tString uploadKey = request.getUploadKey();\n\t\tif (!StringUtils.notEmpty(uploadKey)) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.UPLOAD_KEY_PARAMETER_MISSING.getName(), absolutePuName);\n\t\t}\n\n\t\tString cloudOverrides = request.getCloudOverrides();\n\t\tif (cloudOverrides.length() > overrdiesMaxLength) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.SERVICE_OVERRIDES_LENGTH_LIMIT_EXCEEDED.getName(), absolutePuName);\n\t\t}\n\t\tString serviceOverrides = request.getServiceOverrides();\n\t\tif (serviceOverrides.length() > overrdiesMaxLength) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.SERVICE_OVERRIDES_LENGTH_LIMIT_EXCEEDED.getName(), absolutePuName);\n\t\t}\n\n\t\tString authGroups = request.getAuthGroups();\n\t\t\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic InstallServiceValidator getValidatorInstance(final Object optionalValidatorParam) {\n\t\tValidateInstallServiceRequest validator = new ValidateInstallServiceRequest();\n\t\tif (optionalValidatorParam != null) {\n\t\t\tvalidator.setOverrdiesMaxLength((Long) optionalValidatorParam);\n\t\t}\n\t\treturn validator;\n\t}","id":24891,"modified_method":"@Override\n\tpublic InstallServiceValidator getValidatorInstance() {\n\t\treturn validator;\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void testServiceOverridesMaxLengthExceeded() {\n\t\tfinal InstallServiceRequest request = buildRequest(\n\t\t\t\tUPLOAD_KEY /* uploadKey */, CLOUD_CONFIG_UPLOAD_KEY /* cloudConfigUploadKey */, \n\t\t\t\tAUTH_GROUP /* authGroups */, SELF_HEALING /* selfHealing */, \n\t\t\t\tCLOUD_OVERRIDES /* cloudOverrides */, \"a = b\" /* serviceOverrides */);\n\t\ttestValidator(request, CloudifyMessageKeys.OVERRIDES_LENGTH_LIMIT_EXCEEDED, OVERRIDES_MAX_LENGTH);\n\t}","id":24892,"modified_method":"@Test\n\tpublic void testServiceOverridesMaxLengthExceeded() {\n\t\tfinal InstallServiceRequest request = buildRequest(\n\t\t\t\tUPLOAD_KEY /* uploadKey */, CLOUD_CONFIG_UPLOAD_KEY /* cloudConfigUploadKey */, \n\t\t\t\tAUTH_GROUP /* authGroups */, SELF_HEALING /* selfHealing */, \n\t\t\t\tCLOUD_OVERRIDES /* cloudOverrides */, \"a = b\" /* serviceOverrides */);\n\t\tvalidator.setOverrdiesMaxLength(OVERRIDES_MAX_LENGTH);\n\t\ttestValidator(request, CloudifyMessageKeys.SERVICE_OVERRIDES_LENGTH_LIMIT_EXCEEDED);\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void testCloudOverridesMaxLengthExceeded() {\n\t\tfinal InstallServiceRequest request = buildRequest(\n\t\t\t\tUPLOAD_KEY /* uploadKey */, CLOUD_CONFIG_UPLOAD_KEY /* cloudConfigUploadKey */, \n\t\t\t\tAUTH_GROUP /* authGroups */, SELF_HEALING /* selfHealing */, \n\t\t\t\t\"a = b\" /* cloudOverrides */, SERVICE_OVERRIDES /* serviceOverrides */);\n\t\ttestValidator(request, CloudifyMessageKeys.OVERRIDES_LENGTH_LIMIT_EXCEEDED, OVERRIDES_MAX_LENGTH);\n\t}","id":24893,"modified_method":"@Test\n\tpublic void testCloudOverridesMaxLengthExceeded() {\n\t\tfinal InstallServiceRequest request = buildRequest(\n\t\t\t\tUPLOAD_KEY /* uploadKey */, CLOUD_CONFIG_UPLOAD_KEY /* cloudConfigUploadKey */, \n\t\t\t\tAUTH_GROUP /* authGroups */, SELF_HEALING /* selfHealing */, \n\t\t\t\t\"a = b\" /* cloudOverrides */, SERVICE_OVERRIDES /* serviceOverrides */);\n\t\tvalidator.setOverrdiesMaxLength(OVERRIDES_MAX_LENGTH);\n\t\ttestValidator(request, CloudifyMessageKeys.SERVICE_OVERRIDES_LENGTH_LIMIT_EXCEEDED);\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void testMissingTemplate() throws IOException, DSLException, PackagingException {\n\t\tCloud cloud = ServiceReader.readCloud(new File(CLOUD_FILE_PATH));\n\t\tService service = ServiceReader.readService(new File(NOT_EXIST_TEMPLATE_SERVICE_GROOVY));\n\t\ttestValidator(cloud, service, CloudifyMessageKeys.MISSING_TEMPLATE);\n\t}","id":24894,"modified_method":"@Test\n\tpublic void testMissingTemplate() throws IOException, DSLException, PackagingException {\n\t\tCloud cloud = ServiceReader.readCloud(new File(CLOUD_FILE_PATH));\n\t\tService service = ServiceReader.readService(new File(NOT_EXIST_TEMPLATE_SERVICE_GROOVY));\n\t\ttestValidator(cloud, service, service.getCompute().getTemplate(), CloudifyMessageKeys.MISSING_TEMPLATE);\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic InstallServiceValidator getValidatorInstance(final Object optionalValidatorParam) {\n\t\treturn new ValidateTemplate();\n\t}","id":24895,"modified_method":"@Override\n\tpublic InstallServiceValidator getValidatorInstance() {\n\t\treturn new ValidateTemplate();\n\t}","commit_id":"32e7df5bdcba2a91d206999399e2a0236b0e27c2","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateInstallService(final String absolutePuName, final InstallServiceRequest request,\n\t\t\tfinal Service service, final String templateName) throws RestErrorException {\n\t\tfinal InstallServiceValidationContext validationContext = new InstallServiceValidationContext();\n\t\tvalidationContext.setAbsolutePuName(absolutePuName);\n\t\tvalidationContext.setCloud(restConfig.getCloud());\n\t\tvalidationContext.setRequest(request);\n\t\tvalidationContext.setService(service);\n\t\tvalidationContext.setTemplateName(templateName);\n\t\tfor (final InstallServiceValidator validator : installServiceValidators) {\n\t\t\tvalidator.validate(validationContext);\n\t\t}\n\t}","id":24896,"modified_method":"private void validateInstallService(final String absolutePuName, final InstallServiceRequest request,\n\t\t\tfinal Service service, final String templateName, File cloudConfiguration) throws RestErrorException {\n\t\tfinal InstallServiceValidationContext validationContext = new InstallServiceValidationContext();\n\t\tvalidationContext.setAbsolutePuName(absolutePuName);\n\t\tvalidationContext.setCloud(restConfig.getCloud());\n\t\tvalidationContext.setRequest(request);\n\t\tvalidationContext.setService(service);\n\t\tvalidationContext.setTemplateName(templateName);\n\t\tvalidationContext.setCloudConfiguration(cloudConfiguration);\n\t\tfor (final InstallServiceValidator validator : installServiceValidators) {\n\t\t\tvalidator.validate(validationContext);\n\t\t}\n\t}","commit_id":"430c06b529104363b9030ea9c0aeb0a008a5346c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/******\n\t * Installs an service.\n\t * \n\t * @param appName\n\t *            the application name.\n\t * @param serviceName\n\t *            the service name.\n\t * @param request\n\t *            the install-service request.\n\t * @return {@link InstallServiceResponse} contains the lifecycleEventContainerID.\n\t * @throws RestErrorException .\n\t */\n\t@RequestMapping(value = \"/{appName}/services/{serviceName}\", method = RequestMethod.POST)\n\tpublic InstallServiceResponse installService(\n\t\t\t@PathVariable final String appName,\n\t\t\t@PathVariable final String serviceName,\n\t\t\tfinal InstallServiceRequest request) throws RestErrorException {\n\n\t\tfinal String absolutePuName = ServiceUtils.getAbsolutePUName(appName, serviceName);\n\n\t\tfinal File srcFile = repo.get(request.getUploadKey());\n\t\tFile serviceDir = null;\n\t\ttry {\n\t\t\t// unzip srcFile into a new directory named absolutePuName under baseDir.\n\t\t\tserviceDir = ServiceReader.extractProjectFileToDir(srcFile, absolutePuName, repo.getBaseDir());\n\t\t} catch (final IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\tFile editSrcFile = srcFile;\n\t\t\n\t\ttry {\n\t\t\tmergeOverridesWithProperties(request, serviceDir);\n\t\t} catch (IOException e2) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\n\t\ttry {\n\t\t\teditSrcFile = Packager.createZipFile(\"temp\", serviceDir);\n\t\t} catch (IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\t\n\t\t// Use service reader to read the service\n\t\tService service = null;\n\t\ttry {\n\t\t\tservice = ServiceReader.readService(editSrcFile);\n\t\t} catch (final DSLException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t} catch (final PackagingException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\t// update template name\n\t\tString templateName = getTempalteNameFromService(service);\n\n\t\t// validate\n\t\tvalidateInstallService(absolutePuName, request, service, templateName);\n\t\t\n\t\t// TODO update/create props file\n\t\t\n\t\t// TODO use repo to get cloudOverrides\n\t\t\n\t\t// update effective authGroups\n\t\tString effectiveAuthGroups = request.getAuthGroups();\n\t\tif (StringUtils.isBlank(effectiveAuthGroups)) {\n\t\t\tif (permissionEvaluator != null) {\n\t\t\t\teffectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();\n\t\t\t} else {\n\t\t\t\teffectiveAuthGroups = \"\";\n\t\t\t}\n\t\t}\n\n\t\t// TODO call doDeploy\n\t\t\n\t\tInstallServiceResponse installServiceResponse = new InstallServiceResponse();\n\t\tString lifecycleEventContainerID = \"\";\n\t\t// TODO update lifecycleEventContainerID\n\t\tinstallServiceResponse.setLifecycleEventContainerID(lifecycleEventContainerID);\n\t\treturn installServiceResponse;\n\n\t}","id":24897,"modified_method":"/******\n\t * Installs an service.\n\t * \n\t * @param appName\n\t *            the application name.\n\t * @param serviceName\n\t *            the service name.\n\t * @param request\n\t *            the install-service request.\n\t * @return {@link InstallServiceResponse} contains the lifecycleEventContainerID.\n\t * @throws RestErrorException .\n\t */\n\t@RequestMapping(value = \"/{appName}/services/{serviceName}\", method = RequestMethod.POST)\n\tpublic InstallServiceResponse installService(\n\t\t\t@PathVariable final String appName,\n\t\t\t@PathVariable final String serviceName,\n\t\t\tfinal InstallServiceRequest request) throws RestErrorException {\n\n\t\tfinal String absolutePuName = ServiceUtils.getAbsolutePUName(appName, serviceName);\n\n\t\tfinal File srcFile = repo.get(request.getUploadKey());\n\t\tFile serviceDir = null;\n\t\ttry {\n\t\t\t// unzip srcFile into a new directory named absolutePuName under baseDir.\n\t\t\tserviceDir = ServiceReader.extractProjectFileToDir(srcFile, absolutePuName, repo.getBaseDir());\n\t\t} catch (final IOException e1) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.FAILED_TO_EXTRACT_PROJECT_FILE.getName(), absolutePuName);\n\t\t}\n\n\t\tFile editSrcFile = srcFile;\n\t\t\n\t\ttry {\n\t\t\tmergeOverridesWithProperties(request, serviceDir);\n\t\t\teditSrcFile = Packager.createZipFile(\"temp\", serviceDir);\n\t\t} catch (IOException e2) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.FAILED_TO_MERGE_OVERRIDES.getName(), absolutePuName);\n\t\t}\n\t\t\n\t\t// Use service reader to read the service\n\t\tService service = null;\n\t\ttry {\n\t\t\tservice = ServiceReader.readService(editSrcFile);\n\t\t} catch (final Exception e) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.FAILED_TO_READ_SERVICE.getName(), absolutePuName);\n\t\t}\n\n\t\t// update template name\n\t\tString templateName = getTempalteNameFromService(service);\n\n\t\t// use repo to get serviceCloudConfiguration\n\t\tFile file = repo.get(request.getCloudConfigurationUploadKey());\n\t\tFile serviceCloudConfigurationFile = null;\n\t\tbyte[] serviceCloudConfigurationContents = null;\n\t\ttry {\n\t\t\tZipUtils.unzip(file, repo.getBaseDir());\n\t\t\tserviceCloudConfigurationFile = \n\t\t\t\t\tnew File(repo.getBaseDir(), CloudifyConstants.SERVICE_CLOUD_CONFIGURATION_FILE_NAME);\n\t\t\tif (serviceCloudConfigurationFile != null) {\n\t\t\t\tserviceCloudConfigurationContents = FileUtils\n\t\t\t\t\t\t.readFileToByteArray(serviceCloudConfigurationFile);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.FAILED_TO_READ_SERVICE_CLOUD_CONFIGURATION.getName(), \n\t\t\t\t\tabsolutePuName);\n\t\t}\n\t\t\n\t\t// validate\n\t\tvalidateInstallService(absolutePuName, request, service, templateName, serviceCloudConfigurationFile);\n\t\t\n\t\t// TODO update/create props file\n\t\t\n\t\t\n\t\t// update effective authGroups\n\t\tString effectiveAuthGroups = request.getAuthGroups();\n\t\tif (StringUtils.isBlank(effectiveAuthGroups)) {\n\t\t\tif (permissionEvaluator != null) {\n\t\t\t\teffectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();\n\t\t\t} else {\n\t\t\t\teffectiveAuthGroups = \"\";\n\t\t\t}\n\t\t}\n\n\t\t// TODO call deployer to deploy service\n\t\t\n\t\tInstallServiceResponse installServiceResponse = new InstallServiceResponse();\n\t\tString lifecycleEventContainerID = \"\";\n\t\t// TODO update lifecycleEventContainerID\n\t\tinstallServiceResponse.setLifecycleEventContainerID(lifecycleEventContainerID);\n\t\treturn installServiceResponse;\n\n\t}","commit_id":"430c06b529104363b9030ea9c0aeb0a008a5346c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/******\n\t * Installs an service.\n\t * \n\t * @param appName\n\t *            the application name.\n\t * @param serviceName\n\t *            the service name.\n\t * @param request\n\t *            the install-service request.\n\t * @return {@link InstallServiceResponse} contains the lifecycleEventContainerID.\n\t * @throws RestErrorException .\n\t */\n\t@RequestMapping(value = \"/{appName}/services/{serviceName}\", method = RequestMethod.POST)\n\tpublic InstallServiceResponse installService(\n\t\t\t@PathVariable final String appName,\n\t\t\t@PathVariable final String serviceName,\n\t\t\tfinal InstallServiceRequest request) throws RestErrorException {\n\n\t\tfinal String absolutePuName = ServiceUtils.getAbsolutePUName(appName, serviceName);\n\n\t\tfinal File srcFile = repo.get(request.getUploadKey());\n\t\tFile serviceDir = null;\n\t\ttry {\n\t\t\t// unzip srcFile into a new directory named absolutePuName under baseDir.\n\t\t\tserviceDir = ServiceReader.extractProjectFileToDir(srcFile, absolutePuName, repo.getBaseDir());\n\t\t} catch (final IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\tFile editSrcFile = srcFile;\n\t\t\n\t\tmergeOverridesWithProperties(request, serviceDir);\n\t\n\t\ttry {\n\t\t\teditSrcFile = Packager.createZipFile(\"temp\", serviceDir);\n\t\t} catch (IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\t\n\t\t// Use service reader to read the service\n\t\tService service = null;\n\t\ttry {\n\t\t\tservice = ServiceReader.readService(editSrcFile);\n\t\t} catch (final DSLException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t} catch (final PackagingException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\t// update template name\n\t\tString templateName = getTempalteNameFromService(service);\n\n\t\t// TODO update/create props file\n\t\t\n\t\t// validate\n\t\tvalidateInstallService(absolutePuName, request, service, templateName);\n\n\t\t// TODO call doDeploy\n\t\t\n\t\tInstallServiceResponse installServiceResponse = new InstallServiceResponse();\n\t\tString lifecycleEventContainerID = \"\";\n\t\t// TODO update lifecycleEventContainerID\n\t\tinstallServiceResponse.setLifecycleEventContainerID(lifecycleEventContainerID);\n\t\treturn installServiceResponse;\n\n\t}","id":24898,"modified_method":"/******\n\t * Installs an service.\n\t * \n\t * @param appName\n\t *            the application name.\n\t * @param serviceName\n\t *            the service name.\n\t * @param request\n\t *            the install-service request.\n\t * @return {@link InstallServiceResponse} contains the lifecycleEventContainerID.\n\t * @throws RestErrorException .\n\t */\n\t@RequestMapping(value = \"/{appName}/services/{serviceName}\", method = RequestMethod.POST)\n\tpublic InstallServiceResponse installService(\n\t\t\t@PathVariable final String appName,\n\t\t\t@PathVariable final String serviceName,\n\t\t\tfinal InstallServiceRequest request) throws RestErrorException {\n\n\t\tfinal String absolutePuName = ServiceUtils.getAbsolutePUName(appName, serviceName);\n\n\t\tfinal File srcFile = repo.get(request.getUploadKey());\n\t\tFile serviceDir = null;\n\t\ttry {\n\t\t\t// unzip srcFile into a new directory named absolutePuName under baseDir.\n\t\t\tserviceDir = ServiceReader.extractProjectFileToDir(srcFile, absolutePuName, repo.getBaseDir());\n\t\t} catch (final IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\tFile editSrcFile = srcFile;\n\t\t\n\t\ttry {\n\t\t\tmergeOverridesWithProperties(request, serviceDir);\n\t\t} catch (IOException e2) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\n\t\ttry {\n\t\t\teditSrcFile = Packager.createZipFile(\"temp\", serviceDir);\n\t\t} catch (IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\t\n\t\t// Use service reader to read the service\n\t\tService service = null;\n\t\ttry {\n\t\t\tservice = ServiceReader.readService(editSrcFile);\n\t\t} catch (final DSLException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t} catch (final PackagingException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\t// update template name\n\t\tString templateName = getTempalteNameFromService(service);\n\n\t\t// validate\n\t\tvalidateInstallService(absolutePuName, request, service, templateName);\n\t\t\n\t\t// TODO update/create props file\n\t\t\n\t\t// TODO use repo to get cloudOverrides\n\t\t\n\t\t// update effective authGroups\n\t\tString effectiveAuthGroups = request.getAuthGroups();\n\t\tif (StringUtils.isBlank(effectiveAuthGroups)) {\n\t\t\tif (permissionEvaluator != null) {\n\t\t\t\teffectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();\n\t\t\t} else {\n\t\t\t\teffectiveAuthGroups = \"\";\n\t\t\t}\n\t\t}\n\n\t\t// TODO call doDeploy\n\t\t\n\t\tInstallServiceResponse installServiceResponse = new InstallServiceResponse();\n\t\tString lifecycleEventContainerID = \"\";\n\t\t// TODO update lifecycleEventContainerID\n\t\tinstallServiceResponse.setLifecycleEventContainerID(lifecycleEventContainerID);\n\t\treturn installServiceResponse;\n\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void mergeOverridesWithProperties(final InstallServiceRequest request, final File serviceDir) \n\t\t\tthrows RestErrorException {\n\t\tString serviceOverrides = request.getServiceOverrides();\n\t\t// check if merge is necessary\n\t\tif (StringUtils.notEmpty(serviceOverrides)) {\n\t\t\t// get properties file from working directory\n\t\t\tfinal File workingProjectDir = new File(serviceDir, \"ext\");\n\t\t\tfinal String propertiesFileName = \n\t\t\t\t\tDSLUtils.getPropertiesFileName(workingProjectDir, DSLUtils.SERVICE_DSL_FILE_NAME_SUFFIX);\n\t\t\tfinal File servicePropertiesFile = new File(workingProjectDir, propertiesFileName);\n\t\t\t// load properties\n\t\t\tProperties serviceProperties = new Properties();\n\t\t\tFileInputStream inStream;\n\t\t\ttry {\n\t\t\t\t// create new properties file if needed\n\t\t\t\tif (!servicePropertiesFile.exists()) {\n\t\t\t\t\tservicePropertiesFile.createNewFile();\n\t\t\t\t}\n\t\t\t\tinStream = new FileInputStream(servicePropertiesFile);\n\t\t\t\tserviceProperties.load(inStream);\n\t\t\t\t// add/update properties from overrides\n\t\t\t\tString[] serviceOverridesProeprties = serviceOverrides.split(\",\");\n\t\t\t\tfor (String keyValuePairStr : serviceOverridesProeprties) {\n\t\t\t\t\tString[] keyValuePair = keyValuePairStr.split(\"=\");\n\t\t\t\t\tserviceProperties.setProperty(keyValuePair[0].trim(), keyValuePair[1].trim());\n\t\t\t\t}\n\t\t\t\t// store\n\t\t\t\tserviceProperties.store(new FileOutputStream(servicePropertiesFile), null);\n\t\t\t} catch (FileNotFoundException e2) {\n\t\t\t\t// TODO Add error massage. \n\t\t\t\tthrow new RestErrorException(\"\");\n\t\t\t} catch (IOException e) {\n\t\t\t\t// TODO Add error massage. \n\t\t\t\tthrow new RestErrorException(\"\");\n\t\t\t}\n\t\t}\n\t}","id":24899,"modified_method":"private void mergeOverridesWithProperties(final InstallServiceRequest request, final File serviceDir) \n\t\t\tthrows RestErrorException, IOException {\n\t\tString serviceOverrides = request.getServiceOverrides();\n\t\tFile applicationProeprtiesFile = request.getApplicationPropertiesFile();\n\t\t// check if merge is necessary\n\t\tif (!StringUtils.isBlank(serviceOverrides) || applicationProeprtiesFile != null) {\n\t\t\t// get properties file from working directory\n\t\t\tfinal File workingProjectDir = new File(serviceDir, \"ext\");\n\t\t\tfinal String propertiesFileName = \n\t\t\t\t\tDSLUtils.getPropertiesFileName(workingProjectDir, DSLUtils.SERVICE_DSL_FILE_NAME_SUFFIX);\n\t\t\tfinal File servicePropertiesFile = new File(workingProjectDir, propertiesFileName);\n\t\t\tfinal File finalPropertiesFile = File.createTempFile(\"finalPropertiesFile\", \".properties\");\n\t\t\ttry {\n\t\t\t\tFileAppender appender = new FileAppender(finalPropertiesFile);\n\t\t\t\tif (applicationProeprtiesFile != null && applicationProeprtiesFile.exists()) {\n\t\t\t\t\tappender.append(\"application proeprties file\", applicationProeprtiesFile);\n\t\t\t\t}\n\t\t\t\tif (servicePropertiesFile.exists()) {\n\t\t\t\t\tappender.append(\"service proeprties file\", servicePropertiesFile);\n\t\t\t\t}\n\t\t\t\tif (!StringUtils.isBlank(serviceOverrides)) {\n\t\t\t\t\tserviceOverrides = serviceOverrides.replaceAll(\",\", FileAppender.LINE_SEPARATOR);\n\t\t\t\t\tappender.append(\"service overrides file\", serviceOverrides);\n\t\t\t\t}\n\t\t\t\tappender.flush();\n\t\t\t\tFileUtils.copyFile(finalPropertiesFile, servicePropertiesFile);\n\t\t\t} finally {\n\t\t\t\tfinalPropertiesFile.delete();\n\t\t\t}\n\t\t}\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * @param comment - this comment will be appended to the beginning of the file to merge.\n\t * @param fileToMerge - the file to merge with\n\t * @return .\n\t * @throws IOException \n\t */\n\tpublic FileAppender append(final String comment, final File fileToMerge) throws IOException {\n\t\twriter.append(\"//\").append(comment).append(\" Generated By \").append(FileAppender.class.getName())\n            .append(\" On : \").append(new Date(System.currentTimeMillis()).toString())\n\t\t    .append(LINE_SEPARATOR)\n\t\t    .append(LINE_SEPARATOR)\n\t\t    .append(FileUtils.readFileToString(fileToMerge))\n\t\t    .append(LINE_SEPARATOR)\n\t\t    .append(LINE_SEPARATOR);\n\t\treturn this;\n\t}","id":24900,"modified_method":"/**\n\t * @param comment - this comment will be appended to the beginning of the file to merge.\n\t * @param fileToMerge - the file to merge with\n\t * @return .\n\t * @throws IOException \n\t */\n\tpublic FileAppender append(final String comment, final File fileToMerge) throws IOException {\n\t\treturn append(comment, FileUtils.readFileToString(fileToMerge));\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final Cloud cloud, final Service service, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, true, exceptionCause);\n\t}","id":24901,"modified_method":"public void testValidator(final Cloud cloud, final Service service, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, null, null, true, exceptionCause);\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public abstract InstallServiceValidator getValidatorInstance(Object optionalValidatorParam);","id":24902,"modified_method":"public abstract InstallServiceValidator getValidatorInstance();","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final InstallServiceRequest request, final Cloud cloud, final Service service,\n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause, \n\t\t\tfinal CustomPermissionEvaluator permissionEvaluator, final Object optionalValidatorParam) {\n\t\t\n\t\tfinal InstallServiceValidator validator = getValidatorInstance(optionalValidatorParam);\n\t\tInstallServiceValidationContext validationContext = new InstallServiceValidationContext();\n\t\tvalidationContext.setRequest(request);\n\t\tvalidationContext.setCloud(cloud);\n\t\tvalidationContext.setService(service);\n\t\ttry {\n\t\t\tvalidator.validate(validationContext);\n\t\t\tif (shouldFail) {\n\t\t\t\tAssert.fail(exceptionCause + \" didn't yield the expected RestErrorException.\");\n\t\t\t}\n\t\t} catch (final RestErrorException e) {\n\t\t\tif (!shouldFail) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tAssert.assertEquals(exceptionCause.getName(), e.getMessage());\n\t\t}\n\t}","id":24903,"modified_method":"public void testValidator(final InstallServiceRequest request, final Cloud cloud, final Service service, \n\t\t\tfinal String templateName, final File cloudOverridesFile, \n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\t\n\t\tfinal InstallServiceValidator validator = getValidatorInstance();\n\t\tInstallServiceValidationContext validationContext = new InstallServiceValidationContext();\n\t\tvalidationContext.setRequest(request);\n\t\tvalidationContext.setCloud(cloud);\n\t\tvalidationContext.setService(service);\n\t\tvalidationContext.setCloudConfiguration(cloudOverridesFile);\n\t\tvalidationContext.setTemplateName(templateName);\n\t\ttry {\n\t\t\tvalidator.validate(validationContext);\n\t\t\tif (shouldFail) {\n\t\t\t\tAssert.fail(exceptionCause + \" didn't yield the expected RestErrorException.\");\n\t\t\t}\n\t\t} catch (final RestErrorException e) {\n\t\t\tif (!shouldFail) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tAssert.fail();\n\t\t\t}\n\t\t\tAssert.assertEquals(exceptionCause.getName(), e.getMessage());\n\t\t}\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final InstallServiceRequest request, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(request, null, null, true, exceptionCause);\n\t}","id":24904,"modified_method":"public void testValidator(final InstallServiceRequest request, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(request, null, null, null, null, true, exceptionCause);\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final InstallServiceRequest request, final Cloud cloud, final Service service,\n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(request, cloud, service, shouldFail, exceptionCause, null, null);\n\t}","id":24905,"modified_method":"public void testValidator(final InstallServiceRequest request, final Cloud cloud, final Service service,\n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(request, cloud, service, null, null, shouldFail, exceptionCause);\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final Cloud cloud, final Service service, \n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, shouldFail, exceptionCause);\n\t}","id":24906,"modified_method":"public void testValidator(final Cloud cloud, final Service service, \n\t\t\tfinal boolean shouldFail, final CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, null, null, shouldFail, exceptionCause);\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public void testValidator(final InstallServiceRequest request, final CloudifyMessageKeys exceptionCause, \n\t\t\tfinal Object optionalValidatorParam) {\n\t\ttestValidator(request, null, null, true, exceptionCause, null, optionalValidatorParam);\n\t}","id":24907,"modified_method":"public void testValidator(final Cloud cloud, final Service service, final String templateName, \n\t\t\tfinal CloudifyMessageKeys exceptionCause) {\n\t\ttestValidator(null, cloud, service, templateName, null, true, exceptionCause);\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void validate(final InstallServiceValidationContext validationContext) throws RestErrorException {\n\t\tString absolutePuName = validationContext.getAbsolutePuName();\n\t\tInstallServiceRequest request = validationContext.getRequest();\n\t\tif (request == null) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.VALIDATOR_REQUEST_MISSING.getName(), absolutePuName);\n\t\t}\n\t\tString uploadKey = request.getUploadKey();\n\t\tif (!StringUtils.notEmpty(uploadKey)) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.UPLOAD_KEY_PARAMETER_MISSING.getName(), absolutePuName);\n\t\t}\n\n\t\tString cloudOverrides = request.getCloudOverrides();\n\t\tif (cloudOverrides.length() > overrdiesMaxLength) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.OVERRIDES_LENGTH_LIMIT_EXCEEDED.getName(), absolutePuName);\n\t\t}\n\t\tString serviceOverrides = request.getServiceOverrides();\n\t\tif (serviceOverrides.length() > overrdiesMaxLength) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.OVERRIDES_LENGTH_LIMIT_EXCEEDED.getName(), absolutePuName);\n\t\t}\n\n\t\tString authGroups = request.getAuthGroups();\n\t\t\n\t}","id":24908,"modified_method":"@Override\n\tpublic void validate(final InstallServiceValidationContext validationContext) throws RestErrorException {\n\t\tString absolutePuName = validationContext.getAbsolutePuName();\n\t\tInstallServiceRequest request = validationContext.getRequest();\n\t\tif (request == null) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.VALIDATOR_REQUEST_MISSING.getName(), absolutePuName);\n\t\t}\n\t\tString uploadKey = request.getUploadKey();\n\t\tif (!StringUtils.notEmpty(uploadKey)) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.UPLOAD_KEY_PARAMETER_MISSING.getName(), absolutePuName);\n\t\t}\n\n\t\tString cloudOverrides = request.getCloudOverrides();\n\t\tif (cloudOverrides.length() > overrdiesMaxLength) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.SERVICE_OVERRIDES_LENGTH_LIMIT_EXCEEDED.getName(), absolutePuName);\n\t\t}\n\t\tString serviceOverrides = request.getServiceOverrides();\n\t\tif (serviceOverrides.length() > overrdiesMaxLength) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.SERVICE_OVERRIDES_LENGTH_LIMIT_EXCEEDED.getName(), absolutePuName);\n\t\t}\n\n\t\tString authGroups = request.getAuthGroups();\n\t\t\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic InstallServiceValidator getValidatorInstance(final Object optionalValidatorParam) {\n\t\tValidateInstallServiceRequest validator = new ValidateInstallServiceRequest();\n\t\tif (optionalValidatorParam != null) {\n\t\t\tvalidator.setOverrdiesMaxLength((Long) optionalValidatorParam);\n\t\t}\n\t\treturn validator;\n\t}","id":24909,"modified_method":"@Override\n\tpublic InstallServiceValidator getValidatorInstance() {\n\t\treturn validator;\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void testCloudOverridesMaxLengthExceeded() {\n\t\tfinal InstallServiceRequest request = buildRequest(\n\t\t\t\tUPLOAD_KEY /* uploadKey */, CLOUD_CONFIG_UPLOAD_KEY /* cloudConfigUploadKey */, \n\t\t\t\tAUTH_GROUP /* authGroups */, SELF_HEALING /* selfHealing */, \n\t\t\t\t\"a = b\" /* cloudOverrides */, SERVICE_OVERRIDES /* serviceOverrides */);\n\t\ttestValidator(request, CloudifyMessageKeys.OVERRIDES_LENGTH_LIMIT_EXCEEDED, OVERRIDES_MAX_LENGTH);\n\t}","id":24910,"modified_method":"@Test\n\tpublic void testCloudOverridesMaxLengthExceeded() {\n\t\tfinal InstallServiceRequest request = buildRequest(\n\t\t\t\tUPLOAD_KEY /* uploadKey */, CLOUD_CONFIG_UPLOAD_KEY /* cloudConfigUploadKey */, \n\t\t\t\tAUTH_GROUP /* authGroups */, SELF_HEALING /* selfHealing */, \n\t\t\t\t\"a = b\" /* cloudOverrides */, SERVICE_OVERRIDES /* serviceOverrides */);\n\t\tvalidator.setOverrdiesMaxLength(OVERRIDES_MAX_LENGTH);\n\t\ttestValidator(request, CloudifyMessageKeys.SERVICE_OVERRIDES_LENGTH_LIMIT_EXCEEDED);\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void testServiceOverridesMaxLengthExceeded() {\n\t\tfinal InstallServiceRequest request = buildRequest(\n\t\t\t\tUPLOAD_KEY /* uploadKey */, CLOUD_CONFIG_UPLOAD_KEY /* cloudConfigUploadKey */, \n\t\t\t\tAUTH_GROUP /* authGroups */, SELF_HEALING /* selfHealing */, \n\t\t\t\tCLOUD_OVERRIDES /* cloudOverrides */, \"a = b\" /* serviceOverrides */);\n\t\ttestValidator(request, CloudifyMessageKeys.OVERRIDES_LENGTH_LIMIT_EXCEEDED, OVERRIDES_MAX_LENGTH);\n\t}","id":24911,"modified_method":"@Test\n\tpublic void testServiceOverridesMaxLengthExceeded() {\n\t\tfinal InstallServiceRequest request = buildRequest(\n\t\t\t\tUPLOAD_KEY /* uploadKey */, CLOUD_CONFIG_UPLOAD_KEY /* cloudConfigUploadKey */, \n\t\t\t\tAUTH_GROUP /* authGroups */, SELF_HEALING /* selfHealing */, \n\t\t\t\tCLOUD_OVERRIDES /* cloudOverrides */, \"a = b\" /* serviceOverrides */);\n\t\tvalidator.setOverrdiesMaxLength(OVERRIDES_MAX_LENGTH);\n\t\ttestValidator(request, CloudifyMessageKeys.SERVICE_OVERRIDES_LENGTH_LIMIT_EXCEEDED);\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Test\n\tpublic void testMissingTemplate() throws IOException, DSLException, PackagingException {\n\t\tCloud cloud = ServiceReader.readCloud(new File(CLOUD_FILE_PATH));\n\t\tService service = ServiceReader.readService(new File(NOT_EXIST_TEMPLATE_SERVICE_GROOVY));\n\t\ttestValidator(cloud, service, CloudifyMessageKeys.MISSING_TEMPLATE);\n\t}","id":24912,"modified_method":"@Test\n\tpublic void testMissingTemplate() throws IOException, DSLException, PackagingException {\n\t\tCloud cloud = ServiceReader.readCloud(new File(CLOUD_FILE_PATH));\n\t\tService service = ServiceReader.readService(new File(NOT_EXIST_TEMPLATE_SERVICE_GROOVY));\n\t\ttestValidator(cloud, service, service.getCompute().getTemplate(), CloudifyMessageKeys.MISSING_TEMPLATE);\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic InstallServiceValidator getValidatorInstance(final Object optionalValidatorParam) {\n\t\treturn new ValidateTemplate();\n\t}","id":24913,"modified_method":"@Override\n\tpublic InstallServiceValidator getValidatorInstance() {\n\t\treturn new ValidateTemplate();\n\t}","commit_id":"4aaf8bdc0007c8151ec7da0002ac93adc14613d0","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/******\n\t * Installs an service.\n\t * \n\t * @param appName\n\t *            the application name.\n\t * @param serviceName\n\t *            the service name.\n\t * @param request\n\t *            the install-service request.\n\t * @return {@link InstallServiceResponse} contains the lifecycleEventContainerID.\n\t * @throws RestErrorException .\n\t */\n\t@RequestMapping(value = \"/{appName}/services/{serviceName}\", method = RequestMethod.POST)\n\tpublic InstallServiceResponse installService(\n\t\t\t@PathVariable final String appName,\n\t\t\t@PathVariable final String serviceName,\n\t\t\tfinal InstallServiceRequest request) throws RestErrorException {\n\n\t\tfinal String absolutePuName = ServiceUtils.getAbsolutePUName(appName, serviceName);\n\n\t\tfinal File srcFile = repo.get(request.getUploadKey());\n\t\tFile serviceDir = null;\n\t\ttry {\n\t\t\t// unzip srcFile into a new directory named absolutePuName under baseDir.\n\t\t\tserviceDir = ServiceReader.extractProjectFileToDir(srcFile, absolutePuName, repo.getBaseDir());\n\t\t} catch (final IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\tFile editSrcFile = srcFile;\n\t\t\n\t\ttry {\n\t\t\tmergeOverridesWithProperties(request, serviceDir);\n\t\t} catch (IOException e2) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\n\t\ttry {\n\t\t\teditSrcFile = Packager.createZipFile(\"temp\", serviceDir);\n\t\t} catch (IOException e1) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\t\t\n\t\t// Use service reader to read the service\n\t\tService service = null;\n\t\ttry {\n\t\t\tservice = ServiceReader.readService(editSrcFile);\n\t\t} catch (final DSLException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t} catch (final PackagingException e) {\n\t\t\t// TODO Add error massage. \n\t\t\tthrow new RestErrorException(\"\");\n\t\t}\n\n\t\t// update template name\n\t\tString templateName = getTempalteNameFromService(service);\n\n\t\t// validate\n\t\tvalidateInstallService(absolutePuName, request, service, templateName);\n\t\t\n\t\t// TODO update/create props file\n\t\t\n\t\t// TODO use repo to get cloudOverrides\n\t\t\n\t\t// update effective authGroups\n\t\tString effectiveAuthGroups = request.getAuthGroups();\n\t\tif (StringUtils.isBlank(effectiveAuthGroups)) {\n\t\t\tif (permissionEvaluator != null) {\n\t\t\t\teffectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();\n\t\t\t} else {\n\t\t\t\teffectiveAuthGroups = \"\";\n\t\t\t}\n\t\t}\n\n\t\t// TODO call doDeploy\n\t\t\n\t\tInstallServiceResponse installServiceResponse = new InstallServiceResponse();\n\t\tString lifecycleEventContainerID = \"\";\n\t\t// TODO update lifecycleEventContainerID\n\t\tinstallServiceResponse.setLifecycleEventContainerID(lifecycleEventContainerID);\n\t\treturn installServiceResponse;\n\n\t}","id":24914,"modified_method":"/******\n\t * Installs an service.\n\t * \n\t * @param appName\n\t *            the application name.\n\t * @param serviceName\n\t *            the service name.\n\t * @param request\n\t *            the install-service request.\n\t * @return {@link InstallServiceResponse} contains the lifecycleEventContainerID.\n\t * @throws RestErrorException .\n\t */\n\t@RequestMapping(value = \"/{appName}/services/{serviceName}\", method = RequestMethod.POST)\n\tpublic InstallServiceResponse installService(\n\t\t\t@PathVariable final String appName,\n\t\t\t@PathVariable final String serviceName,\n\t\t\tfinal InstallServiceRequest request) throws RestErrorException {\n\n\t\tfinal String absolutePuName = ServiceUtils.getAbsolutePUName(appName, serviceName);\n\n\t\tfinal File srcFile = repo.get(request.getUploadKey());\n\t\tFile serviceDir = null;\n\t\ttry {\n\t\t\t// unzip srcFile into a new directory named absolutePuName under baseDir.\n\t\t\tserviceDir = ServiceReader.extractProjectFileToDir(srcFile, absolutePuName, repo.getBaseDir());\n\t\t} catch (final IOException e1) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.FAILED_TO_EXTRACT_PROJECT_FILE.getName(), absolutePuName);\n\t\t}\n\n\t\tFile editSrcFile = srcFile;\n\t\t\n\t\ttry {\n\t\t\tmergeOverridesWithProperties(request, serviceDir);\n\t\t\teditSrcFile = Packager.createZipFile(\"temp\", serviceDir);\n\t\t} catch (IOException e2) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.FAILED_TO_MERGE_OVERRIDES.getName(), absolutePuName);\n\t\t}\n\t\t\n\t\t// Use service reader to read the service\n\t\tService service = null;\n\t\ttry {\n\t\t\tservice = ServiceReader.readService(editSrcFile);\n\t\t} catch (final Exception e) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.FAILED_TO_READ_SERVICE.getName(), absolutePuName);\n\t\t}\n\n\t\t// update template name\n\t\tString templateName = getTempalteNameFromService(service);\n\n\t\t// use repo to get serviceCloudConfiguration\n\t\tFile file = repo.get(request.getCloudConfigurationUploadKey());\n\t\tFile serviceCloudConfigurationFile = null;\n\t\tbyte[] serviceCloudConfigurationContents = null;\n\t\ttry {\n\t\t\tZipUtils.unzip(file, repo.getBaseDir());\n\t\t\tserviceCloudConfigurationFile = \n\t\t\t\t\tnew File(repo.getBaseDir(), CloudifyConstants.SERVICE_CLOUD_CONFIGURATION_FILE_NAME);\n\t\t\tif (serviceCloudConfigurationFile != null) {\n\t\t\t\tserviceCloudConfigurationContents = FileUtils\n\t\t\t\t\t\t.readFileToByteArray(serviceCloudConfigurationFile);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RestErrorException(CloudifyMessageKeys.FAILED_TO_READ_SERVICE_CLOUD_CONFIGURATION.getName(), \n\t\t\t\t\tabsolutePuName);\n\t\t}\n\t\t\n\t\t// validate\n\t\tvalidateInstallService(absolutePuName, request, service, templateName, serviceCloudConfigurationFile);\n\t\t\n\t\t// TODO update/create props file\n\t\t\n\t\t\n\t\t// update effective authGroups\n\t\tString effectiveAuthGroups = request.getAuthGroups();\n\t\tif (StringUtils.isBlank(effectiveAuthGroups)) {\n\t\t\tif (permissionEvaluator != null) {\n\t\t\t\teffectiveAuthGroups = permissionEvaluator.getUserAuthGroupsString();\n\t\t\t} else {\n\t\t\t\teffectiveAuthGroups = \"\";\n\t\t\t}\n\t\t}\n\n\t\t// TODO call deployer to deploy service\n\t\t\n\t\tInstallServiceResponse installServiceResponse = new InstallServiceResponse();\n\t\tString lifecycleEventContainerID = \"\";\n\t\t// TODO update lifecycleEventContainerID\n\t\tinstallServiceResponse.setLifecycleEventContainerID(lifecycleEventContainerID);\n\t\treturn installServiceResponse;\n\n\t}","commit_id":"878b242cff134c6f753705c9357eee1e5030992c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void validateInstallService(final String absolutePuName, final InstallServiceRequest request,\n\t\t\tfinal Service service, final String templateName) throws RestErrorException {\n\t\tfinal InstallServiceValidationContext validationContext = new InstallServiceValidationContext();\n\t\tvalidationContext.setAbsolutePuName(absolutePuName);\n\t\tvalidationContext.setCloud(restConfig.getCloud());\n\t\tvalidationContext.setRequest(request);\n\t\tvalidationContext.setService(service);\n\t\tvalidationContext.setTemplateName(templateName);\n\t\tfor (final InstallServiceValidator validator : installServiceValidators) {\n\t\t\tvalidator.validate(validationContext);\n\t\t}\n\t}","id":24915,"modified_method":"private void validateInstallService(final String absolutePuName, final InstallServiceRequest request,\n\t\t\tfinal Service service, final String templateName, File cloudConfiguration) throws RestErrorException {\n\t\tfinal InstallServiceValidationContext validationContext = new InstallServiceValidationContext();\n\t\tvalidationContext.setAbsolutePuName(absolutePuName);\n\t\tvalidationContext.setCloud(restConfig.getCloud());\n\t\tvalidationContext.setRequest(request);\n\t\tvalidationContext.setService(service);\n\t\tvalidationContext.setTemplateName(templateName);\n\t\tvalidationContext.setCloudConfiguration(cloudConfiguration);\n\t\tfor (final InstallServiceValidator validator : installServiceValidators) {\n\t\t\tvalidator.validate(validationContext);\n\t\t}\n\t}","commit_id":"878b242cff134c6f753705c9357eee1e5030992c","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n     * Generate reports pages\n     *\n     * @param reports\n     * @param locale\n     * @param localeOutputDirectory\n     */\n    private void generateReportsPages( List reports, Locale locale, File localeOutputDirectory, Locale defaultLocale,\n                                       String siteDescriptor )\n        throws RendererException, IOException, MavenReportException\n    {\n        for ( Iterator j = reports.iterator(); j.hasNext(); )\n        {\n            MavenReport report = (MavenReport) j.next();\n\n            getLog().info( \"Generate \\\"\" + report.getName( locale ) + \"\\\" report.\" );\n\n            report.setReportOutputDirectory( localeOutputDirectory );\n\n            String reportFileName = report.getOutputName();\n\n            if ( locale.equals( defaultLocale ) )\n            {\n                generatedReportsFileName.add( reportFileName );\n            }\n            else\n            {\n                generatedReportsFileName.add( locale.getLanguage() + File.separator + reportFileName );\n            }\n\n            String outputFileName = reportFileName + \".html\";\n\n            SiteRendererSink sink = siteRenderer.createSink( new File( siteDirectory ), outputFileName,\n                                                             siteDescriptor );\n\n            report.generate( sink, locale );\n\n            if ( !report.isExternalReport() )\n            {\n                File outputFile = new File( localeOutputDirectory, outputFileName );\n\n                if ( !outputFile.getParentFile().exists() )\n                {\n                    outputFile.getParentFile().mkdirs();\n                }\n\n                siteRenderer.generateDocument(\n                    new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ), template, attributes,\n                    sink, locale );\n            }\n        }\n    }","id":24916,"modified_method":"/**\n     * Generate reports pages\n     *\n     * @param reports\n     * @param locale\n     * @param localeOutputDirectory\n     */\n    private List generateReportsPages( List reports, Locale locale, File localeOutputDirectory, Locale defaultLocale,\n                                       String siteDescriptor )\n        throws RendererException, IOException, MavenReportException\n    {\n        List generatedReportsFileName = new ArrayList();\n\n        for ( Iterator j = reports.iterator(); j.hasNext(); )\n        {\n            MavenReport report = (MavenReport) j.next();\n\n            getLog().info( \"Generate \\\"\" + report.getName( locale ) + \"\\\" report.\" );\n\n            report.setReportOutputDirectory( localeOutputDirectory );\n\n            String reportFileName = report.getOutputName();\n\n            if ( locale.equals( defaultLocale ) )\n            {\n                generatedReportsFileName.add( reportFileName );\n            }\n            else\n            {\n                generatedReportsFileName.add( locale.getLanguage() + File.separator + reportFileName );\n            }\n\n            String outputFileName = reportFileName + \".html\";\n\n            SiteRendererSink sink = siteRenderer.createSink( new File( siteDirectory ), outputFileName,\n                                                             siteDescriptor );\n\n            report.generate( sink, locale );\n\n            if ( !report.isExternalReport() )\n            {\n                File outputFile = new File( localeOutputDirectory, outputFileName );\n\n                if ( !outputFile.getParentFile().exists() )\n                {\n                    outputFile.getParentFile().mkdirs();\n                }\n\n                siteRenderer.generateDocument(\n                    new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ), template, attributes,\n                    sink, locale );\n            }\n        }\n        return generatedReportsFileName;\n    }","commit_id":"95f8e446754336c8a0f7f4712e79da1781124b85","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void categorizeReports( List reports, Locale defaultLocale, List projectInfos, List projectReports )\n        throws MojoExecutionException\n    {\n        for ( Iterator i = reports.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n            if ( MavenReport.CATEGORY_PROJECT_INFORMATION.equals( report.getCategoryName() ) )\n            {\n                projectInfos.add( report );\n            }\n            else if ( MavenReport.CATEGORY_PROJECT_REPORTS.equals( report.getCategoryName() ) )\n            {\n                projectReports.add( report );\n            }\n            else\n            {\n                throw new MojoExecutionException( \"'\" + report.getCategoryName() + \"' category define for \" +\n                    report.getName( defaultLocale ) + \" mojo isn't valid.\" );\n            }\n        }\n    }","id":24917,"modified_method":"private Map categorizeReports( List reports )\n    {\n        Map categories = new HashMap();\n\n        for ( Iterator i = reports.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n\n            List category = (List) categories.get( report.getCategoryName() );\n            if ( category == null )\n            {\n                category = new ArrayList();\n                categories.put( report.getCategoryName(), category );\n            }\n            category.add( report );\n        }\n        return categories;\n    }","commit_id":"95f8e446754336c8a0f7f4712e79da1781124b85","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * @see org.apache.maven.plugin.Mojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( templateDirectory == null )\n        {\n            siteRenderer.setTemplateClassLoader( DoxiaMojo.class.getClassLoader() );\n        }\n        else\n        {\n            try\n            {\n                URL templateDirectoryUrl = new URL( templateDirectory );\n\n                URL[] urls = {templateDirectoryUrl};\n\n                URLClassLoader urlClassloader = new URLClassLoader( urls );\n\n                siteRenderer.setTemplateClassLoader( urlClassloader );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MojoExecutionException( templateDirectory + \" isn't a valid URL.\", e );\n            }\n        }\n\n        List reports = getReports();\n\n        if ( attributes == null )\n        {\n            attributes = new HashMap();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", outputEncoding );\n        }\n\n        try\n        {\n            List localesList = initLocalesList();\n            if ( localesList.isEmpty() )\n            {\n                localesList = Collections.singletonList( Locale.ENGLISH );\n            }\n\n            // Default is first in the list\n            Locale defaultLocale = (Locale) localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            List projectInfos = new ArrayList();\n            List projectReports = new ArrayList();\n            categorizeReports( reports, defaultLocale, projectInfos, projectReports );\n\n            for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n            {\n                Locale locale = (Locale) iterator.next();\n\n                String siteDescriptor = getSiteDescriptor( reports, locale, projectInfos, projectReports );\n\n                File outputDirectory = getOutputDirectory( locale, defaultLocale );\n\n                // Safety\n                if ( !outputDirectory.exists() )\n                {\n                    outputDirectory.mkdirs();\n                }\n\n                // Handle the GeneratedSite Directory\n                File generatedSiteFile = new File( generatedSiteDirectory );\n                if ( generatedSiteFile.exists() )\n                {\n                    siteRenderer.render( generatedSiteFile, outputDirectory, siteDescriptor, template, attributes,\n                                         locale );\n                }\n\n                // Generate static site\n                File siteDirectoryFile = new File( siteDirectory );\n                if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    siteDirectoryFile = new File( siteDirectory, locale.getLanguage() );\n                }\n\n                // Try to find duplicate files\n                Map duplicate = new LinkedHashMap();\n                if ( siteDirectoryFile.exists() )\n                {\n                    tryToFindDuplicates( siteDirectoryFile, duplicate );\n                }\n                if ( generatedSiteFile.exists() )\n                {\n                    tryToFindDuplicates( generatedSiteFile, duplicate );\n                }\n\n                // Exception if a file is duplicate\n                String msg = createDuplicateExceptionMsg( duplicate, locale );\n                if ( msg != null )\n                {\n                    throw new MavenReportException( msg );\n                }\n\n                //Generate reports\n                if ( reports != null )\n                {\n                    generateReportsPages( reports, locale, outputDirectory, defaultLocale, siteDescriptor );\n                }\n\n                //Generate overview pages\n                if ( projectInfos.size() > 0 )\n                {\n                    generateProjectInfoPage( siteDescriptor, locale, projectInfos, outputDirectory );\n                }\n\n                if ( projectReports.size() > 0 )\n                {\n                    generateProjectReportsPage( siteDescriptor, locale, projectReports, outputDirectory );\n                }\n\n                // Try to generate the index.html\n                String displayLanguage = locale.getDisplayLanguage( Locale.ENGLISH );\n                if ( duplicate.get( \"index\" ) != null )\n                {\n                    getLog().info( \"Ignoring the index file generation for the \" + displayLanguage + \" version.\" );\n                }\n                else\n                {\n                    getLog().info( \"Generate an index file for the \" + displayLanguage + \" version.\" );\n                    generateIndexPage( siteDescriptor, locale, outputDirectory );\n                }\n\n                // Log if a user override a report file\n                for ( Iterator it = generatedReportsFileName.iterator(); it.hasNext(); )\n                {\n                    String reportFileName = (String) it.next();\n\n                    if ( duplicate.get( reportFileName ) != null )\n                    {\n                        getLog().info( \"Override the generated file \\\"\" + reportFileName + \"\\\" for the \" +\n                            displayLanguage + \" version.\" );\n                    }\n                }\n\n                siteRenderer.render( siteDirectoryFile, outputDirectory, siteDescriptor, template, attributes, locale );\n\n                File cssDirectory = new File( siteDirectory, \"css\" );\n                File imagesDirectory = new File( siteDirectory, \"images\" );\n\n                // special case for backwards compatibility\n                if ( cssDirectory.exists() || imagesDirectory.exists() )\n                {\n                    getLog().warn( \"DEPRECATED: the css and images directories are deprecated, please use resources\" );\n\n                    copyDirectory( cssDirectory, new File( outputDirectory, \"css\" ) );\n\n                    copyDirectory( imagesDirectory, new File( outputDirectory, \"images\" ) );\n                }\n\n                copyResources( outputDirectory );\n\n                // Copy site resources\n                if ( resourcesDirectory != null && resourcesDirectory.exists() )\n                {\n                    copyDirectory( resourcesDirectory, outputDirectory );\n                }\n\n                // Copy the generated site in parent site if needed to provide module links\n                if ( addModules )\n                {\n                    MavenProject parentProject = project.getParent();\n                    if ( parentProject != null )\n                    {\n                        // TODO Handle user plugin configuration\n/* TODO: Not working, and would be better working as a top-level aggregation rather than pushing from the subprojects...\n                        File basedir = parentProject.getBasedir();\n                        if ( basedir != null )\n                        {\n                            String path = parentProject.getBuild().getDirectory() + \"/site/\" + project.getArtifactId();\n                            File parentSiteDir = new File( basedir, path );\n\n                            if ( !parentSiteDir.exists() )\n                            {\n                                parentSiteDir.mkdirs();\n                            }\n\n                            File siteDir = new File( outputDirectory );\n                            FileUtils.copyDirectoryStructure( siteDir, parentSiteDir );\n                        }\n                        else\n                        {\n                            getLog().info( \"Not using parent as it was not located on the filesystem\" );\n                        }\n*/\n                    }\n                }\n            }\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"Error during report generation\", e );\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"Error during page generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during site generation\", e );\n        }\n    }","id":24918,"modified_method":"/**\n     * @see org.apache.maven.plugin.Mojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( templateDirectory == null )\n        {\n            siteRenderer.setTemplateClassLoader( DoxiaMojo.class.getClassLoader() );\n        }\n        else\n        {\n            try\n            {\n                URL templateDirectoryUrl = new URL( templateDirectory );\n\n                URL[] urls = {templateDirectoryUrl};\n\n                URLClassLoader urlClassloader = new URLClassLoader( urls );\n\n                siteRenderer.setTemplateClassLoader( urlClassloader );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MojoExecutionException( templateDirectory + \" isn't a valid URL.\", e );\n            }\n        }\n\n        if ( attributes == null )\n        {\n            attributes = new HashMap();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", outputEncoding );\n        }\n\n        try\n        {\n            List localesList = initLocalesList();\n            if ( localesList.isEmpty() )\n            {\n                localesList = Collections.singletonList( Locale.ENGLISH );\n            }\n\n            // Default is first in the list\n            Locale defaultLocale = (Locale) localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n            {\n                Locale locale = (Locale) iterator.next();\n\n                File outputDirectory = getOutputDirectory( locale, defaultLocale );\n\n                // Safety\n                if ( !outputDirectory.exists() )\n                {\n                    outputDirectory.mkdirs();\n                }\n\n                // Generate static site\n                File siteDirectoryFile = new File( siteDirectory );\n                if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    siteDirectoryFile = new File( siteDirectory, locale.getLanguage() );\n                }\n\n                // Try to find duplicate files\n                Map duplicate = new LinkedHashMap();\n                if ( siteDirectoryFile.exists() )\n                {\n                    tryToFindDuplicates( siteDirectoryFile, duplicate );\n                }\n\n                // Handle the GeneratedSite Directory\n                File generatedSiteFile = new File( generatedSiteDirectory );\n\n                if ( generatedSiteFile.exists() )\n                {\n                    tryToFindDuplicates( generatedSiteFile, duplicate );\n                }\n\n                // Exception if a file is duplicate\n                String msg = createDuplicateExceptionMsg( duplicate, locale );\n                if ( msg != null )\n                {\n                    throw new MavenReportException( msg );\n                }\n\n                List reports = getReports();\n\n                Map categories = categorizeReports( reports );\n\n                List projectInfos = (List) categories.get( MavenReport.CATEGORY_PROJECT_INFORMATION );\n                List projectReports = (List) categories.get( MavenReport.CATEGORY_PROJECT_REPORTS );\n\n                if ( projectInfos == null )\n                {\n                    projectInfos = Collections.EMPTY_LIST;\n                }\n\n                if ( projectReports == null )\n                {\n                    projectReports = Collections.EMPTY_LIST;\n                }\n\n                String siteDescriptor = getSiteDescriptor( reports, locale, projectInfos, projectReports );\n\n                if ( generatedSiteFile.exists() )\n                {\n                    siteRenderer.render( generatedSiteFile, outputDirectory, siteDescriptor, template, attributes,\n                                         locale );\n                }\n\n                //Generate reports\n                List generatedReportsFileName = Collections.EMPTY_LIST;\n                if ( reports != null )\n                {\n                    generatedReportsFileName = generateReportsPages( reports, locale, outputDirectory, defaultLocale,\n                                                                     siteDescriptor );\n                }\n\n                //Generate overview pages\n                if ( projectInfos.size() > 0 )\n                {\n                    generateProjectInfoPage( siteDescriptor, locale, projectInfos, outputDirectory );\n                }\n\n                if ( projectReports.size() > 0 )\n                {\n                    generateProjectReportsPage( siteDescriptor, locale, projectReports, outputDirectory );\n                }\n\n                // Try to generate the index.html\n                String displayLanguage = locale.getDisplayLanguage( Locale.ENGLISH );\n                if ( duplicate.get( \"index\" ) != null )\n                {\n                    getLog().info( \"Ignoring the index file generation for the \" + displayLanguage + \" version.\" );\n                }\n                else\n                {\n                    getLog().info( \"Generate an index file for the \" + displayLanguage + \" version.\" );\n                    generateIndexPage( siteDescriptor, locale, outputDirectory );\n                }\n\n                // Log if a user override a report file\n                for ( Iterator it = generatedReportsFileName.iterator(); it.hasNext(); )\n                {\n                    String reportFileName = (String) it.next();\n\n                    if ( duplicate.get( reportFileName ) != null )\n                    {\n                        getLog().info( \"Override the generated file \\\"\" + reportFileName + \"\\\" for the \" +\n                            displayLanguage + \" version.\" );\n                    }\n                }\n\n                siteRenderer.render( siteDirectoryFile, outputDirectory, siteDescriptor, template, attributes, locale );\n\n                File cssDirectory = new File( siteDirectory, \"css\" );\n                File imagesDirectory = new File( siteDirectory, \"images\" );\n\n                // special case for backwards compatibility\n                if ( cssDirectory.exists() || imagesDirectory.exists() )\n                {\n                    getLog().warn( \"DEPRECATED: the css and images directories are deprecated, please use resources\" );\n\n                    copyDirectory( cssDirectory, new File( outputDirectory, \"css\" ) );\n\n                    copyDirectory( imagesDirectory, new File( outputDirectory, \"images\" ) );\n                }\n\n                copyResources( outputDirectory );\n\n                // Copy site resources\n                if ( resourcesDirectory != null && resourcesDirectory.exists() )\n                {\n                    copyDirectory( resourcesDirectory, outputDirectory );\n                }\n\n                // Copy the generated site in parent site if needed to provide module links\n                if ( addModules )\n                {\n                    MavenProject parentProject = project.getParent();\n                    if ( parentProject != null )\n                    {\n                        // TODO Handle user plugin configuration\n/* TODO: Not working, and would be better working as a top-level aggregation rather than pushing from the subprojects...\n                        File basedir = parentProject.getBasedir();\n                        if ( basedir != null )\n                        {\n                            String path = parentProject.getBuild().getDirectory() + \"/site/\" + project.getArtifactId();\n                            File parentSiteDir = new File( basedir, path );\n\n                            if ( !parentSiteDir.exists() )\n                            {\n                                parentSiteDir.mkdirs();\n                            }\n\n                            File siteDir = new File( outputDirectory );\n                            FileUtils.copyDirectoryStructure( siteDir, parentSiteDir );\n                        }\n                        else\n                        {\n                            getLog().info( \"Not using parent as it was not located on the filesystem\" );\n                        }\n*/\n                    }\n                }\n            }\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"Error during report generation\", e );\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"Error during page generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during site generation\", e );\n        }\n    }","commit_id":"95f8e446754336c8a0f7f4712e79da1781124b85","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void categorizeReports( List reports, Locale defaultLocale, List projectInfos, List projectReports )\n        throws MojoExecutionException\n    {\n        for ( Iterator i = reports.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n            if ( MavenReport.CATEGORY_PROJECT_INFORMATION.equals( report.getCategoryName() ) )\n            {\n                projectInfos.add( report );\n            }\n            else if ( MavenReport.CATEGORY_PROJECT_REPORTS.equals( report.getCategoryName() ) )\n            {\n                projectReports.add( report );\n            }\n            else\n            {\n                throw new MojoExecutionException( \"'\" + report.getCategoryName() + \"' category define for \" +\n                    report.getName( defaultLocale ) + \" mojo isn't valid.\" );\n            }\n        }\n    }","id":24919,"modified_method":"private Map categorizeReports( List reports )\n    {\n        Map categories = new HashMap();\n\n        for ( Iterator i = reports.iterator(); i.hasNext(); )\n        {\n            MavenReport report = (MavenReport) i.next();\n\n            List category = (List) categories.get( report.getCategoryName() );\n            if ( category == null )\n            {\n                category = new ArrayList();\n                categories.put( report.getCategoryName(), category );\n            }\n            category.add( report );\n        }\n        return categories;\n    }","commit_id":"156a22fefabfa46e54f645c273b5312052cba47e","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Generate reports pages\n     *\n     * @param reports\n     * @param locale\n     * @param localeOutputDirectory\n     */\n    private void generateReportsPages( List reports, Locale locale, File localeOutputDirectory, Locale defaultLocale,\n                                       String siteDescriptor )\n        throws RendererException, IOException, MavenReportException\n    {\n        for ( Iterator j = reports.iterator(); j.hasNext(); )\n        {\n            MavenReport report = (MavenReport) j.next();\n\n            getLog().info( \"Generate \\\"\" + report.getName( locale ) + \"\\\" report.\" );\n\n            report.setReportOutputDirectory( localeOutputDirectory );\n\n            String reportFileName = report.getOutputName();\n\n            if ( locale.equals( defaultLocale ) )\n            {\n                generatedReportsFileName.add( reportFileName );\n            }\n            else\n            {\n                generatedReportsFileName.add( locale.getLanguage() + File.separator + reportFileName );\n            }\n\n            String outputFileName = reportFileName + \".html\";\n\n            SiteRendererSink sink = siteRenderer.createSink( new File( siteDirectory ), outputFileName,\n                                                             siteDescriptor );\n\n            report.generate( sink, locale );\n\n            if ( !report.isExternalReport() )\n            {\n                File outputFile = new File( localeOutputDirectory, outputFileName );\n\n                if ( !outputFile.getParentFile().exists() )\n                {\n                    outputFile.getParentFile().mkdirs();\n                }\n\n                siteRenderer.generateDocument(\n                    new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ), template, attributes,\n                    sink, locale );\n            }\n        }\n    }","id":24920,"modified_method":"/**\n     * Generate reports pages\n     *\n     * @param reports\n     * @param locale\n     * @param localeOutputDirectory\n     */\n    private List generateReportsPages( List reports, Locale locale, File localeOutputDirectory, Locale defaultLocale,\n                                       String siteDescriptor )\n        throws RendererException, IOException, MavenReportException\n    {\n        List generatedReportsFileName = new ArrayList();\n\n        for ( Iterator j = reports.iterator(); j.hasNext(); )\n        {\n            MavenReport report = (MavenReport) j.next();\n\n            getLog().info( \"Generate \\\"\" + report.getName( locale ) + \"\\\" report.\" );\n\n            report.setReportOutputDirectory( localeOutputDirectory );\n\n            String reportFileName = report.getOutputName();\n\n            if ( locale.equals( defaultLocale ) )\n            {\n                generatedReportsFileName.add( reportFileName );\n            }\n            else\n            {\n                generatedReportsFileName.add( locale.getLanguage() + File.separator + reportFileName );\n            }\n\n            String outputFileName = reportFileName + \".html\";\n\n            SiteRendererSink sink = siteRenderer.createSink( new File( siteDirectory ), outputFileName,\n                                                             siteDescriptor );\n\n            report.generate( sink, locale );\n\n            if ( !report.isExternalReport() )\n            {\n                File outputFile = new File( localeOutputDirectory, outputFileName );\n\n                if ( !outputFile.getParentFile().exists() )\n                {\n                    outputFile.getParentFile().mkdirs();\n                }\n\n                siteRenderer.generateDocument(\n                    new OutputStreamWriter( new FileOutputStream( outputFile ), outputEncoding ), template, attributes,\n                    sink, locale );\n            }\n        }\n        return generatedReportsFileName;\n    }","commit_id":"156a22fefabfa46e54f645c273b5312052cba47e","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * @see org.apache.maven.plugin.Mojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( templateDirectory == null )\n        {\n            siteRenderer.setTemplateClassLoader( DoxiaMojo.class.getClassLoader() );\n        }\n        else\n        {\n            try\n            {\n                URL templateDirectoryUrl = new URL( templateDirectory );\n\n                URL[] urls = {templateDirectoryUrl};\n\n                URLClassLoader urlClassloader = new URLClassLoader( urls );\n\n                siteRenderer.setTemplateClassLoader( urlClassloader );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MojoExecutionException( templateDirectory + \" isn't a valid URL.\", e );\n            }\n        }\n\n        List reports = getReports();\n\n        if ( attributes == null )\n        {\n            attributes = new HashMap();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", outputEncoding );\n        }\n\n        try\n        {\n            List localesList = initLocalesList();\n            if ( localesList.isEmpty() )\n            {\n                localesList = Collections.singletonList( Locale.ENGLISH );\n            }\n\n            // Default is first in the list\n            Locale defaultLocale = (Locale) localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            List projectInfos = new ArrayList();\n            List projectReports = new ArrayList();\n            categorizeReports( reports, defaultLocale, projectInfos, projectReports );\n\n            for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n            {\n                Locale locale = (Locale) iterator.next();\n\n                String siteDescriptor = getSiteDescriptor( reports, locale, projectInfos, projectReports );\n\n                File outputDirectory = getOutputDirectory( locale, defaultLocale );\n\n                // Safety\n                if ( !outputDirectory.exists() )\n                {\n                    outputDirectory.mkdirs();\n                }\n\n                // Handle the GeneratedSite Directory\n                File generatedSiteFile = new File( generatedSiteDirectory );\n                if ( generatedSiteFile.exists() )\n                {\n                    siteRenderer.render( generatedSiteFile, outputDirectory, siteDescriptor, template, attributes,\n                                         locale );\n                }\n\n                // Generate static site\n                File siteDirectoryFile = new File( siteDirectory );\n                if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    siteDirectoryFile = new File( siteDirectory, locale.getLanguage() );\n                }\n\n                // Try to find duplicate files\n                Map duplicate = new LinkedHashMap();\n                if ( siteDirectoryFile.exists() )\n                {\n                    tryToFindDuplicates( siteDirectoryFile, duplicate );\n                }\n                if ( generatedSiteFile.exists() )\n                {\n                    tryToFindDuplicates( generatedSiteFile, duplicate );\n                }\n\n                // Exception if a file is duplicate\n                String msg = createDuplicateExceptionMsg( duplicate, locale );\n                if ( msg != null )\n                {\n                    throw new MavenReportException( msg );\n                }\n\n                //Generate reports\n                if ( reports != null )\n                {\n                    generateReportsPages( reports, locale, outputDirectory, defaultLocale, siteDescriptor );\n                }\n\n                //Generate overview pages\n                if ( projectInfos.size() > 0 )\n                {\n                    generateProjectInfoPage( siteDescriptor, locale, projectInfos, outputDirectory );\n                }\n\n                if ( projectReports.size() > 0 )\n                {\n                    generateProjectReportsPage( siteDescriptor, locale, projectReports, outputDirectory );\n                }\n\n                // Try to generate the index.html\n                String displayLanguage = locale.getDisplayLanguage( Locale.ENGLISH );\n                if ( duplicate.get( \"index\" ) != null )\n                {\n                    getLog().info( \"Ignoring the index file generation for the \" + displayLanguage + \" version.\" );\n                }\n                else\n                {\n                    getLog().info( \"Generate an index file for the \" + displayLanguage + \" version.\" );\n                    generateIndexPage( siteDescriptor, locale, outputDirectory );\n                }\n\n                // Log if a user override a report file\n                for ( Iterator it = generatedReportsFileName.iterator(); it.hasNext(); )\n                {\n                    String reportFileName = (String) it.next();\n\n                    if ( duplicate.get( reportFileName ) != null )\n                    {\n                        getLog().info( \"Override the generated file \\\"\" + reportFileName + \"\\\" for the \" +\n                            displayLanguage + \" version.\" );\n                    }\n                }\n\n                siteRenderer.render( siteDirectoryFile, outputDirectory, siteDescriptor, template, attributes, locale );\n\n                File cssDirectory = new File( siteDirectory, \"css\" );\n                File imagesDirectory = new File( siteDirectory, \"images\" );\n\n                // special case for backwards compatibility\n                if ( cssDirectory.exists() || imagesDirectory.exists() )\n                {\n                    getLog().warn( \"DEPRECATED: the css and images directories are deprecated, please use resources\" );\n\n                    copyDirectory( cssDirectory, new File( outputDirectory, \"css\" ) );\n\n                    copyDirectory( imagesDirectory, new File( outputDirectory, \"images\" ) );\n                }\n\n                copyResources( outputDirectory );\n\n                // Copy site resources\n                if ( resourcesDirectory != null && resourcesDirectory.exists() )\n                {\n                    copyDirectory( resourcesDirectory, outputDirectory );\n                }\n\n                // Copy the generated site in parent site if needed to provide module links\n                if ( addModules )\n                {\n                    MavenProject parentProject = project.getParent();\n                    if ( parentProject != null )\n                    {\n                        // TODO Handle user plugin configuration\n/* TODO: Not working, and would be better working as a top-level aggregation rather than pushing from the subprojects...\n                        File basedir = parentProject.getBasedir();\n                        if ( basedir != null )\n                        {\n                            String path = parentProject.getBuild().getDirectory() + \"/site/\" + project.getArtifactId();\n                            File parentSiteDir = new File( basedir, path );\n\n                            if ( !parentSiteDir.exists() )\n                            {\n                                parentSiteDir.mkdirs();\n                            }\n\n                            File siteDir = new File( outputDirectory );\n                            FileUtils.copyDirectoryStructure( siteDir, parentSiteDir );\n                        }\n                        else\n                        {\n                            getLog().info( \"Not using parent as it was not located on the filesystem\" );\n                        }\n*/\n                    }\n                }\n            }\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"Error during report generation\", e );\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"Error during page generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during site generation\", e );\n        }\n    }","id":24921,"modified_method":"/**\n     * @see org.apache.maven.plugin.Mojo#execute()\n     */\n    public void execute()\n        throws MojoExecutionException\n    {\n        if ( templateDirectory == null )\n        {\n            siteRenderer.setTemplateClassLoader( DoxiaMojo.class.getClassLoader() );\n        }\n        else\n        {\n            try\n            {\n                URL templateDirectoryUrl = new URL( templateDirectory );\n\n                URL[] urls = {templateDirectoryUrl};\n\n                URLClassLoader urlClassloader = new URLClassLoader( urls );\n\n                siteRenderer.setTemplateClassLoader( urlClassloader );\n            }\n            catch ( MalformedURLException e )\n            {\n                throw new MojoExecutionException( templateDirectory + \" isn't a valid URL.\", e );\n            }\n        }\n\n        if ( attributes == null )\n        {\n            attributes = new HashMap();\n        }\n\n        if ( attributes.get( \"project\" ) == null )\n        {\n            attributes.put( \"project\", project );\n        }\n\n        if ( attributes.get( \"outputEncoding\" ) == null )\n        {\n            attributes.put( \"outputEncoding\", outputEncoding );\n        }\n\n        try\n        {\n            List localesList = initLocalesList();\n            if ( localesList.isEmpty() )\n            {\n                localesList = Collections.singletonList( Locale.ENGLISH );\n            }\n\n            // Default is first in the list\n            Locale defaultLocale = (Locale) localesList.get( 0 );\n            Locale.setDefault( defaultLocale );\n\n            for ( Iterator iterator = localesList.iterator(); iterator.hasNext(); )\n            {\n                Locale locale = (Locale) iterator.next();\n\n                File outputDirectory = getOutputDirectory( locale, defaultLocale );\n\n                // Safety\n                if ( !outputDirectory.exists() )\n                {\n                    outputDirectory.mkdirs();\n                }\n\n                // Generate static site\n                File siteDirectoryFile = new File( siteDirectory );\n                if ( !locale.getLanguage().equals( defaultLocale.getLanguage() ) )\n                {\n                    siteDirectoryFile = new File( siteDirectory, locale.getLanguage() );\n                }\n\n                // Try to find duplicate files\n                Map duplicate = new LinkedHashMap();\n                if ( siteDirectoryFile.exists() )\n                {\n                    tryToFindDuplicates( siteDirectoryFile, duplicate );\n                }\n\n                // Handle the GeneratedSite Directory\n                File generatedSiteFile = new File( generatedSiteDirectory );\n\n                if ( generatedSiteFile.exists() )\n                {\n                    tryToFindDuplicates( generatedSiteFile, duplicate );\n                }\n\n                // Exception if a file is duplicate\n                String msg = createDuplicateExceptionMsg( duplicate, locale );\n                if ( msg != null )\n                {\n                    throw new MavenReportException( msg );\n                }\n\n                List reports = getReports();\n\n                Map categories = categorizeReports( reports );\n\n                List projectInfos = (List) categories.get( MavenReport.CATEGORY_PROJECT_INFORMATION );\n                List projectReports = (List) categories.get( MavenReport.CATEGORY_PROJECT_REPORTS );\n\n                if ( projectInfos == null )\n                {\n                    projectInfos = Collections.EMPTY_LIST;\n                }\n\n                if ( projectReports == null )\n                {\n                    projectReports = Collections.EMPTY_LIST;\n                }\n\n                String siteDescriptor = getSiteDescriptor( reports, locale, projectInfos, projectReports );\n\n                if ( generatedSiteFile.exists() )\n                {\n                    siteRenderer.render( generatedSiteFile, outputDirectory, siteDescriptor, template, attributes,\n                                         locale );\n                }\n\n                //Generate reports\n                List generatedReportsFileName = Collections.EMPTY_LIST;\n                if ( reports != null )\n                {\n                    generatedReportsFileName = generateReportsPages( reports, locale, outputDirectory, defaultLocale,\n                                                                     siteDescriptor );\n                }\n\n                //Generate overview pages\n                if ( projectInfos.size() > 0 )\n                {\n                    generateProjectInfoPage( siteDescriptor, locale, projectInfos, outputDirectory );\n                }\n\n                if ( projectReports.size() > 0 )\n                {\n                    generateProjectReportsPage( siteDescriptor, locale, projectReports, outputDirectory );\n                }\n\n                // Try to generate the index.html\n                String displayLanguage = locale.getDisplayLanguage( Locale.ENGLISH );\n                if ( duplicate.get( \"index\" ) != null )\n                {\n                    getLog().info( \"Ignoring the index file generation for the \" + displayLanguage + \" version.\" );\n                }\n                else\n                {\n                    getLog().info( \"Generate an index file for the \" + displayLanguage + \" version.\" );\n                    generateIndexPage( siteDescriptor, locale, outputDirectory );\n                }\n\n                // Log if a user override a report file\n                for ( Iterator it = generatedReportsFileName.iterator(); it.hasNext(); )\n                {\n                    String reportFileName = (String) it.next();\n\n                    if ( duplicate.get( reportFileName ) != null )\n                    {\n                        getLog().info( \"Override the generated file \\\"\" + reportFileName + \"\\\" for the \" +\n                            displayLanguage + \" version.\" );\n                    }\n                }\n\n                siteRenderer.render( siteDirectoryFile, outputDirectory, siteDescriptor, template, attributes, locale );\n\n                File cssDirectory = new File( siteDirectory, \"css\" );\n                File imagesDirectory = new File( siteDirectory, \"images\" );\n\n                // special case for backwards compatibility\n                if ( cssDirectory.exists() || imagesDirectory.exists() )\n                {\n                    getLog().warn( \"DEPRECATED: the css and images directories are deprecated, please use resources\" );\n\n                    copyDirectory( cssDirectory, new File( outputDirectory, \"css\" ) );\n\n                    copyDirectory( imagesDirectory, new File( outputDirectory, \"images\" ) );\n                }\n\n                copyResources( outputDirectory );\n\n                // Copy site resources\n                if ( resourcesDirectory != null && resourcesDirectory.exists() )\n                {\n                    copyDirectory( resourcesDirectory, outputDirectory );\n                }\n\n                // Copy the generated site in parent site if needed to provide module links\n                if ( addModules )\n                {\n                    MavenProject parentProject = project.getParent();\n                    if ( parentProject != null )\n                    {\n                        // TODO Handle user plugin configuration\n/* TODO: Not working, and would be better working as a top-level aggregation rather than pushing from the subprojects...\n                        File basedir = parentProject.getBasedir();\n                        if ( basedir != null )\n                        {\n                            String path = parentProject.getBuild().getDirectory() + \"/site/\" + project.getArtifactId();\n                            File parentSiteDir = new File( basedir, path );\n\n                            if ( !parentSiteDir.exists() )\n                            {\n                                parentSiteDir.mkdirs();\n                            }\n\n                            File siteDir = new File( outputDirectory );\n                            FileUtils.copyDirectoryStructure( siteDir, parentSiteDir );\n                        }\n                        else\n                        {\n                            getLog().info( \"Not using parent as it was not located on the filesystem\" );\n                        }\n*/\n                    }\n                }\n            }\n        }\n        catch ( MavenReportException e )\n        {\n            throw new MojoExecutionException( \"Error during report generation\", e );\n        }\n        catch ( RendererException e )\n        {\n            throw new MojoExecutionException( \"Error during page generation\", e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error during site generation\", e );\n        }\n    }","commit_id":"156a22fefabfa46e54f645c273b5312052cba47e","url":"https://github.com/apache/maven"},{"original_method":"public void renderHead(IHeaderResponse response) {\n\t\tsuper.renderHead(response);\n\n\t\tString version = ServerConfigurationService.getString(\"portal.cdn.version\", \"\");\n\n\t\t//Drag and Drop/Date Picker (requires jQueryUI)\n\t\tresponse.render(JavaScriptHeaderItem.forUrl(String.format(\"/library/js/jquery/ui/1.11.3/jquery-ui.min.js?version=%s\", version)));\n\n\t\t//Include Sakai Date Picker\n\t\tresponse.render(JavaScriptHeaderItem.forUrl(String.format(\"/library/js/lang-datepicker/lang-datepicker.js?version=%s\", version)));\n\n\t\t//GradebookNG Grade specific styles and behaviour\n\t\tresponse.render(CssHeaderItem.forUrl(String.format(\"/gradebookng-tool/styles/gradebook-grades.css?version=%s\", version)));\n\t\tresponse.render(JavaScriptHeaderItem.forUrl(String.format(\"/gradebookng-tool/scripts/gradebook-grades.js?version=%s\", version)));\n\t\tresponse.render(JavaScriptHeaderItem.forUrl(String.format(\"/gradebookng-tool/scripts/gradebook-grade-summary.js?version=%s\", version)));\n\t\tresponse.render(JavaScriptHeaderItem.forUrl(String.format(\"/gradebookng-tool/scripts/gradebook-update-ungraded.js?version=%s\", version)));\n\t}","id":24922,"modified_method":"@Override\n\tpublic void renderHead(final IHeaderResponse response) {\n\t\tsuper.renderHead(response);\n\n\t\tfinal String version = ServerConfigurationService.getString(\"portal.cdn.version\", \"\");\n\n\t\t// Drag and Drop/Date Picker (requires jQueryUI)\n\t\tresponse.render(JavaScriptHeaderItem.forUrl(String.format(\"/library/js/jquery/ui/1.11.3/jquery-ui.min.js?version=%s\", version)));\n\n\t\t// Include Sakai Date Picker\n\t\tresponse.render(JavaScriptHeaderItem.forUrl(String.format(\"/library/js/lang-datepicker/lang-datepicker.js?version=%s\", version)));\n\n\t\t// GradebookNG Grade specific styles and behaviour\n\t\tresponse.render(CssHeaderItem.forUrl(String.format(\"/gradebookng-tool/styles/gradebook-grades.css?version=%s\", version)));\n\t\tresponse.render(JavaScriptHeaderItem.forUrl(String.format(\"/gradebookng-tool/scripts/gradebook-grades.js?version=%s\", version)));\n\t\tresponse.render(\n\t\t\t\tJavaScriptHeaderItem.forUrl(String.format(\"/gradebookng-tool/scripts/gradebook-grade-summary.js?version=%s\", version)));\n\t\tresponse.render(\n\t\t\t\tJavaScriptHeaderItem.forUrl(String.format(\"/gradebookng-tool/scripts/gradebook-update-ungraded.js?version=%s\", version)));\n\t}","commit_id":"d4428407080ee37007d17a2e0b1feaa435ca66c2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\", \"serial\" })\n\tpublic GradebookPage() {\n\t\tdisableLink(this.gradebookPageLink);\n\n\t\t// students cannot access this page\n\t\tif (this.role == GbRole.STUDENT) {\n\t\t\tthrow new RestartResponseException(StudentPage.class);\n\t\t}\n\n\t\tfinal StopWatch stopwatch = new StopWatch();\n\t\tstopwatch.start();\n\t\tTemp.time(\"GradebookPage init\", stopwatch.getTime());\n\n\t\tthis.form = new Form<Void>(\"form\");\n\t\tadd(this.form);\n\n\t\t/**\n\t\t * Note that SEMI_TRANSPARENT has a 100% black background and TRANSPARENT is overridden to 10% opacity\n\t\t */\n\t\tthis.addOrEditGradeItemWindow = new ModalWindow(\"addOrEditGradeItemWindow\");\n\t\tthis.addOrEditGradeItemWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.addOrEditGradeItemWindow.setResizable(false);\n\t\tthis.addOrEditGradeItemWindow.setUseInitialHeight(false);\n\t\tthis.addOrEditGradeItemWindow.showUnloadConfirmation(false);\n\t\tthis.addOrEditGradeItemWindow.setCloseButtonCallback(new ModalWindow.CloseButtonCallback() {\n\t\t\t@Override\n\t\t\tpublic boolean onCloseButtonClicked(AjaxRequestTarget target) {\n\t\t\t\t//Ensure the date picker is hidden\n\t\t\t\ttarget.appendJavaScript(\"$('#ui-datepicker-div').hide();\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tthis.form.add(this.addOrEditGradeItemWindow);\n\n\t\tthis.studentGradeSummaryWindow = new ModalWindow(\"studentGradeSummaryWindow\");\n\t\tthis.studentGradeSummaryWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.studentGradeSummaryWindow.setResizable(false);\n\t\tthis.studentGradeSummaryWindow.setUseInitialHeight(false);\n\t\tthis.studentGradeSummaryWindow.setWidthUnit(\"%\");\n\t\tthis.studentGradeSummaryWindow.setInitialWidth(70);\n\t\tthis.studentGradeSummaryWindow.setCloseButtonCallback(new ModalWindow.CloseButtonCallback() {\n\t\t\t@Override\n\t\t\tpublic boolean onCloseButtonClicked(final AjaxRequestTarget target) {\n\t\t\t\ttarget.appendJavaScript(\"GradebookGradeSummaryUtils.clearBlur();\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tthis.form.add(this.studentGradeSummaryWindow);\n\n\t\tthis.updateUngradedItemsWindow = new ModalWindow(\"updateUngradedItemsWindow\");\n\t\tthis.updateUngradedItemsWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.updateUngradedItemsWindow.setResizable(false);\n\t\tthis.updateUngradedItemsWindow.setUseInitialHeight(true);\n\t\tthis.form.add(this.updateUngradedItemsWindow);\n\n\t\tthis.gradeLogWindow = new ModalWindow(\"gradeLogWindow\");\n\t\tthis.gradeLogWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.gradeLogWindow.setResizable(false);\n\t\tthis.gradeLogWindow.setUseInitialHeight(false);\n\t\tthis.form.add(this.gradeLogWindow);\n\n\t\tthis.gradeCommentWindow = new ModalWindow(\"gradeCommentWindow\");\n\t\tthis.gradeCommentWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.gradeCommentWindow.setResizable(false);\n\t\tthis.gradeCommentWindow.setUseInitialHeight(false);\n\t\tthis.form.add(this.gradeCommentWindow);\n\n\t\tthis.deleteItemWindow = new ModalWindow(\"deleteItemWindow\");\n\t\tthis.deleteItemWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.deleteItemWindow.setResizable(false);\n\t\tthis.deleteItemWindow.setUseInitialHeight(false);\n\t\tthis.form.add(this.deleteItemWindow);\n\n\t\tfinal AjaxButton addGradeItem = new AjaxButton(\"addGradeItem\") {\n\t\t\t@Override\n\t\t\tpublic void onSubmit(final AjaxRequestTarget target, final Form form) {\n\t\t\t\tfinal ModalWindow window = getAddOrEditGradeItemWindow();\n\t\t\t\twindow.setContent(new AddOrEditGradeItemPanel(window.getContentId(), window, null));\n\t\t\t\twindow.show(target);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\tif (GradebookPage.this.role != GbRole.INSTRUCTOR) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t};\n\t\taddGradeItem.setDefaultFormProcessing(false);\n\t\tthis.form.add(addGradeItem);\n\n\t\t// first get any settings data from the session\n\t\tfinal GradebookUiSettings settings = getUiSettings();\n\n\t\t// get list of assignments. this allows us to build the columns and then fetch the grades for each student for each assignment from\n\t\t// the map\n\t\tfinal List<Assignment> assignments = this.businessService.getGradebookAssignments();\n\t\tTemp.time(\"getGradebookAssignments\", stopwatch.getTime());\n\n\t\t// get the grade matrix. It should be sorted if we have that info\n\t\tfinal List<GbStudentGradeInfo> grades = this.businessService.buildGradeMatrix(assignments, settings.getAssignmentSortOrder(),\n\t\t\t\tsettings.getNameSortOrder(), settings.getGroupFilter());\n\n\t\tTemp.time(\"buildGradeMatrix\", stopwatch.getTime());\n\n\t\t// get assignment order\n\t\tfinal Map<String, List<Long>> categorizedAssignmentOrder = this.businessService.getCategorizedAssignmentsOrder();\n\n\t\t// get course grade visibility\n\t\tfinal boolean courseGradeVisible = this.businessService.isCourseGradeVisible(this.currentUserUuid);\n\n\t\t// categories enabled?\n\t\tfinal boolean categoriesEnabled = this.businessService.categoriesAreEnabled();\n\n\t\t// this could potentially be a sortable data provider\n\t\tfinal ListDataProvider<GbStudentGradeInfo> studentGradeMatrix = new ListDataProvider<GbStudentGradeInfo>(grades);\n\t\tfinal List<IColumn> cols = new ArrayList<IColumn>();\n\n\t\t// add an empty column that we can use as a handle for selecting the row\n\t\tfinal AbstractColumn handleColumn = new AbstractColumn(new Model(\"\")) {\n\n\t\t\t@Override\n\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\tcellItem.add(new EmptyPanel(componentId));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getCssClass() {\n\t\t\t\treturn \"gb-row-selector\";\n\t\t\t}\n\t\t};\n\t\tcols.add(handleColumn);\n\n\t\t// student name column\n\t\tfinal AbstractColumn studentNameColumn = new AbstractColumn(new Model(\"\")) {\n\n\t\t\t@Override\n\t\t\tpublic Component getHeader(final String componentId) {\n\t\t\t\treturn new StudentNameColumnHeaderPanel(componentId, Model.of(settings.getNameSortOrder())); // pass in the sort\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\tfinal GbStudentGradeInfo studentGradeInfo = (GbStudentGradeInfo) rowModel.getObject();\n\n\t\t\t\tfinal Map<String, Object> modelData = new HashMap<>();\n\t\t\t\tmodelData.put(\"userId\", studentGradeInfo.getStudentUuid());\n\t\t\t\tmodelData.put(\"eid\", studentGradeInfo.getStudentEid());\n\t\t\t\tmodelData.put(\"firstName\", studentGradeInfo.getStudentFirstName());\n\t\t\t\tmodelData.put(\"lastName\", studentGradeInfo.getStudentLastName());\n\t\t\t\tmodelData.put(\"displayName\", studentGradeInfo.getStudentDisplayName());\n\t\t\t\tmodelData.put(\"nameSortOrder\", settings.getNameSortOrder()); // pass in the sort\n\n\t\t\t\tcellItem.add(new StudentNameCellPanel(componentId, Model.ofMap(modelData)));\n\t\t\t\tcellItem.add(new AttributeModifier(\"data-studentUuid\", studentGradeInfo.getStudentUuid()));\n\n\t\t\t\t// TODO may need a subclass of Item that does the onComponentTag override and then tag.setName(\"th\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getCssClass() {\n\t\t\t\treturn \"gb-student-cell\";\n\t\t\t}\n\n\t\t};\n\t\tcols.add(studentNameColumn);\n\n\t\t// course grade column\n\t\tfinal AbstractColumn courseGradeColumn = new AbstractColumn(new Model(\"\")) {\n\t\t\t@Override\n\t\t\tpublic Component getHeader(final String componentId) {\n\t\t\t\tfinal CourseGradeColumnHeaderPanel panel = new CourseGradeColumnHeaderPanel(componentId);\n\t\t\t\treturn panel;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getCssClass() {\n\t\t\t\treturn \"gb-course-grade\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\tfinal GbStudentGradeInfo studentGradeInfo = (GbStudentGradeInfo) rowModel.getObject();\n\n\t\t\t\tString courseGrade;\n\n\t\t\t\tif (courseGradeVisible) {\n\t\t\t\t\tcourseGrade = studentGradeInfo.getCourseGrade();\n\t\t\t\t} else {\n\t\t\t\t\tcourseGrade = getString(\"label.coursegrade.nopermission\");\n\t\t\t\t}\n\n\t\t\t\tfinal Label courseGradeLabel = new Label(componentId, Model.of(courseGrade)) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onEvent(final IEvent<?> event) {\n\t\t\t\t\t\tsuper.onEvent(event);\n\t\t\t\t\t\tif (event.getPayload() instanceof ScoreChangedEvent) {\n\t\t\t\t\t\t\tfinal ScoreChangedEvent scoreChangedEvent = (ScoreChangedEvent) event.getPayload();\n\t\t\t\t\t\t\tif (studentGradeInfo.getStudentUuid().equals(scoreChangedEvent.getStudentUuid())) {\n\t\t\t\t\t\t\t\tfinal CourseGrade courseGrade = GradebookPage.this.businessService\n\t\t\t\t\t\t\t\t\t\t.getCourseGrade(scoreChangedEvent.getStudentUuid());\n\t\t\t\t\t\t\t\t((Model<String>) getDefaultModel()).setObject(courseGrade.getMappedGrade());\n\t\t\t\t\t\t\t\tscoreChangedEvent.getTarget().add(this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcourseGradeLabel.setOutputMarkupId(true);\n\t\t\t\tcellItem.add(courseGradeLabel);\n\t\t\t}\n\t\t};\n\t\tcols.add(courseGradeColumn);\n\n\t\t// build the rest of the columns based on the assignment list\n\t\tfor (final Assignment assignment : assignments) {\n\n\t\t\tfinal AbstractColumn column = new AbstractColumn(new Model(\"\")) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Component getHeader(final String componentId) {\n\t\t\t\t\tfinal AssignmentColumnHeaderPanel panel = new AssignmentColumnHeaderPanel(componentId,\n\t\t\t\t\t\t\tnew Model<Assignment>(assignment));\n\n\t\t\t\t\tfinal String category = assignment.getCategoryName();\n\n\t\t\t\t\tint order = -1;\n\t\t\t\t\tif (categorizedAssignmentOrder.containsKey(category)) {\n\t\t\t\t\t\torder = categorizedAssignmentOrder.get(category).indexOf(assignment.getId());\n\t\t\t\t\t}\n\n\t\t\t\t\tpanel.add(new AttributeModifier(\"data-category\", category));\n\t\t\t\t\tpanel.add(new AttributeModifier(\"data-categorized-order\", order));\n\n\t\t\t\t\tfinal StringValue createdAssignmentId = getPageParameters().get(CREATED_ASSIGNMENT_ID_PARAM);\n\t\t\t\t\tif (!createdAssignmentId.isNull() && assignment.getId().equals(createdAssignmentId.toLong())) {\n\t\t\t\t\t\tpanel.add(new AttributeModifier(\"class\", \"gb-just-created\"));\n\t\t\t\t\t\tgetPageParameters().remove(CREATED_ASSIGNMENT_ID_PARAM);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn panel;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getCssClass() {\n\t\t\t\t\treturn \"gb-grade-item-column-cell\";\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\t\tfinal GbStudentGradeInfo studentGrades = (GbStudentGradeInfo) rowModel.getObject();\n\n\t\t\t\t\tfinal GbGradeInfo gradeInfo = studentGrades.getGrades().get(assignment.getId());\n\n\t\t\t\t\tfinal Map<String, Object> modelData = new HashMap<>();\n\t\t\t\t\tmodelData.put(\"assignmentId\", assignment.getId());\n\t\t\t\t\tmodelData.put(\"assignmentPoints\", assignment.getPoints());\n\t\t\t\t\tmodelData.put(\"studentUuid\", studentGrades.getStudentUuid());\n\t\t\t\t\tmodelData.put(\"categoryId\", assignment.getCategoryId());\n\t\t\t\t\tmodelData.put(\"isExternal\", assignment.isExternallyMaintained());\n\t\t\t\t\tmodelData.put(\"gradeInfo\", gradeInfo);\n\t\t\t\t\tmodelData.put(\"role\", GradebookPage.this.role);\n\n\t\t\t\t\tcellItem.add(new GradeItemCellPanel(componentId, Model.ofMap(modelData)));\n\n\t\t\t\t\tcellItem.setOutputMarkupId(true);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcols.add(column);\n\t\t}\n\n\t\t// render the categories\n\t\t// Display rules:\n\t\t// 1. only show categories if the global setting is enabled\n\t\t// 2. only show categories if they have items\n\t\t// TODO may be able to pass this list into the matrix to save another lookup in there)\n\n\t\tList<CategoryDefinition> categories = new ArrayList<>();\n\n\t\tif (categoriesEnabled) {\n\n\t\t\t// only work with categories if enabled\n\t\t\tcategories = this.businessService.getGradebookCategories();\n\n\t\t\t// remove those that have no assignments\n\t\t\tcategories.removeIf(cat -> cat.getAssignmentList().isEmpty());\n\n\t\t\tfor (final CategoryDefinition category : categories) {\n\n\t\t\t\tif (category.getAssignmentList().isEmpty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfinal AbstractColumn column = new AbstractColumn(new Model(\"\")) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Component getHeader(final String componentId) {\n\t\t\t\t\t\tfinal CategoryColumnHeaderPanel panel = new CategoryColumnHeaderPanel(componentId,\n\t\t\t\t\t\t\t\tnew Model<CategoryDefinition>(category));\n\n\t\t\t\t\t\tpanel.add(new AttributeModifier(\"data-category\", category.getName()));\n\n\t\t\t\t\t\treturn panel;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\t\t\tfinal GbStudentGradeInfo studentGrades = (GbStudentGradeInfo) rowModel.getObject();\n\n\t\t\t\t\t\tfinal Double score = studentGrades.getCategoryAverages().get(category.getId());\n\n\t\t\t\t\t\tfinal Map<String, Object> modelData = new HashMap<>();\n\t\t\t\t\t\tmodelData.put(\"score\", score);\n\t\t\t\t\t\tmodelData.put(\"studentUuid\", studentGrades.getStudentUuid());\n\t\t\t\t\t\tmodelData.put(\"categoryId\", category.getId());\n\n\t\t\t\t\t\tcellItem.add(new CategoryColumnCellPanel(componentId, Model.ofMap(modelData)));\n\t\t\t\t\t\tcellItem.setOutputMarkupId(true);\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getCssClass() {\n\t\t\t\t\t\treturn \"gb-category-item-column-cell\";\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tcols.add(column);\n\t\t\t}\n\t\t}\n\n\t\tTemp.time(\"all Columns added\", stopwatch.getTime());\n\n\t\t// TODO make this AjaxFallbackDefaultDataTable\n\t\tfinal DataTable table = new DataTable(\"table\", cols, studentGradeMatrix, 100);\n\t\ttable.addBottomToolbar(new NavigationToolbar(table));\n\t\ttable.addTopToolbar(new HeadersToolbar(table, null));\n\t\ttable.add(new AttributeModifier(\"data-siteid\", this.businessService.getCurrentSiteId()));\n\n\t\tfinal WebMarkupContainer noAssignments = new WebMarkupContainer(\"noAssignments\");\n\t\tnoAssignments.setVisible(false);\n\t\tthis.form.add(noAssignments);\n\n\t\tfinal WebMarkupContainer noStudents = new WebMarkupContainer(\"noStudents\");\n\t\tnoStudents.setVisible(false);\n\t\tthis.form.add(noStudents);\n\n\t\tthis.form.add(table);\n\n\t\t// Populate the toolbar\n\t\tfinal Label gradeItemSummary = new Label(\"gradeItemSummary\", new StringResourceModel(\"label.toolbar.gradeitemsummary\", null,\n\t\t\t\tassignments.size() + categories.size(), assignments.size() + categories.size()));\n\t\tgradeItemSummary.setEscapeModelStrings(false);\n\t\tthis.form.add(gradeItemSummary);\n\n\t\tfinal WebMarkupContainer toggleGradeItemsToolbarItem = new WebMarkupContainer(\"toggleGradeItemsToolbarItem\");\n\t\tthis.form.add(toggleGradeItemsToolbarItem);\n\n\t\tfinal AjaxButton toggleCategoriesToolbarItem = new AjaxButton(\"toggleCategoriesToolbarItem\") {\n\t\t\t@Override\n\t\t\tprotected void onInitialize() {\n\t\t\t\tsuper.onInitialize();\n\t\t\t\tif (settings.isCategoriesEnabled()) {\n\t\t\t\t\tadd(new AttributeModifier(\"class\", \"on\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onSubmit(final AjaxRequestTarget target, final Form<?> form) {\n\t\t\t\tsettings.setCategoriesEnabled(!settings.isCategoriesEnabled());\n\t\t\t\tsetUiSettings(settings);\n\n\t\t\t\tif (settings.isCategoriesEnabled()) {\n\t\t\t\t\tadd(new AttributeModifier(\"class\", \"on\"));\n\t\t\t\t} else {\n\t\t\t\t\tadd(new AttributeModifier(\"class\", \"\"));\n\t\t\t\t}\n\t\t\t\ttarget.add(this);\n\t\t\t\ttarget.appendJavaScript(\"sakai.gradebookng.spreadsheet.toggleCategories();\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\treturn categoriesEnabled && !assignments.isEmpty();\n\t\t\t}\n\t\t};\n\t\tthis.form.add(toggleCategoriesToolbarItem);\n\n\t\t// section and group dropdown\n\t\tfinal List<GbGroup> groups = this.businessService.getSiteSectionsAndGroups();\n\n\t\t// add the default ALL group to the list\n\t\tgroups.add(0, new GbGroup(null, getString(\"groups.all\"), null, GbGroup.Type.ALL));\n\n\t\tfinal DropDownChoice<GbGroup> groupFilter = new DropDownChoice<GbGroup>(\"groupFilter\", new Model<GbGroup>(), groups,\n\t\t\t\tnew ChoiceRenderer<GbGroup>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object getDisplayValue(final GbGroup g) {\n\t\t\t\t\t\treturn g.getTitle();\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getIdValue(final GbGroup g, final int index) {\n\t\t\t\t\t\treturn g.getId();\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\tgroupFilter.add(new AjaxFormComponentUpdatingBehavior(\"onchange\") {\n\n\t\t\t@Override\n\t\t\tprotected void onUpdate(final AjaxRequestTarget target) {\n\n\t\t\t\tfinal GbGroup selected = (GbGroup) groupFilter.getDefaultModelObject();\n\n\t\t\t\t// store selected group (null ok)\n\t\t\t\tfinal GradebookUiSettings settings = getUiSettings();\n\t\t\t\tsettings.setGroupFilter(selected);\n\t\t\t\tsetUiSettings(settings);\n\n\t\t\t\t// refresh\n\t\t\t\tsetResponsePage(new GradebookPage());\n\t\t\t}\n\n\t\t});\n\n\t\t// set selected group, or first item in list\n\t\tgroupFilter.setModelObject((settings.getGroupFilter() != null) ? settings.getGroupFilter() : groups.get(0));\n\t\tgroupFilter.setNullValid(false);\n\t\tthis.form.add(groupFilter);\n\n\t\tfinal ToggleGradeItemsToolbarPanel gradeItemsTogglePanel = new ToggleGradeItemsToolbarPanel(\"gradeItemsTogglePanel\",\n\t\t\t\tModel.ofList(assignments));\n\t\tadd(gradeItemsTogglePanel);\n\n\t\t// hide/show components\n\n\t\t// no assignments, hide table, show message\n\t\tif (assignments.isEmpty()) {\n\t\t\ttable.setVisible(false);\n\t\t\ttoggleGradeItemsToolbarItem.setVisible(false);\n\t\t\tnoAssignments.setVisible(true);\n\t\t}\n\n\t\t// no visible students, show table, show message\n\t\t// don't want two messages though, hence the else\n\t\telse if (studentGradeMatrix.size() == 0) {\n\t\t\tnoStudents.setVisible(true);\n\t\t}\n\n\t\tTemp.time(\"Gradebook page done\", stopwatch.getTime());\n\t}","id":24923,"modified_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\", \"serial\" })\n\tpublic GradebookPage() {\n\t\tdisableLink(this.gradebookPageLink);\n\n\t\t// students cannot access this page\n\t\tif (this.role == GbRole.STUDENT) {\n\t\t\tthrow new RestartResponseException(StudentPage.class);\n\t\t}\n\n\t\tfinal StopWatch stopwatch = new StopWatch();\n\t\tstopwatch.start();\n\t\tTemp.time(\"GradebookPage init\", stopwatch.getTime());\n\n\t\tthis.form = new Form<Void>(\"form\");\n\t\tadd(this.form);\n\n\t\t/**\n\t\t * Note that SEMI_TRANSPARENT has a 100% black background and TRANSPARENT is overridden to 10% opacity\n\t\t */\n\t\tthis.addOrEditGradeItemWindow = new ModalWindow(\"addOrEditGradeItemWindow\");\n\t\tthis.addOrEditGradeItemWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.addOrEditGradeItemWindow.setResizable(false);\n\t\tthis.addOrEditGradeItemWindow.setUseInitialHeight(false);\n\t\tthis.addOrEditGradeItemWindow.showUnloadConfirmation(false);\n\t\tthis.addOrEditGradeItemWindow.setCloseButtonCallback(new ModalWindow.CloseButtonCallback() {\n\t\t\t@Override\n\t\t\tpublic boolean onCloseButtonClicked(final AjaxRequestTarget target) {\n\t\t\t\t// Ensure the date picker is hidden\n\t\t\t\ttarget.appendJavaScript(\"$('#ui-datepicker-div').hide();\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tthis.form.add(this.addOrEditGradeItemWindow);\n\n\t\tthis.studentGradeSummaryWindow = new ModalWindow(\"studentGradeSummaryWindow\");\n\t\tthis.studentGradeSummaryWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.studentGradeSummaryWindow.setResizable(false);\n\t\tthis.studentGradeSummaryWindow.setUseInitialHeight(false);\n\t\tthis.studentGradeSummaryWindow.setWidthUnit(\"%\");\n\t\tthis.studentGradeSummaryWindow.setInitialWidth(70);\n\t\tthis.studentGradeSummaryWindow.setCloseButtonCallback(new ModalWindow.CloseButtonCallback() {\n\t\t\t@Override\n\t\t\tpublic boolean onCloseButtonClicked(final AjaxRequestTarget target) {\n\t\t\t\ttarget.appendJavaScript(\"GradebookGradeSummaryUtils.clearBlur();\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tthis.form.add(this.studentGradeSummaryWindow);\n\n\t\tthis.updateUngradedItemsWindow = new ModalWindow(\"updateUngradedItemsWindow\");\n\t\tthis.updateUngradedItemsWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.updateUngradedItemsWindow.setResizable(false);\n\t\tthis.updateUngradedItemsWindow.setUseInitialHeight(true);\n\t\tthis.form.add(this.updateUngradedItemsWindow);\n\n\t\tthis.gradeLogWindow = new ModalWindow(\"gradeLogWindow\");\n\t\tthis.gradeLogWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.gradeLogWindow.setResizable(false);\n\t\tthis.gradeLogWindow.setUseInitialHeight(false);\n\t\tthis.form.add(this.gradeLogWindow);\n\n\t\tthis.gradeCommentWindow = new ModalWindow(\"gradeCommentWindow\");\n\t\tthis.gradeCommentWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.gradeCommentWindow.setResizable(false);\n\t\tthis.gradeCommentWindow.setUseInitialHeight(false);\n\t\tthis.form.add(this.gradeCommentWindow);\n\n\t\tthis.deleteItemWindow = new ModalWindow(\"deleteItemWindow\");\n\t\tthis.deleteItemWindow.setMaskType(MaskType.TRANSPARENT);\n\t\tthis.deleteItemWindow.setResizable(false);\n\t\tthis.deleteItemWindow.setUseInitialHeight(false);\n\t\tthis.form.add(this.deleteItemWindow);\n\n\t\tfinal AjaxButton addGradeItem = new AjaxButton(\"addGradeItem\") {\n\t\t\t@Override\n\t\t\tpublic void onSubmit(final AjaxRequestTarget target, final Form form) {\n\t\t\t\tfinal ModalWindow window = getAddOrEditGradeItemWindow();\n\t\t\t\twindow.setContent(new AddOrEditGradeItemPanel(window.getContentId(), window, null));\n\t\t\t\twindow.show(target);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\tif (GradebookPage.this.role != GbRole.INSTRUCTOR) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t};\n\t\taddGradeItem.setDefaultFormProcessing(false);\n\t\tthis.form.add(addGradeItem);\n\n\t\t// first get any settings data from the session\n\t\tfinal GradebookUiSettings settings = getUiSettings();\n\n\t\t// get list of assignments. this allows us to build the columns and then fetch the grades for each student for each assignment from\n\t\t// the map\n\t\tfinal List<Assignment> assignments = this.businessService.getGradebookAssignments();\n\t\tTemp.time(\"getGradebookAssignments\", stopwatch.getTime());\n\n\t\t// get the grade matrix. It should be sorted if we have that info\n\t\tfinal List<GbStudentGradeInfo> grades = this.businessService.buildGradeMatrix(assignments, settings.getAssignmentSortOrder(),\n\t\t\t\tsettings.getNameSortOrder(), settings.getGroupFilter());\n\n\t\tTemp.time(\"buildGradeMatrix\", stopwatch.getTime());\n\n\t\t// get assignment order\n\t\tfinal Map<String, List<Long>> categorizedAssignmentOrder = this.businessService.getCategorizedAssignmentsOrder();\n\n\t\t// get course grade visibility\n\t\tfinal boolean courseGradeVisible = this.businessService.isCourseGradeVisible(this.currentUserUuid);\n\n\t\t// categories enabled?\n\t\tfinal boolean categoriesEnabled = this.businessService.categoriesAreEnabled();\n\n\t\t// this could potentially be a sortable data provider\n\t\tfinal ListDataProvider<GbStudentGradeInfo> studentGradeMatrix = new ListDataProvider<GbStudentGradeInfo>(grades);\n\t\tfinal List<IColumn> cols = new ArrayList<IColumn>();\n\n\t\t// add an empty column that we can use as a handle for selecting the row\n\t\tfinal AbstractColumn handleColumn = new AbstractColumn(new Model(\"\")) {\n\n\t\t\t@Override\n\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\tcellItem.add(new EmptyPanel(componentId));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getCssClass() {\n\t\t\t\treturn \"gb-row-selector\";\n\t\t\t}\n\t\t};\n\t\tcols.add(handleColumn);\n\n\t\t// student name column\n\t\tfinal AbstractColumn studentNameColumn = new AbstractColumn(new Model(\"\")) {\n\n\t\t\t@Override\n\t\t\tpublic Component getHeader(final String componentId) {\n\t\t\t\treturn new StudentNameColumnHeaderPanel(componentId, Model.of(settings.getNameSortOrder())); // pass in the sort\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\tfinal GbStudentGradeInfo studentGradeInfo = (GbStudentGradeInfo) rowModel.getObject();\n\n\t\t\t\tfinal Map<String, Object> modelData = new HashMap<>();\n\t\t\t\tmodelData.put(\"userId\", studentGradeInfo.getStudentUuid());\n\t\t\t\tmodelData.put(\"eid\", studentGradeInfo.getStudentEid());\n\t\t\t\tmodelData.put(\"firstName\", studentGradeInfo.getStudentFirstName());\n\t\t\t\tmodelData.put(\"lastName\", studentGradeInfo.getStudentLastName());\n\t\t\t\tmodelData.put(\"displayName\", studentGradeInfo.getStudentDisplayName());\n\t\t\t\tmodelData.put(\"nameSortOrder\", settings.getNameSortOrder()); // pass in the sort\n\n\t\t\t\tcellItem.add(new StudentNameCellPanel(componentId, Model.ofMap(modelData)));\n\t\t\t\tcellItem.add(new AttributeModifier(\"data-studentUuid\", studentGradeInfo.getStudentUuid()));\n\n\t\t\t\t// TODO may need a subclass of Item that does the onComponentTag override and then tag.setName(\"th\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getCssClass() {\n\t\t\t\treturn \"gb-student-cell\";\n\t\t\t}\n\n\t\t};\n\t\tcols.add(studentNameColumn);\n\n\t\t// course grade column\n\t\tfinal AbstractColumn courseGradeColumn = new AbstractColumn(new Model(\"\")) {\n\t\t\t@Override\n\t\t\tpublic Component getHeader(final String componentId) {\n\t\t\t\tfinal CourseGradeColumnHeaderPanel panel = new CourseGradeColumnHeaderPanel(componentId);\n\t\t\t\treturn panel;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String getCssClass() {\n\t\t\t\treturn \"gb-course-grade\";\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\tfinal GbStudentGradeInfo studentGradeInfo = (GbStudentGradeInfo) rowModel.getObject();\n\n\t\t\t\tString courseGrade;\n\n\t\t\t\tif (courseGradeVisible) {\n\t\t\t\t\tcourseGrade = studentGradeInfo.getCourseGrade();\n\t\t\t\t} else {\n\t\t\t\t\tcourseGrade = getString(\"label.coursegrade.nopermission\");\n\t\t\t\t}\n\n\t\t\t\tfinal Label courseGradeLabel = new Label(componentId, Model.of(courseGrade)) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onEvent(final IEvent<?> event) {\n\t\t\t\t\t\tsuper.onEvent(event);\n\t\t\t\t\t\tif (event.getPayload() instanceof ScoreChangedEvent) {\n\t\t\t\t\t\t\tfinal ScoreChangedEvent scoreChangedEvent = (ScoreChangedEvent) event.getPayload();\n\t\t\t\t\t\t\tif (studentGradeInfo.getStudentUuid().equals(scoreChangedEvent.getStudentUuid())) {\n\t\t\t\t\t\t\t\tfinal CourseGrade courseGrade = GradebookPage.this.businessService\n\t\t\t\t\t\t\t\t\t\t.getCourseGrade(scoreChangedEvent.getStudentUuid());\n\t\t\t\t\t\t\t\t((Model<String>) getDefaultModel()).setObject(courseGrade.getMappedGrade());\n\t\t\t\t\t\t\t\tscoreChangedEvent.getTarget().add(this);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcourseGradeLabel.setOutputMarkupId(true);\n\t\t\t\tcellItem.add(courseGradeLabel);\n\t\t\t}\n\t\t};\n\t\tcols.add(courseGradeColumn);\n\n\t\t// build the rest of the columns based on the assignment list\n\t\tfor (final Assignment assignment : assignments) {\n\n\t\t\tfinal AbstractColumn column = new AbstractColumn(new Model(\"\")) {\n\n\t\t\t\t@Override\n\t\t\t\tpublic Component getHeader(final String componentId) {\n\t\t\t\t\tfinal AssignmentColumnHeaderPanel panel = new AssignmentColumnHeaderPanel(componentId,\n\t\t\t\t\t\t\tnew Model<Assignment>(assignment));\n\n\t\t\t\t\tfinal String category = assignment.getCategoryName();\n\n\t\t\t\t\tint order = -1;\n\t\t\t\t\tif (categorizedAssignmentOrder.containsKey(category)) {\n\t\t\t\t\t\torder = categorizedAssignmentOrder.get(category).indexOf(assignment.getId());\n\t\t\t\t\t}\n\n\t\t\t\t\tpanel.add(new AttributeModifier(\"data-category\", category));\n\t\t\t\t\tpanel.add(new AttributeModifier(\"data-categorized-order\", order));\n\n\t\t\t\t\tfinal StringValue createdAssignmentId = getPageParameters().get(CREATED_ASSIGNMENT_ID_PARAM);\n\t\t\t\t\tif (!createdAssignmentId.isNull() && assignment.getId().equals(createdAssignmentId.toLong())) {\n\t\t\t\t\t\tpanel.add(new AttributeModifier(\"class\", \"gb-just-created\"));\n\t\t\t\t\t\tgetPageParameters().remove(CREATED_ASSIGNMENT_ID_PARAM);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn panel;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic String getCssClass() {\n\t\t\t\t\treturn \"gb-grade-item-column-cell\";\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\t\tfinal GbStudentGradeInfo studentGrades = (GbStudentGradeInfo) rowModel.getObject();\n\n\t\t\t\t\tfinal GbGradeInfo gradeInfo = studentGrades.getGrades().get(assignment.getId());\n\n\t\t\t\t\tfinal Map<String, Object> modelData = new HashMap<>();\n\t\t\t\t\tmodelData.put(\"assignmentId\", assignment.getId());\n\t\t\t\t\tmodelData.put(\"assignmentPoints\", assignment.getPoints());\n\t\t\t\t\tmodelData.put(\"studentUuid\", studentGrades.getStudentUuid());\n\t\t\t\t\tmodelData.put(\"categoryId\", assignment.getCategoryId());\n\t\t\t\t\tmodelData.put(\"isExternal\", assignment.isExternallyMaintained());\n\t\t\t\t\tmodelData.put(\"gradeInfo\", gradeInfo);\n\t\t\t\t\tmodelData.put(\"role\", GradebookPage.this.role);\n\n\t\t\t\t\tcellItem.add(new GradeItemCellPanel(componentId, Model.ofMap(modelData)));\n\n\t\t\t\t\tcellItem.setOutputMarkupId(true);\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tcols.add(column);\n\t\t}\n\n\t\t// render the categories\n\t\t// Display rules:\n\t\t// 1. only show categories if the global setting is enabled\n\t\t// 2. only show categories if they have items\n\t\t// TODO may be able to pass this list into the matrix to save another lookup in there)\n\n\t\tList<CategoryDefinition> categories = new ArrayList<>();\n\n\t\tif (categoriesEnabled) {\n\n\t\t\t// only work with categories if enabled\n\t\t\tcategories = this.businessService.getGradebookCategories();\n\n\t\t\t// remove those that have no assignments\n\t\t\tcategories.removeIf(cat -> cat.getAssignmentList().isEmpty());\n\n\t\t\tfor (final CategoryDefinition category : categories) {\n\n\t\t\t\tif (category.getAssignmentList().isEmpty()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfinal AbstractColumn column = new AbstractColumn(new Model(\"\")) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Component getHeader(final String componentId) {\n\t\t\t\t\t\tfinal CategoryColumnHeaderPanel panel = new CategoryColumnHeaderPanel(componentId,\n\t\t\t\t\t\t\t\tnew Model<CategoryDefinition>(category));\n\n\t\t\t\t\t\tpanel.add(new AttributeModifier(\"data-category\", category.getName()));\n\n\t\t\t\t\t\treturn panel;\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void populateItem(final Item cellItem, final String componentId, final IModel rowModel) {\n\t\t\t\t\t\tfinal GbStudentGradeInfo studentGrades = (GbStudentGradeInfo) rowModel.getObject();\n\n\t\t\t\t\t\tfinal Double score = studentGrades.getCategoryAverages().get(category.getId());\n\n\t\t\t\t\t\tfinal Map<String, Object> modelData = new HashMap<>();\n\t\t\t\t\t\tmodelData.put(\"score\", score);\n\t\t\t\t\t\tmodelData.put(\"studentUuid\", studentGrades.getStudentUuid());\n\t\t\t\t\t\tmodelData.put(\"categoryId\", category.getId());\n\n\t\t\t\t\t\tcellItem.add(new CategoryColumnCellPanel(componentId, Model.ofMap(modelData)));\n\t\t\t\t\t\tcellItem.setOutputMarkupId(true);\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getCssClass() {\n\t\t\t\t\t\treturn \"gb-category-item-column-cell\";\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tcols.add(column);\n\t\t\t}\n\t\t}\n\n\t\tTemp.time(\"all Columns added\", stopwatch.getTime());\n\n\t\t// TODO make this AjaxFallbackDefaultDataTable\n\t\tfinal DataTable table = new DataTable(\"table\", cols, studentGradeMatrix, 100);\n\t\ttable.addBottomToolbar(new NavigationToolbar(table));\n\t\ttable.addTopToolbar(new HeadersToolbar(table, null));\n\t\ttable.add(new AttributeModifier(\"data-siteid\", this.businessService.getCurrentSiteId()));\n\n\t\tfinal WebMarkupContainer noAssignments = new WebMarkupContainer(\"noAssignments\");\n\t\tnoAssignments.setVisible(false);\n\t\tthis.form.add(noAssignments);\n\n\t\tfinal WebMarkupContainer noStudents = new WebMarkupContainer(\"noStudents\");\n\t\tnoStudents.setVisible(false);\n\t\tthis.form.add(noStudents);\n\n\t\tthis.form.add(table);\n\n\t\t// Populate the toolbar\n\t\tfinal Label gradeItemSummary = new Label(\"gradeItemSummary\", new StringResourceModel(\"label.toolbar.gradeitemsummary\", null,\n\t\t\t\tassignments.size() + categories.size(), assignments.size() + categories.size()));\n\t\tgradeItemSummary.setEscapeModelStrings(false);\n\t\tthis.form.add(gradeItemSummary);\n\n\t\tfinal WebMarkupContainer toggleGradeItemsToolbarItem = new WebMarkupContainer(\"toggleGradeItemsToolbarItem\");\n\t\tthis.form.add(toggleGradeItemsToolbarItem);\n\n\t\tfinal AjaxButton toggleCategoriesToolbarItem = new AjaxButton(\"toggleCategoriesToolbarItem\") {\n\t\t\t@Override\n\t\t\tprotected void onInitialize() {\n\t\t\t\tsuper.onInitialize();\n\t\t\t\tif (settings.isCategoriesEnabled()) {\n\t\t\t\t\tadd(new AttributeModifier(\"class\", \"on\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tprotected void onSubmit(final AjaxRequestTarget target, final Form<?> form) {\n\t\t\t\tsettings.setCategoriesEnabled(!settings.isCategoriesEnabled());\n\t\t\t\tsetUiSettings(settings);\n\n\t\t\t\tif (settings.isCategoriesEnabled()) {\n\t\t\t\t\tadd(new AttributeModifier(\"class\", \"on\"));\n\t\t\t\t} else {\n\t\t\t\t\tadd(new AttributeModifier(\"class\", \"\"));\n\t\t\t\t}\n\t\t\t\ttarget.add(this);\n\t\t\t\ttarget.appendJavaScript(\"sakai.gradebookng.spreadsheet.toggleCategories();\");\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\treturn categoriesEnabled && !assignments.isEmpty();\n\t\t\t}\n\t\t};\n\t\tthis.form.add(toggleCategoriesToolbarItem);\n\n\t\t// section and group dropdown\n\t\tfinal List<GbGroup> groups = this.businessService.getSiteSectionsAndGroups();\n\n\t\t// add the default ALL group to the list\n\t\tgroups.add(0, new GbGroup(null, getString(\"groups.all\"), null, GbGroup.Type.ALL));\n\n\t\tfinal DropDownChoice<GbGroup> groupFilter = new DropDownChoice<GbGroup>(\"groupFilter\", new Model<GbGroup>(), groups,\n\t\t\t\tnew ChoiceRenderer<GbGroup>() {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Object getDisplayValue(final GbGroup g) {\n\t\t\t\t\t\treturn g.getTitle();\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic String getIdValue(final GbGroup g, final int index) {\n\t\t\t\t\t\treturn g.getId();\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\tgroupFilter.add(new AjaxFormComponentUpdatingBehavior(\"onchange\") {\n\n\t\t\t@Override\n\t\t\tprotected void onUpdate(final AjaxRequestTarget target) {\n\n\t\t\t\tfinal GbGroup selected = (GbGroup) groupFilter.getDefaultModelObject();\n\n\t\t\t\t// store selected group (null ok)\n\t\t\t\tfinal GradebookUiSettings settings = getUiSettings();\n\t\t\t\tsettings.setGroupFilter(selected);\n\t\t\t\tsetUiSettings(settings);\n\n\t\t\t\t// refresh\n\t\t\t\tsetResponsePage(new GradebookPage());\n\t\t\t}\n\n\t\t});\n\n\t\t// set selected group, or first item in list\n\t\tgroupFilter.setModelObject((settings.getGroupFilter() != null) ? settings.getGroupFilter() : groups.get(0));\n\t\tgroupFilter.setNullValid(false);\n\t\tthis.form.add(groupFilter);\n\n\t\tfinal ToggleGradeItemsToolbarPanel gradeItemsTogglePanel = new ToggleGradeItemsToolbarPanel(\"gradeItemsTogglePanel\",\n\t\t\t\tModel.ofList(assignments));\n\t\tadd(gradeItemsTogglePanel);\n\n\t\t// hide/show components\n\n\t\t// no assignments, hide table, show message\n\t\tif (assignments.isEmpty()) {\n\t\t\ttable.setVisible(false);\n\t\t\ttoggleGradeItemsToolbarItem.setVisible(false);\n\t\t\tnoAssignments.setVisible(true);\n\t\t}\n\n\t\t// no visible students, show table, show message\n\t\t// don't want two messages though, hence the else\n\t\telse if (studentGradeMatrix.size() == 0) {\n\t\t\tnoStudents.setVisible(true);\n\t\t}\n\n\t\tTemp.time(\"Gradebook page done\", stopwatch.getTime());\n\t}","commit_id":"d4428407080ee37007d17a2e0b1feaa435ca66c2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tpublic void onInitialize() {\n\t\tsuper.onInitialize();\n\t\t\n\t\t//unpack model\n\t\tMap<String,Object> modelData = (Map<String,Object>) this.getDefaultModelObject();\n\t\tString userId = (String) modelData.get(\"userId\");\n\t\tString displayName = (String) modelData.get(\"displayName\");\n\t\t\n\t\t//build the grade matrix for the user\n\t\tfinal List<Assignment> assignments = this.businessService.getGradebookAssignments();\n        \n\t\t//TODO catch if this is null, the get(0) will throw an exception\n\t\t//TODO also catch the GbException\n\t\tthis.gradeInfo = this.businessService.buildGradeMatrix(assignments, Collections.singletonList(userId)).get(0);\n\t\tthis.categories = this.businessService.getGradebookCategories();\n\n\t\tfinal List<String> categoryNames = new ArrayList<String>();\n\t\tfinal Map<String, List<Assignment>> categoriesToAssignments = new HashMap<String, List<Assignment>>();\n\n\t\tIterator<Assignment> assignmentIterator = assignments.iterator();\n\t\twhile (assignmentIterator.hasNext()) {\n\t\t\tAssignment assignment = assignmentIterator.next();\n\n\t\t\tString categoryName = assignment.getCategoryName() == null ? GradebookPage.UNCATEGORIZED : assignment.getCategoryName();\n\n\t\t\tif (!categoriesToAssignments.containsKey(categoryName)) {\n\t\t\t\tcategoryNames.add(categoryName);\n\t\t\t\tcategoriesToAssignments.put(categoryName, new ArrayList<Assignment>());\n\t\t\t}\n\n\t\t\tcategoriesToAssignments.get(categoryName).add(assignment);\n\t\t}\n\n\t\tCollections.sort(categoryNames);\n\n\t\tfinal boolean[] categoryScoreHidden = { false };\n\n\t\tadd(new ListView<String>(\"categoriesList\", categoryNames) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(ListItem<String> categoryItem) {\n\t\t\t\tfinal String categoryName = categoryItem.getModelObject();\n\n\t\t\t\tList<Assignment> categoryAssignments = categoriesToAssignments.get(categoryName);\n\n\t\t\t\tcategoryItem.add(new Label(\"category\", categoryName));\n\n\t\t\t\tCategoryDefinition categoryDefinition = null;\n\t\t\t\tfor (CategoryDefinition aCategoryDefinition : categories) {\n\t\t\t\t\tif (aCategoryDefinition.getName().equals(categoryName)) {\n\t\t\t\t\t\tcategoryDefinition = aCategoryDefinition;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (categoryDefinition != null) {\n\t\t\t\t\tDouble score = gradeInfo.getCategoryAverages().get(categoryDefinition.getId());\n\t\t\t\t\tString grade = \"\";\n\t\t\t\t\tif (score != null) {\n\t\t\t\t\t\tgrade = FormatHelper.formatDoubleAsPercentage(score);\n\t\t\t\t\t}\n\t\t\t\t\tcategoryItem.add(new Label(\"categoryGrade\", grade));\n\n\t\t\t\t\tString weight = \"\";\n\t\t\t\t\tif (categoryDefinition.getWeight() == null) {\n\t\t\t\t\t\tcategoryItem.add(new Label(\"categoryWeight\", \"\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tweight = FormatHelper.formatDoubleAsPercentage(categoryDefinition.getWeight() * 100);\n\t\t\t\t\t\tcategoryItem.add(new Label(\"categoryWeight\", weight));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcategoryItem.add(new Label(\"categoryGrade\", \"\"));\n\t\t\t\t\tcategoryItem.add(new Label(\"categoryWeight\", \"\"));\n\t\t\t\t}\n\n\t\t\t\tcategoryItem.add(new ListView<Assignment>(\"assignmentsForCategory\", categoryAssignments) {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void populateItem(ListItem<Assignment> assignmentItem) {\n\t\t\t\t\t\tfinal Assignment assignment = assignmentItem.getModelObject();\n\n\t\t\t\t\t\tGbGradeInfo gradeInfo = InstructorGradeSummaryGradesPanel.this.gradeInfo.getGrades().get(assignment.getId());\n\n\t\t\t\t\t\tfinal String rawGrade;\n\t\t\t\t\t\tString comment;\n\t\t\t\t\t\tif(gradeInfo != null) {\n\t\t\t\t\t\t\trawGrade = gradeInfo.getGrade();\n\t\t\t\t\t\t\tcomment = gradeInfo.getGradeComment();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trawGrade = \"\";\n\t\t\t\t\t\t\tcomment = \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tLabel title = new Label(\"title\", assignment.getName());\n\t\t\t\t\t\tassignmentItem.add(title);\n\n\t\t\t\t\t\tGradebookPage gradebookPage = (GradebookPage) getPage();\n\t\t\t\t\t\tWebMarkupContainer flags = new WebMarkupContainer(\"flags\");\n\t\t\t\t\t\tflags.add(gradebookPage.buildFlagWithPopover(\"isExtraCredit\", getString(\"label.gradeitem.extracredit\")).setVisible(assignment.getExtraCredit()));\n\t\t\t\t\t\tflags.add(gradebookPage.buildFlagWithPopover(\"isNotCounted\", getString(\"label.gradeitem.notcounted\")).setVisible(!assignment.isCounted()));\n\t\t\t\t\t\tflags.add(gradebookPage.buildFlagWithPopover(\"isNotReleased\", getString(\"label.gradeitem.notreleased\")).setVisible(!assignment.isReleased()));\n\t\t\t\t\t\tassignmentItem.add(flags);\n\n\t\t\t\t\t\tassignmentItem.add(new Label(\"dueDate\", FormatHelper.formatDate(assignment.getDueDate(), getString(\"label.studentsummary.noduedate\"))));\n\t\t\t\t\t\tassignmentItem.add(new Label(\"grade\", FormatHelper.formatGrade(rawGrade)));\n\t\t\t\t\t\tassignmentItem.add(new Label(\"outOf\",  new StringResourceModel(\"label.studentsummary.outof\", null, new Object[] { assignment.getPoints() })) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean isVisible() {\n\t\t\t\t\t\t\t\treturn StringUtils.isNotBlank(rawGrade);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tassignmentItem.add(new Label(\"comments\", comment));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\t//course grade\n\t\tfinal Gradebook gradebook = businessService.getGradebook();\n\t\t\n\t\tString currentUserUuid = this.businessService.getCurrentUser().getId();\n\t\tif (!this.businessService.isCourseGradeVisible(currentUserUuid)) {\n\t\t\tadd(new Label(\"courseGrade\", new ResourceModel(\"label.coursegrade.nopermission\")));\n\t\t} else {\n\t\t\tadd(new Label(\"courseGrade\", this.gradeInfo.getCourseGrade()));\n\t\t}\n\t\tadd(new Label(\"courseGradeNotReleasedFlag\", \"*\") {\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\treturn !gradebook.isCourseGradeDisplayed();\n\t\t\t}\n\t\t});\n\n\t\tadd(new Label(\"courseGradeNotReleasedMessage\", getString(\"label.studentsummary.coursegradenotreleasedmessage\")) {\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\treturn !gradebook.isCourseGradeDisplayed();\n\t\t\t}\n\t\t});\n\n\t\tadd(new AttributeModifier(\"data-studentid\", userId));\n\n\t\tadd(new Label(\"categoryScoreNotReleased\", getString(\"label.studentsummary.categoryscorenotreleased\")) {\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\treturn categoryScoreHidden[0];\n\t\t\t}\n\t\t});\n\t}","id":24924,"modified_method":"@Override\n\tpublic void onInitialize() {\n\t\tsuper.onInitialize();\n\n\t\t// unpack model\n\t\tfinal Map<String, Object> modelData = (Map<String, Object>) getDefaultModelObject();\n\t\tfinal String userId = (String) modelData.get(\"userId\");\n\n\t\t// build the grade matrix for the user\n\t\tfinal List<Assignment> assignments = this.businessService.getGradebookAssignments();\n\n\t\t// TODO catch if this is null, the get(0) will throw an exception\n\t\t// TODO also catch the GbException\n\t\tthis.gradeInfo = this.businessService.buildGradeMatrix(assignments, Collections.singletonList(userId)).get(0);\n\t\tthis.categories = this.businessService.getGradebookCategories();\n\n\t\t// get settings\n\t\tfinal GradebookInformation gbInfo = this.businessService.getGradebookSettings();\n\t\tthis.configuredCategoryType = gbInfo.getCategoryType();\n\n\t\t// setup\n\t\tfinal List<String> categoryNames = new ArrayList<String>();\n\t\tfinal Map<String, List<Assignment>> categoryNamesToAssignments = new HashMap<String, List<Assignment>>();\n\n\t\t// iterate over assignments and build map of categoryname to list of assignments\n\t\tfor (final Assignment assignment : assignments) {\n\n\t\t\tfinal String categoryName = getCategoryName(assignment);\n\n\t\t\tif (!categoryNamesToAssignments.containsKey(categoryName)) {\n\t\t\t\tcategoryNames.add(categoryName);\n\t\t\t\tcategoryNamesToAssignments.put(categoryName, new ArrayList<Assignment>());\n\t\t\t}\n\n\t\t\tcategoryNamesToAssignments.get(categoryName).add(assignment);\n\t\t}\n\t\tCollections.sort(categoryNames);\n\n\t\tfinal boolean[] categoryScoreHidden = { false };\n\n\t\tadd(new ListView<String>(\"categoriesList\", categoryNames) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(final ListItem<String> categoryItem) {\n\t\t\t\tfinal String categoryName = categoryItem.getModelObject();\n\n\t\t\t\tfinal List<Assignment> categoryAssignments = categoryNamesToAssignments.get(categoryName);\n\n\t\t\t\tcategoryItem.add(new Label(\"category\", categoryName));\n\n\t\t\t\tCategoryDefinition categoryDefinition = null;\n\t\t\t\tfor (final CategoryDefinition aCategoryDefinition : InstructorGradeSummaryGradesPanel.this.categories) {\n\t\t\t\t\tif (aCategoryDefinition.getName().equals(categoryName)) {\n\t\t\t\t\t\tcategoryDefinition = aCategoryDefinition;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (categoryDefinition != null) {\n\t\t\t\t\tfinal Double score = InstructorGradeSummaryGradesPanel.this.gradeInfo.getCategoryAverages()\n\t\t\t\t\t\t\t.get(categoryDefinition.getId());\n\t\t\t\t\tString grade = \"\";\n\t\t\t\t\tif (score != null) {\n\t\t\t\t\t\tgrade = FormatHelper.formatDoubleAsPercentage(score);\n\t\t\t\t\t}\n\t\t\t\t\tcategoryItem.add(new Label(\"categoryGrade\", grade));\n\n\t\t\t\t\tString weight = \"\";\n\t\t\t\t\tif (categoryDefinition.getWeight() == null) {\n\t\t\t\t\t\tcategoryItem.add(new Label(\"categoryWeight\", \"\"));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tweight = FormatHelper.formatDoubleAsPercentage(categoryDefinition.getWeight() * 100);\n\t\t\t\t\t\tcategoryItem.add(new Label(\"categoryWeight\", weight));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcategoryItem.add(new Label(\"categoryGrade\", \"\"));\n\t\t\t\t\tcategoryItem.add(new Label(\"categoryWeight\", \"\"));\n\t\t\t\t}\n\n\t\t\t\tcategoryItem.add(new ListView<Assignment>(\"assignmentsForCategory\", categoryAssignments) {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void populateItem(final ListItem<Assignment> assignmentItem) {\n\t\t\t\t\t\tfinal Assignment assignment = assignmentItem.getModelObject();\n\n\t\t\t\t\t\tfinal GbGradeInfo gradeInfo = InstructorGradeSummaryGradesPanel.this.gradeInfo.getGrades().get(assignment.getId());\n\n\t\t\t\t\t\tfinal String rawGrade;\n\t\t\t\t\t\tString comment;\n\t\t\t\t\t\tif (gradeInfo != null) {\n\t\t\t\t\t\t\trawGrade = gradeInfo.getGrade();\n\t\t\t\t\t\t\tcomment = gradeInfo.getGradeComment();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trawGrade = \"\";\n\t\t\t\t\t\t\tcomment = \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfinal Label title = new Label(\"title\", assignment.getName());\n\t\t\t\t\t\tassignmentItem.add(title);\n\n\t\t\t\t\t\tfinal GradebookPage gradebookPage = (GradebookPage) getPage();\n\t\t\t\t\t\tfinal WebMarkupContainer flags = new WebMarkupContainer(\"flags\");\n\t\t\t\t\t\tflags.add(gradebookPage.buildFlagWithPopover(\"isExtraCredit\", getString(\"label.gradeitem.extracredit\"))\n\t\t\t\t\t\t\t\t.setVisible(assignment.getExtraCredit()));\n\t\t\t\t\t\tflags.add(gradebookPage.buildFlagWithPopover(\"isNotCounted\", getString(\"label.gradeitem.notcounted\"))\n\t\t\t\t\t\t\t\t.setVisible(!assignment.isCounted()));\n\t\t\t\t\t\tflags.add(gradebookPage.buildFlagWithPopover(\"isNotReleased\", getString(\"label.gradeitem.notreleased\"))\n\t\t\t\t\t\t\t\t.setVisible(!assignment.isReleased()));\n\t\t\t\t\t\tassignmentItem.add(flags);\n\n\t\t\t\t\t\tassignmentItem.add(new Label(\"dueDate\",\n\t\t\t\t\t\t\t\tFormatHelper.formatDate(assignment.getDueDate(), getString(\"label.studentsummary.noduedate\"))));\n\t\t\t\t\t\tassignmentItem.add(new Label(\"grade\", FormatHelper.formatGrade(rawGrade)));\n\t\t\t\t\t\tassignmentItem.add(new Label(\"outOf\",\n\t\t\t\t\t\t\t\tnew StringResourceModel(\"label.studentsummary.outof\", null, new Object[] { assignment.getPoints() })) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean isVisible() {\n\t\t\t\t\t\t\t\treturn StringUtils.isNotBlank(rawGrade);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tassignmentItem.add(new Label(\"comments\", comment));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void renderHead(final IHeaderResponse response) {\n\t\t\t\tsuper.renderHead(response);\n\n\t\t\t\t// hide the weight column if weightings are not enabled\n\t\t\t\tif (!isCategoryWeightEnabled()) {\n\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(\"$('.weight-col').hide();\"));\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n\n\t\t// course grade\n\t\tfinal Gradebook gradebook = this.businessService.getGradebook();\n\n\t\tfinal String currentUserUuid = this.businessService.getCurrentUser().getId();\n\t\tif (!this.businessService.isCourseGradeVisible(currentUserUuid)) {\n\t\t\tadd(new Label(\"courseGrade\", new ResourceModel(\"label.coursegrade.nopermission\")));\n\t\t} else {\n\t\t\tadd(new Label(\"courseGrade\", this.gradeInfo.getCourseGrade()));\n\t\t}\n\t\tadd(new Label(\"courseGradeNotReleasedFlag\", \"*\") {\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\treturn !gradebook.isCourseGradeDisplayed();\n\t\t\t}\n\t\t});\n\n\t\tadd(new Label(\"courseGradeNotReleasedMessage\", getString(\"label.studentsummary.coursegradenotreleasedmessage\")) {\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\treturn !gradebook.isCourseGradeDisplayed();\n\t\t\t}\n\t\t});\n\n\t\tadd(new AttributeModifier(\"data-studentid\", userId));\n\n\t\tadd(new Label(\"categoryScoreNotReleased\", getString(\"label.studentsummary.categoryscorenotreleased\")) {\n\t\t\t@Override\n\t\t\tpublic boolean isVisible() {\n\t\t\t\treturn categoryScoreHidden[0];\n\t\t\t}\n\t\t});\n\t}","commit_id":"d4428407080ee37007d17a2e0b1feaa435ca66c2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tpublic void onInitialize() {\n\t\tsuper.onInitialize();\n\t\t\n\t\t//unpack model\n\t\tMap<String,Object> modelData = (Map<String,Object>) this.getDefaultModelObject();\n\t\tString userId = (String) modelData.get(\"userId\");\n\t\tString displayName = (String) modelData.get(\"displayName\");\n\n\t\t//get grades\n\t\tfinal Map<Assignment, GbGradeInfo> grades = this.businessService.getGradesForStudent(userId);\n\t\tfinal List<Assignment> assignments = new ArrayList(grades.keySet());\n\t\t\n\t\tfinal List<String> categoryNames = new ArrayList<String>();\n\t\tfinal Map<String, List<Assignment>> categoriesToAssignments = new HashMap<String, List<Assignment>>();\n\t\tfinal Map<String, String> categoryAverages = new HashMap<>();\n\n\t\tIterator<Assignment> assignmentIterator = assignments.iterator();\n\t\twhile (assignmentIterator.hasNext()) {\n\t\t\tAssignment assignment = assignmentIterator.next();\n\t\t\tString category = assignment.getCategoryName() == null ? GradebookPage.UNCATEGORIZED : assignment.getCategoryName();\n\n\t\t\tif (!categoriesToAssignments.containsKey(category)) {\n\t\t\t\tcategoryNames.add(category);\n\t\t\t\tcategoriesToAssignments.put(category, new ArrayList<Assignment>());\n\n\t\t\t\tDouble categoryAverage = businessService.getCategoryScoreForStudent(assignment.getCategoryId(), userId, grades);\n\t\t\t\tif (categoryAverage == null || category.equals(GradebookPage.UNCATEGORIZED)) {\n\t\t\t\t\tcategoryAverages.put(category, getString(\"label.nocategoryscore\"));\n\t\t\t\t} else {\n\t\t\t\t\tcategoryAverages.put(category, FormatHelper.formatDoubleAsPercentage(categoryAverage));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcategoriesToAssignments.get(category).add(assignment);\n\t\t}\n\n\t\tCollections.sort(categoryNames);\n\n\t\tadd(new ListView<String>(\"categoriesList\", categoryNames) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(ListItem<String> categoryItem) {\n\t\t\t\tfinal String category = categoryItem.getModelObject();\n\n\t\t\t\tList<Assignment> categoryAssignments = categoriesToAssignments.get(category);\n\n\t\t\t\tcategoryItem.add(new Label(\"category\", category));\n\t\t\t\tcategoryItem.add(new Label(\"categoryGrade\", categoryAverages.get(category)));\n\n\t\t\t\tString categoryWeight = \"\";\n\t\t\t\tif (!categoryAssignments.isEmpty()) {\n\t\t\t\t\tDouble weight = categoryAssignments.get(0).getWeight();\n\t\t\t\t\tif (weight != null) {\n\t\t\t\t\t\tcategoryWeight = FormatHelper.formatDoubleAsPercentage(weight * 100);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcategoryItem.add(new Label(\"categoryWeight\", categoryWeight));\n\n\t\t\t\tcategoryItem.add(new ListView<Assignment>(\"assignmentsForCategory\", categoryAssignments) {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void populateItem(ListItem<Assignment> assignmentItem) {\n\t\t\t\t\t\tfinal Assignment assignment = assignmentItem.getModelObject();\n\n\t\t\t\t\t\tif (!assignment.isReleased()) {\n\t\t\t\t\t\t\tassignmentItem.setVisible(false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tGbGradeInfo gradeInfo = grades.get(assignment);\n\n\t\t\t\t\t\tfinal String rawGrade;\n\t\t\t\t\t\tString comment;\n\t\t\t\t\t\tif(gradeInfo != null) {\n\t\t\t\t\t\t\trawGrade = gradeInfo.getGrade();\n\t\t\t\t\t\t\tcomment = gradeInfo.getGradeComment();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trawGrade = \"\";\n\t\t\t\t\t\t\tcomment = \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tLabel title = new Label(\"title\", assignment.getName());\n\t\t\t\t\t\tassignmentItem.add(title);\n\n\t\t\t\t\t\tBasePage page = (BasePage) getPage();\n\t\t\t\t\t\tWebMarkupContainer flags = new WebMarkupContainer(\"flags\");\n\t\t\t\t\t\tflags.add(page.buildFlagWithPopover(\"isExtraCredit\", getString(\"label.gradeitem.extracredit\")).setVisible(assignment.getExtraCredit()));\n\t\t\t\t\t\tflags.add(page.buildFlagWithPopover(\"isNotCounted\", getString(\"label.gradeitem.notcounted\")).setVisible(!assignment.isCounted()));\n\t\t\t\t\t\tassignmentItem.add(flags);\n\n\t\t\t\t\t\tassignmentItem.add(new Label(\"dueDate\", FormatHelper.formatDate(assignment.getDueDate(), getString(\"label.studentsummary.noduedate\"))));\n\t\t\t\t\t\tassignmentItem.add(new Label(\"grade\", FormatHelper.formatGrade(rawGrade)));\n\t\t\t\t\t\tassignmentItem.add(new Label(\"outOf\",  new StringResourceModel(\"label.studentsummary.outof\", null, new Object[] { assignment.getPoints() })) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean isVisible() {\n\t\t\t\t\t\t\t\treturn StringUtils.isNotBlank(rawGrade);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tassignmentItem.add(new Label(\"comments\", comment));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tfinal Gradebook gradebook = businessService.getGradebook();\n\t\tif (gradebook.isCourseGradeDisplayed()) {\n\t\t\t\n\t\t\t//check permission for current user to view course grade\n\t\t\t//otherwise fetch and render it\n\t\t\tString currentUserUuid = this.businessService.getCurrentUser().getId();\n\t\t\tif (!this.businessService.isCourseGradeVisible(currentUserUuid)) {\n\t\t\t\tadd(new Label(\"courseGrade\", new ResourceModel(\"label.coursegrade.nopermission\")));\n\t\t\t} else {\n\t\t\t\tCourseGrade courseGrade = this.businessService.getCourseGrade(userId);\n\t\t\t\tif(StringUtils.isBlank(courseGrade.getEnteredGrade()) && StringUtils.isBlank(courseGrade.getMappedGrade())) {\n\t\t\t\t\tadd(new Label(\"courseGrade\", new ResourceModel(\"label.studentsummary.coursegrade.none\")));\n\t\t\t\t} else if(StringUtils.isNotBlank(courseGrade.getEnteredGrade())){\n\t\t\t\t\tadd(new Label(\"courseGrade\", courseGrade.getEnteredGrade()));\n\t\t\t\t} else {\n\t\t\t\t\tadd(new Label(\"courseGrade\", new StringResourceModel(\"label.studentsummary.coursegrade.display\", null, new Object[] { courseGrade.getMappedGrade(), FormatHelper.formatStringAsPercentage(courseGrade.getCalculatedGrade()) } )));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tadd(new Label(\"courseGrade\", getString(\"label.studentsummary.coursegradenotreleased\")));\n\t\t}\n\n\t\tadd(new AttributeModifier(\"data-studentid\", userId));\n\t}","id":24925,"modified_method":"@Override\n\tpublic void onInitialize() {\n\t\tsuper.onInitialize();\n\n\t\t// unpack model\n\t\tfinal Map<String, Object> modelData = (Map<String, Object>) getDefaultModelObject();\n\t\tfinal String userId = (String) modelData.get(\"userId\");\n\n\t\t// get grades\n\t\tfinal Map<Assignment, GbGradeInfo> grades = this.businessService.getGradesForStudent(userId);\n\t\tfinal List<Assignment> assignments = new ArrayList(grades.keySet());\n\n\t\t// get settings\n\t\tfinal GradebookInformation gbInfo = this.businessService.getGradebookSettings();\n\t\tthis.configuredCategoryType = gbInfo.getCategoryType();\n\n\t\t// setup\n\t\tfinal List<String> categoryNames = new ArrayList<String>();\n\t\tfinal Map<String, List<Assignment>> categoryNamesToAssignments = new HashMap<String, List<Assignment>>();\n\t\tfinal Map<String, String> categoryAverages = new HashMap<>();\n\n\t\t// iterate over assignments and build map of categoryname to list of assignments as well as category averages\n\t\tfor (final Assignment assignment : assignments) {\n\n\t\t\tfinal String categoryName = getCategoryName(assignment);\n\n\t\t\tif (!categoryNamesToAssignments.containsKey(categoryName)) {\n\t\t\t\tcategoryNames.add(categoryName);\n\t\t\t\tcategoryNamesToAssignments.put(categoryName, new ArrayList<Assignment>());\n\n\t\t\t\tfinal Double categoryAverage = this.businessService.getCategoryScoreForStudent(assignment.getCategoryId(), userId, grades);\n\t\t\t\tif (categoryAverage == null || categoryName.equals(GradebookPage.UNCATEGORISED)) {\n\t\t\t\t\tcategoryAverages.put(categoryName, getString(\"label.nocategoryscore\"));\n\t\t\t\t} else {\n\t\t\t\t\tcategoryAverages.put(categoryName, FormatHelper.formatDoubleAsPercentage(categoryAverage));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcategoryNamesToAssignments.get(categoryName).add(assignment);\n\t\t}\n\t\tCollections.sort(categoryNames);\n\n\t\tadd(new ListView<String>(\"categoriesList\", categoryNames) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(final ListItem<String> categoryItem) {\n\t\t\t\tfinal String categoryName = categoryItem.getModelObject();\n\n\t\t\t\tfinal List<Assignment> categoryAssignments = categoryNamesToAssignments.get(categoryName);\n\n\t\t\t\tcategoryItem.add(new Label(\"category\", categoryName));\n\t\t\t\tcategoryItem.add(new Label(\"categoryGrade\", categoryAverages.get(categoryName)));\n\n\t\t\t\tString categoryWeight = \"\";\n\t\t\t\tif (!categoryAssignments.isEmpty()) {\n\t\t\t\t\tfinal Double weight = categoryAssignments.get(0).getWeight();\n\t\t\t\t\tif (weight != null) {\n\t\t\t\t\t\tcategoryWeight = FormatHelper.formatDoubleAsPercentage(weight * 100);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcategoryItem.add(new Label(\"categoryWeight\", categoryWeight));\n\n\t\t\t\tcategoryItem.add(new ListView<Assignment>(\"assignmentsForCategory\", categoryAssignments) {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void populateItem(final ListItem<Assignment> assignmentItem) {\n\t\t\t\t\t\tfinal Assignment assignment = assignmentItem.getModelObject();\n\n\t\t\t\t\t\tif (!assignment.isReleased()) {\n\t\t\t\t\t\t\tassignmentItem.setVisible(false);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfinal GbGradeInfo gradeInfo = grades.get(assignment);\n\n\t\t\t\t\t\tfinal String rawGrade;\n\t\t\t\t\t\tString comment;\n\t\t\t\t\t\tif (gradeInfo != null) {\n\t\t\t\t\t\t\trawGrade = gradeInfo.getGrade();\n\t\t\t\t\t\t\tcomment = gradeInfo.getGradeComment();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trawGrade = \"\";\n\t\t\t\t\t\t\tcomment = \"\";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfinal Label title = new Label(\"title\", assignment.getName());\n\t\t\t\t\t\tassignmentItem.add(title);\n\n\t\t\t\t\t\tfinal BasePage page = (BasePage) getPage();\n\t\t\t\t\t\tfinal WebMarkupContainer flags = new WebMarkupContainer(\"flags\");\n\t\t\t\t\t\tflags.add(page.buildFlagWithPopover(\"isExtraCredit\", getString(\"label.gradeitem.extracredit\"))\n\t\t\t\t\t\t\t\t.setVisible(assignment.getExtraCredit()));\n\t\t\t\t\t\tflags.add(page.buildFlagWithPopover(\"isNotCounted\", getString(\"label.gradeitem.notcounted\"))\n\t\t\t\t\t\t\t\t.setVisible(!assignment.isCounted()));\n\t\t\t\t\t\tassignmentItem.add(flags);\n\n\t\t\t\t\t\tassignmentItem.add(new Label(\"dueDate\",\n\t\t\t\t\t\t\t\tFormatHelper.formatDate(assignment.getDueDate(), getString(\"label.studentsummary.noduedate\"))));\n\t\t\t\t\t\tassignmentItem.add(new Label(\"grade\", FormatHelper.formatGrade(rawGrade)));\n\t\t\t\t\t\tassignmentItem.add(new Label(\"outOf\",\n\t\t\t\t\t\t\t\tnew StringResourceModel(\"label.studentsummary.outof\", null, new Object[] { assignment.getPoints() })) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic boolean isVisible() {\n\t\t\t\t\t\t\t\treturn StringUtils.isNotBlank(rawGrade);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tassignmentItem.add(new Label(\"comments\", comment));\n\t\t\t\t\t}\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void renderHead(final IHeaderResponse response) {\n\t\t\t\t\t\tsuper.renderHead(response);\n\n\t\t\t\t\t\t// hide the weight column if weightings are not enabled\n\t\t\t\t\t\tif (!isCategoryWeightEnabled()) {\n\t\t\t\t\t\t\tresponse.render(OnDomReadyHeaderItem.forScript(\"$('.weight-col').hide();\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\tfinal Gradebook gradebook = this.businessService.getGradebook();\n\t\tif (gradebook.isCourseGradeDisplayed()) {\n\n\t\t\t// check permission for current user to view course grade\n\t\t\t// otherwise fetch and render it\n\t\t\tfinal String currentUserUuid = this.businessService.getCurrentUser().getId();\n\t\t\tif (!this.businessService.isCourseGradeVisible(currentUserUuid)) {\n\t\t\t\tadd(new Label(\"courseGrade\", new ResourceModel(\"label.coursegrade.nopermission\")));\n\t\t\t} else {\n\t\t\t\tfinal CourseGrade courseGrade = this.businessService.getCourseGrade(userId);\n\t\t\t\tif (StringUtils.isBlank(courseGrade.getEnteredGrade()) && StringUtils.isBlank(courseGrade.getMappedGrade())) {\n\t\t\t\t\tadd(new Label(\"courseGrade\", new ResourceModel(\"label.studentsummary.coursegrade.none\")));\n\t\t\t\t} else if (StringUtils.isNotBlank(courseGrade.getEnteredGrade())) {\n\t\t\t\t\tadd(new Label(\"courseGrade\", courseGrade.getEnteredGrade()));\n\t\t\t\t} else {\n\t\t\t\t\tadd(new Label(\"courseGrade\", new StringResourceModel(\"label.studentsummary.coursegrade.display\", null, new Object[] {\n\t\t\t\t\t\t\tcourseGrade.getMappedGrade(), FormatHelper.formatStringAsPercentage(courseGrade.getCalculatedGrade()) })));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tadd(new Label(\"courseGrade\", getString(\"label.studentsummary.coursegradenotreleased\")));\n\t\t}\n\n\t\tadd(new AttributeModifier(\"data-studentid\", userId));\n\t}","commit_id":"d4428407080ee37007d17a2e0b1feaa435ca66c2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tpublic void onInitialize() {\n\t\tsuper.onInitialize();\n\n\t\t// setup\n\t\tfinal List<String> categoryNames = new ArrayList<String>();\n\t\tfinal Map<String, List<Assignment>> categoryNamesToAssignments = new HashMap<String, List<Assignment>>();\n\n\t\tfinal List<Assignment> assignments = (List<Assignment>) this.model.getObject();\n\n\t\t// only deal with categories if categories are enabled\n\t\tthis.categoriesEnabled = this.businessService.categoriesAreEnabled();\n\n\t\t// iterate over assignments and build map of categoryname to list of assignments\n\t\tfor (final Assignment assignment : assignments) {\n\n\t\t\tfinal String categoryName = getCategoryName(assignment);\n\n\t\t\tif (!categoryNamesToAssignments.containsKey(categoryName)) {\n\t\t\t\tcategoryNames.add(categoryName);\n\t\t\t\tcategoryNamesToAssignments.put(categoryName, new ArrayList<Assignment>());\n\t\t\t}\n\n\t\t\tcategoryNamesToAssignments.get(categoryName).add(assignment);\n\t\t}\n\n\t\tCollections.sort(categoryNames);\n\n\t\tadd(new ListView<String>(\"categoriesList\", categoryNames) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(final ListItem<String> categoryItem) {\n\t\t\t\tfinal String category = categoryItem.getModelObject();\n\n\t\t\t\tfinal GradebookPage gradebookPage = (GradebookPage) getPage();\n\n\t\t\t\tcategoryItem.add(new Label(\"category\", category));\n\n\t\t\t\tfinal CheckBox categoryCheckbox = new CheckBox(\"categoryCheckbox\");\n\t\t\t\tcategoryCheckbox.add(new AttributeModifier(\"value\", category));\n\t\t\t\tcategoryCheckbox.add(new AttributeModifier(\"checked\", \"checked\"));\n\t\t\t\tcategoryItem.add(categoryCheckbox);\n\n\t\t\t\tcategoryItem.add(new ListView<Assignment>(\"assignmentsForCategory\", categoryNamesToAssignments.get(category)) {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void populateItem(final ListItem<Assignment> assignmentItem) {\n\t\t\t\t\t\tfinal Assignment assignment = assignmentItem.getModelObject();\n\n\t\t\t\t\t\tGradebookUiSettings settings = gradebookPage.getUiSettings();\n\t\t\t\t\t\tif (settings == null) {\n\t\t\t\t\t\t\tsettings = new GradebookUiSettings();\n\t\t\t\t\t\t\tgradebookPage.setUiSettings(settings);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tassignmentItem.add(new Label(\"assignmentTitle\", assignment.getName()));\n\n\t\t\t\t\t\tfinal CheckBox assignmentCheckbox = new AjaxCheckBox(\"assignmentCheckbox\",\n\t\t\t\t\t\t\t\tModel.of(Boolean.valueOf(settings.isAssignmentVisible(assignment.getId())))) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected void onUpdate(final AjaxRequestTarget target) {\n\t\t\t\t\t\t\t\tGradebookUiSettings settings = gradebookPage.getUiSettings();\n\t\t\t\t\t\t\t\tif (settings == null) {\n\t\t\t\t\t\t\t\t\tsettings = new GradebookUiSettings();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfinal Boolean value = settings.isAssignmentVisible(assignment.getId());\n\t\t\t\t\t\t\t\tsettings.setAssignmentVisibility(assignment.getId(), !value);\n\n\t\t\t\t\t\t\t\tgradebookPage.setUiSettings(settings);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tassignmentCheckbox.add(new AttributeModifier(\"value\", assignment.getId().toString()));\n\t\t\t\t\t\tassignmentCheckbox.add(new AttributeModifier(\"data-colidx\", assignments.indexOf(assignment)));\n\t\t\t\t\t\tassignmentItem.add(assignmentCheckbox);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tfinal WebMarkupContainer categoryScoreFilter = new WebMarkupContainer(\"categoryScore\");\n\t\t\t\tcategoryScoreFilter.setVisible(category != getString(\"gradebookpage.uncategorised\"));\n\t\t\t\tcategoryScoreFilter.add(new Label(\"categoryScoreLabel\",\n\t\t\t\t\t\tnew StringResourceModel(\"label.toolbar.categoryscorelabel\", null, new Object[] { category })));\n\n\t\t\t\tGradebookUiSettings settings = gradebookPage.getUiSettings();\n\t\t\t\tif (settings == null) {\n\t\t\t\t\tsettings = new GradebookUiSettings();\n\t\t\t\t\tgradebookPage.setUiSettings(settings);\n\t\t\t\t}\n\n\t\t\t\tfinal CheckBox categoryScoreCheckbox = new AjaxCheckBox(\"categoryScoreCheckbox\",\n\t\t\t\t\t\tnew Model<Boolean>(settings.isCategoryScoreVisible(category))) {// Model.of(Boolean.valueOf(settings.isCategoryScoreVisible(category))))\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onUpdate(final AjaxRequestTarget target) {\n\t\t\t\t\t\tGradebookUiSettings settings = gradebookPage.getUiSettings();\n\t\t\t\t\t\tif (settings == null) {\n\t\t\t\t\t\t\tsettings = new GradebookUiSettings();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfinal Boolean value = settings.isCategoryScoreVisible(category);\n\t\t\t\t\t\tsettings.setCategoryScoreVisibility(category, !value);\n\n\t\t\t\t\t\tgradebookPage.setUiSettings(settings);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcategoryScoreCheckbox.add(new AttributeModifier(\"value\", category));\n\t\t\t\tcategoryScoreFilter.add(categoryScoreCheckbox);\n\n\t\t\t\tcategoryItem.add(categoryScoreFilter);\n\t\t\t}\n\t\t});\n\t}","id":24926,"modified_method":"@Override\n\tpublic void onInitialize() {\n\t\tsuper.onInitialize();\n\n\t\t// setup\n\t\tfinal List<String> categoryNames = new ArrayList<String>();\n\t\tfinal Map<String, List<Assignment>> categoryNamesToAssignments = new HashMap<String, List<Assignment>>();\n\n\t\tfinal List<Assignment> assignments = (List<Assignment>) this.model.getObject();\n\n\t\t// only deal with categories if categories are enabled\n\t\tthis.categoriesEnabled = this.businessService.categoriesAreEnabled();\n\n\t\t// iterate over assignments and build map of categoryname to list of assignments\n\t\tfor (final Assignment assignment : assignments) {\n\n\t\t\tfinal String categoryName = getCategoryName(assignment);\n\n\t\t\tif (!categoryNamesToAssignments.containsKey(categoryName)) {\n\t\t\t\tcategoryNames.add(categoryName);\n\t\t\t\tcategoryNamesToAssignments.put(categoryName, new ArrayList<Assignment>());\n\t\t\t}\n\n\t\t\tcategoryNamesToAssignments.get(categoryName).add(assignment);\n\t\t}\n\t\tCollections.sort(categoryNames);\n\n\t\tadd(new ListView<String>(\"categoriesList\", categoryNames) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void populateItem(final ListItem<String> categoryItem) {\n\t\t\t\tfinal String categoryName = categoryItem.getModelObject();\n\n\t\t\t\tfinal GradebookPage gradebookPage = (GradebookPage) getPage();\n\n\t\t\t\tcategoryItem.add(new Label(\"category\", categoryName));\n\n\t\t\t\tfinal CheckBox categoryCheckbox = new CheckBox(\"categoryCheckbox\");\n\t\t\t\tcategoryCheckbox.add(new AttributeModifier(\"value\", categoryName));\n\t\t\t\tcategoryCheckbox.add(new AttributeModifier(\"checked\", \"checked\"));\n\t\t\t\tcategoryItem.add(categoryCheckbox);\n\n\t\t\t\tcategoryItem.add(new ListView<Assignment>(\"assignmentsForCategory\", categoryNamesToAssignments.get(categoryName)) {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void populateItem(final ListItem<Assignment> assignmentItem) {\n\t\t\t\t\t\tfinal Assignment assignment = assignmentItem.getModelObject();\n\n\t\t\t\t\t\tGradebookUiSettings settings = gradebookPage.getUiSettings();\n\t\t\t\t\t\tif (settings == null) {\n\t\t\t\t\t\t\tsettings = new GradebookUiSettings();\n\t\t\t\t\t\t\tgradebookPage.setUiSettings(settings);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tassignmentItem.add(new Label(\"assignmentTitle\", assignment.getName()));\n\n\t\t\t\t\t\tfinal CheckBox assignmentCheckbox = new AjaxCheckBox(\"assignmentCheckbox\",\n\t\t\t\t\t\t\t\tModel.of(Boolean.valueOf(settings.isAssignmentVisible(assignment.getId())))) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected void onUpdate(final AjaxRequestTarget target) {\n\t\t\t\t\t\t\t\tGradebookUiSettings settings = gradebookPage.getUiSettings();\n\t\t\t\t\t\t\t\tif (settings == null) {\n\t\t\t\t\t\t\t\t\tsettings = new GradebookUiSettings();\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfinal Boolean value = settings.isAssignmentVisible(assignment.getId());\n\t\t\t\t\t\t\t\tsettings.setAssignmentVisibility(assignment.getId(), !value);\n\n\t\t\t\t\t\t\t\tgradebookPage.setUiSettings(settings);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tassignmentCheckbox.add(new AttributeModifier(\"value\", assignment.getId().toString()));\n\t\t\t\t\t\tassignmentCheckbox.add(new AttributeModifier(\"data-colidx\", assignments.indexOf(assignment)));\n\t\t\t\t\t\tassignmentItem.add(assignmentCheckbox);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tfinal WebMarkupContainer categoryScoreFilter = new WebMarkupContainer(\"categoryScore\");\n\t\t\t\tcategoryScoreFilter.setVisible(categoryName != getString(GradebookPage.UNCATEGORISED));\n\t\t\t\tcategoryScoreFilter.add(new Label(\"categoryScoreLabel\",\n\t\t\t\t\t\tnew StringResourceModel(\"label.toolbar.categoryscorelabel\", null, new Object[] { categoryName })));\n\n\t\t\t\tGradebookUiSettings settings = gradebookPage.getUiSettings();\n\t\t\t\tif (settings == null) {\n\t\t\t\t\tsettings = new GradebookUiSettings();\n\t\t\t\t\tgradebookPage.setUiSettings(settings);\n\t\t\t\t}\n\n\t\t\t\tfinal CheckBox categoryScoreCheckbox = new AjaxCheckBox(\"categoryScoreCheckbox\",\n\t\t\t\t\t\tnew Model<Boolean>(settings.isCategoryScoreVisible(categoryName))) {// Model.of(Boolean.valueOf(settings.isCategoryScoreVisible(category))))\n\t\t\t\t\t// {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onUpdate(final AjaxRequestTarget target) {\n\t\t\t\t\t\tGradebookUiSettings settings = gradebookPage.getUiSettings();\n\t\t\t\t\t\tif (settings == null) {\n\t\t\t\t\t\t\tsettings = new GradebookUiSettings();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfinal Boolean value = settings.isCategoryScoreVisible(categoryName);\n\t\t\t\t\t\tsettings.setCategoryScoreVisibility(categoryName, !value);\n\n\t\t\t\t\t\tgradebookPage.setUiSettings(settings);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tcategoryScoreCheckbox.add(new AttributeModifier(\"value\", categoryName));\n\t\t\t\tcategoryScoreFilter.add(categoryScoreCheckbox);\n\n\t\t\t\tcategoryItem.add(categoryScoreFilter);\n\t\t\t}\n\t\t});\n\t}","commit_id":"d4428407080ee37007d17a2e0b1feaa435ca66c2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Helper to get the category name. Looks at settings as well.\n\t * \n\t * @param assignment\n\t * @return\n\t */\n\tprivate String getCategoryName(final Assignment assignment) {\n\n\t\tif (!this.categoriesEnabled) {\n\t\t\treturn getString(\"gradebookpage.uncategorised\");\n\t\t}\n\n\t\treturn StringUtils.isBlank(assignment.getCategoryName()) ? getString(\"gradebookpage.uncategorised\") : assignment.getCategoryName();\n\n\t}","id":24927,"modified_method":"/**\n\t * Helper to get the category name. Looks at settings as well.\n\t *\n\t * @param assignment\n\t * @return\n\t */\n\tprivate String getCategoryName(final Assignment assignment) {\n\n\t\tif (!this.categoriesEnabled) {\n\t\t\treturn getString(GradebookPage.UNCATEGORISED);\n\t\t}\n\n\t\treturn StringUtils.isBlank(assignment.getCategoryName()) ? getString(GradebookPage.UNCATEGORISED) : assignment.getCategoryName();\n\t}","commit_id":"d4428407080ee37007d17a2e0b1feaa435ca66c2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected ViewHandlerException createException(String msg, Exception e, HttpServletRequest request, HttpServletResponse response) {\n        Debug.logError(msg + \": \" + e, module);\n        try {\n            Writer writer = new StringWriter();\n            ScreenRenderer screens = new ScreenRenderer(writer, null, new HtmlScreenRenderer());\n            screens.populateContextForRequest(request, response, servletContext);\n            screens.getContext().put(\"errorMessage\", e.toString());\n            screens.render(DEFAULT_ERROR_TEMPLATE);\n            response.setContentType(\"text/html\");\n            response.getOutputStream().write(writer.toString().getBytes());\n            writer.close();\n        } catch (Exception x) {\n            Debug.logError(\"Multiple errors rendering FOP\", module);\n        }\n        return new ViewHandlerException(msg, e);\n    }","id":24928,"modified_method":"protected void renderError(String msg, Exception e, HttpServletRequest request, HttpServletResponse response) throws ViewHandlerException {\n        Debug.logError(msg + \": \" + e, module);\n        try {\n            Writer writer = new StringWriter();\n            ScreenRenderer screens = new ScreenRenderer(writer, null, new HtmlScreenRenderer());\n            screens.populateContextForRequest(request, response, servletContext);\n            screens.getContext().put(\"errorMessage\", msg + \": \" + e);\n            screens.render(DEFAULT_ERROR_TEMPLATE);\n            response.setContentType(\"text/html\");\n            response.getWriter().write(writer.toString());\n            writer.close();\n        } catch (Exception x) {\n            Debug.logError(\"Multiple errors rendering FOP\", module);\n            throw new ViewHandlerException(\"Multiple errors rendering FOP\", x);\n        }\n    }","commit_id":"945c933032dfc4c7611d83f5fd38f05168266274","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * @see org.ofbiz.content.webapp.view.ViewHandler#render(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void render(String name, String page, String info, String contentType, String encoding, HttpServletRequest request, HttpServletResponse response) throws ViewHandlerException {\n\n        // render and obtain the XSL-FO\n        Writer writer = new StringWriter();\n        try {\n            ScreenRenderer screens = new ScreenRenderer(writer, null, foScreenRenderer);\n            screens.populateContextForRequest(request, response, servletContext);\n\n            // this is the object used to render forms from their definitions\n            screens.getContext().put(\"formStringRenderer\", new FoFormRenderer(request, response));\n            screens.render(page);\n        } catch (Exception e) {\n            throw createException(\"Problems with the response writer/output stream\", e, request, response);\n        }\n\n        // set the input source (XSL-FO) and generate the output stream of contentType\n        Reader reader = new StringReader(writer.toString());\n        StreamSource src = new StreamSource(reader);\n        if (Debug.verboseOn()) {\n            Debug.logVerbose(\"Transforming the following xsl-fo template: \" + writer.toString(), module);\n        }\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        try {\n            Fop fop = ApacheFopWorker.createFopInstance(out, contentType);\n            ApacheFopWorker.transform(src, null, fop);\n        } catch (Exception e) {\n            throw createException(\"Unable to transform FO file\", e, request, response);\n        }\n        // set the content type and length\n        response.setContentType(contentType);\n        response.setContentLength(out.size());\n\n        // write to the browser\n        try {\n            out.writeTo(response.getOutputStream());\n            response.getOutputStream().flush();\n        } catch (IOException e) {\n            throw createException(\"Unable write to browser OutputStream\", e, request, response);\n        }\n    }","id":24929,"modified_method":"/**\n     * @see org.ofbiz.content.webapp.view.ViewHandler#render(java.lang.String, java.lang.String, java.lang.String, java.lang.String, java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)\n     */\n    public void render(String name, String page, String info, String contentType, String encoding, HttpServletRequest request, HttpServletResponse response) throws ViewHandlerException {\n\n        // render and obtain the XSL-FO\n        Writer writer = new StringWriter();\n        try {\n            ScreenRenderer screens = new ScreenRenderer(writer, null, foScreenRenderer);\n            screens.populateContextForRequest(request, response, servletContext);\n\n            // this is the object used to render forms from their definitions\n            screens.getContext().put(\"formStringRenderer\", new FoFormRenderer(request, response));\n            screens.render(page);\n        } catch (Exception e) {\n            renderError(\"Problems with the response writer/output stream\", e, request, response);\n            return;\n        }\n\n        // set the input source (XSL-FO) and generate the output stream of contentType\n        Reader reader = new StringReader(writer.toString());\n        StreamSource src = new StreamSource(reader);\n        if (Debug.verboseOn()) {\n            Debug.logVerbose(\"Transforming the following xsl-fo template: \" + writer.toString(), module);\n        }\n\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n        try {\n            Fop fop = ApacheFopWorker.createFopInstance(out, contentType);\n            ApacheFopWorker.transform(src, null, fop);\n        } catch (Exception e) {\n            renderError(\"Unable to transform FO file\", e, request, response);\n            return;\n        }\n        // set the content type and length\n        response.setContentType(contentType);\n        response.setContentLength(out.size());\n\n        // write to the browser\n        try {\n            out.writeTo(response.getOutputStream());\n            response.getOutputStream().flush();\n        } catch (IOException e) {\n            renderError(\"Unable to write to OutputStream\", e, request, response);\n        }\n    }","commit_id":"945c933032dfc4c7611d83f5fd38f05168266274","url":"https://github.com/apache/ofbiz"},{"original_method":"/**\n     * Scan should try first remote node and fallbacks to second remote node.\n     *\n     * @throws Exception If failed.\n     */\n    public void testScanFallback() throws Exception {\n        cacheMode = CacheMode.PARTITIONED;\n        backups = 1;\n        commSpiFactory = new TestFallbackCommunicationSpiFactory();\n\n        final Set<Integer> candidates = new TreeSet<>();\n\n        final AtomicBoolean test = new AtomicBoolean(false);\n\n        for(int j = 0; j < 2; j++) {\n            clientMode = true;\n\n            latch = new CountDownLatch(1);\n\n            try {\n                final Ignite ignite0 = startGrid(0);\n\n                clientMode = false;\n\n                final IgniteEx ignite1 = startGrid(1);\n                final IgniteEx ignite2 = startGrid(2);\n                startGrid(3);\n\n                if (test.get()) {\n                    expNodeId = ignite1.localNode().id();\n                    expFallbackNodeId = ignite2.localNode().id();\n                }\n\n                final IgniteCacheProxy<Integer, Integer> cache = fillCache(ignite0);\n\n                if (!test.get()) {\n                    candidates.addAll(localPartitions(ignite1));\n                    candidates.retainAll(localPartitions(ignite2));\n                }\n\n                Runnable run = new Runnable() {\n                    @Override public void run() {\n                        try {\n                            startGrid(4);\n                            startGrid(5);\n\n                            awaitPartitionMapExchange();\n\n                            if (!test.get()) {\n                                Set<Integer> parts = localPartitions(ignite1);\n                                candidates.removeAll(parts);\n                            }\n\n                            latch.countDown();\n                        }\n                        catch (Exception e) {\n                            e.printStackTrace();\n                        }\n\n                    }\n                };\n\n                int part;\n                CacheQuery<Map.Entry<Integer, Integer>> qry = null;\n\n                if (test.get()) {\n                    part = F.first(candidates);\n\n                    qry = cache.context().queries().createScanQuery(null, part, false);\n                }\n\n                new Thread(run).start();\n\n                if (test.get())\n                    doTestScanQuery(qry);\n                else\n                    latch.await();\n            }\n            finally {\n                test.set(true);\n\n                stopAllGrids();\n            }\n        }\n    }","id":24930,"modified_method":"/**\n     * Scan should try first remote node and fallbacks to second remote node.\n     *\n     * @throws Exception If failed.\n     */\n    public void testScanFallback() throws Exception {\n        cacheMode = CacheMode.PARTITIONED;\n        backups = 1;\n        commSpiFactory = new TestFallbackCommunicationSpiFactory();\n\n        final Set<Integer> candidates = new TreeSet<>();\n\n        final AtomicBoolean test = new AtomicBoolean(false);\n\n        for(int j = 0; j < 2; j++) {\n            clientMode = true;\n\n            latch = new CountDownLatch(1);\n\n            try {\n                final Ignite ignite0 = startGrid(0);\n\n                clientMode = false;\n\n                final IgniteEx ignite1 = startGrid(1);\n                final IgniteEx ignite2 = startGrid(2);\n                startGrid(3);\n\n                if (test.get()) {\n                    expNodeId = ignite1.localNode().id();\n                    expFallbackNodeId = ignite2.localNode().id();\n                }\n\n                final IgniteCacheProxy<Integer, Integer> cache = fillCache(ignite0);\n\n                if (!test.get()) {\n                    candidates.addAll(localPartitions(ignite1));\n\n                    candidates.retainAll(localPartitions(ignite2));\n                }\n\n                Runnable run = new Runnable() {\n                    @Override public void run() {\n                        try {\n                            startGrid(4);\n                            startGrid(5);\n\n                            awaitPartitionMapExchange();\n\n                            if (!test.get()) {\n                                candidates.removeAll(localPartitions(ignite1));\n\n                                F.retain(candidates, false, localPartitions(ignite2));\n                            }\n\n                            latch.countDown();\n                        }\n                        catch (Exception e) {\n                            e.printStackTrace();\n                        }\n\n                    }\n                };\n\n                int part;\n                CacheQuery<Map.Entry<Integer, Integer>> qry = null;\n\n                if (test.get()) {\n                    part = F.first(candidates);\n\n                    qry = cache.context().queries().createScanQuery(null, part, false);\n                }\n\n                new Thread(run).start();\n\n                if (test.get())\n                    doTestScanQuery(qry);\n                else\n                    latch.await();\n            }\n            finally {\n                test.set(true);\n\n                stopAllGrids();\n            }\n        }\n    }","commit_id":"9fca6b5005a6f5ddd16af936c6445748b398ed39","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        cfg.setCommunicationSpi(commSpiFactory.create());\n\n        CacheConfiguration ccfg = defaultCacheConfiguration();\n        ccfg.setCacheMode(cacheMode);\n        ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);\n        ccfg.setBackups(backups);\n        ccfg.setNearConfiguration(null);\n\n        cfg.setCacheConfiguration(ccfg);\n\n        cfg.setClientMode(clientMode);\n\n        return cfg;\n    }","id":24931,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        cfg.setClientMode(clientMode);\n\n        TcpDiscoverySpi discoSpi = new TcpDiscoverySpi();\n        discoSpi.setIpFinder(IP_FINDER);\n        discoSpi.setForceServerMode(true);\n        cfg.setDiscoverySpi(discoSpi);\n\n        cfg.setCommunicationSpi(commSpiFactory.create());\n\n        CacheConfiguration ccfg = defaultCacheConfiguration();\n        ccfg.setCacheMode(cacheMode);\n        ccfg.setAtomicityMode(CacheAtomicityMode.ATOMIC);\n        ccfg.setBackups(backups);\n        ccfg.setNearConfiguration(null);\n\n        cfg.setCacheConfiguration(ccfg);\n\n        return cfg;\n    }","commit_id":"9fca6b5005a6f5ddd16af936c6445748b398ed39","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testAsyncCacheFuture() throws Exception {\n        final CountDownLatch readyLatch = new CountDownLatch(1);\n\n        GridJavaProcess node1 = null;\n\n        Collection<String> jvmArgs = Arrays.asList(\"-ea\", \"-DIGNITE_QUIET=false\");\n\n        try {\n            node1 = GridJavaProcess.exec(\n                StartNode.class.getName(), null,\n                log,\n                new CI1<String>() {\n                    @Override public void apply(String s) {\n                        info(\"Server node1: \" + s);\n\n                        if (s.contains(\"Topology snapshot\"))\n                            readyLatch.countDown();\n                    }\n                },\n                null,\n                jvmArgs,\n                null\n            );\n\n            assertTrue(readyLatch.await(60, SECONDS));\n\n            Ignite client = startGrid(0);\n\n            IgniteCache<String, NotSerializableClass> cache = client.getOrCreateCache(\"CACHE\");\n\n            cache.put(\"key\", new NotSerializableClass());\n\n            System.setProperty(\"FAIL\", \"true\");\n\n            IgniteCache<String, NotSerializableClass> asyncCache = cache.withAsync();\n\n            asyncCache.get(\"key\");\n\n            final CountDownLatch futLatch = new CountDownLatch(1);\n\n            asyncCache.future().listen(new IgniteInClosure<IgniteFuture<Object>>() {\n                @Override public void apply(IgniteFuture<Object> fut) {\n                    assertTrue(fut.isDone());\n\n                    try {\n                        fut.get();\n\n                        fail();\n                    }\n                    catch (CacheException e) {\n                        log.info(\"Expected error: \" + e);\n\n                        futLatch.countDown();\n                    }\n                }\n            });\n\n            assertTrue(futLatch.await(60, SECONDS));\n        }\n        finally {\n            if (node1 != null)\n                node1.killProcess();\n        }\n    }","id":24932,"modified_method":"/**\n     * @throws Exception If failed.\n     */\n    public void testAsyncCacheFuture() throws Exception {\n        Ignite srv = startGrid(0);\n\n        IgniteCache<String, NotSerializableClass> cache = srv.getOrCreateCache(\"CACHE\");\n        cache.put(\"key\", new NotSerializableClass());\n\n        Ignite client = startGrid(1);\n\n        IgniteCache<String, NotSerializableClass> asyncCache = client.<String, NotSerializableClass>cache(\"CACHE\").withAsync();\n\n        System.setProperty(\"FAIL\", \"true\");\n\n        asyncCache.get(\"key\");\n\n        final CountDownLatch futLatch = new CountDownLatch(1);\n\n        asyncCache.future().listen(new IgniteInClosure<IgniteFuture<Object>>() {\n            @Override public void apply(IgniteFuture<Object> fut) {\n                assertTrue(fut.isDone());\n\n                try {\n                    fut.get();\n\n                    fail();\n                }\n                catch (CacheException e) {\n                    log.info(\"Expected error: \" + e);\n\n                    futLatch.countDown();\n                }\n            }\n        });\n\n        assertTrue(futLatch.await(60, SECONDS));\n    }","commit_id":"94a42a48530998da9895e217c99eec69db71d8c9","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = StartNode.createConfiguration();\n\n        cfg.setClientMode(true);\n\n        return cfg;\n    }","id":24933,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = new IgniteConfiguration();\n        cfg.setGridName(gridName);\n\n        if (gridName.equals(getTestGridName(1)))\n            cfg.setClientMode(true);\n\n        return cfg;\n    }","commit_id":"94a42a48530998da9895e217c99eec69db71d8c9","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        if (cfg.isClientMode() != null && cfg.isClientMode()) {\n            TcpClientDiscoverySpi discoverySpi = new TcpClientDiscoverySpi();\n            discoverySpi.setIpFinder(ipFinder);\n\n            cfg.setDiscoverySpi(discoverySpi);\n        }\n\n        return cfg;\n    }","id":24934,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        if (cfg.isClientMode() != null && cfg.isClientMode()) {\n            TcpDiscoveryVmIpFinder clientFinder = new TcpDiscoveryVmIpFinder();\n            ArrayList<String> addresses = new ArrayList<>(ipFinder.getRegisteredAddresses().size());\n\n            for (InetSocketAddress sockAddr : ipFinder.getRegisteredAddresses()) {\n                addresses.add(sockAddr.getHostString() + \":\" + sockAddr.getPort());\n            }\n\n            clientFinder.setAddresses(addresses);\n\n            TcpClientDiscoverySpi discoverySpi = new TcpClientDiscoverySpi();\n            discoverySpi.setIpFinder(clientFinder);\n\n\n            cfg.setDiscoverySpi(discoverySpi);\n        }\n\n        cfg.setLocalHost(\"127.0.0.1\");\n\n        return cfg;\n    }","commit_id":"46ae32bd7a748db2ea35361fd830ecb08d562e5c","url":"https://github.com/apache/ignite"},{"original_method":"public void testCacheConcurrentlyWithMultipleClientNodes() throws Exception {\n        AtomicInteger threadsCnt = new AtomicInteger();\n\n        IgniteInternalFuture<?> f = multithreadedAsync(\n                new Callable<Object>() {\n                    @Override public Object call() throws Exception {\n                        int clientIdx = SERVER_NODES_COUNT + threadsCnt.getAndIncrement();\n                        Ignite node = grid(clientIdx);\n\n                        assert node.configuration().isClientMode();\n\n                        IgniteCache<Integer, Integer> cache = node.cache(null);\n                        boolean isNearCacheNode = nearCacheNode[clientIdx - SERVER_NODES_COUNT];\n\n                        for (int i = 100 * clientIdx; i < 100 * (clientIdx + 1); i++) {\n                            cache.put(i, i);\n                        }\n\n                        for (int i = 100 * clientIdx; i < 100 * (clientIdx + 1); i++) {\n                            assertEquals(i, (int)cache.get(i));\n\n                            if (isNearCacheNode)\n                                assertEquals(i, (int) cache.localPeek(i, CachePeekMode.ONHEAP));\n                        }\n\n                        //stopGrid(clientIdx);\n\n                        return null;\n                    }\n                },\n                CLIENT_NODES_COUNT\n        );\n\n        f.get();\n    }","id":24935,"modified_method":"public void testCacheConcurrentlyWithMultipleClientNodes() throws Exception {\n        AtomicInteger threadsCnt = new AtomicInteger();\n\n        IgniteInternalFuture<?> f = multithreadedAsync(\n                new Callable<Object>() {\n                    @Override public Object call() throws Exception {\n                        int clientIdx = SERVER_NODES_COUNT + threadsCnt.getAndIncrement();\n                        Ignite node = grid(clientIdx);\n\n                        assert node.configuration().isClientMode();\n\n                        IgniteCache<Integer, Integer> cache = node.cache(null);\n                        boolean isNearCacheNode = nearCacheNode[clientIdx - SERVER_NODES_COUNT];\n\n                        for (int i = 100 * clientIdx; i < 100 * (clientIdx + 1); i++) {\n                            cache.put(i, i);\n                        }\n\n                        for (int i = 100 * clientIdx; i < 100 * (clientIdx + 1); i++) {\n                            assertEquals(i, (int)cache.get(i));\n\n                            if (isNearCacheNode)\n                                assertEquals(i, (int) cache.localPeek(i, CachePeekMode.ONHEAP));\n                        }\n\n                        stopGrid(clientIdx);\n\n                        return null;\n                    }\n                },\n                CLIENT_NODES_COUNT\n        );\n\n        f.get();\n    }","commit_id":"46ae32bd7a748db2ea35361fd830ecb08d562e5c","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n        int nodesCount = gridsCnt.incrementAndGet();\n\n        // Filling configuration for client nodes\n        if (nodesCount > SERVER_NODES_COUNT) {\n            TcpClientDiscoverySpi disco = new TcpClientDiscoverySpi();\n            disco.setIpFinder(ipFinder);\n\n            cfg.setClientMode(true);\n            //cfg.setDiscoverySpi(disco);\n        }\n\n        return cfg;\n    }","id":24936,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n        int nodesCount = gridsCnt.incrementAndGet();\n\n        // Filling configuration for client nodes\n        if (nodesCount > SERVER_NODES_COUNT) {\n            TcpDiscoveryVmIpFinder clientFinder = new TcpDiscoveryVmIpFinder();\n            ArrayList<String> addresses = new ArrayList<>(ipFinder.getRegisteredAddresses().size());\n\n            for (InetSocketAddress sockAddr : ipFinder.getRegisteredAddresses()) {\n                addresses.add(sockAddr.getHostString() + \":\" + sockAddr.getPort());\n            }\n\n            clientFinder.setAddresses(addresses);\n\n            TcpClientDiscoverySpi discoverySpi = new TcpClientDiscoverySpi();\n            discoverySpi.setIpFinder(clientFinder);\n\n            cfg.setDiscoverySpi(discoverySpi);\n            cfg.setClientMode(true);\n        }\n\n        cfg.setLocalHost(\"127.0.0.1\");\n\n        return cfg;\n    }","commit_id":"46ae32bd7a748db2ea35361fd830ecb08d562e5c","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return Test suite.\n     * @throws Exception Thrown in case of the failure.\n     */\n    public static TestSuite suite() throws Exception {\n        TestSuite suite = new TestSuite(\"Ignite Basic Test Suite\");\n\n        suite.addTest(IgniteLangSelfTestSuite.suite());\n        suite.addTest(IgniteUtilSelfTestSuite.suite());\n        suite.addTest(IgniteMarshallerSelfTestSuite.suite());\n        suite.addTest(IgniteKernalSelfTestSuite.suite());\n        suite.addTest(IgniteStartUpTestSuite.suite());\n        suite.addTest(IgniteExternalizableSelfTestSuite.suite());\n        suite.addTest(IgniteP2PSelfTestSuite.suite());\n        suite.addTest(IgniteCacheP2pUnmarshallingErrorTestSuit.suite());\n\n        suite.addTest(new TestSuite(GridSelfTest.class));\n        suite.addTest(new TestSuite(GridProjectionSelfTest.class));\n        suite.addTest(new TestSuite(GridMessagingSelfTest.class));\n        suite.addTest(new TestSuite(GridMessagingNoPeerClassLoadingSelfTest.class));\n\n        if (U.isLinux() || U.isMacOs())\n            suite.addTest(IgniteIpcSharedMemorySelfTestSuite.suite());\n\n        suite.addTestSuite(GridReleaseTypeSelfTest.class);\n        suite.addTestSuite(GridProductVersionSelfTest.class);\n        suite.addTestSuite(GridAffinityProcessorRendezvousSelfTest.class);\n        suite.addTestSuite(GridClosureProcessorSelfTest.class);\n        suite.addTestSuite(GridStartStopSelfTest.class);\n        suite.addTestSuite(GridProjectionForCachesSelfTest.class);\n        suite.addTestSuite(GridProjectionForCachesOnDaemonNodeSelfTest.class);\n        suite.addTestSuite(GridSpiLocalHostInjectionTest.class);\n        suite.addTestSuite(GridLifecycleBeanSelfTest.class);\n        suite.addTestSuite(GridStopWithCancelSelfTest.class);\n        suite.addTestSuite(GridReduceSelfTest.class);\n        suite.addTestSuite(GridEventConsumeSelfTest.class);\n        suite.addTestSuite(GridSuppressedExceptionSelfTest.class);\n        suite.addTestSuite(GridLifecycleAwareSelfTest.class);\n        suite.addTestSuite(GridMessageListenSelfTest.class);\n        suite.addTestSuite(GridFailFastNodeFailureDetectionSelfTest.class);\n        suite.addTestSuite(OffHeapTieredTransactionSelfTest.class);\n\n        return suite;\n    }","id":24937,"modified_method":"/**\n     * @return Test suite.\n     * @throws Exception Thrown in case of the failure.\n     */\n    public static TestSuite suite() throws Exception {\n        TestSuite suite = new TestSuite(\"Ignite Basic Test Suite\");\n\n        suite.addTest(IgniteLangSelfTestSuite.suite());\n        suite.addTest(IgniteUtilSelfTestSuite.suite());\n        suite.addTest(IgniteMarshallerSelfTestSuite.suite());\n        suite.addTest(IgniteKernalSelfTestSuite.suite());\n        suite.addTest(IgniteStartUpTestSuite.suite());\n        suite.addTest(IgniteExternalizableSelfTestSuite.suite());\n        suite.addTest(IgniteP2PSelfTestSuite.suite());\n        suite.addTest(IgniteCacheP2pUnmarshallingErrorTestSuite.suite());\n\n        suite.addTest(new TestSuite(GridSelfTest.class));\n        suite.addTest(new TestSuite(GridProjectionSelfTest.class));\n        suite.addTest(new TestSuite(GridMessagingSelfTest.class));\n        suite.addTest(new TestSuite(GridMessagingNoPeerClassLoadingSelfTest.class));\n\n        if (U.isLinux() || U.isMacOs())\n            suite.addTest(IgniteIpcSharedMemorySelfTestSuite.suite());\n\n        suite.addTestSuite(GridReleaseTypeSelfTest.class);\n        suite.addTestSuite(GridProductVersionSelfTest.class);\n        suite.addTestSuite(GridAffinityProcessorRendezvousSelfTest.class);\n        suite.addTestSuite(GridClosureProcessorSelfTest.class);\n        suite.addTestSuite(GridStartStopSelfTest.class);\n        suite.addTestSuite(GridProjectionForCachesSelfTest.class);\n        suite.addTestSuite(GridProjectionForCachesOnDaemonNodeSelfTest.class);\n        suite.addTestSuite(GridSpiLocalHostInjectionTest.class);\n        suite.addTestSuite(GridLifecycleBeanSelfTest.class);\n        suite.addTestSuite(GridStopWithCancelSelfTest.class);\n        suite.addTestSuite(GridReduceSelfTest.class);\n        suite.addTestSuite(GridEventConsumeSelfTest.class);\n        suite.addTestSuite(GridSuppressedExceptionSelfTest.class);\n        suite.addTestSuite(GridLifecycleAwareSelfTest.class);\n        suite.addTestSuite(GridMessageListenSelfTest.class);\n        suite.addTestSuite(GridFailFastNodeFailureDetectionSelfTest.class);\n        suite.addTestSuite(OffHeapTieredTransactionSelfTest.class);\n\n        return suite;\n    }","commit_id":"bc2269d2284e90c8097195233e0340c264204b71","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        if (gridName.endsWith(\"0\"))\n            cfg.setClientMode(true);\n\n        return cfg;\n    }","id":24938,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        if (getTestGridName(0).equals(gridName)) {\n            cfg.setClientMode(true);\n\n            cfg.setCacheConfiguration();\n        }\n\n        return cfg;\n    }","commit_id":"bc2269d2284e90c8097195233e0340c264204b71","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Tests that correct response will be sent to client node in case of unmarshalling failed.\n     */\n    public void testResponseMessageOnUnmarshallingFailed() throws Exception {\n        //GridNearAtomicUpdateRequest unmarshalling failed test\n        readCnt.set(1);\n\n        failAtomicPut(++key);\n\n        //Check that cache is empty.\n        readCnt.set(Integer.MAX_VALUE);\n\n        assert jcache(0).get(new TestKey(String.valueOf(key))) == null;\n\n        //GridDhtAtomicUpdateRequest unmarshalling failed test\n        readCnt.set(2);\n\n        failAtomicPut(++key);\n\n        //Check that cache is not empty.\n        readCnt.set(Integer.MAX_VALUE);\n\n        assert jcache(0).get(new TestKey(String.valueOf(key))) != null;\n\n        //GridNearGetRequest unmarshalling failed test\n        readCnt.set(1);\n\n        failAtomicGet(++key);\n\n        //GridNearGetResponse unmarshalling failed test\n        readCnt.set(Integer.MAX_VALUE);\n\n        jcache(0).put(new TestKey(String.valueOf(++key)), \"\");\n\n        readCnt.set(2);\n\n        failAtomicGet(key);\n    }","id":24939,"modified_method":"/**\n     * Tests that correct response will be sent to client node in case of unmarshalling failed.\n     *\n     * @throws Exception If failed.\n     */\n    public void testResponseMessageOnUnmarshallingFailed() throws Exception {\n        //GridNearAtomicUpdateRequest unmarshalling failed test\n        readCnt.set(1);\n\n        failAtomicPut(++key);\n\n        //Check that cache is empty.\n        readCnt.set(Integer.MAX_VALUE);\n\n        assert jcache(0).get(new TestKey(String.valueOf(key))) == null;\n\n        //GridDhtAtomicUpdateRequest unmarshalling failed test\n        readCnt.set(2);\n\n        failAtomicPut(++key);\n\n        //Check that cache is not empty.\n        readCnt.set(Integer.MAX_VALUE);\n\n        assert jcache(0).get(new TestKey(String.valueOf(key))) != null;\n\n        //GridNearGetRequest unmarshalling failed test\n        readCnt.set(1);\n\n        failAtomicGet(++key);\n\n        //GridNearGetResponse unmarshalling failed test\n        readCnt.set(Integer.MAX_VALUE);\n\n        jcache(0).put(new TestKey(String.valueOf(++key)), \"\");\n\n        readCnt.set(2);\n\n        failAtomicGet(key);\n    }","commit_id":"bc2269d2284e90c8097195233e0340c264204b71","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Sends put atomically and handles fail.\n     */\n    protected void failAtomicPut(int k) {\n        try {\n            jcache(0).put(new TestKey(String.valueOf(k)), \"\");\n\n            assert false : \"p2p marshalling failed, but error response was not sent\";\n        }\n        catch (CacheException e) {\n            assert X.hasCause(e, IOException.class);\n        }\n\n        assert readCnt.get() == 0; //ensure we have read count as expected.\n    }","id":24940,"modified_method":"/**\n     * Sends put atomically and handles fail.\n     *\n     * @param k Key.\n     */\n    protected void failAtomicPut(int k) {\n        try {\n            jcache(0).put(new TestKey(String.valueOf(k)), \"\");\n\n            assert false : \"p2p marshalling failed, but error response was not sent\";\n        }\n        catch (CacheException e) {\n            assert X.hasCause(e, IOException.class);\n        }\n\n        assert readCnt.get() == 0; //ensure we have read count as expected.\n    }","commit_id":"bc2269d2284e90c8097195233e0340c264204b71","url":"https://github.com/apache/ignite"},{"original_method":"/** Test key 1. */\n        public TestKey(String field) {\n            this.field = field;\n        }","id":24941,"modified_method":"/**\n         * @param field Test key 1.\n         */\n        public TestKey(String field) {\n            this.field = field;\n        }","commit_id":"bc2269d2284e90c8097195233e0340c264204b71","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n        @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            field = (String)in.readObject();\n\n            if (readCnt.decrementAndGet() <= 0) {\n                throw new IOException(\"Class can not be unmarshalled\");\n            }\n        }","id":24942,"modified_method":"/** {@inheritDoc} */\n        @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n            field = (String)in.readObject();\n\n            if (readCnt.decrementAndGet() <= 0)\n                throw new IOException(\"Class can not be unmarshalled.\");\n        }","commit_id":"bc2269d2284e90c8097195233e0340c264204b71","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Sends get atomically and handles fail.\n     */\n    protected void failAtomicGet(int k) {\n        try {\n            jcache(0).get(new TestKey(String.valueOf(k)));\n\n            assert false : \"p2p marshalling failed, but error response was not sent\";\n        }\n        catch (CacheException e) {\n            assert X.hasCause(e, IOException.class);\n        }\n    }","id":24943,"modified_method":"/**\n     * Sends get atomically and handles fail.\n     *\n     * @param k Key.\n     */\n    protected void failAtomicGet(int k) {\n        try {\n            jcache(0).get(new TestKey(String.valueOf(k)));\n\n            assert false : \"p2p marshalling failed, but error response was not sent\";\n        }\n        catch (CacheException e) {\n            assert X.hasCause(e, IOException.class);\n        }\n    }","commit_id":"bc2269d2284e90c8097195233e0340c264204b71","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        cfg.getCacheConfiguration()[0].setEvictMaxOverflowRatio(0);\n        cfg.getCacheConfiguration()[0].setEvictSynchronized(true);\n        cfg.getCacheConfiguration()[0].setEvictSynchronizedKeyBufferSize(1);\n        cfg.getCacheConfiguration()[0].setEvictionPolicy(new FifoEvictionPolicy(1));\n\n        return cfg;\n    }","id":24944,"modified_method":"/** {@inheritDoc} */\n    @Override protected IgniteConfiguration getConfiguration(String gridName) throws Exception {\n        IgniteConfiguration cfg = super.getConfiguration(gridName);\n\n        if (cfg.isClientMode() == null || !cfg.isClientMode()) {\n            cfg.getCacheConfiguration()[0].setEvictMaxOverflowRatio(0);\n            cfg.getCacheConfiguration()[0].setEvictSynchronized(true);\n            cfg.getCacheConfiguration()[0].setEvictSynchronizedKeyBufferSize(1);\n            cfg.getCacheConfiguration()[0].setEvictionPolicy(new FifoEvictionPolicy(1));\n        }\n\n        return cfg;\n    }","commit_id":"bc2269d2284e90c8097195233e0340c264204b71","url":"https://github.com/apache/ignite"},{"original_method":"public Object getValueAt(int row, int column)\n         {\n             \n             categoryIncluded.trimToSize();\n             \n             if(current == null)\n                 return \"null\";\n             \n             java.util.List<VueMetadataElement> list = current.getMetadataList().getMetadata();\n             while(list.size() < row + 1)\n               addNewRow();\n             \n             return current.getMetadataList().getMetadata().get(row);\n         }","id":24945,"modified_method":"public Object getValueAt(int row, int column)\n         {\n             \n             categoryIncluded.trimToSize();\n             \n             if(current == null)\n                 return \"null\";\n             \n             java.util.List<VueMetadataElement> list = current.getMetadataList().getMetadata();\n             while(list.size() < row + 1)\n               addNewRow();\n             \n             return current.getMetadataList().getCategoryListElement(row);\n         }","commit_id":"e652d1e26f86e0a1285d8d0e8919a0fc41ed09d8","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n   * Creates a database instance from the specified byte array.\n   * @param s input source\n   * @param it item type\n   * @return document node\n   * @throws XQException exception\n   */\n  protected final DBNode createNode(final Source s, final XQItemType it)\n      throws XQException {\n\n    valid(s, Source.class);\n    check(NodeType.DOC, it);\n    if(s instanceof SAXSource) {\n      return createNode((SAXSource) s);\n    } else if(s instanceof StreamSource) {\n      final StreamSource ss = (StreamSource) s;\n      final InputStream is = ss.getInputStream();\n      if(is != null) return createNode(is);\n      final Reader r = ss.getReader();\n      if(r != null) return createNode(r);\n      return createNode(IO.get(ss.getSystemId()));\n    }\n    Util.notimplemented();\n    return null;\n  }","id":24946,"modified_method":"/**\n   * Creates a database instance from the specified byte array.\n   * @param s input source\n   * @param it item type\n   * @return document node\n   * @throws XQException exception\n   */\n  protected final DBNode createNode(final Source s, final XQItemType it)\n      throws XQException {\n\n    valid(s, Source.class);\n    check(NodeType.DOC, it);\n    if(s instanceof SAXSource) {\n      return createNode((SAXSource) s);\n    } else if(s instanceof StreamSource) {\n      final StreamSource ss = (StreamSource) s;\n      final InputStream is = ss.getInputStream();\n      if(is != null) return createNode(is);\n      final Reader r = ss.getReader();\n      if(r != null) return createNode(r);\n      return createNode(IO.get(ss.getSystemId()));\n    }\n    throw Util.notimplemented();\n  }","commit_id":"3ad84987134fb90da37270e037f3e3d79e324787","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public void writeItemToResult(final Result result) throws XQException {\n    valid(result, Result.class);\n\n    // evaluate different result types...\n    if(result instanceof StreamResult) {\n      // StreamResult.. directly write result as string\n      writeItem(((StreamResult) result).getWriter(), null);\n    } else if(result instanceof SAXResult) {\n      try {\n        // SAXResult.. serialize result to underlying parser\n        final SAXSerializer ser = new SAXSerializer(null);\n        ser.setContentHandler(((SAXResult) result).getHandler());\n        serialize(it, ser);\n        ser.close();\n      } catch(final IOException ex) {\n        throw new BXQException(ex);\n      }\n    } else {\n      Util.notimplemented();\n    }\n  }","id":24947,"modified_method":"@Override\n  public void writeItemToResult(final Result result) throws XQException {\n    valid(result, Result.class);\n\n    // evaluate different result types...\n    if(result instanceof StreamResult) {\n      // StreamResult.. directly write result as string\n      writeItem(((StreamResult) result).getWriter(), null);\n    } else if(result instanceof SAXResult) {\n      try {\n        // SAXResult.. serialize result to underlying parser\n        final SAXSerializer ser = new SAXSerializer(null);\n        ser.setContentHandler(((SAXResult) result).getHandler());\n        serialize(it, ser);\n        ser.close();\n      } catch(final IOException ex) {\n        throw new BXQException(ex);\n      }\n    } else {\n      throw Util.notimplemented();\n    }\n  }","commit_id":"3ad84987134fb90da37270e037f3e3d79e324787","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void writeSequenceToResult(final Result res) throws XQException {\r\n    valid(res, Result.class);\r\n    if(it != null && !next) throw new BXQException(TWICE);\r\n\r\n    // evaluate different result types...\r\n    if(res instanceof StreamResult) {\r\n      // StreamResult.. directly write result as string\r\n      final StreamResult sr = (StreamResult) res;\r\n      if(sr.getWriter() != null) writeSequence(sr.getWriter(), null);\r\n      else writeSequence(sr.getOutputStream(), null);\r\n    } else if(res instanceof SAXResult) {\r\n      // SAXResult.. serialize result to underlying parser\r\n      final SAXSerializer ser = new SAXSerializer(null);\r\n      final SAXResult sax = (SAXResult) res;\r\n      ser.setContentHandler(sax.getHandler());\r\n      ser.setLexicalHandler(sax.getLexicalHandler());\r\n      while(next()) serialize(item().it, ser);\r\n    } else {\r\n      Util.notimplemented();\r\n    }\r\n  }","id":24948,"modified_method":"@Override\r\n  public void writeSequenceToResult(final Result res) throws XQException {\r\n    valid(res, Result.class);\r\n    if(it != null && !next) throw new BXQException(TWICE);\r\n\r\n    // evaluate different result types...\r\n    if(res instanceof StreamResult) {\r\n      // StreamResult.. directly write result as string\r\n      final StreamResult sr = (StreamResult) res;\r\n      if(sr.getWriter() != null) writeSequence(sr.getWriter(), null);\r\n      else writeSequence(sr.getOutputStream(), null);\r\n    } else if(res instanceof SAXResult) {\r\n      // SAXResult.. serialize result to underlying parser\r\n      final SAXSerializer ser = new SAXSerializer(null);\r\n      final SAXResult sax = (SAXResult) res;\r\n      ser.setContentHandler(sax.getHandler());\r\n      ser.setLexicalHandler(sax.getLexicalHandler());\r\n      while(next()) serialize(item().it, ser);\r\n    } else {\r\n      throw Util.notimplemented();\r\n    }\r\n  }","commit_id":"3ad84987134fb90da37270e037f3e3d79e324787","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n     * Implementation of the Clonable interface. Clones the current qualifier.\n     * @return cloned qualifier.\n     */\n    public Object clone() {\n        return new ERXQualifierInSubquery(qualifier, entityName, attributeName);\n    }","id":24949,"modified_method":"/**\n     * Implementation of the Clonable interface. Clones the current qualifier.\n     * @return cloned qualifier.\n     */\n    public Object clone() {\n        return new ERXQualifierInSubquery(qualifier, entityName, attributeName, destinationAttName);\n    }","commit_id":"ea0453df8c3ef24d9ade93595d923a73dd4ef4aa","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Public three argument constructor. Use\n     * this constructor for for building queries\n     * on foreign key attributes of the current\n     * entity.\n     * @param q sub qualifier\n     * @param entityName of the sub qualification\n     * @param attributeName foriegn key attribute name\n     */\n    // ENHANCEME: Should be able to just use a relationship key instead of both.\n    public ERXQualifierInSubquery(EOQualifier q, String entityName, String attributeName) {\n        super();\n        qualifier = q;\n        entityName = entityName;\n        attributeName = attributeName;\n    }","id":24950,"modified_method":"/**\n     * Public three argument constructor. Use\n     * this constructor for for building queries\n     * on foreign key attributes of the current\n     * entity.\n     * @param q sub qualifier\n     * @param entityName of the sub qualification\n     * @param attributeName foriegn key attribute name\n     */\n    // ENHANCEME: Should be able to just use a relationship key instead of both.\n    public ERXQualifierInSubquery(EOQualifier q, String entityName, String attributeName, String destinationAttName) {\n        super();\n        qualifier = q;\n        this.entityName = entityName;\n        this.attributeName = attributeName;\n        this.destinationAttName = destinationAttName;\n    }","commit_id":"ea0453df8c3ef24d9ade93595d923a73dd4ef4aa","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Public single argument constructor. Use\n     * this constructor for sub-qualification\n     * on the same table.\n     * @param q sub-qualifier\n     */\n    public ERXQualifierInSubquery(EOQualifier q) {        \n        this(q, null, null);\n    }","id":24951,"modified_method":"/**\n     * Public single argument constructor. Use\n     * this constructor for sub-qualification\n     * on the same table.\n     * @param q sub-qualifier\n     */\n    public ERXQualifierInSubquery(EOQualifier q) {        \n        this(q, null, null, null);\n    }","commit_id":"ea0453df8c3ef24d9ade93595d923a73dd4ef4aa","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Generates the sql string for the given sql expression.\n     * Bulk of the logic for generating the sub-query is in \n     * this method.\n     * @param e a given sql expression\n     * @return sql string for the current sub-query.\n     */\n    public String sqlStringForSQLExpression(EOSQLExpression e) {\n        StringBuffer sb = new StringBuffer();\n        if (attributeName != null)\n            sb.append(e.sqlStringForAttributeNamed(attributeName));\n        else {\n            EOAttribute pk = (EOAttribute)e.entity().primaryKeyAttributes().lastObject();\n            sb.append(e.sqlStringForAttribute(pk));            \n        }\n        sb.append(\" IN ( \");\n        EOEntity entity=entityName == null ? e.entity() : e.entity().model().entityNamed(entityName);\n        EOFetchSpecification fs=new EOFetchSpecification(entity.name(),\n                                                         qualifier,\n                                                         null,\n                                                         false,\n                                                         true,\n                                                         null);\n        // ASSUME: This makes a few assumptions, if anyone can figure out a full proof way that would be nice to get the model\n        //\t   Note you can't use: EOAdaptor.adaptorWithModel(e.entity().model()).expressionFactory(); as this creates a\n        //\n        EODatabaseContext context = EODatabaseContext.registeredDatabaseContextForModel(entity.model(),\n                                                                                        EOObjectStoreCoordinator.defaultCoordinator());\n        EOSQLExpressionFactory factory = context.database().adaptor().expressionFactory();\n        EOSQLExpression expression=factory.selectStatementForAttributes(entity.primaryKeyAttributes(),\n                                           false,\n                                           fs,\n                                           entity);\n\n        sb.append(expression.statement());        \n        sb.append(\" ) \");\n        return sb.toString();\n    }","id":24952,"modified_method":"/**\n     * Generates the sql string for the given sql expression.\n     * Bulk of the logic for generating the sub-query is in \n     * this method.\n     * @param e a given sql expression\n     * @return sql string for the current sub-query.\n     */\n    public String sqlStringForSQLExpression(EOSQLExpression e) {\n        StringBuffer sb = new StringBuffer();\n        if (attributeName != null)\n            sb.append(e.sqlStringForAttributeNamed(attributeName));\n        else {\n            EOAttribute pk = (EOAttribute)e.entity().primaryKeyAttributes().lastObject();\n            sb.append(e.sqlStringForAttribute(pk));            \n        }\n        sb.append(\" IN ( \");\n        EOEntity entity=entityName == null ? e.entity() : e.entity().model().entityNamed(entityName);\n\n        EOFetchSpecification fs=new EOFetchSpecification(entity.name(),\n                                                         qualifier,\n                                                         null,\n                                                         false,\n                                                         true,\n                                                         null);\n        // ASSUME: This makes a few assumptions, if anyone can figure out a full proof way that would be nice to get the model\n        //\t   Note you can't use: EOAdaptor.adaptorWithModel(e.entity().model()).expressionFactory(); as this creates a\n        //\n        EODatabaseContext context = EODatabaseContext.registeredDatabaseContextForModel(entity.model(),\n                                                                                        EOObjectStoreCoordinator.defaultCoordinator());\n        EOSQLExpressionFactory factory = context.database().adaptor().expressionFactory();\n\n        NSArray subAttributes = destinationAttName != null ? new NSArray(entity.attributeNamed(destinationAttName)) : entity.primaryKeyAttributes();\n        \n        EOSQLExpression subExpression = factory.expressionForEntity(entity);\n        subExpression.aliasesByRelationshipPath().setObjectForKey(\"t1\", \"\");\n        subExpression.setUseAliases(true);\n        subExpression.prepareSelectExpressionWithAttributes(subAttributes,\n                                                            false,\n                                                            fs);\n        //EOSQLExpression expression=factory.selectStatementForAttributes(entity.primaryKeyAttributes(),\n        //                                   false,\n        //                                   fs,\n        //                                   entity);\n\n        for (Enumeration bindEnumeration = subExpression.bindVariableDictionaries().objectEnumerator();\n             bindEnumeration.hasMoreElements();) {\n            e.addBindVariableDictionary((NSDictionary)bindEnumeration.nextElement());\n        }\n        \n        sb.append(ERXStringUtilities.replaceStringByStringInString(\"t0.\", \"t1.\", subExpression.statement()));        \n        sb.append(\" ) \");\n        return sb.toString();\n    }","commit_id":"ea0453df8c3ef24d9ade93595d923a73dd4ef4aa","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Creates the schema sql for a set of entities.\n\t * \n\t * @param entities\n\t *            the entities to create sql for\n\t * @param databaseContext\n\t *            the database context to use\n\t * @param optionsCreate\n\t *            the options (@see\n\t *            createSchemaSQLForEntitiesInModelWithNameAndOptions)\n\t * @return a sql script\n\t */\n\tpublic String createSchemaSQLForEntitiesWithOptions(NSArray<EOEntity> entities, EODatabaseContext databaseContext, NSDictionary<String, String> optionsCreate) {\n\t\t// get the JDBCAdaptor\n\t\tEOAdaptorContext ac = databaseContext.adaptorContext();\n\t\tEOSynchronizationFactory sf = ((JDBCAdaptor) ac.adaptor()).plugIn().createSynchronizationFactory();\n\t\treturn sf.schemaCreationScriptForEntities(entities, optionsCreate);\n\t}","id":24953,"modified_method":"/**\n\t * Creates the schema sql for a set of entities.\n\t * \n\t * @param entities\n\t *            the entities to create sql for\n\t * @param databaseContext\n\t *            the database context to use\n\t * @param optionsCreate\n\t *            the options (@see\n\t *            createSchemaSQLForEntitiesInModelWithNameAndOptions)\n\t * @return a sql script\n\t */\n\tpublic String createSchemaSQLForEntitiesWithOptions(NSArray<EOEntity> entities, EODatabaseContext databaseContext, NSDictionary<String, String> optionsCreate) {\n\t\treturn createSchemaSQLForEntitiesWithOptions(entities, databaseContext.adaptorContext().adaptor(), optionsCreate);\n\t}","commit_id":"f52c5bbb8010299b7ee5fc8bb70049ab1be90e42","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean tryLock(EOAdaptorChannel channel, EOModel model, String lockOwnerName) {\n\t\ttry {\n\t\t\tint count;\n\t\t\tJDBCChannel jdbcChannel = (JDBCChannel) channel;\n\t\t\tboolean wasOpen = true;\n\t\t\tif (!jdbcChannel.isOpen()) {\n\t\t\t\tjdbcChannel.openChannel();\n\t\t\t\twasOpen = false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tJDBCContext context = (JDBCContext) channel.adaptorContext();\n\t\t\t\tConnection connection = context.connection();\n\t\t\t\tStatement statement = connection.createStatement();\n\t\t\t\ttry {\n\t\t\t\t\tcount = statement.executeUpdate(\"update \\\"\" + _dbUpdaterTableName + \"\\\" set \\\"UpdateLock\\\" = 1, \\\"LockOwner\\\" = '\" + lockOwnerName + \"' where \\\"ModelName\\\" = '\" + model.name() + \"' and (\\\"UpdateLock\\\" = 0 or \\\"LockOwner\\\" = '\" + lockOwnerName + \"')\");\n\t\t\t\t\tif (count == 0) {\n\t\t\t\t\t\tResultSet resultSet = statement.executeQuery(\"select \\\"UpdateLock\\\" from \\\"\" + _dbUpdaterTableName + \"\\\" where \\\"ModelName\\\" = '\" + model.name() + \"'\");\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tensureModelRowExists(resultSet.next(), model);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tresultSet.close();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (ERXJDBCMigrationLock.log.isInfoEnabled()) {\n\t\t\t\t\t\t\tERXJDBCMigrationLock.log.info(\"Waiting on UpdateLock| for model '\" + model.name() + \"' ...\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tstatement.close();\n\t\t\t\t}\n\t\t\t\tif (count > 0 && !connection.getAutoCommit()) {\n\t\t\t\t\tconnection.commit();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (!wasOpen) {\n\t\t\t\t\tjdbcChannel.closeChannel();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count == 1;\n\t\t}\n\t\tcatch (ERXMigrationFailedException e) {\n\t\t\tthrow e;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ERXMigrationFailedException(\"Failed to lock \" + _dbUpdaterTableName + \" table.  It might be missing? Try executing:\\n\" + dbUpdaterCreateStatement(model) + \".\", e);\n\t\t}\n\t}","id":24954,"modified_method":"public boolean tryLock(EOAdaptorChannel channel, EOModel model, String lockOwnerName) {\n\t\ttry {\n\t\t\tint count;\n\t\t\tboolean wasOpen = true;\n\t\t\tif (!channel.isOpen()) {\n\t\t\t\tchannel.openChannel();\n\t\t\t\twasOpen = false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tEOModel dbUpdaterModel = dbUpdaterModelWithModel(model);\n\t\t\t\tNSMutableDictionary row = new NSMutableDictionary();\n\t\t\t\trow.setObjectForKey(new Integer(1), \"UpdateLock\");\n\t\t\t\trow.setObjectForKey(lockOwnerName, \"LockOwner\");\n\t\t\t\tEOEntity dbUpdaterEntity = dbUpdaterModel.entityNamed(_dbUpdaterTableName);\n\t\t\t\tcount = channel.updateValuesInRowsDescribedByQualifier(row, EOQualifier.qualifierWithQualifierFormat(\"ModelName = '\" + model.name() + \"' and (UpdateLock = 0 or LockOwner = '\" + lockOwnerName + \"')\", null), dbUpdaterEntity);\n\t\t\t\tchannel.cancelFetch();\n\t\t\t\tif (count == 0) {\n\t\t\t\t\tEOFetchSpecification fetchSpec = new EOFetchSpecification(_dbUpdaterTableName, new EOKeyValueQualifier(\"ModelName\", EOQualifier.QualifierOperatorEqual, model.name()), null);\n\t\t\t\t\tchannel.selectAttributes(new NSArray(dbUpdaterEntity.attributeNamed(\"UpdateLock\")), fetchSpec, false, dbUpdaterEntity);\n\t\t\t\t\tNSDictionary nextRow = channel.fetchRow();\n\t\t\t\t\tensureModelRowExists(nextRow != null, model);\n\t\t\t\t\tchannel.cancelFetch();\n\t\t\t\t\tif (ERXJDBCMigrationLock.log.isInfoEnabled()) {\n\t\t\t\t\t\tERXJDBCMigrationLock.log.info(\"Waiting on UpdateLock| for model '\" + model.name() + \"' ...\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tchannel.adaptorContext().commitTransaction();\n\t\t\t\tchannel.adaptorContext().beginTransaction();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (!wasOpen) {\n\t\t\t\t\tchannel.closeChannel();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count == 1;\n\t\t}\n\t\tcatch (ERXMigrationFailedException e) {\n\t\t\tthrow e;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ERXMigrationFailedException(\"Failed to lock \" + _dbUpdaterTableName + \" table.  It might be missing? Try executing:\\n\" + dbUpdaterCreateStatement(model) + \".\", e);\n\t\t}\n\t}","commit_id":"82d536dce21be3da8895a5687861daaf0226d061","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setVersionNumber(EOAdaptorChannel channel, EOModel model, int versionNumber) {\n\t\tJDBCChannel jdbcChannel = (JDBCChannel) channel;\n\t\tboolean wasOpen = true;\n\t\tif (!jdbcChannel.isOpen()) {\n\t\t\tjdbcChannel.openChannel();\n\t\t\twasOpen = false;\n\t\t}\n\t\ttry {\n\t\t\tJDBCContext context = (JDBCContext) channel.adaptorContext();\n\t\t\tConnection connection = context.connection();\n\t\t\tStatement statement = connection.createStatement();\n\t\t\ttry {\n\t\t\t\tint count = statement.executeUpdate(\"update \\\"\" + _dbUpdaterTableName + \"\\\" set \\\"Version\\\" = \" + versionNumber + \" where \\\"ModelName\\\" = '\" + model.name() + \"'\");\n\t\t\t\tensureModelRowExists(count != 0, model);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tstatement.close();\n\t\t\t}\n\t\t\tif (!connection.getAutoCommit()) {\n\t\t\t\tconnection.commit();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ERXMigrationFailedException(\"Failed to set version number of \" + _dbUpdaterTableName + \".\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!wasOpen) {\n\t\t\t\tjdbcChannel.closeChannel();\n\t\t\t}\n\t\t}\n\t}","id":24955,"modified_method":"public void setVersionNumber(EOAdaptorChannel channel, EOModel model, int versionNumber) {\n\t\tboolean wasOpen = true;\n\t\tif (!channel.isOpen()) {\n\t\t\tchannel.openChannel();\n\t\t\twasOpen = false;\n\t\t}\n\t\ttry {\n\t\t\tEOModel dbUpdaterModel = dbUpdaterModelWithModel(model);\n\t\t\tNSMutableDictionary row = new NSMutableDictionary();\n\t\t\trow.setObjectForKey(new Integer(versionNumber), \"Version\");\n\t\t\tEOEntity dbUpdaterEntity = dbUpdaterModel.entityNamed(_dbUpdaterTableName);\n\t\t\tint count = channel.updateValuesInRowsDescribedByQualifier(row, new EOKeyValueQualifier(\"ModelName\", EOQualifier.QualifierOperatorEqual, model.name()), dbUpdaterEntity);\n\t\t\tchannel.cancelFetch();\n\t\t\tensureModelRowExists(count != 0, model);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ERXMigrationFailedException(\"Failed to set version number of \" + _dbUpdaterTableName + \".\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!wasOpen) {\n\t\t\t\tchannel.closeChannel();\n\t\t\t}\n\t\t}\n\t}","commit_id":"82d536dce21be3da8895a5687861daaf0226d061","url":"https://github.com/wocommunity/wonder"},{"original_method":"public int versionNumber(EOAdaptorChannel channel, EOModel model) {\n\t\tint version;\n\t\tJDBCChannel jdbcChannel = (JDBCChannel) channel;\n\t\tboolean wasOpen = true;\n\t\tif (!jdbcChannel.isOpen()) {\n\t\t\tjdbcChannel.openChannel();\n\t\t\twasOpen = false;\n\t\t}\n\t\ttry {\n\t\t\tJDBCContext context = (JDBCContext) channel.adaptorContext();\n\t\t\tConnection connection = context.connection();\n\t\t\tStatement statement = connection.createStatement();\n\t\t\ttry {\n\t\t\t\tResultSet results = statement.executeQuery(\"select \\\"Version\\\" from \\\"\" + _dbUpdaterTableName + \"\\\" where \\\"ModelName\\\" = '\" + model.name() + \"'\");\n\t\t\t\ttry {\n\t\t\t\t\tif (results.next()) {\n\t\t\t\t\t\tversion = results.getInt(1);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tversion = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tresults.close();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tstatement.close();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ERXMigrationFailedException(\"Failed to get version number from \" + _dbUpdaterTableName + \" table.\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!wasOpen) {\n\t\t\t\tjdbcChannel.closeChannel();\n\t\t\t}\n\t\t}\n\t\treturn version;\n\t}","id":24956,"modified_method":"public int versionNumber(EOAdaptorChannel channel, EOModel model) {\n\t\tboolean wasOpen = true;\n\t\tif (!channel.isOpen()) {\n\t\t\tchannel.openChannel();\n\t\t\twasOpen = false;\n\t\t}\n\t\tint version;\n\t\ttry {\n\t\t\tEOModel dbUpdaterModel = dbUpdaterModelWithModel(model);\n\t\t\tEOEntity dbUpdaterEntity = dbUpdaterModel.entityNamed(_dbUpdaterTableName);\n\t\t\tEOFetchSpecification fetchSpec = new EOFetchSpecification(_dbUpdaterTableName, new EOKeyValueQualifier(\"ModelName\", EOQualifier.QualifierOperatorEqual, model.name()), null);\n\t\t\tchannel.selectAttributes(new NSArray(dbUpdaterEntity.attributeNamed(\"Version\")), fetchSpec, false, dbUpdaterEntity);\n\t\t\tNSDictionary nextRow = channel.fetchRow();\n\t\t\tif (nextRow == null) {\n\t\t\t\tversion = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tInteger versionInteger = (Integer) nextRow.objectForKey(\"Version\");\n\t\t\t\tversion = versionInteger.intValue();\n\t\t\t}\n\t\t\tchannel.cancelFetch();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ERXMigrationFailedException(\"Failed to get version number from \" + _dbUpdaterTableName + \" table.\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!wasOpen) {\n\t\t\t\tchannel.closeChannel();\n\t\t\t}\n\t\t}\n\t\treturn version;\n\t}","commit_id":"82d536dce21be3da8895a5687861daaf0226d061","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void unlock(EOAdaptorChannel channel, EOModel model) {\n\t\tJDBCChannel jdbcChannel = (JDBCChannel) channel;\n\t\tboolean wasOpen = true;\n\t\tif (!jdbcChannel.isOpen()) {\n\t\t\tjdbcChannel.openChannel();\n\t\t\twasOpen = false;\n\t\t}\n\t\ttry {\n\t\t\tJDBCContext context = (JDBCContext) channel.adaptorContext();\n\t\t\tConnection connection = context.connection();\n\t\t\tStatement statement = connection.createStatement();\n\t\t\ttry {\n\t\t\t\tstatement.executeUpdate(\"update \\\"\" + _dbUpdaterTableName + \"\\\" set \\\"UpdateLock\\\" = 0, \\\"LockOwner\\\" = NULL where \\\"ModelName\\\" = '\" + model.name() + \"'\");\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tstatement.close();\n\t\t\t}\n\t\t\tif (!connection.getAutoCommit()) {\n\t\t\t\tconnection.commit();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ERXMigrationFailedException(\"Failed to unlock \" + _dbUpdaterTableName + \" table.\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!wasOpen) {\n\t\t\t\tjdbcChannel.closeChannel();\n\t\t\t}\n\t\t}\n\t}","id":24957,"modified_method":"public void unlock(EOAdaptorChannel channel, EOModel model) {\n\t\tboolean wasOpen = true;\n\t\tif (!channel.isOpen()) {\n\t\t\tchannel.openChannel();\n\t\t\twasOpen = false;\n\t\t}\n\t\ttry {\n\t\t\tEOModel dbUpdaterModel = dbUpdaterModelWithModel(model);\n\t\t\tNSMutableDictionary row = new NSMutableDictionary();\n\t\t\trow.setObjectForKey(new Integer(0), \"UpdateLock\");\n\t\t\trow.setObjectForKey(NSKeyValueCoding.NullValue, \"LockOwner\");\n\t\t\tEOEntity dbUpdaterEntity = dbUpdaterModel.entityNamed(_dbUpdaterTableName);\n\t\t\tchannel.updateValuesInRowsDescribedByQualifier(row, new EOKeyValueQualifier(\"ModelName\", EOQualifier.QualifierOperatorEqual, model.name()), dbUpdaterEntity);\n\t\t\tchannel.cancelFetch();\n\t\t\tchannel.adaptorContext().commitTransaction();\n\t\t\tchannel.adaptorContext().beginTransaction();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new ERXMigrationFailedException(\"Failed to unlock \" + _dbUpdaterTableName + \" table.\", e);\n\t\t}\n\t\tfinally {\n\t\t\tif (!wasOpen) {\n\t\t\t\tchannel.closeChannel();\n\t\t\t}\n\t\t}\n\t}","commit_id":"82d536dce21be3da8895a5687861daaf0226d061","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected EOModel dbUpdaterModelWithModel(EOModel model) {\n\t\tEOModel dbUpdateModel = new EOModel();\n\t\tdbUpdateModel.setConnectionDictionary(model.connectionDictionary());\n\t\tdbUpdateModel.setAdaptorName(model.adaptorName());\n\t\tEOAdaptor adaptor = EOAdaptor.adaptorWithModel(model);\n\n\t\tEOEntity dbUpdaterEntity = new EOEntity();\n\t\tdbUpdaterEntity.setExternalName(_dbUpdaterTableName);\n\t\tdbUpdaterEntity.setName(_dbUpdaterTableName);\n\t\tdbUpdateModel.addEntity(dbUpdaterEntity);\n\n\t\tEOAttribute modelNameAttribute = new EOAttribute();\n\t\tmodelNameAttribute.setName(\"ModelName\");\n\t\tmodelNameAttribute.setColumnName(\"ModelName\");\n\t\tmodelNameAttribute.setClassName(\"java.lang.String\");\n\t\tmodelNameAttribute.setWidth(100);\n\t\tmodelNameAttribute.setAllowsNull(false);\n\t\tadaptor.assignExternalTypeForAttribute(modelNameAttribute);\n\t\tdbUpdaterEntity.addAttribute(modelNameAttribute);\n\n\t\tEOAttribute versionAttribute = new EOAttribute();\n\t\tversionAttribute.setName(\"Version\");\n\t\tversionAttribute.setColumnName(\"Version\");\n\t\tversionAttribute.setClassName(\"java.lang.Number\");\n\t\tversionAttribute.setAllowsNull(false);\n\t\tadaptor.assignExternalTypeForAttribute(versionAttribute);\n\t\tdbUpdaterEntity.addAttribute(versionAttribute);\n\n\t\tEOAttribute updateLockAttribute = new EOAttribute();\n\t\tupdateLockAttribute.setName(\"UpdateLock\");\n\t\tupdateLockAttribute.setColumnName(\"UpdateLock\");\n\t\tupdateLockAttribute.setClassName(\"java.lang.Number\");\n\t\tupdateLockAttribute.setAllowsNull(false);\n\t\tadaptor.assignExternalTypeForAttribute(updateLockAttribute);\n\t\tdbUpdaterEntity.addAttribute(updateLockAttribute);\n\n\t\tEOAttribute lockOwnerAttribute = new EOAttribute();\n\t\tlockOwnerAttribute.setName(\"LockOwner\");\n\t\tlockOwnerAttribute.setColumnName(\"LockOwner\");\n\t\tlockOwnerAttribute.setClassName(\"java.lang.String\");\n\t\tlockOwnerAttribute.setWidth(100);\n\t\tlockOwnerAttribute.setAllowsNull(true);\n\t\tadaptor.assignExternalTypeForAttribute(lockOwnerAttribute);\n\t\tdbUpdaterEntity.addAttribute(lockOwnerAttribute);\n\n\t\treturn dbUpdateModel;\n\t}","id":24958,"modified_method":"protected EOModel dbUpdaterModelWithModel(EOModel model) {\n\t\tEOModel dbUpdateModel = new EOModel();\n\n\t\tEOEntity dbUpdaterEntity = new EOEntity();\n\t\tdbUpdaterEntity.setExternalName(_dbUpdaterTableName);\n\t\tdbUpdaterEntity.setName(_dbUpdaterTableName);\n\t\tdbUpdateModel.addEntity(dbUpdaterEntity);\n\n\t\tEOAttribute modelNameAttribute = new EOAttribute();\n\t\tmodelNameAttribute.setName(\"ModelName\");\n\t\tmodelNameAttribute.setColumnName(\"ModelName\");\n\t\tmodelNameAttribute.setClassName(\"java.lang.String\");\n\t\tmodelNameAttribute.setWidth(100);\n\t\tmodelNameAttribute.setAllowsNull(false);\n\t\tdbUpdaterEntity.addAttribute(modelNameAttribute);\n\n\t\tEOAttribute versionAttribute = new EOAttribute();\n\t\tversionAttribute.setName(\"Version\");\n\t\tversionAttribute.setColumnName(\"Version\");\n\t\tversionAttribute.setClassName(\"java.lang.Number\");\n\t\tversionAttribute.setAllowsNull(false);\n\t\tdbUpdaterEntity.addAttribute(versionAttribute);\n\n\t\tEOAttribute updateLockAttribute = new EOAttribute();\n\t\tupdateLockAttribute.setName(\"UpdateLock\");\n\t\tupdateLockAttribute.setColumnName(\"UpdateLock\");\n\t\tupdateLockAttribute.setClassName(\"java.lang.Number\");\n\t\tupdateLockAttribute.setAllowsNull(false);\n\t\tdbUpdaterEntity.addAttribute(updateLockAttribute);\n\n\t\tEOAttribute lockOwnerAttribute = new EOAttribute();\n\t\tlockOwnerAttribute.setName(\"LockOwner\");\n\t\tlockOwnerAttribute.setColumnName(\"LockOwner\");\n\t\tlockOwnerAttribute.setClassName(\"java.lang.String\");\n\t\tlockOwnerAttribute.setWidth(100);\n\t\tlockOwnerAttribute.setAllowsNull(true);\n\t\tdbUpdaterEntity.addAttribute(lockOwnerAttribute);\n\n\t\tdbUpdateModel.setConnectionDictionary(model.connectionDictionary());\n\t\tdbUpdateModel.setAdaptorName(model.adaptorName());\n\t\tEOAdaptor adaptor = EOAdaptor.adaptorWithModel(model);\n\t\tadaptor.assignExternalTypeForAttribute(modelNameAttribute);\n\t\tadaptor.assignExternalTypeForAttribute(versionAttribute);\n\t\tadaptor.assignExternalTypeForAttribute(updateLockAttribute);\n\t\tadaptor.assignExternalTypeForAttribute(lockOwnerAttribute);\n\t\treturn dbUpdateModel;\n\t}","commit_id":"82d536dce21be3da8895a5687861daaf0226d061","url":"https://github.com/wocommunity/wonder"},{"original_method":"public Expression parseExpression(XelContext xelc, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\ttry {\n\t\t\treturn new ELXelExpression(\n\t\t\t\t_eval.parseExpression(expression, expectedType,\n\t\t\t\t\txelc != null ? new XelELMapper(xelc.getFunctionMapper()): null));\n\t\t} catch (ELException ex) {\n\t\t\tthrow new XelException(\"Failed to parse \"+expression, ex);\n\t\t}\n\t}","id":24959,"modified_method":"public Expression parseExpression(XelContext xelc, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\tFunctionMapper mapper = xelc != null ? xelc.getFunctionMapper(): null;\n\t\ttry {\n\t\t\treturn new ELXelExpression(\n\t\t\t\t_eval.parseExpression(expression, expectedType,\n\t\t\t\t\tmapper != null ? new XelELMapper(mapper): null),\n\t\t\t\t\texpression, mapper, expectedType);\n\t\t} catch (ELException ex) {\n\t\t\tthrow new XelException(\"Failed to parse \"+expression, ex);\n\t\t}\n\t}","commit_id":"07cbbae120aa51eb3e6248fb9913a13646e51aca","url":"https://github.com/zkoss/zk"},{"original_method":"public Expression parseExpression(XelContext xelc, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\treturn new ELXelExpression(\n\t\t\t_eval.parseExpression(expression, expectedType,\n\t\t\t\txelc != null ? xelc.getFunctionMapper(): null));\n\t}","id":24960,"modified_method":"public Expression parseExpression(XelContext xelc, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\tFunctionMapper mapper = xelc != null ? xelc.getFunctionMapper(): null;\n\t\treturn new ELXelExpression(\n\t\t\t_eval.parseExpression(expression, expectedType, mapper),\n\t\t\texpression, mapper, expectedType);\n\t}","commit_id":"07cbbae120aa51eb3e6248fb9913a13646e51aca","url":"https://github.com/zkoss/zk"},{"original_method":"public Object evaluate(XelContext ctx) {\n\t\treturn _expr.evaluate(ctx.getVariableResolver());\n\t}","id":24961,"modified_method":"public Object evaluate(XelContext ctx) {\n\t\t//Test case: B30-1957661.zul where a function mapper is created\n\t\t//by zscript so it is different from one page to page\n\t\t//In this case, we cannot reuse parsed expression.\n\t\t//\n\t\t//Note: if nfm is null, we consider it as not-change since DSP\n\t\t//doesn't save function mapper when evaluating\n\t\tfinal FunctionMapper nfm = ctx.getFunctionMapper();\n\t\tif (nfm != null && _mapper != nfm)\n\t\t\treturn new ELFactory().evaluate(ctx, _rawexpr, _expected);\n\t\treturn _expr.evaluate(ctx.getVariableResolver());\n\t}","commit_id":"07cbbae120aa51eb3e6248fb9913a13646e51aca","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * @param expr the expression. It cannot be null.\n\t */\n\tpublic ELXelExpression(javax.servlet.jsp.el.Expression expr) {\n\t\tif (expr == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\t_expr = expr;\n\t}","id":24962,"modified_method":"/**\n\t * @param expr the expression. It cannot be null.\n\t */\n\tpublic ELXelExpression(javax.servlet.jsp.el.Expression expr,\n\tString rawexpr, FunctionMapper mapper, Class expectedType) {\n\t\tif (expr == null)\n\t\t\tthrow new IllegalArgumentException();\n\t\t_rawexpr = rawexpr;\n\t\t_expr = expr;\n\t\t_mapper = mapper;\n\t\t_expected = expectedType;\n\t}","commit_id":"07cbbae120aa51eb3e6248fb9913a13646e51aca","url":"https://github.com/zkoss/zk"},{"original_method":"public Object evaluate(XelContext ctx) {\n\t\ttry {\n\t\t\tfinal VariableResolver resolver = ctx.getVariableResolver();\n\t\t\treturn _expr.evaluate(\n\t\t\t\tresolver != null ? new XelELResolver(resolver): null);\n\t\t} catch (ELException ex) {\n\t\t\tthrow new XelException(ex);\n\t\t}\n\t}","id":24963,"modified_method":"public Object evaluate(XelContext ctx) {\n\t\t//Test case: B30-1957661.zul where a function mapper is created\n\t\t//by zscript so it is different from one page to page\n\t\t//In this case, we cannot reuse parsed expression.\n\t\t//\n\t\t//Note: if nfm is null, we consider it as not-change since DSP\n\t\t//doesn't save function mapper when evaluating\n\t\ttry {\n\t\t\tfinal FunctionMapper nfm = ctx.getFunctionMapper();\n\t\t\tif (nfm != null && _mapper != nfm)\n\t\t\t\treturn new ApacheELFactory().evaluate(ctx, _rawexpr, _expected);\n\n\t\t\tfinal VariableResolver resolver = ctx.getVariableResolver();\n\t\t\treturn _expr.evaluate(\n\t\t\t\tresolver != null ? new XelELResolver(resolver): null);\n\t\t} catch (ELException ex) {\n\t\t\tthrow new XelException(ex);\n\t\t}\n\t}","commit_id":"07cbbae120aa51eb3e6248fb9913a13646e51aca","url":"https://github.com/zkoss/zk"},{"original_method":"public ELFactory() {\n\t\t_eval = newExpressionEvaluator();\n\t}","id":24964,"modified_method":"public ELFactory() {\n\t\t_eval = new ExpressionEvaluatorImpl();\n\t}","commit_id":"013034165e4f13d7aa6cb0e1a82688117febfd78","url":"https://github.com/zkoss/zk"},{"original_method":"public Object evaluate(XelContext xelc, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\ttry {\n\t\t\treturn _eval.evaluate(expression, expectedType,\n\t\t\t\txelc != null ?\n\t\t\t\t\tnew XelELResolver(xelc.getVariableResolver()): null,\n\t\t\t\txelc != null ?\n\t\t\t\t\tnew XelELMapper(xelc.getFunctionMapper()): null);\n\t\t} catch (ELException ex) {\n\t\t\tthrow new XelException(\"Failed to evaluate \"+expression, ex);\n\t\t}\n\t}","id":24965,"modified_method":"public Object evaluate(XelContext xelc, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\treturn _eval.evaluate(expression, expectedType,\n\t\t\txelc != null ? xelc.getVariableResolver(): null,\n\t\t\txelc != null ? xelc.getFunctionMapper(): null);\n\t}","commit_id":"013034165e4f13d7aa6cb0e1a82688117febfd78","url":"https://github.com/zkoss/zk"},{"original_method":"public Expression parseExpression(XelContext xelc, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\ttry {\n\t\t\treturn new ELXelExpression(\n\t\t\t\t_eval.parseExpression(expression, expectedType,\n\t\t\t\t\txelc != null ? new XelELMapper(xelc.getFunctionMapper()): null));\n\t\t} catch (ELException ex) {\n\t\t\tthrow new XelException(\"Failed to parse \"+expression, ex);\n\t\t}\n\t}","id":24966,"modified_method":"public Expression parseExpression(XelContext xelc, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\treturn new ELXelExpression(\n\t\t\t_eval.parseExpression(expression, expectedType,\n\t\t\t\txelc != null ? xelc.getFunctionMapper(): null));\n\t}","commit_id":"013034165e4f13d7aa6cb0e1a82688117febfd78","url":"https://github.com/zkoss/zk"},{"original_method":"public Object evaluate(XelContext ctx) {\n\t\ttry {\n\t\t\tfinal VariableResolver resolver = ctx.getVariableResolver();\n\t\t\treturn _expr.evaluate(\n\t\t\t\tresolver != null ? new XelELResolver(resolver): null);\n\t\t} catch (ELException ex) {\n\t\t\tthrow new XelException(ex);\n\t\t}\n\t}","id":24967,"modified_method":"public Object evaluate(XelContext ctx) {\n\t\treturn _expr.evaluate(ctx.getVariableResolver());\n\t}","commit_id":"013034165e4f13d7aa6cb0e1a82688117febfd78","url":"https://github.com/zkoss/zk"},{"original_method":"/** Unwraps an exception if the enclosing one is InvocationTargetException\n\t * or UndeclaredThrowableException.\n\t * <p>Use it if you are catching exceptions thrown by Method.invoke().\n\t */\n\tpublic static final Throwable unwrap(Throwable ex) {\n\t\tfor (;;) {\n\t\t\tif (ex instanceof InvocationTargetException)\n\t\t\t\tex = ex.getCause(); //might returns UndeclaredThrowableException\n\t\t\telse if (ex instanceof UndeclaredThrowableException)\n\t\t\t\tex = ex.getCause();\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tif (ex instanceof bsh.TargetError) {\n\t\t\t\t\t\tfinal Throwable t = ((bsh.TargetError)ex).getTarget();\n\t\t\t\t\t\tif (t != null) ex = t;\n\t\t\t\t\t} else if (ex instanceof bsh.UtilTargetError) {\n\t\t\t\t\t\tfinal Throwable t = ((bsh.UtilTargetError)ex).t;\n\t\t\t\t\t\tif (t != null) ex = t;\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable e2) {\n\t\t\t\t\tif (log.debugable()) log.debug(\"Ignored: unable to resolve \" + ex.getClass());\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif (ex instanceof javax.servlet.jsp.el.ELException) {\n\t\t\t\t\t\tfinal Throwable t =\n\t\t\t\t\t\t\t((javax.servlet.jsp.el.ELException)ex).getRootCause();\n\t\t\t\t\t\tif (t != null) ex = t;\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable e2) {\n\t\t\t\t\tif (log.debugable()) log.debug(\"Ignored: unable to resolve \" + ex.getClass());\n\t\t\t\t}\n\t\t\t\treturn ex;\n\t\t\t}\n\t\t\tassert D.OFF || ex != null: \"null cause\";\n\t\t}\n\t}","id":24968,"modified_method":"/** Unwraps an exception if the enclosing one is InvocationTargetException\n\t * or UndeclaredThrowableException.\n\t * <p>Use it if you are catching exceptions thrown by Method.invoke().\n\t */\n\tpublic static final Throwable unwrap(Throwable ex) {\n\t\tfor (;;) {\n\t\t\tif (ex instanceof InvocationTargetException)\n\t\t\t\tex = ex.getCause(); //might returns UndeclaredThrowableException\n\t\t\telse if (ex instanceof UndeclaredThrowableException)\n\t\t\t\tex = ex.getCause();\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tif (ex instanceof bsh.TargetError) {\n\t\t\t\t\t\tfinal Throwable t = ((bsh.TargetError)ex).getTarget();\n\t\t\t\t\t\tif (t != null) ex = t;\n\t\t\t\t\t} else if (ex instanceof bsh.UtilTargetError) {\n\t\t\t\t\t\tfinal Throwable t = ((bsh.UtilTargetError)ex).t;\n\t\t\t\t\t\tif (t != null) ex = t;\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable e2) {\n\t\t\t\t\tif (log.debugable()) log.debug(\"Ignored: unable to resolve \" + ex.getClass());\n\t\t\t\t}\n//Remove the dependence on EL\n/*\t\t\t\ttry {\n\t\t\t\t\tif (ex instanceof javax.servlet.jsp.el.ELException) {\n\t\t\t\t\t\tfinal Throwable t =\n\t\t\t\t\t\t\t((javax.servlet.jsp.el.ELException)ex).getRootCause();\n\t\t\t\t\t\tif (t != null) ex = t;\n\t\t\t\t\t}\n\t\t\t\t} catch (Throwable e2) {\n\t\t\t\t\tif (log.debugable()) log.debug(\"Ignored: unable to resolve \" + ex.getClass());\n\t\t\t\t}*/\n\t\t\t\treturn ex;\n\t\t\t}\n\t\t\tassert D.OFF || ex != null: \"null cause\";\n\t\t}\n\t}","commit_id":"013034165e4f13d7aa6cb0e1a82688117febfd78","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the cause of the given throwable. It is the same as\n\t * t.getCause, but it solves the compatibility of J2EE that might not\n\t * support JDK 1.4.\n\t */\n\tpublic static final Throwable getCause(Throwable ex) {\n\t\tThrowable t = ex.getCause();\n\t\tif (t == null)\n\t\t\ttry {\n\t\t\t\tif (ex instanceof java.rmi.RemoteException) {\n\t\t\t\t\treturn ((java.rmi.RemoteException)ex).detail;\n\t\t\t\t} else if (ex instanceof org.xml.sax.SAXException) {\n\t\t\t\t\treturn ((org.xml.sax.SAXException)ex).getException();\n\t\t\t\t} else if (ex instanceof javax.servlet.ServletException) {\n\t\t\t\t\treturn ((javax.servlet.ServletException)ex).getRootCause();\n\t\t\t\t} else if (ex instanceof javax.servlet.jsp.el.ELException) {\n\t\t\t\t\treturn ((javax.servlet.jsp.el.ELException)ex).getRootCause();\n\t\t\t\t} else if (ex instanceof javax.servlet.jsp.JspException) {\n\t\t\t\t\treturn ((javax.servlet.jsp.JspException)ex).getRootCause();\n\t\t\t\t} else if (ex instanceof bsh.TargetError) {\n\t\t\t\t\treturn ((bsh.TargetError)ex).getTarget();\n\t\t\t\t} else if (ex instanceof bsh.UtilTargetError) {\n\t\t\t\t\treturn ((bsh.UtilTargetError)ex).t;\n//Remove the dependence on EJB\n//\t\t\t\t} else if (ex instanceof javax.ejb.EJBException) {\n//\t\t\t\t\treturn ((javax.ejb.EJBException)ex).getCausedByException();\n\t\t\t\t}\n\t\t\t} catch (Throwable e2) {\n\t\t\t\tif (log.debugable()) log.debug(\"Ignored: unable to resolve \" + ex.getClass());\n\t\t\t}\n\t\treturn t;\n\t}","id":24969,"modified_method":"/** Returns the cause of the given throwable. It is the same as\n\t * t.getCause, but it solves the compatibility of J2EE that might not\n\t * support JDK 1.4.\n\t */\n\tpublic static final Throwable getCause(Throwable ex) {\n\t\tThrowable t = ex.getCause();\n\t\tif (t == null)\n\t\t\ttry {\n\t\t\t\tif (ex instanceof java.rmi.RemoteException) {\n\t\t\t\t\treturn ((java.rmi.RemoteException)ex).detail;\n\t\t\t\t} else if (ex instanceof org.xml.sax.SAXException) {\n\t\t\t\t\treturn ((org.xml.sax.SAXException)ex).getException();\n\t\t\t\t} else if (ex instanceof javax.servlet.ServletException) {\n\t\t\t\t\treturn ((javax.servlet.ServletException)ex).getRootCause();\n\t\t\t\t} else if (ex instanceof bsh.TargetError) {\n\t\t\t\t\treturn ((bsh.TargetError)ex).getTarget();\n\t\t\t\t} else if (ex instanceof bsh.UtilTargetError) {\n\t\t\t\t\treturn ((bsh.UtilTargetError)ex).t;\n//Remove the dependence on EJB\n//\t\t\t\t} else if (ex instanceof javax.ejb.EJBException) {\n//\t\t\t\t\treturn ((javax.ejb.EJBException)ex).getCausedByException();\n//Remove the dependence on JSP\n//\t\t\t\t} else if (ex instanceof javax.servlet.jsp.JspException) {\n//\t\t\t\t\treturn ((javax.servlet.jsp.JspException)ex).getRootCause();\n//Remove the dependence on EL\n//\t\t\t\t} else if (ex instanceof javax.servlet.jsp.el.ELException) {\n//\t\t\t\t\treturn ((javax.servlet.jsp.el.ELException)ex).getRootCause();\n\t\t\t\t}\n\t\t\t} catch (Throwable e2) {\n\t\t\t\tif (log.debugable()) log.debug(\"Ignored: unable to resolve \" + ex.getClass());\n\t\t\t}\n\t\treturn t;\n\t}","commit_id":"013034165e4f13d7aa6cb0e1a82688117febfd78","url":"https://github.com/zkoss/zk"},{"original_method":"public void setSelected(AnActionEvent e, boolean state) {\n    final EditorEx editor = getEditor(e);\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    if (state) {\n      boolean hasSelection = selectionModel.hasSelection();\n      int selStart = selectionModel.getSelectionStart();\n      int selEnd = selectionModel.getSelectionEnd();\n      final CaretModel caretModel = editor.getCaretModel();\n      LogicalPosition blockStart = selStart == caretModel.getOffset()\n                                   ? caretModel.getLogicalPosition()\n                                   : editor.offsetToLogicalPosition(selStart);\n      LogicalPosition blockEnd = selEnd == caretModel.getOffset()\n                                 ? caretModel.getLogicalPosition()\n                                 : editor.offsetToLogicalPosition(selEnd);\n      editor.setColumnMode(true);\n      if (hasSelection) {\n        selectionModel.setBlockSelection(blockStart, blockEnd);\n      }\n      else {\n        selectionModel.removeSelection();\n      }\n    }\n    else {\n      boolean hasSelection = selectionModel.hasBlockSelection();\n      int selStart = editor.logicalPositionToOffset(selectionModel.getBlockStart());\n      int selEnd = editor.logicalPositionToOffset(selectionModel.getBlockEnd());\n      editor.setColumnMode(false);\n      if (hasSelection) {\n        selectionModel.setSelection(selStart, selEnd);\n      }\n      else {\n        selectionModel.removeSelection();\n      }\n    }\n  }","id":24970,"modified_method":"public void setSelected(AnActionEvent e, boolean state) {\n    final EditorEx editor = getEditor(e);\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    if (state) {\n      boolean hasSelection = selectionModel.hasSelection();\n      int selStart = selectionModel.getSelectionStart();\n      int selEnd = selectionModel.getSelectionEnd();\n      final CaretModel caretModel = editor.getCaretModel();\n      LogicalPosition blockStart = selStart == caretModel.getOffset()\n                                   ? caretModel.getLogicalPosition()\n                                   : editor.offsetToLogicalPosition(selStart);\n      LogicalPosition blockEnd = selEnd == caretModel.getOffset()\n                                 ? caretModel.getLogicalPosition()\n                                 : editor.offsetToLogicalPosition(selEnd);\n      editor.setColumnMode(true);\n      if (hasSelection) {\n        selectionModel.setBlockSelection(blockStart, blockEnd);\n      }\n      else {\n        selectionModel.removeSelection();\n      }\n    }\n    else {\n      boolean hasSelection = selectionModel.hasBlockSelection();\n      int selStart = hasSelection ? editor.logicalPositionToOffset(selectionModel.getBlockStart()) : 0;\n      int selEnd = hasSelection ? editor.logicalPositionToOffset(selectionModel.getBlockEnd()) : 0;\n      editor.setColumnMode(false);\n      if (hasSelection) {\n        selectionModel.setSelection(selStart, selEnd);\n      }\n      else {\n        selectionModel.removeSelection();\n      }\n    }\n  }","commit_id":"dad7df2cba491636b47ae319e7f33db37258d7a7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void selectLookupItem(final LookupItem item, final boolean signatureSelected, final char completionChar, final CompletionContext context,\n                                        final LookupData data) {\n    insertLookupString(context, context.editor.getCaretModel().getOffset(), item.getLookupString());\n    final int caretOffset = context.editor.getCaretModel().getOffset();\n\n    final int previousSelectionEndOffset = context.getSelectionEndOffset();\n\n    context.setSelectionEndOffset(caretOffset);\n    final int identifierEndOffset =\n      CompletionUtil.isOverwrite(item, completionChar) && previousSelectionEndOffset ==\n                                                          context.getOffsetMap().getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET) ?\n      caretOffset:Math.max(caretOffset, context.getOffsetMap().getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n    context.getOffsetMap().addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, identifierEndOffset, true);\n    lookupItemSelected(context, data, item, signatureSelected, completionChar);\n  }","id":24971,"modified_method":"protected final void selectLookupItem(final LookupItem item, final boolean signatureSelected, final char completionChar, final CompletionContext context,\n                                        final LookupData data) {\n    insertLookupString(context, context.editor.getCaretModel().getOffset(), item.getLookupString());\n    final int caretOffset = context.editor.getCaretModel().getOffset();\n\n    final int previousSelectionEndOffset = context.getSelectionEndOffset();\n\n    context.setSelectionEndOffset(caretOffset);\n    final int identifierEndOffset =\n      CompletionUtil.isOverwrite(item, completionChar) && previousSelectionEndOffset ==\n                                                          context.getOffsetMap().getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET) ?\n      caretOffset:Math.max(caretOffset, context.getOffsetMap().getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n    context.getOffsetMap().addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, identifierEndOffset);\n    lookupItemSelected(context, data, item, signatureSelected, completionChar);\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Pair<CompletionContext, PsiElement> insertDummyIdentifier(final CompletionContext context) {\n    PsiFile oldFileCopy = createFileCopy(context.file);\n    PsiFile hostFile = InjectedLanguageUtil.getTopLevelFile(oldFileCopy);\n    Project project = hostFile.getProject();\n    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(project);\n    // is null in tests\n    int hostStartOffset = injectedLanguageManager == null ? context.getStartOffset() : injectedLanguageManager.injectedToHost(oldFileCopy, TextRange.from(\n      context.getStartOffset(), 0)).getStartOffset();\n    Document document = oldFileCopy.getViewProvider().getDocument();\n\n    document.insertString(context.getStartOffset(), CompletionUtil.DUMMY_IDENTIFIER);\n    PsiDocumentManager.getInstance(project).commitDocument(document);\n    PsiFile fileCopy = InjectedLanguageUtil.findInjectedPsiAt(hostFile, hostStartOffset);\n    if (fileCopy == null) {\n      PsiElement elementAfterCommit = findElementAt(hostFile, hostStartOffset);\n      fileCopy = elementAfterCommit == null ? oldFileCopy : elementAfterCommit.getContainingFile();\n    }\n\n    if (oldFileCopy != fileCopy) {\n      // newly inserted identifier can well end up in the injected language region\n      Editor oldEditor = context.editor;\n      Editor editor = EditorFactory.getInstance().createEditor(document, project);\n      Editor newEditor = InjectedLanguageUtil.getEditorForInjectedLanguage(editor, hostFile, context.getStartOffset());\n      if (newEditor instanceof EditorWindow) {\n        EditorWindow injectedEditor = (EditorWindow)newEditor;\n        int newOffset1 = injectedEditor.logicalPositionToOffset(injectedEditor.hostToInjected(oldEditor.offsetToLogicalPosition(context.getStartOffset())));\n        int newOffset2 = injectedEditor.logicalPositionToOffset(injectedEditor.hostToInjected(oldEditor.offsetToLogicalPosition(context.getSelectionEndOffset())));\n        PsiFile injectedFile = injectedEditor.getInjectedFile();\n        CompletionContext newContext = new CompletionContext(context.project, injectedEditor, injectedFile, context.getOffsetMap());\n        PsiElement element = findElementAt(injectedFile, newContext.getStartOffset());\n        if (element == null) {\n          LOG.assertTrue(false, \"offset \" + newContext.getStartOffset() + \" at:\\n\" + injectedFile.getText());\n        }\n        EditorFactory.getInstance().releaseEditor(editor);\n        return Pair.create(newContext, element);\n      }\n      EditorFactory.getInstance().releaseEditor(editor);\n    }\n    PsiElement element = findElementAt(fileCopy, context.getStartOffset());\n    if (element == null) {\n      LOG.assertTrue(false, \"offset \" + context.getStartOffset() + \" at:\\n\" + fileCopy.getText());\n    }\n    return Pair.create(context, element);\n  }","id":24972,"modified_method":"protected Pair<CompletionContext, PsiElement> insertDummyIdentifier(final CompletionContext context) {\n    PsiFile oldFileCopy = createFileCopy(context.file);\n    PsiFile hostFile = InjectedLanguageUtil.getTopLevelFile(oldFileCopy);\n    Project project = hostFile.getProject();\n    InjectedLanguageManager injectedLanguageManager = InjectedLanguageManager.getInstance(project);\n    // is null in tests\n    int hostStartOffset = injectedLanguageManager == null ? context.getStartOffset() : injectedLanguageManager.injectedToHost(oldFileCopy, TextRange.from(\n      context.getStartOffset(), 0)).getStartOffset();\n    Document document = oldFileCopy.getViewProvider().getDocument();\n\n    document.insertString(context.getStartOffset(), CompletionUtil.DUMMY_IDENTIFIER);\n    PsiDocumentManager.getInstance(project).commitDocument(document);\n    PsiFile fileCopy = InjectedLanguageUtil.findInjectedPsiAt(hostFile, hostStartOffset);\n    if (fileCopy == null) {\n      PsiElement elementAfterCommit = findElementAt(hostFile, hostStartOffset);\n      fileCopy = elementAfterCommit == null ? oldFileCopy : elementAfterCommit.getContainingFile();\n    }\n\n    if (oldFileCopy != fileCopy) {\n      // newly inserted identifier can well end up in the injected language region\n      Editor oldEditor = context.editor;\n      Editor editor = EditorFactory.getInstance().createEditor(document, project);\n      Editor newEditor = InjectedLanguageUtil.getEditorForInjectedLanguage(editor, hostFile, context.getStartOffset());\n      if (newEditor instanceof EditorWindow) {\n        EditorWindow injectedEditor = (EditorWindow)newEditor;\n        PsiFile injectedFile = injectedEditor.getInjectedFile();\n        final OffsetMap map = new OffsetMap(newEditor.getDocument());\n        final OffsetMap oldMap = context.getOffsetMap();\n        for (final OffsetKey key : oldMap.keySet()) {\n          map.addOffset(key, injectedEditor.logicalPositionToOffset(injectedEditor.hostToInjected(oldEditor.offsetToLogicalPosition(oldMap.getOffset(key)))));\n        }\n        CompletionContext newContext = new CompletionContext(context.project, injectedEditor, injectedFile, map);\n        PsiElement element = findElementAt(injectedFile, newContext.getStartOffset());\n        if (element == null) {\n          LOG.assertTrue(false, \"offset \" + newContext.getStartOffset() + \" at:\\n\" + injectedFile.getText());\n        }\n        EditorFactory.getInstance().releaseEditor(editor);\n        return Pair.create(newContext, element);\n      }\n      EditorFactory.getInstance().releaseEditor(editor);\n    }\n    PsiElement element = findElementAt(fileCopy, context.getStartOffset());\n    if (element == null) {\n      LOG.assertTrue(false, \"offset \" + context.getStartOffset() + \" at:\\n\" + fileCopy.getText());\n    }\n    return Pair.create(context, element);\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setSelectionEndOffset(final int selectionEndOffset) {\n    getOffsetMap().addOffset(CompletionInitializationContext.SELECTION_END_OFFSET, selectionEndOffset, true);\n  }","id":24973,"modified_method":"public void setSelectionEndOffset(final int selectionEndOffset) {\n    getOffsetMap().addOffset(CompletionInitializationContext.SELECTION_END_OFFSET, selectionEndOffset);\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setStartOffset(final int newStartOffset) {\n    getOffsetMap().addOffset(CompletionInitializationContext.START_OFFSET, newStartOffset, false);\n  }","id":24974,"modified_method":"public void setStartOffset(final int newStartOffset) {\n    getOffsetMap().addOffset(CompletionInitializationContext.START_OFFSET, newStartOffset);\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CompletionInitializationContext(final Editor editor, final PsiFile file, final CompletionType completionType) {\n    myEditor = editor;\n    myFile = file;\n    myCompletionType = completionType;\n    myOffsetMap = new OffsetMap(editor.getDocument());\n\n    final int caretOffset = editor.getCaretModel().getOffset();\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    myOffsetMap.addOffset(START_OFFSET, selectionModel.hasSelection() ? selectionModel.getSelectionStart() : caretOffset, false);\n    \n    final int selectionEndOffset = selectionModel.hasSelection() ? selectionModel.getSelectionEnd() : caretOffset;\n    myOffsetMap.addOffset(SELECTION_END_OFFSET, selectionEndOffset, true);\n\n    final PsiReference reference = file.findReferenceAt(selectionEndOffset);\n    if(reference != null){\n      myOffsetMap.addOffset(IDENTIFIER_END_OFFSET,\n                            reference.getElement().getTextRange().getStartOffset() + reference.getRangeInElement().getEndOffset(), true);\n    } else {\n      myOffsetMap.addOffset(IDENTIFIER_END_OFFSET, selectionEndOffset, true);\n    }\n  }","id":24975,"modified_method":"public CompletionInitializationContext(final Editor editor, final PsiFile file, final CompletionType completionType) {\n    myEditor = editor;\n    myFile = file;\n    myCompletionType = completionType;\n    myOffsetMap = new OffsetMap(editor.getDocument());\n\n    final int caretOffset = editor.getCaretModel().getOffset();\n    final SelectionModel selectionModel = editor.getSelectionModel();\n    myOffsetMap.addOffset(START_OFFSET, selectionModel.hasSelection() ? selectionModel.getSelectionStart() : caretOffset);\n    \n    final int selectionEndOffset = selectionModel.hasSelection() ? selectionModel.getSelectionEnd() : caretOffset;\n    myOffsetMap.addOffset(SELECTION_END_OFFSET, selectionEndOffset);\n\n    final PsiReference reference = file.findReferenceAt(selectionEndOffset);\n    if(reference != null){\n      myOffsetMap.addOffset(IDENTIFIER_END_OFFSET,\n                            reference.getElement().getTextRange().getStartOffset() + reference.getRangeInElement().getEndOffset());\n    } else {\n      myOffsetMap.addOffset(IDENTIFIER_END_OFFSET, selectionEndOffset);\n    }\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void initOffsets(final PsiFile file, final Project project, final OffsetMap offsetMap){\n    final int selectionEndOffset = offsetMap.getOffset(CompletionInitializationContext.SELECTION_END_OFFSET);\n\n    PsiElement element = file.findElementAt(selectionEndOffset);\n    if (element == null) return;\n\n    final PsiReference reference = file.findReferenceAt(selectionEndOffset);\n    if(reference != null){\n      if(reference instanceof PsiJavaCodeReferenceElement){\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getParent().getTextRange().getEndOffset(), true);\n      }\n      else{\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET,\n                                 reference.getElement().getTextRange().getStartOffset() + reference.getRangeInElement().getEndOffset(), true);\n      }\n\n      element = file.findElementAt(offsetMap.getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n    }\n    else if (isWord(element)){\n      if(element instanceof PsiIdentifier && element.getParent() instanceof PsiJavaCodeReferenceElement){\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getParent().getTextRange().getEndOffset(), true);\n      }\n      else{\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getTextRange().getEndOffset(), true);\n      }\n\n      element = file.findElementAt(offsetMap.getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n      if (element == null) return;\n    }\n\n    if (element instanceof PsiWhiteSpace &&\n        ( !element.textContains('\\n') ||\n          CodeStyleSettingsManager.getInstance(project).getCurrentSettings().METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE\n        )\n       ){\n      element = file.findElementAt(element.getTextRange().getEndOffset());\n    }\n\n    if (element instanceof PsiJavaToken\n        && ((PsiJavaToken)element).getTokenType() == JavaTokenType.LPARENTH){\n\n      if(element.getParent() instanceof PsiExpressionList || \".\".equals(file.findElementAt(selectionEndOffset - 1).getText())\n        || PlatformPatterns.psiElement().afterLeaf(PlatformPatterns.psiElement(JavaTokenType.NEW_KEYWORD)).accepts(element)) {\n        offsetMap.addOffset(LPAREN_OFFSET, element.getTextRange().getStartOffset(), true);\n        PsiElement list = element.getParent();\n        PsiElement last = list.getLastChild();\n        if (last instanceof PsiJavaToken && ((PsiJavaToken)last).getTokenType() == JavaTokenType.RPARENTH){\n          offsetMap.addOffset(RPAREN_OFFSET, last.getTextRange().getStartOffset(), true);\n        }\n\n\n        offsetMap.addOffset(ARG_LIST_END_OFFSET, list.getTextRange().getEndOffset(), true);\n      }\n    }\n  }","id":24976,"modified_method":"public static void initOffsets(final PsiFile file, final Project project, final OffsetMap offsetMap){\n    final int selectionEndOffset = offsetMap.getOffset(CompletionInitializationContext.SELECTION_END_OFFSET);\n\n    PsiElement element = file.findElementAt(selectionEndOffset);\n    if (element == null) return;\n\n    final PsiReference reference = file.findReferenceAt(selectionEndOffset);\n    if(reference != null){\n      if(reference instanceof PsiJavaCodeReferenceElement){\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getParent().getTextRange().getEndOffset());\n      }\n      else{\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET,\n                                 reference.getElement().getTextRange().getStartOffset() + reference.getRangeInElement().getEndOffset());\n      }\n\n      element = file.findElementAt(offsetMap.getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n    }\n    else if (isWord(element)){\n      if(element instanceof PsiIdentifier && element.getParent() instanceof PsiJavaCodeReferenceElement){\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getParent().getTextRange().getEndOffset());\n      }\n      else{\n        offsetMap.addOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET, element.getTextRange().getEndOffset());\n      }\n\n      element = file.findElementAt(offsetMap.getOffset(CompletionInitializationContext.IDENTIFIER_END_OFFSET));\n      if (element == null) return;\n    }\n\n    if (element instanceof PsiWhiteSpace &&\n        ( !element.textContains('\\n') ||\n          CodeStyleSettingsManager.getInstance(project).getCurrentSettings().METHOD_PARAMETERS_LPAREN_ON_NEXT_LINE\n        )\n       ){\n      element = file.findElementAt(element.getTextRange().getEndOffset());\n    }\n\n    if (element instanceof PsiJavaToken\n        && ((PsiJavaToken)element).getTokenType() == JavaTokenType.LPARENTH){\n\n      if(element.getParent() instanceof PsiExpressionList || \".\".equals(file.findElementAt(selectionEndOffset - 1).getText())\n        || PlatformPatterns.psiElement().afterLeaf(PlatformPatterns.psiElement(JavaTokenType.NEW_KEYWORD)).accepts(element)) {\n        offsetMap.addOffset(LPAREN_OFFSET, element.getTextRange().getStartOffset());\n        PsiElement list = element.getParent();\n        PsiElement last = list.getLastChild();\n        if (last instanceof PsiJavaToken && ((PsiJavaToken)last).getTokenType() == JavaTokenType.RPARENTH){\n          offsetMap.addOffset(RPAREN_OFFSET, last.getTextRange().getStartOffset());\n        }\n\n\n        offsetMap.addOffset(ARG_LIST_END_OFFSET, list.getTextRange().getEndOffset());\n      }\n    }\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private OffsetKey(@NonNls String name) {\n    myName = name;\n  }","id":24977,"modified_method":"private OffsetKey(@NonNls String name, final boolean moveableToRight) {\n    myName = name;\n    myMoveableToRight = moveableToRight;\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static OffsetKey create(@NonNls String name) {\n    return new OffsetKey(name);\n  }","id":24978,"modified_method":"public static OffsetKey create(@NonNls String name) {\n    return create(name, true);\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Register key-offset binding. Offset will change together with {@link Document} editing operations\n   * unless an operation replaces completely the offset vicinity.\n   * @param key\n   * @param offset\n   * @param moveableToRight whether the offset should move right when a string is inserted directly into\n   * this offset position\n   */\n  public void addOffset(OffsetKey key, int offset, boolean moveableToRight) {\n    if (offset < 0) {\n      removeOffset(key);\n      return;\n    }\n\n    final RangeMarker marker = myDocument.createRangeMarker(offset, offset);\n    marker.setGreedyToRight(moveableToRight);\n    myMap.put(key, marker);\n  }","id":24979,"modified_method":"/**\n   * Register key-offset binding. Offset will change together with {@link Document} editing operations\n   * unless an operation replaces completely the offset vicinity.\n   * @param key\n   * @param offset\n   */\n  public void addOffset(OffsetKey key, int offset) {\n    if (offset < 0) {\n      removeOffset(key);\n      return;\n    }\n\n    final RangeMarker marker = myDocument.createRangeMarker(offset, offset);\n    marker.setGreedyToRight(key.isMoveableToRight());\n    myMap.put(key, marker);\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @param key key\n   * @return offset An offset registered earlier with this key.\n   * -1 if offset wasn't registered or became invalidated due to document changes\n   */\n  public int getOffset(OffsetKey key) {\n    final RangeMarker marker = myMap.get(key);\n    if (marker == null) return -1;\n    if (!marker.isValid()) {\n      removeOffset(key);\n      return -1;\n    }\n\n    final int endOffset = marker.getEndOffset();\n    if (marker.getStartOffset() != endOffset) {\n      addOffset(key, endOffset, true);\n    }\n    return endOffset;\n  }","id":24980,"modified_method":"/**\n   * @param key key\n   * @return offset An offset registered earlier with this key.\n   * -1 if offset wasn't registered or became invalidated due to document changes\n   */\n  public int getOffset(OffsetKey key) {\n    final RangeMarker marker = myMap.get(key);\n    if (marker == null) return -1;\n    if (!marker.isValid()) {\n      removeOffset(key);\n      return -1;\n    }\n\n    final int endOffset = marker.getEndOffset();\n    if (marker.getStartOffset() != endOffset) {\n      addOffset(key, endOffset);\n    }\n    return endOffset;\n  }","commit_id":"bab4043099df6bae37c2e1c254c99af43f8afbee","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ETLBatchTemplate() throws Exception {\n    sourceClassMap = Maps.newHashMap();\n    sinkClassMap = Maps.newHashMap();\n    transformClassMap = Maps.newHashMap();\n\n    //TODO: Add classes from Lib here to be available for use in the ETL Adapter. Remove this when\n    //plugins management is completed.\n    initTable(Lists.<Class>newArrayList(KVTableSource.class, KVTableSink.class, IdentityTransform.class));\n  }","id":24981,"modified_method":"public ETLBatchTemplate() throws Exception {\n    sourceClassMap = Maps.newHashMap();\n    sinkClassMap = Maps.newHashMap();\n    transformClassMap = Maps.newHashMap();\n\n    //TODO: Add classes from Lib here to be available for use in the ETL Adapter. Remove this when\n    //plugins management is completed.\n    initTable(Lists.<Class>newArrayList(KVTableSource.class, KVTableSink.class, IdentityTransform.class,\n                                        StructuredRecordToGenericRecordTransform.class));\n  }","commit_id":"71c6d9c68cecb190aad738f7f2d37ab005492a8a","url":"https://github.com/caskdata/cdap"},{"original_method":"private void validateTransforms(List<ETLStage> transform) throws Exception {\n    for (int i = 0; i < transform.size() - 1; i++) {\n      String transform1 = transformClassMap.get(transform.get(i).getName());\n      String transform2 = transformClassMap.get(transform.get(i + 1).getName());\n      Transform firstTransform = (Transform) Class.forName(transform1).newInstance();\n      Transform secondTransform = (Transform) Class.forName(transform2).newInstance();\n\n      Preconditions.checkArgument(secondTransform.getKeyInType().getClass().isAssignableFrom(\n        firstTransform.getKeyInType().getClass()));\n      Preconditions.checkArgument(secondTransform.getValueInType().getClass().isAssignableFrom(\n        firstTransform.getValueInType().getClass()));\n      Preconditions.checkArgument(secondTransform.getKeyOutType().getClass().isAssignableFrom(\n        firstTransform.getKeyOutType().getClass()));\n      Preconditions.checkArgument(secondTransform.getValueOutType().getClass().isAssignableFrom(\n        firstTransform.getValueOutType().getClass()));\n    }\n  }","id":24982,"modified_method":"private void validateTransforms(List<ETLStage> transform) throws Exception {\n    for (int i = 0; i < transform.size() - 1; i++) {\n      String transform1 = transformClassMap.get(transform.get(i).getName());\n      String transform2 = transformClassMap.get(transform.get(i + 1).getName());\n      Transform firstTransform = (Transform) Class.forName(transform1).newInstance();\n      Transform secondTransform = (Transform) Class.forName(transform2).newInstance();\n\n      Preconditions.checkArgument(secondTransform.getKeyInType().equals(firstTransform.getKeyInType()));\n      Preconditions.checkArgument(secondTransform.getValueInType().equals(firstTransform.getValueInType()));\n      Preconditions.checkArgument(secondTransform.getKeyOutType().equals(firstTransform.getKeyOutType()));\n      Preconditions.checkArgument(secondTransform.getValueOutType().equals(firstTransform.getValueOutType()));\n    }\n  }","commit_id":"71c6d9c68cecb190aad738f7f2d37ab005492a8a","url":"https://github.com/caskdata/cdap"},{"original_method":"private void validateAdapter(ETLStage source, ETLStage sink, List<ETLStage> transform) throws Exception {\n    String sourceName = source.getName();\n    String sinkName = sink.getName();\n    String sourceClassName = sourceClassMap.get(sourceName);\n    String sinkClassName = sinkClassMap.get(sinkName);\n\n    BatchSource batchSource = (BatchSource) Class.forName(sourceClassName).newInstance();\n    BatchSink batchSink = (BatchSink) Class.forName(sinkClassName).newInstance();\n\n    if (transform.size() == 0) {\n      // No transforms. Check only source and sink.\n      Preconditions.checkArgument(batchSink.getKeyType().getClass().isAssignableFrom(\n        batchSource.getKeyType().getClass()));\n      Preconditions.checkArgument(batchSink.getValueType().getClass().isAssignableFrom(\n        batchSource.getValueType().getClass()));\n    } else {\n      // Check the first and last transform with source and sink.\n      String firstTransformClassName = transformClassMap.get(transform.get(0).getName());\n      String lastTransformClassName = transformClassMap.get(transform.get(transform.size() - 1).getName());\n      Transform firstTransform = (Transform) Class.forName(firstTransformClassName).newInstance();\n      Transform lastTransform = (Transform) Class.forName(lastTransformClassName).newInstance();\n\n      Preconditions.checkArgument(firstTransform.getKeyInType().getClass().isAssignableFrom(\n        batchSource.getKeyType().getClass()));\n      Preconditions.checkArgument(firstTransform.getValueInType().getClass().isAssignableFrom(\n        batchSource.getValueType().getClass()));\n      Preconditions.checkArgument(lastTransform.getKeyOutType().getClass().isAssignableFrom(\n        batchSink.getKeyType().getClass()));\n      Preconditions.checkArgument(lastTransform.getValueOutType().getClass().isAssignableFrom(\n        batchSink.getValueType().getClass()));\n      if (transform.size() > 1) {\n        // Check transform stages.\n        validateTransforms(transform);\n      }\n    }\n  }","id":24983,"modified_method":"private void validateAdapter(ETLStage source, ETLStage sink, List<ETLStage> transform) throws Exception {\n    String sourceName = source.getName();\n    String sinkName = sink.getName();\n    String sourceClassName = sourceClassMap.get(sourceName);\n    String sinkClassName = sinkClassMap.get(sinkName);\n\n    BatchSource batchSource = (BatchSource) Class.forName(sourceClassName).newInstance();\n    BatchSink batchSink = (BatchSink) Class.forName(sinkClassName).newInstance();\n\n    if (transform.size() == 0) {\n      // No transforms. Check only source and sink.\n      Preconditions.checkArgument(batchSink.getKeyType().equals(batchSource.getKeyType()));\n      Preconditions.checkArgument(batchSink.getValueType().equals(batchSource.getValueType()));\n    } else {\n      // Check the first and last transform with source and sink.\n      String firstTransformClassName = transformClassMap.get(transform.get(0).getName());\n      String lastTransformClassName = transformClassMap.get(transform.get(transform.size() - 1).getName());\n      Transform firstTransform = (Transform) Class.forName(firstTransformClassName).newInstance();\n      Transform lastTransform = (Transform) Class.forName(lastTransformClassName).newInstance();\n\n      Preconditions.checkArgument(firstTransform.getKeyInType().equals(batchSource.getKeyType()));\n      Preconditions.checkArgument(firstTransform.getValueInType().equals(batchSource.getValueType()));\n      Preconditions.checkArgument(lastTransform.getKeyOutType().equals(batchSink.getKeyType()));\n      Preconditions.checkArgument(lastTransform.getValueOutType().equals(batchSink.getValueType()));\n      if (transform.size() > 1) {\n        // Check transform stages.\n        validateTransforms(transform);\n      }\n    }\n  }","commit_id":"71c6d9c68cecb190aad738f7f2d37ab005492a8a","url":"https://github.com/caskdata/cdap"},{"original_method":"private ETLBatchConfig constructETLBatchConfig() {\n    ETLStage source = new ETLStage(\"KVTableSource\", ImmutableMap.of(\"name\", \"table1\"));\n    ETLStage sink = new ETLStage(\"KVTableSink\", ImmutableMap.of(\"name\", \"table2\"));\n    ETLStage transform = new ETLStage(\"IdentityTransform\", ImmutableMap.<String, String>of());\n    List<ETLStage> transformList = Lists.newArrayList();\n    transformList.add(transform);\n    return new ETLBatchConfig(\"\", source, sink, transformList);\n  }","id":24984,"modified_method":"private ETLBatchConfig constructETLBatchConfig() {\n    ETLStage source = new ETLStage(\"KVTableSource\", ImmutableMap.of(\"name\", \"table1\"));\n    ETLStage sink = new ETLStage(\"KVTableSink\", ImmutableMap.of(\"name\", \"table2\"));\n    List<ETLStage> transformList = Lists.newArrayList();\n    return new ETLBatchConfig(\"\", source, sink, transformList);\n  }","commit_id":"71c6d9c68cecb190aad738f7f2d37ab005492a8a","url":"https://github.com/caskdata/cdap"},{"original_method":"private static boolean isMainMethod(PsiMethod method) {\n    if (!\"main\".equals(method.getName())) return false;\n    if (!method.hasModifierProperty(PsiModifier.STATIC)) return false;\n    if (!method.hasModifierProperty(PsiModifier.PUBLIC)) return false;\n    PsiParameter[] parms = method.getParameterList().getParameters();\n    if (parms.length != 1) return false;\n    return parms[0].getType().equalsToText(\"java.lang.String[]\");\n  }","id":24985,"modified_method":"private static boolean isMainMethod(PsiMethod method) {\n    if (!PsiType.VOID.equals(method.getReturnType())) return false;\n    final PsiElementFactory factory = method.getManager().getElementFactory();\n    try {\n      final PsiMethod appMain = factory.createMethodFromText(\"void main(String[] args);\", null);\n      if (MethodSignatureUtil.areSignaturesEqual(method, appMain)) return true;\n      final PsiMethod appPremain = factory.createMethodFromText(\"void premain(String[] args, java.lang.instrument.Instrumentation i);\", null);\n      if (MethodSignatureUtil.areSignaturesEqual(method, appPremain)) return true;\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n    return false;\n  }","commit_id":"fe8916d040a9ede39e5c7f52fc8460415981bf76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public RefManager(Project project, AnalysisScope scope) {\n    myDeclarationsFound = false;\n    myProject = project;\n    myScope = scope;\n    myRefProject = new RefProject(this);\n    myRefTable = new HashMap<PsiElement, RefElement>();\n    myPsiManager = PsiManager.getInstance(project);\n\n    myProjectIterator = new ProjectIterator();\n\n    PsiElementFactory factory = myPsiManager.getElementFactory();\n    try {\n      myAppMainPattern = factory.createMethodFromText(\"void main(String[] args);\", null);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n\n    myApplet = myPsiManager.findClass(\"java.applet.Applet\");\n    myServlet = myPsiManager.findClass(\"javax.servlet.Servlet\");\n  }","id":24986,"modified_method":"public RefManager(Project project, AnalysisScope scope) {\n    myDeclarationsFound = false;\n    myProject = project;\n    myScope = scope;\n    myRefProject = new RefProject(this);\n    myRefTable = new HashMap<PsiElement, RefElement>();\n    myPsiManager = PsiManager.getInstance(project);\n\n    myProjectIterator = new ProjectIterator();\n\n    PsiElementFactory factory = myPsiManager.getElementFactory();\n    try {\n      myAppMainPattern = factory.createMethodFromText(\"void main(String[] args);\", null);\n      myAppPremainPattern = factory.createMethodFromText(\"void premain(String[] args, java.lang.instrument.Instrumentation i);\", null);\n    }\n    catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n\n    myApplet = myPsiManager.findClass(\"java.applet.Applet\", GlobalSearchScope.allScope(project));\n    myServlet = myPsiManager.findClass(\"javax.servlet.Servlet\", GlobalSearchScope.allScope(project));\n  }","commit_id":"fe8916d040a9ede39e5c7f52fc8460415981bf76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isAppMain(PsiMethod psiMethod, RefMethod refMethod) {\n    if (!refMethod.isStatic()) return false;\n\n    PsiMethod appMainPattern = refMethod.getRefManager().getAppMainPattern();\n    return MethodSignatureUtil.areSignaturesEqual(psiMethod, appMainPattern);\n  }","id":24987,"modified_method":"public static boolean isAppMain(PsiMethod psiMethod, RefMethod refMethod) {\n    if (!refMethod.isStatic()) return false;\n    if (!PsiType.VOID.equals(psiMethod.getReturnType())) return false;\n\n    PsiMethod appMainPattern = refMethod.getRefManager().getAppMainPattern();\n    if(MethodSignatureUtil.areSignaturesEqual(psiMethod, appMainPattern)) return true;\n\n    PsiMethod appPremainPattern = refMethod.getRefManager().getAppPremainPattern();\n    return MethodSignatureUtil.areSignaturesEqual(psiMethod, appPremainPattern);\n  }","commit_id":"fe8916d040a9ede39e5c7f52fc8460415981bf76","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiCallExpression canBeMethodReferenceProblem(@Nullable final PsiElement body,\n                                                              final PsiParameter[] parameters,\n                                                              PsiType functionalInterfaceType, \n                                                              @Nullable PsiElement context) {\n    final PsiCallExpression callExpression = extractMethodCallFromBlock(body);\n    if (callExpression instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)callExpression;\n      if (newExpression.getAnonymousClass() != null || newExpression.getArrayInitializer() != null) {\n        return null;\n      }\n    }\n\n    final String methodReferenceText = createMethodReferenceText(callExpression, functionalInterfaceType, parameters);\n    if (methodReferenceText != null) {\n      LOG.assertTrue(callExpression != null);\n      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(callExpression.getProject());\n      final PsiMethodReferenceExpression methodReferenceExpression = \n        (PsiMethodReferenceExpression)elementFactory.createExpressionFromText(methodReferenceText, context != null ? context : callExpression);\n      final Map<PsiElement, PsiType> map = LambdaUtil.getFunctionalTypeMap();\n      try {\n        map.put(methodReferenceExpression, functionalInterfaceType);\n        final JavaResolveResult result = methodReferenceExpression.advancedResolve(false);\n        final PsiElement element = result.getElement();\n        if (element != null && result.isAccessible() &&\n            !(result instanceof MethodCandidateInfo && !((MethodCandidateInfo)result).isApplicable())) {\n          if (element instanceof PsiMethod && !isSimpleCall(parameters, callExpression, (PsiMethod)element)) {\n            return null;\n          }\n          if (!(element instanceof PsiMethod)) {\n            LOG.assertTrue(callExpression instanceof PsiNewExpression);\n            if (((PsiNewExpression)callExpression).getQualifier() != null) {\n              return null;\n            }\n\n            final PsiExpression[] dims = ((PsiNewExpression)callExpression).getArrayDimensions();\n            if (dims.length == 1 && parameters.length == 1){\n              if (!resolvesToParameter(dims[0], parameters[0])) {\n                return null;\n              }\n            }\n            else if (dims.length > 0) {\n              return null;\n            }\n            return callExpression;\n          }\n\n          final PsiMethod method = callExpression.resolveMethod();\n          if (method != null) {\n            return MethodSignatureUtil.areSignaturesEqual((PsiMethod)element, method) ? callExpression : null;\n          }\n        }\n      }\n      finally {\n        map.remove(methodReferenceExpression);\n      }\n    }\n    return null;\n  }","id":24988,"modified_method":"@Nullable\n  public static PsiCallExpression canBeMethodReferenceProblem(@Nullable final PsiElement body,\n                                                              final PsiParameter[] parameters,\n                                                              PsiType functionalInterfaceType, \n                                                              @Nullable PsiElement context) {\n    final PsiCallExpression callExpression = extractMethodCallFromBlock(body);\n    if (callExpression instanceof PsiNewExpression) {\n      final PsiNewExpression newExpression = (PsiNewExpression)callExpression;\n      if (newExpression.getAnonymousClass() != null || newExpression.getArrayInitializer() != null) {\n        return null;\n      }\n    }\n\n    final String methodReferenceText = createMethodReferenceText(callExpression, functionalInterfaceType, parameters);\n    if (methodReferenceText != null) {\n      LOG.assertTrue(callExpression != null);\n      final PsiMethod method = callExpression.resolveMethod();\n      if (method != null) {\n        if (!isSimpleCall(parameters, callExpression, method)) {\n          return null;\n        }\n      }\n      else {\n        LOG.assertTrue(callExpression instanceof PsiNewExpression);\n        if (((PsiNewExpression)callExpression).getQualifier() != null) {\n          return null;\n        }\n\n        final PsiExpression[] dims = ((PsiNewExpression)callExpression).getArrayDimensions();\n        if (dims.length == 1 && parameters.length == 1){\n          if (!resolvesToParameter(dims[0], parameters[0])) {\n            return null;\n          }\n        }\n        else if (dims.length > 0) {\n          return null;\n        }\n      }\n      final PsiElementFactory elementFactory = JavaPsiFacade.getElementFactory(callExpression.getProject());\n      PsiMethodReferenceExpression methodReferenceExpression = \n        (PsiMethodReferenceExpression)elementFactory.createExpressionFromText(methodReferenceText, context != null ? context : callExpression);\n      final Map<PsiElement, PsiType> map = LambdaUtil.getFunctionalTypeMap();\n      try {\n        map.put(methodReferenceExpression, functionalInterfaceType);\n        final JavaResolveResult result = methodReferenceExpression.advancedResolve(false);\n        final PsiElement element = result.getElement();\n        if (element != null && result.isAccessible() &&\n            !(result instanceof MethodCandidateInfo && !((MethodCandidateInfo)result).isApplicable())) {\n          if (!(element instanceof PsiMethod)) {\n            return callExpression;\n          }\n\n          return method != null && MethodSignatureUtil.areSignaturesEqual((PsiMethod)element, method) ? callExpression : null;\n        }\n      }\n      finally {\n        map.remove(methodReferenceExpression);\n      }\n    }\n    return null;\n  }","commit_id":"01fc1dc40fc27e8217d7a1951f2e141b35b37577","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      final PsiElement element = descriptor.getPsiElement();\n      if (!FileModificationService.getInstance().preparePsiElementForWrite(element)) return;\n      final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(element, PsiLambdaExpression.class);\n      if (lambdaExpression == null) return;\n      PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n      if (functionalInterfaceType == null || !functionalInterfaceType.isValid()) return;\n      final String methodRefText = createMethodReferenceText(element, functionalInterfaceType,\n                                                             lambdaExpression.getParameterList().getParameters());\n\n      if (methodRefText != null) {\n        final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n        final PsiExpression psiExpression = factory.createExpressionFromText(methodRefText, lambdaExpression);\n        final SmartTypePointer typePointer = SmartTypePointerManager.getInstance(project).createSmartTypePointer(functionalInterfaceType);\n        PsiElement replace = lambdaExpression.replace(psiExpression);\n        final PsiType functionalTypeAfterReplacement = ((PsiMethodReferenceExpression)replace).getFunctionalInterfaceType();\n        functionalInterfaceType = typePointer.getType();\n        if (functionalTypeAfterReplacement == null || functionalInterfaceType != null && !functionalTypeAfterReplacement.equals(functionalInterfaceType)) { //ambiguity\n          final PsiTypeCastExpression cast = (PsiTypeCastExpression)factory.createExpressionFromText(\"(A)a\", replace);\n          cast.getCastType().replace(factory.createTypeElement(functionalInterfaceType));\n          cast.getOperand().replace(replace);\n          replace = replace.replace(cast);\n        }\n        JavaCodeStyleManager.getInstance(project).shortenClassReferences(replace);\n      }\n    }","id":24989,"modified_method":"@Override\n    public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      final PsiElement element = descriptor.getPsiElement();\n      if (!FileModificationService.getInstance().preparePsiElementForWrite(element)) return;\n      final PsiLambdaExpression lambdaExpression = PsiTreeUtil.getParentOfType(element, PsiLambdaExpression.class);\n      if (lambdaExpression == null) return;\n      PsiType functionalInterfaceType = lambdaExpression.getFunctionalInterfaceType();\n      if (functionalInterfaceType == null || !functionalInterfaceType.isValid()) return;\n      final PsiType denotableFunctionalInterfaceType = RefactoringChangeUtil.getTypeByExpression(lambdaExpression);\n      if (denotableFunctionalInterfaceType == null) return;\n      final String methodRefText = createMethodReferenceText(element, functionalInterfaceType,\n                                                             lambdaExpression.getParameterList().getParameters());\n\n      if (methodRefText != null) {\n        final PsiElementFactory factory = JavaPsiFacade.getElementFactory(project);\n        final PsiExpression psiExpression = factory.createExpressionFromText(methodRefText, lambdaExpression);\n        final SmartTypePointer typePointer = SmartTypePointerManager.getInstance(project).createSmartTypePointer(denotableFunctionalInterfaceType);\n        PsiElement replace = lambdaExpression.replace(psiExpression);\n        final PsiType functionalTypeAfterReplacement = ((PsiMethodReferenceExpression)replace).getFunctionalInterfaceType();\n        functionalInterfaceType = typePointer.getType();\n        if (functionalTypeAfterReplacement == null || functionalInterfaceType != null && !functionalTypeAfterReplacement.equals(functionalInterfaceType)) { //ambiguity\n          final PsiTypeCastExpression cast = (PsiTypeCastExpression)factory.createExpressionFromText(\"(A)a\", replace);\n          cast.getCastType().replace(factory.createTypeElement(functionalInterfaceType));\n          cast.getOperand().replace(replace);\n          replace = replace.replace(cast);\n        }\n        JavaCodeStyleManager.getInstance(project).shortenClassReferences(replace);\n      }\n    }","commit_id":"01fc1dc40fc27e8217d7a1951f2e141b35b37577","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n    if (!myInitialized.getAndSet(true)) {\n      final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(holder.getProject());\n      final PsiClass psiObjectClass = ApplicationManager.getApplication().runReadAction(\n          new Computable<PsiClass>() {\n            @Nullable\n            public PsiClass compute() {\n              return psiFacade.findClass(\"java.lang.Object\");\n            }\n          }\n      );\n      if (psiObjectClass != null) {\n        PsiMethod[] methods = psiObjectClass.getMethods();\n        for (PsiMethod method : methods) {\n          @NonNls final String name = method.getName();\n          if (\"equals\".equals(name)) {\n            myEquals = method;\n          }\n          else if (\"hashCode\".equals(name)) {\n            myHashCode = method;\n          }\n        }\n      }\n    }\n\n    //jdk wasn't configured for the project\n    if (myEquals == null || myHashCode == null || !myEquals.isValid() || !myHashCode.isValid()) return new PsiElementVisitor() {};\n\n    return new JavaElementVisitor() {\n      @Override public void visitClass(PsiClass aClass) {\n        super.visitClass(aClass);\n        boolean [] hasEquals = new boolean[] {false};\n        boolean [] hasHashCode = new boolean[] {false};\n        processClass(aClass, hasEquals, hasHashCode);\n        if (hasEquals[0] != hasHashCode[0]) {\n          PsiIdentifier identifier = aClass.getNameIdentifier();\n          holder.registerProblem(identifier != null ? identifier : aClass,\n                                 hasEquals[0]\n                                  ? InspectionsBundle.message(\"inspection.equals.hashcode.only.one.defined.problem.descriptor\", \"<code>equals()<\/code>\", \"<code>hashCode()<\/code>\")\n                                  : InspectionsBundle.message(\"inspection.equals.hashcode.only.one.defined.problem.descriptor\",\"<code>hashCode()<\/code>\", \"<code>equals()<\/code>\"),\n                                 (LocalQuickFix[])null);\n        }\n      }\n\n      @Override public void visitReferenceExpression(PsiReferenceExpression expression) {\n        //do nothing\n      }\n    };\n  }","id":24990,"modified_method":"@NotNull\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder, boolean isOnTheFly) {\n\n    final Project project = holder.getProject();\n    Pair<PsiMethod, PsiMethod> pair = CachedValuesManager.getManager(project).getCachedValue(project, new CachedValueProvider<Pair<PsiMethod, PsiMethod>>() {\n      @Override\n      public Result<Pair<PsiMethod, PsiMethod>> compute() {\n        final JavaPsiFacade psiFacade = JavaPsiFacade.getInstance(project);\n        final PsiClass psiObjectClass = ApplicationManager.getApplication().runReadAction(\n            new Computable<PsiClass>() {\n              @Nullable\n              public PsiClass compute() {\n                return psiFacade.findClass(\"java.lang.Object\", GlobalSearchScope.allScope(project));\n              }\n            }\n        );\n        if (psiObjectClass == null) {\n          return Result.create(null, ProjectRootManager.getInstance(project));\n        }\n        PsiMethod[] methods = psiObjectClass.getMethods();\n        PsiMethod myEquals = null;\n        PsiMethod myHashCode = null;\n        for (PsiMethod method : methods) {\n          @NonNls final String name = method.getName();\n          if (\"equals\".equals(name)) {\n            myEquals = method;\n          }\n          else if (\"hashCode\".equals(name)) {\n            myHashCode = method;\n          }\n        }\n        return Result.create(Pair.create(myEquals, myHashCode), psiObjectClass);\n      }\n    });\n\n    if (pair == null) return new PsiElementVisitor() {};\n\n    //jdk wasn't configured for the project\n    final PsiMethod myEquals = pair.first;\n    final PsiMethod myHashCode = pair.second;\n    if (myEquals == null || myHashCode == null || !myEquals.isValid() || !myHashCode.isValid()) return new PsiElementVisitor() {};\n\n    return new JavaElementVisitor() {\n      @Override public void visitClass(PsiClass aClass) {\n        super.visitClass(aClass);\n        boolean [] hasEquals = new boolean[] {false};\n        boolean [] hasHashCode = new boolean[] {false};\n        processClass(aClass, hasEquals, hasHashCode, myEquals, myHashCode);\n        if (hasEquals[0] != hasHashCode[0]) {\n          PsiIdentifier identifier = aClass.getNameIdentifier();\n          holder.registerProblem(identifier != null ? identifier : aClass,\n                                 hasEquals[0]\n                                  ? InspectionsBundle.message(\"inspection.equals.hashcode.only.one.defined.problem.descriptor\", \"<code>equals()<\/code>\", \"<code>hashCode()<\/code>\")\n                                  : InspectionsBundle.message(\"inspection.equals.hashcode.only.one.defined.problem.descriptor\",\"<code>hashCode()<\/code>\", \"<code>equals()<\/code>\"),\n                                 (LocalQuickFix[])null);\n        }\n      }\n\n      @Override public void visitReferenceExpression(PsiReferenceExpression expression) {\n        //do nothing\n      }\n    };\n  }","commit_id":"410b4f4c8de4145d280f1d6fac120c4c74424c6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void processClass(final PsiClass aClass, final boolean[] hasEquals, final boolean[] hasHashCode) {\n    final PsiMethod[] methods = aClass.getMethods();\n    for (PsiMethod method : methods) {\n      if (MethodSignatureUtil.areSignaturesEqual(method, myEquals)) {\n        hasEquals[0] = true;\n      }\n      else if (MethodSignatureUtil.areSignaturesEqual(method, myHashCode)) {\n        hasHashCode[0] = true;\n      }\n    }\n  }","id":24991,"modified_method":"private static void processClass(final PsiClass aClass,\n                                   final boolean[] hasEquals,\n                                   final boolean[] hasHashCode,\n                                   PsiMethod equals, PsiMethod hashcode) {\n    final PsiMethod[] methods = aClass.getMethods();\n    for (PsiMethod method : methods) {\n      if (MethodSignatureUtil.areSignaturesEqual(method, equals)) {\n        hasEquals[0] = true;\n      }\n      else if (MethodSignatureUtil.areSignaturesEqual(method, hashcode)) {\n        hasHashCode[0] = true;\n      }\n    }\n  }","commit_id":"410b4f4c8de4145d280f1d6fac120c4c74424c6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @deprecated use areSignaturesEqual() which takes correct substitutors\n   */\n  public static boolean areSignaturesEqual(PsiMethod method1, PsiMethod method2) {\n    return method1.getSignature(PsiSubstitutor.EMPTY).equals(method2.getSignature(PsiSubstitutor.EMPTY));\n  }","id":24992,"modified_method":"public static boolean areSignaturesEqual(PsiMethod method1, PsiMethod method2) {\n    return method1.getSignature(PsiSubstitutor.EMPTY).equals(method2.getSignature(PsiSubstitutor.EMPTY));\n  }","commit_id":"410b4f4c8de4145d280f1d6fac120c4c74424c6d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TagsEntry addEntry(\n\t\t\tlong userId, String parentEntryName, String name,\n\t\t\tString vocabularyName, String[] properties)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\t\tname = name.trim().toLowerCase();\n\n\t\tvalidate(name);\n\n\t\tif (hasEntry(user.getCompanyId(), name)) {\n\t\t\tthrow new DuplicateEntryException(\n\t\t\t\t\"A tag entry with the name \" + name + \" already exists\");\n\t\t}\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tTagsEntry entry = tagsEntryPersistence.create(entryId);\n\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(now);\n\t\tentry.setModifiedDate(now);\n\t\tentry.setName(name);\n\n\t\tif (Validator.isNotNull(vocabularyName)) {\n\t\t\tTagsVocabulary vocabulary = tagsVocabularyPersistence.findByC_N(\n\t\t\t\tuser.getCompanyId(), vocabularyName);\n\n\t\t\tentry.setVocabularyId(vocabulary.getVocabularyId());\n\t\t}\n\t\telse {\n\t\t\tentry.setParentEntryId(TagsEntryConstants.DEFAULT_VOCABULARY_ID);\n\t\t}\n\n\t\tif (Validator.isNotNull(parentEntryName)) {\n\t\t\tTagsEntry parentEntry = tagsEntryPersistence.findByC_N(\n\t\t\t\tuser.getCompanyId(), parentEntryName);\n\n\t\t\tentry.setParentEntryId(parentEntry.getEntryId());\n\t\t}\n\t\telse {\n\t\t\tentry.setParentEntryId(TagsEntryConstants.DEFAULT_PARENT_ENTRY_ID);\n\t\t}\n\n\t\ttagsEntryPersistence.update(entry, false);\n\n\t\tfor (int i = 0; i < properties.length; i++) {\n\t\t\tString[] property = StringUtil.split(\n\t\t\t\tproperties[i], StringPool.COLON);\n\n\t\t\tString key = StringPool.BLANK;\n\n\t\t\tif (property.length > 1) {\n\t\t\t\tkey = GetterUtil.getString(property[1]);\n\t\t\t}\n\n\t\t\tString value = StringPool.BLANK;\n\n\t\t\tif (property.length > 2) {\n\t\t\t\tvalue = GetterUtil.getString(property[2]);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(key)) {\n\t\t\t\ttagsPropertyLocalService.addProperty(\n\t\t\t\t\tuserId, entryId, key, value);\n\t\t\t}\n\t\t}\n\n\t\treturn entry;\n\n\t}","id":24993,"modified_method":"public TagsEntry addEntry(\n\t\t\tlong userId, String parentEntryName, String name,\n\t\t\tString vocabularyName, String[] properties)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\t\tname = name.trim().toLowerCase();\n\n\t\tvalidate(name);\n\n\t\tif (hasEntry(user.getCompanyId(), name)) {\n\t\t\tthrow new DuplicateEntryException(\n\t\t\t\t\"A tag entry with the name \" + name + \" already exists\");\n\t\t}\n\n\t\tlong entryId = counterLocalService.increment();\n\n\t\tTagsEntry entry = tagsEntryPersistence.create(entryId);\n\n\t\tentry.setCompanyId(user.getCompanyId());\n\t\tentry.setUserId(user.getUserId());\n\t\tentry.setUserName(user.getFullName());\n\t\tentry.setCreateDate(now);\n\t\tentry.setModifiedDate(now);\n\t\tentry.setName(name);\n\n\t\tif (Validator.isNull(vocabularyName)) {\n\t\t\tvocabularyName = PropsValues.TAGS_VOCABULARY_DEFAULT;\n\t\t}\n\n\t\tTagsVocabulary vocabulary;\n\n\t\ttry {\n\t\t\tvocabulary = tagsVocabularyPersistence.findByC_N(\n\t\t\t\tuser.getCompanyId(), vocabularyName);\n\t\t}\n\t\tcatch (NoSuchVocabularyException nsve) {\n\t\t\tif (vocabularyName.equals(PropsValues.TAGS_VOCABULARY_DEFAULT)) {\n\t\t\t\tvocabulary = tagsVocabularyLocalService.addVocabulary(\n\t\t\t\t\tuserId, vocabularyName, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow nsve;\n\t\t\t}\n\t\t}\n\n\t\tentry.setVocabularyId(vocabulary.getVocabularyId());\n\n\t\tif (Validator.isNotNull(parentEntryName)) {\n\t\t\tTagsEntry parentEntry = tagsEntryPersistence.findByC_N(\n\t\t\t\tuser.getCompanyId(), parentEntryName);\n\n\t\t\tentry.setParentEntryId(parentEntry.getEntryId());\n\t\t}\n\t\telse {\n\t\t\tentry.setParentEntryId(TagsEntryConstants.DEFAULT_PARENT_ENTRY_ID);\n\t\t}\n\n\t\ttagsEntryPersistence.update(entry, false);\n\n\t\tfor (int i = 0; i < properties.length; i++) {\n\t\t\tString[] property = StringUtil.split(\n\t\t\t\tproperties[i], StringPool.COLON);\n\n\t\t\tString key = StringPool.BLANK;\n\n\t\t\tif (property.length > 1) {\n\t\t\t\tkey = GetterUtil.getString(property[1]);\n\t\t\t}\n\n\t\t\tString value = StringPool.BLANK;\n\n\t\t\tif (property.length > 2) {\n\t\t\t\tvalue = GetterUtil.getString(property[2]);\n\t\t\t}\n\n\t\t\tif (Validator.isNotNull(key)) {\n\t\t\t\ttagsPropertyLocalService.addProperty(\n\t\t\t\t\tuserId, entryId, key, value);\n\t\t\t}\n\t\t}\n\n\t\treturn entry;\n\n\t}","commit_id":"7edfd544069a8e2256ac9271263afbe637acee8c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public TagsEntry updateEntry(\n\t\t\tlong entryId, String parentEntryName, String name,\n\t\t\tString vocabularyName)\n\t\tthrows PortalException, SystemException {\n\n\t\tname = name.trim().toLowerCase();\n\n\t\tvalidate(name);\n\n\t\tTagsEntry entry = tagsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tif (!entry.getName().equals(name)) {\n\t\t\tif (hasEntry(entry.getCompanyId(), name)) {\n\t\t\t\tthrow new DuplicateEntryException();\n\t\t\t}\n\t\t}\n\n\t\tentry.setModifiedDate(new Date());\n\t\tentry.setName(name);\n\n\t\tif (Validator.isNotNull(vocabularyName)) {\n\t\t\tTagsVocabulary vocabulary =\n\t\t\t\ttagsVocabularyLocalService.getVocabulary(\n\t\t\t\t\tentry.getCompanyId(), vocabularyName);\n\n\t\t\tentry.setVocabularyId(vocabulary.getVocabularyId());\n\t\t}\n\t\telse {\n\t\t\tentry.setParentEntryId(TagsEntryConstants.DEFAULT_VOCABULARY_ID);\n\t\t}\n\n\t\tif (Validator.isNotNull(parentEntryName)) {\n\t\t\tTagsEntry parent = getEntry(entry.getCompanyId(), parentEntryName);\n\n\t\t\tentry.setParentEntryId(parent.getEntryId());\n\t\t}\n\t\telse {\n\t\t\tentry.setParentEntryId(TagsEntryConstants.DEFAULT_PARENT_ENTRY_ID);\n\t\t}\n\n\t\ttagsEntryPersistence.update(entry, false);\n\n\t\treturn entry;\n\t}","id":24994,"modified_method":"public TagsEntry updateEntry(\n\t\t\tlong entryId, String parentEntryName, String name,\n\t\t\tString vocabularyName)\n\t\tthrows PortalException, SystemException {\n\n\t\tname = name.trim().toLowerCase();\n\n\t\tvalidate(name);\n\n\t\tTagsEntry entry = tagsEntryPersistence.findByPrimaryKey(entryId);\n\n\t\tif (!entry.getName().equals(name)) {\n\t\t\tif (hasEntry(entry.getCompanyId(), name)) {\n\t\t\t\tthrow new DuplicateEntryException();\n\t\t\t}\n\t\t}\n\n\t\tentry.setModifiedDate(new Date());\n\t\tentry.setName(name);\n\n\t\tif (Validator.isNull(vocabularyName)) {\n\t\t\tvocabularyName = PropsValues.TAGS_VOCABULARY_DEFAULT;\n\t\t}\n\n\t\tTagsVocabulary vocabulary;\n\n\t\ttry {\n\t\t\tvocabulary = tagsVocabularyPersistence.findByC_N(\n\t\t\t\tentry.getCompanyId(), vocabularyName);\n\t\t}\n\t\tcatch (NoSuchVocabularyException nsve) {\n\n\t\t\tif (vocabularyName.equals(PropsValues.TAGS_VOCABULARY_DEFAULT)) {\n\t\t\t\tvocabulary = tagsVocabularyLocalService.addVocabulary(\n\t\t\t\t\tentry.getUserId(), vocabularyName, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow nsve;\n\t\t\t}\n\t\t}\n\n\t\tentry.setVocabularyId(vocabulary.getVocabularyId());\n\n\t\tif (Validator.isNotNull(parentEntryName)) {\n\t\t\tTagsEntry parent = getEntry(entry.getCompanyId(), parentEntryName);\n\n\t\t\tentry.setParentEntryId(parent.getEntryId());\n\t\t}\n\t\telse {\n\t\t\tentry.setParentEntryId(TagsEntryConstants.DEFAULT_PARENT_ENTRY_ID);\n\t\t}\n\n\t\ttagsEntryPersistence.update(entry, false);\n\n\t\treturn entry;\n\t}","commit_id":"7edfd544069a8e2256ac9271263afbe637acee8c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public TagsEntry addEntry(long userId, String name, String[] properties)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addEntry(userId, name, null, properties);\n\t}","id":24995,"modified_method":"public TagsEntry addEntry(long userId, String name, String[] properties)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn addEntry(\n\t\t\tuserId, name, PropsValues.TAGS_VOCABULARY_DEFAULT, properties);\n\t}","commit_id":"7edfd544069a8e2256ac9271263afbe637acee8c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public TagsEntry updateEntry(long entryId, String name)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn updateEntry(entryId, null, name, null);\n\t}","id":24996,"modified_method":"public TagsEntry updateEntry(long entryId, String name)\n\t\tthrows PortalException, SystemException {\n\n\t\treturn updateEntry(\n\t\t\tentryId, null, name, PropsValues.TAGS_VOCABULARY_DEFAULT);\n\t}","commit_id":"7edfd544069a8e2256ac9271263afbe637acee8c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void upgrade() throws UpgradeException {\n\t\t_log.info(\"Upgrading\");\n\n\t\tupgrade(UpgradeSchema.class);\n\t}","id":24997,"modified_method":"public void upgrade() throws UpgradeException {\n\t\t_log.info(\"Upgrading\");\n\n\t\tupgrade(UpgradeSchema.class);\n\t\tupgrade(UpgradeTags.class);\n\t}","commit_id":"7edfd544069a8e2256ac9271263afbe637acee8c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void checkSystemRoles(long companyId)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Regular roles\n\n\t\tString[] systemRoles = PortalUtil.getSystemRoles();\n\n\t\tfor (int i = 0; i < systemRoles.length; i++) {\n\t\t\tString roleName = systemRoles[i];\n\t\t\tString roleDescription = StringPool.BLANK;\n\t\t\tint roleType = RoleImpl.TYPE_REGULAR;\n\n\t\t\ttry {\n\t\t\t\troleFinder.findByC_N(companyId, roleName);\n\t\t\t}\n\t\t\tcatch (NoSuchRoleException nsre) {\n\t\t\t\taddRole(0, companyId, roleName, roleDescription, roleType);\n\t\t\t}\n\t\t}\n\n\t\t// Community roles\n\n\t\tString[] systemCommunityRoles = PortalUtil.getSystemCommunityRoles();\n\n\t\tfor (int i = 0; i < systemCommunityRoles.length; i++) {\n\t\t\tString roleName = systemCommunityRoles[i];\n\t\t\tString roleDescription = StringPool.BLANK;\n\t\t\tint roleType = RoleImpl.TYPE_COMMUNITY;\n\n\t\t\ttry {\n\t\t\t\troleFinder.findByC_N(companyId, roleName);\n\t\t\t}\n\t\t\tcatch (NoSuchRoleException nsre) {\n\t\t\t\taddRole(0, companyId, roleName, roleDescription, roleType);\n\t\t\t}\n\t\t}\n\n\t\t// Organization roles\n\n\t\tString[] systemOrganizationRoles =\n\t\t\tPortalUtil.getSystemOrganizationRoles();\n\n\t\tfor (int i = 0; i < systemOrganizationRoles.length; i++) {\n\t\t\tString roleName = systemOrganizationRoles[i];\n\t\t\tString roleDescription = StringPool.BLANK;\n\t\t\tint roleType = RoleImpl.TYPE_ORGANIZATION;\n\n\t\t\ttry {\n\t\t\t\troleFinder.findByC_N(companyId, systemOrganizationRoles[i]);\n\t\t\t}\n\t\t\tcatch (NoSuchRoleException nsre) {\n\t\t\t\taddRole(0, companyId, roleName, roleDescription, roleType);\n\t\t\t}\n\t\t}\n\t}","id":24998,"modified_method":"public void checkSystemRoles(long companyId)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Regular roles\n\n\t\tString[] systemRoles = PortalUtil.getSystemRoles();\n\n\t\tfor (int i = 0; i < systemRoles.length; i++) {\n\t\t\tString roleName = systemRoles[i];\n\t\t\tString roleDescription = PropsUtil.get(\n\t\t\t\t\"system.role.\" + StringUtil.replace(roleName, \" \", \".\") +\n\t\t\t\t\t\".description\");\n\t\t\tint roleType = RoleImpl.TYPE_REGULAR;\n\n\t\t\ttry {\n\t\t\t\tRole role = roleFinder.findByC_N(companyId, roleName);\n\n\t\t\t\tif (!role.getDescription().equals(roleDescription)) {\n\t\t\t\t\trole.setDescription(roleDescription);\n\n\t\t\t\t\trolePersistence.update(role);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchRoleException nsre) {\n\t\t\t\taddRole(0, companyId, roleName, roleDescription, roleType);\n\t\t\t}\n\t\t}\n\n\t\t// Community roles\n\n\t\tString[] systemCommunityRoles = PortalUtil.getSystemCommunityRoles();\n\n\t\tfor (int i = 0; i < systemCommunityRoles.length; i++) {\n\t\t\tString roleName = systemCommunityRoles[i];\n\t\t\tString roleDescription = PropsUtil.get(\n\t\t\t\t\"system.community.role.\" +\n\t\t\t\t\tStringUtil.replace(roleName, \" \", \".\") + \".description\");\n\t\t\tint roleType = RoleImpl.TYPE_COMMUNITY;\n\n\t\t\ttry {\n\t\t\t\tRole role = roleFinder.findByC_N(companyId, roleName);\n\n\t\t\t\tif (!role.getDescription().equals(roleDescription)) {\n\t\t\t\t\trole.setDescription(roleDescription);\n\n\t\t\t\t\trolePersistence.update(role);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchRoleException nsre) {\n\t\t\t\taddRole(0, companyId, roleName, roleDescription, roleType);\n\t\t\t}\n\t\t}\n\n\t\t// Organization roles\n\n\t\tString[] systemOrganizationRoles =\n\t\t\tPortalUtil.getSystemOrganizationRoles();\n\n\t\tfor (int i = 0; i < systemOrganizationRoles.length; i++) {\n\t\t\tString roleName = systemOrganizationRoles[i];\n\t\t\tString roleDescription = PropsUtil.get(\n\t\t\t\t\"system.organization.role.\" +\n\t\t\t\t\tStringUtil.replace(roleName, \" \", \".\") + \".description\");\n\t\t\tint roleType = RoleImpl.TYPE_ORGANIZATION;\n\n\t\t\ttry {\n\t\t\t\tRole role = roleFinder.findByC_N(companyId, roleName);\n\n\t\t\t\tif (!role.getDescription().equals(roleDescription)) {\n\t\t\t\t\trole.setDescription(roleDescription);\n\n\t\t\t\t\trolePersistence.update(role);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (NoSuchRoleException nsre) {\n\t\t\t\taddRole(0, companyId, roleName, roleDescription, roleType);\n\t\t\t}\n\t\t}\n\t}","commit_id":"95e25b1d839a516e59f1225d4b5dfca805d80576","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n    public void shouldNotReturnAvailableButFailedSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( iterable(new ClusterMember(clusterUri1).availableAs( \"SLAVE\", haUri1 ).failed()) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 0L ));\n    }","id":24999,"modified_method":"@Test\n    public void shouldNotReturnAvailableButFailedSlaves() throws Throwable\n    {\n        // given\n        Cluster cluster = mock( Cluster.class);\n        ClusterMembers clusterMembers = mock( ClusterMembers.class);\n        when( clusterMembers.getMembers() ).thenReturn( Iterables.<ClusterMember,ClusterMember>iterable(new ClusterMember(clusterUri1).availableAs(\"SLAVE\", haUri1).failed()) );\n\n        SlaveFactory slaveFactory = mock( SlaveFactory.class );\n\n        HighAvailabilitySlaves slaves = new HighAvailabilitySlaves( clusterMembers, cluster, slaveFactory);\n        slaves.init();\n\n        // when\n        Iterable<Slave> memberSlaves = slaves.getSlaves();\n\n        // then\n        Assert.assertThat( count( memberSlaves ), CoreMatchers.equalTo( 0L ));\n    }","commit_id":"f29a3e9f642d75976a70c73f67b52823dda3e651","url":"https://github.com/neo4j/neo4j"}]