[{"original_method":"@NonNls\n  public String toString() {\n    @NonNls StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntTarget: \");\n      builder.append(getName());\n      if (myDescription != null) {\n        builder.append(\" [\");\n        builder.append(myDescription);\n        builder.append(']');\n      }\n      final AntTarget[] targets = getDependsTargets();\n      if (targets.length > 0) {\n        builder.append(\" -> [\");\n        for (AntTarget target : targets) {\n          builder.append(' ');\n          builder.append(target.getName());\n        }\n        builder.append(\" ]\");\n      }\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","id":90000,"modified_method":"@NonNls\n  public String toString() {\n    @NonNls StringBuilder builder = StringBuilderSpinAllocator.alloc();\n    try {\n      builder.append(\"AntTarget: \");\n      builder.append(getName());\n      if (getDescription() != null) {\n        builder.append(\" [\");\n        builder.append(getDescription());\n        builder.append(']');\n      }\n      final AntTarget[] targets = getDependsTargets();\n      if (targets.length > 0) {\n        builder.append(\" -> [\");\n        for (AntTarget target : targets) {\n          builder.append(' ');\n          builder.append(target.getName());\n        }\n        builder.append(\" ]\");\n      }\n      return builder.toString();\n    }\n    finally {\n      StringBuilderSpinAllocator.dispose(builder);\n    }\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getName() {\n    parseTag();\n    return myName;\n  }","id":90001,"modified_method":"@Nullable\n  public String getName() {\n    return getSourceElement().getAttributeValue(\"name\");\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public String getDescription() {\n    parseTag();\n    return myDescription;\n  }","id":90002,"modified_method":"@Nullable\n  public String getDescription() {\n    return getSourceElement().getAttributeValue(\"description\");\n  }","commit_id":"52b1a865e7ba50af51fc694e3ce71fff82ba2ad9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processStringLiteral(@NotNull PsiElement element, @NotNull MultiHostRegistrar registrar, @NotNull String prefix,\n                                           @NotNull String suffix, @NotNull Formatting formatting) {\n    final String missingValue = \"missing\";\n    if (element instanceof PyStringLiteralExpression) {\n      final PyStringLiteralExpression expr = (PyStringLiteralExpression)element;\n      final List<TextRange> ranges = expr.getStringValueTextRanges();\n      final String text = expr.getText();\n      for (TextRange range : ranges) {\n        if (formatting != Formatting.NONE) {\n          final String part = range.substring(text);\n          final List<FormatStringChunk> chunks = formatting == Formatting.NEW_STYLE ? parseNewStyleFormat(part) : parsePercentFormat(part);\n          if (chunks.isEmpty()) {\n            registrar.addPlace(prefix, suffix, expr, range);\n            continue;\n          }\n          for (int i = 0; i < chunks.size(); i++) {\n            final FormatStringChunk chunk = chunks.get(i);\n            if (chunk instanceof ConstantChunk) {\n              final int nextIndex = i + 1;\n              final String chunkPrefix;\n              if (i == 1 && chunks.get(0) instanceof SubstitutionChunk) {\n                chunkPrefix = missingValue;\n              }\n              else if (i == 0) {\n                chunkPrefix = prefix;\n              } else {\n                chunkPrefix = \"\";\n              }\n              final String chunkSuffix;\n              if (nextIndex < chunks.size() && chunks.get(nextIndex) instanceof SubstitutionChunk) {\n                chunkSuffix = missingValue;\n              }\n              else if (nextIndex == chunks.size()) {\n                chunkSuffix = suffix;\n              }\n              else {\n                chunkSuffix = \"\";\n              }\n              final TextRange chunkRange = chunk.getTextRange().shiftRight(range.getStartOffset());\n              registrar.addPlace(chunkPrefix, chunkSuffix, expr, chunkRange);\n            }\n          }\n        }\n        else {\n          registrar.addPlace(prefix, suffix, expr, range);\n        }\n      }\n    }\n    else if (element instanceof PyParenthesizedExpression) {\n      final PyExpression contained = ((PyParenthesizedExpression)element).getContainedExpression();\n      if (contained != null) {\n        processStringLiteral(contained, registrar, prefix, suffix, formatting);\n      }\n    }\n    else if (element instanceof PyBinaryExpression) {\n      final PyBinaryExpression expr = (PyBinaryExpression)element;\n      final PyExpression left = expr.getLeftExpression();\n      final PyExpression right = expr.getRightExpression();\n      final boolean isLeftString = isStringLiteralPart(left, null);\n      if (expr.isOperator(\"+\")) {\n        final boolean isRightString = right != null && isStringLiteralPart(right, null);\n        if (isLeftString) {\n          processStringLiteral(left, registrar, prefix, isRightString ? \"\" : missingValue, formatting);\n        }\n        if (isRightString) {\n          processStringLiteral(right, registrar, isLeftString ? \"\" : missingValue, suffix, formatting);\n        }\n      }\n      else if (expr.isOperator(\"%\")) {\n        processStringLiteral(left, registrar, prefix, suffix, Formatting.PERCENT);\n      }\n    }\n    else if (element instanceof PyCallExpression) {\n      final PyExpression qualifier = getFormatCallQualifier((PyCallExpression)element);\n      if (qualifier != null) {\n        processStringLiteral(qualifier, registrar, prefix, suffix, Formatting.NEW_STYLE);\n      }\n    }\n  }","id":90003,"modified_method":"@NotNull\n  private static InjectionResult processStringLiteral(@NotNull PsiElement element, @NotNull MultiHostRegistrar registrar,\n                                                      @NotNull String prefix, @NotNull String suffix, @NotNull Formatting formatting) {\n    final String missingValue = \"missing_value\";\n    if (element instanceof PyStringLiteralExpression) {\n      boolean injected = false;\n      boolean strict = true;\n      final PyStringLiteralExpression expr = (PyStringLiteralExpression)element;\n      final List<TextRange> ranges = expr.getStringValueTextRanges();\n      final String text = expr.getText();\n      for (TextRange range : ranges) {\n        if (formatting != Formatting.NONE) {\n          final String part = range.substring(text);\n          final List<FormatStringChunk> chunks = formatting == Formatting.NEW_STYLE ? parseNewStyleFormat(part) : parsePercentFormat(part);\n          if (!filterSubstitutions(chunks).isEmpty()) {\n            strict = false;\n          }\n          for (int i = 0; i < chunks.size(); i++) {\n            final FormatStringChunk chunk = chunks.get(i);\n            if (chunk instanceof ConstantChunk) {\n              final int nextIndex = i + 1;\n              final String chunkPrefix;\n              if (i == 1 && chunks.get(0) instanceof SubstitutionChunk) {\n                chunkPrefix = missingValue;\n              }\n              else if (i == 0) {\n                chunkPrefix = prefix;\n              } else {\n                chunkPrefix = \"\";\n              }\n              final String chunkSuffix;\n              if (nextIndex < chunks.size() && chunks.get(nextIndex) instanceof SubstitutionChunk) {\n                chunkSuffix = missingValue;\n              }\n              else if (nextIndex == chunks.size()) {\n                chunkSuffix = suffix;\n              }\n              else {\n                chunkSuffix = \"\";\n              }\n              final TextRange chunkRange = chunk.getTextRange().shiftRight(range.getStartOffset());\n              registrar.addPlace(chunkPrefix, chunkSuffix, expr, chunkRange);\n              injected = true;\n            }\n          }\n        }\n        else {\n          registrar.addPlace(prefix, suffix, expr, range);\n          injected = true;\n        }\n      }\n      return new InjectionResult(injected, strict);\n    }\n    else if (element instanceof PyParenthesizedExpression) {\n      final PyExpression contained = ((PyParenthesizedExpression)element).getContainedExpression();\n      if (contained != null) {\n        return processStringLiteral(contained, registrar, prefix, suffix, formatting);\n      }\n    }\n    else if (element instanceof PyBinaryExpression) {\n      final PyBinaryExpression expr = (PyBinaryExpression)element;\n      final PyExpression left = expr.getLeftExpression();\n      final PyExpression right = expr.getRightExpression();\n      final boolean isLeftString = isStringLiteralPart(left, null);\n      if (expr.isOperator(\"+\")) {\n        final boolean isRightString = right != null && isStringLiteralPart(right, null);\n        InjectionResult result = InjectionResult.EMPTY;\n        if (isLeftString) {\n          result = result.append(processStringLiteral(left, registrar, prefix, isRightString ? \"\" : missingValue, formatting));\n        }\n        if (isRightString) {\n          result = result.append(processStringLiteral(right, registrar, isLeftString ? \"\" : missingValue, suffix, formatting));\n        }\n        return result;\n      }\n      else if (expr.isOperator(\"%\")) {\n        return processStringLiteral(left, registrar, prefix, suffix, Formatting.PERCENT);\n      }\n    }\n    else if (element instanceof PyCallExpression) {\n      final PyExpression qualifier = getFormatCallQualifier((PyCallExpression)element);\n      if (qualifier != null) {\n        return processStringLiteral(qualifier, registrar, prefix, suffix, Formatting.NEW_STYLE);\n      }\n    }\n    return InjectionResult.EMPTY;\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Registers language injections in the given registrar for the specified string literal element or its ancestor that contains\n   * string concatenations or formatting.\n   */\n  public static void registerStringLiteralInjection(@NotNull PsiElement element, @NotNull MultiHostRegistrar registrar) {\n    processStringLiteral(element, registrar, \"\", \"\", Formatting.PERCENT);\n  }","id":90004,"modified_method":"/**\n   * Registers language injections in the given registrar for the specified string literal element or its ancestor that contains\n   * string concatenations or formatting.\n   */\n  @NotNull\n  public static InjectionResult registerStringLiteralInjection(@NotNull PsiElement element, @NotNull MultiHostRegistrar registrar) {\n    return processStringLiteral(element, registrar, \"\", \"\", Formatting.PERCENT);\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean registerInjection(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    final Language language = getInjectedLanguage(context);\n    if (language != null) {\n      final PsiElement element = PyInjectionUtil.getLargestStringLiteral(context);\n      if (element != null) {\n        registrar.startInjecting(language);\n        PyInjectionUtil.registerStringLiteralInjection(element, registrar);\n        registrar.doneInjecting();\n        return true;\n      }\n    }\n    return false;\n  }","id":90005,"modified_method":"protected PyInjectionUtil.InjectionResult registerInjection(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    final Language language = getInjectedLanguage(context);\n    if (language != null) {\n      final PsiElement element = PyInjectionUtil.getLargestStringLiteral(context);\n      if (element != null) {\n        registrar.startInjecting(language);\n        final PyInjectionUtil.InjectionResult result = PyInjectionUtil.registerStringLiteralInjection(element, registrar);\n        if (result.isInjected()) {\n          registrar.doneInjecting();\n        }\n        return result;\n      }\n    }\n    return PyInjectionUtil.InjectionResult.EMPTY;\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testNewStyleFormattingRegexpAutoInjection() {\n    doTestInjectedText(\"import re\\n\" +\n                       \"\\n\" +\n                       \"def f(x, y):\\n\" +\n                       \"    re.search('<caret>.*{foo}-{}'.format(x, foo=y), 'foo')\\n\",\n                       \".*missing-missing\");\n  }","id":90006,"modified_method":"public void testNewStyleFormattingRegexpAutoInjection() {\n    doTestInjectedText(\"import re\\n\" +\n                       \"\\n\" +\n                       \"def f(x, y):\\n\" +\n                       \"    re.search('<caret>.*{foo}-{}'.format(x, foo=y), 'foo')\\n\",\n                       \".*missing_value-missing_value\");\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testConcatStringWithValuesRegexpAutoInjection() {\n    doTestInjectedText(\"import re\\n\" +\n                       \"\\n\" +\n                       \"def f(x, y):\\n\" +\n                       \"    re.search('<caret>.*(' + x + ')' + y, 'foo')\\n\",\n                       \".*(missing)missing\");\n  }","id":90007,"modified_method":"public void testConcatStringWithValuesRegexpAutoInjection() {\n    doTestInjectedText(\"import re\\n\" +\n                       \"\\n\" +\n                       \"def f(x, y):\\n\" +\n                       \"    re.search('<caret>.*(' + x + ')' + y, 'foo')\\n\",\n                       \".*(missing_value)missing_value\");\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testPercentFormattingRegexpAutoInjection() {\n    doTestInjectedText(\"import re \\n\" +\n                       \"\\n\" +\n                       \"def f(x, y):\\n\" +\n                       \"    re.search('<caret>.*%s-%d' % (x, y), 'foo')\\n\",\n                       \".*missing-missing\");\n  }","id":90008,"modified_method":"public void testPercentFormattingRegexpAutoInjection() {\n    doTestInjectedText(\"import re \\n\" +\n                       \"\\n\" +\n                       \"def f(x, y):\\n\" +\n                       \"    re.search('<caret>.*%s-%d' % (x, y), 'foo')\\n\",\n                       \".*missing_value-missing_value\");\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testNewStyleFormattingEndsWithConstant() {\n    doTestInjectedText(\"import re\\n\" +\n                       \"\\n\" +\n                       \"def f(**kwargs):\" +\n                       \"    re.search('<caret>(foo{bar}baz$)'.format(**kwargs), 'foo')\\n\",\n                       \"(foomissingbaz$)\");\n  }","id":90009,"modified_method":"public void testNewStyleFormattingEndsWithConstant() {\n    doTestInjectedText(\"import re\\n\" +\n                       \"\\n\" +\n                       \"def f(**kwargs):\" +\n                       \"    re.search('<caret>(foo{bar}baz$)'.format(**kwargs), 'foo')\\n\",\n                       \"(foomissing_valuebaz$)\");\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    if (registerInjection(registrar, context)) {\n      final TemporaryPlacesRegistry registry = TemporaryPlacesRegistry.getInstance(context.getProject());\n      InjectorUtils.registerSupport(registry.getLanguageInjectionSupport(), false, registrar);\n    }\n  }","id":90010,"modified_method":"@Override\n  public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    final PyInjectionUtil.InjectionResult result = registerInjection(registrar, context);\n    if (result.isInjected()) {\n      final TemporaryPlacesRegistry registry = TemporaryPlacesRegistry.getInstance(context.getProject());\n      InjectorUtils.registerSupport(registry.getLanguageInjectionSupport(), false, registrar);\n      if (!result.isStrict()) {\n        InjectorUtils.putInjectedFileUserData(registrar, InjectedLanguageUtil.FRANKENSTEIN_INJECTION, Boolean.TRUE);\n      }\n    }\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    final PsiElement contextParent = context.getParent();\n    if (PyInjectionUtil.getLargestStringLiteral(context) == context && contextParent instanceof PyArgumentList) {\n      final PyExpression[] args = ((PyArgumentList)contextParent).getArguments();\n      int index = ArrayUtil.indexOf(args, context);\n      PyCallExpression call = PsiTreeUtil.getParentOfType(context, PyCallExpression.class);\n      if (call != null) {\n        final PyExpression callee = call.getCallee();\n        if (callee instanceof PyReferenceExpression && canBeRegexpCall(callee)) {\n          final PsiPolyVariantReference ref = ((PyReferenceExpression)callee).getReference(PyResolveContext.noImplicits());\n          if (ref != null) {\n            final PsiElement element = ref.resolve();\n            if (element != null && ScopeUtil.getScopeOwner(element) instanceof PyFile &&\n                element.getContainingFile().getName().equals(\"re.py\") && isRegexpMethod(element, index)) {\n              final Language language = isVerbose(call) ? PythonVerboseRegexpLanguage.INSTANCE : PythonRegexpLanguage.INSTANCE;\n              registrar.startInjecting(language);\n              PyInjectionUtil.registerStringLiteralInjection(context, registrar);\n              registrar.doneInjecting();\n            }\n          }\n        }\n      }\n    }\n  }","id":90011,"modified_method":"@Override\n  public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement context) {\n    final PsiElement contextParent = context.getParent();\n    if (PyInjectionUtil.getLargestStringLiteral(context) == context && contextParent instanceof PyArgumentList) {\n      final PyExpression[] args = ((PyArgumentList)contextParent).getArguments();\n      int index = ArrayUtil.indexOf(args, context);\n      PyCallExpression call = PsiTreeUtil.getParentOfType(context, PyCallExpression.class);\n      if (call != null) {\n        final PyExpression callee = call.getCallee();\n        if (callee instanceof PyReferenceExpression && canBeRegexpCall(callee)) {\n          final PsiPolyVariantReference ref = ((PyReferenceExpression)callee).getReference(PyResolveContext.noImplicits());\n          if (ref != null) {\n            final PsiElement element = ref.resolve();\n            if (element != null && ScopeUtil.getScopeOwner(element) instanceof PyFile &&\n                element.getContainingFile().getName().equals(\"re.py\") && isRegexpMethod(element, index)) {\n              final Language language = isVerbose(call) ? PythonVerboseRegexpLanguage.INSTANCE : PythonRegexpLanguage.INSTANCE;\n              registrar.startInjecting(language);\n              final PyInjectionUtil.InjectionResult result = PyInjectionUtil.registerStringLiteralInjection(context, registrar);\n              if (result.isInjected()) {\n                registrar.doneInjecting();\n                if (!result.isStrict()) {\n                  final PsiFile file = getInjectedFile(registrar);\n                  if (file != null) {\n                    file.putUserData(InjectedLanguageUtil.FRANKENSTEIN_INJECTION, Boolean.TRUE);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }","commit_id":"6e66b227d64d7917335077163401b3204b1809b4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void setCantReadText(JEditorPane browser, TipAndTrickBean missingFile) {\n    try {\n      browser.read(new StringReader(\n        IdeBundle.message(\"error.unable.to.read.tip.of.the.day\", missingFile, ApplicationNamesInfo.getInstance().getFullProductName())), null);\n    }\n    catch (IOException ignored) {\n    }\n  }","id":90012,"modified_method":"private static void setCantReadText(JEditorPane browser, TipAndTrickBean bean) {\n    try {\n      String plugin = getPoweredByText(bean);\n      String product = ApplicationNamesInfo.getInstance().getFullProductName();\n      if (!plugin.isEmpty()) {\n        product += \" and \" + plugin + \" plugin\";\n      }\n      String message = IdeBundle.message(\"error.unable.to.read.tip.of.the.day\", bean.getFileName(), product);\n      browser.read(new StringReader(message), null);\n    }\n    catch (IOException ignored) {\n    }\n  }","commit_id":"0826b4a018f7acfa123fc67b4abeb573b190a421","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public StatisticsConfigurationComponent() {\n    myTitle.setText(\"Help improve \"+ ApplicationNamesInfo.getInstance().getFullProductName() + \" by sending anonymous usage statistics to JetBrains\");\n    myLabel.setText(\"<html>We're asking your permission to send information about your plugins configuration (what is enabled <br>and what is not) and feature usage statistics (e.g. how frequently you're using code completion).<br>    This data is anonymous, does not contain any personal information, collected for use only by JetBrains<br> and will never be transmitted to any third party.<\/html>\");\n    myLabel.setFont(UIUtil.getLabelFont(UIUtil.FontSize.SMALL));\n\n    myAllowToSendUsagesCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        setRadioButtonsEnabled();\n      }\n    });\n  }","id":90013,"modified_method":"public StatisticsConfigurationComponent() {\n    String product = ApplicationNamesInfo.getInstance().getFullProductName();\n    String company = ApplicationInfo.getInstance().getCompanyName();\n    myTitle.setText(StatisticsBundle.message(\"stats.title\", product, company));\n    myLabel.setText(StatisticsBundle.message(\"stats.config.details\", company));\n    myLabel.setFont(UIUtil.getLabelFont(UIUtil.FontSize.SMALL));\n\n    myAllowToSendUsagesCheckBox.setText(StatisticsBundle.message(\"stats.config.allow.send.stats.text\", company));\n    myAllowToSendUsagesCheckBox.addActionListener(new ActionListener() {\n      @Override\n      public void actionPerformed(ActionEvent e) {\n        setRadioButtonsEnabled();\n      }\n    });\n  }","commit_id":"98931afc57c197a938c0648ef57012265938cdf5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String getTitle() {\n    return \"Help improve \"+ ApplicationNamesInfo.getInstance().getFullProductName() +\" by sending anonymous usage statistics to JetBrains\";\n  }","id":90014,"modified_method":"private static String getTitle() {\n    String product = ApplicationNamesInfo.getInstance().getFullProductName();\n    String company = ApplicationInfo.getInstance().getCompanyName();\n    return StatisticsBundle.message(\"stats.title\", product, company);\n  }","commit_id":"98931afc57c197a938c0648ef57012265938cdf5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean validate() throws ConfigurationException {\n    String name = myNamePathComponent.getNameValue();\n    if (name.length() == 0) {\n      final ApplicationInfo info = ApplicationInfo.getInstance();\n      throw new ConfigurationException(IdeBundle.message(\"prompt.new.project.file.name\", info.getVersionName(), myWizardContext.getPresentationName()));\n    }\n\n    final String projectFileDirectory = getProjectFileDirectory();\n    if (projectFileDirectory.length() == 0) {\n      throw new ConfigurationException(IdeBundle.message(\"prompt.enter.project.file.location\", myWizardContext.getPresentationName()));\n    }\n\n    final boolean shouldPromptCreation = myNamePathComponent.isPathChangedByUser();\n    if (!ProjectWizardUtil.createDirectoryIfNotExists(IdeBundle.message(\"directory.project.file.directory\",myWizardContext.getPresentationName()), projectFileDirectory, shouldPromptCreation)) {\n      return false;\n    }\n\n    boolean shouldContinue = true;\n\n    final String path = myWizardContext.isCreatingNewProject() && myWizardContext.getProjectStorageFormat() == DIRECTORY_BASED\n                        ? getProjectFileDirectory() + \"/\" + Project.DIRECTORY_STORE_FOLDER : getProjectFilePath();\n    final File projectFile = new File(path);\n    if (projectFile.exists()) {\n      final String title = myWizardContext.isCreatingNewProject()\n                           ? IdeBundle.message(\"title.new.project\")\n                           : IdeBundle.message(\"title.add.module\");\n      final String message = myWizardContext.isCreatingNewProject() && myWizardContext.getProjectStorageFormat() == DIRECTORY_BASED\n                             ? IdeBundle.message(\"prompt.overwrite.project.folder\",\n                                                 Project.DIRECTORY_STORE_FOLDER, projectFile.getParentFile().getAbsolutePath())\n                             : IdeBundle.message(\"prompt.overwrite.project.file\",\n                                                 projectFile.getAbsolutePath(), myWizardContext.getPresentationName());\n      int answer = Messages.showYesNoDialog(message, title, Messages.getQuestionIcon());\n      shouldContinue = answer == Messages.YES;\n    }\n\n    return shouldContinue;\n  }","id":90015,"modified_method":"public boolean validate() throws ConfigurationException {\n    String name = myNamePathComponent.getNameValue();\n    if (name.length() == 0) {\n      final ApplicationInfo info = ApplicationInfo.getInstance();\n      throw new ConfigurationException(IdeBundle.message(\"prompt.new.project.file.name\", info.getVersionName(), myWizardContext.getPresentationName()));\n    }\n\n    final String projectFileDirectory = getProjectFileDirectory();\n    if (projectFileDirectory.length() == 0) {\n      throw new ConfigurationException(IdeBundle.message(\"prompt.enter.project.file.location\", myWizardContext.getPresentationName()));\n    }\n\n    final boolean shouldPromptCreation = myNamePathComponent.isPathChangedByUser();\n    String prefix = IdeBundle.message(\"directory.project.file.directory\", myWizardContext.getPresentationName());\n    if (!ProjectWizardUtil.createDirectoryIfNotExists(prefix, projectFileDirectory, shouldPromptCreation)) {\n      return false;\n    }\n\n    boolean shouldContinue = true;\n\n    final String path = myWizardContext.isCreatingNewProject() && myWizardContext.getProjectStorageFormat() == DIRECTORY_BASED\n                        ? getProjectFileDirectory() + \"/\" + Project.DIRECTORY_STORE_FOLDER : getProjectFilePath();\n    final File projectFile = new File(path);\n    if (projectFile.exists()) {\n      final String title = myWizardContext.isCreatingNewProject()\n                           ? IdeBundle.message(\"title.new.project\")\n                           : IdeBundle.message(\"title.add.module\");\n      final String message = myWizardContext.isCreatingNewProject() && myWizardContext.getProjectStorageFormat() == DIRECTORY_BASED\n                             ? IdeBundle.message(\"prompt.overwrite.project.folder\",\n                                                 Project.DIRECTORY_STORE_FOLDER, projectFile.getParentFile().getAbsolutePath())\n                             : IdeBundle.message(\"prompt.overwrite.project.file\",\n                                                 projectFile.getAbsolutePath(), myWizardContext.getPresentationName());\n      int answer = Messages.showYesNoDialog(message, title, Messages.getQuestionIcon());\n      shouldContinue = answer == Messages.YES;\n    }\n\n    return shouldContinue;\n  }","commit_id":"eeae16e5cc2ca9cf43c6c8b0976c45c86a32766b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean createDirectoryIfNotExists(final String promptPrefix, String directoryPath, boolean promptUser) {\n    File dir = new File(directoryPath);\n    if (!dir.exists()) {\n      if (promptUser) {\n        final int answer = Messages.showOkCancelDialog(IdeBundle.message(\"promot.projectwizard.directory.does.not.exist\", promptPrefix,\n                                                                         dir.getPath(), ApplicationNamesInfo.getInstance().getFullProductName()),\n                                                       IdeBundle.message(\"title.directory.does.not.exist\"), Messages.getQuestionIcon());\n        if (answer != Messages.OK) {\n          return false;\n        }\n      }\n      try {\n        VfsUtil.createDirectories(dir.getPath());\n      }\n      catch (IOException e) {\n        Messages.showErrorDialog(IdeBundle.message(\"error.failed.to.create.directory\", dir.getPath()), CommonBundle.getErrorTitle());\n        return false;\n      }\n    }\n    return true;\n  }","id":90016,"modified_method":"public static boolean createDirectoryIfNotExists(String promptPrefix, String directoryPath, boolean promptUser) {\n    File dir = new File(directoryPath);\n\n    if (!dir.exists()) {\n      if (promptUser) {\n        String ide = ApplicationNamesInfo.getInstance().getFullProductName();\n        String message = IdeBundle.message(\"prompt.project.wizard.directory.does.not.exist\", promptPrefix, dir, ide);\n        int answer = Messages.showOkCancelDialog(message, IdeBundle.message(\"title.directory.does.not.exist\"), Messages.getQuestionIcon());\n        if (answer != Messages.OK) {\n          return false;\n        }\n      }\n\n      if (!FileUtil.createDirectory(dir)) {\n        Messages.showErrorDialog(IdeBundle.message(\"error.failed.to.create.directory\", dir.getPath()), CommonBundle.getErrorTitle());\n        return false;\n      }\n    }\n\n    if (SystemInfo.isUnix && !dir.canWrite()) {\n      Messages.showErrorDialog(IdeBundle.message(\"error.directory.read.only\", dir.getPath()), CommonBundle.getErrorTitle());\n      return false;\n    }\n\n    return true;\n  }","commit_id":"eeae16e5cc2ca9cf43c6c8b0976c45c86a32766b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String findNonExistingFileName(String searchDirectory, @NonNls String preferredName, String extension){\n    for (int idx = 0; ; idx++){\n      final String fileName = (idx > 0? preferredName + idx : preferredName) + extension;\n      if(!new File(searchDirectory + File.separator + fileName).exists()) {\n        return fileName;\n      }\n    }\n  }","id":90017,"modified_method":"public static String findNonExistingFileName(String searchDirectory, String preferredName, String extension) {\n    for (int idx = 0; ; idx++) {\n      String fileName = (idx > 0 ? preferredName + idx : preferredName) + extension;\n      if (!new File(searchDirectory, fileName).exists()) {\n        return fileName;\n      }\n    }\n  }","commit_id":"eeae16e5cc2ca9cf43c6c8b0976c45c86a32766b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Creates WordCount hadoop job for API v1.\n     *\n     * @param inFile input file name for the job.\n     * @param outFile output file name for the job.\n     * @return Hadoop job.\n     * @throws IOException if fails.\n     */\n    @Override public GridHadoopJob getHadoopJob(String inFile, String outFile) throws IOException {\n        JobConf hadoopJob = GridGainWordCount1.getJob(inFile, outFile);\n\n        GridHadoopDefaultJobInfo jobInfo = new GridHadoopDefaultJobInfo(hadoopJob);\n\n        GridHadoopJobId jobId = new GridHadoopJobId(new UUID(0, 0), 0);\n\n        GridHadoopV1JobImpl gridHadoopJob = new GridHadoopV1JobImpl(jobId, jobInfo);\n\n        //TODO: How to set job ID in v1?\n        // hadoopJob.setJobID(gridHadoopJob.hadoopJobContext().getJobID());\n\n        return gridHadoopJob;\n    }","id":90018,"modified_method":"/**\n     * Creates WordCount hadoop job for API v1.\n     *\n     * @param inFile input file name for the job.\n     * @param outFile output file name for the job.\n     * @return Hadoop job.\n     * @throws IOException if fails.\n     */\n    @Override public GridHadoopJob getHadoopJob(String inFile, String outFile) throws IOException {\n        JobConf hadoopJob = GridGainWordCount1.getJob(inFile, outFile);\n\n        GridHadoopDefaultJobInfo jobInfo = new GridHadoopDefaultJobInfo(hadoopJob);\n\n        GridHadoopJobId jobId = new GridHadoopJobId(new UUID(0, 0), 0);\n\n        GridHadoopV2JobImpl gridHadoopJob = new GridHadoopV2JobImpl(jobId, jobInfo);\n\n        return gridHadoopJob;\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Creates WordCount hadoop job for API v2.\n     *\n     * @param inFile Input file name for the job.\n     * @param outFile Output file name for the job.\n     * @return Hadoop job.\n     * @throws IOException if fails.\n     */\n    @Override public GridHadoopJob getHadoopJob(String inFile, String outFile) throws IOException {\n        Job hadoopJob = GridGainWordCount2.getJob(inFile, outFile);\n\n        GridHadoopDefaultJobInfo jobInfo = new GridHadoopDefaultJobInfo(hadoopJob.getConfiguration());\n\n        GridHadoopJobId jobId = new GridHadoopJobId(new UUID(0, 0), 0);\n\n        GridHadoopV2JobImpl gridHadoopJob = new GridHadoopV2JobImpl(jobId, jobInfo);\n\n        hadoopJob.setJobID(gridHadoopJob.hadoopJobContext().getJobID());\n\n        return gridHadoopJob;\n    }","id":90019,"modified_method":"/**\n     * Creates WordCount hadoop job for API v2.\n     *\n     * @param inFile Input file name for the job.\n     * @param outFile Output file name for the job.\n     * @return Hadoop job.\n     * @throws IOException if fails.\n     */\n    @Override public GridHadoopJob getHadoopJob(String inFile, String outFile) throws IOException {\n        Job hadoopJob = GridGainWordCount2.getJob(inFile, outFile);\n        hadoopJob.getConfiguration().setBooleanIfUnset(\"mapred.mapper.new-api\", true);\n        hadoopJob.getConfiguration().setBooleanIfUnset(\"mapred.reducer.new-api\", true);\n\n        GridHadoopDefaultJobInfo jobInfo = new GridHadoopDefaultJobInfo(hadoopJob.getConfiguration());\n\n        GridHadoopJobId jobId = new GridHadoopJobId(new UUID(0, 0), 0);\n\n        GridHadoopV2JobImpl gridHadoopJob = new GridHadoopV2JobImpl(jobId, jobInfo);\n\n        hadoopJob.setJobID(gridHadoopJob.hadoopJobContext().getJobID());\n\n        return gridHadoopJob;\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void run(GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV1JobImpl jobImpl = (GridHadoopV1JobImpl)taskCtx.job();\n\n        JobContext jobCtx = jobImpl.hadoopJobContext();\n\n        try {\n            OutputCommitter commiter = jobCtx.getJobConf().getOutputCommitter();\n\n            if (abort)\n                commiter.abortJob(jobCtx, JobStatus.State.FAILED);\n            else\n                commiter.commitJob(jobCtx);\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","id":90020,"modified_method":"/** {@inheritDoc} */\n    @Override public void run(GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2JobImpl jobImpl = (GridHadoopV2JobImpl) taskCtx.job();\n\n        JobContext jobCtx = jobImpl.hadoopJobContext();\n\n        try {\n            OutputCommitter commiter = jobCtx.getJobConf().getOutputCommitter();\n\n            if (abort)\n                commiter.abortJob(jobCtx, JobStatus.State.FAILED);\n            else\n                commiter.commitJob(jobCtx);\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void run(final GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV1JobImpl jobImpl = (GridHadoopV1JobImpl)taskCtx.job();\n\n        JobContext jobCtx = jobImpl.hadoopJobContext();\n\n        Reducer combiner = U.newInstance(jobCtx.getJobConf().getCombinerClass());\n\n        combiner.configure(jobCtx.getJobConf());\n\n        GridHadoopTaskInput input = taskCtx.input();\n\n        Reporter reporter = Reporter.NULL;\n\n        OutputCollector collector = new OutputCollector() {\n            @Override public void collect(Object key, Object val) throws IOException {\n                try {\n                    taskCtx.output().write(key, val);\n                }\n                catch (GridException e) {\n                    throw new IOException(e);\n                }\n            }\n        };\n\n        try {\n            while (input.next()) {\n                combiner.reduce(input.key(), input.values(), collector, reporter);\n            }\n\n            combiner.close();\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","id":90021,"modified_method":"/** {@inheritDoc} */\n    @Override public void run(final GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2JobImpl jobImpl = (GridHadoopV2JobImpl) taskCtx.job();\n\n        JobConf jobConf = jobImpl.hadoopJobContext().getJobConf();\n\n        Reducer combiner = U.newInstance(jobConf.getCombinerClass());\n\n        combiner.configure(jobConf);\n\n        GridHadoopTaskInput input = taskCtx.input();\n\n        Reporter reporter = Reporter.NULL;\n\n        OutputCollector collector = new OutputCollector() {\n            @Override public void collect(Object key, Object val) throws IOException {\n                try {\n                    taskCtx.output().write(key, val);\n                }\n                catch (GridException e) {\n                    throw new IOException(e);\n                }\n            }\n        };\n\n        try {\n            while (input.next()) {\n                combiner.reduce(input.key(), input.values(), collector, reporter);\n            }\n\n            combiner.close();\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void run(final GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV1JobImpl jobImpl = (GridHadoopV1JobImpl)taskCtx.job();\n\n        JobContext jobCtx = jobImpl.hadoopJobContext();\n\n        Mapper mapper = U.newInstance(jobCtx.getJobConf().getMapperClass());\n\n        InputFormat inFormat = jobCtx.getJobConf().getInputFormat();\n\n        GridHadoopFileBlock block = info().fileBlock();\n\n        InputSplit split = new FileSplit(new Path(block.file().toString()), block.start(), block.length(), block.hosts());\n\n        OutputCollector collector = new OutputCollector() {\n            @Override public void collect(Object key, Object val) throws IOException {\n                try {\n                    taskCtx.output().write(key, val);\n                }\n                catch (GridException e) {\n                    throw new IOException(e);\n                }\n            }\n        };\n\n        Reporter reporter = Reporter.NULL;\n\n        try {\n            RecordReader reader = inFormat.getRecordReader(split, jobCtx.getJobConf(), reporter);\n\n            Object key = reader.createKey();\n            Object val = reader.createValue();\n\n            mapper.configure(jobCtx.getJobConf());\n\n            while (reader.next(key, val)) {\n                mapper.map(key, val, collector, reporter);\n            }\n\n            mapper.close();\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","id":90022,"modified_method":"/** {@inheritDoc} */\n    @Override public void run(final GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2JobImpl jobImpl = (GridHadoopV2JobImpl) taskCtx.job();\n\n        JobConf jobConf = jobImpl.hadoopJobContext().getJobConf();\n\n        Mapper mapper = U.newInstance(jobConf.getMapperClass());\n\n        InputFormat inFormat = jobConf.getInputFormat();\n\n        GridHadoopFileBlock block = info().fileBlock();\n\n        InputSplit split = new FileSplit(new Path(block.file().toString()), block.start(), block.length(), block.hosts());\n\n        OutputCollector collector = new OutputCollector() {\n            @Override public void collect(Object key, Object val) throws IOException {\n                try {\n                    taskCtx.output().write(key, val);\n                }\n                catch (GridException e) {\n                    throw new IOException(e);\n                }\n            }\n        };\n\n        Reporter reporter = Reporter.NULL;\n\n        try {\n            RecordReader reader = inFormat.getRecordReader(split, jobConf, reporter);\n\n            Object key = reader.createKey();\n            Object val = reader.createValue();\n\n            mapper.configure(jobConf);\n\n            while (reader.next(key, val)) {\n                mapper.map(key, val, collector, reporter);\n            }\n\n            mapper.close();\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void run(GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV1JobImpl jobImpl = (GridHadoopV1JobImpl)taskCtx.job();\n\n        JobContext jobCtx = jobImpl.hadoopJobContext();\n\n        Reducer reducer = U.newInstance(jobCtx.getJobConf().getReducerClass());\n\n        OutputFormat outFormat = jobCtx.getJobConf().getOutputFormat();\n\n        Reporter reporter = Reporter.NULL;\n\n        NumberFormat numberFormat = NumberFormat.getInstance();\n\n        numberFormat.setMinimumIntegerDigits(5);\n        numberFormat.setGroupingUsed(false);\n\n        String fileName = \"part-\" + numberFormat.format(info().taskNumber());\n\n        reducer.configure(jobCtx.getJobConf());\n\n        GridHadoopTaskInput input = taskCtx.input();\n\n        TaskAttemptID attempt = jobImpl.attemptId(info());\n\n        jobCtx.getJobConf().set(\"mapreduce.task.attempt.id\", attempt.toString());\n\n        try {\n            final RecordWriter writer = outFormat.getRecordWriter(null, jobCtx.getJobConf(), fileName, reporter);\n\n            OutputCollector collector = new OutputCollector() {\n                @Override public void collect(Object key, Object val) throws IOException {\n                    writer.write(key, val);\n                }\n            };\n\n            try {\n                while (input.next()) {\n                    reducer.reduce(input.key(), input.values(), collector, reporter);\n                }\n\n                reducer.close();\n            }\n            finally {\n                writer.close(reporter);\n            }\n\n            OutputCommitter commiter = jobCtx.getJobConf().getOutputCommitter();\n\n            commiter.commitTask(new TaskAttemptContextImpl(jobCtx.getJobConf(), attempt));\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","id":90023,"modified_method":"/** {@inheritDoc} */\n    @Override public void run(GridHadoopTaskContext taskCtx) throws GridInterruptedException, GridException {\n        GridHadoopV2JobImpl jobImpl = (GridHadoopV2JobImpl) taskCtx.job();\n\n        JobConf jobConf = jobImpl.hadoopJobContext().getJobConf();\n\n        Reducer reducer = U.newInstance(jobConf.getReducerClass());\n\n        OutputFormat outFormat = jobConf.getOutputFormat();\n\n        Reporter reporter = Reporter.NULL;\n\n        NumberFormat numFormat = NumberFormat.getInstance();\n\n        numFormat.setMinimumIntegerDigits(5);\n        numFormat.setGroupingUsed(false);\n\n        String fileName = \"part-\" + numFormat.format(info().taskNumber());\n\n        reducer.configure(jobConf);\n\n        GridHadoopTaskInput input = taskCtx.input();\n\n        TaskAttemptID attempt = jobImpl.attemptId(info());\n\n        jobConf.set(\"mapreduce.task.attempt.id\", attempt.toString());\n\n        try {\n            final RecordWriter writer = outFormat.getRecordWriter(null, jobConf, fileName, reporter);\n\n            OutputCollector collector = new OutputCollector() {\n                @Override public void collect(Object key, Object val) throws IOException {\n                    writer.write(key, val);\n                }\n            };\n\n            try {\n                while (input.next()) {\n                    reducer.reduce(input.key(), input.values(), collector, reporter);\n                }\n\n                reducer.close();\n            }\n            finally {\n                writer.close(reporter);\n            }\n\n            OutputCommitter commiter = jobConf.getOutputCommitter();\n\n            commiter.commitTask(new TaskAttemptContextImpl(jobConf, attempt));\n        }\n        catch (IOException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public GridHadoopPartitioner partitioner() throws GridException {\n        try {\n            Class<? extends Partitioner> partCls = ctx.getPartitionerClass();\n\n            return new GridHadoopV2PartitionerAdapter((Partitioner<Object, Object>)U.newInstance(partCls));\n        }\n        catch (ClassNotFoundException e) {\n            throw new GridException(e);\n        }\n    }","id":90024,"modified_method":"/** {@inheritDoc} */\n    @Override public GridHadoopPartitioner partitioner() throws GridException {\n        Class partClsOld = ctx.getConfiguration().getClass(\"mapred.partitioner.class\", null);\n\n        if (partClsOld != null)\n            return new GridHadoopV1PartitionerAdapter(U.newInstance(ctx.getJobConf().getPartitionerClass()));\n\n        try {\n            Class<? extends Partitioner<?, ?>> partCls = ctx.getPartitionerClass();\n\n            return new GridHadoopV2PartitionerAdapter((Partitioner<Object, Object>) U.newInstance(partCls));\n        }\n        catch (ClassNotFoundException e) {\n            throw new GridException(e);\n        }\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @param jobId Job ID.\n     * @param jobInfo Job info.\n     */\n    public GridHadoopV2JobImpl(GridHadoopJobId jobId, GridHadoopDefaultJobInfo jobInfo) {\n        this.jobId = jobId;\n        this.jobInfo = jobInfo;\n\n        ctx = new JobContextImpl(jobInfo.configuration(), new JobID(jobId.globalId().toString(), jobId.localId()));\n\n        keyCls = ctx.getMapOutputKeyClass();\n        valCls = ctx.getMapOutputValueClass();\n    }","id":90025,"modified_method":"/**\n     * @param jobId Job ID.\n     * @param jobInfo Job info.\n     */\n    public GridHadoopV2JobImpl(GridHadoopJobId jobId, GridHadoopDefaultJobInfo jobInfo) {\n        this.jobId = jobId;\n        this.jobInfo = jobInfo;\n\n        JobID hadoopJobID = new JobID(jobId.globalId().toString(), jobId.localId());\n\n        ctx = new JobContextImpl(new JobConf(jobInfo.configuration()), hadoopJobID);\n\n        keyCls = ctx.getMapOutputKeyClass();\n        valCls = ctx.getMapOutputValueClass();\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Gets combiner class.\n     *\n     * @return Combiner class or {@code null} if combiner is not specified.\n     */\n    private Class<? extends Reducer<?, ?, ?, ?>> combinerClass() {\n        try {\n            return ctx.getCombinerClass();\n        }\n        catch (ClassNotFoundException e) {\n            // TODO check combiner class at initialization and throw meaningful exception.\n            throw new GridRuntimeException(e);\n        }\n    }","id":90026,"modified_method":"/**\n     * Gets combiner class.\n     *\n     * @return Combiner class or {@code null} if combiner is not specified.\n     */\n    private Class combinerClass() {\n        Class res = ctx.getJobConf().getCombinerClass();\n\n        try {\n            if (res == null)\n                res = ctx.getCombinerClass();\n\n            return res;\n        }\n        catch (ClassNotFoundException e) {\n            // TODO check combiner class at initialization and throw meaningful exception.\n            throw new GridRuntimeException(e);\n        }\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public GridHadoopTask createTask(GridHadoopTaskInfo taskInfo) {\n        switch (taskInfo.type()) {\n            case MAP:\n                return new GridHadoopV2MapTask(taskInfo);\n\n            case REDUCE:\n                return new GridHadoopV2ReduceTask(taskInfo);\n\n            case COMBINE:\n                return new GridHadoopV2CombineTask(taskInfo);\n\n            case COMMIT:\n                return new GridHadoopV2CleanupTask(taskInfo, false);\n\n            case ABORT:\n                return new GridHadoopV2CleanupTask(taskInfo, true);\n\n            default:\n                return null;\n        }\n    }","id":90027,"modified_method":"/** {@inheritDoc} */\n    @Override public GridHadoopTask createTask(GridHadoopTaskInfo taskInfo) {\n        boolean isAbort = taskInfo.type() == GridHadoopTaskType.ABORT;\n\n        switch (taskInfo.type()) {\n            case MAP: {\n                if (ctx.getJobConf().getUseNewMapper())\n                    return new GridHadoopV2MapTask(taskInfo);\n                else\n                    return  new GridHadoopV1MapTask(taskInfo);\n            }\n\n            case REDUCE: {\n                if (ctx.getJobConf().getUseNewReducer())\n                    return new GridHadoopV2ReduceTask(taskInfo);\n                else\n                    return new GridHadoopV1ReduceTask(taskInfo);\n            }\n\n            case COMBINE: {\n                if (ctx.getJobConf().getCombinerClass() == null)\n                    return new GridHadoopV2CombineTask(taskInfo);\n                else\n                    return new GridHadoopV1CombineTask(taskInfo);\n            }\n\n            case COMMIT:\n            case ABORT: {\n                if (ctx.getJobConf().getUseNewReducer())\n                    return new GridHadoopV2CleanupTask(taskInfo, isAbort);\n                else\n                    return new GridHadoopV1CleanupTask(taskInfo, isAbort);\n            }\n\n            default:\n                return null;\n        }\n    }","commit_id":"44a09fdb19ec401324a90875f5d8f793b62cd2ac","url":"https://github.com/apache/ignite"},{"original_method":"private static void invoke(final Project project, Editor editor, PsiFile file, boolean isInteractive) {\n    final PsiParameter myParameter = findParameterAtCursor(file, editor);\n    if (!CodeInsightUtilBase.prepareFileForWrite(myParameter.getContainingFile())) return;\n    final Collection<SmartPsiElementPointer<PsiParameter>> unboundedParams = getUnboundedParams(myParameter);\n    if (unboundedParams.size() > 1 && !ApplicationManager.getApplication().isUnitTestMode()) {\n      ClassMember[] members = new ClassMember[unboundedParams.size()];\n      ClassMember selection = null;\n      int i = 0;\n      for (SmartPsiElementPointer<PsiParameter> pointer : unboundedParams) {\n        final PsiParameter parameter = pointer.getElement();\n        final ParameterClassMember classMember = new ParameterClassMember(parameter);\n        members[i++] = classMember;\n        if (parameter == myParameter) {\n          selection = classMember;\n        }\n      }\n      final PsiParameterList parameterList = ((PsiMethod)myParameter.getDeclarationScope()).getParameterList();\n      Arrays.sort(members, new Comparator<ClassMember>() {\n        @Override\n        public int compare(ClassMember o1, ClassMember o2) {\n          return parameterList.getParameterIndex(((ParameterClassMember)o1).getParameter()) - \n                 parameterList.getParameterIndex(((ParameterClassMember)o2).getParameter());\n        }\n      });\n\n      final MemberChooser<ClassMember> chooser = new MemberChooser<ClassMember>(members, false, true, project);\n      if (selection != null) {\n        chooser.selectElements(new ClassMember[] {selection});\n      }\n      chooser.setTitle(\"Choose Constructor Parameters to Generate Fields\");\n      chooser.setCopyJavadocVisible(false);\n      chooser.show();\n      if (chooser.getExitCode() != DialogWrapper.OK_EXIT_CODE) return;\n      final List<ClassMember> selectedElements = chooser.getSelectedElements();\n      if (selectedElements == null) return;\n      if (selectedElements.size() == 1) {\n        processParameter(project, ((ParameterClassMember)selectedElements.get(0)).getParameter(), isInteractive);\n      } else {\n        //do not ask for names in batch\n        for (ClassMember selectedElement : selectedElements) {\n          processParameter(project, ((ParameterClassMember)selectedElement).getParameter(), false);\n        }\n      }\n    }\n    else {\n      processParameter(project, myParameter, isInteractive);\n    }\n    unboundedParams.clear();\n  }","id":90028,"modified_method":"private static void invoke(final Project project, Editor editor, PsiFile file, boolean isInteractive) {\n    PsiParameter myParameter = findParameterAtCursor(file, editor);\n    if (!CodeInsightUtilBase.prepareFileForWrite(file)) return;\n    final PsiMethod method = myParameter != null ? (PsiMethod)myParameter.getDeclarationScope() : PsiTreeUtil.getParentOfType(file.findElementAt(editor.getCaretModel().getOffset()), PsiMethod.class);\n    LOG.assertTrue(method != null);\n    final Collection<SmartPsiElementPointer<PsiParameter>> unboundedParams = getUnboundedParams(method);\n    if (myParameter == null) {\n      myParameter = unboundedParams.iterator().next().getElement();\n    }\n    if (unboundedParams.size() > 1 && !ApplicationManager.getApplication().isUnitTestMode()) {\n      ClassMember[] members = new ClassMember[unboundedParams.size()];\n      ClassMember selection = null;\n      int i = 0;\n      for (SmartPsiElementPointer<PsiParameter> pointer : unboundedParams) {\n        final PsiParameter parameter = pointer.getElement();\n        final ParameterClassMember classMember = new ParameterClassMember(parameter);\n        members[i++] = classMember;\n        if (parameter == myParameter) {\n          selection = classMember;\n        }\n      }\n      final PsiParameterList parameterList = method.getParameterList();\n      Arrays.sort(members, new Comparator<ClassMember>() {\n        @Override\n        public int compare(ClassMember o1, ClassMember o2) {\n          return parameterList.getParameterIndex(((ParameterClassMember)o1).getParameter()) - \n                 parameterList.getParameterIndex(((ParameterClassMember)o2).getParameter());\n        }\n      });\n\n      final MemberChooser<ClassMember> chooser = new MemberChooser<ClassMember>(members, false, true, project);\n      if (selection != null) {\n        chooser.selectElements(new ClassMember[] {selection});\n      }\n      chooser.setTitle(\"Choose Constructor Parameters to Generate Fields\");\n      chooser.setCopyJavadocVisible(false);\n      chooser.show();\n      if (chooser.getExitCode() != DialogWrapper.OK_EXIT_CODE) return;\n      final List<ClassMember> selectedElements = chooser.getSelectedElements();\n      if (selectedElements == null) return;\n      if (selectedElements.size() == 1) {\n        processParameter(project, ((ParameterClassMember)selectedElements.get(0)).getParameter(), isInteractive);\n      } else {\n        //do not ask for names in batch\n        for (ClassMember selectedElement : selectedElements) {\n          processParameter(project, ((ParameterClassMember)selectedElement).getParameter(), false);\n        }\n      }\n    }\n    else {\n      processParameter(project, myParameter, isInteractive);\n    }\n    unboundedParams.clear();\n  }","commit_id":"eab8b8b456ae6d06c6da6351dbd1655d9f9da582","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    PsiParameter psiParameter = findParameterAtCursor(file, editor);\n    if (psiParameter == null) return false;\n    final Collection<SmartPsiElementPointer<PsiParameter>> params = getUnboundedParams(psiParameter);\n    params.clear();\n    final PsiParameter[] parameters = ((PsiMethod)psiParameter.getDeclarationScope()).getParameterList().getParameters();\n    for (PsiParameter parameter : parameters) {\n      params.add(SmartPointerManager.getInstance(project).createSmartPsiElementPointer(parameter));\n    }\n    myName = params.size() > 1 && !ApplicationManager.getApplication().isUnitTestMode() ? null : psiParameter.getName();\n    return isAvailable(psiParameter);\n  }","id":90029,"modified_method":"public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    PsiParameter psiParameter = findParameterAtCursor(file, editor);\n    PsiMethod method = null;\n    if (psiParameter == null) {\n      final PsiElement elementAt = file.findElementAt(editor.getCaretModel().getOffset());\n      if (elementAt instanceof PsiIdentifier) {\n        final PsiElement parent = elementAt.getParent();\n        if (parent instanceof PsiMethod) {\n          method  = (PsiMethod)parent;\n        }\n      }\n    } else {\n      final PsiElement declarationScope = psiParameter.getDeclarationScope();\n      if (declarationScope instanceof PsiMethod) {\n        method = (PsiMethod)declarationScope;\n      }\n    }\n    if (method == null) return false;\n    final Collection<SmartPsiElementPointer<PsiParameter>> params = getUnboundedParams(method);\n    params.clear();\n    final PsiParameter[] parameters = method.getParameterList().getParameters();\n    for (PsiParameter parameter : parameters) {\n      params.add(SmartPointerManager.getInstance(project).createSmartPsiElementPointer(parameter));\n    }\n    if (params.isEmpty()) return false;\n    if (psiParameter == null) {\n      psiParameter = params.iterator().next().getElement();\n      LOG.assertTrue(psiParameter != null);\n    }\n    myName = params.size() > 1 && !ApplicationManager.getApplication().isUnitTestMode() ? null : psiParameter.getName();\n    return isAvailable(psiParameter);\n  }","commit_id":"eab8b8b456ae6d06c6da6351dbd1655d9f9da582","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static Collection<SmartPsiElementPointer<PsiParameter>> getUnboundedParams(PsiParameter parameter) {\n    final PsiElement psiElement = parameter.getDeclarationScope();\n    if (!(psiElement instanceof PsiMethod)) return Collections.emptyList();\n    final PsiMethod psiMethod = (PsiMethod)psiElement;\n    Map<SmartPsiElementPointer<PsiParameter>, Boolean> params = psiMethod.getUserData(PARAMS);\n    if (params == null) psiMethod.putUserData(PARAMS, params = new ConcurrentWeakHashMap<SmartPsiElementPointer<PsiParameter>, Boolean>(1));\n    final Map<SmartPsiElementPointer<PsiParameter>, Boolean> finalParams = params;\n    return new AbstractCollection<SmartPsiElementPointer<PsiParameter>>() {\n      @Override\n      public boolean add(SmartPsiElementPointer<PsiParameter> psiVariable) {\n        PsiParameter psiParameter = psiVariable.getElement();\n        if (psiParameter == null || !isAvailable(psiParameter)) return false;\n        return finalParams.put(psiVariable, Boolean.TRUE) == null;\n      }\n\n      @Override\n      public Iterator<SmartPsiElementPointer<PsiParameter>> iterator() {\n        return finalParams.keySet().iterator();\n      }\n\n      @Override\n      public int size() {\n        return finalParams.size();\n      }\n\n      @Override\n      public void clear() {\n        finalParams.clear();\n      }\n    };\n  }","id":90030,"modified_method":"@NotNull\n  private static Collection<SmartPsiElementPointer<PsiParameter>> getUnboundedParams(PsiMethod psiMethod) {\n    Map<SmartPsiElementPointer<PsiParameter>, Boolean> params = psiMethod.getUserData(PARAMS);\n    if (params == null) psiMethod.putUserData(PARAMS, params = new ConcurrentWeakHashMap<SmartPsiElementPointer<PsiParameter>, Boolean>(1));\n    final Map<SmartPsiElementPointer<PsiParameter>, Boolean> finalParams = params;\n    return new AbstractCollection<SmartPsiElementPointer<PsiParameter>>() {\n      @Override\n      public boolean add(SmartPsiElementPointer<PsiParameter> psiVariable) {\n        PsiParameter psiParameter = psiVariable.getElement();\n        if (psiParameter == null || !isAvailable(psiParameter)) return false;\n        return finalParams.put(psiVariable, Boolean.TRUE) == null;\n      }\n\n      @Override\n      public Iterator<SmartPsiElementPointer<PsiParameter>> iterator() {\n        return finalParams.keySet().iterator();\n      }\n\n      @Override\n      public int size() {\n        return finalParams.size();\n      }\n\n      @Override\n      public void clear() {\n        finalParams.clear();\n      }\n    };\n  }","commit_id":"eab8b8b456ae6d06c6da6351dbd1655d9f9da582","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public SearchScope getUseScope() {\n    if (!isPhysical()) {\n      final PsiFile file = getContainingFile();\n      final PsiElement context = file.getContext();\n      if (context != null) return new LocalSearchScope(context);\n      return super.getUseScope();\n    }\n\n    return new LocalSearchScope(getDeclarationScope());\n  }","id":90031,"modified_method":"@NotNull\n  public SearchScope getUseScope() {\n    if (!isPhysical()) {\n      final PsiFile file = getContainingFile();\n      final PsiElement context = file.getContext();\n      if (context != null) return new LocalSearchScope(context);\n      return super.getUseScope();\n    }\n\n    final PsiElement scope = getDeclarationScope();\n    if (scope instanceof GrDocCommentOwner) {\n      GrDocCommentOwner owner = (GrDocCommentOwner)scope;\n      final GrDocComment comment = owner.getGrDocComment();\n      if (comment != null) {\n        return new LocalSearchScope(new PsiElement[]{scope, comment});\n      }\n    }\n\n    return new LocalSearchScope(scope);\n  }","commit_id":"750d28986c1f835c3bb9b6815c26d58d8c2ca79e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean mayRenameInplace(PsiElement elementToRename, final PsiElement nameSuggestionContext) {\n    if (!(elementToRename instanceof PsiVariable)) return false;\n    if (nameSuggestionContext != null && nameSuggestionContext.getContainingFile() != elementToRename.getContainingFile()) return false;\n    if (!(elementToRename instanceof PsiLocalVariable) && !(elementToRename instanceof PsiParameter)) return false;\n    SearchScope useScope = elementToRename.getUseScope();\n    if (!(useScope instanceof LocalSearchScope)) return false;\n    PsiElement[] scopeElements = ((LocalSearchScope) useScope).getScope();\n    if (scopeElements.length > 1) return false; //assume there are no elements with use scopes with holes in'em\n    PsiFile containingFile = elementToRename.getContainingFile();\n    return PsiTreeUtil.isAncestor(containingFile, scopeElements[0], false);\n  }","id":90032,"modified_method":"public static boolean mayRenameInplace(PsiElement elementToRename, final PsiElement nameSuggestionContext) {\n    if (!(elementToRename instanceof PsiVariable)) return false;\n    if (nameSuggestionContext != null && nameSuggestionContext.getContainingFile() != elementToRename.getContainingFile()) return false;\n    if (!(elementToRename instanceof PsiLocalVariable) && !(elementToRename instanceof PsiParameter)) return false;\n    SearchScope useScope = elementToRename.getUseScope();\n    if (!(useScope instanceof LocalSearchScope)) return false;\n    PsiElement[] scopeElements = ((LocalSearchScope) useScope).getScope();\n    if (scopeElements.length > 1 &&                          // assume there are no elements with use scopes with holes in'em\n        !isElementWithComment(scopeElements)) return false;  // except a case of element and it's doc comment\n    PsiFile containingFile = elementToRename.getContainingFile();\n    return PsiTreeUtil.isAncestor(containingFile, scopeElements[0], false);\n  }","commit_id":"35fed7feeff6f29ae5d6cbef72f99a77de01ae2f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public SearchScope getUseScope() {\n    return new LocalSearchScope(getDeclarationScope());\n  }","id":90033,"modified_method":"@NotNull\n  public SearchScope getUseScope() {\n    final PsiElement declarationScope = getDeclarationScope();\n    if (declarationScope instanceof PsiMethod) {\n      final PsiDocComment comment = ((PsiMethod)declarationScope).getDocComment();\n      if (comment != null && !declarationScope.getTextRange().contains(comment.getTextRange())) {\n        return new LocalSearchScope(new PsiElement[]{declarationScope, comment});\n      }\n    }\n    return new LocalSearchScope(declarationScope);\n  }","commit_id":"35fed7feeff6f29ae5d6cbef72f99a77de01ae2f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Start the dependency.\n     */\n    public void start() {\n\n        if (isOptional() && !isAggregate()) {\n            if (m_di == null) {\n                // If nullable are supported, create the nullable object.\n                if (m_supportNullable) {\n                    // To load the proxy we use the POJO class loader. Indeed, this classloader imports iPOJO (so can access to Nullable) and has\n                    // access to the service specification.\n                    try {\n                        m_nullable =\n                            Proxy.newProxyInstance(getHandler().getInstanceManager().getClazz().getClassLoader(), new Class[] {\n                                    getSpecification(), Nullable.class }, new NullableObject()); // NOPMD\n                    } catch (NoClassDefFoundError e) {\n                        // A NoClassDefFoundError is thrown if the specification uses a class not accessible by the actual instance.\n                        // It generally comes from a missing import.\n                        throw new IllegalStateException(\"Cannot create the Nullable object, a referenced class cannot be loaded: \" + e.getMessage());\n                    } catch (Throwable e) { // Catch any other exception that can occurs\n                        throw new IllegalStateException(\n                                \"Cannot create the Nullable object, an unexpected error occurs: \"\n                                        + e.getMessage());\n                    }\n                }\n            } else {\n                // Create the default-implementation object.\n                try {\n                    Class clazz = getHandler().getInstanceManager().getContext().getBundle().loadClass(m_di);\n                    m_nullable = clazz.newInstance();\n                } catch (IllegalAccessException e) {\n                    throw new IllegalStateException(\"Cannot load the default-implementation \" + m_di + \" : \" + e.getMessage());\n                } catch (InstantiationException e) {\n                    throw new IllegalStateException(\"Cannot load the default-implementation \" + m_di + \" : \" + e.getMessage());\n                } catch (ClassNotFoundException e) {\n                    throw new IllegalStateException(\"Cannot load the default-implementation \" + m_di + \" : \" + e.getMessage());\n                } catch (Throwable e) { // Catch any other exception\n                    throw new IllegalStateException(\"Cannot load the default-implementation (unexpected exception) \" + m_di + \" : \" + e.getMessage());\n                }\n            }\n        }\n\n        if (m_isProxy) {\n            if (isAggregate()) {\n                m_proxyObject = new ServiceCollection(this);\n            } else {\n                String type = getHandler().getInstanceManager().getContext().getProperty(DependencyHandler.PROXY_TYPE_PROPERTY);\n                if (type == null || type.equals(DependencyHandler.SMART_PROXY)) {\n                    SmartProxyFactory proxyFactory = new SmartProxyFactory(this.getClass().getClassLoader());\n                    m_proxyObject = proxyFactory.getProxy(getSpecification(), this);\n                } else {\n                    DynamicProxyFactory proxyFactory = new DynamicProxyFactory();\n                    m_proxyObject = proxyFactory.getProxy(getSpecification());\n                }\n            }\n        }\n\n        super.start();\n        // Once the dependency is started, access to fields must be synchronized.\n        synchronized (this) {\n            if (getBindingPolicy() == STATIC_BINDING_POLICY && m_handler.getInstanceManager().getPojoObjects() != null) {\n                m_isFrozen = true;\n            }\n\n            m_isStarted = true;\n        }\n\n\n    }","id":90034,"modified_method":"/**\n     * Start the dependency.\n     */\n    public void start() {\n\n        if (isOptional() && !isAggregate()) {\n            if (m_di == null) {\n                // If nullable are supported, create the nullable object.\n                if (m_supportNullable) {\n                    // To load the proxy we use the POJO class loader. Indeed, this classloader imports iPOJO (so can access to Nullable) and has\n                    // access to the service specification.\n                    try {\n                        ClassLoader cl = new NullableClassLoader(\n                                getHandler().getInstanceManager().getClazz().getClassLoader(), \n                                getSpecification().getClassLoader());\n                        \n                        m_nullable =\n                            Proxy.newProxyInstance(cl, new Class[] {\n                                    getSpecification(), Nullable.class }, new NullableObject()); // NOPMD\n                        \n                    } catch (NoClassDefFoundError e) {\n                        // A NoClassDefFoundError is thrown if the specification uses a class not accessible by the actual instance.\n                        // It generally comes from a missing import.\n                        throw new IllegalStateException(\"Cannot create the Nullable object, a referenced class cannot be loaded: \" + e.getMessage());\n                    } catch (Throwable e) { // Catch any other exception that can occurs\n                        throw new IllegalStateException(\n                                \"Cannot create the Nullable object, an unexpected error occurs: \"\n                                        + e.getMessage());\n                    }\n                }\n            } else {\n                // Create the default-implementation object.\n                try {\n                    Class clazz = getHandler().getInstanceManager().getContext().getBundle().loadClass(m_di);\n                    m_nullable = clazz.newInstance();\n                } catch (IllegalAccessException e) {\n                    throw new IllegalStateException(\"Cannot load the default-implementation \" + m_di + \" : \" + e.getMessage());\n                } catch (InstantiationException e) {\n                    throw new IllegalStateException(\"Cannot load the default-implementation \" + m_di + \" : \" + e.getMessage());\n                } catch (ClassNotFoundException e) {\n                    throw new IllegalStateException(\"Cannot load the default-implementation \" + m_di + \" : \" + e.getMessage());\n                } catch (Throwable e) { // Catch any other exception\n                    throw new IllegalStateException(\"Cannot load the default-implementation (unexpected exception) \" + m_di + \" : \" + e.getMessage());\n                }\n            }\n        }\n\n        if (m_isProxy) {\n            if (isAggregate()) {\n                m_proxyObject = new ServiceCollection(this);\n            } else {\n                String type = getHandler().getInstanceManager().getContext().getProperty(DependencyHandler.PROXY_TYPE_PROPERTY);\n                if (type == null || type.equals(DependencyHandler.SMART_PROXY)) {\n                    SmartProxyFactory proxyFactory = new SmartProxyFactory(this.getClass().getClassLoader());\n                    m_proxyObject = proxyFactory.getProxy(getSpecification(), this);\n                } else {\n                    DynamicProxyFactory proxyFactory = new DynamicProxyFactory();\n                    m_proxyObject = proxyFactory.getProxy(getSpecification());\n                }\n            }\n        }\n\n        super.start();\n        // Once the dependency is started, access to fields must be synchronized.\n        synchronized (this) {\n            if (getBindingPolicy() == STATIC_BINDING_POLICY && m_handler.getInstanceManager().getPojoObjects() != null) {\n                m_isFrozen = true;\n            }\n\n            m_isStarted = true;\n        }\n\n\n    }","commit_id":"b8ec0448c2f38cec2f95f0433fc58b7552d6673f","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Check if the dependency given is valid in the sense that metadata are consistent.\n     * @param dep : the dependency to check\n     * @param manipulation : the component-type manipulation metadata\n     * @return true if the dependency is valid\n     * @throws ConfigurationException : the checked dependency is not correct\n     */\n    private boolean checkDependency(Dependency dep, PojoMetadata manipulation) throws ConfigurationException {       \n        // Check the internal type of dependency\n        String field = dep.getField();\n        DependencyCallback[] callbacks = dep.getCallbacks();\n\n        if (callbacks == null && field == null) {\n            throw new ConfigurationException(\"A service requirement requires at least binding methods or a field\");\n        }\n\n        for (int i = 0; callbacks != null && i < callbacks.length; i++) {\n            MethodMetadata[] mets = manipulation.getMethods(callbacks[i].getMethodName());\n            if (mets.length == 0) {\n                debug(\"A requirement callback \" + callbacks[i].getMethodName() + \" does not exist in the implementation class, will try the super classes\");\n            } else {\n                if (mets[0].getMethodArguments().length > 2) {\n                    throw new ConfigurationException(\"Requirement Callback : A requirement callback \"\n                            + callbacks[i].getMethodName()\n                            + \" must have 0, 1 or 2 arguments\");\n                }\n\n                callbacks[i].setArgument(mets[0].getMethodArguments());\n\n                if (mets[0].getMethodArguments().length == 1) {\n                    if (!mets[0].getMethodArguments()[0].equals(ServiceReference.class.getName())) {\n                        // The callback receives the service object.\n                        setSpecification(dep, mets[0].getMethodArguments()[0], false); // Just warn if a mismatch is discovered.\n                    }\n                } else if (mets[0].getMethodArguments().length == 2) {\n                    // The callback receives service object, service reference. Check that the second argument is a service reference\n                    if (!(mets[0].getMethodArguments()[1].equals(ServiceReference.class.getName()) // callback with (service object, service reference)\n                           || mets[0].getMethodArguments()[1].equals(Dictionary.class.getName()) // callback with (service object, service properties in a dictionary)\n                           || mets[0].getMethodArguments()[1].equals(Map.class.getName()))) { // callback with (service object, service properties in a map)\n                        String message =\n                                \"The requirement callback \" + callbacks[i].getMethodName() + \" must have a ServiceReference, a Dictionary or a Map as the second argument\";\n                        throw new ConfigurationException(message);\n                    }\n                    setSpecification(dep, mets[0].getMethodArguments()[0], false); // Just warn if a mismatch is discovered.\n                }\n            }\n\n        }\n\n        if (field != null) {\n            FieldMetadata meta = manipulation.getField(field);\n            if (meta == null) {\n                throw new ConfigurationException(\"Requirement Callback : A requirement field \"\n                        + field\n                        + \" does not exist in the implementation class\");\n            }\n            String type = meta.getFieldType();\n            if (type.endsWith(\"[]\")) {\n                if (dep.isProxy()) {\n                    warn(\"Arrays cannot be used for proxied dependencies - Disable the proxy mode\");\n                    dep.setProxy(false);\n                }\n                // Set the dependency to multiple\n                dep.setAggregate(true);\n                type = type.substring(0, type.length() - 2);\n            } else if (type.equals(List.class.getName()) || type.equals(Collection.class.getName())) {\n                dep.setType(LIST);\n                type = null;\n            } else if (type.equals(Vector.class.getName())) {\n                dep.setType(VECTOR);\n                if (dep.isProxy()) {\n                    warn(\"Vectors cannot be used for proxied dependencies - Disable the proxy mode\");\n                    dep.setProxy(false);\n                }\n                type = null;\n            } else if (type.equals(Set.class.getName())) {\n                dep.setType(SET);\n                type = null;\n            } else {\n                if (dep.isAggregate()) {\n                    throw new ConfigurationException(\"A required service is not correct : the field \"\n                            + meta.getFieldName()\n                            + \" must be an array to support aggregate injections\");\n                }\n            }\n            setSpecification(dep, type, true); // Throws an exception if the field type mismatch.\n        }\n        \n        // Disables proxy on null (nullable=false)\n        if (dep.isProxy()  && dep.isOptional() && ! dep.supportsNullable()) {\n            dep.setProxy(false);\n            warn(\"Optional Null Dependencies do not support proxying - Disable the proxy mode\");\n        }\n\n        // Check that all required info are set\n        return dep.getSpecification() != null;\n    }","id":90035,"modified_method":"/**\n     * Check if the dependency given is valid in the sense that metadata are consistent.\n     * @param dep : the dependency to check\n     * @param manipulation : the component-type manipulation metadata\n     * @return true if the dependency is valid\n     * @throws ConfigurationException : the checked dependency is not correct\n     */\n    private boolean checkDependency(Dependency dep, PojoMetadata manipulation) throws ConfigurationException {       \n        // Check the internal type of dependency\n        String field = dep.getField();\n        DependencyCallback[] callbacks = dep.getCallbacks();\n\n        if (callbacks == null && field == null) {\n            throw new ConfigurationException(\"A service requirement requires at least binding methods or a field\");\n        }\n\n        for (int i = 0; callbacks != null && i < callbacks.length; i++) {\n            MethodMetadata[] mets = manipulation.getMethods(callbacks[i].getMethodName());\n            if (mets.length == 0) {\n                debug(\"A requirement callback \" + callbacks[i].getMethodName() + \" does not exist in the implementation class, will try the super classes\");\n            } else {\n                if (mets[0].getMethodArguments().length > 2) {\n                    throw new ConfigurationException(\"Requirement Callback : A requirement callback \"\n                            + callbacks[i].getMethodName()\n                            + \" must have 0, 1 or 2 arguments\");\n                }\n\n                callbacks[i].setArgument(mets[0].getMethodArguments());\n\n                if (mets[0].getMethodArguments().length == 1) {\n                    if (!mets[0].getMethodArguments()[0].equals(ServiceReference.class.getName())) {\n                        // The callback receives the service object.\n                        setSpecification(dep, mets[0].getMethodArguments()[0], false); // Just warn if a mismatch is discovered.\n                    }\n                } else if (mets[0].getMethodArguments().length == 2) {\n                    // The callback receives service object, service reference. Check that the second argument is a service reference\n                    if (!(mets[0].getMethodArguments()[1].equals(ServiceReference.class.getName()) // callback with (service object, service reference)\n                           || mets[0].getMethodArguments()[1].equals(Dictionary.class.getName()) // callback with (service object, service properties in a dictionary)\n                           || mets[0].getMethodArguments()[1].equals(Map.class.getName()))) { // callback with (service object, service properties in a map)\n                        String message =\n                                \"The requirement callback \" + callbacks[i].getMethodName() + \" must have a ServiceReference, a Dictionary or a Map as the second argument\";\n                        throw new ConfigurationException(message);\n                    }\n                    setSpecification(dep, mets[0].getMethodArguments()[0], false); // Just warn if a mismatch is discovered.\n                }\n            }\n\n        }\n\n        if (field != null) {\n            FieldMetadata meta = manipulation.getField(field);\n            if (meta == null) {\n                throw new ConfigurationException(\"Requirement Callback : A requirement field \"\n                        + field\n                        + \" does not exist in the implementation class\");\n            }\n            String type = meta.getFieldType();\n            if (type.endsWith(\"[]\")) {\n                if (dep.isProxy()) {\n                    info(\"Arrays cannot be used for proxied dependencies - Disable the proxy mode\");\n                    dep.setProxy(false);\n                }\n                // Set the dependency to multiple\n                dep.setAggregate(true);\n                type = type.substring(0, type.length() - 2);\n            } else if (type.equals(List.class.getName()) || type.equals(Collection.class.getName())) {\n                dep.setType(LIST);\n                type = null;\n            } else if (type.equals(Vector.class.getName())) {\n                dep.setType(VECTOR);\n                if (dep.isProxy()) {\n                    warn(\"Vectors cannot be used for proxied dependencies - Disable the proxy mode\");\n                    dep.setProxy(false);\n                }\n                type = null;\n            } else if (type.equals(Set.class.getName())) {\n                dep.setType(SET);\n                type = null;\n            } else {\n                if (dep.isAggregate()) {\n                    throw new ConfigurationException(\"A required service is not correct : the field \"\n                            + meta.getFieldName()\n                            + \" must be an array to support aggregate injections\");\n                }\n            }\n            setSpecification(dep, type, true); // Throws an exception if the field type mismatch.\n        }\n        \n        // Disables proxy on null (nullable=false)\n        if (dep.isProxy()  && dep.isOptional() && ! dep.supportsNullable()) {\n            dep.setProxy(false);\n            warn(\"Optional Null Dependencies do not support proxying - Disable the proxy mode\");\n        }\n\n        // Check that all required info are set\n        return dep.getSpecification() != null;\n    }","commit_id":"b8ec0448c2f38cec2f95f0433fc58b7552d6673f","url":"https://github.com/apache/felix"},{"original_method":"@Test\n    public void testServiceProperty() {\n          // Version 1.0\n          ServiceReference refv1 = ipojo.getServiceReferenceByName(MyService.class.getName(), \"instance-v1\");\n          Assert.assertNotNull(refv1);\n          String version = (String) refv1.getProperty(\"factory.version\");\n          Assert.assertEquals(\"1.0\", version);\n\n          // Version 1.1\n          ServiceReference refv11 = ipojo.getServiceReferenceByName(MyService.class.getName(), \"instance-v1.1\");\n          Assert.assertNotNull(refv11);\n          String version11 = (String) refv11.getProperty(\"factory.version\");\n\n          Assert.assertEquals(\"1.1\", version11);\n\n          // No Version\n          ServiceReference refany = ipojo.getServiceReferenceByName(MyService.class.getName(), \"instance-any\");\n          Assert.assertNotNull(refany);\n          String any = (String) refany.getProperty(\"factory.version\");\n          Assert.assertNotNull(any);\n\n          // No version set in the factory, so no version.\n          ServiceReference refmci = ipojo.getServiceReferenceByName(MyService.class.getName(), \"MyComponentInstance\");\n          Assert.assertNotNull(refmci);\n          String mci = (String) refmci.getProperty(\"factory.version\");\n          Assert.assertNull(mci);\n    }","id":90036,"modified_method":"@Test\n    public void testServiceProperty() throws InvalidSyntaxException {\n          \n          // Version 1.0\n          //ServiceReference refv1 = ipojo.getServiceReferenceByName(MyService.class.getName(), \"instance-v1\");\n          ServiceReference[] refv1 = context.getAllServiceReferences(MyService.class.getName(), \"(instance.name=instance-v1)\");\n          Assert.assertNotNull(refv1);\n          String version = (String) refv1[0].getProperty(\"factory.version\");\n          Assert.assertEquals(\"1.0\", version);\n\n          // Version 1.1\n          ServiceReference[] refv11 = context.getAllServiceReferences(MyService.class.getName(), \"(instance.name=instance-v1.1)\");          \n          //ServiceReference refv11 = ipojo.getServiceReferenceByName(MyService.class.getName(), \"instance-v1.1\");\n          Assert.assertNotNull(refv11);\n          String version11 = (String) refv11[0].getProperty(\"factory.version\");\n\n          Assert.assertEquals(\"1.1\", version11);\n\n          // No Version\n          ServiceReference[] refany = context.getAllServiceReferences(MyService.class.getName(), \"(instance.name=instance-any)\");          \n\n          // ServiceReference refany = ipojo.getServiceReferenceByName(MyService.class.getName(), \"instance-any\");\n          Assert.assertNotNull(refany);\n          String any = (String) refany[0].getProperty(\"factory.version\");\n          Assert.assertNotNull(any);\n\n          // No version set in the factory, so no version.\n          ServiceReference[] refmci = context.getAllServiceReferences(MyService.class.getName(), \"(instance.name=MyComponentInstance)\");          \n          //ServiceReference refmci = ipojo.getServiceReferenceByName(MyService.class.getName(), \"MyComponentInstance\");\n          Assert.assertNotNull(refmci);\n          String mci = (String) refmci[0].getProperty(\"factory.version\");\n          Assert.assertNull(mci);\n    }","commit_id":"b8ec0448c2f38cec2f95f0433fc58b7552d6673f","url":"https://github.com/apache/felix"},{"original_method":"@Configuration\n    public static Option[] configure() {\n\n        File tmp = new File(\"target/tmp\");\n        tmp.mkdirs();\n\n        Option[] opt =  options(\n                felix(),\n                equinox(),\n                knopflerfish(),\n                provision(\n                        // Runtime.\n                        mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.ipojo\").version(asInProject()),\n                        mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.ipojo.test.helpers\").version(asInProject()),\n                        mavenBundle().groupId( \"org.ops4j.pax.swissbox\" ).artifactId( \"pax-swissbox-tinybundles\" ).version(asInProject())\n                        ),\n                provision(\n                        newBundle()\n                            .addClass( MyService.class )\n                            .prepare()\n                           .set(Constants.BUNDLE_SYMBOLICNAME,\"ServiceInterface\")\n                           .set(Constants.EXPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service\")\n                            .build( asURL() ).toExternalForm()\n                    ),\n               provision(\n                       // Component V1\n                        newBundle()\n                            .addClass(MyComponent.class)\n                            .prepare(\n                                    with()\n                                        .set(Constants.BUNDLE_SYMBOLICNAME,\"ProviderV1\")\n                                        .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service\")\n                                    )\n                            .build( asiPOJOBundle(new File(tmp, \"provider-v1.jar\"), new File(\"provider-v1.xml\"))).toExternalForm(),\n                     // Component V1.1 (Bundle Version)\n                        newBundle()\n                            .addClass(MyComponent.class)\n                            .prepare(\n                                    with()\n                                        .set(Constants.BUNDLE_SYMBOLICNAME,\"ProviderV1.1\")\n                                        .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service\")\n                                        .set(Constants.BUNDLE_VERSION, \"1.1\")\n                                    )\n                            .build( asiPOJOBundle(new File(tmp, \"provider-v1.1.jar\"), new File(\"provider-v1.1.xml\"))).toExternalForm(),\n                // Instance declaration\n                newBundle()\n                    .prepare(\n                            with()\n                                .set(Constants.BUNDLE_SYMBOLICNAME,\"Instances\")\n                            )\n                    .build( asiPOJOBundle(new File(tmp, \"instances.jar\"), new File(\"instances.xml\"))).toExternalForm()\n\n                    )\n                );\n        return opt;\n    }","id":90037,"modified_method":"@Configuration\n    public static Option[] configure() {\n\n        File tmp = new File(\"target/tmp\");\n        tmp.mkdirs();\n\n        Option[] opt =  options(\n                felix(),\n                equinox(),\n                knopflerfish(),\n                provision(\n                        // Runtime.\n                        mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.ipojo\").version(asInProject()),\n                        mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.ipojo.test.helpers\").version(asInProject())\n                        // mavenBundle().groupId( \"org.ops4j.pax.swissbox\" ).artifactId( \"pax-swissbox-tinybundles\" ).version(asInProject())\n                        ),\n                provision(\n                        newBundle()\n                            .add( MyService.class )\n                           .set(Constants.BUNDLE_SYMBOLICNAME,\"ServiceInterface\")\n                           .set(Constants.EXPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service\")\n                            .build( withBnd() )\n                    ),\n               provision(\n                       // Component V1\n                        newBundle()\n                            .add(MyComponent.class)\n                            .set(Constants.BUNDLE_SYMBOLICNAME,\"ProviderV1\")\n                            .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service\")\n                            .build( asiPOJOBundle(new File(tmp, \"provider-v1.jar\"), new File(\"provider-v1.xml\"))),\n                     // Component V1.1 (Bundle Version)\n                        newBundle()\n                            .add(MyComponent.class)\n                            .set(Constants.BUNDLE_SYMBOLICNAME,\"ProviderV1.1\")\n                            .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service\")\n                            .set(Constants.BUNDLE_VERSION, \"1.1\")\n                            .build( asiPOJOBundle(new File(tmp, \"provider-v1.1.jar\"), new File(\"provider-v1.1.xml\"))),\n                // Instance declaration\n                newBundle()\n                    .set(Constants.BUNDLE_SYMBOLICNAME,\"Instances\")\n                    .build( asiPOJOBundle(new File(tmp, \"instances.jar\"), new File(\"instances.xml\")))\n                    )\n                );\n        return opt;\n    }","commit_id":"b8ec0448c2f38cec2f95f0433fc58b7552d6673f","url":"https://github.com/apache/felix"},{"original_method":"@Configuration\n    public static Option[] configure() throws MalformedURLException {\n\n        File tmp = new File(\"target/tmp\");\n        tmp.mkdirs();\n\n        String url1 =  // Version 1\n            newBundle()\n            .addClass( MyService.class )\n            .prepare()\n           .set(Constants.BUNDLE_SYMBOLICNAME,\"ServiceInterfaceV1\")\n           .set(Constants.BUNDLE_VERSION, \"1.0.0\")\n           .set(Constants.EXPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"1.0.0\\\"\")\n            .build( asFile(new File(tmp, \"ServiceInterfaceV1.jar\"))).toURL().toExternalForm();\n\n        String url2 = // Version 2\n                newBundle()\n                    .addClass( MyService.class )\n                    .prepare()\n                   .set(Constants.BUNDLE_SYMBOLICNAME,\"ServiceInterfaceV2\")\n                   .set(Constants.BUNDLE_VERSION, \"2.0.0\")\n                   .set(Constants.EXPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"2.0.0\\\"\")\n            .build( asFile(new File(tmp, \"ServiceInterfaceV2.jar\"))).toURL().toExternalForm();\n\n\n        String c1 = newBundle()\n            .addClass(MyComponent.class)\n            .prepare(\n              with()\n                  .set(Constants.BUNDLE_SYMBOLICNAME,\"ProviderV1\")\n                  .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"[1.0.0, 1.0.0]\\\"\")\n              )\n              .build( asiPOJOBundle(new File(tmp, \"vprovider-v1.jar\"), new File(\"vprovider-v1.xml\"))).toExternalForm();\n\n      String c2 = newBundle()\n          .addClass(MyComponent.class)\n          .prepare(\n              with()\n                  .set(Constants.BUNDLE_SYMBOLICNAME,\"ProviderV2\")\n                  .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"[2.0.0, 2.0.0]\\\"\")\n                  .set(Constants.BUNDLE_VERSION, \"2.0\")\n              )\n              .build( asiPOJOBundle(new File(tmp, \"vprovider-v2.0.jar\"), new File(\"vprovider-v2.xml\"))).toExternalForm();\n\n      String cons =   newBundle()\n        .addClass(MyCons.class)\n        .prepare(\n            with()\n                .set(Constants.BUNDLE_SYMBOLICNAME,\"MyCons\")\n                .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"[2.0.0, 2.0.0]\\\"\")\n                .set(Constants.BUNDLE_VERSION, \"2.0\")\n            )\n        .build( asiPOJOBundle(new File(tmp, \"cons.jar\"), new File(\"cons.xml\"))).toExternalForm();\n\n\n      String consV1 =   newBundle()\n      .addClass(MyCons.class)\n      .prepare(\n          with()\n              .set(Constants.BUNDLE_SYMBOLICNAME,\"MyCons\")\n              .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"[1.0.0, 1.0.0]\\\"\")\n              .set(Constants.BUNDLE_VERSION, \"1.0\")\n          )\n      .build( asiPOJOBundle(new File(tmp, \"consv1.jar\"), new File(\"cons.xml\"))).toExternalForm();\n\n        Option[] opt =  options(\n                felix(),\n                equinox(),\n                knopflerfish(),\n                provision(\n                        // Runtime.\n                        mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.ipojo\").version(asInProject()),\n                        mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.ipojo.test.helpers\").version(asInProject()),\n                        mavenBundle().groupId( \"org.ops4j.pax.swissbox\" ).artifactId( \"pax-swissbox-tinybundles\" ).version(asInProject())\n                        ),\n                        systemProperty( \"url1\" ).value( url1 ),\n                        systemProperty( \"url2\" ).value( url2 ),\n\n                        systemProperty( \"c1\" ).value( c1 ),\n                        systemProperty( \"c2\" ).value( c2 ),\n                        systemProperty( \"cons\" ).value( cons ),\n                        systemProperty( \"consV1\" ).value( consV1 )\n\n\n\n                );\n        return opt;\n    }","id":90038,"modified_method":"@Configuration\n    public static Option[] configure() throws NullArgumentException, FileNotFoundException, IOException {\n\n        File tmp = new File(\"target/tmp\");\n        tmp.mkdirs();\n\n        File f1 = new File(tmp, \"service-interface-v1.jar\");\n        StreamUtils.copyStream(\n                newBundle()\n                .add( MyService.class )\n               .set(Constants.BUNDLE_SYMBOLICNAME,\"ServiceInterfaceV1\")\n               .set(Constants.BUNDLE_VERSION, \"1.0.0\")\n               .set(Constants.EXPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"1.0.0\\\"\")\n               .build( withBnd()),\n                new FileOutputStream(f1),\n                true);\n        \n        File f2 = new File(tmp, \"service-interface-v2.jar\");\n        StreamUtils.copyStream(\n                newBundle()\n                .add( MyService.class )\n                .set(Constants.BUNDLE_SYMBOLICNAME,\"ServiceInterfaceV2\")\n                .set(Constants.BUNDLE_VERSION, \"2.0.0\")\n                .set(Constants.EXPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"2.0.0\\\"\")\n                .build( withBnd()),\n                new FileOutputStream(f2),\n                true);\n        \n        File c1 = new File(tmp, \"component-v1.jar\");\n        StreamUtils.copyStream(\n                newBundle()\n               .add(MyComponent.class)\n               .set(Constants.BUNDLE_SYMBOLICNAME,\"ProviderV1\")\n               .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"[1.0.0, 1.0.0]\\\"\")\n               .build( asiPOJOBundle(new File(\"vprovider-v1.xml\"))),\n               new FileOutputStream(c1),\n               true);\n\n        File c2 = new File(tmp, \"component-v2.jar\");\n        StreamUtils.copyStream(\n                newBundle()\n               .add(MyComponent.class)\n               .set(Constants.BUNDLE_SYMBOLICNAME,\"ProviderV2\")\n               .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"[2.0.0, 2.0.0]\\\"\")\n               .build( asiPOJOBundle(new File(\"vprovider-v2.xml\"))),\n               new FileOutputStream(c2),\n               true);\n\n        File cons = new File(tmp, \"cons.jar\");\n        StreamUtils.copyStream(\n                newBundle()\n               .add(MyCons.class)\n               .set(Constants.BUNDLE_SYMBOLICNAME,\"MyCons\")\n               .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"[2.0.0, 2.0.0]\\\"\")\n               .set(Constants.BUNDLE_VERSION, \"2.0\")\n               .build(asiPOJOBundle(new File(\"cons.xml\"))),\n               new FileOutputStream(cons),\n               true);\n        \n        File consV1 = new File(tmp, \"cons-v1.jar\");\n        StreamUtils.copyStream(\n                newBundle()\n               .add(MyCons.class)\n               .set(Constants.BUNDLE_SYMBOLICNAME,\"MyCons\")\n               .set(Constants.IMPORT_PACKAGE, \"org.apache.felix.ipojo.tests.core.service; version=\\\"[1.0.0, 1.0.0]\\\"\")\n               .set(Constants.BUNDLE_VERSION, \"1.0\")\n               .build(asiPOJOBundle(new File(\"cons.xml\"))),\n               new FileOutputStream(consV1),\n               true);\n        \n        Option[] opt =  options(\n                felix(),\n                equinox(),\n                knopflerfish(),\n                provision(\n                        // Runtime.\n                        mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.ipojo\").version(asInProject()),\n                        mavenBundle().groupId(\"org.apache.felix\").artifactId(\"org.apache.felix.ipojo.test.helpers\").version(asInProject()),\n                        mavenBundle().groupId(\"org.ops4j.base\").artifactId(\"ops4j-base-lang\").versionAsInProject()\n//                        mavenBundle().groupId( \"org.ops4j.pax.swissbox\" ).artifactId( \"pax-swissbox-tinybundles\" ).version(asInProject())\n                        ),\n                        systemProperty( \"url1\" ).value( f1.toURI().toURL().toExternalForm() ),\n                        systemProperty( \"url2\" ).value( f2.toURI().toURL().toExternalForm() ),\n\n                        systemProperty( \"c1\" ).value( c1.toURI().toURL().toExternalForm() ),\n                        systemProperty( \"c2\" ).value( c2.toURI().toURL().toExternalForm() ),\n                        systemProperty( \"cons\" ).value( cons.toURI().toURL().toExternalForm() ),\n                        systemProperty( \"consV1\" ).value( consV1.toURI().toURL().toExternalForm() )\n                );\n        return opt;\n    }","commit_id":"b8ec0448c2f38cec2f95f0433fc58b7552d6673f","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * This method supports two modes to set a property:\n     *\n     * 1. Setting a property that has already been resolved, this is the case when {@code context} and {@code refName} are\n     * NULL and {@code value} is non-NULL.\n     *\n     * 2. Setting a property that has not yet been resolved, the property will be resolved based on the suitable methods\n     * found matching the property name on the {@code target} bean. For this mode to be triggered the parameters\n     * {@code context} and {@code refName} must NOT be NULL, and {@code value} MUST be NULL.\n     *\n     */\n    public static boolean setProperty(CamelContext context, TypeConverter typeConverter, Object target, String name, Object value, String refName, boolean allowBuilderPattern) throws Exception {\n        Class<?> clazz = target.getClass();\n        Collection<Method> setters;\n\n        // we need to lookup the value from the registry\n        if (context != null && refName != null && value == null) {\n            setters = findSetterMethodsOrderedByParameterType(clazz, name, allowBuilderPattern);\n        } else {\n            // find candidates of setter methods as there can be overloaded setters\n            setters = findSetterMethods(clazz, name, value, allowBuilderPattern);\n        }\n        if (setters.isEmpty()) {\n            return false;\n        }\n\n        // loop and execute the best setter method\n        Exception typeConversionFailed = null;\n        for (Method setter : setters) {\n            Class<?> parameterType = setter.getParameterTypes()[0];\n            Object ref = value;\n            // try and lookup the reference based on the method\n            if (context != null && refName != null && ref == null) {\n                ref = CamelContextHelper.lookup(context, refName.replaceAll(\"#\", \"\"), parameterType);\n                if (ref == null) {\n                    continue; // try the next method if nothing was found\n                }\n            }\n\n            try {\n                try {\n                    // If the type is null or it matches the needed type, just use the value directly\n                    if (value == null || parameterType.isAssignableFrom(ref.getClass())) {\n                        // we may want to set options on classes that has package view visibility, so override the accessible\n                        setter.setAccessible(true);\n                        setter.invoke(target, ref);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Configured property: {} on bean: {} with value: {}\", new Object[]{name, target, ref});\n                        }\n                        return true;\n                    } else {\n                        // We need to convert it\n                        Object convertedValue = convert(typeConverter, parameterType, ref);\n                        // we may want to set options on classes that has package view visibility, so override the accessible\n                        setter.setAccessible(true);\n                        setter.invoke(target, convertedValue);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Configured property: {} on bean: {} with value: {}\", new Object[]{name, target, ref});\n                        }\n                        return true;\n                    }\n                } catch (InvocationTargetException e) {\n                    // lets unwrap the exception\n                    Throwable throwable = e.getCause();\n                    if (throwable instanceof Exception) {\n                        Exception exception = (Exception)throwable;\n                        throw exception;\n                    } else {\n                        Error error = (Error)throwable;\n                        throw error;\n                    }\n                }\n            // ignore exceptions as there could be another setter method where we could type convert successfully\n            } catch (SecurityException e) {\n                typeConversionFailed = e;\n            } catch (NoTypeConversionAvailableException e) {\n                typeConversionFailed = e;\n            } catch (IllegalArgumentException e) {\n                typeConversionFailed = e;\n            }\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Setter \\\"{}\\\" with parameter type \\\"{}\\\" could not be used for type conversions of {}\",\n                        new Object[]{setter, parameterType, ref});\n            }\n        }\n\n        if (typeConversionFailed != null) {\n            // we did not find a setter method to use, and if we did try to use a type converter then throw\n            // this kind of exception as the caused by will hint this error\n            throw new IllegalArgumentException(\"Could not find a suitable setter for property: \" + name\n                    + \" as there isn't a setter method with same type: \" + value.getClass().getCanonicalName()\n                    + \" nor type conversion possible: \" + typeConversionFailed.getMessage());\n        } else {\n            return false;\n        }\n    }","id":90039,"modified_method":"/**\n     * This method supports two modes to set a property:\n     *\n     * 1. Setting a property that has already been resolved, this is the case when {@code context} and {@code refName} are\n     * NULL and {@code value} is non-NULL.\n     *\n     * 2. Setting a property that has not yet been resolved, the property will be resolved based on the suitable methods\n     * found matching the property name on the {@code target} bean. For this mode to be triggered the parameters\n     * {@code context} and {@code refName} must NOT be NULL, and {@code value} MUST be NULL.\n     *\n     */\n    public static boolean setProperty(CamelContext context, TypeConverter typeConverter, Object target, String name, Object value, String refName, boolean allowBuilderPattern) throws Exception {\n        Class<?> clazz = target.getClass();\n        Collection<Method> setters;\n\n        // we need to lookup the value from the registry\n        if (context != null && refName != null && value == null) {\n            setters = findSetterMethodsOrderedByParameterType(clazz, name, allowBuilderPattern);\n        } else {\n            // find candidates of setter methods as there can be overloaded setters\n            setters = findSetterMethods(clazz, name, value, allowBuilderPattern);\n        }\n        if (setters.isEmpty()) {\n            return false;\n        }\n\n        // loop and execute the best setter method\n        Exception typeConversionFailed = null;\n        for (Method setter : setters) {\n            Class<?> parameterType = setter.getParameterTypes()[0];\n            Object ref = value;\n            // try and lookup the reference based on the method\n            if (context != null && refName != null && ref == null) {\n                ref = CamelContextHelper.lookup(context, refName.replaceAll(\"#\", \"\"), parameterType);\n                if (ref == null) {\n                    continue; // try the next method if nothing was found\n                }\n            }\n\n            try {\n                try {\n                    // If the type is null or it matches the needed type, just use the value directly\n                    if (value == null || parameterType.isAssignableFrom(ref.getClass())) {\n                        // we may want to set options on classes that has package view visibility, so override the accessible\n                        setter.setAccessible(true);\n                        setter.invoke(target, ref);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Configured property: {} on bean: {} with value: {}\", new Object[]{name, target, ref});\n                        }\n                        return true;\n                    } else {\n                        // We need to convert it\n                        Object convertedValue = convert(typeConverter, parameterType, ref);\n                        // we may want to set options on classes that has package view visibility, so override the accessible\n                        setter.setAccessible(true);\n                        setter.invoke(target, convertedValue);\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Configured property: {} on bean: {} with value: {}\", new Object[]{name, target, ref});\n                        }\n                        return true;\n                    }\n                } catch (InvocationTargetException e) {\n                    // lets unwrap the exception\n                    Throwable throwable = e.getCause();\n                    if (throwable instanceof Exception) {\n                        Exception exception = (Exception)throwable;\n                        throw exception;\n                    } else {\n                        Error error = (Error)throwable;\n                        throw error;\n                    }\n                }\n            // ignore exceptions as there could be another setter method where we could type convert successfully\n            } catch (SecurityException e) {\n                typeConversionFailed = e;\n            } catch (NoTypeConversionAvailableException e) {\n                typeConversionFailed = e;\n            } catch (IllegalArgumentException e) {\n                typeConversionFailed = e;\n            }\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Setter \\\"{}\\\" with parameter type \\\"{}\\\" could not be used for type conversions of {}\",\n                        new Object[]{setter, parameterType, ref});\n            }\n        }\n\n        if (typeConversionFailed != null) {\n            // we did not find a setter method to use, and if we did try to use a type converter then throw\n            // this kind of exception as the caused by will hint this error\n            throw new IllegalArgumentException(\"Could not find a suitable setter for property: \" + name\n                    + \" as there isn't a setter method with same type: \" + (value != null ? value.getClass().getCanonicalName() : \"[null]\")\n                    + \" nor type conversion possible: \" + typeConversionFailed.getMessage());\n        } else {\n            return false;\n        }\n    }","commit_id":"978b102866d37fa4eb33b4ecec3cc83584905ae3","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {\n        // same instance type\n        if (type.isInstance(value)) {\n            return type.cast(value);\n        }\n\n        // make sure we have loaded the converters\n        checkLoaded();\n\n        // try to find a suitable type converter\n        TypeConverter converter = getOrFindTypeConverter(type, value);\n        if (converter != null) {\n            return converter.convertTo(type, exchange, value);\n        }\n\n        // fallback converters\n        for (TypeConverter fallback : fallbackConverters) {\n            T rc = fallback.convertTo(type, exchange, value);\n            if (rc != null) {\n                return rc;\n            }\n        }\n\n        // lets avoid NullPointerException when converting to boolean for null values\n        if (boolean.class.isAssignableFrom(type)) {\n            return (T) Boolean.FALSE;\n        }\n\n        // primitives\n        if (type.isPrimitive()) {\n            Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(type);\n            if (primitiveType != type) {\n                return (T) convertTo(primitiveType, exchange, value);\n            }\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Could not find a type converter for converting \"\n                + value.getClass().getCanonicalName() + \" -> \" + type.getCanonicalName()\n                + \" with value: \" + value);\n        }\n        return null;\n    }","id":90040,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public <T> T convertTo(Class<T> type, Exchange exchange, Object value) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Converting \" + (value == null ? \"null\" : value.getClass().getCanonicalName())\n                + \" -> \" + type.getCanonicalName() + \" with value: \" + value);\n        }\n\n        // same instance type\n        if (type.isInstance(value)) {\n            return type.cast(value);\n        }\n\n        // make sure we have loaded the converters\n        checkLoaded();\n\n        // try to find a suitable type converter\n        TypeConverter converter = getOrFindTypeConverter(type, value);\n        if (converter != null) {\n            return converter.convertTo(type, exchange, value);\n        }\n\n        // fallback converters\n        for (TypeConverter fallback : fallbackConverters) {\n            T rc = fallback.convertTo(type, exchange, value);\n            if (rc != null) {\n                return rc;\n            }\n        }\n\n        // lets avoid NullPointerException when converting to boolean for null values\n        if (boolean.class.isAssignableFrom(type)) {\n            return (T) Boolean.FALSE;\n        }\n\n        // primitives\n        if (type.isPrimitive()) {\n            Class primitiveType = ObjectHelper.convertPrimitiveTypeToWrapperType(type);\n            if (primitiveType != type) {\n                return (T) convertTo(primitiveType, exchange, value);\n            }\n        }\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Could not find a type converter for converting \"\n                + (value == null ? \"null\" : value.getClass().getCanonicalName())\n                + \" -> \" + type.getCanonicalName() + \" with value: \" + value);\n        }\n        return null;\n    }","commit_id":"97798653f79abec1d50d935644d9ccb210b4ffc6","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public T read(ConfigurationResource cr) {\n        Object rtn = null;\n        UnmarshallerValidator pooledObject = null;\n        try {\n            pooledObject = objectPool.borrowObject();\n            try {\n                final Object unmarshalledObject = pooledObject.validateUnmarshal(cr.newInputStream());\n                if (unmarshalledObject instanceof JAXBElement) {\n                    rtn = ((JAXBElement) unmarshalledObject).getValue();\n                } else {\n                    rtn = unmarshalledObject;\n                }\n            } catch (Exception e) {\n                objectPool.invalidateObject(pooledObject);\n                pooledObject = null;\n                LOG.error(\"Failed to utilize the UnmarshallerValidator.\", e);\n            } finally {\n                if (null != pooledObject) {\n                    objectPool.returnObject(pooledObject);\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"Failed to obtain an UnmarshallerValidator.\", e);\n        }\n        if (!configurationClass().isInstance(rtn)) {\n            throw new ClassCastException(\"Parsed object from XML does not match the expected configuration class. \"\n                    + \"Expected: \" + configurationClass().getCanonicalName() + \"  -  \"\n                    + \"Actual: \" + rtn.getClass().getCanonicalName());\n        }\n        return configurationClass().cast(rtn);\n    }","id":90041,"modified_method":"@Override\n    public T read(ConfigurationResource cr) {\n        Object rtn = null;\n        UnmarshallerValidator pooledObject = null;\n        try {\n            pooledObject = objectPool.borrowObject();\n            try {\n                final Object unmarshalledObject = pooledObject.validateUnmarshal(cr.newInputStream());\n                if (unmarshalledObject instanceof JAXBElement) {\n                    rtn = ((JAXBElement) unmarshalledObject).getValue();\n                } else {\n                    rtn = unmarshalledObject;\n                }\n            } catch (Exception e) {\n                objectPool.invalidateObject(pooledObject);\n                pooledObject = null;\n                LOG.error(\"Failed to utilize the UnmarshallerValidator.\", e);\n            } finally {\n                if (null != pooledObject) {\n                    objectPool.returnObject(pooledObject);\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"Failed to obtain an UnmarshallerValidator.\", e);\n        }\n        if (!configurationClass().isInstance(rtn)) {\n            throw new ClassCastException(\"Parsed object from XML does not match the expected configuration class. \"\n                    + \"Expected: \" + configurationClass().getCanonicalName() + \"  -  \"\n                    + \"Actual: \" + (rtn==null?null:rtn.getClass().getCanonicalName()));\n        }\n        return configurationClass().cast(rtn);\n    }","commit_id":"6fc1b7cf633b7ad39ff2b47b38d851fdc4865504","url":"https://github.com/rackerlabs/repose"},{"original_method":"/**\n\t * This should be called by the plugin to store its PluginStore in the node's\n\t * database.\n\t * @param store Store to put.\n\t * @param storeIdentifier Some string to identify the store, basically the plugin's name.\n\t * @throws DatabaseDisabledException\n\t */\n\tpublic void putStore(final PluginStore store) throws DatabaseDisabledException {\n\t\tfinal PluginStoreContainer storeC = new PluginStoreContainer();\n\t\tstoreC.nodeDBHandle = this.node.nodeDBHandle;\n\t\tstoreC.pluginStore = null;\n\t\tstoreC.storeIdentifier = this.plugin.getClass().getCanonicalName();\n\n\t\tthis.node.clientCore.queue(new DBJob() {\n\n\t\t\t@Override\n\t\t\tpublic boolean run(ObjectContainer container, ClientContext context) {\n\t\t\t\t// cascadeOnDelete(true) will make the calls to store() delete\n\t\t\t\t// any precedent stored instance of PluginStore.\n\n\t\t\t\tif(container.queryByExample(storeC).size() == 0) {\n\t\t\t\t\t// Let's store the whole container.\n\t\t\t\t\tstoreC.pluginStore = store;\n\t\t\t\t\tcontainer.ext().store(storeC, Integer.MAX_VALUE);\n\t\t\t\t} else {\n\t\t\t\t\t// Only update the PluginStore.\n\t\t\t\t\t// Check all subStores for changes, not only the top-level store.\n\t\t\t\t\tstoreC.pluginStore = store;\n\t\t\t\t\tcontainer.ext().store(storeC.pluginStore, Integer.MAX_VALUE);\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}, NativeThread.NORM_PRIORITY, false);\n\t}","id":90042,"modified_method":"/**\n\t * This should be called by the plugin to store its PluginStore in the node's\n\t * database.\n\t * @param store Store to put.\n\t * @param storeIdentifier Some string to identify the store, basically the plugin's name.\n\t * @throws DatabaseDisabledException\n\t */\n\tpublic void putStore(final PluginStore store) throws DatabaseDisabledException {\n\t    stores.writePluginStore(this.plugin.getClass().getCanonicalName(), store);\n\t}","commit_id":"f1b58273464e0f91b63df7f761809bdbfb8332ca","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Get a PluginStore that can be used by the plugin to put data in a database.\n\t * The database used is the node's database, so all the encrypt/decrypt part\n\t * is already automatically handled according to the physical security level.\n\t * @param storeIdentifier PluginStore identifier, Plugin's name or some other identifier.\n\t * @return PluginStore\n\t * @throws DatabaseDisabledException\n\t */\n\tpublic PluginStore getStore() throws DatabaseDisabledException {\n\t\tfinal PluginStoreContainer example = new PluginStoreContainer();\n\t\texample.nodeDBHandle = this.node.nodeDBHandle;\n\t\texample.storeIdentifier = this.plugin.getClass().getCanonicalName();\n\t\texample.pluginStore = null;\n\n\t\t// This runs off-thread, so we need to synchronize, even though we wait for it to complete.\n\t\tthis.node.clientCore.runBlocking(new DBJob() {\n\n\t\t\t@Override\n\t\t\tpublic boolean run(ObjectContainer container, ClientContext context) {\n\t\t\t\tObjectSet<PluginStoreContainer> stores = container.queryByExample(example);\n\t\t\t\tsynchronized(PluginRespirator.this) {\n\t\t\t\t\tif(stores.size() == 0) store = new PluginStore();\n\t\t\t\t\telse {\n\t\t\t\t\t\tstore = stores.get(0).pluginStore;\n\t\t\t\t\t\tcontainer.activate(store, Integer.MAX_VALUE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}, NativeThread.HIGH_PRIORITY);\n\t\tsynchronized(this) {\n\t\t\tif(store == null) throw new NullPointerException();\n\t\t\treturn store;\n\t\t}\n\t}","id":90043,"modified_method":"/**\n\t * Get a PluginStore that can be used by the plugin to put data in a database.\n\t * The database used is the node's database, so all the encrypt/decrypt part\n\t * is already automatically handled according to the physical security level.\n\t * @param storeIdentifier PluginStore identifier, Plugin's name or some other identifier.\n\t * @return PluginStore\n\t * @throws DatabaseDisabledException\n\t */\n\tpublic PluginStore getStore() throws DatabaseDisabledException {\n\t    synchronized(this) {\n\t        if(store != null) return store;\n\t        store = stores.loadPluginStore(this.plugin.getClass().getCanonicalName());\n\t        if(store == null)\n\t            store = new PluginStore();\n\t        return store;\n\t    }\n\t}","commit_id":"f1b58273464e0f91b63df7f761809bdbfb8332ca","url":"https://github.com/freenet/fred"},{"original_method":"private Bucket writePluginStoreFile(String storeIdentifier) throws FileNotFoundException {\n        String filename = storeIdentifier;\n        filename += \".data\";\n//      boolean isEncrypted = node.isDatabaseEncrypted();\n//      if(isEncrypted)\n//          filename += \".crypt\";\n        File f = pluginStoresDir.file(filename);\n        Bucket bucket = new FileBucket(f, false, true, false, false, false);\n        // FIXME REINSTATE\n//      if(isEncrypted)\n//          bucket = new CipherBucket(bucket, node.getPluginStoreKey(storeIdentifier));\n        return bucket;\n    }","id":90044,"modified_method":"private Bucket getPluginStoreFile(String storeIdentifier) throws FileNotFoundException {\n        String filename = storeIdentifier;\n        filename += \".data\";\n//      boolean isEncrypted = node.isDatabaseEncrypted();\n//      if(isEncrypted)\n//          filename += \".crypt\";\n        File f = pluginStoresDir.file(filename);\n        Bucket bucket = new FileBucket(f, false, false, false, false, false);\n        // FIXME REINSTATE\n//      if(isEncrypted)\n//          bucket = new CipherBucket(bucket, node.getPluginStoreKey(storeIdentifier));\n        return bucket;\n    }","commit_id":"f1b58273464e0f91b63df7f761809bdbfb8332ca","url":"https://github.com/freenet/fred"},{"original_method":"/** Migrate a single PluginStore from the database to on disk \n     * @throws IOException */\n    public void migratePluginStores(ObjectContainer container, PluginStoreContainer psc) {\n        try {\n            Bucket bucket = writePluginStoreFile(psc.storeIdentifier);\n            OutputStream os = bucket.getOutputStream();\n            try {\n                if(psc.pluginStore != null) {\n                    psc.pluginStore.exportStoreAsSFS().writeTo(os);\n                }\n            } finally {\n                os.close();\n            }\n            // FIXME implement removal when sure it works.\n            //psc.pluginStore.removeFrom(container);\n            container.commit();\n            System.out.println(\"Migrated plugin store for \"+psc.storeIdentifier+\" from database to disk\");\n        } catch (IOException e) {\n            System.err.println(\"Unable to migrate plugin store for \"+psc.storeIdentifier+\" from database to disk : \"+e);\n        }\n    }","id":90045,"modified_method":"/** Migrate a single PluginStore from the database to on disk \n     * @throws IOException */\n    public void migratePluginStores(ObjectContainer container, PluginStoreContainer psc) {\n        try {\n            if(psc.pluginStore == null) return;\n            writePluginStoreInner(psc.storeIdentifier, psc.pluginStore);\n            // FIXME implement removal when sure it works.\n            //psc.pluginStore.removeFrom(container);\n            container.commit();\n            System.out.println(\"Migrated plugin store for \"+psc.storeIdentifier+\" from database to disk\");\n        } catch (IOException e) {\n            System.err.println(\"Unable to migrate plugin store for \"+psc.storeIdentifier+\" from database to disk : \"+e);\n        }\n    }","commit_id":"f1b58273464e0f91b63df7f761809bdbfb8332ca","url":"https://github.com/freenet/fred"},{"original_method":"protected Message createJmsMessage(Exchange exchange, Object body, Map<String, Object> headers, Session session, CamelContext context) throws JMSException {\n        JmsMessageType type = null;\n\n        // special for transferExchange\n        if (endpoint != null && endpoint.isTransferExchange()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Option transferExchange=true so we use JmsMessageType: Object\");\n            }\n            Serializable holder = DefaultExchangeHolder.marshal(exchange);\n            return session.createObjectMessage(holder);\n        }\n\n        // check if header have a type set, if so we force to use it\n        if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) {\n            type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE));\n        } else if (endpoint != null && endpoint.getConfiguration().getJmsMessageType() != null) {\n            // force a specific type from the endpoint configuration\n            type = endpoint.getConfiguration().getJmsMessageType();\n        } else {\n            // let body deterime the type\n            if (body instanceof Node || body instanceof String) {\n                type = Text;\n            } else if (body instanceof byte[] || body instanceof GenericFile || body instanceof File || body instanceof Reader\n                    || body instanceof InputStream || body instanceof ByteBuffer) {\n                type = Bytes;\n            } else if (body instanceof Map) {\n                type = Map;\n            } else if (body instanceof Serializable) {\n                type = Object;\n            }\n        }\n\n        // create the JmsMessage based on the type\n        if (type != null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Using JmsMessageType: \" + type);\n            }\n\n            switch (type) {\n            case Text: {\n                TextMessage message = session.createTextMessage();\n                String payload = context.getTypeConverter().convertTo(String.class, body);\n                message.setText(payload);\n                return message;\n            }\n            case Bytes: {\n                BytesMessage message = session.createBytesMessage();\n                byte[] payload = context.getTypeConverter().convertTo(byte[].class, body);\n                message.writeBytes(payload);\n                return message;\n            }\n            case Map: {\n                MapMessage message = session.createMapMessage();\n                Map payload = context.getTypeConverter().convertTo(Map.class, body);\n                populateMapMessage(message, payload, context);\n                return message;\n            }\n            case Object:\n                return session.createObjectMessage((Serializable)body);\n            case Strem:\n                // TODO: Stream is not supported\n                break;\n            default:\n                break;\n            }\n        }\n\n        // TODO: should we throw an exception instead?\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Could not determine specific JmsMessage type to use from body.\"\n                    + \" Will use generic JmsMessage. Body class: \" + body.getClass().getCanonicalName());\n        }\n\n        // return a default message\n        return session.createMessage();\n    }","id":90046,"modified_method":"protected Message createJmsMessage(Exchange exchange, Object body, Map<String, Object> headers, Session session, CamelContext context) throws JMSException {\n        JmsMessageType type = null;\n\n        // special for transferExchange\n        if (endpoint != null && endpoint.isTransferExchange()) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Option transferExchange=true so we use JmsMessageType: Object\");\n            }\n            Serializable holder = DefaultExchangeHolder.marshal(exchange);\n            return session.createObjectMessage(holder);\n        }\n\n        // check if header have a type set, if so we force to use it\n        if (headers.containsKey(JmsConstants.JMS_MESSAGE_TYPE)) {\n            type = context.getTypeConverter().convertTo(JmsMessageType.class, headers.get(JmsConstants.JMS_MESSAGE_TYPE));\n        } else if (endpoint != null && endpoint.getConfiguration().getJmsMessageType() != null) {\n            // force a specific type from the endpoint configuration\n            type = endpoint.getConfiguration().getJmsMessageType();\n        } else {\n            // let body deterime the type\n            if (body instanceof Node || body instanceof String) {\n                type = Text;\n            } else if (body instanceof byte[] || body instanceof GenericFile || body instanceof File || body instanceof Reader\n                    || body instanceof InputStream || body instanceof ByteBuffer) {\n                type = Bytes;\n            } else if (body instanceof Map) {\n                type = Map;\n            } else if (body instanceof Serializable) {\n                type = Object;\n            }\n        }\n\n        // create the JmsMessage based on the type\n        if (type != null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Using JmsMessageType: \" + type);\n            }\n\n            switch (type) {\n            case Text: {\n                TextMessage message = session.createTextMessage();\n                String payload = context.getTypeConverter().convertTo(String.class, body);\n                message.setText(payload);\n                return message;\n            }\n            case Bytes: {\n                BytesMessage message = session.createBytesMessage();\n                byte[] payload = context.getTypeConverter().convertTo(byte[].class, body);\n                message.writeBytes(payload);\n                return message;\n            }\n            case Map: {\n                MapMessage message = session.createMapMessage();\n                Map payload = context.getTypeConverter().convertTo(Map.class, body);\n                populateMapMessage(message, payload, context);\n                return message;\n            }\n            case Object:\n                return session.createObjectMessage((Serializable)body);\n            case Strem:\n                // TODO: Stream is not supported\n                break;\n            default:\n                break;\n            }\n        }\n\n        // TODO: should we throw an exception instead?\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Could not determine specific JmsMessage type to use from body.\"\n                    + \" Will use generic JmsMessage.\"\n                    + (body != null ? (\" Body class: \" + body.getClass().getCanonicalName()) : \"\") );\n        }\n\n        // return a default message\n        return session.createMessage();\n    }","commit_id":"5a1ecffd0f115b0265fcf49e81f05049037c683b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Creates a JMS message from the Camel exchange and message\n     *\n     * @param exchange the current exchange\n     * @param camelMessage the body to make a javax.jms.Message as\n     * @param session the JMS session used to create the message\n     * @param cause optional exception occured that should be sent as reply instead of a regular body\n     * @return a newly created JMS Message instance containing the\n     * @throws JMSException if the message could not be created\n     */\n    public Message makeJmsMessage(Exchange exchange, org.apache.camel.Message camelMessage, Session session, Exception cause) throws JMSException {\n        Message answer = null;\n\n        boolean alwaysCopy = endpoint != null && endpoint.getConfiguration().isAlwaysCopyMessage();\n        if (!alwaysCopy && camelMessage instanceof JmsMessage) {\n            JmsMessage jmsMessage = (JmsMessage)camelMessage;\n            if (!jmsMessage.shouldCreateNewMessage()) {\n                answer = jmsMessage.getJmsMessage();\n            }\n        }\n\n        if (answer == null) {\n            if (cause != null) {\n                // an exception occured so send it as response\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Will create JmsMessage with caused exception: \" + cause);\n                }\n                // create jms message containg the caused exception\n                answer = createJmsMessage(cause, session);\n            } else {\n                ObjectHelper.notNull(camelMessage, \"message body\");\n                // create regular jms message using the camel message body\n                answer = createJmsMessage(exchange, camelMessage.getBody(), camelMessage.getHeaders(), session, exchange.getContext());\n                appendJmsProperties(answer, exchange, camelMessage);\n            }\n        }\n\n        return answer;\n    }","id":90047,"modified_method":"/**\n     * Creates a JMS message from the Camel exchange and message\n     *\n     * @param exchange the current exchange\n     * @param camelMessage the body to make a javax.jms.Message as\n     * @param session the JMS session used to create the message\n     * @param cause optional exception occured that should be sent as reply instead of a regular body\n     * @return a newly created JMS Message instance containing the\n     * @throws JMSException if the message could not be created\n     */\n    public Message makeJmsMessage(Exchange exchange, org.apache.camel.Message camelMessage, Session session, Exception cause) throws JMSException {\n        Message answer = null;\n\n        boolean alwaysCopy = endpoint != null && endpoint.getConfiguration().isAlwaysCopyMessage();\n        if (!alwaysCopy && camelMessage instanceof JmsMessage) {\n            JmsMessage jmsMessage = (JmsMessage)camelMessage;\n            if (!jmsMessage.shouldCreateNewMessage()) {\n                answer = jmsMessage.getJmsMessage();\n            }\n        }\n\n        if (answer == null) {\n            if (cause != null) {\n                // an exception occured so send it as response\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Will create JmsMessage with caused exception: \" + cause);\n                }\n                // create jms message containg the caused exception\n                answer = createJmsMessage(cause, session);\n            } else {\n                ObjectHelper.notNull(camelMessage, \"message\");\n                // create regular jms message using the camel message body\n                answer = createJmsMessage(exchange, camelMessage.getBody(), camelMessage.getHeaders(), session, exchange.getContext());\n                appendJmsProperties(answer, exchange, camelMessage);\n            }\n        }\n\n        return answer;\n    }","commit_id":"5a1ecffd0f115b0265fcf49e81f05049037c683b","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Execute a map/reduce job with this nanoScheduler\n     *\n     * Data comes from inputReader.  Will be read until hasNext() == false.\n     * map is called on each element provided by inputReader.  No order of operations is guarenteed\n     * reduce is called in order of the input data provided by inputReader on the result of map() applied\n     * to each element.\n     *\n     * Note that the caller thread is put to work with this function call.  The call doesn't return\n     * until all elements have been processes.\n     *\n     * It is safe to call this function repeatedly on a single nanoScheduler, at least until the\n     * shutdown method is called.\n     *\n     * Note that this function goes through a single threaded fast path if the number of threads\n     * is 1.\n     *\n     * @param inputReader an iterator providing us with the input data to nanoSchedule map/reduce over\n     * @param map the map function from input type -> map type, will be applied in parallel to each input\n     * @param reduce the reduce function from map type + reduce type -> reduce type to be applied in order to map results\n     * @return the last reduce value\n     */\n    public ReduceType execute(final Iterator<InputType> inputReader,\n                              final NanoSchedulerMapFunction<InputType, MapType> map,\n                              final ReduceType initialValue,\n                              final NanoSchedulerReduceFunction<MapType, ReduceType> reduce) {\n        if ( isShutdown() ) throw new IllegalStateException(\"execute called on already shutdown NanoScheduler\");\n        if ( inputReader == null ) throw new IllegalArgumentException(\"inputReader cannot be null\");\n        if ( map == null ) throw new IllegalArgumentException(\"map function cannot be null\");\n        if ( reduce == null ) throw new IllegalArgumentException(\"reduce function cannot be null\");\n\n        outsideSchedulerTimer.stop();\n\n        ReduceType result;\n        if ( ALLOW_SINGLE_THREAD_FASTPATH && getnThreads() == 1 ) {\n            result = executeSingleThreaded(inputReader, map, initialValue, reduce);\n        } else {\n            result = executeMultiThreaded(inputReader, map, initialValue, reduce);\n        }\n\n        outsideSchedulerTimer.restart();\n        return result;\n    }","id":90048,"modified_method":"/**\n     * Execute a map/reduce job with this nanoScheduler\n     *\n     * Data comes from inputReader.  Will be read until hasNext() == false.\n     * map is called on each element provided by inputReader.  No order of operations is guarenteed\n     * reduce is called in order of the input data provided by inputReader on the result of map() applied\n     * to each element.\n     *\n     * Note that the caller thread is put to work with this function call.  The call doesn't return\n     * until all elements have been processes.\n     *\n     * It is safe to call this function repeatedly on a single nanoScheduler, at least until the\n     * shutdown method is called.\n     *\n     * Note that this function goes through a single threaded fast path if the number of threads\n     * is 1.\n     *\n     * @param inputReader an iterator providing us with the input data to nanoSchedule map/reduce over\n     * @param map the map function from input type -> map type, will be applied in parallel to each input\n     * @param reduce the reduce function from map type + reduce type -> reduce type to be applied in order to map results\n     * @return the last reduce value\n     */\n    public ReduceType execute(final Iterator<InputType> inputReader,\n                              final NSMapFunction<InputType, MapType> map,\n                              final ReduceType initialValue,\n                              final NSReduceFunction<MapType, ReduceType> reduce) {\n        if ( isShutdown() ) throw new IllegalStateException(\"execute called on already shutdown NanoScheduler\");\n        if ( inputReader == null ) throw new IllegalArgumentException(\"inputReader cannot be null\");\n        if ( map == null ) throw new IllegalArgumentException(\"map function cannot be null\");\n        if ( reduce == null ) throw new IllegalArgumentException(\"reduce function cannot be null\");\n\n        outsideSchedulerTimer.stop();\n\n        ReduceType result;\n        if ( ALLOW_SINGLE_THREAD_FASTPATH && getnThreads() == 1 ) {\n            result = executeSingleThreaded(inputReader, map, initialValue, reduce);\n        } else {\n            result = executeMultiThreaded(inputReader, map, initialValue, reduce);\n        }\n\n        outsideSchedulerTimer.restart();\n        return result;\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Simple efficient reference implementation for single threaded execution.\n     *\n     * @return the reduce result of this map/reduce job\n     */\n    @Requires({\"inputReader != null\", \"map != null\", \"reduce != null\"})\n    private ReduceType executeSingleThreaded(final Iterator<InputType> inputReader,\n                                             final NanoSchedulerMapFunction<InputType, MapType> map,\n                                             final ReduceType initialValue,\n                                             final NanoSchedulerReduceFunction<MapType, ReduceType> reduce) {\n        ReduceType sum = initialValue;\n        int i = 0;\n\n        // start timer to ensure that both hasNext and next are caught by the timer\n        if ( TIME_CALLS ) inputTimer.restart();\n        while ( inputReader.hasNext() ) {\n            final InputType input = inputReader.next();\n            if ( TIME_CALLS ) inputTimer.stop();\n\n            // map\n            if ( TIME_CALLS ) mapTimer.restart();\n            final long preMapTime = LOG_MAP_TIMES ? 0 : mapTimer.currentTimeNano();\n            final MapType mapValue = map.apply(input);\n            if ( LOG_MAP_TIMES ) logger.info(\"MAP TIME \" + (mapTimer.currentTimeNano() - preMapTime));\n            if ( TIME_CALLS ) mapTimer.stop();\n\n            if ( i++ % bufferSize == 0 && progressFunction != null )\n                progressFunction.progress(input);\n\n            // reduce\n            if ( TIME_CALLS ) reduceTimer.restart();\n            sum = reduce.apply(mapValue, sum);\n            if ( TIME_CALLS ) reduceTimer.stop();\n\n            if ( TIME_CALLS ) inputTimer.restart();\n        }\n\n        return sum;\n    }","id":90049,"modified_method":"/**\n     * Simple efficient reference implementation for single threaded execution.\n     *\n     * @return the reduce result of this map/reduce job\n     */\n    @Requires({\"inputReader != null\", \"map != null\", \"reduce != null\"})\n    private ReduceType executeSingleThreaded(final Iterator<InputType> inputReader,\n                                             final NSMapFunction<InputType, MapType> map,\n                                             final ReduceType initialValue,\n                                             final NSReduceFunction<MapType, ReduceType> reduce) {\n        ReduceType sum = initialValue;\n        int i = 0;\n\n        // start timer to ensure that both hasNext and next are caught by the timer\n        if ( TIME_CALLS ) inputTimer.restart();\n        while ( inputReader.hasNext() ) {\n            final InputType input = inputReader.next();\n            if ( TIME_CALLS ) inputTimer.stop();\n\n            // map\n            if ( TIME_CALLS ) mapTimer.restart();\n            final long preMapTime = LOG_MAP_TIMES ? 0 : mapTimer.currentTimeNano();\n            final MapType mapValue = map.apply(input);\n            if ( LOG_MAP_TIMES ) logger.info(\"MAP TIME \" + (mapTimer.currentTimeNano() - preMapTime));\n            if ( TIME_CALLS ) mapTimer.stop();\n\n            if ( i++ % inputBufferSize == 0 && progressFunction != null )\n                progressFunction.progress(input);\n\n            // reduce\n            if ( TIME_CALLS ) reduceTimer.restart();\n            sum = reduce.apply(mapValue, sum);\n            if ( TIME_CALLS ) reduceTimer.stop();\n\n            if ( TIME_CALLS ) inputTimer.restart();\n        }\n\n        return sum;\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Efficient parallel version of Map/Reduce\n     *\n     * @return the reduce result of this map/reduce job\n     */\n    @Requires({\"inputReader != null\", \"map != null\", \"reduce != null\"})\n    private ReduceType executeMultiThreaded(final Iterator<InputType> inputReader,\n                                            final NanoSchedulerMapFunction<InputType, MapType> map,\n                                            final ReduceType initialValue,\n                                            final NanoSchedulerReduceFunction<MapType, ReduceType> reduce) {\n        debugPrint(\"Executing nanoScheduler\");\n\n        // a completion service that tracks when jobs complete, so we can wait in this thread\n        // until all of the map jobs are completed, without having to shut down the executor itself\n        final ExecutorCompletionService<Integer> mapJobCompletionService =\n                new ExecutorCompletionService<Integer>(mapExecutor);\n\n        // a blocking queue that limits the number of input datum to the requested buffer size\n        final BlockingQueue<InputDatum> inputQueue = new LinkedBlockingDeque<InputDatum>(bufferSize);\n\n        // a priority queue that stores up to bufferSize * MAP_QUEUE_SCALE_FACTOR elements\n        // produced by completed map jobs.\n        final PriorityBlockingQueue<MapResult> mapResultQueue = new PriorityBlockingQueue<MapResult>(bufferSize*100);\n\n        // TODO -- the logic of this blocking queue is wrong!  We need to wait for map jobs in order, not just\n        //      -- in the order in which they are produced\n\n        // TODO -- map executor must have fixed size map jobs queue\n\n        inputExecutor.submit(new InputProducer(inputReader, inputQueue));\n        final Future<ReduceType> reduceResult = reduceExecutor.submit(new ReducerThread(reduce, initialValue, mapResultQueue));\n\n        try {\n            int numJobs = 0;\n            while ( true ) {\n                // block on input\n                final InputDatum inputEnqueueWrapped = inputQueue.take();\n\n                if ( ! inputEnqueueWrapped.isLast() ) {\n                    // get the object itself\n                    final InputType input = inputEnqueueWrapped.datum;\n\n                    // the next map call has id + 1\n                    numJobs++;\n\n                    // send job for map via the completion service\n                    final CallableMap doMap = new CallableMap(map, numJobs, input, mapResultQueue);\n                    mapJobCompletionService.submit(doMap, numJobs);\n\n                    debugPrint(\"  Done with cycle of map/reduce\");\n\n                    if ( progressFunction != null ) // TODO -- don't cycle so often\n                        progressFunction.progress(input);\n                } else {\n                    waitForLastJob(mapJobCompletionService, numJobs);\n                    mapResultQueue.add(new MapResult());\n                    return reduceResult.get(); // wait for our result of reduce\n                }\n            }\n        } catch (InterruptedException ex) {\n            throw new ReviewedStingException(\"got execution exception\", ex);\n        } catch (ExecutionException ex) {\n            throw new ReviewedStingException(\"got execution exception\", ex);\n        }\n    }","id":90050,"modified_method":"/**\n     * Efficient parallel version of Map/Reduce\n     *\n     * @return the reduce result of this map/reduce job\n     */\n    @Requires({\"inputReader != null\", \"map != null\", \"reduce != null\"})\n    private ReduceType executeMultiThreaded(final Iterator<InputType> inputReader,\n                                            final NSMapFunction<InputType, MapType> map,\n                                            final ReduceType initialValue,\n                                            final NSReduceFunction<MapType, ReduceType> reduce) {\n        debugPrint(\"Executing nanoScheduler\");\n\n        // a blocking queue that limits the number of input datum to the requested buffer size\n        final BlockingQueue<InputProducer<InputType>.InputValue> inputQueue\n                = new LinkedBlockingDeque<InputProducer<InputType>.InputValue>(inputBufferSize);\n\n        // a priority queue that stores up to mapBufferSize elements\n        // produced by completed map jobs.\n        final BlockingQueue<Future<MapResult<MapType>>> mapResultQueue =\n                new LinkedBlockingDeque<Future<MapResult<MapType>>>(mapBufferSize);\n\n        // Start running the input reader thread\n        inputExecutor.submit(new InputProducer<InputType>(inputReader, inputTimer, inputQueue));\n\n        // Start running the reducer thread\n        final ReducerThread<MapType, ReduceType> reducer\n                = new ReducerThread<MapType, ReduceType>(reduce, reduceTimer, initialValue, mapResultQueue);\n        final Future<ReduceType> reduceResult = reduceExecutor.submit(reducer);\n\n        try {\n            int numJobs = 0;\n\n            while ( true ) {\n                // block on input\n                final InputProducer<InputType>.InputValue inputEnqueueWrapped = inputQueue.take();\n\n                if ( ! inputEnqueueWrapped.isLast() ) {\n                    // get the object itself\n                    final InputType input = inputEnqueueWrapped.getValue();\n\n                    // the next map call has jobID + 1\n                    numJobs++;\n\n                    // send job for map via the completion service\n                    final CallableMap doMap = new CallableMap(map, numJobs, input);\n                    final Future<MapResult<MapType>> mapJob = mapExecutor.submit(doMap);\n                    mapResultQueue.put(mapJob);\n\n                    debugPrint(\"  Done with cycle of map/reduce\");\n\n                    if ( numJobs % inputBufferSize == 0 && progressFunction != null )\n                        progressFunction.progress(input);\n                } else {\n                    mapResultQueue.put(new FutureValue<MapResult<MapType>>(new MapResult<MapType>()));\n                    return reduceResult.get(); // wait for our result of reduce\n                }\n            }\n        } catch (InterruptedException ex) {\n            throw new ReviewedStingException(\"got execution exception\", ex);\n        } catch (ExecutionException ex) {\n            throw new ReviewedStingException(\"got execution exception\", ex);\n        }\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * The input buffer size used by this NanoScheduler\n     * @return\n     */\n    @Ensures(\"result > 0\")\n    public int getBufferSize() {\n        return bufferSize;\n    }","id":90051,"modified_method":"/**\n     * The input buffer size used by this NanoScheduler\n     * @return\n     */\n    @Ensures(\"result > 0\")\n    public int getInputBufferSize() {\n        return inputBufferSize;\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Helper function to cleanly shutdown an execution service, checking that the execution\n     * state is clean when it's done.\n     *\n     * @param name a string name for error messages for the executorService we are shutting down\n     * @param executorService the executorService to shut down\n     */\n    private void shutdownExecutor(final String name, final ExecutorService executorService) {\n        if ( executorService != null ) {\n            if ( executorService.isShutdown() || executorService.isTerminated() )\n                throw new IllegalStateException(\"Executor service \" + name + \" is already shut down!\");\n\n            final List<Runnable> remaining = executorService.shutdownNow();\n            if ( ! remaining.isEmpty() )\n                throw new IllegalStateException(remaining.size() + \" remaining tasks found in an executor \" + name + \", unexpected behavior!\");\n        }\n    }","id":90052,"modified_method":"/**\n     * Helper function to cleanly shutdown an execution service, checking that the execution\n     * state is clean when it's done.\n     *\n     * @param name a string name for error messages for the executorService we are shutting down\n     * @param executorService the executorService to shut down\n     */\n    @Requires({\"name != null\", \"executorService != null\"})\n    @Ensures(\"executorService.isShutdown()\")\n    private void shutdownExecutor(final String name, final ExecutorService executorService) {\n        if ( executorService.isShutdown() || executorService.isTerminated() )\n            throw new IllegalStateException(\"Executor service \" + name + \" is already shut down!\");\n\n        final List<Runnable> remaining = executorService.shutdownNow();\n        if ( ! remaining.isEmpty() )\n            throw new IllegalStateException(remaining.size() + \" remaining tasks found in an executor \" + name + \", unexpected behavior!\");\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Requires({\"map != null\"})\n        private CallableMap(final NanoSchedulerMapFunction<InputType, MapType> map,\n                            final int id,\n                            final InputType input,\n                            final PriorityBlockingQueue<MapResult> mapResultQueue) {\n            this.id = id;\n            this.input = input;\n            this.map = map;\n            this.mapResultQueue = mapResultQueue;\n        }","id":90053,"modified_method":"@Requires({\"map != null\"})\n        private CallableMap(final NSMapFunction<InputType, MapType> map,\n                            final int id,\n                            final InputType input) {\n            this.id = id;\n            this.input = input;\n            this.map = map;\n        }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new nanoschedule with the desire characteristics requested by the argument\n     *\n     * @param bufferSize the number of input elements to read in each scheduling cycle.\n     * @param nThreads the number of threads to use to get work done, in addition to the thread calling execute\n     */\n    public NanoScheduler(final int bufferSize,\n                         final int nThreads) {\n        if ( bufferSize < 1 ) throw new IllegalArgumentException(\"bufferSize must be >= 1, got \" + bufferSize);\n        if ( nThreads < 1 ) throw new IllegalArgumentException(\"nThreads must be >= 1, got \" + nThreads);\n\n        this.bufferSize = bufferSize;\n        this.nThreads = nThreads;\n\n        if ( nThreads == 1 ) {\n            this.mapExecutor = this.inputExecutor = this.reduceExecutor = null;\n        } else {\n            this.mapExecutor = Executors.newFixedThreadPool(nThreads-1, new NamedThreadFactory(\"NS-map-thread-%d\"));\n            this.inputExecutor = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"NS-input-thread-%d\"));\n            this.reduceExecutor = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"NS-reduce-thread-%d\"));\n        }\n\n        // start timing the time spent outside of the nanoScheduler\n        outsideSchedulerTimer.start();\n    }","id":90054,"modified_method":"/**\n     * Create a new nanoscheduler with the desire characteristics requested by the argument\n     *\n     * @param inputBufferSize the number of input elements to read in each scheduling cycle.\n     * @param nThreads the number of threads to use to get work done, in addition to the\n     *                 thread calling execute\n     */\n    public NanoScheduler(final int inputBufferSize, final int nThreads) {\n        if ( inputBufferSize < 1 ) throw new IllegalArgumentException(\"inputBufferSize must be >= 1, got \" + inputBufferSize);\n        if ( nThreads < 1 ) throw new IllegalArgumentException(\"nThreads must be >= 1, got \" + nThreads);\n\n        this.inputBufferSize = inputBufferSize;\n        this.mapBufferSize = inputBufferSize * MAP_BUFFER_SIZE_SCALE_FACTOR;\n        this.nThreads = nThreads;\n\n        if ( nThreads == 1 ) {\n            this.mapExecutor = null;\n            this.inputExecutor = this.reduceExecutor = null;\n        } else {\n            this.mapExecutor = (ThreadPoolExecutor)Executors.newFixedThreadPool(nThreads-1, new NamedThreadFactory(\"NS-map-thread-%d\"));\n            this.mapExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n            this.inputExecutor = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"NS-input-thread-%d\"));\n            this.reduceExecutor = Executors.newSingleThreadExecutor(new NamedThreadFactory(\"NS-reduce-thread-%d\"));\n        }\n\n        // start timing the time spent outside of the nanoScheduler\n        outsideSchedulerTimer.start();\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Set the progress callback function to progressFunction\n     *\n     * The progress callback is invoked after each buffer size elements have been processed by map/reduce\n     *\n     * @param progressFunction a progress function to call, or null if you don't want any progress callback\n     */\n    public void setProgressFunction(final NanoSchedulerProgressFunction<InputType> progressFunction) {\n        this.progressFunction = progressFunction;\n    }","id":90055,"modified_method":"/**\n     * Set the progress callback function to progressFunction\n     *\n     * The progress callback is invoked after each buffer size elements have been processed by map/reduce\n     *\n     * @param progressFunction a progress function to call, or null if you don't want any progress callback\n     */\n    public void setProgressFunction(final NSProgressFunction<InputType> progressFunction) {\n        this.progressFunction = progressFunction;\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Tells this nanoScheduler to shutdown immediately, releasing all its resources.\n     *\n     * After this call, execute cannot be invoked without throwing an error\n     */\n    public void shutdown() {\n        outsideSchedulerTimer.stop();\n\n        shutdownExecutor(\"inputExecutor\", inputExecutor);\n        shutdownExecutor(\"mapExecutor\", mapExecutor);\n        shutdownExecutor(\"reduceExecutor\", reduceExecutor);\n        shutdown = true;\n\n        if (TIME_CALLS) {\n            printTimerInfo(\"Input   time\", inputTimer);\n            printTimerInfo(\"Map     time\", mapTimer);\n            printTimerInfo(\"Reduce  time\", reduceTimer);\n            printTimerInfo(\"Outside time\", outsideSchedulerTimer);\n        }\n    }","id":90056,"modified_method":"/**\n     * Tells this nanoScheduler to shutdown immediately, releasing all its resources.\n     *\n     * After this call, execute cannot be invoked without throwing an error\n     */\n    public void shutdown() {\n        outsideSchedulerTimer.stop();\n\n        if ( nThreads > 1 ) {\n            shutdownExecutor(\"inputExecutor\", inputExecutor);\n            shutdownExecutor(\"mapExecutor\", mapExecutor);\n            shutdownExecutor(\"reduceExecutor\", reduceExecutor);\n        }\n        shutdown = true;\n\n        if (TIME_CALLS) {\n            printTimerInfo(\"Input   time\", inputTimer);\n            printTimerInfo(\"Map     time\", mapTimer);\n            printTimerInfo(\"Reduce  time\", reduceTimer);\n            printTimerInfo(\"Outside time\", outsideSchedulerTimer);\n        }\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"private void testNanoScheduler(final NanoSchedulerBasicTest test) throws InterruptedException {\n        final NanoScheduler<Integer, Integer, Integer> nanoScheduler =\n                new NanoScheduler<Integer, Integer, Integer>(test.bufferSize, test.nThreads);\n\n        final ProgressCallback callback = new ProgressCallback();\n        nanoScheduler.setProgressFunction(callback);\n\n        Assert.assertEquals(nanoScheduler.getBufferSize(), test.bufferSize, \"bufferSize argument\");\n        Assert.assertEquals(nanoScheduler.getnThreads(), test.nThreads, \"nThreads argument\");\n\n        final Integer sum = nanoScheduler.execute(test.makeReader(), test.makeMap(), test.initReduce(), test.makeReduce());\n        Assert.assertNotNull(sum);\n        Assert.assertEquals((int)sum, test.expectedResult, \"NanoScheduler sum not the same as calculated directly\");\n\n        Assert.assertTrue(callback.callBacks >= test.nExpectedCallbacks(), \"Not enough callbacks detected.  Expected at least \" + test.nExpectedCallbacks() + \" but saw only \" + callback.callBacks);\n        nanoScheduler.shutdown();\n    }","id":90057,"modified_method":"private void testNanoScheduler(final NanoSchedulerBasicTest test) throws InterruptedException {\n        final NanoScheduler<Integer, Integer, Integer> nanoScheduler =\n                new NanoScheduler<Integer, Integer, Integer>(test.bufferSize, test.nThreads);\n\n        final ProgressCallback callback = new ProgressCallback();\n        nanoScheduler.setProgressFunction(callback);\n\n        Assert.assertEquals(nanoScheduler.getInputBufferSize(), test.bufferSize, \"inputBufferSize argument\");\n        Assert.assertEquals(nanoScheduler.getnThreads(), test.nThreads, \"nThreads argument\");\n\n        final Integer sum = nanoScheduler.execute(test.makeReader(), test.makeMap(), test.initReduce(), test.makeReduce());\n        Assert.assertNotNull(sum);\n        Assert.assertEquals((int)sum, test.expectedResult, \"NanoScheduler sum not the same as calculated directly\");\n\n        Assert.assertTrue(callback.callBacks >= test.nExpectedCallbacks(), \"Not enough callbacks detected.  Expected at least \" + test.nExpectedCallbacks() + \" but saw only \" + callback.callBacks);\n        nanoScheduler.shutdown();\n    }","commit_id":"2e7b32acc0f59f4c4c301347fbbc9fde82c4175f","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter behavior. Gets called after all completion\n\t * proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to trim matching\n\t * <code>ICompletionProposal#displayString<\/code> with matching prefix values.\n\t * \n\t * @see #sortAndFilter(List, EObject, String, IDocument, int, AbstractNode, LeafNode)\n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\n\t\tMap<String, ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String, ICompletionProposal>();\n\n\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator.hasNext();) {\n\n\t\t\tICompletionProposal completionProposal = iterator.next();\n\n\t\t\t// filter duplicate displayString\n\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\n\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\n\t\t\t\tif (model != null) {\n\n\t\t\t\t\tCompositeNode parserNode = NodeUtil.getRootNode(model);\n\n\t\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(parserNode, offset);\n\n\t\t\t\t\tboolean isCursorAtTheEndOfTheLastElement = offset == (currentLeafNode.getTotalOffset() + currentLeafNode\n\t\t\t\t\t\t\t.getTotalLength());\n\n\t\t\t\t\tif (isCursorAtTheEndOfTheLastElement && completionProposal instanceof XtextCompletionProposal) {\n\n\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\n\t\t\t\t\t\tAbstractElement abstractElement = xtextCompletionProposal.getAbstractElement();\n\n\t\t\t\t\t\tEObject grammarElement = currentLeafNode.getGrammarElement();\n\t\t\t\t\t\t// at the end of the last element we want to filter only the CompletionProposal for the same grammar element\n\t\t\t\t\t\tif (((isCursorAtTheEndOfTheLastElement && abstractElement.equals(grammarElement)) || !isCursorAtTheEndOfTheLastElement)\n\t\t\t\t\t\t\t\t&& !completionProposal.getDisplayString().startsWith(currentLeafNode.getText())) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"filter completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"filter duplicate completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t}\n\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","id":90058,"modified_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter behavior. Gets called after all completion\n\t * proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to trim matching\n\t * <code>ICompletionProposal#displayString<\/code> with matching prefix values.\n\t * \n\t * @see #sortAndFilter(List, EObject, String, IDocument, int, AbstractNode, LeafNode)\n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\n\t\tMap<String, ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String, ICompletionProposal>();\n\n\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator.hasNext();) {\n\n\t\t\tICompletionProposal completionProposal = iterator.next();\n\n\t\t\t// filter duplicate displayString\n\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\n\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\n\t\t\t\tif (model != null) {\n\n\t\t\t\t\t// filter by prefix \n\t\t\t\t\t// TODO: this works only if we have access to the corresponding grammarelement \n\t\t\t\t\tif (completionProposal instanceof XtextCompletionProposal) {\n\n\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\n\t\t\t\t\t\tAbstractElement abstractElement = null;\n\n\t\t\t\t\t\tif (xtextCompletionProposal.getAbstractElement() instanceof Keyword ||\n\t\t\t\t\t\t\txtextCompletionProposal.getAbstractElement() instanceof CrossReference) {\n\t\t\t\t\t\t\tabstractElement = GrammarUtil.containingAssignment(xtextCompletionProposal.getAbstractElement());\n\t\t\t\t\t\t} \n\t\t\t\t\t\t\n\t\t\t\t\t\tif (null==abstractElement) {\n\t\t\t\t\t\t\tabstractElement = xtextCompletionProposal.getAbstractElement();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tCompositeNode rootNode = NodeUtil.getRootNode(model);\n\n\t\t\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\t\t\tEObject grammarElement =  GrammarUtil.containingAssignment(currentLeafNode.getGrammarElement());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (null==grammarElement) {\n\t\t\t\t\t\t\tgrammarElement = currentLeafNode.getGrammarElement();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboolean atTheEndOfTheLastCompleteNode = currentLeafNode == lastCompleteNode;\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean candidateToCompare \t\t\t= false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// means if we are at the end of a complete token we want to filter only equal grammarelements (not the 'next' ones)\n\t\t\t\t\t\tif (atTheEndOfTheLastCompleteNode && abstractElement.equals(grammarElement)) {\n\t\t\t\t\t\t\tcandidateToCompare = true;\n\t\t\t\t\t\t} else if (!atTheEndOfTheLastCompleteNode ) {\n\t\t\t\t\t\t\tcandidateToCompare = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( candidateToCompare && (!\"\".equals(prefix.trim()) && !completionProposal.getDisplayString().toUpperCase().startsWith(prefix.toUpperCase()))) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"filter completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"filter duplicate completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t}\n\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","commit_id":"b9e16970797aa6ce60cc83699be4189d8488bdbc","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * computes the possible grammar elements following the one at the given offset and calls the respective methods on\n\t * the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\n\t\tICompletionProposal[] completionProposals = null;\n\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\n\t\t\tif (document instanceof IXtextDocument) {\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tIXtextDocument xtextDocument = (IXtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = calculatePrefix(viewer, offset, currentLeafNode);\n\n\t\t\t\tEObject model = lastCompleteNode instanceof AbstractNode ? NodeUtil\n\t\t\t\t\t\t.getNearestSemanticObject((AbstractNode) lastCompleteNode) : lastCompleteNode;\n\n\t\t\t\tSet<AbstractElement> nextValidElementSet = new LinkedHashSet<AbstractElement>();\n\t\t\t\t/**\n\t\t\t\t * in case of a crossreference which isnt linked already we evaluate it again and delegate to\n\t\t\t\t * proposalProvider (again)\n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode)) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode,\n\t\t\t\t\t\t\toffset));\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * in case of 'at-the-end' of the previous,completed element we evaluate it again for\n\t\t\t\t * 'right-to-left-backtracking' cases (e.g. for keyword 'kind' kind>|< |=cursorpos)\n\t\t\t\t */\n\t\t\t\telse if (currentLeafNode == lastCompleteNode) {\n\t\t\t\t\tnextValidElementSet = ParseTreeUtil\n\t\t\t\t\t\t\t.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnextValidElementSet = ParseTreeUtil\n\t\t\t\t\t\t\t.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t}\n\n\t\t\t\tProposalProviderInvokerSwitch proposalProviderInvokerSwitch = new ProposalProviderInvokerSwitch(model,\n\t\t\t\t\t\tdocument, offset, prefix, proposalProvider);\n\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = proposalProviderInvokerSwitch\n\t\t\t\t\t\t\t.collectCompletionProposalList(resolvedElementOrRuleList);\n\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> processedCompletionProposalList = proposalProvider\n\t\t\t\t\t\t\t.sortAndFilter(completionProposalList, model, prefix, document, offset);\n\t\t\t\t\tcompletionProposals = processedCompletionProposalList.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposals;\n\t}","id":90059,"modified_method":"/**\n\t * computes the possible grammar elements following the one at the given offset and calls the respective methods on\n\t * the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\n\t\tICompletionProposal[] completionProposals = null;\n\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\n\t\t\tif (document instanceof IXtextDocument) {\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tIXtextDocument xtextDocument = (IXtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = calculatePrefix(viewer, offset, currentLeafNode);\n\n\t\t\t\tEObject model = lastCompleteNode instanceof AbstractNode ? NodeUtil\n\t\t\t\t\t\t.getNearestSemanticObject((AbstractNode) lastCompleteNode) : lastCompleteNode;\n\n\t\t\t\tSet<AbstractElement> nextValidElementSet = new LinkedHashSet<AbstractElement>();\n\t\t\t\t/**\n\t\t\t\t * in case of a crossreference which isnt linked already we evaluate it again and delegate to\n\t\t\t\t * proposalProvider (again)\n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode)) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode,\n\t\t\t\t\t\t\toffset));\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * in case of 'at-the-end' of the previous,completed element we evaluate it again for\n\t\t\t\t * 'right-to-left-backtracking' cases (e.g. for keyword 'kind' kind>|< |=cursorpos)\n\t\t\t\t */\n\t\t\t\telse if (currentLeafNode == lastCompleteNode) {\n\t\t\t\t\tAssignment containingAssignment = GrammarUtil.containingAssignment(lastCompleteNode.getGrammarElement());\n\t\t\t\t\t\n\t\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof RuleCall && containingAssignment!=null) {\n\t\t\t\t\t\tnextValidElementSet.add(containingAssignment);\n\t\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextValidElementSet = ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnextValidElementSet = ParseTreeUtil\n\t\t\t\t\t\t\t.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t}\n\n\t\t\t\tProposalProviderInvokerSwitch proposalProviderInvokerSwitch = new ProposalProviderInvokerSwitch(model,\n\t\t\t\t\t\tdocument, offset, prefix, proposalProvider);\n\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = proposalProviderInvokerSwitch\n\t\t\t\t\t\t\t.collectCompletionProposalList(resolvedElementOrRuleList);\n\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> processedCompletionProposalList = proposalProvider\n\t\t\t\t\t\t\t.sortAndFilter(completionProposalList, model, prefix, document, offset);\n\t\t\t\t\tcompletionProposals = processedCompletionProposalList.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposals;\n\t}","commit_id":"b9e16970797aa6ce60cc83699be4189d8488bdbc","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testComputeCompletionProposalsCount() throws Exception {\r\n\t\t\r\n\t\tMap<String, Integer> model2ExpectedProposalCountMap = new HashMap<String, Integer>();\r\n\t\tStringBuilder modelBuilder = new StringBuilder(\"\");\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.toString(), 1);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"spielplatz \").toString(), 2);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"1 \").toString(), 3);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"\\\"JUNIT\\\" \").toString(), 1);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"{ \").toString(), 5);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"kind \").toString(), 1);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"(k1 0) erwachsener(e1 0) erwachsener(e2 0) familie( f1 \").toString(),2);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"e1 \").toString(),2);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"e2 \").toString(),1);\r\n\r\n\t\tfor (Iterator<String> iterator = model2ExpectedProposalCountMap.keySet()\r\n\t\t\t\t.iterator(); iterator.hasNext();) {\r\n\r\n\t\t\tString testDslModel = iterator.next();\r\n\t\t\t\r\n\t\t\tint expectedProposalCount = model2ExpectedProposalCountMap.get(testDslModel);\r\n\r\n\t\t\tCompositeNode rootNode = getRootNode(testDslModel);\r\n\t\t\t\r\n\t\t\treset(textViewerMock,xtextDocumentMock,textViewerMock);\r\n\t\t\t\r\n\t\t\texpect(textViewerMock.getDocument()).andReturn(xtextDocumentMock);\r\n\t\t\texpect(xtextDocumentMock.readOnly((UnitOfWork<CompositeNode>) anyObject())).andReturn(rootNode);\r\n\t\t\texpect(textViewerMock.getTextWidget()).andReturn(newStyledTextWidgetMock(testDslModel));\r\n\t\t\t\r\n\t\t\treplay(textViewerMock,xtextDocumentMock);\r\n\r\n\t\t\tICompletionProposal[] computeCompletionProposals = defaultContentAssistProcessor\r\n\t\t\t\t\t.computeCompletionProposals(textViewerMock, testDslModel\r\n\t\t\t\t\t\t\t.length());\r\n\t\t\t\r\n\t\t\tassertEquals(\"expect only \" + expectedProposalCount+ \" CompletionProposal item for model '\" + testDslModel+ \"'\", \r\n\t\t\t\t\texpectedProposalCount,\r\n\t\t\t\t\tcomputeCompletionProposals.length);\r\n\t\t}\r\n\r\n\t}","id":90060,"modified_method":"public void testComputeCompletionProposalsCount() throws Exception {\r\n\t\tcontentAssistProcessorTestBuilder.assertCount(1)\r\n\t\t\t.append(\"spielplatz \").assertCount(2)\r\n\t\t\t.append(\"1 \").assertCount(3)\r\n\t\t\t.append(\"\\\"JUNIT\\\" \").assertCount(1)\r\n\t\t\t.append(\"{ \").assertCount(5)\r\n\t\t\t.append(\"kind \").assertCount(1)\r\n\t\t\t.append(\"(k1 0) erwachsener(e1 0) erwachsener(e2 0) familie( f1 \").assertCount(2)\r\n\t\t\t.append(\"e1 \").assertCount(2)\r\n\t\t\t.append(\"e2\").assertCount(1);\r\n\t}","commit_id":"b9e16970797aa6ce60cc83699be4189d8488bdbc","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\r\n\tprotected void setUp() throws Exception {\r\n\t\tsuper.setUp();\r\n\t\twithUi(ReferenceGrammarStandaloneSetup.class,ReferenceGrammarUiConfig.class);\r\n\t\ttextViewerMock = createMock(ITextViewer.class);\r\n\t\txtextDocumentMock = createMock(IXtextDocument.class);\r\n\t\tdefaultContentAssistProcessor = new DefaultContentAssistProcessor();\r\n\t\tServiceRegistry.injectServices(getCurrentServiceScope(), defaultContentAssistProcessor);\r\n\t}","id":90061,"modified_method":"@Override\r\n\tprotected void setUp() throws Exception {\r\n\t\tsuper.setUp();\r\n\t\twithUi(ReferenceGrammarStandaloneSetup.class,ReferenceGrammarUiConfig.class);\r\n\t\tcontentAssistProcessorTestBuilder = new ContentAssistProcessorTestBuilder(getCurrentServiceScope(),new DefaultContentAssistProcessor());\r\n\t}","commit_id":"b9e16970797aa6ce60cc83699be4189d8488bdbc","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testComputeCompletionProposalsText() throws Exception {\r\n\t\t\r\n\t\tMap<String, List<String>> model2ExpectedProposalTextMap = new HashMap<String, List<String>>();\r\n\t\tStringBuilder modelBuilder = new StringBuilder(\"\");\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.toString(), Arrays.asList(\"spielplatz \"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"spielplatz \").toString(), Arrays.asList(\"0\",\"1\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"1 \").toString(), Arrays.asList(\"\\\"SpielplatzBeschreibungSTRING\\\"\",\"\\\"SpielplatzBeschreibung\\\"\",\"{\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"\\\"SpielplatzBeschreibung\\\" \").toString(), Arrays.asList(\"{\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"{ \").toString(), Arrays.asList(\"erwachsener \",\"familie \",\"spielzeug \",\"kind \",\"}\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"erwachsener \").toString(), Arrays.asList(\"(\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"( \").toString(), Arrays.asList(\"ErwachsenerNameID\",\"ErwachsenerName\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"e1 \").toString(), Arrays.asList(\"0\",\"1\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"0 \").toString(), Arrays.asList(\")\"));\r\n\t\tmodelBuilder.append(\")\").append(\"erwachsener (e2 0)\");\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"kind \").toString(), Arrays.asList(\"(\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"( \").toString(), Arrays.asList(\"KindNameID\",\"KindName\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"k1 \").toString(), Arrays.asList(\"0\",\"1\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"0 \").toString(), Arrays.asList(\")\"));\r\n\t\tmodelBuilder.append(\")\").append(\"kind (k2 0)\");\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"familie \").toString(), Arrays.asList(\"(\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"( \").toString(), Arrays.asList(\"keyword \",\"\\\"FamilieNameSTRING\\\"\",\"FamilieNameID\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"keyword \").toString(), Arrays.asList(\"e1\",\"e2\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"e1 \").toString(), Arrays.asList(\"e1\",\"e2\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"\").toString(), Arrays.asList(\"e1\",\"e2\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"e2 \").toString(), Arrays.asList(\"k1\",\"k2\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"k\").toString(), Arrays.asList(\"k1\",\"k2\",\",\",\")\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"1 \").toString(), Arrays.asList(\",\",\")\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"k2 \").toString(), Arrays.asList(\",\",\")\"));\r\n\t\t\r\n\t\tfor (Iterator<String> iterator = model2ExpectedProposalTextMap.keySet()\r\n\t\t\t\t.iterator(); iterator.hasNext();) {\r\n\r\n\t\t\tString testDslModel = iterator.next();\r\n\t\t\t\r\n\t\t\tList<String> expectedTextList = model2ExpectedProposalTextMap.get(testDslModel);\r\n\r\n\t\t\tCompositeNode rootNode = getRootNode(testDslModel);\r\n\t\t\t\r\n\t\t\treset(textViewerMock,xtextDocumentMock,textViewerMock);\r\n\t\t\t\r\n\t\t\texpect(textViewerMock.getDocument()).andReturn(xtextDocumentMock);\r\n\t\t\texpect(xtextDocumentMock.readOnly((UnitOfWork<CompositeNode>) anyObject())).andReturn(rootNode);\r\n\t\t\texpect(textViewerMock.getTextWidget()).andReturn(newStyledTextWidgetMock(testDslModel));\r\n\t\t\t\r\n\t\t\treplay(textViewerMock,xtextDocumentMock);\r\n\r\n\t\t\tICompletionProposal[] computeCompletionProposals = defaultContentAssistProcessor\r\n\t\t\t\t\t.computeCompletionProposals(textViewerMock, testDslModel\r\n\t\t\t\t\t\t\t.length());\r\n\t\t\t\r\n\t\t\tassertEquals(\"expect only \" + expectedTextList.size()+ \" CompletionProposal item for model '\" + testDslModel+ \"'\", \r\n\t\t\t\t\texpectedTextList.size(),\r\n\t\t\t\t\tcomputeCompletionProposals.length);\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < computeCompletionProposals.length; i++) {\r\n\t\t\t\tICompletionProposal completionProposal = computeCompletionProposals[i];\r\n\t\t\t\tassertTrue(\"expect completionProposal text '\"+completionProposal+\"' \", expectedTextList.contains(completionProposal.getDisplayString()));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\r\n\t}","id":90062,"modified_method":"public void testComputeCompletionProposalsText() throws Exception {\r\n\t\tcontentAssistProcessorTestBuilder.assertText(\"spielplatz \")\r\n\t\t\t.applyText().assertText(\"0\",\"1\")\r\n\t\t\t.applyText().assertText(\"\\\"SpielplatzBeschreibungSTRING\\\"\",\"\\\"SpielplatzBeschreibung\\\"\",\"{\")\r\n\t\t\t.applyText().assertText(\"{\")\r\n\t\t\t.applyText().assertText(\"erwachsener \",\"familie \",\"spielzeug \",\"kind \",\"}\")\r\n\t\t\t.append(\"erwachsener \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"ErwachsenerNameID\",\"ErwachsenerName\")\r\n\t\t\t.append(\"e1 \").assertText(\"0\",\"1\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"erwachsener (e2 0) kind \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"KindNameID\",\"KindName\")\r\n\t\t\t.append(\"k1 \").assertText(\"0\",\"1\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"kind (k2 0) familie \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"keyword \",\"\\\"FamilieNameSTRING\\\"\",\"FamilieNameID\")\r\n\t\t\t.append(\"keyword \").assertText(\"e1\",\"e2\")\r\n\t\t\t.applyText().assertText(\"e1\",\"e2\")\r\n\t\t\t.append(\"e2 \").assertText(\"k1\",\"k2\")\r\n\t\t\t.append(\"k\").assertText(\"k1\",\"k2\",\",\",\")\")\r\n\t\t\t.append(\"1 \").assertText(\",\",\")\")\r\n\t\t\t.append(\"k2 \").assertText(\",\",\")\")\r\n\t\t;\r\n\t\t\r\n\t\t\r\n\t}","commit_id":"b9e16970797aa6ce60cc83699be4189d8488bdbc","url":"https://github.com/eclipse/xtext"},{"original_method":"public void apply(ITextViewer viewer, char trigger, int stateMask,\n\t\t\tint offset) {\n\n\t\ttry {\n\t\t\t\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tif (model != null) {\n\t\t\t\tCompositeNode parserNode = NodeUtil.getRootNode(model);\n\t\t\t\t\n\t\t\t\tLeafNode currentLeafNode=ParseTreeUtil.getCurrentNodeByOffset(parserNode, offset);\n\t\t\t\t\n\t\t\t\tboolean isCursorAtTheEndOfTheLastElement = offset == (currentLeafNode.getTotalOffset() + currentLeafNode\n\t\t\t\t\t\t.getTotalLength());\n\t\t\t\t\n\t\t\t\tif ((currentLeafNode.isHidden() && !\"\".equals(currentLeafNode.getText().trim()))\n\t\t\t\t\t\t|| isCursorAtTheEndOfTheLastElement) {\n\t\t\t\t\tif (getDisplayString().startsWith(currentLeafNode.getText())) {\n\t\t\t\t\t\tsetText(getText().substring(currentLeafNode.getText().length()));\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (!currentLeafNode.isHidden() && \n\t\t\t\t\t\tisCursorAtTheEndOfTheLastElement && \n\t\t\t\t\t\tgetDisplayString().equalsIgnoreCase(getText())) {\n\n\t\t\t\t\tif (currentLeafNode.getGrammarElement() instanceof CrossReference\n\t\t\t\t\t\t\t&& abstractElement instanceof CrossReference) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (currentLeafNode.getGrammarElement() instanceof RuleCall\n\t\t\t\t\t\t\t&& currentLeafNode.getGrammarElement().eContainer() instanceof Assignment\n\t\t\t\t\t\t\t&& abstractElement instanceof Assignment) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (!GrammarUtil.containingParserRule(abstractElement).equals(GrammarUtil.containingParserRule(currentLeafNode.getGrammarElement()))) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tdocument.replace(this.offset, offset != this.offset ? offset\n\t\t\t\t\t- this.offset : 0, getText());\n\n\t\t} catch (BadLocationException e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}","id":90063,"modified_method":"public void apply(ITextViewer viewer, char trigger, int stateMask,\n\t\t\tint offset) {\n\n\t\ttry {\n\t\t\t\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tint offsetToApply = this.offset;\n\n\t\t\tif (model != null) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tCompositeNode parserNode = NodeUtil.getRootNode(model);\n\t\t\t\t\n\t\t\t\tLeafNode currentLeafNode=ParseTreeUtil.getCurrentNodeByOffset(parserNode, offset);\n\t\t\t\t\n\t\t\t\tboolean isCursorAtTheEndOfTheLastElement = offset == (currentLeafNode.getTotalOffset() + currentLeafNode\n\t\t\t\t\t\t.getTotalLength());\n\t\t\t\t\n\t\t\t\tif ((currentLeafNode.isHidden() && !\"\".equals(currentLeafNode.getText().trim()))\n\t\t\t\t\t\t|| isCursorAtTheEndOfTheLastElement) {\n\t\t\t\t\tif (getDisplayString().toUpperCase().startsWith(currentLeafNode.getText().toUpperCase())) {\n\t\t\t\t\t\toffsetToApply-=currentLeafNode.getText().trim().length();\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (!currentLeafNode.isHidden() && \n\t\t\t\t\t\tisCursorAtTheEndOfTheLastElement && \n\t\t\t\t\t\toffsetToApply==offset) {\n\n\t\t\t\t\tif (currentLeafNode.getGrammarElement() instanceof CrossReference\n\t\t\t\t\t\t\t&& abstractElement instanceof CrossReference) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (currentLeafNode.getGrammarElement() instanceof RuleCall\n\t\t\t\t\t\t\t&& currentLeafNode.getGrammarElement().eContainer() instanceof Assignment\n\t\t\t\t\t\t\t&& abstractElement instanceof Assignment) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (!GrammarUtil.containingParserRule(abstractElement).equals(GrammarUtil.containingParserRule(currentLeafNode.getGrammarElement()))) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tdocument.replace(offsetToApply, offset != offsetToApply ? offset\n\t\t\t\t\t- offsetToApply : 0, getText());\n\n\t\t} catch (BadLocationException e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}","commit_id":"b9e16970797aa6ce60cc83699be4189d8488bdbc","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter behavior. Gets called after all completion\n\t * proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to trim matching\n\t * <code>ICompletionProposal#displayString<\/code> with matching prefix values.\n\t * \n\t * @see #sortAndFilter(List, EObject, String, IDocument, int, AbstractNode, LeafNode)\n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\n\t\tMap<String, ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String, ICompletionProposal>();\n\n\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator.hasNext();) {\n\n\t\t\tICompletionProposal completionProposal = iterator.next();\n\n\t\t\t// filter duplicate displayString\n\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\n\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\n\t\t\t\tif (model != null) {\n\n\t\t\t\t\tCompositeNode parserNode = NodeUtil.getRootNode(model);\n\n\t\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(parserNode, offset);\n\n\t\t\t\t\tboolean isCursorAtTheEndOfTheLastElement = offset == (currentLeafNode.getTotalOffset() + currentLeafNode\n\t\t\t\t\t\t\t.getTotalLength());\n\n\t\t\t\t\tif (isCursorAtTheEndOfTheLastElement && completionProposal instanceof XtextCompletionProposal) {\n\n\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\n\t\t\t\t\t\tAbstractElement abstractElement = xtextCompletionProposal.getAbstractElement();\n\n\t\t\t\t\t\tEObject grammarElement = currentLeafNode.getGrammarElement();\n\t\t\t\t\t\t// at the end of the last element we want to filter only the CompletionProposal for the same grammar element\n\t\t\t\t\t\tif (((isCursorAtTheEndOfTheLastElement && abstractElement.equals(grammarElement)) || !isCursorAtTheEndOfTheLastElement)\n\t\t\t\t\t\t\t\t&& !completionProposal.getDisplayString().startsWith(currentLeafNode.getText())) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"filter completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"filter duplicate completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t}\n\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","id":90064,"modified_method":"/**\n\t * Concrete subclasses can override this for custom sort and filter behavior. Gets called after all completion\n\t * proposals have been collected.\n\t * \n\t * The default behavior of this implementation is to sort duplicates and to trim matching\n\t * <code>ICompletionProposal#displayString<\/code> with matching prefix values.\n\t * \n\t * @see #sortAndFilter(List, EObject, String, IDocument, int, AbstractNode, LeafNode)\n\t */\n\tprotected List<? extends ICompletionProposal> doSortAndFilter(\n\t\t\tList<? extends ICompletionProposal> completionProposalList, EObject model, String prefix,\n\t\t\tIDocument document, int offset) {\n\n\t\tMap<String, ICompletionProposal> displayString2ICompletionProposalMap = new HashMap<String, ICompletionProposal>();\n\n\t\tfor (Iterator<? extends ICompletionProposal> iterator = completionProposalList.iterator(); iterator.hasNext();) {\n\n\t\t\tICompletionProposal completionProposal = iterator.next();\n\n\t\t\t// filter duplicate displayString\n\t\t\tif (!displayString2ICompletionProposalMap.containsKey(completionProposal.getDisplayString())) {\n\n\t\t\t\tdisplayString2ICompletionProposalMap.put(completionProposal.getDisplayString(), completionProposal);\n\n\t\t\t\tif (model != null) {\n\n\t\t\t\t\t// filter by prefix \n\t\t\t\t\t// TODO: this works only if we have access to the corresponding grammarelement \n\t\t\t\t\tif (completionProposal instanceof XtextCompletionProposal) {\n\n\t\t\t\t\t\tXtextCompletionProposal xtextCompletionProposal = (XtextCompletionProposal) completionProposal;\n\n\t\t\t\t\t\tAbstractElement abstractElement = null;\n\n\t\t\t\t\t\tif (xtextCompletionProposal.getAbstractElement() instanceof Keyword ||\n\t\t\t\t\t\t\txtextCompletionProposal.getAbstractElement() instanceof CrossReference) {\n\t\t\t\t\t\t\tabstractElement = GrammarUtil.containingAssignment(xtextCompletionProposal.getAbstractElement());\n\t\t\t\t\t\t} \n\t\t\t\t\t\t\n\t\t\t\t\t\tif (null==abstractElement) {\n\t\t\t\t\t\t\tabstractElement = xtextCompletionProposal.getAbstractElement();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tCompositeNode rootNode = NodeUtil.getRootNode(model);\n\n\t\t\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\t\t\tEObject grammarElement =  GrammarUtil.containingAssignment(currentLeafNode.getGrammarElement());\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (null==grammarElement) {\n\t\t\t\t\t\t\tgrammarElement = currentLeafNode.getGrammarElement();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tboolean atTheEndOfTheLastCompleteNode = currentLeafNode == lastCompleteNode;\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean candidateToCompare \t\t\t= false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// means if we are at the end of a complete token we want to filter only equal grammarelements (not the 'next' ones)\n\t\t\t\t\t\tif (atTheEndOfTheLastCompleteNode && abstractElement.equals(grammarElement)) {\n\t\t\t\t\t\t\tcandidateToCompare = true;\n\t\t\t\t\t\t} else if (!atTheEndOfTheLastCompleteNode ) {\n\t\t\t\t\t\t\tcandidateToCompare = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ( candidateToCompare && (!\"\".equals(prefix.trim()) && !completionProposal.getDisplayString().toUpperCase().startsWith(prefix.toUpperCase()))) {\n\t\t\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\t\t\tlogger.debug(\"filter completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titerator.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"filter duplicate completionProposal '\" + completionProposal + \"'\");\n\t\t\t\t}\n\n\t\t\t\titerator.remove();\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposalList;\n\t}","commit_id":"baf15411ca9eda7664ed4fbe73bea36b34b79ec4","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * computes the possible grammar elements following the one at the given offset and calls the respective methods on\n\t * the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\n\t\tICompletionProposal[] completionProposals = null;\n\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\n\t\t\tif (document instanceof IXtextDocument) {\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tIXtextDocument xtextDocument = (IXtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = calculatePrefix(viewer, offset, currentLeafNode);\n\n\t\t\t\tEObject model = lastCompleteNode instanceof AbstractNode ? NodeUtil\n\t\t\t\t\t\t.getNearestSemanticObject((AbstractNode) lastCompleteNode) : lastCompleteNode;\n\n\t\t\t\tSet<AbstractElement> nextValidElementSet = new LinkedHashSet<AbstractElement>();\n\t\t\t\t/**\n\t\t\t\t * in case of a crossreference which isnt linked already we evaluate it again and delegate to\n\t\t\t\t * proposalProvider (again)\n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode)) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode,\n\t\t\t\t\t\t\toffset));\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * in case of 'at-the-end' of the previous,completed element we evaluate it again for\n\t\t\t\t * 'right-to-left-backtracking' cases (e.g. for keyword 'kind' kind>|< |=cursorpos)\n\t\t\t\t */\n\t\t\t\telse if (currentLeafNode == lastCompleteNode) {\n\t\t\t\t\tnextValidElementSet = ParseTreeUtil\n\t\t\t\t\t\t\t.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnextValidElementSet = ParseTreeUtil\n\t\t\t\t\t\t\t.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t}\n\n\t\t\t\tProposalProviderInvokerSwitch proposalProviderInvokerSwitch = new ProposalProviderInvokerSwitch(model,\n\t\t\t\t\t\tdocument, offset, prefix, proposalProvider);\n\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = proposalProviderInvokerSwitch\n\t\t\t\t\t\t\t.collectCompletionProposalList(resolvedElementOrRuleList);\n\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> processedCompletionProposalList = proposalProvider\n\t\t\t\t\t\t\t.sortAndFilter(completionProposalList, model, prefix, document, offset);\n\t\t\t\t\tcompletionProposals = processedCompletionProposalList.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposals;\n\t}","id":90065,"modified_method":"/**\n\t * computes the possible grammar elements following the one at the given offset and calls the respective methods on\n\t * the proposal provider.\n\t */\n\tpublic ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, final int offset) {\n\n\t\tICompletionProposal[] completionProposals = null;\n\n\t\tif (proposalProvider != null) {\n\n\t\t\tIDocument document = viewer.getDocument();\n\n\t\t\tif (document instanceof IXtextDocument) {\n\n\t\t\t\tList<ICompletionProposal> completionProposalList = new ArrayList<ICompletionProposal>();\n\n\t\t\t\tIXtextDocument xtextDocument = (IXtextDocument) document;\n\n\t\t\t\tCompositeNode rootNode = xtextDocument.readOnly(new UnitOfWork<CompositeNode>() {\n\t\t\t\t\tpublic CompositeNode exec(XtextResource resource) throws Exception {\n\t\t\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\t\t\treturn parseResult.getRootNode();\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tAssert.isNotNull(rootNode);\n\n\t\t\t\tAbstractNode lastCompleteNode = ParseTreeUtil.getLastCompleteNodeByOffset(rootNode, offset);\n\n\t\t\t\tLeafNode currentLeafNode = ParseTreeUtil.getCurrentNodeByOffset(rootNode, offset);\n\n\t\t\t\tString prefix = calculatePrefix(viewer, offset, currentLeafNode);\n\n\t\t\t\tEObject model = lastCompleteNode instanceof AbstractNode ? NodeUtil\n\t\t\t\t\t\t.getNearestSemanticObject((AbstractNode) lastCompleteNode) : lastCompleteNode;\n\n\t\t\t\tSet<AbstractElement> nextValidElementSet = new LinkedHashSet<AbstractElement>();\n\t\t\t\t/**\n\t\t\t\t * in case of a crossreference which isnt linked already we evaluate it again and delegate to\n\t\t\t\t * proposalProvider (again)\n\t\t\t\t */\n\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof CrossReference && !isLinked(lastCompleteNode)) {\n\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode,\n\t\t\t\t\t\t\toffset));\n\t\t\t\t}\n\t\t\t\t/**\n\t\t\t\t * in case of 'at-the-end' of the previous,completed element we evaluate it again for\n\t\t\t\t * 'right-to-left-backtracking' cases (e.g. for keyword 'kind' kind>|< |=cursorpos)\n\t\t\t\t */\n\t\t\t\telse if (currentLeafNode == lastCompleteNode) {\n\t\t\t\t\tAssignment containingAssignment = GrammarUtil.containingAssignment(lastCompleteNode.getGrammarElement());\n\t\t\t\t\t\n\t\t\t\t\tif (lastCompleteNode.getGrammarElement() instanceof RuleCall && containingAssignment!=null) {\n\t\t\t\t\t\tnextValidElementSet.add(containingAssignment);\n\t\t\t\t\t\tnextValidElementSet.addAll(ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnextValidElementSet = ParseTreeUtil.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t\t\tnextValidElementSet.add((AbstractElement) lastCompleteNode.getGrammarElement());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnextValidElementSet = ParseTreeUtil\n\t\t\t\t\t\t\t.getElementSetValidFromOffset(rootNode, lastCompleteNode, offset);\n\t\t\t\t}\n\n\t\t\t\tProposalProviderInvokerSwitch proposalProviderInvokerSwitch = new ProposalProviderInvokerSwitch(model,\n\t\t\t\t\t\tdocument, offset, prefix, proposalProvider);\n\n\t\t\t\tfor (List<EObject> resolvedElementOrRuleList : new ProposalCandidateResolverSwitch(nextValidElementSet)) {\n\n\t\t\t\t\tList<ICompletionProposal> collectedCompletionProposalList = proposalProviderInvokerSwitch\n\t\t\t\t\t\t\t.collectCompletionProposalList(resolvedElementOrRuleList);\n\n\t\t\t\t\tcompletionProposalList.addAll(collectedCompletionProposalList);\n\t\t\t\t}\n\t\t\t\tif (completionProposalList != null) {\n\t\t\t\t\tList<? extends ICompletionProposal> processedCompletionProposalList = proposalProvider\n\t\t\t\t\t\t\t.sortAndFilter(completionProposalList, model, prefix, document, offset);\n\t\t\t\t\tcompletionProposals = processedCompletionProposalList.toArray(new ICompletionProposal[] {});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn completionProposals;\n\t}","commit_id":"baf15411ca9eda7664ed4fbe73bea36b34b79ec4","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testComputeCompletionProposalsCount() throws Exception {\r\n\t\t\r\n\t\tMap<String, Integer> model2ExpectedProposalCountMap = new HashMap<String, Integer>();\r\n\t\tStringBuilder modelBuilder = new StringBuilder(\"\");\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.toString(), 1);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"spielplatz \").toString(), 2);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"1 \").toString(), 3);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"\\\"JUNIT\\\" \").toString(), 1);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"{ \").toString(), 5);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"kind \").toString(), 1);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"(k1 0) erwachsener(e1 0) erwachsener(e2 0) familie( f1 \").toString(),2);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"e1 \").toString(),2);\r\n\t\tmodel2ExpectedProposalCountMap.put(modelBuilder.append(\"e2 \").toString(),1);\r\n\r\n\t\tfor (Iterator<String> iterator = model2ExpectedProposalCountMap.keySet()\r\n\t\t\t\t.iterator(); iterator.hasNext();) {\r\n\r\n\t\t\tString testDslModel = iterator.next();\r\n\t\t\t\r\n\t\t\tint expectedProposalCount = model2ExpectedProposalCountMap.get(testDslModel);\r\n\r\n\t\t\tCompositeNode rootNode = getRootNode(testDslModel);\r\n\t\t\t\r\n\t\t\treset(textViewerMock,xtextDocumentMock,textViewerMock);\r\n\t\t\t\r\n\t\t\texpect(textViewerMock.getDocument()).andReturn(xtextDocumentMock);\r\n\t\t\texpect(xtextDocumentMock.readOnly((UnitOfWork<CompositeNode>) anyObject())).andReturn(rootNode);\r\n\t\t\texpect(textViewerMock.getTextWidget()).andReturn(newStyledTextWidgetMock(testDslModel));\r\n\t\t\t\r\n\t\t\treplay(textViewerMock,xtextDocumentMock);\r\n\r\n\t\t\tICompletionProposal[] computeCompletionProposals = defaultContentAssistProcessor\r\n\t\t\t\t\t.computeCompletionProposals(textViewerMock, testDslModel\r\n\t\t\t\t\t\t\t.length());\r\n\t\t\t\r\n\t\t\tassertEquals(\"expect only \" + expectedProposalCount+ \" CompletionProposal item for model '\" + testDslModel+ \"'\", \r\n\t\t\t\t\texpectedProposalCount,\r\n\t\t\t\t\tcomputeCompletionProposals.length);\r\n\t\t}\r\n\r\n\t}","id":90066,"modified_method":"public void testComputeCompletionProposalsCount() throws Exception {\r\n\t\tcontentAssistProcessorTestBuilder.assertCount(1)\r\n\t\t\t.append(\"spielplatz \").assertCount(2)\r\n\t\t\t.append(\"1 \").assertCount(3)\r\n\t\t\t.append(\"\\\"JUNIT\\\" \").assertCount(1)\r\n\t\t\t.append(\"{ \").assertCount(5)\r\n\t\t\t.append(\"kind \").assertCount(1)\r\n\t\t\t.append(\"(k1 0) erwachsener(e1 0) erwachsener(e2 0) familie( f1 \").assertCount(2)\r\n\t\t\t.append(\"e1 \").assertCount(2)\r\n\t\t\t.append(\"e2\").assertCount(1);\r\n\t}","commit_id":"baf15411ca9eda7664ed4fbe73bea36b34b79ec4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\r\n\tprotected void setUp() throws Exception {\r\n\t\tsuper.setUp();\r\n\t\twithUi(ReferenceGrammarStandaloneSetup.class,ReferenceGrammarUiConfig.class);\r\n\t\ttextViewerMock = createMock(ITextViewer.class);\r\n\t\txtextDocumentMock = createMock(IXtextDocument.class);\r\n\t\tdefaultContentAssistProcessor = new DefaultContentAssistProcessor();\r\n\t\tServiceRegistry.injectServices(getCurrentServiceScope(), defaultContentAssistProcessor);\r\n\t}","id":90067,"modified_method":"@Override\r\n\tprotected void setUp() throws Exception {\r\n\t\tsuper.setUp();\r\n\t\twithUi(ReferenceGrammarStandaloneSetup.class,ReferenceGrammarUiConfig.class);\r\n\t\tcontentAssistProcessorTestBuilder = new ContentAssistProcessorTestBuilder(getCurrentServiceScope(),new DefaultContentAssistProcessor());\r\n\t}","commit_id":"baf15411ca9eda7664ed4fbe73bea36b34b79ec4","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testComputeCompletionProposalsText() throws Exception {\r\n\t\t\r\n\t\tMap<String, List<String>> model2ExpectedProposalTextMap = new HashMap<String, List<String>>();\r\n\t\tStringBuilder modelBuilder = new StringBuilder(\"\");\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.toString(), Arrays.asList(\"spielplatz \"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"spielplatz \").toString(), Arrays.asList(\"0\",\"1\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"1 \").toString(), Arrays.asList(\"\\\"SpielplatzBeschreibungSTRING\\\"\",\"\\\"SpielplatzBeschreibung\\\"\",\"{\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"\\\"SpielplatzBeschreibung\\\" \").toString(), Arrays.asList(\"{\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"{ \").toString(), Arrays.asList(\"erwachsener \",\"familie \",\"spielzeug \",\"kind \",\"}\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"erwachsener \").toString(), Arrays.asList(\"(\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"( \").toString(), Arrays.asList(\"ErwachsenerNameID\",\"ErwachsenerName\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"e1 \").toString(), Arrays.asList(\"0\",\"1\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"0 \").toString(), Arrays.asList(\")\"));\r\n\t\tmodelBuilder.append(\")\").append(\"erwachsener (e2 0)\");\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"kind \").toString(), Arrays.asList(\"(\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"( \").toString(), Arrays.asList(\"KindNameID\",\"KindName\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"k1 \").toString(), Arrays.asList(\"0\",\"1\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"0 \").toString(), Arrays.asList(\")\"));\r\n\t\tmodelBuilder.append(\")\").append(\"kind (k2 0)\");\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"familie \").toString(), Arrays.asList(\"(\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"( \").toString(), Arrays.asList(\"keyword \",\"\\\"FamilieNameSTRING\\\"\",\"FamilieNameID\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"keyword \").toString(), Arrays.asList(\"e1\",\"e2\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"e1 \").toString(), Arrays.asList(\"e1\",\"e2\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"\").toString(), Arrays.asList(\"e1\",\"e2\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"e2 \").toString(), Arrays.asList(\"k1\",\"k2\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"k\").toString(), Arrays.asList(\"k1\",\"k2\",\",\",\")\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"1 \").toString(), Arrays.asList(\",\",\")\"));\r\n\t\tmodel2ExpectedProposalTextMap.put(modelBuilder.append(\"k2 \").toString(), Arrays.asList(\",\",\")\"));\r\n\t\t\r\n\t\tfor (Iterator<String> iterator = model2ExpectedProposalTextMap.keySet()\r\n\t\t\t\t.iterator(); iterator.hasNext();) {\r\n\r\n\t\t\tString testDslModel = iterator.next();\r\n\t\t\t\r\n\t\t\tList<String> expectedTextList = model2ExpectedProposalTextMap.get(testDslModel);\r\n\r\n\t\t\tCompositeNode rootNode = getRootNode(testDslModel);\r\n\t\t\t\r\n\t\t\treset(textViewerMock,xtextDocumentMock,textViewerMock);\r\n\t\t\t\r\n\t\t\texpect(textViewerMock.getDocument()).andReturn(xtextDocumentMock);\r\n\t\t\texpect(xtextDocumentMock.readOnly((UnitOfWork<CompositeNode>) anyObject())).andReturn(rootNode);\r\n\t\t\texpect(textViewerMock.getTextWidget()).andReturn(newStyledTextWidgetMock(testDslModel));\r\n\t\t\t\r\n\t\t\treplay(textViewerMock,xtextDocumentMock);\r\n\r\n\t\t\tICompletionProposal[] computeCompletionProposals = defaultContentAssistProcessor\r\n\t\t\t\t\t.computeCompletionProposals(textViewerMock, testDslModel\r\n\t\t\t\t\t\t\t.length());\r\n\t\t\t\r\n\t\t\tassertEquals(\"expect only \" + expectedTextList.size()+ \" CompletionProposal item for model '\" + testDslModel+ \"'\", \r\n\t\t\t\t\texpectedTextList.size(),\r\n\t\t\t\t\tcomputeCompletionProposals.length);\r\n\t\t\t\r\n\t\t\tfor (int i = 0; i < computeCompletionProposals.length; i++) {\r\n\t\t\t\tICompletionProposal completionProposal = computeCompletionProposals[i];\r\n\t\t\t\tassertTrue(\"expect completionProposal text '\"+completionProposal+\"' \", expectedTextList.contains(completionProposal.getDisplayString()));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t\r\n\t\t}\r\n\r\n\t}","id":90068,"modified_method":"public void testComputeCompletionProposalsText() throws Exception {\r\n\t\tcontentAssistProcessorTestBuilder.assertText(\"spielplatz \")\r\n\t\t\t.applyText().assertText(\"0\",\"1\")\r\n\t\t\t.applyText().assertText(\"\\\"SpielplatzBeschreibungSTRING\\\"\",\"\\\"SpielplatzBeschreibung\\\"\",\"{\")\r\n\t\t\t.applyText().assertText(\"{\")\r\n\t\t\t.applyText().assertText(\"erwachsener \",\"familie \",\"spielzeug \",\"kind \",\"}\")\r\n\t\t\t.append(\"erwachsener \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"ErwachsenerNameID\",\"ErwachsenerName\")\r\n\t\t\t.append(\"e1 \").assertText(\"0\",\"1\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"erwachsener (e2 0) kind \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"KindNameID\",\"KindName\")\r\n\t\t\t.append(\"k1 \").assertText(\"0\",\"1\")\r\n\t\t\t.applyText().assertText(\")\")\r\n\t\t\t.applyText().append(\"kind (k2 0) familie \").assertText(\"(\")\r\n\t\t\t.applyText().assertText(\"keyword \",\"\\\"FamilieNameSTRING\\\"\",\"FamilieNameID\")\r\n\t\t\t.append(\"keyword \").assertText(\"e1\",\"e2\")\r\n\t\t\t.applyText().assertText(\"e1\",\"e2\")\r\n\t\t\t.append(\"e2 \").assertText(\"k1\",\"k2\")\r\n\t\t\t.append(\"k\").assertText(\"k1\",\"k2\",\",\",\")\")\r\n\t\t\t.append(\"1 \").assertText(\",\",\")\")\r\n\t\t\t.append(\"k2 \").assertText(\",\",\")\")\r\n\t\t;\r\n\t\t\r\n\t\t\r\n\t}","commit_id":"baf15411ca9eda7664ed4fbe73bea36b34b79ec4","url":"https://github.com/eclipse/xtext"},{"original_method":"public void apply(ITextViewer viewer, char trigger, int stateMask,\n\t\t\tint offset) {\n\n\t\ttry {\n\t\t\t\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tif (model != null) {\n\t\t\t\tCompositeNode parserNode = NodeUtil.getRootNode(model);\n\t\t\t\t\n\t\t\t\tLeafNode currentLeafNode=ParseTreeUtil.getCurrentNodeByOffset(parserNode, offset);\n\t\t\t\t\n\t\t\t\tboolean isCursorAtTheEndOfTheLastElement = offset == (currentLeafNode.getTotalOffset() + currentLeafNode\n\t\t\t\t\t\t.getTotalLength());\n\t\t\t\t\n\t\t\t\tif ((currentLeafNode.isHidden() && !\"\".equals(currentLeafNode.getText().trim()))\n\t\t\t\t\t\t|| isCursorAtTheEndOfTheLastElement) {\n\t\t\t\t\tif (getDisplayString().startsWith(currentLeafNode.getText())) {\n\t\t\t\t\t\tsetText(getText().substring(currentLeafNode.getText().length()));\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (!currentLeafNode.isHidden() && \n\t\t\t\t\t\tisCursorAtTheEndOfTheLastElement && \n\t\t\t\t\t\tgetDisplayString().equalsIgnoreCase(getText())) {\n\n\t\t\t\t\tif (currentLeafNode.getGrammarElement() instanceof CrossReference\n\t\t\t\t\t\t\t&& abstractElement instanceof CrossReference) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (currentLeafNode.getGrammarElement() instanceof RuleCall\n\t\t\t\t\t\t\t&& currentLeafNode.getGrammarElement().eContainer() instanceof Assignment\n\t\t\t\t\t\t\t&& abstractElement instanceof Assignment) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (!GrammarUtil.containingParserRule(abstractElement).equals(GrammarUtil.containingParserRule(currentLeafNode.getGrammarElement()))) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tdocument.replace(this.offset, offset != this.offset ? offset\n\t\t\t\t\t- this.offset : 0, getText());\n\n\t\t} catch (BadLocationException e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}","id":90069,"modified_method":"public void apply(ITextViewer viewer, char trigger, int stateMask,\n\t\t\tint offset) {\n\n\t\ttry {\n\t\t\t\n\t\t\tIDocument document = viewer.getDocument();\n\t\t\t\n\t\t\tint offsetToApply = this.offset;\n\n\t\t\tif (model != null) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tCompositeNode parserNode = NodeUtil.getRootNode(model);\n\t\t\t\t\n\t\t\t\tLeafNode currentLeafNode=ParseTreeUtil.getCurrentNodeByOffset(parserNode, offset);\n\t\t\t\t\n\t\t\t\tboolean isCursorAtTheEndOfTheLastElement = offset == (currentLeafNode.getTotalOffset() + currentLeafNode\n\t\t\t\t\t\t.getTotalLength());\n\t\t\t\t\n\t\t\t\tif ((currentLeafNode.isHidden() && !\"\".equals(currentLeafNode.getText().trim()))\n\t\t\t\t\t\t|| isCursorAtTheEndOfTheLastElement) {\n\t\t\t\t\tif (getDisplayString().toUpperCase().startsWith(currentLeafNode.getText().toUpperCase())) {\n\t\t\t\t\t\toffsetToApply-=currentLeafNode.getText().trim().length();\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (!currentLeafNode.isHidden() && \n\t\t\t\t\t\tisCursorAtTheEndOfTheLastElement && \n\t\t\t\t\t\toffsetToApply==offset) {\n\n\t\t\t\t\tif (currentLeafNode.getGrammarElement() instanceof CrossReference\n\t\t\t\t\t\t\t&& abstractElement instanceof CrossReference) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (currentLeafNode.getGrammarElement() instanceof RuleCall\n\t\t\t\t\t\t\t&& currentLeafNode.getGrammarElement().eContainer() instanceof Assignment\n\t\t\t\t\t\t\t&& abstractElement instanceof Assignment) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\t\t\t\t\telse if (!GrammarUtil.containingParserRule(abstractElement).equals(GrammarUtil.containingParserRule(currentLeafNode.getGrammarElement()))) {\n\t\t\t\t\t\tsetText(\" \" + getText());\n\t\t\t\t\t}\n\n\t\t\t\t}\t\n\t\t\t}\n\t\t\t\n\t\t\tdocument.replace(offsetToApply, offset != offsetToApply ? offset\n\t\t\t\t\t- offsetToApply : 0, getText());\n\n\t\t} catch (BadLocationException e) {\n\t\t\tlogger.error(e);\n\t\t}\n\t}","commit_id":"baf15411ca9eda7664ed4fbe73bea36b34b79ec4","url":"https://github.com/eclipse/xtext"},{"original_method":"private List<String> getNodeSequence(EObject model) {\n\t\tList<String> result = Lists.newArrayList();\n\t\tGrammarElementTitleSwitch titleSwitch = new GrammarElementTitleSwitch().showAssignments();\n\t\tEmitterNodeIterator ni = new EmitterNodeIterator(NodeModelUtils.findActualNodeFor(model));\n\t\twhile (ni.hasNext()) {\n\t\t\tINode next = ni.next();\n\t\t\tif (next instanceof ILeafNode)\n\t\t\t\tresult.add(titleSwitch.doSwitch(next.getGrammarElement()) + \" -> \" + next.getText());\n\t\t\tif (next instanceof ICompositeNode)\n\t\t\t\tresult.add(titleSwitch.doSwitch(next.getGrammarElement()));\n\t\t}\n\t\treturn result;\n\t}","id":90070,"modified_method":"private List<String> getNodeSequence(EObject model) {\n\t\tList<String> result = Lists.newArrayList();\n\t\tGrammarElementTitleSwitch titleSwitch = new GrammarElementTitleSwitch().showAssignments();\n\t\tEmitterNodeIterator ni = new EmitterNodeIterator(NodeModelUtils.findActualNodeFor(model));\n\t\twhile (ni.hasNext()) {\n\t\t\tINode next = ni.next();\n\t\t\tEObject ele = next.getGrammarElement() instanceof CrossReference ? ((CrossReference) next\n\t\t\t\t\t.getGrammarElement()).getTerminal() : next.getGrammarElement();\n\t\t\tif (next instanceof ILeafNode || GrammarUtil.isDatatypeRuleCall(ele))\n\t\t\t\tresult.add(titleSwitch.doSwitch(ele) + \" -> \" + next.getText().trim());\n\t\t\telse if (next instanceof ICompositeNode)\n\t\t\t\tresult.add(titleSwitch.doSwitch(ele));\n\t\t}\n\t\treturn result;\n\t}","commit_id":"accb7285b39d188818531e62bf1b2ec2aa8ef3a1","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testMandatoryKeywords() throws Exception {\n\t\tList<IConstraintContext> ctxts = get(IGrammarConstraintProvider.class).getConstraints(\n\t\t\t\tgetGrammarAccess().getGrammar());\n\t\tList<String> result = Lists.newArrayList();\n\t\tSet<IConstraint> visited = Sets.newHashSet();\n\t\tfor (IConstraintContext ctx : ctxts) {\n\t\t\tresult.add(ctx.toString());\n\t\t\tfor (IConstraint c : ctx.getConstraints())\n\t\t\t\tif (visited.add(c))\n\t\t\t\t\tresult.add(\"  \" + c.toString());\n\t\t}\n\t\t//\t\tSystem.out.println(Joiner.on(\"\\n\").join(result));\n\n\t\t//\t\tSyntacticSequencerPDA2ExtendedDot.drawGrammar(get(ISyntacticSequencerPDAProvider.class),\n\t\t//\t\t\t\t\"pdf/syntacticSequencerTest-PDA.pdf\", get(IGrammarAccess.class).getGrammar());\n\t\t//\t\tnew SequenceParserPDA2Dot(get(ISyntacticSequencerPDAProvider.class)).draw(get(IGrammarAccess.class)\n\t\t//\t\t\t\t.getGrammar(), \"pdf/syntacticSequencerTest-PDA.pdf\", \"-T pdf\");\n\n\t\ttestSequence(\"#1 a kw1 b kw2 kw3 c kw4\");\n\t}","id":90071,"modified_method":"public void testMandatoryKeywords() throws Exception {\n\t\ttestSequence(\"#1 a kw1 b kw2 kw3 c kw4\");\n\t}","commit_id":"accb7285b39d188818531e62bf1b2ec2aa8ef3a1","url":"https://github.com/eclipse/xtext"},{"original_method":"private void testSequence(String stringModel) throws Exception {\n\t\tEObject model = getModel(stringModel);\n\t\tEObject context = nmSequencer.findContexts(model, true, null).iterator().next();\n\t\tDebugSequenceAcceptor actual = new NoEnterNodesDebugSequenceAcceptor(false);\n\t\tISemanticSequencer semanticSequencer = semanticSequencerProvider.get();\n\t\tISyntacticSequencer syntacticSequencer = syntacticSequencerProvider.get();\n\t\tsemanticSequencer\n\t\t\t\t.init((ISemanticSequenceAcceptor) syntacticSequencer, ISerializationDiagnostic.STDERR_ACCEPTOR);\n\t\tsyntacticSequencer.init(context, model, actual, ISerializationDiagnostic.STDERR_ACCEPTOR);\n\t\tsemanticSequencer.createSequence(context, model);\n\n\t\t//\t\t((IHiddenTokenSequencerOwner) recSequencer).setHiddenTokenSequencer(get(PassThroughHiddenTokenSequencer.class));\n\t\t//\t\trecSequencer.createSequence(context, model, actual, ISerializationDiagnostic.STDERR_ACCEPTOR);\n\t\t//\t\tSystem.out.println(actual);\n\t\t//\t\tSystem.out.println(NodeModelUtils.compactDump(NodeModelUtils.findActualNodeFor(model), false));\n\t\tassertEquals(Joiner.on(\"\\n\").join(getNodeSequence(model)), Joiner.on(\"\\n\").join(actual.getColumn(4)));\n\t}","id":90072,"modified_method":"private void testSequence(String stringModel) throws Exception {\n\t\tEObject model = getModel(stringModel);\n\t\tEObject context = nmSequencer.findContexts(model, true, null).iterator().next();\n\t\tAcceptor actual = new Acceptor();\n\t\tISemanticSequencer semanticSeq = semanticSequencerProvider.get();\n\t\tISyntacticSequencer syntacticSeq = syntacticSequencerProvider.get();\n\t\tsemanticSeq.init((ISemanticSequenceAcceptor) syntacticSeq, ISerializationDiagnostic.STDERR_ACCEPTOR);\n\t\tsyntacticSeq.init(context, model, actual, ISerializationDiagnostic.STDERR_ACCEPTOR);\n\t\tsemanticSeq.createSequence(context, model);\n\t\tassertEquals(Joiner.on(\"\\n\").join(getNodeSequence(model)), Joiner.on(\"\\n\").join(actual.getResult()));\n\t}","commit_id":"accb7285b39d188818531e62bf1b2ec2aa8ef3a1","url":"https://github.com/eclipse/xtext"},{"original_method":"public String elementAliasToConstructor(AbstractElementAlias alias, JavaFile file) {\n\t\tString many = String.valueOf(alias.isMany());\n\t\tString optional = String.valueOf(alias.isOptional());\n\t\t//\t\tString absEle = file.imported(AbstractElement.class);\n\t\tif (alias instanceof TokenAlias) {\n\t\t\tTokenAlias ele = (TokenAlias) alias;\n\t\t\tString eleAlias = file.imported(TokenAlias.class);\n\t\t\tString eleAcc = \"grammarAccess.\" + grammarAccess.gaAccessor(ele.getToken());\n\t\t\treturn \"new \" + eleAlias + \"(\" + optional + \", \" + many + \", \" + eleAcc + \")\";\n\t\t} else if (alias instanceof GroupAlias) {\n\t\t\tList<String> children = Lists.newArrayList();\n\t\t\tfor (AbstractElementAlias child : ((GroupAlias) alias).getChildren())\n\t\t\t\tchildren.add(elementAliasToConstructor(child, file));\n\t\t\tString body = Join.join(\", \", children);\n\t\t\tString grpAlias = file.imported(GroupAlias.class);\n\t\t\treturn \"new \" + grpAlias + \"(\" + optional + \", \" + many + \", \" + body + \")\";\n\t\t} else if (alias instanceof AlternativeAlias) {\n\t\t\tList<String> children = Lists.newArrayList();\n\t\t\tfor (AbstractElementAlias child : ((AlternativeAlias) alias).getChildren())\n\t\t\t\tchildren.add(elementAliasToConstructor(child, file));\n\t\t\tCollections.sort(children);\n\t\t\tString body = Join.join(\", \", children);\n\t\t\tString altAlias = file.imported(AlternativeAlias.class);\n\t\t\treturn \"new \" + altAlias + \"(\" + optional + \", \" + many + \", \" + body + \")\";\n\t\t}\n\t\tthrow new RuntimeException(\"unknown element\");\n\t}","id":90073,"modified_method":"public String elementAliasToConstructor(AbstractElementAlias alias, JavaFile file) {\n\t\tString many = String.valueOf(alias.isMany());\n\t\tString optional = String.valueOf(alias.isOptional());\n\t\t//\t\tString absEle = file.imported(AbstractElement.class);\n\t\tif (alias instanceof TokenAlias) {\n\t\t\tTokenAlias ele = (TokenAlias) alias;\n\t\t\tString eleAlias = file.imported(TokenAlias.class);\n\t\t\tString eleAcc = \"grammarAccess.\" + grammarAccess.gaAccessor(ele.getToken());\n\t\t\treturn \"new \" + eleAlias + \"(\" + many + \", \" + optional + \", \" + eleAcc + \")\";\n\t\t} else if (alias instanceof GroupAlias) {\n\t\t\tList<String> children = Lists.newArrayList();\n\t\t\tfor (AbstractElementAlias child : ((GroupAlias) alias).getChildren())\n\t\t\t\tchildren.add(elementAliasToConstructor(child, file));\n\t\t\tString body = Join.join(\", \", children);\n\t\t\tString grpAlias = file.imported(GroupAlias.class);\n\t\t\treturn \"new \" + grpAlias + \"(\" + many + \", \" + optional + \", \" + body + \")\";\n\t\t} else if (alias instanceof AlternativeAlias) {\n\t\t\tList<String> children = Lists.newArrayList();\n\t\t\tfor (AbstractElementAlias child : ((AlternativeAlias) alias).getChildren())\n\t\t\t\tchildren.add(elementAliasToConstructor(child, file));\n\t\t\tCollections.sort(children);\n\t\t\tString body = Join.join(\", \", children);\n\t\t\tString altAlias = file.imported(AlternativeAlias.class);\n\t\t\treturn \"new \" + altAlias + \"(\" + many + \", \" + optional + \", \" + body + \")\";\n\t\t}\n\t\tthrow new RuntimeException(\"unknown element\");\n\t}","commit_id":"accb7285b39d188818531e62bf1b2ec2aa8ef3a1","url":"https://github.com/eclipse/xtext"},{"original_method":"public void editRoot(@NotNull Project project, @NotNull SNodeId rootId, @NotNull SModel model) {\n    SNode root = model.getNodeById(rootId);\n    if (SNodeOperations.getParent(root) == null) {\n      getMainEditor().editNode(root, DiffTemporaryModule.getOperationContext(project, model));\n    }\n  }","id":90074,"modified_method":"public void editRoot(@NotNull Project project, @Nullable SNodeId rootId, @NotNull SModel model) {\n    SNode root = (rootId == null ?\n      null :\n      model.getNodeById(rootId)\n    );\n    if (SNodeOperations.getParent(root) == null) {\n      getMainEditor().editNode(root, DiffTemporaryModule.getOperationContext(project, model));\n    }\n  }","commit_id":"faae532188318c66a96e8e2c4673f9cb2fa3b009","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doubleClick() {\n      SNodeId id = myChange.getAffectedNodeId();\n      if (myChange instanceof NewNodeChange && ((NewNodeChange) myChange).getNodeParent() != null) {\n        NewNodeChange anc = (NewNodeChange) myChange;\n        id = anc.getNodeParent();\n      }\n      SNode node = myMerger.getResultModel().getNodeById(id);\n      if (node != null) {\n        TreeNode tn = myResultTree.findNodeWith(node);\n        myResultTree.selectNode(tn);\n      }\n    }","id":90075,"modified_method":"public void doubleClick() {\n      SNodeId id = myChange.getAffectedNodeId();\n      if (myChange instanceof NewNodeChange && ((NewNodeChange) myChange).getNodeParent() != null) {\n        NewNodeChange anc = (NewNodeChange) myChange;\n        id = anc.getNodeParent();\n      }\n      SNode node = (id == null ?\n        null :\n        myMerger.getResultModel().getNodeById(id)\n      );\n      if (node != null) {\n        TreeNode tn = myResultTree.findNodeWith(node);\n        myResultTree.selectNode(tn);\n      }\n    }","commit_id":"1fb0476e3ade7c0fa73ce8e6ec6569e742cce447","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean apply(SModel m) {\n    SNode node = m.getNodeById(myNodeId);\n    if (node == null) {\n      return false;\n    }\n    SNode parent = m.getNodeById(myNewParent);\n    if (parent == null) {\n      return false;\n    }\n    node.getParent().removeChild(node);\n    SNode prevSibling = m.getNodeById(myPrevSibling);\n    parent.insertChild(prevSibling, myNewRole, node);\n    return true;\n  }","id":90076,"modified_method":"public boolean apply(SModel m) {\n    SNode node = m.getNodeById(myNodeId);\n    if (node == null) {\n      return false;\n    }\n    SNode parent = m.getNodeById(myNewParent);\n    if (parent == null) {\n      return false;\n    }\n    node.getParent().removeChild(node);\n    SNode prevSibling = (myPrevSibling == null ?\n      null :\n      m.getNodeById(myPrevSibling)\n    );\n    parent.insertChild(prevSibling, myNewRole, node);\n    return true;\n  }","commit_id":"1fb0476e3ade7c0fa73ce8e6ec6569e742cce447","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void main(final String[] args) throws JDOMException, IOException {\n    IdeMain.setTestMode(TestMode.NO_TEST);\n    configureMPS();\n\n    final SModel models[] = new SModel[3];\n\n    String resultFile;\n    if (args.length == 2) {\n      try {\n        final SModel[] zipped = ModelUtils.loadZippedModels(new File(args[0]), VcsMergeVersion.values(), false);\n        models[0] = zipped[0];\n        models[1] = zipped[1];\n        models[2] = zipped[2];\n      } catch (ReadException e) {\n        return;\n      }\n\n      resultFile = args[1];\n    } else if (args.length == 4) {\n      models[0] = ModelUtils.readModel(args[0]);\n      models[1] = ModelUtils.readModel(args[1]);\n      models[2] = ModelUtils.readModel(args[2]);\n\n      resultFile = args[3];\n    } else {\n      System.err.println(\"There must be 2 or 4 parameters\");\n      return;\n    }\n\n    /*ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        LibraryManager manager = LibraryManager.getInstance();\n        MyState state = manager.getState();\n        Library webrdnq = new Library();\n        webrdnq.setName(\"webr-dnq\");\n        webrdnq.setPath(\"/media/d/devel/webr-dnq\");\n        state.getLibraries().put(webrdnq.getName(), webrdnq);\n        Library charisma = new Library();\n        charisma.setName(\"charisma\");\n        charisma.setPath(\"/media/d/devel/charisma\");\n        state.getLibraries().put(charisma.getName(), charisma);\n        manager.loadState(state);\n        manager.update();\n      }\n    });\n*/\n    final String finalResultFile = resultFile;\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        final MergeModelsDialog dialog = ModelAccess.instance().runReadAction(new Computable<MergeModelsDialog>() {\n          public MergeModelsDialog compute() {\n            IOperationContext context = new StandaloneMPSContext() {\n              @Override\n              public Project getProject() {\n                return null;\n              }\n\n              public IModule getModule() {\n                return null;\n              }\n\n              @NotNull\n              public IScope getScope() {\n                return GlobalScope.getInstance();\n              }\n\n              @Override\n              public <T> T getComponent(Class<T> clazz) {\n                if (clazz == EditorManager.class) {\n                  return (T) ourEditorManager;\n                }\n                return null;\n              }\n            };\n\n            return new MergeModelsDialog(context, models[0], models[1], models[2]);\n          }\n        });\n        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        dialog.showDialog();\n\n        final SModel result = dialog.getResultModel();\n        if (result == null) {\n          dialog.dispose();\n          System.exit(0);\n        }\n        ModelAccess.instance().runReadAction(new Runnable() {\n          public void run() {\n            IFile iFile = FileSystem.getInstance().getFileByPath(finalResultFile);\n            if (!iFile.exists()) iFile.createNewFile();\n            ModelPersistence.saveModel(result, iFile, true, result.getPersistenceVersion());\n          }\n        });\n        dialog.dispose();\n        System.exit(0);\n      }\n    });\n  }","id":90077,"modified_method":"public static void main(final String[] args) throws JDOMException, IOException {\n    IdeMain.setTestMode(TestMode.NO_TEST);\n    configureMPS();\n\n    final SModel models[] = new SModel[3];\n\n    String resultFile;\n    if (args.length == 2) {\n      try {\n        final SModel[] zipped = ModelUtils.loadZippedModels(new File(args[0]), VcsMergeVersion.values(), false);\n        models[0] = zipped[0];\n        models[1] = zipped[1];\n        models[2] = zipped[2];\n      } catch (ReadException e) {\n        return;\n      }\n\n      resultFile = args[1];\n    } else if (args.length == 4) {\n      models[0] = ModelUtils.readModel(args[0]);\n      models[1] = ModelUtils.readModel(args[1]);\n      models[2] = ModelUtils.readModel(args[2]);\n\n      resultFile = args[3];\n    } else {\n      System.err.println(\"There must be 2 or 4 parameters\");\n      return;\n    }\n\n    /*ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        LibraryManager manager = LibraryManager.getInstance();\n        MyState state = manager.getState();\n        Library webrdnq = new Library();\n        webrdnq.setName(\"webr-dnq\");\n        webrdnq.setPath(\"/media/d/devel/webr-dnq\");\n        state.getLibraries().put(webrdnq.getName(), webrdnq);\n        Library charisma = new Library();\n        charisma.setName(\"charisma\");\n        charisma.setPath(\"/media/d/devel/charisma\");\n        state.getLibraries().put(charisma.getName(), charisma);\n        manager.loadState(state);\n        manager.update();\n      }\n    });\n*/\n    final String finalResultFile = resultFile;\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        final MergeModelsDialog dialog = ModelAccess.instance().runReadAction(new Computable<MergeModelsDialog>() {\n          public MergeModelsDialog compute() {\n            IOperationContext context = new StandaloneMPSContext() {\n              @Override\n              public Project getProject() {\n                return null;\n              }\n\n              public IModule getModule() {\n                return null;\n              }\n\n              @NotNull\n              public IScope getScope() {\n                return GlobalScope.getInstance();\n              }\n\n              @Override\n              public <T> T getComponent(Class<T> clazz) {\n                if (clazz == EditorManager.class) {\n                  return (T) ourEditorManager;\n                }\n                return null;\n              }\n            };\n\n            return new MergeModelsDialog(context, models[0], models[1], models[2]);\n          }\n        });\n        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        dialog.showDialog();\n\n        final SModel result = dialog.getResultModel();\n        if (result == null) {\n          dialog.dispose();\n          System.exit(0);\n        }\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          public void run() {\n            IFile iFile = FileSystem.getInstance().getFileByPath(finalResultFile);\n            if (!iFile.exists()) iFile.createNewFile();\n            ModelPersistence.saveModel(result, iFile, true, result.getPersistenceVersion());\n          }\n        });\n        dialog.dispose();\n        System.exit(0);\n      }\n    });\n  }","commit_id":"1fb0476e3ade7c0fa73ce8e6ec6569e742cce447","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void removeRootInfoForChange(@NotNull Change change) {\n    myCommandQueue.assertSoftlyIsCommandThread();\n    SNodeId rootId = MapSequence.fromMap(myRootForChange).get(change);\n    if (rootId != null && MapSequence.fromMap(myChangesCountsForRoots).containsKey(rootId)) {\n      MapSequence.fromMap(myChangesCountsForRoots).put(rootId, MapSequence.fromMap(myChangesCountsForRoots).get(rootId) - 1);\n    }\n    MapSequence.fromMap(myRootForChange).removeKey(change);\n    fileStatusChangedForRootNode(getModel().getNodeById(rootId));\n  }","id":90078,"modified_method":"private void removeRootInfoForChange(@NotNull Change change) {\n    myCommandQueue.assertSoftlyIsCommandThread();\n    SNodeId rootId = MapSequence.fromMap(myRootForChange).get(change);\n    if (rootId != null && MapSequence.fromMap(myChangesCountsForRoots).containsKey(rootId)) {\n      MapSequence.fromMap(myChangesCountsForRoots).put(rootId, MapSequence.fromMap(myChangesCountsForRoots).get(rootId) - 1);\n    }\n    MapSequence.fromMap(myRootForChange).removeKey(change);\n    fileStatusChangedForRootNode((rootId == null ?\n      null :\n      getModel().getNodeById(rootId)\n    ));\n  }","commit_id":"441393432f07c17eb8063e483f23e7c0a77a70dd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void renameElement(final PsiElement psiElement,\n                            final String newName,\n                            final UsageInfo[] usages,\n                            final RefactoringElementListener listener) throws IncorrectOperationException {\n\n    final GrField field = (GrField)psiElement;\n    final PsiMethod getter = GroovyPropertyUtils.findGetterForField(field);\n    final PsiMethod setter = GroovyPropertyUtils.findSetterForField(field);\n    final String newGetterName = (getter != null && getter.getName().startsWith(\"is\") ? \"is\" : \"get\") + StringUtil.capitalize(newName);\n    final String newSetterName = \"set\" + StringUtil.capitalize(newName);\n\n    final PsiManager manager = field.getManager();\n\n    List<PsiReference> getterRefs = new ArrayList<PsiReference>();\n    List<PsiReference> setterRefs = new ArrayList<PsiReference>();\n    List<PsiReference> fieldRefs = new ArrayList<PsiReference>();\n\n    for (UsageInfo usage : usages) {\n      final PsiElement element = usage.getElement();\n      if (element == null) continue;\n\n      PsiReference ref = element.getReference();\n      if (ref == null) continue;\n\n      PsiElement resolved = ref.resolve();\n      if (manager.areElementsEquivalent(resolved, getter)) {\n        getterRefs.add(ref);\n      }\n      else if (manager.areElementsEquivalent(resolved, setter)) {\n        setterRefs.add(ref);\n      }\n      else if (manager.areElementsEquivalent(resolved, field)) {\n        fieldRefs.add(ref);\n      }\n      else {\n        ref.handleElementRename(newName);\n      }\n    }\n\n    field.setName(newName);\n\n    final PsiMethod newGetter = GroovyPropertyUtils.findGetterForField(field);\n    for (PsiReference ref : getterRefs) {\n      rename(ref, newGetterName, manager, newGetter);\n    }\n\n    final PsiMethod newSetter = GroovyPropertyUtils.findSetterForField(field);\n    for (PsiReference ref : setterRefs) {\n      rename(ref, newSetterName, manager, newSetter);\n    }\n\n    for (PsiReference ref : fieldRefs) {\n      rename(ref, newName, manager, field);\n    }\n\n    listener.elementRenamed(field);\n  }","id":90079,"modified_method":"@Override\n  public void renameElement(final PsiElement psiElement,\n                            final String newName,\n                            final UsageInfo[] usages,\n                            final RefactoringElementListener listener) throws IncorrectOperationException {\n\n    final GrField field = (GrField)psiElement;\n    final PsiMethod getter = GroovyPropertyUtils.findGetterForField(field);\n    final PsiMethod setter = GroovyPropertyUtils.findSetterForField(field);\n    final String newGetterName = (getter != null && getter.getName().startsWith(\"is\") ? \"is\" : \"get\") + StringUtil.capitalize(newName);\n    final String newSetterName = \"set\" + StringUtil.capitalize(newName);\n\n    final PsiManager manager = field.getManager();\n\n    List<PsiReference> getterRefs = new ArrayList<PsiReference>();\n    List<PsiReference> setterRefs = new ArrayList<PsiReference>();\n    List<PsiReference> fieldRefs = new ArrayList<PsiReference>();\n\n    for (UsageInfo usage : usages) {\n      final PsiElement element = usage.getElement();\n      if (element == null) continue;\n\n      PsiReference ref = element.getReference();\n      if (ref == null) continue;\n\n      PsiElement resolved = ref.resolve();\n      if (manager.areElementsEquivalent(resolved, getter)) {\n        if (isPropertyAccess(element)) {\n          fieldRefs.add(ref);\n        }\n        else {\n          getterRefs.add(ref);\n        }\n      }\n      else if (manager.areElementsEquivalent(resolved, setter)) {\n        if (isPropertyAccess(element)) {\n          fieldRefs.add(ref);\n        }\n        else {\n          setterRefs.add(ref);\n        }\n      }\n      else if (manager.areElementsEquivalent(resolved, field)) {\n        fieldRefs.add(ref);\n      }\n      else {\n        ref.handleElementRename(newName);\n      }\n    }\n\n    field.setName(newName);\n\n    final PsiMethod newGetter = GroovyPropertyUtils.findGetterForField(field);\n    doRename(newGetterName, manager, getterRefs, newGetter);\n\n    final PsiMethod newSetter = GroovyPropertyUtils.findSetterForField(field);\n    doRename(newSetterName, manager, setterRefs, newSetter);\n\n    doRename(newName, manager, fieldRefs, field);\n\n    listener.elementRenamed(field);\n  }","commit_id":"fd7980e9674bdb6effdac79e494142ba6d9df4cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Collection<PsiReference> findReferences(final PsiElement element) {\n    ArrayList<PsiReference> refs = new ArrayList<PsiReference>();\n    if (element instanceof GrField) {\n      GrField field = (GrField)element;\n      PsiMethod setter = GroovyPropertyUtils.findSetterForField(field);\n      GlobalSearchScope projectScope = GlobalSearchScope.projectScope(element.getProject());\n      if (setter != null && setter instanceof GrAccessorMethod) {\n        refs.addAll(MethodReferencesSearch.search(setter, projectScope, true).findAll());\n      }\n      GrAccessorMethod[] getters = field.getGetters();\n      for (GrAccessorMethod getter : getters) {\n        refs.addAll(MethodReferencesSearch.search(getter, projectScope, true).findAll());\n      }\n      refs.addAll(ReferencesSearch.search(field, projectScope, true).findAll());\n      return refs;\n    }\n    return super.findReferences(element);\n  }","id":90080,"modified_method":"@NotNull\n  @Override\n  public Collection<PsiReference> findReferences(final PsiElement element) {\n    if (element instanceof GrField) {\n      ArrayList<PsiReference> refs = new ArrayList<PsiReference>();\n\n      GrField field = (GrField)element;\n      PsiMethod setter = GroovyPropertyUtils.findSetterForField(field);\n      GlobalSearchScope projectScope = GlobalSearchScope.projectScope(element.getProject());\n      if (setter != null && setter instanceof GrAccessorMethod) {\n        refs.addAll(RenameAliasedUsagesUtil.filterAliasedRefs(MethodReferencesSearch.search(setter, projectScope, true).findAll(), setter));\n      }\n      GrAccessorMethod[] getters = field.getGetters();\n      for (GrAccessorMethod getter : getters) {\n        refs.addAll(RenameAliasedUsagesUtil.filterAliasedRefs(MethodReferencesSearch.search(getter, projectScope, true).findAll(), getter));\n      }\n      refs.addAll(RenameAliasedUsagesUtil.filterAliasedRefs(ReferencesSearch.search(field, projectScope, true).findAll(), field));\n      return refs;\n    }\n    return super.findReferences(element);\n  }","commit_id":"fd7980e9674bdb6effdac79e494142ba6d9df4cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void rename(PsiReference ref, String newName, PsiManager manager, PsiMember elementToResolve) {\n    final PsiElement renamed = ref.handleElementRename(newName);\n    final PsiElement newly_resolved = ref.resolve();\n    if (!manager.areElementsEquivalent(newly_resolved, elementToResolve)) {\n      qualify(elementToResolve, renamed, newName);\n    }\n  }","id":90081,"modified_method":"private static void rename(PsiReference ref,\n                             String newName,\n                             PsiManager manager,\n                             PsiMember elementToResolve) {\n    final PsiElement renamed = ref.handleElementRename(newName);\n    PsiElement newly_resolved = ref.resolve();\n    if (!manager.areElementsEquivalent(newly_resolved, elementToResolve)) {\n      if (newly_resolved instanceof PsiMethod) {\n        newly_resolved = GroovyPropertyUtils.findFieldForAccessor((PsiMethod)newly_resolved, false);\n      }\n      if (!manager.areElementsEquivalent(newly_resolved, elementToResolve)) {\n        qualify(elementToResolve, renamed, newName);\n      }\n    }\n  }","commit_id":"fd7980e9674bdb6effdac79e494142ba6d9df4cd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static URL createMavenGavURL(String artifactGav) throws MalformedURLException {\n        Artifact artifact = new DefaultArtifact(artifactGav);\n        if (artifact.getVersion() == null) {\n            throw new IllegalArgumentException(\"Null version\");\n        }\n\n        VersionScheme versionScheme = new GenericVersionScheme();\n        try {\n            versionScheme.parseVersion(artifact.getVersion());\n        } catch (InvalidVersionSpecificationException e) {\n            throw new IllegalArgumentException(e);\n        }\n\n        try {\n            versionScheme.parseVersionRange(artifact.getVersion());\n            throw new IllegalArgumentException(artifact.getVersion() + \" is a version range. A specific version is needed\");\n        } catch (InvalidVersionSpecificationException expected) {\n\n        }\n\n        RepositorySystemSession session = newRepositorySystemSession();\n        RemoteRepository central = newCentralRepository();\n        //TODO add more remote repositories - especially the JBoss one\n\n        ArtifactRequest artifactRequest = new ArtifactRequest();\n        artifactRequest.setArtifact(artifact);\n        artifactRequest.addRepository(central);\n\n        ArtifactResult artifactResult;\n        try {\n            artifactResult = REPOSITORY_SYSTEM.resolveArtifact(session, artifactRequest);\n        } catch(ArtifactResolutionException e) {\n            throw new RuntimeException(e);\n        }\n\n        File file = artifactResult.getArtifact().getFile().getAbsoluteFile();\n        System.out.println(file);\n        return file.toURI().toURL();\n    }","id":90082,"modified_method":"static URL createMavenGavURL(String artifactGav) throws MalformedURLException {\n        Artifact artifact = new DefaultArtifact(artifactGav);\n        if (artifact.getVersion() == null) {\n            throw new IllegalArgumentException(\"Null version\");\n        }\n\n        VersionScheme versionScheme = new GenericVersionScheme();\n        try {\n            versionScheme.parseVersion(artifact.getVersion());\n        } catch (InvalidVersionSpecificationException e) {\n            throw new IllegalArgumentException(e);\n        }\n\n        try {\n            versionScheme.parseVersionRange(artifact.getVersion());\n            throw new IllegalArgumentException(artifact.getVersion() + \" is a version range. A specific version is needed\");\n        } catch (InvalidVersionSpecificationException expected) {\n\n        }\n\n        RepositorySystemSession session = newRepositorySystemSession();\n        List<RemoteRepository> remoteRepositories = createRemoteRepositories();\n        //TODO add more remote repositories - especially the JBoss one\n\n        ArtifactRequest artifactRequest = new ArtifactRequest();\n        artifactRequest.setArtifact(artifact);\n        for (RemoteRepository remoteRepo : remoteRepositories){\n            artifactRequest.addRepository(remoteRepo);\n        }\n\n        ArtifactResult artifactResult;\n        try {\n            artifactResult = REPOSITORY_SYSTEM.resolveArtifact(session, artifactRequest);\n        } catch(ArtifactResolutionException e) {\n            throw new RuntimeException(e);\n        }\n\n        File file = artifactResult.getArtifact().getFile().getAbsoluteFile();\n        System.out.println(file);\n        return file.toURI().toURL();\n    }","commit_id":"cd7f62c9f785dabc8a77ff77a4975003ed91d807","url":"https://github.com/wildfly/wildfly"},{"original_method":"static List<URL> createMavenGavRecursiveURLs(String artifactGav, String... excludes) throws MalformedURLException, DependencyCollectionException, DependencyResolutionException {\n        Artifact artifact = new DefaultArtifact(artifactGav);\n        if (artifact.getVersion() == null) {\n            throw new IllegalArgumentException(\"Null version\");\n        }\n\n        VersionScheme versionScheme = new GenericVersionScheme();\n        try {\n            versionScheme.parseVersion(artifact.getVersion());\n        } catch (InvalidVersionSpecificationException e) {\n            throw new IllegalArgumentException(e);\n        }\n\n        try {\n            versionScheme.parseVersionRange(artifact.getVersion());\n            throw new IllegalArgumentException(artifact.getVersion() + \" is a version range. A specific version is needed\");\n        } catch (InvalidVersionSpecificationException expected) {\n\n        }\n\n        RepositorySystemSession session = newRepositorySystemSession();\n        RemoteRepository central = newCentralRepository();\n        //TODO add more remote repositories - especially the JBoss one\n\n        ArtifactRequest artifactRequest = new ArtifactRequest();\n        artifactRequest.setArtifact(artifact);\n        artifactRequest.addRepository(central);\n\n        ArtifactResult artifactResult;\n        try {\n            artifactResult = REPOSITORY_SYSTEM.resolveArtifact(session, artifactRequest);\n        } catch(ArtifactResolutionException e) {\n            throw new RuntimeException(e);\n        }\n\n        List<URL> urls = new ArrayList<URL>();\n        urls.add(artifactToUrl(artifactResult.getArtifact()));\n\n        CollectRequest collectRequest = new CollectRequest();\n        collectRequest.setRoot(new Dependency(artifact, \"compile\" ));\n        collectRequest.addRepository( central );\n        DependencyNode node = REPOSITORY_SYSTEM.collectDependencies( session, collectRequest ).getRoot();\n        DependencyFilter filter = new ExclusionsDependencyFilter(Arrays.asList(excludes));\n        DependencyRequest dependencyRequest = new DependencyRequest( node, filter );\n\n        REPOSITORY_SYSTEM.resolveDependencies( session, dependencyRequest  );\n\n        PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();\n        node.accept( nlg );\n        for (Artifact cur : nlg.getArtifacts(false)) {\n            urls.add(artifactToUrl(cur));\n        }\n\n        System.out.println(\"--------------------\");\n        System.out.println(nlg.getClassPath());\n        System.out.println(\"--------------------\");\n\n        return urls;\n    }","id":90083,"modified_method":"static List<URL> createMavenGavRecursiveURLs(String artifactGav, String... excludes) throws MalformedURLException, DependencyCollectionException, DependencyResolutionException {\n        Artifact artifact = new DefaultArtifact(artifactGav);\n        if (artifact.getVersion() == null) {\n            throw new IllegalArgumentException(\"Null version\");\n        }\n\n        VersionScheme versionScheme = new GenericVersionScheme();\n        try {\n            versionScheme.parseVersion(artifact.getVersion());\n        } catch (InvalidVersionSpecificationException e) {\n            throw new IllegalArgumentException(e);\n        }\n\n        try {\n            versionScheme.parseVersionRange(artifact.getVersion());\n            throw new IllegalArgumentException(artifact.getVersion() + \" is a version range. A specific version is needed\");\n        } catch (InvalidVersionSpecificationException expected) {\n\n        }\n\n        RepositorySystemSession session = newRepositorySystemSession();\n        List<RemoteRepository> remoteRepositories = createRemoteRepositories();\n        //TODO add more remote repositories - especially the JBoss one\n\n        ArtifactRequest artifactRequest = new ArtifactRequest();\n        artifactRequest.setArtifact(artifact);\n        for (RemoteRepository remoteRepo : remoteRepositories){\n            artifactRequest.addRepository(remoteRepo);\n        }\n\n        ArtifactResult artifactResult;\n        try {\n            artifactResult = REPOSITORY_SYSTEM.resolveArtifact(session, artifactRequest);\n        } catch(ArtifactResolutionException e) {\n            throw new RuntimeException(e);\n        }\n\n        List<URL> urls = new ArrayList<URL>();\n        urls.add(artifactToUrl(artifactResult.getArtifact()));\n\n        CollectRequest collectRequest = new CollectRequest();\n        collectRequest.setRoot(new Dependency(artifact, \"compile\" ));\n        for (RemoteRepository remoteRepo : remoteRepositories) {\n            collectRequest.addRepository( remoteRepo );\n        }\n        DependencyNode node = REPOSITORY_SYSTEM.collectDependencies( session, collectRequest ).getRoot();\n        DependencyFilter filter = new ExclusionsDependencyFilter(Arrays.asList(excludes));\n        DependencyRequest dependencyRequest = new DependencyRequest( node, filter );\n\n        REPOSITORY_SYSTEM.resolveDependencies( session, dependencyRequest  );\n\n        PreorderNodeListGenerator nlg = new PreorderNodeListGenerator();\n        node.accept( nlg );\n        for (Artifact cur : nlg.getArtifacts(false)) {\n            urls.add(artifactToUrl(cur));\n        }\n\n        System.out.println(\"--------------------\");\n        System.out.println(nlg.getClassPath());\n        System.out.println(\"--------------------\");\n\n        return urls;\n    }","commit_id":"cd7f62c9f785dabc8a77ff77a4975003ed91d807","url":"https://github.com/wildfly/wildfly"},{"original_method":"@NonNls\n  public static String getValueAsString(final EvaluationContext evaluationContext, Value value) throws EvaluateException {\n    try {\n      if (value == null) {\n        return \"null\";\n      }\n      if (value instanceof StringReference) {\n        return ((StringReference)value).value();\n      }\n      if (isInteger(value)) {\n        long v = ((PrimitiveValue)value).longValue();\n        return String.valueOf(v);\n      }\n      if (isNumeric(value)) {\n        double v = ((PrimitiveValue)value).doubleValue();\n        return String.valueOf(v);\n      }\n      if (value instanceof BooleanValue) {\n        boolean v = ((PrimitiveValue)value).booleanValue();\n        return String.valueOf(v);\n      }\n      if (value instanceof CharValue) {\n        char v = ((PrimitiveValue)value).charValue();\n        return String.valueOf(v);\n      }\n      if (value instanceof ObjectReference) {\n        if (value instanceof ArrayReference) {\n          final StringBuilder builder = new StringBuilder();\n          builder.append(\"[\");\n          for (Iterator<Value> iterator = ((ArrayReference)value).getValues().iterator(); iterator.hasNext();) {\n            final Value element = iterator.next();\n            builder.append(getValueAsString(evaluationContext, element));\n            if (iterator.hasNext()) {\n              builder.append(\",\");\n            }\n          }\n          builder.append(\"]\");\n          return builder.toString();\n        }\n\n        final ObjectReference objRef = (ObjectReference)value;\n        final DebugProcess debugProcess = evaluationContext.getDebugProcess();\n        Method toStringMethod = debugProcess.getUserData(TO_STRING_METHOD_KEY);\n        if (toStringMethod == null) {\n          try {\n            ReferenceType refType = objRef.virtualMachine().classesByName(CommonClassNames.JAVA_LANG_OBJECT).get(0);\n            toStringMethod = findMethod(refType, \"toString\", \"()Ljava/lang/String;\");\n            debugProcess.putUserData(TO_STRING_METHOD_KEY, toStringMethod);\n          }\n          catch (Exception ignored) {\n            throw EvaluateExceptionUtil.createEvaluateException(\n              DebuggerBundle.message(\"evaluation.error.cannot.evaluate.tostring\", objRef.referenceType().name()));\n          }\n        }\n        if (toStringMethod == null) {\n          throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.cannot.evaluate.tostring\", objRef.referenceType().name()));\n        }\n        // while result must be of com.sun.jdi.StringReference type, it turns out that sometimes (jvm bugs?)\n        // it is a plain com.sun.tools.jdi.ObjectReferenceImpl\n        final Value result = debugProcess.invokeInstanceMethod(evaluationContext, objRef, toStringMethod, Collections.emptyList(), 0);\n        if (result == null) {\n          return \"null\";\n        }\n        return result instanceof StringReference ? ((StringReference)result).value() : result.toString();\n      }\n      throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unsupported.expression.type\"));\n    }\n    catch (ObjectCollectedException ignored) {\n      throw EvaluateExceptionUtil.OBJECT_WAS_COLLECTED;\n    }\n  }","id":90084,"modified_method":"@NonNls\n  public static String getValueAsString(final EvaluationContext evaluationContext, Value value) throws EvaluateException {\n    try {\n      if (value == null) {\n        return \"null\";\n      }\n      if (value instanceof StringReference) {\n        return ((StringReference)value).value();\n      }\n      if (isInteger(value)) {\n        long v = ((PrimitiveValue)value).longValue();\n        return String.valueOf(v);\n      }\n      if (isNumeric(value)) {\n        double v = ((PrimitiveValue)value).doubleValue();\n        return String.valueOf(v);\n      }\n      if (value instanceof BooleanValue) {\n        boolean v = ((PrimitiveValue)value).booleanValue();\n        return String.valueOf(v);\n      }\n      if (value instanceof CharValue) {\n        char v = ((PrimitiveValue)value).charValue();\n        return String.valueOf(v);\n      }\n      if (value instanceof ObjectReference) {\n        if (value instanceof ArrayReference) {\n          final StringBuilder builder = new StringBuilder();\n          builder.append(\"[\");\n          for (Iterator<Value> iterator = ((ArrayReference)value).getValues().iterator(); iterator.hasNext();) {\n            final Value element = iterator.next();\n            builder.append(getValueAsString(evaluationContext, element));\n            if (iterator.hasNext()) {\n              builder.append(\",\");\n            }\n          }\n          builder.append(\"]\");\n          return builder.toString();\n        }\n\n        final ObjectReference objRef = (ObjectReference)value;\n        final DebugProcess debugProcess = evaluationContext.getDebugProcess();\n        Method toStringMethod = debugProcess.getUserData(TO_STRING_METHOD_KEY);\n        if (toStringMethod == null) {\n          try {\n            ReferenceType refType = getObjectClassType(objRef.virtualMachine());\n            toStringMethod = findMethod(refType, \"toString\", \"()Ljava/lang/String;\");\n            debugProcess.putUserData(TO_STRING_METHOD_KEY, toStringMethod);\n          }\n          catch (Exception ignored) {\n            throw EvaluateExceptionUtil.createEvaluateException(\n              DebuggerBundle.message(\"evaluation.error.cannot.evaluate.tostring\", objRef.referenceType().name()));\n          }\n        }\n        if (toStringMethod == null) {\n          throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.cannot.evaluate.tostring\", objRef.referenceType().name()));\n        }\n        // while result must be of com.sun.jdi.StringReference type, it turns out that sometimes (jvm bugs?)\n        // it is a plain com.sun.tools.jdi.ObjectReferenceImpl\n        final Value result = debugProcess.invokeInstanceMethod(evaluationContext, objRef, toStringMethod, Collections.emptyList(), 0);\n        if (result == null) {\n          return \"null\";\n        }\n        return result instanceof StringReference ? ((StringReference)result).value() : result.toString();\n      }\n      throw EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unsupported.expression.type\"));\n    }\n    catch (ObjectCollectedException ignored) {\n      throw EvaluateExceptionUtil.OBJECT_WAS_COLLECTED;\n    }\n  }","commit_id":"a61529944c1e0e0ffaaaa0dc9da73d8dbf239f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean instanceOf(@Nullable Type subType, @NotNull String superType) {\n    return getSuperType(subType, superType) != null;\n  }","id":90085,"modified_method":"public static boolean instanceOf(@Nullable Type subType, @NotNull String superType) {\n    if (subType == null || subType instanceof PrimitiveType || subType instanceof VoidType) {\n      return false;\n    }\n\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(superType)) {\n      return true;\n    }\n\n    return getSuperTypeInt(subType, superType) != null;\n  }","commit_id":"a61529944c1e0e0ffaaaa0dc9da73d8dbf239f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Type getSuperTypeInt(@NotNull Type subType, @NotNull String superType) {\n    if (typeEquals(subType, superType)) {\n      return subType;\n    }\n\n    Type result;\n    if (subType instanceof ClassType) {\n      try {\n        ClassType clsType = (ClassType)subType;\n        result = getSuperType(clsType.superclass(), superType);\n        if (result != null) {\n          return result;\n        }\n\n        for (InterfaceType iface : clsType.allInterfaces()) {\n          if (typeEquals(iface, superType)) {\n            return iface;\n          }\n        }\n      }\n      catch (ClassNotPreparedException e) {\n        LOG.info(e);\n      }\n      return null;\n    }\n\n    if (subType instanceof InterfaceType) {\n      try {\n        for (InterfaceType iface : ((InterfaceType)subType).superinterfaces()) {\n          result = getSuperType(iface, superType);\n          if (result != null) {\n            return result;\n          }\n        }\n      }\n      catch (ClassNotPreparedException e) {\n        LOG.info(e);\n      }\n    }\n    else if (subType instanceof ArrayType) {\n      if (superType.endsWith(\"[]\")) {\n        try {\n          String superTypeItem = superType.substring(0, superType.length() - 2);\n          Type subTypeItem = ((ArrayType)subType).componentType();\n          return instanceOf(subTypeItem, superTypeItem) ? subType : null;\n        }\n        catch (ClassNotLoadedException e) {\n          LOG.info(e);\n        }\n      }\n    }\n    else if (subType instanceof PrimitiveType) {\n      //noinspection HardCodedStringLiteral\n      if(superType.equals(\"java.lang.Primitive\")) {\n        return subType;\n      }\n    }\n\n    //only for interfaces and arrays\n    if(CommonClassNames.JAVA_LANG_OBJECT.equals(superType)) {\n      List list = subType.virtualMachine().classesByName(CommonClassNames.JAVA_LANG_OBJECT);\n      if(list.size() > 0) {\n        return (ReferenceType)list.get(0);\n      }\n    }\n    return null;\n  }","id":90086,"modified_method":"private static Type getSuperTypeInt(@NotNull Type subType, @NotNull String superType) {\n    if (typeEquals(subType, superType)) {\n      return subType;\n    }\n\n    Type result;\n    if (subType instanceof ClassType) {\n      try {\n        ClassType clsType = (ClassType)subType;\n        result = getSuperType(clsType.superclass(), superType);\n        if (result != null) {\n          return result;\n        }\n\n        for (InterfaceType iface : clsType.allInterfaces()) {\n          if (typeEquals(iface, superType)) {\n            return iface;\n          }\n        }\n      }\n      catch (ClassNotPreparedException e) {\n        LOG.info(e);\n      }\n      return null;\n    }\n\n    if (subType instanceof InterfaceType) {\n      try {\n        for (InterfaceType iface : ((InterfaceType)subType).superinterfaces()) {\n          result = getSuperType(iface, superType);\n          if (result != null) {\n            return result;\n          }\n        }\n      }\n      catch (ClassNotPreparedException e) {\n        LOG.info(e);\n      }\n    }\n    else if (subType instanceof ArrayType) {\n      if (superType.endsWith(\"[]\")) {\n        try {\n          String superTypeItem = superType.substring(0, superType.length() - 2);\n          Type subTypeItem = ((ArrayType)subType).componentType();\n          return instanceOf(subTypeItem, superTypeItem) ? subType : null;\n        }\n        catch (ClassNotLoadedException e) {\n          LOG.info(e);\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"a61529944c1e0e0ffaaaa0dc9da73d8dbf239f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Method findMethod(@NotNull ReferenceType refType, @NonNls String methodName, @Nullable @NonNls String methodSignature) {\n    if (refType instanceof ArrayType) {\n      // for array types methodByName() in JDI always returns empty list\n      Method method = findMethod(refType.virtualMachine().classesByName(CommonClassNames.JAVA_LANG_OBJECT).get(0), methodName, methodSignature);\n      if (method != null) {\n        return method;\n      }\n      // for arrays, clone signature may return array of objects, there is no such method in Object class\n      if (\"clone\".equals(methodName) && \"()[Ljava/lang/Object;\".equals(methodSignature)) {\n        method = findMethod(refType.virtualMachine().classesByName(CommonClassNames.JAVA_LANG_OBJECT).get(0), \"clone\", null);\n        if (method != null) {\n          return method;\n        }\n      }\n    }\n\n    Method method = null;\n    if (methodSignature != null) {\n      if (refType instanceof ClassType) {\n        method = ((ClassType)refType).concreteMethodByName(methodName, methodSignature);\n      }\n      if (method == null) {\n        method = ContainerUtil.getFirstItem(refType.methodsByName(methodName, methodSignature));\n      }\n    }\n    else {\n      method = ContainerUtil.getFirstItem(refType.methodsByName(methodName));\n    }\n    return method;\n  }","id":90087,"modified_method":"@Nullable\n  public static Method findMethod(@NotNull ReferenceType refType, @NonNls String methodName, @Nullable @NonNls String methodSignature) {\n    if (refType instanceof ArrayType) {\n      // for array types methodByName() in JDI always returns empty list\n      Method method = findMethod(getObjectClassType(refType.virtualMachine()), methodName, methodSignature);\n      if (method != null) {\n        return method;\n      }\n      // for arrays, clone signature may return array of objects, there is no such method in Object class\n      if (\"clone\".equals(methodName) && \"()[Ljava/lang/Object;\".equals(methodSignature)) {\n        method = findMethod(getObjectClassType(refType.virtualMachine()), \"clone\", null);\n        if (method != null) {\n          return method;\n        }\n      }\n    }\n\n    Method method = null;\n    if (methodSignature != null) {\n      if (refType instanceof ClassType) {\n        method = ((ClassType)refType).concreteMethodByName(methodName, methodSignature);\n      }\n      if (method == null) {\n        method = ContainerUtil.getFirstItem(refType.methodsByName(methodName, methodSignature));\n      }\n    }\n    else {\n      method = ContainerUtil.getFirstItem(refType.methodsByName(methodName));\n    }\n    return method;\n  }","commit_id":"a61529944c1e0e0ffaaaa0dc9da73d8dbf239f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Type getSuperType(@Nullable Type subType, @NotNull String superType) {\n    if (subType == null) return null;\n\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(superType)) {\n      List list = subType.virtualMachine().classesByName(CommonClassNames.JAVA_LANG_OBJECT);\n      if(list.size() > 0) {\n        return (ReferenceType)list.get(0);\n      }\n      return null;\n    }\n\n    return getSuperTypeInt(subType, superType);\n  }","id":90088,"modified_method":"@Nullable\n  public static Type getSuperType(@Nullable Type subType, @NotNull String superType) {\n    if (subType == null || subType instanceof PrimitiveType || subType instanceof VoidType) {\n      return null;\n    }\n\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(superType)) {\n      return getObjectClassType(subType.virtualMachine());\n    }\n\n    return getSuperTypeInt(subType, superType);\n  }","commit_id":"a61529944c1e0e0ffaaaa0dc9da73d8dbf239f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isFiltered(Type t) {\n    if (t instanceof ReferenceType) {\n      for (ClassFilter classFilter : myClassFilters) {\n        if (classFilter.isEnabled() && DebuggerUtils.getSuperType(t, classFilter.getPattern()) != null) {\n          return true;\n        }\n      }\n    }\n    return DebuggerUtilsEx.isFiltered(t.name(), myClassFilters);\n  }","id":90089,"modified_method":"private boolean isFiltered(Type t) {\n    if (t instanceof ReferenceType) {\n      for (ClassFilter classFilter : myClassFilters) {\n        if (classFilter.isEnabled() && DebuggerUtils.instanceOf(t, classFilter.getPattern())) {\n          return true;\n        }\n      }\n    }\n    return DebuggerUtilsEx.isFiltered(t.name(), myClassFilters);\n  }","commit_id":"a61529944c1e0e0ffaaaa0dc9da73d8dbf239f5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration\n     * provided by the specified XML element.\n     *\n     * @param element a XML element containing a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack\n     *         configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of\n     *                          the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(Element element) throws ChannelException {\n        ProtocolStackConfigurator returnValue;\n\n        if (propertiesOverride != null) {\n            returnValue = getStackConfigurator(propertiesOverride);\n        }\n        else {\n            checkForNullConfiguration(element);\n\n            // Since Element is a part of the JAXP specification and because an\n            // Element instance already exists, there is no need to check for\n            // JAXP availability.\n            //\n            // checkJAXPAvailability();\n\n            try {\n                returnValue=XmlConfigurator.getInstance(element);\n            }\n            catch (IOException ioe) {\n                throw createChannelConfigurationException(ioe);\n            }\n        }\n\n        return returnValue;\n    }","id":90090,"modified_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration provided by the specified XML element.\n     *\n     * @param element a XML element containing a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(Element element) throws ChannelException {\n        try {\n            checkForNullConfiguration(element);\n            return XmlConfigurator.getInstance(element);\n        }\n        catch (IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration\n     * provided at the specified URL.\n     *\n     * @param url a URL pointing to a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack\n     *         configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of\n     *                          the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(URL url) throws ChannelException {\n        ProtocolStackConfigurator returnValue;\n\n        if (propertiesOverride != null) {\n            returnValue = getStackConfigurator(propertiesOverride);\n        }\n        else {\n            checkForNullConfiguration(url);\n            checkJAXPAvailability();\n\n            try {\n                returnValue=XmlConfigurator.getInstance(url);\n            }\n            catch (IOException ioe) {\n                throw createChannelConfigurationException(ioe);\n            }\n        }\n\n        return returnValue;\n    }","id":90091,"modified_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration provided at the specified URL.\n     *\n     * @param url a URL pointing to a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(URL url) throws ChannelException {\n        try {\n            checkForNullConfiguration(url);\n            checkJAXPAvailability();\n            return XmlConfigurator.getInstance(url);\n        }\n        catch (IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"public static InputStream getConfigStream(URL url) throws Exception {\n        if (propertiesOverride != null)\n            return getConfigStream(propertiesOverride);\n        try {\n            checkJAXPAvailability();\n            return url.openStream();\n        }\n        catch(Exception ex) {\n            throw createChannelConfigurationException(ex);\n        }\n    }","id":90092,"modified_method":"public static InputStream getConfigStream(URL url) throws Exception {\n        try {\n            checkJAXPAvailability();\n            return url.openStream();\n        }\n        catch(Exception ex) {\n            throw createChannelConfigurationException(ex);\n        }\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"public static InputStream getConfigStream(File file) throws Exception {\n        if(propertiesOverride != null)\n            return getConfigStream(propertiesOverride);\n\n        checkForNullConfiguration(file);\n\n        try {\n            return new FileInputStream(file);\n        }\n        catch(IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n    }","id":90093,"modified_method":"public static InputStream getConfigStream(File file) throws Exception {\n        try {\n            checkForNullConfiguration(file);\n            return new FileInputStream(file);\n        }\n        catch(IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the provided properties\n     * string.\n     *\n     * @param properties an old style property string, a string representing a\n     *                   system resource containing a JGroups XML configuration,\n     *                   a string representing a URL pointing to a JGroups XML\n     *                   XML configuration, or a string representing a file name\n     *                   that contains a JGroups XML configuration.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(String properties) throws ChannelException {\n        if (propertiesOverride != null) {\n            properties = propertiesOverride;\n        }\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        checkForNullConfiguration(properties);\n\n        ProtocolStackConfigurator returnValue;\n\n        // Attempt to treat the properties string as a pointer to an XML\n        // configuration.\n        XmlConfigurator configurator = null;\n\n        try {\n            configurator=getXmlConfigurator(properties);\n        }\n        catch (IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n\n        // Did the properties string point to a JGroups XML configuration?\n        if (configurator != null) {\n            returnValue=configurator;\n        }\n        else {\n            // Attempt to process the properties string as the old style\n            // property string.\n            returnValue=new PlainConfigurator(properties);\n        }\n\n        return returnValue;\n    }","id":90094,"modified_method":"/**\n     * Returns a protocol stack configurator based on the provided properties\n     * string.\n     *\n     * @param properties an old style property string, a string representing a system resource containing a JGroups\n     *                   XML configuration, a string representing a URL pointing to a JGroups XML configuration,\n     *                   or a string representing a file name that contains a JGroups XML configuration.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(String properties) throws ChannelException {\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        // Attempt to treat the properties string as a pointer to an XML configuration.\n        XmlConfigurator configurator = null;\n\n        try {\n            checkForNullConfiguration(properties);\n            configurator=getXmlConfigurator(properties);\n        }\n        catch (IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n\n        // Did the properties string point to a JGroups XML configuration?\n        if (configurator != null) {\n            return configurator;\n        }\n        else {\n            // Attempt to process the properties string as the old style property string.\n            return new PlainConfigurator(properties);\n        }\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a JGroups XML configuration InputStream based on the provided\n     * properties string.\n     *\n     * @param properties a string representing a system resource containing a\n     *                   JGroups XML configuration, a string representing a URL\n     *                   pointing to a JGroups ML configuration, or a string\n     *                   representing a file name that contains a JGroups XML\n     *                   configuration.\n     *\n     * @throws IOException  if the provided properties string appears to be a\n     *                      valid URL but is unreachable.\n     */\n    public static InputStream getConfigStream(String properties) throws IOException {\n        InputStream configStream = null;\n        if (propertiesOverride != null)\n            return getConfigStream(propertiesOverride);\n\n        // Check to see if the properties string is the name of a file.\n        try {\n            configStream=new FileInputStream(properties);\n        }\n        catch(FileNotFoundException fnfe) {\n            // the properties string is likely not a file\n        }\n        catch(AccessControlException access_ex) {\n            // fixes http://jira.jboss.com/jira/browse/JGRP-94\n        }\n\n        // Check to see if the properties string is a URL.\n        if(configStream == null) {\n            try {\n                configStream=new URL(properties).openStream();\n            }\n            catch (MalformedURLException mre) {\n                // the properties string is not a URL\n            }\n        }\n        // Commented so the caller is notified of this condition, but left in\n        // the code for documentation purposes.\n        //\n        // catch (IOException ioe) {\n            // the specified URL string was not reachable\n        // }\n\n        // Check to see if the properties string is the name of a resource,\n        // e.g. udp.xml.\n        if(configStream == null && properties.endsWith(\"xml\")) {\n            configStream=Util.getResourceAsStream(properties, ConfiguratorFactory.class);\n        }\n        return configStream;\n    }","id":90095,"modified_method":"/**\n     * Returns a JGroups XML configuration InputStream based on the provided properties string.\n     *\n     * @param properties a string representing a system resource containing a JGroups XML configuration, a string\n     *                   representing a URL pointing to a JGroups ML configuration, or a string representing\n     *                   a file name that contains a JGroups XML configuration.\n     *\n     * @throws IOException  if the provided properties string appears to be a valid URL but is unreachable.\n     */\n    public static InputStream getConfigStream(String properties) throws IOException {\n        InputStream configStream = null;\n\n        // Check to see if the properties string is the name of a file.\n        try {\n            configStream=new FileInputStream(properties);\n        }\n        catch(FileNotFoundException fnfe) {\n            // the properties string is likely not a file\n        }\n        catch(AccessControlException access_ex) {\n            // fixes http://jira.jboss.com/jira/browse/JGRP-94\n        }\n\n        // Check to see if the properties string is a URL.\n        if(configStream == null) {\n            try {\n                configStream=new URL(properties).openStream();\n            }\n            catch (MalformedURLException mre) {\n                // the properties string is not a URL\n            }\n        }\n        // Commented so the caller is notified of this condition, but left in\n        // the code for documentation purposes.\n        //\n        // catch (IOException ioe) {\n            // the specified URL string was not reachable\n        // }\n\n        // Check to see if the properties string is the name of a resource,\n        // e.g. udp.xml.\n        if(configStream == null && properties.endsWith(\"xml\")) {\n            configStream=Util.getResourceAsStream(properties, ConfiguratorFactory.class);\n        }\n        return configStream;\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the properties passed in.<BR>\n     * If the properties parameter is a plain string UDP:FRAG:MERGE:GMS etc, a PlainConfigurator is returned.<BR>\n     * If the properties parameter is a string that represents a url for example http://www.filip.net/test.xml\n     * or the parameter is a java.net.URL object, an XmlConfigurator is returned<BR>\n     *\n     * @param properties old style property string, url string, or java.net.URL object\n     * @return a ProtocolStackConfigurator containing the stack configuration\n     * @throws IOException if it fails to parse the XML content\n     * @throws IOException if the URL is invalid or a the content can not be reached\n     * @deprecated Used by the JChannel(Object) constructor which has been deprecated.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(Object properties) throws IOException {\n        InputStream input=null;\n\n        if (propertiesOverride != null) {\n            properties = propertiesOverride;\n        }\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        if(properties instanceof URL) {\n            try {\n                input=((URL)properties).openStream();\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        // if it is a string, then it could be a plain string or a url\n        if(input == null && properties instanceof String) {\n            try {\n                input=new URL((String)properties).openStream();\n            }\n            catch(Exception ignore) {\n                // if we get here this means we don't have a URL\n            }\n\n            // another try - maybe it is a resource, e.g. udp.xml\n            if(input == null && ((String)properties).endsWith(\"xml\")) {\n                try {\n                    input=Util.getResourceAsStream((String)properties, ConfiguratorFactory.class);\n                }\n                catch(Throwable ignore) {\n                }\n            }\n\n            // try a regular file name\n            //\n            // This code was moved from the parent block (below) because of the\n            // possibility of causing a ClassCastException.\n\n            if(input == null) {\n                try {\n                    input=new FileInputStream((String)properties);\n                }\n                catch(Throwable t) {\n                }\n            }\n        }\n\n        // try a regular file\n        if(input == null && properties instanceof File) {\n            try {\n                input=new FileInputStream((File)properties);\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        if(input != null) {\n            return XmlConfigurator.getInstance(input);\n        }\n\n        if(properties instanceof Element) {\n            return XmlConfigurator.getInstance((Element)properties);\n        }\n\n        return new PlainConfigurator((String)properties);\n    }","id":90096,"modified_method":"/**\n     * Returns a protocol stack configurator based on the properties passed in.<BR>\n     * If the properties parameter is a plain string UDP:FRAG:MERGE:GMS etc, a PlainConfigurator is returned.<BR>\n     * If the properties parameter is a string that represents a url for example http://www.filip.net/test.xml\n     * or the parameter is a java.net.URL object, an XmlConfigurator is returned<BR>\n     *\n     * @param properties old style property string, url string, or java.net.URL object\n     * @return a ProtocolStackConfigurator containing the stack configuration\n     * @throws IOException if it fails to parse the XML content\n     * @throws IOException if the URL is invalid or a the content can not be reached\n     * @deprecated Used by the JChannel(Object) constructor which has been deprecated.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(Object properties) throws IOException {\n        InputStream input=null;\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        if(properties instanceof URL) {\n            try {\n                input=((URL)properties).openStream();\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        // if it is a string, then it could be a plain string or a url\n        if(input == null && properties instanceof String) {\n            try {\n                input=new URL((String)properties).openStream();\n            }\n            catch(Exception ignore) {\n                // if we get here this means we don't have a URL\n            }\n\n            // another try - maybe it is a resource, e.g. udp.xml\n            if(input == null && ((String)properties).endsWith(\"xml\")) {\n                try {\n                    input=Util.getResourceAsStream((String)properties, ConfiguratorFactory.class);\n                }\n                catch(Throwable ignore) {\n                }\n            }\n\n            // try a regular file name\n            //\n            // This code was moved from the parent block (below) because of the\n            // possibility of causing a ClassCastException.\n\n            if(input == null) {\n                try {\n                    input=new FileInputStream((String)properties);\n                }\n                catch(Throwable t) {\n                }\n            }\n        }\n\n        // try a regular file\n        if(input == null && properties instanceof File) {\n            try {\n                input=new FileInputStream((File)properties);\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        if(input != null) {\n            return XmlConfigurator.getInstance(input);\n        }\n\n        if(properties instanceof Element) {\n            return XmlConfigurator.getInstance((Element)properties);\n        }\n\n        return new PlainConfigurator((String)properties);\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration\n     * provided by the specified File.\n     *\n     * @param file a File with a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack\n     *         configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of\n     *                          the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(File file) throws ChannelException {\n        ProtocolStackConfigurator returnValue;\n\n        if (propertiesOverride != null) {\n            returnValue = getStackConfigurator(propertiesOverride);\n        }\n        else {\n            try {\n                checkJAXPAvailability();\n                InputStream input=getConfigStream(file);\n                returnValue=XmlConfigurator.getInstance(input);\n            }\n            catch(Exception ex) {\n                throw createChannelConfigurationException(ex);\n            }\n        }\n        return returnValue;\n    }","id":90097,"modified_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration provided by the specified File.\n     *\n     * @param file a File with a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(File file) throws ChannelException {\n        try {\n            checkJAXPAvailability();\n            InputStream input=getConfigStream(file);\n            return XmlConfigurator.getInstance(input);\n        }\n        catch(Exception ex) {\n            throw createChannelConfigurationException(ex);\n        }\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"public static InputStream getConfigStream(Object properties) throws IOException {\n        InputStream input=null;\n        if (propertiesOverride != null)\n            return getConfigStream(propertiesOverride);\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        if(properties instanceof URL) {\n            try {\n                input=((URL)properties).openStream();\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        // if it is a string, then it could be a plain string or a url\n        if(input == null && properties instanceof String) {\n            input=getConfigStream((String)properties);\n        }\n\n        // try a regular file\n        if(input == null && properties instanceof File) {\n            try {\n                input=new FileInputStream((File)properties);\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        if(input != null)\n            return input;\n\n        if(properties instanceof Element) {\n            return getConfigStream(properties);\n        }\n\n        return new ByteArrayInputStream(((String)properties).getBytes());\n    }","id":90098,"modified_method":"public static InputStream getConfigStream(Object properties) throws IOException {\n        InputStream input=null;\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        if(properties instanceof URL) {\n            try {\n                input=((URL)properties).openStream();\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        // if it is a string, then it could be a plain string or a url\n        if(input == null && properties instanceof String) {\n            input=getConfigStream((String)properties);\n        }\n\n        // try a regular file\n        if(input == null && properties instanceof File) {\n            try {\n                input=new FileInputStream((File)properties);\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        if(input != null)\n            return input;\n\n        if(properties instanceof Element) {\n            return getConfigStream(properties);\n        }\n\n        return new ByteArrayInputStream(((String)properties).getBytes());\n    }","commit_id":"389230c1f09faaf2a3f32e57faad50f1bce67e9e","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the properties passed in.<BR>\n     * If the properties parameter is a plain string UDP:FRAG:MERGE:GMS etc, a PlainConfigurator is returned.<BR>\n     * If the properties parameter is a string that represents a url for example http://www.filip.net/test.xml\n     * or the parameter is a java.net.URL object, an XmlConfigurator is returned<BR>\n     *\n     * @param properties old style property string, url string, or java.net.URL object\n     * @return a ProtocolStackConfigurator containing the stack configuration\n     * @throws IOException if it fails to parse the XML content\n     * @throws IOException if the URL is invalid or a the content can not be reached\n     * @deprecated Used by the JChannel(Object) constructor which has been deprecated.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(Object properties) throws IOException {\n        InputStream input=null;\n\n        if (propertiesOverride != null) {\n            properties = propertiesOverride;\n        }\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        if(properties instanceof URL) {\n            try {\n                input=((URL)properties).openStream();\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        // if it is a string, then it could be a plain string or a url\n        if(input == null && properties instanceof String) {\n            try {\n                input=new URL((String)properties).openStream();\n            }\n            catch(Exception ignore) {\n                // if we get here this means we don't have a URL\n            }\n\n            // another try - maybe it is a resource, e.g. udp.xml\n            if(input == null && ((String)properties).endsWith(\"xml\")) {\n                try {\n                    input=Util.getResourceAsStream((String)properties, ConfiguratorFactory.class);\n                }\n                catch(Throwable ignore) {\n                }\n            }\n\n            // try a regular file name\n            //\n            // This code was moved from the parent block (below) because of the\n            // possibility of causing a ClassCastException.\n\n            if(input == null) {\n                try {\n                    input=new FileInputStream((String)properties);\n                }\n                catch(Throwable t) {\n                }\n            }\n        }\n\n        // try a regular file\n        if(input == null && properties instanceof File) {\n            try {\n                input=new FileInputStream((File)properties);\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        if(input != null) {\n            return XmlConfigurator.getInstance(input);\n        }\n\n        if(properties instanceof Element) {\n            return XmlConfigurator.getInstance((Element)properties);\n        }\n\n        return new PlainConfigurator((String)properties);\n    }","id":90099,"modified_method":"/**\n     * Returns a protocol stack configurator based on the properties passed in.<BR>\n     * If the properties parameter is a plain string UDP:FRAG:MERGE:GMS etc, a PlainConfigurator is returned.<BR>\n     * If the properties parameter is a string that represents a url for example http://www.filip.net/test.xml\n     * or the parameter is a java.net.URL object, an XmlConfigurator is returned<BR>\n     *\n     * @param properties old style property string, url string, or java.net.URL object\n     * @return a ProtocolStackConfigurator containing the stack configuration\n     * @throws IOException if it fails to parse the XML content\n     * @throws IOException if the URL is invalid or a the content can not be reached\n     * @deprecated Used by the JChannel(Object) constructor which has been deprecated.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(Object properties) throws IOException {\n        InputStream input=null;\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        if(properties instanceof URL) {\n            try {\n                input=((URL)properties).openStream();\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        // if it is a string, then it could be a plain string or a url\n        if(input == null && properties instanceof String) {\n            try {\n                input=new URL((String)properties).openStream();\n            }\n            catch(Exception ignore) {\n                // if we get here this means we don't have a URL\n            }\n\n            // another try - maybe it is a resource, e.g. udp.xml\n            if(input == null && ((String)properties).endsWith(\"xml\")) {\n                try {\n                    input=Util.getResourceAsStream((String)properties, ConfiguratorFactory.class);\n                }\n                catch(Throwable ignore) {\n                }\n            }\n\n            // try a regular file name\n            //\n            // This code was moved from the parent block (below) because of the\n            // possibility of causing a ClassCastException.\n\n            if(input == null) {\n                try {\n                    input=new FileInputStream((String)properties);\n                }\n                catch(Throwable t) {\n                }\n            }\n        }\n\n        // try a regular file\n        if(input == null && properties instanceof File) {\n            try {\n                input=new FileInputStream((File)properties);\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        if(input != null) {\n            return XmlConfigurator.getInstance(input);\n        }\n\n        if(properties instanceof Element) {\n            return XmlConfigurator.getInstance((Element)properties);\n        }\n\n        return new PlainConfigurator((String)properties);\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the provided properties\n     * string.\n     *\n     * @param properties an old style property string, a string representing a\n     *                   system resource containing a JGroups XML configuration,\n     *                   a string representing a URL pointing to a JGroups XML\n     *                   XML configuration, or a string representing a file name\n     *                   that contains a JGroups XML configuration.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(String properties) throws ChannelException {\n        if (propertiesOverride != null) {\n            properties = propertiesOverride;\n        }\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        checkForNullConfiguration(properties);\n\n        ProtocolStackConfigurator returnValue;\n\n        // Attempt to treat the properties string as a pointer to an XML\n        // configuration.\n        XmlConfigurator configurator = null;\n\n        try {\n            configurator=getXmlConfigurator(properties);\n        }\n        catch (IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n\n        // Did the properties string point to a JGroups XML configuration?\n        if (configurator != null) {\n            returnValue=configurator;\n        }\n        else {\n            // Attempt to process the properties string as the old style\n            // property string.\n            returnValue=new PlainConfigurator(properties);\n        }\n\n        return returnValue;\n    }","id":90100,"modified_method":"/**\n     * Returns a protocol stack configurator based on the provided properties\n     * string.\n     *\n     * @param properties an old style property string, a string representing a system resource containing a JGroups\n     *                   XML configuration, a string representing a URL pointing to a JGroups XML configuration,\n     *                   or a string representing a file name that contains a JGroups XML configuration.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(String properties) throws ChannelException {\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        // Attempt to treat the properties string as a pointer to an XML configuration.\n        XmlConfigurator configurator = null;\n\n        try {\n            checkForNullConfiguration(properties);\n            configurator=getXmlConfigurator(properties);\n        }\n        catch (IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n\n        // Did the properties string point to a JGroups XML configuration?\n        if (configurator != null) {\n            return configurator;\n        }\n        else {\n            // Attempt to process the properties string as the old style property string.\n            return new PlainConfigurator(properties);\n        }\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"public static InputStream getConfigStream(File file) throws Exception {\n        if(propertiesOverride != null)\n            return getConfigStream(propertiesOverride);\n\n        checkForNullConfiguration(file);\n\n        try {\n            return new FileInputStream(file);\n        }\n        catch(IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n    }","id":90101,"modified_method":"public static InputStream getConfigStream(File file) throws Exception {\n        try {\n            checkForNullConfiguration(file);\n            return new FileInputStream(file);\n        }\n        catch(IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"public static InputStream getConfigStream(Object properties) throws IOException {\n        InputStream input=null;\n        if (propertiesOverride != null)\n            return getConfigStream(propertiesOverride);\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        if(properties instanceof URL) {\n            try {\n                input=((URL)properties).openStream();\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        // if it is a string, then it could be a plain string or a url\n        if(input == null && properties instanceof String) {\n            input=getConfigStream((String)properties);\n        }\n\n        // try a regular file\n        if(input == null && properties instanceof File) {\n            try {\n                input=new FileInputStream((File)properties);\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        if(input != null)\n            return input;\n\n        if(properties instanceof Element) {\n            return getConfigStream(properties);\n        }\n\n        return new ByteArrayInputStream(((String)properties).getBytes());\n    }","id":90102,"modified_method":"public static InputStream getConfigStream(Object properties) throws IOException {\n        InputStream input=null;\n\n        // added by bela: for null String props we use the default properties\n        if(properties == null)\n            properties=JChannel.DEFAULT_PROTOCOL_STACK;\n\n        if(properties instanceof URL) {\n            try {\n                input=((URL)properties).openStream();\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        // if it is a string, then it could be a plain string or a url\n        if(input == null && properties instanceof String) {\n            input=getConfigStream((String)properties);\n        }\n\n        // try a regular file\n        if(input == null && properties instanceof File) {\n            try {\n                input=new FileInputStream((File)properties);\n            }\n            catch(Throwable t) {\n            }\n        }\n\n        if(input != null)\n            return input;\n\n        if(properties instanceof Element) {\n            return getConfigStream(properties);\n        }\n\n        return new ByteArrayInputStream(((String)properties).getBytes());\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration\n     * provided at the specified URL.\n     *\n     * @param url a URL pointing to a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack\n     *         configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of\n     *                          the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(URL url) throws ChannelException {\n        ProtocolStackConfigurator returnValue;\n\n        if (propertiesOverride != null) {\n            returnValue = getStackConfigurator(propertiesOverride);\n        }\n        else {\n            checkForNullConfiguration(url);\n            checkJAXPAvailability();\n\n            try {\n                returnValue=XmlConfigurator.getInstance(url);\n            }\n            catch (IOException ioe) {\n                throw createChannelConfigurationException(ioe);\n            }\n        }\n\n        return returnValue;\n    }","id":90103,"modified_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration provided at the specified URL.\n     *\n     * @param url a URL pointing to a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(URL url) throws ChannelException {\n        try {\n            checkForNullConfiguration(url);\n            checkJAXPAvailability();\n            return XmlConfigurator.getInstance(url);\n        }\n        catch (IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration\n     * provided by the specified XML element.\n     *\n     * @param element a XML element containing a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack\n     *         configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of\n     *                          the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(Element element) throws ChannelException {\n        ProtocolStackConfigurator returnValue;\n\n        if (propertiesOverride != null) {\n            returnValue = getStackConfigurator(propertiesOverride);\n        }\n        else {\n            checkForNullConfiguration(element);\n\n            // Since Element is a part of the JAXP specification and because an\n            // Element instance already exists, there is no need to check for\n            // JAXP availability.\n            //\n            // checkJAXPAvailability();\n\n            try {\n                returnValue=XmlConfigurator.getInstance(element);\n            }\n            catch (IOException ioe) {\n                throw createChannelConfigurationException(ioe);\n            }\n        }\n\n        return returnValue;\n    }","id":90104,"modified_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration provided by the specified XML element.\n     *\n     * @param element a XML element containing a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(Element element) throws ChannelException {\n        try {\n            checkForNullConfiguration(element);\n            return XmlConfigurator.getInstance(element);\n        }\n        catch (IOException ioe) {\n            throw createChannelConfigurationException(ioe);\n        }\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration\n     * provided by the specified File.\n     *\n     * @param file a File with a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack\n     *         configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of\n     *                          the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(File file) throws ChannelException {\n        ProtocolStackConfigurator returnValue;\n\n        if (propertiesOverride != null) {\n            returnValue = getStackConfigurator(propertiesOverride);\n        }\n        else {\n            try {\n                checkJAXPAvailability();\n                InputStream input=getConfigStream(file);\n                returnValue=XmlConfigurator.getInstance(input);\n            }\n            catch(Exception ex) {\n                throw createChannelConfigurationException(ex);\n            }\n        }\n        return returnValue;\n    }","id":90105,"modified_method":"/**\n     * Returns a protocol stack configurator based on the XML configuration provided by the specified File.\n     *\n     * @param file a File with a JGroups XML configuration.\n     *\n     * @return a <code>ProtocolStackConfigurator<\/code> containing the stack configuration.\n     *\n     * @throws ChannelException if problems occur during the configuration of the protocol stack.\n     */\n    public static ProtocolStackConfigurator getStackConfigurator(File file) throws ChannelException {\n        try {\n            checkJAXPAvailability();\n            InputStream input=getConfigStream(file);\n            return XmlConfigurator.getInstance(input);\n        }\n        catch(Exception ex) {\n            throw createChannelConfigurationException(ex);\n        }\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns a JGroups XML configuration InputStream based on the provided\n     * properties string.\n     *\n     * @param properties a string representing a system resource containing a\n     *                   JGroups XML configuration, a string representing a URL\n     *                   pointing to a JGroups ML configuration, or a string\n     *                   representing a file name that contains a JGroups XML\n     *                   configuration.\n     *\n     * @throws IOException  if the provided properties string appears to be a\n     *                      valid URL but is unreachable.\n     */\n    public static InputStream getConfigStream(String properties) throws IOException {\n        InputStream configStream = null;\n        if (propertiesOverride != null)\n            return getConfigStream(propertiesOverride);\n\n        // Check to see if the properties string is the name of a file.\n        try {\n            configStream=new FileInputStream(properties);\n        }\n        catch(FileNotFoundException fnfe) {\n            // the properties string is likely not a file\n        }\n        catch(AccessControlException access_ex) {\n            // fixes http://jira.jboss.com/jira/browse/JGRP-94\n        }\n\n        // Check to see if the properties string is a URL.\n        if(configStream == null) {\n            try {\n                configStream=new URL(properties).openStream();\n            }\n            catch (MalformedURLException mre) {\n                // the properties string is not a URL\n            }\n        }\n        // Commented so the caller is notified of this condition, but left in\n        // the code for documentation purposes.\n        //\n        // catch (IOException ioe) {\n            // the specified URL string was not reachable\n        // }\n\n        // Check to see if the properties string is the name of a resource,\n        // e.g. udp.xml.\n        if(configStream == null && properties.endsWith(\"xml\")) {\n            configStream=Util.getResourceAsStream(properties, ConfiguratorFactory.class);\n        }\n        return configStream;\n    }","id":90106,"modified_method":"/**\n     * Returns a JGroups XML configuration InputStream based on the provided properties string.\n     *\n     * @param properties a string representing a system resource containing a JGroups XML configuration, a string\n     *                   representing a URL pointing to a JGroups ML configuration, or a string representing\n     *                   a file name that contains a JGroups XML configuration.\n     *\n     * @throws IOException  if the provided properties string appears to be a valid URL but is unreachable.\n     */\n    public static InputStream getConfigStream(String properties) throws IOException {\n        InputStream configStream = null;\n\n        // Check to see if the properties string is the name of a file.\n        try {\n            configStream=new FileInputStream(properties);\n        }\n        catch(FileNotFoundException fnfe) {\n            // the properties string is likely not a file\n        }\n        catch(AccessControlException access_ex) {\n            // fixes http://jira.jboss.com/jira/browse/JGRP-94\n        }\n\n        // Check to see if the properties string is a URL.\n        if(configStream == null) {\n            try {\n                configStream=new URL(properties).openStream();\n            }\n            catch (MalformedURLException mre) {\n                // the properties string is not a URL\n            }\n        }\n        // Commented so the caller is notified of this condition, but left in\n        // the code for documentation purposes.\n        //\n        // catch (IOException ioe) {\n            // the specified URL string was not reachable\n        // }\n\n        // Check to see if the properties string is the name of a resource,\n        // e.g. udp.xml.\n        if(configStream == null && properties.endsWith(\"xml\")) {\n            configStream=Util.getResourceAsStream(properties, ConfiguratorFactory.class);\n        }\n        return configStream;\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"public static InputStream getConfigStream(URL url) throws Exception {\n        if (propertiesOverride != null)\n            return getConfigStream(propertiesOverride);\n        try {\n            checkJAXPAvailability();\n            return url.openStream();\n        }\n        catch(Exception ex) {\n            throw createChannelConfigurationException(ex);\n        }\n    }","id":90107,"modified_method":"public static InputStream getConfigStream(URL url) throws Exception {\n        try {\n            checkJAXPAvailability();\n            return url.openStream();\n        }\n        catch(Exception ex) {\n            throw createChannelConfigurationException(ex);\n        }\n    }","commit_id":"e472979cb2e7d889fbb8e36489508aea8805ac54","url":"https://github.com/belaban/JGroups"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final String patchId = operation.require(PATCH_ID).asString();\n        //\n        context.acquireControllerLock();\n        final ServiceController<?> mgrService = context.getServiceRegistry(false).getRequiredService(InstallationManagerService.NAME);\n        final InstallationManager mgr = (InstallationManager) mgrService.getValue();\n        final PatchableTarget.TargetInfo info;\n        try {\n            info = mgr.getIdentity().loadTargetInfo();\n        } catch (IOException e) {\n            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n        }\n        if(info.getCumulativePatchID().equals(patchId)) {\n            throw PatchManagementMessages.MESSAGES.patchActive(patchId);\n        }\n        if(info.getPatchIDs().contains(patchId)) {\n            throw PatchManagementMessages.MESSAGES.patchActive(patchId);\n        }\n        final InstalledImage installedImage = info.getDirectoryStructure().getInstalledImage();\n\n        // Remove directories\n        final File history = installedImage.getPatchHistoryDir(patchId);\n        if(history.exists()) {\n            recursiveDelete(history);\n        }\n        // Remove patch contents\n        final File patchRoot = installedImage.getPatchHistoryDir(patchId);\n        if(patchRoot.exists()) {\n            recursiveDelete(patchRoot);\n        }\n\n        // TODO perhaps recursively remove one-off patches in case this targets a CP\n\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","id":90108,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final String patchId = operation.require(PATCH_ID).asString();\n\n        // Acquire the lock and check the write permissions for this operation\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final ServiceController<?> mgrService = registry.getRequiredService(InstallationManagerService.NAME);\n        final InstallationManager mgr = (InstallationManager) mgrService.getValue();\n        final PatchableTarget.TargetInfo info;\n        try {\n            info = mgr.getIdentity().loadTargetInfo();\n        } catch (IOException e) {\n            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n        }\n        if(info.getCumulativePatchID().equals(patchId)) {\n            throw PatchManagementMessages.MESSAGES.patchActive(patchId);\n        }\n        if(info.getPatchIDs().contains(patchId)) {\n            throw PatchManagementMessages.MESSAGES.patchActive(patchId);\n        }\n        final InstalledImage installedImage = info.getDirectoryStructure().getInstalledImage();\n\n        // Remove directories\n        final File history = installedImage.getPatchHistoryDir(patchId);\n        if(history.exists()) {\n            recursiveDelete(history);\n        }\n        // Remove patch contents\n        final File patchRoot = installedImage.getPatchHistoryDir(patchId);\n        if(patchRoot.exists()) {\n            recursiveDelete(patchRoot);\n        }\n\n        // TODO perhaps recursively remove one-off patches in case this targets a CP\n\n        context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n    }","commit_id":"2909894f26e0f091b8b580240bb107ea7181ed1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        context.acquireControllerLock();\n        // Setup\n        final InstallationManager installationManager = (InstallationManager) context.getServiceRegistry(false).getRequiredService(InstallationManagerService.NAME).getValue();\n\n        if (installationManager.requiresRestart()) {\n            throw MESSAGES.serverRequiresRestart();\n        }\n\n        try {\n            final PatchTool runner = PatchTool.Factory.create(installationManager);\n            final ContentVerificationPolicy policy = PatchTool.Factory.create(operation);\n\n            final int index = operation.get(ModelDescriptionConstants.INPUT_STREAM_INDEX).asInt(0);\n            final InputStream is = context.getAttachmentStream(index);\n            installationManager.restartRequired();\n            final PatchingResult result = runner.applyPatch(is, policy);\n            context.restartRequired();\n            context.completeStep(new OperationContext.ResultHandler() {\n\n                @Override\n                public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                    if(resultAction == OperationContext.ResultAction.KEEP) {\n                        result.commit();\n                    } else {\n                        installationManager.clearRestartRequired();\n                        context.revertRestartRequired();\n                        result.rollback();\n                    }\n                }\n\n            });\n        } catch (PatchingException e) {\n            final ModelNode failureDescription = context.getFailureDescription();\n            PatchOperationTarget.formatFailedResponse(e, failureDescription);\n            installationManager.clearRestartRequired();\n            context.stepCompleted();\n        }\n    }","id":90109,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n\n        // Acquire the lock and check the write permissions for this operation\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final InstallationManager installationManager = (InstallationManager) registry.getRequiredService(InstallationManagerService.NAME).getValue();\n\n        if (installationManager.requiresRestart()) {\n            throw MESSAGES.serverRequiresRestart();\n        }\n\n        try {\n            final PatchTool runner = PatchTool.Factory.create(installationManager);\n            final ContentVerificationPolicy policy = PatchTool.Factory.create(operation);\n\n            final int index = operation.get(ModelDescriptionConstants.INPUT_STREAM_INDEX).asInt(0);\n            final InputStream is = context.getAttachmentStream(index);\n            installationManager.restartRequired();\n            final PatchingResult result = runner.applyPatch(is, policy);\n            context.restartRequired();\n            context.completeStep(new OperationContext.ResultHandler() {\n\n                @Override\n                public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                    if(resultAction == OperationContext.ResultAction.KEEP) {\n                        result.commit();\n                    } else {\n                        installationManager.clearRestartRequired();\n                        context.revertRestartRequired();\n                        result.rollback();\n                    }\n                }\n\n            });\n        } catch (PatchingException e) {\n            final ModelNode failureDescription = context.getFailureDescription();\n            PatchOperationTarget.formatFailedResponse(e, failureDescription);\n            installationManager.clearRestartRequired();\n            context.stepCompleted();\n        }\n    }","commit_id":"2909894f26e0f091b8b580240bb107ea7181ed1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final String patchId = PatchResourceDefinition.PATCH_ID.resolveModelAttribute(context, operation).asString();\n        final boolean rollbackTo = PatchResourceDefinition.ROLLBACK_TO.resolveModelAttribute(context, operation).asBoolean();\n        final boolean restoreConfiguration = PatchResourceDefinition.RESET_CONFIGURATION.resolveModelAttribute(context, operation).asBoolean();\n\n        context.acquireControllerLock();\n        final InstallationManager installationManager = (InstallationManager) context.getServiceRegistry(false).getRequiredService(InstallationManagerService.NAME).getValue();\n\n        if (installationManager.requiresRestart()) {\n            throw MESSAGES.serverRequiresRestart();\n        }\n\n        final PatchTool runner = PatchTool.Factory.create(installationManager);\n        final ContentVerificationPolicy policy = PatchTool.Factory.create(operation);\n        try {\n            // Rollback\n            final PatchingResult result = runner.rollback(patchId, policy, rollbackTo, restoreConfiguration);\n            installationManager.restartRequired();\n            context.restartRequired();\n            context.completeStep(new OperationContext.ResultHandler() {\n\n                @Override\n                public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                    if(resultAction == OperationContext.ResultAction.KEEP) {\n                        result.commit();\n                    } else {\n                        installationManager.clearRestartRequired();\n                        context.revertRestartRequired();\n                        result.rollback();\n                    }\n                }\n\n            });\n        } catch (PatchingException e) {\n            final ModelNode failureDescription = context.getFailureDescription();\n            PatchOperationTarget.formatFailedResponse(e, failureDescription);\n            installationManager.clearRestartRequired();\n            context.stepCompleted();\n        } finally {\n            //\n        }\n    }","id":90110,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final String patchId = PatchResourceDefinition.PATCH_ID.resolveModelAttribute(context, operation).asString();\n        final boolean rollbackTo = PatchResourceDefinition.ROLLBACK_TO.resolveModelAttribute(context, operation).asBoolean();\n        final boolean restoreConfiguration = PatchResourceDefinition.RESET_CONFIGURATION.resolveModelAttribute(context, operation).asBoolean();\n\n        // Acquire the lock and check the write permissions for this operation\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final InstallationManager installationManager = (InstallationManager) registry.getRequiredService(InstallationManagerService.NAME).getValue();\n\n        if (installationManager.requiresRestart()) {\n            throw MESSAGES.serverRequiresRestart();\n        }\n\n        final PatchTool runner = PatchTool.Factory.create(installationManager);\n        final ContentVerificationPolicy policy = PatchTool.Factory.create(operation);\n        try {\n            // Rollback\n            final PatchingResult result = runner.rollback(patchId, policy, rollbackTo, restoreConfiguration);\n            installationManager.restartRequired();\n            context.restartRequired();\n            context.completeStep(new OperationContext.ResultHandler() {\n\n                @Override\n                public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                    if(resultAction == OperationContext.ResultAction.KEEP) {\n                        result.commit();\n                    } else {\n                        installationManager.clearRestartRequired();\n                        context.revertRestartRequired();\n                        result.rollback();\n                    }\n                }\n\n            });\n        } catch (PatchingException e) {\n            final ModelNode failureDescription = context.getFailureDescription();\n            PatchOperationTarget.formatFailedResponse(e, failureDescription);\n            installationManager.clearRestartRequired();\n            context.stepCompleted();\n        } finally {\n            //\n        }\n    }","commit_id":"2909894f26e0f091b8b580240bb107ea7181ed1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final boolean resetConfiguration = PatchResourceDefinition.RESET_CONFIGURATION.resolveModelAttribute(context, operation).asBoolean();\n\n        context.acquireControllerLock();\n        final InstallationManager installationManager = (InstallationManager) context.getServiceRegistry(false).getRequiredService(InstallationManagerService.NAME).getValue();\n\n        if (installationManager.requiresRestart()) {\n            throw MESSAGES.serverRequiresRestart();\n        }\n\n        final PatchTool runner = PatchTool.Factory.create(installationManager);\n        final ContentVerificationPolicy policy = PatchTool.Factory.create(operation);\n        try {\n            // Rollback\n            final PatchingResult result = runner.rollbackLast(policy, resetConfiguration);\n            installationManager.restartRequired();\n            context.restartRequired();\n            context.completeStep(new OperationContext.ResultHandler() {\n\n                @Override\n                public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                    if (resultAction == OperationContext.ResultAction.KEEP) {\n                        result.commit();\n                    } else {\n                        installationManager.clearRestartRequired();\n                        context.revertRestartRequired();\n                        result.rollback();\n                    }\n                }\n\n            });\n        } catch (PatchingException e) {\n            final ModelNode failureDescription = context.getFailureDescription();\n            PatchOperationTarget.formatFailedResponse(e, failureDescription);\n            installationManager.clearRestartRequired();\n            context.stepCompleted();\n        } finally {\n            //\n        }\n    }","id":90111,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        final boolean resetConfiguration = PatchResourceDefinition.RESET_CONFIGURATION.resolveModelAttribute(context, operation).asBoolean();\n\n        // Acquire the lock and check the write permissions for this operation\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final InstallationManager installationManager = (InstallationManager) registry.getRequiredService(InstallationManagerService.NAME).getValue();\n\n        if (installationManager.requiresRestart()) {\n            throw MESSAGES.serverRequiresRestart();\n        }\n\n        final PatchTool runner = PatchTool.Factory.create(installationManager);\n        final ContentVerificationPolicy policy = PatchTool.Factory.create(operation);\n        try {\n            // Rollback\n            final PatchingResult result = runner.rollbackLast(policy, resetConfiguration);\n            installationManager.restartRequired();\n            context.restartRequired();\n            context.completeStep(new OperationContext.ResultHandler() {\n\n                @Override\n                public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {\n                    if (resultAction == OperationContext.ResultAction.KEEP) {\n                        result.commit();\n                    } else {\n                        installationManager.clearRestartRequired();\n                        context.revertRestartRequired();\n                        result.rollback();\n                    }\n                }\n\n            });\n        } catch (PatchingException e) {\n            final ModelNode failureDescription = context.getFailureDescription();\n            PatchOperationTarget.formatFailedResponse(e, failureDescription);\n            installationManager.clearRestartRequired();\n            context.stepCompleted();\n        } finally {\n            //\n        }\n    }","commit_id":"2909894f26e0f091b8b580240bb107ea7181ed1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n        context.acquireControllerLock();\n        // Setup\n        final InstallationManager installationManager = (InstallationManager) context.getServiceRegistry(false).getRequiredService(InstallationManagerService.NAME).getValue();\n        try {\n            final PatchableTarget.TargetInfo info = installationManager.getIdentity().loadTargetInfo();\n            final InstalledImage installedImage = info.getDirectoryStructure().getInstalledImage();\n\n            final ModelNode result = new ModelNode();\n            result.setEmptyList();\n\n            final String releaseID = info.getCumulativePatchID();\n            if (!BASE.equals(releaseID)) {\n                fillHistory(result, CUMULATIVE, releaseID, installedImage.getPatchHistoryDir(releaseID));\n            }\n\n            final List<String> oneOffPatchIDs = info.getPatchIDs();\n            for (String oneOffPatchID : oneOffPatchIDs) {\n                File historyDir = installedImage.getPatchHistoryDir(oneOffPatchID);\n                fillHistory(result, ONE_OFF, oneOffPatchID, historyDir);\n            }\n            context.getResult().set(result);\n            context.stepCompleted();\n        } catch (Throwable t) {\n            PatchManagementLogger.ROOT_LOGGER.debugf(t, \"failed to get history\");\n            throw PatchManagementMessages.MESSAGES.failedToShowHistory(t);\n        }\n    }","id":90112,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n\n        // Acquire the lock and check the write permissions for this operation\n        final ServiceRegistry registry = context.getServiceRegistry(true);\n        final InstallationManager installationManager = (InstallationManager) registry.getRequiredService(InstallationManagerService.NAME).getValue();\n        try {\n            final PatchableTarget.TargetInfo info = installationManager.getIdentity().loadTargetInfo();\n            final InstalledImage installedImage = info.getDirectoryStructure().getInstalledImage();\n\n            final ModelNode result = new ModelNode();\n            result.setEmptyList();\n\n            final String releaseID = info.getCumulativePatchID();\n            if (!BASE.equals(releaseID)) {\n                fillHistory(result, CUMULATIVE, releaseID, installedImage.getPatchHistoryDir(releaseID));\n            }\n\n            final List<String> oneOffPatchIDs = info.getPatchIDs();\n            for (String oneOffPatchID : oneOffPatchIDs) {\n                File historyDir = installedImage.getPatchHistoryDir(oneOffPatchID);\n                fillHistory(result, ONE_OFF, oneOffPatchID, historyDir);\n            }\n            context.getResult().set(result);\n            context.stepCompleted();\n        } catch (Throwable t) {\n            PatchManagementLogger.ROOT_LOGGER.debugf(t, \"failed to get history\");\n            throw PatchManagementMessages.MESSAGES.failedToShowHistory(t);\n        }\n    }","commit_id":"2909894f26e0f091b8b580240bb107ea7181ed1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected PatchResource(ServiceController<InstallationManager> imController) {\n        super.registerResourceProvider(\"layer\", new LayerResourceProvider(imController));\n        super.registerResourceProvider(\"addon\", new AddOnResourceProvider(imController));\n    }","id":90113,"modified_method":"protected PatchResource(ServiceController<InstallationManager> imController) {\n        super.registerResourceProvider(\"layer\", new LayerResourceProvider(imController));\n        super.registerResourceProvider(\"addon\", new AddOnResourceProvider(imController));\n        model.protect();\n    }","commit_id":"2909894f26e0f091b8b580240bb107ea7181ed1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration registry) {\n        super.registerAttributes(registry);\n\n        registry.registerReadOnlyAttribute(VERSION, new PatchAttributeReadHandler() {\n            @Override\n            void handle(ModelNode result, Identity info) {\n                result.set(info.getVersion());\n            }\n        });\n        registry.registerReadOnlyAttribute(CUMULATIVE_PATCH_ID, new PatchAttributeReadHandler() {\n            @Override\n            void handle(ModelNode result, Identity info) throws IOException {\n                result.set(info.loadTargetInfo().getCumulativePatchID());\n            }\n        });\n        registry.registerReadOnlyAttribute(PATCHES, new PatchAttributeReadHandler() {\n            @Override\n            void handle(ModelNode result, Identity info) throws IOException {\n                result.setEmptyList();\n                for (final String id : info.loadTargetInfo().getPatchIDs()) {\n                    result.add(id);\n                }\n            }\n        });\n\n        StandardResourceDescriptionResolver resolver = new StandardResourceDescriptionResolver(\"patching.layer\", \"org.jboss.as.patching.management.LocalDescriptions\", PatchResourceDefinition.class.getClassLoader());\n        registry.registerSubModel(new SimpleResourceDefinition(PathElement.pathElement(\"layer\"), resolver) {\n            @Override\n            public void registerAttributes(final ManagementResourceRegistration resource) {\n                resource.registerReadOnlyAttribute(CUMULATIVE_PATCH_ID, new ElementProviderAttributeReadHandler.LayerAttributeReadHandler() {\n                    @Override\n                    void handle(ModelNode result, PatchableTarget layer) throws OperationFailedException {\n                        try {\n                            result.set(layer.loadTargetInfo().getCumulativePatchID());\n                        } catch (IOException e) {\n                            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n                        }\n                    }\n                });\n                resource.registerReadOnlyAttribute(PATCHES, new ElementProviderAttributeReadHandler.LayerAttributeReadHandler() {\n                    @Override\n                    void handle(ModelNode result, PatchableTarget layer) throws OperationFailedException {\n                        result.setEmptyList();\n                        try {\n                            for (final String id : layer.loadTargetInfo().getPatchIDs()) {\n                                result.add(id);\n                            }\n                        } catch (IOException e) {\n                            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n                        }\n                    }\n                });\n            }\n        });\n\n        resolver = new StandardResourceDescriptionResolver(\"patching.addon\", \"org.jboss.as.patching.management.LocalDescriptions\", PatchResourceDefinition.class.getClassLoader());\n        registry.registerSubModel(new SimpleResourceDefinition(PathElement.pathElement(\"addon\"), resolver) {\n            @Override\n            public void registerAttributes(final ManagementResourceRegistration resource) {\n                resource.registerReadOnlyAttribute(CUMULATIVE_PATCH_ID, new ElementProviderAttributeReadHandler.AddOnAttributeReadHandler() {\n                    @Override\n                    void handle(ModelNode result, PatchableTarget addon) throws OperationFailedException {\n                        try {\n                            result.set(addon.loadTargetInfo().getCumulativePatchID());\n                        } catch (IOException e) {\n                            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n                        }\n                    }\n                });\n                resource.registerReadOnlyAttribute(PATCHES, new ElementProviderAttributeReadHandler.AddOnAttributeReadHandler() {\n                    @Override\n                    void handle(ModelNode result, PatchableTarget addon) throws OperationFailedException {\n                        result.setEmptyList();\n                        try {\n                            for (final String id : addon.loadTargetInfo().getPatchIDs()) {\n                                result.add(id);\n                            }\n                        } catch (IOException e) {\n                            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n                        }\n                    }\n                });\n            }\n        });\n    }","id":90114,"modified_method":"@Override\n    public void registerAttributes(ManagementResourceRegistration registry) {\n        super.registerAttributes(registry);\n\n        registry.registerReadOnlyAttribute(VERSION, new PatchAttributeReadHandler() {\n            @Override\n            void handle(ModelNode result, Identity info) {\n                result.set(info.getVersion());\n            }\n        });\n        registry.registerReadOnlyAttribute(CUMULATIVE_PATCH_ID, new PatchAttributeReadHandler() {\n            @Override\n            void handle(ModelNode result, Identity info) throws IOException {\n                result.set(info.loadTargetInfo().getCumulativePatchID());\n            }\n        });\n        registry.registerReadOnlyAttribute(PATCHES, new PatchAttributeReadHandler() {\n            @Override\n            void handle(ModelNode result, Identity info) throws IOException {\n                result.setEmptyList();\n                for (final String id : info.loadTargetInfo().getPatchIDs()) {\n                    result.add(id);\n                }\n            }\n        });\n\n        StandardResourceDescriptionResolver resolver = new StandardResourceDescriptionResolver(\"patching.layer\", \"org.jboss.as.patching.management.LocalDescriptions\", PatchResourceDefinition.class.getClassLoader());\n        registry.registerSubModel(new SimpleResourceDefinition(PathElement.pathElement(\"layer\"), resolver) {\n\n            @Override\n            public void registerAttributes(final ManagementResourceRegistration resource) {\n                resource.registerReadOnlyAttribute(CUMULATIVE_PATCH_ID, new ElementProviderAttributeReadHandler.LayerAttributeReadHandler() {\n                    @Override\n                    void handle(ModelNode result, PatchableTarget layer) throws OperationFailedException {\n                        try {\n                            result.set(layer.loadTargetInfo().getCumulativePatchID());\n                        } catch (IOException e) {\n                            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n                        }\n                    }\n                });\n                resource.registerReadOnlyAttribute(PATCHES, new ElementProviderAttributeReadHandler.LayerAttributeReadHandler() {\n                    @Override\n                    void handle(ModelNode result, PatchableTarget layer) throws OperationFailedException {\n                        result.setEmptyList();\n                        try {\n                            for (final String id : layer.loadTargetInfo().getPatchIDs()) {\n                                result.add(id);\n                            }\n                        } catch (IOException e) {\n                            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n                        }\n                    }\n                });\n\n            }\n\n            @Override\n            public List<AccessConstraintDefinition> getAccessConstraints() {\n                return sensitivity;\n            }\n\n        });\n\n        resolver = new StandardResourceDescriptionResolver(\"patching.addon\", \"org.jboss.as.patching.management.LocalDescriptions\", PatchResourceDefinition.class.getClassLoader());\n        registry.registerSubModel(new SimpleResourceDefinition(PathElement.pathElement(\"addon\"), resolver) {\n            @Override\n            public void registerAttributes(final ManagementResourceRegistration resource) {\n                resource.registerReadOnlyAttribute(CUMULATIVE_PATCH_ID, new ElementProviderAttributeReadHandler.AddOnAttributeReadHandler() {\n                    @Override\n                    void handle(ModelNode result, PatchableTarget addon) throws OperationFailedException {\n                        try {\n                            result.set(addon.loadTargetInfo().getCumulativePatchID());\n                        } catch (IOException e) {\n                            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n                        }\n                    }\n                });\n                resource.registerReadOnlyAttribute(PATCHES, new ElementProviderAttributeReadHandler.AddOnAttributeReadHandler() {\n                    @Override\n                    void handle(ModelNode result, PatchableTarget addon) throws OperationFailedException {\n                        result.setEmptyList();\n                        try {\n                            for (final String id : addon.loadTargetInfo().getPatchIDs()) {\n                                result.add(id);\n                            }\n                        } catch (IOException e) {\n                            throw new OperationFailedException(PatchManagementMessages.MESSAGES.failedToLoadIdentity(), e);\n                        }\n                    }\n                });\n            }\n\n            @Override\n            public List<AccessConstraintDefinition> getAccessConstraints() {\n                return sensitivity;\n            }\n\n        });\n    }","commit_id":"2909894f26e0f091b8b580240bb107ea7181ed1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"private PatchResourceDefinition() {\n        super(PATH, getResourceDescriptionResolver(NAME));\n    }","id":90115,"modified_method":"private PatchResourceDefinition() {\n        super(PATH, getResourceDescriptionResolver(NAME));\n        sensitivity = SensitiveTargetAccessConstraintDefinition.PATCHING.wrapAsList();\n    }","commit_id":"2909894f26e0f091b8b580240bb107ea7181ed1f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public AbstractAction()\n   {\n      hostUrl = WebDriverFactory.INSTANCE.getHostUrl();\n      driver = WebDriverFactory.INSTANCE.getDriver();\n      driver.get(hostUrl);\n\n      homePage = new HomePage(driver);\n   }","id":90116,"modified_method":"public AbstractAction()\n   {\n      String baseUrl = WebDriverFactory.INSTANCE.getHostUrl();\n      hostUrl = appendTrailingSlash(baseUrl);\n      driver = WebDriverFactory.INSTANCE.getDriver();\n      driver.get(hostUrl);\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public AbstractPage(final WebDriver driver)\n   {\n      PageFactory.initElements(new AjaxElementLocatorFactory(driver, 30), this);\n      this.driver = driver;\n   }","id":90117,"modified_method":"public AbstractPage(final WebDriver driver)\n   {\n      PageFactory.initElements(new AjaxElementLocatorFactory(driver, 30), this);\n      this.driver = driver;\n      navMenuItems = navMenu.findElements(By.tagName(\"a\"));\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public CreateProjectPage selectStatus(String status)\n   {\n      new Select(statusSelection).selectByValue(status);\n      return this;\n   }","id":90118,"modified_method":"public CreateProjectPage selectStatus(String status)\n   {\n      new Select(statusSelection).selectByVisibleText(status);\n      return this;\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ProjectPage saveProject()\n   {\n      saveButton.click();\n      return PageFactory.initElements(getDriver(), ProjectPage.class);\n   }","id":90119,"modified_method":"public ProjectPage saveProject()\n   {\n      saveButton.click();\n      return new ProjectPage(getDriver());\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test\n   public void canCreateProject() {\n      new LoginAction().signIn(\"admin\", \"admin\");\n      ProjectPage projectPage = new CreateProjectAction().createNewProject(\"plurals\", \"plural project\");\n\n      assertThat(projectPage.getProjectId(), Matchers.equalTo(\"Project ID: plurals\"));\n      assertThat(projectPage.getProjectName(), Matchers.equalTo(\"Name: plural project\"));\n   }","id":90120,"modified_method":"@Test\n   public void canCreateProjectAndVersion() {\n      HomePage homePage = new LoginAction().signIn(\"admin\", \"admin\");\n      ProjectAction projectAction = new ProjectAction();\n      ProjectPage projectPage = projectAction.createNewProject(homePage, \"plurals\", \"plural project\");\n\n      assertThat(projectPage.getProjectId(), Matchers.equalTo(\"Project ID: plurals\"));\n      assertThat(projectPage.getProjectName(), Matchers.equalTo(\"Name: plural project\"));\n\n      ProjectVersionPage projectVersionPage = projectAction.createNewProjectVersion(projectPage, \"master\");\n\n      //can go to project version page\n\n      String url = projectAction.toUrl(\"project/view/plurals/master\");\n\n      projectVersionPage = homePage.goToUrl(url, projectVersionPage);\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public CreateVersionPage setVersionId(String versionId)\n   {\n      versionIdField.sendKeys(versionId);\n      return this;\n   }","id":90121,"modified_method":"public CreateVersionPage inputVersionId(String versionId)\n   {\n      versionIdField.sendKeys(versionId);\n      return this;\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public SignInPage clickSignInLink()\n   {\n      LOGGER.info(\"header text: {}\", headerTopRightDiv.getText());\n      List<WebElement> links = headerTopRightDiv.findElements(By.tagName(\"a\"));\n      WebElement firstLink = links.get(0);\n      if (firstLink.getText().equalsIgnoreCase(\"Sign In\"))\n      {\n          firstLink.click();\n      }\n      //else already signed in, no op\n      return PageFactory.initElements(getDriver(), SignInPage.class);\n   }","id":90122,"modified_method":"public SignInPage clickSignInLink()\n   {\n      LOGGER.info(\"header text: {}\", headerTopRightDiv.getText());\n      List<WebElement> links = headerTopRightDiv.findElements(By.tagName(\"a\"));\n      WebElement firstLink = links.get(0);\n      if (firstLink.getText().equalsIgnoreCase(\"Sign In\"))\n      {\n          firstLink.click();\n      }\n      //else already signed in, no op\n      return new SignInPage(getDriver());\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public ProjectsPage goToProjects()\n   {\n      projectsLink.click();\n      return PageFactory.initElements(getDriver(), ProjectsPage.class);\n   }","id":90123,"modified_method":"public ProjectsPage goToProjects()\n   {\n      projectsLink.click();\n      return new ProjectsPage(getDriver());\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public CreateVersionPage clickCreateVersionLink()\n   {\n      createVersionLink.click();\n      return PageFactory.initElements(getDriver(), CreateVersionPage.class);\n   }","id":90124,"modified_method":"public CreateVersionPage clickCreateVersionLink()\n   {\n      createVersionLink.click();\n      return new CreateVersionPage(getDriver());\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public CreateProjectPage clickOnCreateProjectLink()\n   {\n      createProjectActionLink.click();\n      return PageFactory.initElements(getDriver(), CreateProjectPage.class);\n   }","id":90125,"modified_method":"public CreateProjectPage clickOnCreateProjectLink()\n   {\n      createProjectActionLink.click();\n      return new CreateProjectPage(getDriver());\n   }","commit_id":"cb312e8bf3f745a675cc710a85c0d4e12e438fa7","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void convert(String actionName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"actionName\", actionName);\n\n\t\tprocessTemplate(\"action.ftl\", context);\n\t}","id":90126,"modified_method":"public void convert(String actionName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"actionName\", actionName);\n\n\t\tString content = processTemplate(\"action.ftl\", context);\n\n\t\tseleniumBuilderFileUtil.writeFile(\n\t\t\tseleniumBuilderContext.getActionJavaFileName(actionName), content,\n\t\t\ttrue);\n\t}","commit_id":"b6c794a11a5b7ce0b44acb748fb09ac2450c9648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void convert(String macroName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"macroName\", macroName);\n\n\t\tprocessTemplate(\"macro.ftl\", context);\n\t}","id":90127,"modified_method":"public void convert(String macroName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"macroName\", macroName);\n\n\t\tString content = processTemplate(\"macro.ftl\", context);\n\n\t\tseleniumBuilderFileUtil.writeFile(\n\t\t\tseleniumBuilderContext.getMacroJavaFileName(macroName), content,\n\t\t\ttrue);\n\t}","commit_id":"b6c794a11a5b7ce0b44acb748fb09ac2450c9648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void convert(String pathName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"pathName\", pathName);\n\n\t\tprocessTemplate(\"path.ftl\", context);\n\t}","id":90128,"modified_method":"public void convert(String pathName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"pathName\", pathName);\n\n\t\tString content = processTemplate(\"path.ftl\", context);\n\n\t\tseleniumBuilderFileUtil.writeFile(\n\t\t\tseleniumBuilderContext.getPathJavaFileName(pathName), content,\n\t\t\ttrue);\n\t}","commit_id":"b6c794a11a5b7ce0b44acb748fb09ac2450c9648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public SeleniumBuilderContext(String baseDir) throws Exception {\n\t\t_baseDir = baseDir;\n\n\t\t_seleniumBuilderFileUtil = new SeleniumBuilderFileUtil(_baseDir);\n\n\t\tDirectoryScanner directoryScanner = new DirectoryScanner();\n\n\t\tdirectoryScanner.setBasedir(_baseDir);\n\t\tdirectoryScanner.setIncludes(\n\t\t\tnew String[] {\n\t\t\t\t\"**\\\\*.action\", \"**\\\\*.function\", \"**\\\\*.macro\", \"**\\\\*.path\",\n\t\t\t\t\"**\\\\*.testcase\", \"**\\\\*.testsuite\"\n\t\t\t});\n\n\t\tdirectoryScanner.scan();\n\n\t\tString[] fileNames = directoryScanner.getIncludedFiles();\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tfileName = _normalizeFileName(fileName);\n\n\t\t\tif (fileName.endsWith(\".action\")) {\n\t\t\t\tString actionName = _getName(fileName);\n\n\t\t\t\t_actionFileNames.put(actionName, fileName);\n\n\t\t\t\tif (_actionNames.contains(actionName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + actionName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_actionRootElements.put(actionName, _getRootElement(fileName));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".function\")) {\n\t\t\t\tString functionName = _getName(fileName);\n\n\t\t\t\t_functionClassNames.put(functionName, _getClassName(fileName));\n\n\t\t\t\t_functionFileNames.put(functionName, fileName);\n\n\t\t\t\t_functionJavaFileNames.put(\n\t\t\t\t\tfunctionName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_functionNames.contains(functionName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + functionName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_functionNames.add(functionName);\n\n\t\t\t\t_functionPackageNames.put(\n\t\t\t\t\tfunctionName, _getPackageName(fileName));\n\n\t\t\t\t_functionReturnTypes.put(\n\t\t\t\t\tfunctionName, _getReturnType(functionName));\n\n\t\t\t\tElement rootElement = _getRootElement(fileName);\n\n\t\t\t\t_functionRootElements.put(functionName, rootElement);\n\n\t\t\t\t_functionSimpleClassNames.put(\n\t\t\t\t\tfunctionName, _getSimpleClassName(fileName));\n\n\t\t\t\t_functionTargetCounts.put(\n\t\t\t\t\tfunctionName, _getTargetCount(rootElement));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".macro\")) {\n\t\t\t\tString macroName = _getName(fileName);\n\n\t\t\t\t_macroClassNames.put(macroName, _getClassName(fileName));\n\n\t\t\t\t_macroFileNames.put(macroName, fileName);\n\n\t\t\t\t_macroJavaFileNames.put(macroName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_macroNames.contains(macroName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + macroName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_macroNames.add(macroName);\n\n\t\t\t\t_macroPackageNames.put(macroName, _getPackageName(fileName));\n\n\t\t\t\t_macroSimpleClassNames.put(\n\t\t\t\t\tmacroName, _getSimpleClassName(fileName));\n\n\t\t\t\t_macroRootElements.put(macroName, _getRootElement(fileName));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".path\")) {\n\t\t\t\tString pathName = _getName(fileName);\n\n\t\t\t\t_actionClassNames.put(\n\t\t\t\t\tpathName, _getClassName(fileName, \"Action\"));\n\n\t\t\t\t_actionJavaFileNames.put(pathName, _getJavaFileName(fileName));\n\n\t\t\t\t_actionNames.add(pathName);\n\n\t\t\t\t_actionPackageNames.put(pathName, _getPackageName(fileName));\n\n\t\t\t\t_actionSimpleClassNames.put(\n\t\t\t\t\tpathName, _getSimpleClassName(fileName, \"Action\"));\n\n\t\t\t\t_pathClassNames.put(pathName, _getClassName(fileName));\n\n\t\t\t\t_pathFileNames.put(pathName, fileName);\n\n\t\t\t\t_pathJavaFileNames.put(pathName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_pathNames.contains(pathName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + pathName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_pathNames.add(pathName);\n\n\t\t\t\t_pathPackageNames.put(pathName, _getPackageName(fileName));\n\n\t\t\t\t_pathRootElements.put(pathName, _getRootElement(fileName));\n\n\t\t\t\t_pathSimpleClassNames.put(\n\t\t\t\t\tpathName, _getSimpleClassName(fileName));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".testcase\")) {\n\t\t\t\tString testCaseName = _getName(fileName);\n\n\t\t\t\t_testCaseClassNames.put(testCaseName, _getClassName(fileName));\n\n\t\t\t\t_testCaseFileNames.put(testCaseName, fileName);\n\n\t\t\t\t_testCaseJavaFileNames.put(\n\t\t\t\t\ttestCaseName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_testCaseNames.contains(testCaseName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + testCaseName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_testCaseNames.add(testCaseName);\n\n\t\t\t\t_testCasePackageNames.put(\n\t\t\t\t\ttestCaseName, _getPackageName(fileName));\n\n\t\t\t\t_testCaseRootElements.put(\n\t\t\t\t\ttestCaseName, _getRootElement(fileName));\n\n\t\t\t\t_testCaseSimpleClassNames.put(\n\t\t\t\t\ttestCaseName, _getSimpleClassName(fileName));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".testsuite\")) {\n\t\t\t\tString testSuiteName = _getName(fileName);\n\n\t\t\t\t_testSuiteClassNames.put(\n\t\t\t\t\ttestSuiteName, _getClassName(fileName));\n\n\t\t\t\t_testSuiteFileNames.put(testSuiteName, fileName);\n\n\t\t\t\t_testSuiteJavaFileNames.put(\n\t\t\t\t\ttestSuiteName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_testSuiteNames.contains(testSuiteName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + testSuiteName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_testSuiteNames.add(testSuiteName);\n\n\t\t\t\t_testSuitePackageNames.put(\n\t\t\t\t\ttestSuiteName, _getPackageName(fileName));\n\n\t\t\t\t_testSuiteRootElements.put(\n\t\t\t\t\ttestSuiteName, _getRootElement(fileName));\n\n\t\t\t\t_testSuiteSimpleClassNames.put(\n\t\t\t\t\ttestSuiteName, _getSimpleClassName(fileName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid file \" + fileName);\n\t\t\t}\n\t\t}\n\t}","id":90129,"modified_method":"public SeleniumBuilderContext(String baseDir) throws Exception {\n\t\t_baseDir = baseDir;\n\n\t\t_seleniumBuilderFileUtil = new SeleniumBuilderFileUtil(_baseDir);\n\n\t\tDirectoryScanner directoryScanner = new DirectoryScanner();\n\n\t\tdirectoryScanner.setBasedir(_baseDir);\n\t\tdirectoryScanner.setIncludes(\n\t\t\tnew String[] {\n\t\t\t\t\"**\\\\*.action\", \"**\\\\*.function\", \"**\\\\*.macro\", \"**\\\\*.path\",\n\t\t\t\t\"**\\\\*.testcase\", \"**\\\\*.testsuite\"\n\t\t\t});\n\n\t\tdirectoryScanner.scan();\n\n\t\tString[] fileNames = directoryScanner.getIncludedFiles();\n\n\t\tfor (String fileName : fileNames) {\n\t\t\tfileName = _normalizeFileName(fileName);\n\n\t\t\tif (fileName.endsWith(\".action\")) {\n\t\t\t\tString actionName = _getName(fileName);\n\n\t\t\t\t_actionFileNames.put(actionName, fileName);\n\n\t\t\t\tif (_actionNames.contains(actionName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + actionName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_actionRootElements.put(actionName, _getRootElement(fileName));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".function\")) {\n\t\t\t\tString functionName = _getName(fileName);\n\n\t\t\t\t_functionClassNames.put(functionName, _getClassName(fileName));\n\n\t\t\t\t_functionFileNames.put(functionName, fileName);\n\n\t\t\t\t_functionJavaFileNames.put(\n\t\t\t\t\tfunctionName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_functionNames.contains(functionName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + functionName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_functionNames.add(functionName);\n\n\t\t\t\t_functionPackageNames.put(\n\t\t\t\t\tfunctionName, _getPackageName(fileName));\n\n\t\t\t\t_functionReturnTypes.put(\n\t\t\t\t\tfunctionName, _getReturnType(functionName));\n\n\t\t\t\tElement rootElement = _getRootElement(fileName);\n\n\t\t\t\t_functionRootElements.put(functionName, rootElement);\n\n\t\t\t\t_functionSimpleClassNames.put(\n\t\t\t\t\tfunctionName, _getSimpleClassName(fileName));\n\n\t\t\t\t_functionTargetCounts.put(\n\t\t\t\t\tfunctionName, _getTargetCount(rootElement));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".macro\")) {\n\t\t\t\tString macroName = _getName(fileName);\n\n\t\t\t\t_macroClassNames.put(macroName, _getClassName(fileName));\n\n\t\t\t\t_macroFileNames.put(macroName, fileName);\n\n\t\t\t\t_macroJavaFileNames.put(macroName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_macroNames.contains(macroName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + macroName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_macroNames.add(macroName);\n\n\t\t\t\t_macroPackageNames.put(macroName, _getPackageName(fileName));\n\n\t\t\t\t_macroSimpleClassNames.put(\n\t\t\t\t\tmacroName, _getSimpleClassName(fileName));\n\n\t\t\t\t_macroRootElements.put(macroName, _getRootElement(fileName));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".path\")) {\n\t\t\t\tString pathName = _getName(fileName);\n\n\t\t\t\t_actionClassNames.put(\n\t\t\t\t\tpathName, _getClassName(fileName, \"Action\"));\n\n\t\t\t\t_actionJavaFileNames.put(\n\t\t\t\t\tpathName, _getJavaFileName(fileName, \"Action\"));\n\n\t\t\t\t_actionNames.add(pathName);\n\n\t\t\t\t_actionPackageNames.put(pathName, _getPackageName(fileName));\n\n\t\t\t\t_actionSimpleClassNames.put(\n\t\t\t\t\tpathName, _getSimpleClassName(fileName, \"Action\"));\n\n\t\t\t\t_pathClassNames.put(pathName, _getClassName(fileName));\n\n\t\t\t\t_pathFileNames.put(pathName, fileName);\n\n\t\t\t\t_pathJavaFileNames.put(pathName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_pathNames.contains(pathName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + pathName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_pathNames.add(pathName);\n\n\t\t\t\t_pathPackageNames.put(pathName, _getPackageName(fileName));\n\n\t\t\t\t_pathRootElements.put(pathName, _getRootElement(fileName));\n\n\t\t\t\t_pathSimpleClassNames.put(\n\t\t\t\t\tpathName, _getSimpleClassName(fileName));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".testcase\")) {\n\t\t\t\tString testCaseName = _getName(fileName);\n\n\t\t\t\t_testCaseClassNames.put(testCaseName, _getClassName(fileName));\n\n\t\t\t\t_testCaseFileNames.put(testCaseName, fileName);\n\n\t\t\t\t_testCaseJavaFileNames.put(\n\t\t\t\t\ttestCaseName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_testCaseNames.contains(testCaseName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + testCaseName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_testCaseNames.add(testCaseName);\n\n\t\t\t\t_testCasePackageNames.put(\n\t\t\t\t\ttestCaseName, _getPackageName(fileName));\n\n\t\t\t\t_testCaseRootElements.put(\n\t\t\t\t\ttestCaseName, _getRootElement(fileName));\n\n\t\t\t\t_testCaseSimpleClassNames.put(\n\t\t\t\t\ttestCaseName, _getSimpleClassName(fileName));\n\t\t\t}\n\t\t\telse if (fileName.endsWith(\".testsuite\")) {\n\t\t\t\tString testSuiteName = _getName(fileName);\n\n\t\t\t\t_testSuiteClassNames.put(\n\t\t\t\t\ttestSuiteName, _getClassName(fileName));\n\n\t\t\t\t_testSuiteFileNames.put(testSuiteName, fileName);\n\n\t\t\t\t_testSuiteJavaFileNames.put(\n\t\t\t\t\ttestSuiteName, _getJavaFileName(fileName));\n\n\t\t\t\tif (_testSuiteNames.contains(testSuiteName)) {\n\t\t\t\t\tthrow new Exception(\n\t\t\t\t\t\t\"Duplicate name \" + testSuiteName + \" at \" + fileName);\n\t\t\t\t}\n\n\t\t\t\t_testSuiteNames.add(testSuiteName);\n\n\t\t\t\t_testSuitePackageNames.put(\n\t\t\t\t\ttestSuiteName, _getPackageName(fileName));\n\n\t\t\t\t_testSuiteRootElements.put(\n\t\t\t\t\ttestSuiteName, _getRootElement(fileName));\n\n\t\t\t\t_testSuiteSimpleClassNames.put(\n\t\t\t\t\ttestSuiteName, _getSimpleClassName(fileName));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid file \" + fileName);\n\t\t\t}\n\t\t}\n\t}","commit_id":"b6c794a11a5b7ce0b44acb748fb09ac2450c9648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void convert(String testCaseName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"testCaseName\", testCaseName);\n\n\t\tprocessTemplate(\"testcase.ftl\", context);\n\t}","id":90130,"modified_method":"public void convert(String testCaseName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"testCaseName\", testCaseName);\n\n\t\tString content = processTemplate(\"testcase.ftl\", context);\n\n\t\tseleniumBuilderFileUtil.writeFile(\n\t\t\tseleniumBuilderContext.getTestCaseJavaFileName(testCaseName),\n\t\t\tcontent, true);\n\t}","commit_id":"b6c794a11a5b7ce0b44acb748fb09ac2450c9648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void convert(String testSuiteName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"testSuiteName\", testSuiteName);\n\n\t\tprocessTemplate(\"testsuite.ftl\", context);\n\t}","id":90131,"modified_method":"public void convert(String testSuiteName) throws Exception {\n\t\tMap<String, Object> context = getContext();\n\n\t\tcontext.put(\"testSuiteName\", testSuiteName);\n\n\t\tString content = processTemplate(\"testsuite.ftl\", context);\n\n\t\tseleniumBuilderFileUtil.writeFile(\n\t\t\tseleniumBuilderContext.getTestSuiteJavaFileName(testSuiteName),\n\t\t\tcontent, true);\n\t}","commit_id":"b6c794a11a5b7ce0b44acb748fb09ac2450c9648","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean isReplaceableImplicitReturn(\n            PsiIfStatement ifStatement){\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsForward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(nextStatement instanceof PsiReturnStatement)){\n            return false;\n        }\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        if(!(thenBranch instanceof PsiReturnStatement)){\n            return false;\n        }\n        final PsiExpression thenReturn =\n                ((PsiReturnStatement) thenBranch).getReturnValue();\n        if(thenReturn == null){\n            return false;\n        }\n        final PsiType thenType = thenReturn.getType();\n        if(thenType == null){\n            return false;\n        }\n        final PsiExpression elseReturn =\n                ((PsiReturnStatement) nextStatement).getReturnValue();\n        if(elseReturn == null){\n            return false;\n        }\n        final PsiType elseType = elseReturn.getType();\n        if(elseType == null){\n            return false;\n        }\n        return thenType.isAssignableFrom(elseType) ||\n                elseType.isAssignableFrom(thenType);\n    }","id":90132,"modified_method":"public static boolean isReplaceableImplicitReturn(\n            PsiIfStatement ifStatement){\n        if(ifStatement.getElseBranch() != null){\n            return false;\n        }\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        if(!(thenBranch instanceof PsiReturnStatement)){\n            return false;\n        }\n        final PsiReturnStatement thenReturnStatement =\n                (PsiReturnStatement)thenBranch;\n        final PsiExpression thenReturn =\n                thenReturnStatement.getReturnValue();\n        if(thenReturn == null){\n            return false;\n        }\n        final PsiType thenType = thenReturn.getType();\n        if(thenType == null){\n            return false;\n        }\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsForward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(nextStatement instanceof PsiReturnStatement)){\n            return false;\n        }\n        final PsiReturnStatement elseReturnStatement =\n                (PsiReturnStatement)nextStatement;\n        final PsiExpression elseReturn =\n                elseReturnStatement.getReturnValue();\n        if(elseReturn == null){\n            return false;\n        }\n        final PsiType elseType = elseReturn.getType();\n        if(elseType == null){\n            return false;\n        }\n        return thenType.isAssignableFrom(elseType) ||\n                elseType.isAssignableFrom(thenType);\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n        final PsiElement parent = token.getParent();\n        if(!(parent instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement ifStatement = (PsiIfStatement) parent;\n        if(ErrorUtil.containsError(ifStatement)){\n            return false;\n        }\n        final PsiExpression condition = ifStatement.getCondition();\n        if(condition == null || !condition.isValid()){\n            return false;\n        }\n        if(isReplaceableAssignment(ifStatement)){\n            return true;\n        }\n        if(isReplaceableReturn(ifStatement)){\n            return true;\n        }\n        return isReplaceableImplicitReturn(ifStatement);\n    }","id":90133,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n        final PsiElement parent = token.getParent();\n        if(!(parent instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement ifStatement = (PsiIfStatement) parent;\n        if(ErrorUtil.containsError(ifStatement)){\n            return false;\n        }\n        final PsiExpression condition = ifStatement.getCondition();\n        if(condition == null){\n            return false;\n        }\n        if(isReplaceableAssignment(ifStatement)){\n            return true;\n        }\n        if(isReplaceableReturn(ifStatement)){\n            return true;\n        }\n        return isReplaceableImplicitReturn(ifStatement);\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSimplifiableAssignmentNegated(\n            PsiIfStatement ifStatement){\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        PsiStatement elseBranch = ifStatement.getElseBranch();\n        elseBranch = ConditionalUtils.stripBraces(elseBranch);\n        if(ConditionalUtils.isAssignment(thenBranch, \"false\") &&\n                ConditionalUtils.isAssignment(elseBranch, \"true\")){\n            final PsiAssignmentExpression thenExpression =\n                    (PsiAssignmentExpression)\n                            ((PsiExpressionStatement) thenBranch).getExpression();\n            final PsiAssignmentExpression elseExpression =\n                    (PsiAssignmentExpression)\n                            ((PsiExpressionStatement) elseBranch).getExpression();\n            final PsiJavaToken thenSign = thenExpression.getOperationSign();\n            final PsiJavaToken elseSign = elseExpression.getOperationSign();\n            final IElementType thenTokenType = thenSign.getTokenType();\n            if(!thenTokenType.equals(elseSign.getTokenType())){\n                return false;\n            }\n            final PsiExpression thenLhs = thenExpression.getLExpression();\n            final PsiExpression elseLhs = elseExpression.getLExpression();\n            return EquivalenceChecker.expressionsAreEquivalent(thenLhs,\n                                                               elseLhs);\n        } else{\n            return false;\n        }\n    }","id":90134,"modified_method":"public static boolean isSimplifiableAssignmentNegated(\n            PsiIfStatement ifStatement){\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        PsiStatement elseBranch = ifStatement.getElseBranch();\n        elseBranch = ConditionalUtils.stripBraces(elseBranch);\n        if(!ConditionalUtils.isAssignment(thenBranch, \"false\") ||\n                !ConditionalUtils.isAssignment(elseBranch, \"true\")){\n            return false;\n        }\n        final PsiExpressionStatement thenExpressionStatement =\n                (PsiExpressionStatement)thenBranch;\n        final PsiAssignmentExpression thenExpression =\n                (PsiAssignmentExpression)\n                        thenExpressionStatement.getExpression();\n        final PsiExpressionStatement elseExpressionStatement =\n                (PsiExpressionStatement)elseBranch;\n        final PsiAssignmentExpression elseExpression =\n                (PsiAssignmentExpression)\n                        elseExpressionStatement.getExpression();\n        final PsiJavaToken thenSign = thenExpression.getOperationSign();\n        final PsiJavaToken elseSign = elseExpression.getOperationSign();\n        final IElementType thenTokenType = thenSign.getTokenType();\n        if(!thenTokenType.equals(elseSign.getTokenType())){\n                return false;\n        }\n        final PsiExpression thenLhs = thenExpression.getLExpression();\n        final PsiExpression elseLhs = elseExpression.getLExpression();\n        return EquivalenceChecker.expressionsAreEquivalent(thenLhs, elseLhs);\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSimplifiableImplicitReturn(\n            PsiIfStatement ifStatement){\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsForward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(nextStatement instanceof PsiStatement)){\n            return false;\n        }\n        final PsiStatement elseBranch = (PsiStatement) nextStatement;\n        return ConditionalUtils.isReturn(thenBranch, \"true\")\n                && ConditionalUtils.isReturn(elseBranch, \"false\");\n    }","id":90135,"modified_method":"public static boolean isSimplifiableImplicitReturn(\n            PsiIfStatement ifStatement){\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        if(ifStatement.getElseBranch() != null){\n            return false;\n        }\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsForward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(nextStatement instanceof PsiStatement)){\n            return false;\n        }\n        final PsiStatement elseBranch = (PsiStatement) nextStatement;\n        return ConditionalUtils.isReturn(thenBranch, \"true\")\n                && ConditionalUtils.isReturn(elseBranch, \"false\");\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n\n        final PsiElement parent = token.getParent();\n        if(!(parent instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement ifStatement = (PsiIfStatement) parent;\n\n        if(ErrorUtil.containsError(ifStatement)){\n            return false;\n        }\n        final PsiExpression condition = ifStatement.getCondition();\n        if(condition == null || !condition.isValid()){\n            return false;\n        }\n        if(isSimplifiableAssignment(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableReturn(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableImplicitReturn(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableAssignmentNegated(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableReturnNegated(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableImplicitReturnNegated(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableImplicitAssignment(ifStatement)){\n            return true;\n        }\n        return isSimplifiableImplicitAssignmentNegated(ifStatement);\n    }","id":90136,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n        final PsiElement parent = token.getParent();\n        if(!(parent instanceof PsiIfStatement)){\n            return false;\n        }\n        final PsiIfStatement ifStatement = (PsiIfStatement) parent;\n        if(ErrorUtil.containsError(ifStatement)){\n            return false;\n        }\n        final PsiExpression condition = ifStatement.getCondition();\n        if(condition == null){\n            return false;\n        }\n        if(isSimplifiableAssignment(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableReturn(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableImplicitReturn(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableAssignmentNegated(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableReturnNegated(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableImplicitReturnNegated(ifStatement)){\n            return true;\n        }\n        if(isSimplifiableImplicitAssignment(ifStatement)){\n            return true;\n        }\n        return isSimplifiableImplicitAssignmentNegated(ifStatement);\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSimplifiableAssignment(PsiIfStatement ifStatement){\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        PsiStatement elseBranch = ifStatement.getElseBranch();\n        elseBranch = ConditionalUtils.stripBraces(elseBranch);\n        if(ConditionalUtils.isAssignment(thenBranch, \"true\") &&\n                ConditionalUtils.isAssignment(elseBranch, \"false\")){\n            final PsiExpressionStatement thenExpressionStatement =\n                    (PsiExpressionStatement)thenBranch;\n            final PsiAssignmentExpression thenExpression =\n                    (PsiAssignmentExpression)\n                            thenExpressionStatement.getExpression();\n            final PsiExpressionStatement elseExpressionStatement =\n                    (PsiExpressionStatement)elseBranch;\n            final PsiAssignmentExpression elseExpression =\n                    (PsiAssignmentExpression)\n                            elseExpressionStatement.getExpression();\n            final PsiJavaToken thenSign = thenExpression.getOperationSign();\n            final PsiJavaToken elseSign = elseExpression.getOperationSign();\n            final IElementType tokenType = thenSign.getTokenType();\n            if(!tokenType.equals(elseSign.getTokenType())){\n                return false;\n            }\n            final PsiExpression thenLhs = thenExpression.getLExpression();\n            final PsiExpression elseLhs = elseExpression.getLExpression();\n            return EquivalenceChecker.expressionsAreEquivalent(thenLhs,\n                                                               elseLhs);\n        } else{\n            return false;\n        }\n    }","id":90137,"modified_method":"public static boolean isSimplifiableAssignment(PsiIfStatement ifStatement){\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        PsiStatement elseBranch = ifStatement.getElseBranch();\n        elseBranch = ConditionalUtils.stripBraces(elseBranch);\n        if(!(ConditionalUtils.isAssignment(thenBranch, \"true\") &&\n                ConditionalUtils.isAssignment(elseBranch, \"false\"))){\n            return false;\n        }\n        final PsiExpressionStatement thenExpressionStatement =\n                (PsiExpressionStatement)thenBranch;\n        final PsiAssignmentExpression thenExpression =\n                (PsiAssignmentExpression)\n                        thenExpressionStatement.getExpression();\n        final PsiExpressionStatement elseExpressionStatement =\n                (PsiExpressionStatement)elseBranch;\n        final PsiAssignmentExpression elseExpression =\n                (PsiAssignmentExpression)\n                        elseExpressionStatement.getExpression();\n        final PsiJavaToken thenSign = thenExpression.getOperationSign();\n        final PsiJavaToken elseSign = elseExpression.getOperationSign();\n        final IElementType thenTokenType = thenSign.getTokenType();\n        if(!thenTokenType.equals(elseSign.getTokenType())){\n                return false;\n        }\n        final PsiExpression thenLhs = thenExpression.getLExpression();\n        final PsiExpression elseLhs = elseExpression.getLExpression();\n        return EquivalenceChecker.expressionsAreEquivalent(thenLhs, elseLhs);\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSimplifiableImplicitReturnNegated(\n            PsiIfStatement ifStatement){\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsForward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(nextStatement instanceof PsiStatement)){\n            return false;\n        }\n        final PsiStatement elseBranch = (PsiStatement) nextStatement;\n        return ConditionalUtils.isReturn(thenBranch, \"false\")\n                && ConditionalUtils.isReturn(elseBranch, \"true\");\n    }","id":90138,"modified_method":"public static boolean isSimplifiableImplicitReturnNegated(\n            PsiIfStatement ifStatement){\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        if(ifStatement.getElseBranch() != null){\n            return false;\n        }\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsForward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(nextStatement instanceof PsiStatement)){\n            return false;\n        }\n        final PsiStatement elseBranch = (PsiStatement) nextStatement;\n        return ConditionalUtils.isReturn(thenBranch, \"false\")\n                && ConditionalUtils.isReturn(elseBranch, \"true\");\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSimplifiableImplicitAssignment(\n            PsiIfStatement ifStatement){\n        if(ifStatement.getElseBranch() != null){\n            return false;\n        }\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsBackward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(nextStatement instanceof PsiStatement)){\n            return false;\n        }\n        PsiStatement elseBranch = (PsiStatement) nextStatement;\n        elseBranch = ConditionalUtils.stripBraces(elseBranch);\n        if(ConditionalUtils.isAssignment(thenBranch, \"true\") &&\n                ConditionalUtils.isAssignment(elseBranch, \"false\")){\n            final PsiAssignmentExpression thenExpression =\n                    (PsiAssignmentExpression)\n                            ((PsiExpressionStatement) thenBranch).getExpression();\n            final PsiAssignmentExpression elseExpression =\n                    (PsiAssignmentExpression)\n                            ((PsiExpressionStatement) elseBranch).getExpression();\n            final PsiJavaToken thenSign = thenExpression.getOperationSign();\n            final PsiJavaToken elseSign = elseExpression.getOperationSign();\n            final IElementType thenTokenType = thenSign.getTokenType();\n            if(!thenTokenType.equals(elseSign.getTokenType())){\n                return false;\n            }\n            final PsiExpression thenLhs = thenExpression.getLExpression();\n            final PsiExpression elseLhs = elseExpression.getLExpression();\n            return EquivalenceChecker.expressionsAreEquivalent(thenLhs,\n                                                               elseLhs);\n        } else{\n            return false;\n        }\n    }","id":90139,"modified_method":"public static boolean isSimplifiableImplicitAssignment(\n            PsiIfStatement ifStatement){\n        if(ifStatement.getElseBranch() != null){\n            return false;\n        }\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        final PsiElement previousStatement =\n                PsiTreeUtil.skipSiblingsBackward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(previousStatement instanceof PsiStatement)){\n            return false;\n        }\n        PsiStatement elseBranch = (PsiStatement) previousStatement;\n        elseBranch = ConditionalUtils.stripBraces(elseBranch);\n        if(!ConditionalUtils.isAssignment(thenBranch, \"true\") ||\n                !ConditionalUtils.isAssignment(elseBranch, \"false\")){\n            return false;\n        }\n        final PsiAssignmentExpression thenExpression =\n                (PsiAssignmentExpression)\n                        ((PsiExpressionStatement) thenBranch).getExpression();\n        final PsiAssignmentExpression elseExpression =\n                (PsiAssignmentExpression)\n                        ((PsiExpressionStatement) elseBranch).getExpression();\n        final PsiJavaToken thenSign = thenExpression.getOperationSign();\n        final PsiJavaToken elseSign = elseExpression.getOperationSign();\n        final IElementType thenTokenType = thenSign.getTokenType();\n        if(!thenTokenType.equals(elseSign.getTokenType())){\n                return false;\n        }\n        final PsiExpression thenLhs = thenExpression.getLExpression();\n        final PsiExpression elseLhs = elseExpression.getLExpression();\n        return EquivalenceChecker.expressionsAreEquivalent(thenLhs, elseLhs);\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSimplifiableImplicitAssignmentNegated(\n            PsiIfStatement ifStatement){\n        if(ifStatement.getElseBranch() != null){\n            return false;\n        }\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        final PsiElement nextStatement =\n                PsiTreeUtil.skipSiblingsBackward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(nextStatement instanceof PsiStatement)){\n            return false;\n        }\n        PsiStatement elseBranch = (PsiStatement) nextStatement;\n        elseBranch = ConditionalUtils.stripBraces(elseBranch);\n        if(ConditionalUtils.isAssignment(thenBranch, \"false\") &&\n                ConditionalUtils.isAssignment(elseBranch, \"true\")){\n            final PsiExpressionStatement thenExpressionStatement =\n                    (PsiExpressionStatement)thenBranch;\n            final PsiAssignmentExpression thenExpression =\n                    (PsiAssignmentExpression)\n                            thenExpressionStatement.getExpression();\n            final PsiExpressionStatement elseExpressionStatement =\n                    (PsiExpressionStatement)elseBranch;\n            final PsiAssignmentExpression elseExpression =\n                    (PsiAssignmentExpression)\n                            elseExpressionStatement.getExpression();\n            final PsiJavaToken thenSign = thenExpression.getOperationSign();\n            final PsiJavaToken elseSign = elseExpression.getOperationSign();\n            final IElementType thenTokenType = thenSign.getTokenType();\n            if(!thenTokenType.equals(elseSign.getTokenType())){\n                return false;\n            }\n            final PsiExpression thenLhs = thenExpression.getLExpression();\n            final PsiExpression elseLhs = elseExpression.getLExpression();\n            return EquivalenceChecker.expressionsAreEquivalent(thenLhs,\n                                                               elseLhs);\n        } else{\n            return false;\n        }\n    }","id":90140,"modified_method":"public static boolean isSimplifiableImplicitAssignmentNegated(\n            PsiIfStatement ifStatement){\n        if(ifStatement.getElseBranch() != null){\n            return false;\n        }\n        PsiStatement thenBranch = ifStatement.getThenBranch();\n        thenBranch = ConditionalUtils.stripBraces(thenBranch);\n        final PsiElement previousStatement =\n                PsiTreeUtil.skipSiblingsBackward(ifStatement,\n                        PsiWhiteSpace.class);\n        if(!(previousStatement instanceof PsiStatement)){\n            return false;\n        }\n        PsiStatement elseBranch = (PsiStatement) previousStatement;\n        elseBranch = ConditionalUtils.stripBraces(elseBranch);\n        if(!ConditionalUtils.isAssignment(thenBranch, \"false\") ||\n                !ConditionalUtils.isAssignment(elseBranch, \"true\")){\n            return false;\n        }\n        final PsiExpressionStatement thenExpressionStatement =\n                (PsiExpressionStatement)thenBranch;\n        final PsiAssignmentExpression thenExpression =\n                (PsiAssignmentExpression)\n                        thenExpressionStatement.getExpression();\n        final PsiExpressionStatement elseExpressionStatement =\n                (PsiExpressionStatement)elseBranch;\n        final PsiAssignmentExpression elseExpression =\n                (PsiAssignmentExpression)\n                        elseExpressionStatement.getExpression();\n        final PsiJavaToken thenSign = thenExpression.getOperationSign();\n        final PsiJavaToken elseSign = elseExpression.getOperationSign();\n        final IElementType thenTokenType = thenSign.getTokenType();\n        if(!thenTokenType.equals(elseSign.getTokenType())){\n                return false;\n        }\n        final PsiExpression thenLhs = thenExpression.getLExpression();\n        final PsiExpression elseLhs = elseExpression.getLExpression();\n        return EquivalenceChecker.expressionsAreEquivalent(thenLhs, elseLhs);\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n        final IElementType tokenType = token.getTokenType();\n        if(!JavaTokenType.SWITCH_KEYWORD.equals(tokenType)){\n            return false;\n        }\n        final PsiElement parent = element.getParent();\n        if(!(parent instanceof PsiSwitchStatement)){\n            return false;\n        }\n        final PsiSwitchStatement switchStatement = (PsiSwitchStatement) parent;\n        final PsiExpression expression = switchStatement.getExpression();\n        if(expression == null || !expression.isValid()){\n            return false;\n        }\n        final PsiCodeBlock body = switchStatement.getBody();\n        if(body == null){\n            return false;\n        }\n        if(ErrorUtil.containsError(switchStatement)){\n            return false;\n        }\n        boolean hasLabel = false;\n        final PsiStatement[] statements = body.getStatements();\n        for(PsiStatement statement : statements){\n            if(statement instanceof PsiSwitchLabelStatement){\n                hasLabel = true;\n                break;\n            }\n        }\n        return hasLabel;\n    }","id":90141,"modified_method":"public boolean satisfiedBy(PsiElement element){\n        if(!(element instanceof PsiJavaToken)){\n            return false;\n        }\n        final PsiJavaToken token = (PsiJavaToken) element;\n        final IElementType tokenType = token.getTokenType();\n        if(!JavaTokenType.SWITCH_KEYWORD.equals(tokenType)){\n            return false;\n        }\n        final PsiElement parent = element.getParent();\n        if(!(parent instanceof PsiSwitchStatement)){\n            return false;\n        }\n        final PsiSwitchStatement switchStatement = (PsiSwitchStatement) parent;\n        final PsiExpression expression = switchStatement.getExpression();\n        if(expression == null){\n            return false;\n        }\n        final PsiCodeBlock body = switchStatement.getBody();\n        if(body == null){\n            return false;\n        }\n        if(ErrorUtil.containsError(switchStatement)){\n            return false;\n        }\n        boolean hasLabel = false;\n        final PsiStatement[] statements = body.getStatements();\n        for(PsiStatement statement : statements){\n            if(statement instanceof PsiSwitchLabelStatement){\n                hasLabel = true;\n                break;\n            }\n        }\n        return hasLabel;\n    }","commit_id":"298806c50bc9313582eae04389717621f74cc4d4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType getVariableTypeByExpressionType(final PsiType type) {\n    PsiType transformed = type.accept(new PsiTypeVisitor<PsiType>() {\n      @Override\n      public PsiType visitArrayType(PsiArrayType arrayType) {\n        PsiType componentType = arrayType.getComponentType();\n        PsiType type = componentType.accept(this);\n        if (type == componentType) return arrayType;\n        return type.createArrayType();\n      }\n\n      @Override\n      public PsiType visitType(PsiType type) {\n        return type;\n      }\n\n      @Override\n      public PsiType visitWildcardType(final PsiWildcardType wildcardType) {\n        final PsiType bound = wildcardType.getBound();\n        PsiManager manager = wildcardType.getManager();\n        if (bound != null) {\n          final PsiType acceptedBound = bound.accept(this);\n          if (acceptedBound instanceof PsiWildcardType) {\n            if (((PsiWildcardType)acceptedBound).isExtends() != wildcardType.isExtends()) return PsiWildcardType.createUnbounded(manager);\n            return acceptedBound;\n          }\n          if (wildcardType.isExtends() && acceptedBound.equalsToText(CommonClassNames.JAVA_LANG_OBJECT)) return PsiWildcardType.createUnbounded(manager);\n          if (acceptedBound.equals(bound)) return wildcardType;\n          return wildcardType.isExtends()\n                 ? PsiWildcardType.createExtends(manager, acceptedBound)\n                 : PsiWildcardType.createSuper(manager, acceptedBound);\n        }\n        return wildcardType;\n      }\n\n      @Override\n      public PsiType visitCapturedWildcardType(PsiCapturedWildcardType capturedWildcardType) {\n        return capturedWildcardType.getWildcard().accept(this);\n      }\n\n      @Override\n      public PsiType visitClassType(PsiClassType classType) {\n        PsiClassType.ClassResolveResult resolveResult = classType.resolveGenerics();\n        PsiClass aClass = resolveResult.getElement();\n        if (aClass == null) return classType;\n        boolean toExtend = false;\n        PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n        for (PsiTypeParameter typeParameter : PsiUtil.typeParametersIterable(aClass)) {\n          PsiType typeArgument = resolveResult.getSubstitutor().substitute(typeParameter);\n          if (typeArgument instanceof PsiCapturedWildcardType) toExtend = true;\n          if (typeArgument instanceof PsiWildcardType && ((PsiWildcardType)typeArgument).getBound() instanceof PsiIntersectionType) {\n            toExtend = true;\n          }\n          PsiType toPut;\n          if (typeArgument == null) {\n            toPut = null;\n          }\n          else {\n            final PsiType accepted = typeArgument.accept(this);\n            if (typeArgument instanceof PsiIntersectionType) {\n              toPut = PsiWildcardType.createExtends(typeParameter.getManager(), accepted);\n            }\n            else {\n              toPut = accepted;\n            }\n          }\n          LOG.assertTrue(toPut == null || toPut.isValid(), toPut);\n          substitutor = substitutor.put(typeParameter, toPut);\n        }\n        final PsiAnnotation[] applicableAnnotations = classType.getApplicableAnnotations();\n        if (substitutor == PsiSubstitutor.EMPTY && !toExtend && applicableAnnotations.length == 0 && !(aClass instanceof PsiTypeParameter)) return classType;\n        PsiManager manager = aClass.getManager();\n        PsiType result = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory()\n          .createType(aClass, substitutor, PsiUtil.getLanguageLevel(aClass), applicableAnnotations);\n        if (toExtend) result = PsiWildcardType.createExtends(manager, result);\n        return result;\n      }\n    });\n\n    PsiType componentType = transformed != null ? transformed.getDeepComponentType() : null;\n    if (componentType instanceof PsiWildcardType) {\n      componentType = ((PsiWildcardType)componentType).getExtendsBound();\n      int dims = transformed.getArrayDimensions();\n      for (int i = 0; i < dims; i++) componentType = componentType.createArrayType();\n      return componentType;\n    }\n\n    return transformed;\n  }","id":90142,"modified_method":"@Nullable\n  public static PsiType getVariableTypeByExpressionType(@Nullable final PsiType type) {\n    if (type == null) return null;\n    PsiType transformed = type.accept(new PsiTypeVisitor<PsiType>() {\n      @Override\n      public PsiType visitArrayType(PsiArrayType arrayType) {\n        PsiType componentType = arrayType.getComponentType();\n        PsiType type = componentType.accept(this);\n        if (type == componentType) return arrayType;\n        return type.createArrayType();\n      }\n\n      @Override\n      public PsiType visitType(PsiType type) {\n        return type;\n      }\n\n      @Override\n      public PsiType visitWildcardType(final PsiWildcardType wildcardType) {\n        final PsiType bound = wildcardType.getBound();\n        PsiManager manager = wildcardType.getManager();\n        if (bound != null) {\n          final PsiType acceptedBound = bound.accept(this);\n          if (acceptedBound instanceof PsiWildcardType) {\n            if (((PsiWildcardType)acceptedBound).isExtends() != wildcardType.isExtends()) return PsiWildcardType.createUnbounded(manager);\n            return acceptedBound;\n          }\n          if (wildcardType.isExtends() && acceptedBound.equalsToText(CommonClassNames.JAVA_LANG_OBJECT)) return PsiWildcardType.createUnbounded(manager);\n          if (acceptedBound.equals(bound)) return wildcardType;\n          return wildcardType.isExtends()\n                 ? PsiWildcardType.createExtends(manager, acceptedBound)\n                 : PsiWildcardType.createSuper(manager, acceptedBound);\n        }\n        return wildcardType;\n      }\n\n      @Override\n      public PsiType visitCapturedWildcardType(PsiCapturedWildcardType capturedWildcardType) {\n        return capturedWildcardType.getWildcard().accept(this);\n      }\n\n      @Override\n      public PsiType visitClassType(PsiClassType classType) {\n        PsiClassType.ClassResolveResult resolveResult = classType.resolveGenerics();\n        PsiClass aClass = resolveResult.getElement();\n        if (aClass == null) return classType;\n        boolean toExtend = false;\n        PsiSubstitutor substitutor = PsiSubstitutor.EMPTY;\n        for (PsiTypeParameter typeParameter : PsiUtil.typeParametersIterable(aClass)) {\n          PsiType typeArgument = resolveResult.getSubstitutor().substitute(typeParameter);\n          if (typeArgument instanceof PsiCapturedWildcardType) toExtend = true;\n          if (typeArgument instanceof PsiWildcardType && ((PsiWildcardType)typeArgument).getBound() instanceof PsiIntersectionType) {\n            toExtend = true;\n          }\n          PsiType toPut;\n          if (typeArgument == null) {\n            toPut = null;\n          }\n          else {\n            final PsiType accepted = typeArgument.accept(this);\n            if (typeArgument instanceof PsiIntersectionType) {\n              toPut = PsiWildcardType.createExtends(typeParameter.getManager(), accepted);\n            }\n            else {\n              toPut = accepted;\n            }\n          }\n          LOG.assertTrue(toPut == null || toPut.isValid(), toPut);\n          substitutor = substitutor.put(typeParameter, toPut);\n        }\n        final PsiAnnotation[] applicableAnnotations = classType.getApplicableAnnotations();\n        if (substitutor == PsiSubstitutor.EMPTY && !toExtend && applicableAnnotations.length == 0 && !(aClass instanceof PsiTypeParameter)) return classType;\n        PsiManager manager = aClass.getManager();\n        PsiType result = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory()\n          .createType(aClass, substitutor, PsiUtil.getLanguageLevel(aClass), applicableAnnotations);\n        if (toExtend) result = PsiWildcardType.createExtends(manager, result);\n        return result;\n      }\n    });\n\n    PsiType componentType = transformed != null ? transformed.getDeepComponentType() : null;\n    if (componentType instanceof PsiWildcardType) {\n      componentType = ((PsiWildcardType)componentType).getExtendsBound();\n      int dims = transformed.getArrayDimensions();\n      for (int i = 0; i < dims; i++) componentType = componentType.createArrayType();\n      return componentType;\n    }\n\n    return transformed;\n  }","commit_id":"a9b4d10f8b054732e51f28f59206bfd8d3f2fc8f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TypeView(@NotNull PsiExpression expr) {\n      PsiType exprType = expr.getType();\n      exprType = exprType instanceof PsiEllipsisType ? ((PsiEllipsisType)exprType).toArrayType() : exprType;\n      myOriginType = exprType != null ? GenericsUtil.getVariableTypeByExpressionType(exprType) : null;\n      PsiType type = myTypeEvaluator.evaluateType(expr);\n      type = type instanceof PsiEllipsisType ? ((PsiEllipsisType)type).toArrayType() : type;\n      myType = type != null ? GenericsUtil.getVariableTypeByExpressionType(type) : null;\n      myChanged = (myOriginType == null || myType == null) ? false : !myType.equals(myOriginType);\n    }","id":90143,"modified_method":"public TypeView(@NotNull PsiExpression expr) {\n      PsiType exprType = expr.getType();\n      exprType = exprType instanceof PsiEllipsisType ? ((PsiEllipsisType)exprType).toArrayType() : exprType;\n      myOriginType = GenericsUtil.getVariableTypeByExpressionType(exprType);\n      PsiType type = myTypeEvaluator.evaluateType(expr);\n      type = type instanceof PsiEllipsisType ? ((PsiEllipsisType)type).toArrayType() : type;\n      myType = GenericsUtil.getVariableTypeByExpressionType(type);\n      myChanged = (myOriginType == null || myType == null) ? false : !myType.equals(myOriginType);\n    }","commit_id":"a9b4d10f8b054732e51f28f59206bfd8d3f2fc8f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public VariableTypeFix(@NotNull PsiVariable variable, PsiType toReturn) {\n    super(variable);\n    myReturnType = toReturn != null ? GenericsUtil.getVariableTypeByExpressionType(toReturn) : null;\n    myName = variable.getName();\n  }","id":90144,"modified_method":"public VariableTypeFix(@NotNull PsiVariable variable, PsiType toReturn) {\n    super(variable);\n    myReturnType = GenericsUtil.getVariableTypeByExpressionType(toReturn);\n    myName = variable.getName();\n  }","commit_id":"a9b4d10f8b054732e51f28f59206bfd8d3f2fc8f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    FacesContext context = FacesContext.getCurrentInstance();\n    Map reqMap = context.getExternalContext().getRequestMap();\n    Map requestParams = context.getExternalContext().getRequestParameterMap();\n    AssessmentService assessmentService = new AssessmentService();\n    PublishedAssessmentService publishedService= new PublishedAssessmentService();\n    //#0 - permission checking before proceeding - daisyf\n    AuthorBean author = (AuthorBean) cu.lookupBean(\n                         \"author\");\n    author.setOutcome(\"createAssessment\");\n    if (!passAuthz(context)){\n      author.setOutcome(\"author\");\n      return;\n    }\n\n    // pass authz test, move on\n    AssessmentBean assessmentBean = (AssessmentBean) cu.lookupBean(\n                                                      \"assessmentBean\");\n\n    ItemAuthorBean itemauthorBean = (ItemAuthorBean) cu.lookupBean(\"itemauthor\");\n    itemauthorBean.setTarget(itemauthorBean.FROM_ASSESSMENT); // save to assessment\n\n\n    // create an assessment based on the title entered and the assessment\n    // template selected\n    // #1 - read from form authorIndex.jsp\n    String assessmentTitle = author.getAssessTitle();\n\n    //HUONG's EDIT\n    //check assessmentTitle and see if it is duplicated, if is not then proceed, else throw error\n    boolean isUnique = assessmentService.assessmentTitleIsUnique(\"0\", assessmentTitle, false);\n    boolean isUniquePublish= publishedService.publishedAssessmentTitleIsUnique(\"0\", assessmentTitle);\n    if (!isUnique){\n      String err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"duplicateName_error\");\n      context.addMessage(null,new FacesMessage(err));\n      author.setOutcome(\"author\");\n      return;\n    }\n\n    String description = author.getAssessmentDescription();\n    String typeId = author.getAssessmentTypeId();\n    String templateId = author.getAssessmentTemplateId();\n\n    if (templateId == null){\n      templateId = AssessmentTemplateFacade.DEFAULTTEMPLATE.toString();\n    }\n    \n    // #2 - got all the info, create now\n    AssessmentFacade assessment = createAssessment(\n       assessmentTitle, description, typeId, templateId);\n\n    // #3a - goto editAssessment.jsp, so prepare assessmentBean\n    assessmentBean.setAssessment(assessment);\n    // #3b - reset the following\n    author.setAssessTitle(\"\");\n    author.setAssessmentDescription(\"\");\n    author.setAssessmentTypeId(\"\");\n    author.setAssessmentTemplateId(AssessmentTemplateFacade.DEFAULTTEMPLATE.toString());\n\n    // #3c - update core AssessmentList\n    ArrayList list = assessmentService.getBasicInfoOfAllActiveAssessments(AssessmentFacadeQueries.TITLE,true);\n    // get the managed bean, author and set the list\n    author.setAssessments(list);\n    author.setOutcome(\"createAssessment\");\n\n  }","id":90145,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    FacesContext context = FacesContext.getCurrentInstance();\n    Map reqMap = context.getExternalContext().getRequestMap();\n    Map requestParams = context.getExternalContext().getRequestParameterMap();\n    AssessmentService assessmentService = new AssessmentService();\n    PublishedAssessmentService publishedService= new PublishedAssessmentService();\n    //#0 - permission checking before proceeding - daisyf\n    AuthorBean author = (AuthorBean) cu.lookupBean(\n                         \"author\");\n    author.setOutcome(\"createAssessment\");\n    if (!passAuthz(context)){\n      author.setOutcome(\"author\");\n      return;\n    }\n\n    // pass authz test, move on\n    AssessmentBean assessmentBean = (AssessmentBean) cu.lookupBean(\n                                                      \"assessmentBean\");\n\n    ItemAuthorBean itemauthorBean = (ItemAuthorBean) cu.lookupBean(\"itemauthor\");\n    itemauthorBean.setTarget(itemauthorBean.FROM_ASSESSMENT); // save to assessment\n\n\n    // create an assessment based on the title entered and the assessment\n    // template selected\n    // #1 - read from form authorIndex.jsp\n    String assessmentTitle = author.getAssessTitle();\n\n    //HUONG's EDIT\n    //check assessmentTitle and see if it is duplicated, if is not then proceed, else throw error\n    boolean isUnique = assessmentService.assessmentTitleIsUnique(\"0\", assessmentTitle, false);\n    boolean isUniquePublish= publishedService.publishedAssessmentTitleIsUnique(\"0\", assessmentTitle);\n if(assessmentTitle!=null && (assessmentTitle.trim()).equals(\"\")){\n     \tString err1=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"assessmentName_empty\");\n\tcontext.addMessage(null,new FacesMessage(err1));\n        author.setOutcome(\"author\");\n\treturn;\n    }\n    if (!isUnique){\n      String err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\",\"duplicateName_error\");\n      context.addMessage(null,new FacesMessage(err));\n      author.setOutcome(\"author\");\n      return;\n    }\n\n    String description = author.getAssessmentDescription();\n    String typeId = author.getAssessmentTypeId();\n    String templateId = author.getAssessmentTemplateId();\n\n    if (templateId == null){\n      templateId = AssessmentTemplateFacade.DEFAULTTEMPLATE.toString();\n    }\n    \n    // #2 - got all the info, create now\n    AssessmentFacade assessment = createAssessment(\n       assessmentTitle, description, typeId, templateId);\n\n    // #3a - goto editAssessment.jsp, so prepare assessmentBean\n    assessmentBean.setAssessment(assessment);\n    // #3b - reset the following\n    author.setAssessTitle(\"\");\n    author.setAssessmentDescription(\"\");\n    author.setAssessmentTypeId(\"\");\n    author.setAssessmentTemplateId(AssessmentTemplateFacade.DEFAULTTEMPLATE.toString());\n\n    // #3c - update core AssessmentList\n    ArrayList list = assessmentService.getBasicInfoOfAllActiveAssessments(AssessmentFacadeQueries.TITLE,true);\n    // get the managed bean, author and set the list\n    author.setAssessments(list);\n    author.setOutcome(\"createAssessment\");\n\n  }","commit_id":"fe92c34173d7104f86b2be8898618be6fa895834","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException {\n    FacesContext context = FacesContext.getCurrentInstance();\n    ExternalContext extContext = context.getExternalContext();\n    Map reqMap = context.getExternalContext().getRequestMap();\n    Map requestParams = context.getExternalContext().getRequestParameterMap();\n    \n    AssessmentSettingsBean assessmentSettings = (AssessmentSettingsBean) cu.\n        lookupBean(\n        \"assessmentSettings\");\n\n    //#1 - permission checking before proceeding - daisyf\n    String assessmentId=String.valueOf(assessmentSettings.getAssessmentId());\n    AssessmentService assessmentService = new AssessmentService();\n    AssessmentFacade assessment = assessmentService.getAssessment(\n        assessmentId);\n    if (!passAuthz(context, assessment.getCreatedBy())){\n      assessmentSettings.setOutcomePublish(\"editAssessmentSettings\");\n      return;\n    }\n\n    //proceed to look for error, save assessment setting and confirm publish\n    //#2a - look for error: check if core assessment title is unique\n    String err=\"\";\n    boolean error=false;\n\n    String assessmentName=assessmentSettings.getTitle();\n    if(!assessmentService.assessmentTitleIsUnique(assessmentId,assessmentName,false)){\n      err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"assessmentName_error\");\n      context.addMessage(null,new FacesMessage(err));\n      error=true;\n    }\n\n    //#2b - validate if this is a time assessment, is there a time entry?\n    Object time=assessmentSettings.getValueMap().get(\"hasTimeAssessment\");\n    boolean isTime=false;\n    if (time!=null)\n      isTime=((Boolean)time).booleanValue();\n  \n    if ((isTime) &&((assessmentSettings.getTimeLimit().intValue())==0)){\n      err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"timeSelect_error\");\n      context.addMessage(null,new FacesMessage(err));\n      error=true;\n    }\n\n    if (error){\n      assessmentSettings.setOutcomePublish(\"editAssessmentSettings\");\n      return;\n    }\n\n    //#3 now u can proceed to save core assessment\n    SaveAssessmentSettings s = new SaveAssessmentSettings();\n    assessment = s.save(assessmentSettings);\n    assessmentSettings.setAssessment(assessment);\n\n    //  we need a publishedUrl, this is the url used by anonymous user\n    String releaseTo = assessment.getAssessmentAccessControl().getReleaseTo();\n    if (releaseTo != null) {\n      // generate an alias to the pub assessment\n      String alias = AgentFacade.getAgentString() + (new Date()).getTime();\n      assessmentSettings.setAlias(alias);\n      //log.info(\"servletPath=\" + extContext.getRequestServletPath());\n      String server = ( (javax.servlet.http.HttpServletRequest) extContext.\n\t\t\t      getRequest()).getRequestURL().toString();\n      int index = server.indexOf(extContext.getRequestContextPath() + \"/\"); // \"/samigo/\"\n      server = server.substring(0, index);\n      //log.info(\"servletPath=\" + server);\n      String url = server + extContext.getRequestContextPath();\n      assessmentSettings.setPublishedUrl(url + \"/servlet/Login?id=\" + alias);\n\n    }\n   \n    //#4 - before going to confirm publishing, check if the title is unique\n    PublishedAssessmentService publishedService = new PublishedAssessmentService();\n    if ( !publishedService.publishedAssessmentTitleIsUnique(assessmentId,assessmentName)){\n      err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"published_assessment_title_not_unique_error\");\n      context.addMessage(null,new FacesMessage(err));\n      assessmentSettings.setOutcomePublish(\"editAssessmentSettings\");\n      return;\n    }\n    assessmentSettings.setOutcomePublish(\"saveSettingsAndConfirmPublish\"); // finally goto confirm\n  }","id":90146,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException {\n    FacesContext context = FacesContext.getCurrentInstance();\n    ExternalContext extContext = context.getExternalContext();\n    Map reqMap = context.getExternalContext().getRequestMap();\n    Map requestParams = context.getExternalContext().getRequestParameterMap();\n    \n    AssessmentSettingsBean assessmentSettings = (AssessmentSettingsBean) cu.\n        lookupBean(\n        \"assessmentSettings\");\n\n    //#1 - permission checking before proceeding - daisyf\n    String assessmentId=String.valueOf(assessmentSettings.getAssessmentId());\n    AssessmentService assessmentService = new AssessmentService();\n    AssessmentFacade assessment = assessmentService.getAssessment(\n        assessmentId);\n    if (!passAuthz(context, assessment.getCreatedBy())){\n      assessmentSettings.setOutcomePublish(\"editAssessmentSettings\");\n      return;\n    }\n\n    //proceed to look for error, save assessment setting and confirm publish\n    //#2a - look for error: check if core assessment title is unique\n    boolean error=false;\n\n    String assessmentName=assessmentSettings.getTitle();\n    if(assessmentName!=null &&(assessmentName.trim()).equals(\"\")){\n     \tString nameEmpty_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"assessmentName_empty\");\n\tcontext.addMessage(null,new FacesMessage(nameEmpty_err));\n\terror=true;\n    }\n    if(!assessmentService.assessmentTitleIsUnique(assessmentId,assessmentName,false)){\n      String nameUnique_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"assessmentName_error\");\n      context.addMessage(null,new FacesMessage(nameUnique_err));\n      error=true;\n    }\n\n    //#2b - validate if this is a time assessment, is there a time entry?\n    Object time=assessmentSettings.getValueMap().get(\"hasTimeAssessment\");\n    boolean isTime=false;\n    if (time!=null)\n      isTime=((Boolean)time).booleanValue();\n  \n    if ((isTime) &&((assessmentSettings.getTimeLimit().intValue())==0)){\n      String time_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"timeSelect_error\");\n      context.addMessage(null,new FacesMessage(time_err));\n      error=true;\n    }\n\n    if (error){\n      assessmentSettings.setOutcomePublish(\"editAssessmentSettings\");\n      return;\n    }\n\n    //#3 now u can proceed to save core assessment\n    SaveAssessmentSettings s = new SaveAssessmentSettings();\n    assessment = s.save(assessmentSettings);\n    assessmentSettings.setAssessment(assessment);\n\n    //  we need a publishedUrl, this is the url used by anonymous user\n    String releaseTo = assessment.getAssessmentAccessControl().getReleaseTo();\n    if (releaseTo != null) {\n      // generate an alias to the pub assessment\n      String alias = AgentFacade.getAgentString() + (new Date()).getTime();\n      assessmentSettings.setAlias(alias);\n      //log.info(\"servletPath=\" + extContext.getRequestServletPath());\n      String server = ( (javax.servlet.http.HttpServletRequest) extContext.\n\t\t\t      getRequest()).getRequestURL().toString();\n      int index = server.indexOf(extContext.getRequestContextPath() + \"/\"); // \"/samigo/\"\n      server = server.substring(0, index);\n      //log.info(\"servletPath=\" + server);\n      String url = server + extContext.getRequestContextPath();\n      assessmentSettings.setPublishedUrl(url + \"/servlet/Login?id=\" + alias);\n\n    }\n   \n    //#4 - before going to confirm publishing, check if the title is unique\n    PublishedAssessmentService publishedService = new PublishedAssessmentService();\n    if ( !publishedService.publishedAssessmentTitleIsUnique(assessmentId,assessmentName)){\n      String err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"published_assessment_title_not_unique_error\");\n      context.addMessage(null,new FacesMessage(err));\n      assessmentSettings.setOutcomePublish(\"editAssessmentSettings\");\n      return;\n    }\n    assessmentSettings.setOutcomePublish(\"saveSettingsAndConfirmPublish\"); // finally goto confirm\n  }","commit_id":"fe92c34173d7104f86b2be8898618be6fa895834","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Standard processAction.\n   * @param ae\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    log.info(\"EDIT TEMPLATE LISTENER.\");\n\n    TemplateBean templateBean = (TemplateBean)ContextUtil.lookupBean(\"template\");\n    templateBean.setOutcome(\"newTemplate\");\n\n    log.info(\"Editing new template.\");\n    String tempName=templateBean.getNewName();\n    AssessmentService assessmentService = new AssessmentService();\n    IndexBean templateIndex = (IndexBean) ContextUtil.lookupBean(\n                       \"templateIndex\");\n\n    ArrayList templates = new ArrayList();\n    // id=0 => new template\n    boolean isUnique=assessmentService.assessmentTitleIsUnique(\"0\",tempName,true);\n    System.out.println(\"*** is unique=\"+isUnique);\n    if (!isUnique){\n      String error=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.TemplateMessages\",\"duplicateName_error\");\n      FacesContext context = FacesContext.getCurrentInstance();\n      context.addMessage(null,new FacesMessage(error));\n      templateBean.setOutcome(\"template\");\n      return;\n    }\n    templateBean.setTemplateName(tempName);\n    templateBean.setIdString(\"0\"); //new template\n  }","id":90147,"modified_method":"/**\n   * Standard processAction.\n   * @param ae\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    log.info(\"EDIT TEMPLATE LISTENER.\");\n\n    TemplateBean templateBean = (TemplateBean)ContextUtil.lookupBean(\"template\");\n    templateBean.setOutcome(\"newTemplate\");\n\n    log.info(\"Editing new template.\");\n    String tempName=templateBean.getNewName();\n    AssessmentService assessmentService = new AssessmentService();\n    IndexBean templateIndex = (IndexBean) ContextUtil.lookupBean(\n                       \"templateIndex\");\n\n    ArrayList templates = new ArrayList();\n    // id=0 => new template\n    boolean isUnique=assessmentService.assessmentTitleIsUnique(\"0\",tempName,true);\n     FacesContext context = FacesContext.getCurrentInstance();\n    if(tempName!=null && (tempName.trim()).equals(\"\")){\n     \tString err1=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.TemplateMessages\",\"templateName_empty\");\n\tcontext.addMessage(null,new FacesMessage(err1));\n        templateBean.setOutcome(\"template\");\n\treturn;\n    }\n    if (!isUnique){\n      String error=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.TemplateMessages\",\"duplicateName_error\");\n      context.addMessage(null,new FacesMessage(error));\n      templateBean.setOutcome(\"template\");\n      return;\n    }\n    templateBean.setTemplateName(tempName);\n    templateBean.setIdString(\"0\"); //new template\n  }","commit_id":"fe92c34173d7104f86b2be8898618be6fa895834","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Standard process action method.\n   * @param ae ActionEvent\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    log.info(\"PoolSaveListener :\");\n    QuestionPoolBean  qpoolbean= (QuestionPoolBean) cu.lookupBean(\"questionpool\");\n    String currentName= qpoolbean.getCurrentPool().getDisplayName();\n   \n    boolean isUnique=true;\n    QuestionPoolService service = new QuestionPoolService();\n   QuestionPoolDataBean bean = qpoolbean.getCurrentPool();\n      Long currentId = new Long (\"0\");\n      if(bean.getId() != null)\n      {\n\t  currentId = bean.getId();\n      }\n\n      Long currentParentId = new Long(\"0\");\n      if(bean.getParentPoolId() != null)\n      {\n        currentParentId = bean.getParentPoolId();\n      }\n     \n    try {\n       \n\tif((qpoolbean.getAddOrEdit()).equals(\"add\")){\n\t    isUnique=service.poolIsUnique(\"0\",currentName,\"\"+currentParentId);\n\t}\n\telse {\n\t     isUnique=service.poolIsUnique(\"\"+currentId,currentName,\"\"+currentParentId);\n\t}\n       \n\tif(!isUnique){\n\t   FacesContext context = FacesContext.getCurrentInstance();\n\t   String error=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.QuestionPoolMessages\",\"duplicateName_error\");\n\t   \n\t   context.addMessage(null,new FacesMessage(error));\n          \n\t   qpoolbean.setOutcomeEdit(\"editPool\");\n\t   qpoolbean.setOutcome(\"addPool\");\n\t \n\t   return;\n        }\n       \n\t\n\tif (!savePool(qpoolbean)){\n\t\t\n\t    throw new RuntimeException(\"failed to populateItemBean.\");   \n\t}\n   \n        if((qpoolbean.getAddOrEdit()).equals(\"edit\")){\n\t    if (!startRemoveItems(qpoolbean)){\n\t\tthrow new RuntimeException(\"failed to populateItemBean.\");\n\t    }\n\t}\n        \n\t   \n    }\n    catch(Exception e){\n\tthrow new Error(e);\n    } //if error=false then save, if not then create error message\n    \n  }","id":90148,"modified_method":"/**\n   * Standard process action method.\n   * @param ae ActionEvent\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    log.info(\"PoolSaveListener :\");\n    QuestionPoolBean  qpoolbean= (QuestionPoolBean) cu.lookupBean(\"questionpool\");\n    String currentName= qpoolbean.getCurrentPool().getDisplayName();\n   \n    boolean isUnique=true;\n    QuestionPoolService service = new QuestionPoolService();\n    QuestionPoolDataBean bean = qpoolbean.getCurrentPool();\n    Long currentId = new Long (\"0\");\n    FacesContext context = FacesContext.getCurrentInstance();\n      if(bean.getId() != null)\n      {\n\t  currentId = bean.getId();\n      }\n\n      Long currentParentId = new Long(\"0\");\n      if(bean.getParentPoolId() != null)\n      {\n        currentParentId = bean.getParentPoolId();\n      }\n     if(currentName!=null &&(currentName.trim()).equals(\"\")){\n     \tString err1=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.QuestionPoolMessages\",\"poolName_empty\");\n\tcontext.addMessage(null,new FacesMessage(err1));\n        qpoolbean.setOutcomeEdit(\"editPool\");\n\tqpoolbean.setOutcome(\"addPool\");\n\treturn;\n    }\n     \n    try {\n       \n\tif((qpoolbean.getAddOrEdit()).equals(\"add\")){\n\t    isUnique=service.poolIsUnique(\"0\",currentName,\"\"+currentParentId);\n\t}\n\telse {\n\t     isUnique=service.poolIsUnique(\"\"+currentId,currentName,\"\"+currentParentId);\n\t}\n       \n\tif(!isUnique){\n\t   \n\t   String error=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.QuestionPoolMessages\",\"duplicateName_error\");\n\t   \n\t   context.addMessage(null,new FacesMessage(error));\n          \n\t   qpoolbean.setOutcomeEdit(\"editPool\");\n\t   qpoolbean.setOutcome(\"addPool\");\n\t \n\t   return;\n        }\n       \n\t\n\tif (!savePool(qpoolbean)){\n\t\t\n\t    throw new RuntimeException(\"failed to populateItemBean.\");   \n\t}\n   \n        if((qpoolbean.getAddOrEdit()).equals(\"edit\")){\n\t    if (!startRemoveItems(qpoolbean)){\n\t\tthrow new RuntimeException(\"failed to populateItemBean.\");\n\t    }\n\t}\n        \n\t   \n    }\n    catch(Exception e){\n\tthrow new Error(e);\n    } //if error=false then save, if not then create error message\n    \n  }","commit_id":"fe92c34173d7104f86b2be8898618be6fa895834","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    FacesContext context = FacesContext.getCurrentInstance();\n    Map reqMap = context.getExternalContext().getRequestMap();\n    Map requestParams = context.getExternalContext().getRequestParameterMap();\n\n    AssessmentSettingsBean assessmentSettings = (AssessmentSettingsBean) cu.\n        lookupBean(\"assessmentSettings\");\n\n    String err=\"\";\n    boolean error=false;\n    String assessmentId=String.valueOf(assessmentSettings.getAssessmentId()); \n    AssessmentService assessmentService = new AssessmentService();\n  \n    //#2 - check if name is unique\n    String assessmentName=assessmentSettings.getTitle();\n    if(!assessmentService.assessmentTitleIsUnique(assessmentId,assessmentName,false)){\n\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"assessmentName_error\");\n\tcontext.addMessage(null,new FacesMessage(err));\n\terror=true;\n    }\n\n    //#3 if timed assessment, does it has value for time\n    Object time=assessmentSettings.getValueMap().get(\"hasTimeAssessment\");\n    boolean isTime=false;\n    try\n    {\n      if (time != null)\n      {\n        isTime = ( (Boolean) time).booleanValue();\n      }\n    }\n    catch (Exception ex)\n    {\n      // keep default\n      log.warn(\"Expecting Boolean hasTimeAssessment, got: \" + time);\n\n    }\n    if((isTime) &&((assessmentSettings.getTimeLimit().intValue())==0)){\n\terr=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"timeSelect_error\");\n\tcontext.addMessage(null,new FacesMessage(err));\n        error=true;\n    }\n\n    if (error){\n      assessmentSettings.setOutcomePublish(\"editAssessmentSettings\");\n      return;\n    }\n \n    assessmentSettings.setOutcomeSave(\"author\");\n    SaveAssessmentSettings s= new SaveAssessmentSettings();\n    s.save(assessmentSettings);\n    // reset the core listing in case assessment title changes\n    AuthorBean author = (AuthorBean) cu.lookupBean(\n                       \"author\");\n \n    ArrayList assessmentList = assessmentService.getBasicInfoOfAllActiveAssessments(\n                      author.getCoreAssessmentOrderBy(),author.isCoreAscending());\n    // get the managed bean, author and set the list\n    author.setAssessments(assessmentList);\n\n    // goto Question Authoring page\n    EditAssessmentListener editA= new EditAssessmentListener();\n    editA.processAction(null);\n\n  }","id":90149,"modified_method":"public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    FacesContext context = FacesContext.getCurrentInstance();\n    Map reqMap = context.getExternalContext().getRequestMap();\n    Map requestParams = context.getExternalContext().getRequestParameterMap();\n\n    AssessmentSettingsBean assessmentSettings = (AssessmentSettingsBean) cu.\n        lookupBean(\"assessmentSettings\");\n    boolean error=false;\n    String assessmentId=String.valueOf(assessmentSettings.getAssessmentId()); \n    AssessmentService assessmentService = new AssessmentService();\n  \n    String assessmentName=assessmentSettings.getTitle();\n// check if name is empty\n    if(assessmentName!=null &&(assessmentName.trim()).equals(\"\")){\n     \tString nameEmpty_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"assessmentName_empty\");\n\tcontext.addMessage(null,new FacesMessage(nameEmpty_err));\n\terror=true;\n    }\n      //#2 - check if name is unique\n    if(!assessmentService.assessmentTitleIsUnique(assessmentId,assessmentName,false)){\n\tString nameUnique_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"assessmentName_error\");\n\tcontext.addMessage(null,new FacesMessage(nameUnique_err));\n\terror=true;\n    }\n\n    //#3 if timed assessment, does it has value for time\n    Object time=assessmentSettings.getValueMap().get(\"hasTimeAssessment\");\n    boolean isTime=false;\n    try\n    {\n      if (time != null)\n      {\n        isTime = ( (Boolean) time).booleanValue();\n      }\n    }\n    catch (Exception ex)\n    {\n      // keep default\n      log.warn(\"Expecting Boolean hasTimeAssessment, got: \" + time);\n\n    }\n    if((isTime) &&((assessmentSettings.getTimeLimit().intValue())==0)){\n\tString time_err=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AssessmentSettingsMessages\",\"timeSelect_error\");\n\tcontext.addMessage(null,new FacesMessage(time_err));\n        error=true;\n    }\n\n    if (error){\n      assessmentSettings.setOutcomeSave(\"editAssessmentSettings\");\n      return;\n    }\n \n    assessmentSettings.setOutcomeSave(\"author\");\n    SaveAssessmentSettings s= new SaveAssessmentSettings();\n    s.save(assessmentSettings);\n    // reset the core listing in case assessment title changes\n    AuthorBean author = (AuthorBean) cu.lookupBean(\n                       \"author\");\n \n    ArrayList assessmentList = assessmentService.getBasicInfoOfAllActiveAssessments(\n                      author.getCoreAssessmentOrderBy(),author.isCoreAscending());\n    // get the managed bean, author and set the list\n    author.setAssessments(assessmentList);\n\n    // goto Question Authoring page\n    EditAssessmentListener editA= new EditAssessmentListener();\n    editA.processAction(null);\n\n  }","commit_id":"fe92c34173d7104f86b2be8898618be6fa895834","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * tempalte name\n   *\n   * @return the name\n   */\n  public String getTemplateName()\n  {\n    return checker(templateName, \"New Template\");\n  }","id":90150,"modified_method":"/**\n   * tempalte name\n   *\n   * @return the name\n   */\n  public String getTemplateName()\n  {\n    return checker(templateName, \"\");\n  }","commit_id":"fe92c34173d7104f86b2be8898618be6fa895834","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n   * Normal listener method.\n   * @param ae\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    FacesContext context = FacesContext.getCurrentInstance();\n    Map reqMap = context.getExternalContext().getRequestMap();\n    Map requestParams = context.getExternalContext().getRequestParameterMap();\n\n    log.info(\"DEBUG: TEMPLATE UPDATE LISTENER.\");\n    log.info(\"debugging ActionEvent: \" + ae);\n    log.info(\"debug requestParams: \" + requestParams);\n    log.info(\"debug reqMap: \" + reqMap);\n    TemplateBean templateBean = lookupTemplateBean(context);\n    templateBean.setOutcome(\"template\");\n    String tempName=templateBean.getTemplateName();\n    AssessmentService assessmentService = new AssessmentService();\n\n    boolean isUnique=assessmentService.assessmentTitleIsUnique(templateBean.getIdString(),tempName,true);\n    System.out.println(\"*** is unique=\"+isUnique);\n    if (!isUnique){\n      String error=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.TemplateMessages\",\"duplicateName_error\");\n      context.addMessage(null,new FacesMessage(error));\n      return;\n    }\n    updateAssessment(templateBean);\n  }","id":90151,"modified_method":"/**\n   * Normal listener method.\n   * @param ae\n   * @throws AbortProcessingException\n   */\n  public void processAction(ActionEvent ae) throws AbortProcessingException\n  {\n    FacesContext context = FacesContext.getCurrentInstance();\n    Map reqMap = context.getExternalContext().getRequestMap();\n    Map requestParams = context.getExternalContext().getRequestParameterMap();\n\n    log.info(\"DEBUG: TEMPLATE UPDATE LISTENER.\");\n    log.info(\"debugging ActionEvent: \" + ae);\n    log.info(\"debug requestParams: \" + requestParams);\n    log.info(\"debug reqMap: \" + reqMap);\n    TemplateBean templateBean = lookupTemplateBean(context);\n    \n    String tempName=templateBean.getTemplateName();\n    AssessmentService assessmentService = new AssessmentService();\n\n    boolean isUnique=assessmentService.assessmentTitleIsUnique(templateBean.getIdString(),tempName,true);\n    System.out.println(\"*** is unique=\"+isUnique);\n    if(tempName!=null && (tempName.trim()).equals(\"\")){\n     \tString err1=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.TemplateMessages\",\"templateName_empty\");\n\tcontext.addMessage(null,new FacesMessage(err1));\n        templateBean.setOutcome(\"editTemplate\");\n\treturn;\n    }\n    if (!isUnique){\n      String error=ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.TemplateMessages\",\"duplicateName_error\");\n      context.addMessage(null,new FacesMessage(error));\n       templateBean.setOutcome(\"editTemplate\");\n      return;\n    }\n    templateBean.setOutcome(\"template\");\n    updateAssessment(templateBean);\n  }","commit_id":"fe92c34173d7104f86b2be8898618be6fa895834","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@GET\n  @Path(\"/namespaces\")\n  public void getAllNamespaces(HttpRequest request, HttpResponder responder) {\n    LOG.debug(\"Lising all namespaces\");\n    try {\n      List<NamespaceMetadata> namespaces = namespaceMetaStore.list();\n      if (null == namespaces) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n      } else {\n        String result = GSON.toJson(namespaces);\n        responder.sendByteArray(HttpResponseStatus.OK, result.getBytes(Charsets.UTF_8),\n                                ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE, \"application/json\"));\n      }\n    } catch (Exception e) {\n      LOG.error(\"Internal error - {} \", e.getLocalizedMessage(), e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","id":90152,"modified_method":"@GET\n  @Path(\"/namespaces\")\n  public void getAllNamespaces(HttpRequest request, HttpResponder responder) {\n    LOG.debug(\"Listing all namespaces\");\n    try {\n      List<NamespaceMetadata> namespaces = namespaceMetaStore.list();\n      if (null == namespaces) {\n        responder.sendStatus(HttpResponseStatus.NOT_FOUND);\n      } else {\n        String result = GSON.toJson(namespaces);\n        responder.sendByteArray(HttpResponseStatus.OK, result.getBytes(Charsets.UTF_8),\n                                ImmutableMultimap.of(HttpHeaders.Names.CONTENT_TYPE, \"application/json\"));\n      }\n    } catch (Exception e) {\n      LOG.error(\"Internal error - {} \", e.getLocalizedMessage(), e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"44dc39d0ff02faba05693e917bb16a976cf88aae","url":"https://github.com/caskdata/cdap"},{"original_method":"@PUT\n  @Path(\"/namespaces/{namespace}\")\n  public void create(HttpRequest request, HttpResponder responder, @PathParam(\"namespace\") String namespace) {\n    LOG.debug(\"Creating namespace {}\", namespace);\n    try {\n      if (namespaceMetaStore.exists(namespace)) {\n        LOG.error(\"Namespace {} already exists\", namespace);\n        responder.sendStatus(HttpResponseStatus.CONFLICT);\n        return;\n      }\n      NamespaceMetadata metadata = parseBody(request, NamespaceMetadata.class);\n      namespaceMetaStore.create(namespace, metadata.getDisplayName(), metadata.getDescription());\n      responder.sendStatus(HttpResponseStatus.OK);\n    } catch (IOException e) {\n      LOG.error(\"Invalid namespace input: {}\", request.getContent().toString(Charsets.UTF_8), e);\n      responder.sendStatus(HttpResponseStatus.BAD_REQUEST);\n    } catch (Exception e) {\n      LOG.error(\"Internal error - {}\", e.getLocalizedMessage(), e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","id":90153,"modified_method":"@PUT\n  @Path(\"/namespaces\")\n  public void create(HttpRequest request, HttpResponder responder) {\n    try {\n      NamespaceMetadata metadata = parseBody(request, NamespaceMetadata.class);\n      String name = metadata.getName();\n      // name cannot be null or empty.\n      if (null == name || name.isEmpty()) {\n        LOG.error(\"Namespace name cannot be null or empty.\");\n        responder.sendStatus(HttpResponseStatus.BAD_REQUEST);\n        return;\n      }\n      if (namespaceMetaStore.exists(name)) {\n        LOG.error(\"Namespace {} already exists\", name);\n        responder.sendStatus(HttpResponseStatus.CONFLICT);\n        return;\n      }\n      LOG.debug(\"Creating namespace {}\", name);\n      // displayName and description could be null\n      String displayName = metadata.getDisplayName();\n      if (null == displayName || displayName.isEmpty()) {\n        displayName = name;\n      }\n      String description = metadata.getDescription();\n      if (null == description) {\n        description = \"\";\n      }\n      namespaceMetaStore.create(name, displayName, description);\n      responder.sendStatus(HttpResponseStatus.OK);\n    } catch (JsonSyntaxException e) {\n      LOG.error(\"Invalid namespace metadata: {}. Must be a valid json string.\", request.getContent()\n        .toString(Charsets.UTF_8), e);\n      responder.sendStatus(HttpResponseStatus.BAD_REQUEST);\n    } catch (IOException e) {\n      LOG.error(\"Error reading namespace metadata: {}\", request.getContent().toString(Charsets.UTF_8), e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    } catch (Exception e) {\n      LOG.error(\"Internal error - {}\", e.getLocalizedMessage(), e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"44dc39d0ff02faba05693e917bb16a976cf88aae","url":"https://github.com/caskdata/cdap"},{"original_method":"private int createNamespace(String name, String metadata) throws Exception {\n    HttpResponse response = doPut(String.format(\"%s/namespaces/%s\", Constants.Gateway.API_VERSION, name), metadata);\n    return response.getStatusLine().getStatusCode();\n  }","id":90154,"modified_method":"private int createNamespace(String metadata) throws Exception {\n    HttpResponse response = doPut(String.format(\"%s/namespaces\", Constants.Gateway.API_VERSION), metadata);\n    return response.getStatusLine().getStatusCode();\n  }","commit_id":"44dc39d0ff02faba05693e917bb16a976cf88aae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testDeleteNamespace() throws Exception {\n    // test deleting non-existent namespace\n    Assert.assertEquals(404, deleteNamespace(\"doesnotexist\"));\n    // setup - create namespace\n    Assert.assertEquals(200, createNamespace(NAME, METADATA));\n    Assert.assertEquals(200, listNamespace(NAME));\n    // test delete\n    Assert.assertEquals(200, deleteNamespace(NAME));\n  }","id":90155,"modified_method":"@Test\n  public void testDeleteNamespace() throws Exception {\n    // test deleting non-existent namespace\n    Assert.assertEquals(404, deleteNamespace(\"doesnotexist\"));\n    // setup - create namespace\n    Assert.assertEquals(200, createNamespace(METADATA_VALID));\n    Assert.assertEquals(200, listNamespace(NAME));\n    // test delete\n    Assert.assertEquals(200, deleteNamespace(NAME));\n  }","commit_id":"44dc39d0ff02faba05693e917bb16a976cf88aae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testCreateNamespace() throws Exception {\n    Assert.assertEquals(200, createNamespace(NAME, METADATA));\n    Assert.assertEquals(200, listNamespace(NAME));\n    // test duplicate creation\n    Assert.assertEquals(409, createNamespace(NAME, METADATA));\n    // cleanup\n    Assert.assertEquals(200, deleteNamespace(NAME));\n  }","id":90156,"modified_method":"@Test\n  public void testCreateNamespace() throws Exception {\n    Assert.assertEquals(200, createNamespace(METADATA_VALID));\n    Assert.assertEquals(200, listNamespace(NAME));\n    // test duplicate creation\n    Assert.assertEquals(409, createNamespace(METADATA_VALID));\n    // cleanup\n    Assert.assertEquals(200, deleteNamespace(NAME));\n  }","commit_id":"44dc39d0ff02faba05693e917bb16a976cf88aae","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void createNamespace(final NamespaceMeta metadata) throws Exception {\n    txnl.executeUnchecked(new TransactionExecutor.Function<AppMds, Void>() {\n      @Override\n      public Void apply(AppMds input) throws Exception {\n        input.apps.createNamespace(metadata);\n        return null;\n      }\n    });\n  }","id":90157,"modified_method":"@Override\n  public NamespaceMeta createNamespace(final NamespaceMeta metadata) throws Exception {\n    return txnl.executeUnchecked(new TransactionExecutor.Function<AppMds, NamespaceMeta>() {\n      @Override\n      public NamespaceMeta apply(AppMds input) throws Exception {\n        Id.Namespace namespaceId = Id.Namespace.from(metadata.getName());\n        if (input.apps.namespaceExists(namespaceId)) {\n          return input.apps.getNamespace(namespaceId);\n        }\n        input.apps.createNamespace(metadata);\n        return null;\n      }\n    });\n  }","commit_id":"24d84b8debfe658010065362ef50ddd98a0588cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteNamespace(final Id.Namespace id) throws Exception {\n    txnl.executeUnchecked(new TransactionExecutor.Function<AppMds, Void>() {\n      @Override\n      public Void apply(AppMds input) throws Exception {\n        input.apps.deleteNamespace(id);\n        return null;\n      }\n    });\n  }","id":90158,"modified_method":"@Override\n  public NamespaceMeta deleteNamespace(final Id.Namespace id) throws Exception {\n    return txnl.executeUnchecked(new TransactionExecutor.Function<AppMds, NamespaceMeta>() {\n      @Override\n      public NamespaceMeta apply(AppMds input) throws Exception {\n        if (!input.apps.namespaceExists(id)) {\n          return null;\n        }\n        NamespaceMeta namespaceMeta = input.apps.getNamespace(id);\n        input.apps.deleteNamespace(id);\n        return namespaceMeta;\n      }\n    });\n  }","commit_id":"24d84b8debfe658010065362ef50ddd98a0588cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@PUT\n  @Path(\"/namespaces\")\n  public void create(HttpRequest request, HttpResponder responder) {\n    try {\n      NamespaceMeta metadata = parseBody(request, NamespaceMeta.class);\n      String name = metadata.getName();\n      // name cannot be null or empty.\n      if (name == null || name.isEmpty()) {\n        responder.sendString(HttpResponseStatus.BAD_REQUEST, \"Namespace name cannot be null or empty.\");\n        return;\n      }\n      if (store.namespaceExists(Id.Namespace.from(name))) {\n        responder.sendString(HttpResponseStatus.CONFLICT, String.format(\"Namespace %s already exists\", name));\n        return;\n      }\n      // displayName and description could be null\n      String displayName = metadata.getDisplayName();\n      if (displayName == null || displayName.isEmpty()) {\n        displayName = name;\n      }\n      String description = metadata.getDescription();\n      if (description == null) {\n        description = \"\";\n      }\n      store.createNamespace(new NamespaceMeta.Builder().setName(name).setDisplayName(displayName)\n                              .setDescription(description).build());\n      responder.sendStatus(HttpResponseStatus.OK);\n    } catch (JsonSyntaxException e) {\n      responder.sendString(HttpResponseStatus.BAD_REQUEST, String.format(\"Invalid namespace metadata. Must be a valid\" +\n                                                                           \" json.\"));\n    } catch (IOException e) {\n      LOG.error(\"Failed to read namespace metadata.\", e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    } catch (Exception e) {\n      LOG.error(\"Internal error while creating namespace\", e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","id":90159,"modified_method":"@PUT\n  @Path(\"/namespaces\")\n  public void create(HttpRequest request, HttpResponder responder) {\n    NamespaceMeta metadata;\n    String name;\n    String displayName;\n    String description;\n\n    try {\n      metadata = parseBody(request, NamespaceMeta.class);\n    } catch (JsonSyntaxException e) {\n      responder.sendString(HttpResponseStatus.BAD_REQUEST, String.format(\"Invalid namespace metadata. Must be a valid\" +\n                                                                           \" json.\"));\n      return;\n    } catch (IOException e) {\n      LOG.error(\"Failed to read namespace metadata.\", e);\n      responder.sendString(HttpResponseStatus.INTERNAL_SERVER_ERROR, \"Failed to read namespace metadata.\");\n      return;\n    }\n\n    name = metadata.getName();\n    // name cannot be null or empty.\n    if (name == null || name.isEmpty()) {\n      responder.sendString(HttpResponseStatus.BAD_REQUEST, \"Namespace name cannot be null or empty.\");\n      return;\n    }\n\n    // check if namespace already exists. Although create already checks for existence, doing this check here so we\n    // don't have to execute any of the logic below if a conflict can be detected here\n    try {\n      if (store.namespaceExists(Id.Namespace.from(name))) {\n        responder.sendString(HttpResponseStatus.CONFLICT, String.format(\"Namespace %s already exists.\", name));\n        return;\n      }\n    } catch (Exception e) {\n      LOG.error(\"Internal error while checking namespace status.\", e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n      return;\n    }\n\n    // displayName and description could be null\n    displayName = metadata.getDisplayName();\n    if (displayName == null || displayName.isEmpty()) {\n      displayName = name;\n    }\n    description = metadata.getDescription();\n    if (description == null) {\n      description = \"\";\n    }\n\n    try {\n      NamespaceMeta existingNamespace = store.createNamespace(new NamespaceMeta.Builder().setName(name)\n                                                               .setDisplayName(displayName).setDescription(description)\n                                                               .build());\n      if (existingNamespace == null) {\n        responder.sendStatus(HttpResponseStatus.OK);\n      } else {\n        responder.sendString(HttpResponseStatus.CONFLICT, String.format(\"Namespace %s already exists.\", name));\n      }\n\n    } catch (Exception e) {\n      LOG.error(\"Internal error while creating namespace.\", e);\n      responder.sendStatus(HttpResponseStatus.INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"24d84b8debfe658010065362ef50ddd98a0588cb","url":"https://github.com/caskdata/cdap"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tString ipAddress = request.getRemoteAddr();\n\n\t\tif (M_log.isDebugEnabled()) {\n\t\t\tM_log.debug(\"Basic LTI Provider request from IP=\" + ipAddress);\n\t\t}\n\n\t\tString enabled = ServerConfigurationService.getString(\n\t\t\t\t\"basiclti.provider.enabled\", null);\n\t\tif (enabled == null || !(\"true\".equals(enabled))) {\n\t\t\tM_log.warn(\"Basic LTI Provider is Disabled IP=\" + ipAddress);\n\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\"Basic LTI Provider is Disabled\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ( \"/casa.json\".equals(request.getPathInfo()) ) {\n\t\t\tif ( ServerConfigurationService.getBoolean(\"casa.provider\", true))  {\n\t\t\t\thandleCASAList(request, response);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tM_log.warn(\"CASA Provider is Disabled IP=\" + ipAddress);\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\t\"CASA Provider is Disabled\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ( \"/canvas-config.xml\".equals(request.getPathInfo()) ) {\n\t\t\tif ( ServerConfigurationService.getBoolean(\"canvas.config.enabled\", true))  {\n\t\t\t\thandleCanvasConfig(request, response);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tM_log.warn(\"Canvas config is Disabled IP=\" + ipAddress);\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\t\"Canvas config is Disabled\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If this is a LTI request of any kind, make sure we don't have any\n\t\t// prior payload in the session.\n\t\tif ( BasicLTIUtil.isRequest(request) ) {\n\t\t\tSession sess = SessionManager.getCurrentSession();\n\t\t\tsess.removeAttribute(\"payload\");\n\t\t}\n\n\t\t// Check if we support ContentItem.\n\t\t// If we are doing ContentItem and have a payload and are not a launch\n\t\t// short-circuit to ContentItem\n\t\tif ( \"/content.item\".equals(request.getPathInfo()) ) {\n\t\t\tif ( ! ServerConfigurationService.getBoolean(\"contentitem.provider\", true))  {\n\t\t\t\tM_log.warn(\"ContentItem is Disabled IP=\" + ipAddress);\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\t\"ContentItem is Disabled\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tSession sess = SessionManager.getCurrentSession();\n\t\t\t\tMap session_payload = (Map) sess.getAttribute(\"payload\");\n\t\t\t\tif ( session_payload != null ) {\n\t\t\t\t\t// Post-Login requests to content.item\n\t\t\t\t\tM_log.debug(\"ContentItem already logged in \"+sess.getUserId());\n\t\t\t\t\thandleContentItem(request, response, session_payload);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (M_log.isDebugEnabled()) {\n\t\t\tMap<String, String[]> params = (Map<String, String[]>) request\n\t\t\t\t\t.getParameterMap();\n\t\t\tfor (Map.Entry<String, String[]> param : params.entrySet()) {\n\t\t\t\tM_log.debug(param.getKey() + \":\" + param.getValue()[0]);\n\t\t\t}\n\t\t}\n\n\t\tMap payload = getPayloadAsMap(request);\n\n\t\t// Get the list of highly trusted consumers from sakai.properties.\n\t\t// If the incoming consumer is highly trusted, we use the context_id and\n\t\t// site_id as is,\n\t\t// ie without prefixing them with the oauth_consumer_key first.\n\t\t// We also don't both checking their roles in the site.\n\t\tboolean isTrustedConsumer = BasicLTIProviderUtil.isHighlyTrustedConsumer(payload);\n\n\t\t/*\n\t\t * Get the list of email trusted consumers from sakai.properties. If the\n\t\t * incoming consumer is email trusted, we use the email address provided\n\t\t * by the consumer and look up the \"user\" info from sakai instead of\n\t\t * consumer's. This use case is especially valuable if 2 different LMS's\n\t\t * acting as TP and TC referring to same user and can be uniquely\n\t\t * identified by email address. more details SAK-29372\n\t\t */\n\t\tboolean isEmailTrustedConsumer = BasicLTIProviderUtil.isEmailTrustedConsumer(payload);\n\n\t\t/*\n\t\t * Checking if the email trusted consumer property and trusted consumer\n\t\t * and not both enabled. the case would be an error condition\n\t\t */\n\t\tif (isTrustedConsumer && isEmailTrustedConsumer) {\n\t\t\tM_log.warn(\"Both Email Trusted and Trusted Consumer property is enabled, this is invalid  IP=\" + ipAddress);\n\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\"Both Email Trusted and Trusted Consumer property is enabled, this is invalid \");\n\t\t\treturn;\n\n\t\t}\n\n        try {\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.beforeValidation);\n\n            validate(payload, isTrustedConsumer);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterValidation);\n\n            User user = userFinderOrCreator.findOrCreateUser(payload, isTrustedConsumer, isEmailTrustedConsumer);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterUserCreation, user);\n\n            // Check if we are loop-backing on the same server, and already logged in as same user\n            Session sess = SessionManager.getCurrentSession();\n            String serverUrl = SakaiBLTIUtil.getOurServerUrl();\n            String ext_sakai_server = (String) payload.get(\"ext_sakai_server\");\n\n            if ( \"/content.item\".equals(request.getPathInfo()) && isTrustedConsumer &&\n                ext_sakai_server != null && ext_sakai_server.equals(serverUrl) &&\n                user.getId().equals(sess.getUserId()) ) {\n\n                M_log.debug(\"ContentItem looping back as \"+sess.getUserId());\n                sess.setAttribute(\"payload\", payload);\n                handleContentItem(request, response, payload);\n                return;\n            }\n\n            loginUser(ipAddress, user);\n\n            // Re-grab the session\n            sess = SessionManager.getCurrentSession();\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterLogin, user);\n\n            // This needs to happen after login, when we have a session for the user.\n            userLocaleSetter.setupUserLocale(payload, user, isTrustedConsumer,isEmailTrustedConsumer);\n\n            userPictureSetter.setupUserPicture(payload, user, isTrustedConsumer, isEmailTrustedConsumer);\n\n            // The first launch of content.item - no site needed\n            if ( \"/content.item\".equals(request.getPathInfo()) ) {\n                    M_log.debug(\"ContentItem inital external login \"+sess.getUserId());\n                    sess.setAttribute(\"payload\", payload);\n\t\t\t\t\thandleContentItem(request, response, payload);\n                    return;\n            }\n\n            Site site = findOrCreateSite(payload, isTrustedConsumer);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterSiteCreation, user, site);\n\n            siteEmailPreferenceSetter.setupUserEmailPreferenceForSite(payload, user, site, isTrustedConsumer);\n\n            site = siteMembershipUpdater.addOrUpdateSiteMembership(payload, isTrustedConsumer, user, site);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterSiteMembership, user, site);\n\n            String toolPlacementId = addOrCreateTool(payload, isTrustedConsumer, user, site);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.beforeLaunch, user, site);\n\n            syncSiteMembershipsOnceThenSchedule(payload, site, isTrustedConsumer, isEmailTrustedConsumer);\n\n            // Construct a URL to this tool\n            StringBuilder url = new StringBuilder();\n                url.append(SakaiBLTIUtil.getOurServerUrl());\n                url.append(ServerConfigurationService.getString(\"portalPath\", \"/portal\"));\n                url.append(\"/tool-reset/\");\n                url.append(toolPlacementId);\n                url.append(\"?panel=Main\");\n\n            if (M_log.isDebugEnabled()) {\n                M_log.debug(\"url=\" + url.toString());\n            }\n            //String toolLink = ServerConfigurationService.getPortalUrl()+ \"/tool-reset/\" + placement_id + \"?panel=Main\";\n            // Compensate for bug in getPortalUrl()\n            //toolLink = toolLink.replace(\"IMS BLTI Portlet\", \"portal\");\n            response.setContentType(\"text/html\");\n            response.setStatus(HttpServletResponse.SC_FOUND);\n            response.sendRedirect(url.toString());\n\n        } catch (LTIException ltiException) {\n            doError(request, response, ltiException.getErrorKey(), ltiException.getMessage(), ltiException.getCause());\n        }\n\n\n\t\t/*\n\t\t\n\t\tPrintWriter out = response.getWriter();\n\t\tout.println(\"<body><div style=\\\"text-align: center\\\">\");\n\t\tout.println(\"&nbsp;<br/>&nbsp;<br/>&nbsp;<br/>&nbsp;<br/>\");\n\t\tout.println(\"&nbsp;<br/>&nbsp;<br/>&nbsp;<br/>&nbsp;<br/>\");\n\t\tout.println(\"<a href=\\\"\" + url.toString() + \"\\\">\");\n\t\tout.println(\"<span id=\\\"hideme\\\">\" + rb.getString(\"launch.continue\")\n\t\t\t\t+ \"<\/span>\");\n\t\tout.println(\"<\/a>\");\n\t\tout.println(\" <script language=\\\"javascript\\\"> \\n\"\n\t\t\t\t\t\t+ \"    document.getElementById(\\\"hideme\\\").style.display = \\\"none\\\";\\n\"\n\t\t\t\t\t\t+ \"    location.href=\\\"\" + url.toString() + \"\\\";\\n\"\n\t\t\t\t\t\t+ \" <\/script> \\n\");\n\t\tout.println(\"<\/div>\");\n\t\tout.println(\"<\/body>\");\n\t\t\n\t\tout.close();\n\t\t*/\n\t\t\n\n\t}","id":90160,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tString ipAddress = request.getRemoteAddr();\n\n\t\tif (M_log.isDebugEnabled()) {\n\t\t\tM_log.debug(\"Basic LTI Provider request from IP=\" + ipAddress);\n\t\t}\n\n\t\tString enabled = ServerConfigurationService.getString(\n\t\t\t\t\"basiclti.provider.enabled\", null);\n\t\tif (enabled == null || !(\"true\".equals(enabled))) {\n\t\t\tM_log.warn(\"Basic LTI Provider is Disabled IP=\" + ipAddress);\n\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\"Basic LTI Provider is Disabled\");\n\t\t\treturn;\n\t\t}\n\n\t\tif ( \"/casa.json\".equals(request.getPathInfo()) ) {\n\t\t\tif ( ServerConfigurationService.getBoolean(\"casa.provider.enabled\", true))  {\n\t\t\t\thandleCASAList(request, response);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tM_log.warn(\"CASA Provider is Disabled IP=\" + ipAddress);\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\t\"CASA Provider is Disabled\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ( \"/canvas-config.xml\".equals(request.getPathInfo()) ) {\n\t\t\tif ( ServerConfigurationService.getBoolean(\"canvas.config.enabled\", true))  {\n\t\t\t\thandleCanvasConfig(request, response);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tM_log.warn(\"Canvas config is Disabled IP=\" + ipAddress);\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\t\"Canvas config is Disabled\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If this is a LTI request of any kind, make sure we don't have any\n\t\t// prior payload in the session.\n\t\tif ( BasicLTIUtil.isRequest(request) ) {\n\t\t\tSession sess = SessionManager.getCurrentSession();\n\t\t\tsess.removeAttribute(\"payload\");\n\t\t}\n\n\t\t// Check if we support ContentItem.\n\t\t// If we are doing ContentItem and have a payload and are not a launch\n\t\t// short-circuit to ContentItem\n\t\tif ( \"/content.item\".equals(request.getPathInfo()) ) {\n\t\t\tif ( ! ServerConfigurationService.getBoolean(\"contentitem.provider\", true))  {\n\t\t\t\tM_log.warn(\"ContentItem is Disabled IP=\" + ipAddress);\n\t\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\t\"ContentItem is Disabled\");\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tSession sess = SessionManager.getCurrentSession();\n\t\t\t\tMap session_payload = (Map) sess.getAttribute(\"payload\");\n\t\t\t\tif ( session_payload != null ) {\n\t\t\t\t\t// Post-Login requests to content.item\n\t\t\t\t\tM_log.debug(\"ContentItem already logged in \"+sess.getUserId());\n\t\t\t\t\thandleContentItem(request, response, session_payload);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (M_log.isDebugEnabled()) {\n\t\t\tMap<String, String[]> params = (Map<String, String[]>) request\n\t\t\t\t\t.getParameterMap();\n\t\t\tfor (Map.Entry<String, String[]> param : params.entrySet()) {\n\t\t\t\tM_log.debug(param.getKey() + \":\" + param.getValue()[0]);\n\t\t\t}\n\t\t}\n\n\t\tMap payload = getPayloadAsMap(request);\n\n\t\t// Get the list of highly trusted consumers from sakai.properties.\n\t\t// If the incoming consumer is highly trusted, we use the context_id and\n\t\t// site_id as is,\n\t\t// ie without prefixing them with the oauth_consumer_key first.\n\t\t// We also don't both checking their roles in the site.\n\t\tboolean isTrustedConsumer = BasicLTIProviderUtil.isHighlyTrustedConsumer(payload);\n\n\t\t/*\n\t\t * Get the list of email trusted consumers from sakai.properties. If the\n\t\t * incoming consumer is email trusted, we use the email address provided\n\t\t * by the consumer and look up the \"user\" info from sakai instead of\n\t\t * consumer's. This use case is especially valuable if 2 different LMS's\n\t\t * acting as TP and TC referring to same user and can be uniquely\n\t\t * identified by email address. more details SAK-29372\n\t\t */\n\t\tboolean isEmailTrustedConsumer = BasicLTIProviderUtil.isEmailTrustedConsumer(payload);\n\n\t\t/*\n\t\t * Checking if the email trusted consumer property and trusted consumer\n\t\t * and not both enabled. the case would be an error condition\n\t\t */\n\t\tif (isTrustedConsumer && isEmailTrustedConsumer) {\n\t\t\tM_log.warn(\"Both Email Trusted and Trusted Consumer property is enabled, this is invalid  IP=\" + ipAddress);\n\t\t\tresponse.sendError(HttpServletResponse.SC_FORBIDDEN,\n\t\t\t\t\t\"Both Email Trusted and Trusted Consumer property is enabled, this is invalid \");\n\t\t\treturn;\n\n\t\t}\n\n        try {\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.beforeValidation);\n\n            validate(payload, isTrustedConsumer);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterValidation);\n\n            User user = userFinderOrCreator.findOrCreateUser(payload, isTrustedConsumer, isEmailTrustedConsumer);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterUserCreation, user);\n\n            // Check if we are loop-backing on the same server, and already logged in as same user\n            Session sess = SessionManager.getCurrentSession();\n            String serverUrl = SakaiBLTIUtil.getOurServerUrl();\n            String ext_sakai_server = (String) payload.get(\"ext_sakai_server\");\n\n            if ( \"/content.item\".equals(request.getPathInfo()) && isTrustedConsumer &&\n                ext_sakai_server != null && ext_sakai_server.equals(serverUrl) &&\n                user.getId().equals(sess.getUserId()) ) {\n\n                M_log.debug(\"ContentItem looping back as \"+sess.getUserId());\n                sess.setAttribute(\"payload\", payload);\n                handleContentItem(request, response, payload);\n                return;\n            }\n\n            loginUser(ipAddress, user);\n\n            // Re-grab the session\n            sess = SessionManager.getCurrentSession();\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterLogin, user);\n\n            // This needs to happen after login, when we have a session for the user.\n            userLocaleSetter.setupUserLocale(payload, user, isTrustedConsumer,isEmailTrustedConsumer);\n\n            userPictureSetter.setupUserPicture(payload, user, isTrustedConsumer, isEmailTrustedConsumer);\n\n            // The first launch of content.item - no site needed\n            if ( \"/content.item\".equals(request.getPathInfo()) ) {\n                    M_log.debug(\"ContentItem inital external login \"+sess.getUserId());\n                    sess.setAttribute(\"payload\", payload);\n\t\t\t\t\thandleContentItem(request, response, payload);\n                    return;\n            }\n\n            Site site = findOrCreateSite(payload, isTrustedConsumer);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterSiteCreation, user, site);\n\n            siteEmailPreferenceSetter.setupUserEmailPreferenceForSite(payload, user, site, isTrustedConsumer);\n\n            site = siteMembershipUpdater.addOrUpdateSiteMembership(payload, isTrustedConsumer, user, site);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.afterSiteMembership, user, site);\n\n            String toolPlacementId = addOrCreateTool(payload, isTrustedConsumer, user, site);\n\n            invokeProcessors(payload, isTrustedConsumer, ProcessingState.beforeLaunch, user, site);\n\n            syncSiteMembershipsOnceThenSchedule(payload, site, isTrustedConsumer, isEmailTrustedConsumer);\n\n            // Construct a URL to this tool\n            StringBuilder url = new StringBuilder();\n                url.append(SakaiBLTIUtil.getOurServerUrl());\n                url.append(ServerConfigurationService.getString(\"portalPath\", \"/portal\"));\n                url.append(\"/tool-reset/\");\n                url.append(toolPlacementId);\n                url.append(\"?panel=Main\");\n\n            if (M_log.isDebugEnabled()) {\n                M_log.debug(\"url=\" + url.toString());\n            }\n            //String toolLink = ServerConfigurationService.getPortalUrl()+ \"/tool-reset/\" + placement_id + \"?panel=Main\";\n            // Compensate for bug in getPortalUrl()\n            //toolLink = toolLink.replace(\"IMS BLTI Portlet\", \"portal\");\n            response.setContentType(\"text/html\");\n            response.setStatus(HttpServletResponse.SC_FOUND);\n            response.sendRedirect(url.toString());\n\n        } catch (LTIException ltiException) {\n            doError(request, response, ltiException.getErrorKey(), ltiException.getMessage(), ltiException.getCause());\n        }\n\n\n\t\t/*\n\t\t\n\t\tPrintWriter out = response.getWriter();\n\t\tout.println(\"<body><div style=\\\"text-align: center\\\">\");\n\t\tout.println(\"&nbsp;<br/>&nbsp;<br/>&nbsp;<br/>&nbsp;<br/>\");\n\t\tout.println(\"&nbsp;<br/>&nbsp;<br/>&nbsp;<br/>&nbsp;<br/>\");\n\t\tout.println(\"<a href=\\\"\" + url.toString() + \"\\\">\");\n\t\tout.println(\"<span id=\\\"hideme\\\">\" + rb.getString(\"launch.continue\")\n\t\t\t\t+ \"<\/span>\");\n\t\tout.println(\"<\/a>\");\n\t\tout.println(\" <script language=\\\"javascript\\\"> \\n\"\n\t\t\t\t\t\t+ \"    document.getElementById(\\\"hideme\\\").style.display = \\\"none\\\";\\n\"\n\t\t\t\t\t\t+ \"    location.href=\\\"\" + url.toString() + \"\\\";\\n\"\n\t\t\t\t\t\t+ \" <\/script> \\n\");\n\t\tout.println(\"<\/div>\");\n\t\tout.println(\"<\/body>\");\n\t\t\n\t\tout.close();\n\t\t*/\n\t\t\n\n\t}","commit_id":"4bd061c62121caa4d5ab9e2c1fdf845da06449d8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static Application getCASAEntry(String toolRegistration)\n\t{\n\t\tTool theTool = ToolManager.getTool(toolRegistration);\n\t\tif ( theTool == null ) return null;\n\t\tLTI2Config cnf = new SakaiLTI2Config();\n\t\tboolean sample = false;\n\t\tif ( cnf.getGuid() == null ) {\n\t\t\tcnf = new SakaiLTI2Base();\n\t\t\tsample = true;\n\t\t}\n\n\t\tLaunch launch = new Launch();\n\t\tlaunch.setLaunch_url(SakaiBLTIUtil.getOurServerUrl() + \"/imsblti/provider/\"+toolRegistration);\n\n\t\tUse use = new Use(launch);\n\t\t// TODO: Fix this \n\t\tuse.setIcon_url(\"https://www.apereo.org/sites/all/themes/apereo/images/apereo-logo-white-bg.png\");\n\t\tuse.setTitle(theTool.getTitle());\n\t\tuse.setText(theTool.getDescription());\n\t\tuse.addContact(new Contact(cnf.getService_owner_owner_name(), cnf.getService_owner_support_email()));\n\n\t\tOriginal orig = new Original(use);\n\t\torig.setUri(SakaiBLTIUtil.getOurServerUrl());\n\t\torig.setPropagate(Boolean.TRUE);\n\t\torig.setShare(Boolean.TRUE);\n\t\t// TODO: Fix this when I know the rules\n\t\torig.setTimestamp(\"2015-01-02T22:17:00.371Z\");\n\n\t\tIdentity identity = new Identity(cnf.getService_owner_id(), toolRegistration);\n\n\t\tApplication app = new Application(identity,orig);\n\t\treturn app;\n\t}","id":90161,"modified_method":"public static Application getCASAEntry(String toolRegistration)\n\t{\n\t\tTool theTool = ToolManager.getTool(toolRegistration);\n\t\tif ( theTool == null ) return null;\n\t\tLTI2Config cnf = new SakaiLTI2Config();\n\t\tboolean sample = false;\n\t\tif ( cnf.getGuid() == null ) {\n\t\t\tcnf = new SakaiLTI2Base();\n\t\t\tsample = true;\n\t\t}\n\n\t\tLaunch launch = new Launch();\n\t\tlaunch.setLaunch_url(SakaiBLTIUtil.getOurServerUrl() + \"/imsblti/provider/\"+toolRegistration);\n\n\t\tUse use = new Use(launch);\n\t\t// TODO: Fix this by generating all the PNGs for Sakai icons\n\t\tuse.setIcon_url(\"https://www.apereo.org/sites/all/themes/apereo/images/apereo-logo-white-bg.png\");\n\t\tuse.setTitle(theTool.getTitle());\n\n\t\tString desc = theTool.getDescription();\n\t\tif ( desc == null ) desc = theTool.getTitle();\n\t\tif ( desc == null ) desc = \"\";\n                String note = ServerConfigurationService.getString(\"casa.provider.note\", null);\n\t\tif ( note != null ) {\n\t\t\tdesc = desc.trim();\n\t\t\tif ( ! desc.endsWith(\".\") ) desc += \".\";\n\t\t\tdesc += \" \"+note;\n\t\t}\n\t\tuse.setText(desc);\n\t\tuse.addContact(new Contact(cnf.getService_owner_owner_name(), cnf.getService_owner_support_email()));\n\n\t\tOriginal orig = new Original(use);\n\t\torig.setUri(SakaiBLTIUtil.getOurServerUrl());\n\t\torig.setPropagate(Boolean.TRUE);\n\t\torig.setShare(Boolean.TRUE);\n\t\t// TODO: Fix this when I know the rules\n\t\torig.setTimestamp(\"2015-01-02T22:17:00.371Z\");\n\n\t\tIdentity identity = new Identity(cnf.getService_owner_id(), toolRegistration);\n\n\t\tApplication app = new Application(identity,orig);\n\t\treturn app;\n\t}","commit_id":"4bd061c62121caa4d5ab9e2c1fdf845da06449d8","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public synchronized void testIgnored(Description description) throws Exception {\n    testStarted(description);\n    prepareIgnoreMessage(description, true);\n    testFinished(description);\n  }","id":90162,"modified_method":"public synchronized void testIgnored(Description description) throws Exception {\n    testStarted(description);\n    Map attrs = new HashMap();\n    try {\n      final Ignore ignoredAnnotation = (Ignore)description.getAnnotation(Ignore.class);\n      if (ignoredAnnotation != null) {\n        final String val = ignoredAnnotation.value();\n        if (val != null) {\n          attrs.put(\"message\", val);\n        }\n      }\n    }\n    catch (NoSuchMethodError ignored) {\n      //junit < 4.4\n    }\n    attrs.put(\"name\", JUnit4ReflectionUtil.getMethodName(description));\n    myPrintStream.println(ServiceMessage.asString(ServiceMessageTypes.TEST_IGNORED, attrs));\n    testFinished(description);\n  }","commit_id":"e97b2f065b48f5a8ceacad8cf9289c6ee2ed6993","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testAssumptionFailure(Failure failure) {\n    prepareIgnoreMessage(failure.getDescription(), false);\n  }","id":90163,"modified_method":"public void testAssumptionFailure(Failure failure) {\n    final Description description = failure.getDescription();\n    try {\n      final String methodName = JUnit4ReflectionUtil.getMethodName(description);\n      //class setUp failed\n      if (methodName == null) {\n        for (Iterator iterator = description.getChildren().iterator(); iterator.hasNext(); ) {\n          final Description testDescription = (Description)iterator.next();\n          testAssumptionFailure(failure, testDescription, JUnit4ReflectionUtil.getMethodName(testDescription));\n        }\n      }\n      else {\n        testAssumptionFailure(failure, description, methodName);\n      }\n    }\n    catch (Exception ignore) {}\n  }","commit_id":"e97b2f065b48f5a8ceacad8cf9289c6ee2ed6993","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testFailure(Failure failure) throws Exception {\n    final Map attrs = new HashMap();\n    attrs.put(\"name\", JUnit4ReflectionUtil.getMethodName(failure.getDescription()));\n    final long duration = currentTime() - myCurrentTestStart;\n    if (duration > 0) {\n      attrs.put(\"duration\", Long.toString(duration));\n    }\n    try {\n      final String trace = failure.getTrace();\n      final Throwable ex = failure.getException();\n      final ComparisonFailureData notification = createExceptionNotification(ex);\n      ComparisonFailureData.registerSMAttributes(notification, trace, failure.getMessage(), attrs, ex);\n    }\n    catch (Throwable e) {\n      final StringWriter stringWriter = new StringWriter();\n      final PrintWriter writer = new PrintWriter(stringWriter);\n      e.printStackTrace(writer);\n      ComparisonFailureData.registerSMAttributes(null, stringWriter.toString(), e.getMessage(), attrs, e);\n    }\n    finally {\n      myPrintStream.println(ServiceMessage.asString(ServiceMessageTypes.TEST_FAILED, attrs));\n    }\n  }","id":90164,"modified_method":"public void testFailure(Failure failure) throws Exception {\n    final Description description = failure.getDescription();\n    final String methodName = JUnit4ReflectionUtil.getMethodName(description);\n    //class setUp failed\n    if (methodName == null) {\n      for (Iterator iterator = description.getChildren().iterator(); iterator.hasNext(); ) {\n        testFailure(failure, ServiceMessageTypes.TEST_FAILED, JUnit4ReflectionUtil.getMethodName((Description)iterator.next()));\n      }\n    }\n    else {\n      testFailure(failure, ServiceMessageTypes.TEST_FAILED, methodName);\n    }\n  }","commit_id":"e97b2f065b48f5a8ceacad8cf9289c6ee2ed6993","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the delete template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The delete template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearre containgine the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n        \n        // the template to be displayed\n        String template=null;\n        \n        // get the lasturl parameter\n        String lasturl = getLastUrl(cms, parameters);\n                        \n        String delete=(String)parameters.get(C_PARA_DELETE);          \n        if (delete != null) {\n            session.putValue(C_PARA_DELETE,delete);        \n        }\n        delete=(String)session.getValue(C_PARA_DELETE); \n        \n        String filename=(String)parameters.get(C_PARA_FILE);\n        if (filename != null) {\n            session.putValue(C_PARA_FILE,filename);        \n        }\n        filename=(String)session.getValue(C_PARA_FILE);\n        \n        String action = (String)parameters.get(\"action\");\n        \n\t\tA_CmsResource file=(A_CmsResource)cms.readFileHeader(filename);\n\n        if (file.isFile()) {\n            template=\"file\";\n        } else {\n            template=\"folder\";\n        }\n\n        //check if the name parameter was included in the request\n        // if not, the delete page is shown for the first time\n    \n\n        if (delete != null) {\n            if (action== null) {\n                template=\"wait\";                \n            } else {\n            \n            // check if the resource is a file or a folder\n            if (file.isFile()) {            \n                // its a file, so delete it\n                deleteFile(cms,file,false);\n            \n                session.removeValue(C_PARA_FILE);\n                try {\n                    if(lasturl == null || \"\".equals(lasturl)) {\n                        cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                    } else {\n                        ((HttpServletResponse)(cms.getRequestContext().getResponse().getOriginalResponse())).sendRedirect(lasturl);                       \n                    }                            \n                } catch (Exception e) {\n                    throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,e);\n                } \n                \n            } else {               \n                // its a folder, so try to delete the folder and its subfolders\n                // get all subfolders and files\n                Vector allFolders=new Vector();\n                Vector allFiles=new Vector();\n                getAllResources(cms,filename,allFiles,allFolders);\n                \n                // unlock the folder, otherwise the subflders and files could not be\n                // deleted.\n                cms.unlockResource(filename);\n                \n                // now delete all files in the subfolders\n                for (int i=0;i<allFiles.size();i++) {\n                    CmsFile newfile=(CmsFile)allFiles.elementAt(i);  \n                    cms.lockResource(newfile.getAbsolutePath());\n                    deleteFile(cms,newfile,true);\n                }    \n                \n                // now delete all subfolders\n                for (int i=0;i<allFolders.size();i++) {\n                    CmsFolder folder=(CmsFolder)allFolders.elementAt(allFolders.size()-i-1);  \n                    cms.lockResource(folder.getAbsolutePath());\n                    cms.deleteFolder(folder.getAbsolutePath());\n                }\n                \n                // finally delete the selected folder\n                cms.lockResource(filename);\n                cms.deleteFolder(filename);\n                session.removeValue(C_PARA_FILE);\n                template=\"update\";\n            }\n            }\n            \n          \n            \n            // TODO: Error handling\n           \n        }\n\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);\n        // set the required datablocks\n        String title=cms.readProperty(file.getAbsolutePath(),C_PROPERTY_TITLE);\n        if (title==null) {\n            title=\"\";\n        }\n        A_CmsUser owner=cms.readOwner(file);\n        xmlTemplateDocument.setXmlData(\"TITLE\",title);\n        xmlTemplateDocument.setXmlData(\"STATE\",getState(cms,file,new CmsXmlLanguageFile(cms)));\n        xmlTemplateDocument.setXmlData(\"OWNER\",owner.getFirstname()+\" \"+owner.getLastname()+\"(\"+owner.getName()+\")\");\n        xmlTemplateDocument.setXmlData(\"GROUP\",cms.readGroup(file).getName());\n\t\txmlTemplateDocument.setXmlData(\"FILENAME\",file.getName());\n           \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template); \n    }","id":90165,"modified_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the delete template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The delete template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearre containgine the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n        \n        // the template to be displayed\n        String template=null;\n        \n        // get the lasturl parameter\n        String lasturl = getLastUrl(cms, parameters);\n                        \n        String delete=(String)parameters.get(C_PARA_DELETE);          \n        if (delete != null) {\n            session.putValue(C_PARA_DELETE,delete);        \n        }\n        delete=(String)session.getValue(C_PARA_DELETE); \n        \n        String filename=(String)parameters.get(C_PARA_FILE);\n        if (filename != null) {\n            session.putValue(C_PARA_FILE,filename);        \n        }\n        filename=(String)session.getValue(C_PARA_FILE);\n        \n        String action = (String)parameters.get(\"action\");\n        \n\t\tA_CmsResource file=(A_CmsResource)cms.readFileHeader(filename);\n\n        if (file.isFile()) {\n            template=\"file\";\n        } else {\n            template=\"folder\";\n        }\n\n        //check if the name parameter was included in the request\n        // if not, the delete page is shown for the first time\n    \n\n        if (delete != null) {\n            if (action== null) {\n                template=\"wait\";                \n            } else {\n            \n            // check if the resource is a file or a folder\n            if (file.isFile()) {            \n                // its a file, so delete it\n                deleteFile(cms,file,false);\n            \n                session.removeValue(C_PARA_FILE);\n                try {\n                    if(lasturl == null || \"\".equals(lasturl)) {\n                        cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                    } else {\n                        ((HttpServletResponse)(cms.getRequestContext().getResponse().getOriginalResponse())).sendRedirect(lasturl);                       \n                    }                            \n                } catch (Exception e) {\n                    throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,e);\n                } \n                \n            } else {               \n                // its a folder, so try to delete the folder and its subfolders\n                // get all subfolders and files\n                Vector allFolders=new Vector();\n                Vector allFiles=new Vector();\n         \n                getAllResources(cms,filename,allFiles,allFolders);\n               \n                // unlock the folder, otherwise the subflders and files could not be\n                // deleted.\n                cms.unlockResource(filename);\n             \n                // now delete all files in the subfolders\n                for (int i=0;i<allFiles.size();i++) {\n                    CmsFile newfile=(CmsFile)allFiles.elementAt(i);  \n                    cms.lockResource(newfile.getAbsolutePath());\n                    deleteFile(cms,newfile,true);\n                }    \n        \n                // now delete all subfolders\n                for (int i=0;i<allFolders.size();i++) {\n                    CmsFolder folder=(CmsFolder)allFolders.elementAt(allFolders.size()-i-1);  \n                    cms.lockResource(folder.getAbsolutePath());\n                    cms.deleteFolder(folder.getAbsolutePath());\n                }\n         \n                // finally delete the selected folder\n                cms.lockResource(filename);\n                cms.deleteFolder(filename);\n                session.removeValue(C_PARA_FILE);\n                template=\"update\";\n            \n            }\n            }\n            \n          \n            \n            // TODO: Error handling\n           \n        }\n\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);\n        // set the required datablocks\n        if (action == null) {\n            String title=cms.readProperty(file.getAbsolutePath(),C_PROPERTY_TITLE);\n            if (title==null) {\n               title=\"\";\n            }\n            A_CmsUser owner=cms.readOwner(file);\n            xmlTemplateDocument.setXmlData(\"TITLE\",title);\n            xmlTemplateDocument.setXmlData(\"STATE\",getState(cms,file,new CmsXmlLanguageFile(cms)));\n            xmlTemplateDocument.setXmlData(\"OWNER\",owner.getFirstname()+\" \"+owner.getLastname()+\"(\"+owner.getName()+\")\");\n            xmlTemplateDocument.setXmlData(\"GROUP\",cms.readGroup(file).getName());\n\t\t    xmlTemplateDocument.setXmlData(\"FILENAME\",file.getName());\n        }\n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template); \n    }","commit_id":"a5925e0f4f8a26ff7aba0051df8a95e28803290c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Gets a formated file state string.\n     * @param cms The CmsObject.\n     * @param file The CmsResource.\n     * @param lang The content definition language file.\n     * @return Formated state string.\n     */\n     private String getState(A_CmsObject cms, CmsResource file,CmsXmlLanguageFile lang)\n         throws CmsException {\n         StringBuffer output=new StringBuffer();\n         \n         if (file.inProject(cms.getRequestContext().currentProject())) {\n            int state=file.getState();\n            output.append(lang.getLanguageValue(\"explorer.state\"+state));\n         } else {\n            output.append(lang.getLanguageValue(\"explorer.statenip\"));\n         }\n         return output.toString();\n     }","id":90166,"modified_method":"/**\n     * Gets a formated file state string.\n     * @param cms The CmsObject.\n     * @param file The CmsResource.\n     * @param lang The content definition language file.\n     * @return Formated state string.\n     */\n     private String getState(A_CmsObject cms, A_CmsResource file,CmsXmlLanguageFile lang)\n         throws CmsException {\n         StringBuffer output=new StringBuffer();\n         \n         if (file.inProject(cms.getRequestContext().currentProject())) {\n            int state=file.getState();\n            output.append(lang.getLanguageValue(\"explorer.state\"+state));\n         } else {\n            output.append(lang.getLanguageValue(\"explorer.statenip\"));\n         }\n         return output.toString();\n     }","commit_id":"a5925e0f4f8a26ff7aba0051df8a95e28803290c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n      * Move a file to another folder.\n      * If the file is a page, the content will be moved too.\n      * @param cms The CmsObject.\n      * @param file The file to be moved.\n      * @param newFolder The folder the file has to be moved to.\n      * @param flags Flags that indicate if the access flags have to be set to the default values.\n      */\n     private void moveFile(A_CmsObject cms, CmsFile file, String newFolder, String flags) \n        throws CmsException {\n        if( (cms.getResourceType(file.getType()).getResourceName()).equals(C_TYPE_PAGE_NAME) ){\n\t\t    String bodyPath = getBodyPath(cms, file);\n    \t    int help = C_CONTENTBODYPATH.lastIndexOf(\"/\");\n\t\t\tString hbodyPath=(C_CONTENTBODYPATH.substring(0,help))+(file.getAbsolutePath());\n\t\t\tif (hbodyPath.equals(bodyPath)){\n\t\t\t\tcheckFolders(cms, newFolder);\n\t\t\t\tcms.moveFile((C_CONTENTBODYPATH.substring(0,help))+file.getAbsolutePath(),(C_CONTENTBODYPATH.substring(0,help))+newFolder+file.getName());\n\t\t\t\tif (flags.equals(\"false\")) {\n\t\t\t\t\t // set access flags of the new file to the default flags\n\t\t\t\t\tCmsFile newfile=cms.readFile(newFolder,file.getName());\n\t\t\t\t\n                    Hashtable startSettings=null;\n                    Integer accessFlags=null;\n                    startSettings=(Hashtable)cms.getRequestContext().currentUser().getAdditionalInfo(C_ADDITIONAL_INFO_STARTSETTINGS);                    \n                    if (startSettings != null) {\n                        accessFlags=(Integer)startSettings.get(C_START_ACCESSFLAGS);\n                        if (accessFlags == null) {\n                            accessFlags=new Integer(C_ACCESS_DEFAULT_FLAGS);\n                        }\n                    }                           \n                    newfile.setAccessFlags(accessFlags.intValue());  \n\t\t\t\t \n\t\t\t\t \tcms.writeFile(newfile);\n                }\n            changeContent(cms, file, (C_CONTENTBODYPATH.substring(0,help))+newFolder+file.getName());\n\t\t\t}\n\t\t\t\t\n\t\t}\n        // moves the file and set the access flags if nescessary\n\t    cms.moveFile(file.getAbsolutePath(),newFolder+file.getName());\n\t\t\t \n       if (flags.equals(\"false\")) {\n        // set access flags of the new file to the default flags\n\t\tCmsFile newfile=cms.readFile(newFolder,file.getName());\n                \n        Hashtable startSettings=null;\n        Integer accessFlags=null;\n        startSettings=(Hashtable)cms.getRequestContext().currentUser().getAdditionalInfo(C_ADDITIONAL_INFO_STARTSETTINGS);                    \n            if (startSettings != null) {\n                accessFlags=(Integer)startSettings.get(C_START_ACCESSFLAGS);\n                    if (accessFlags == null) {\n                        accessFlags=new Integer(C_ACCESS_DEFAULT_FLAGS);\n                    }\n            }                           \n         newfile.setAccessFlags(accessFlags.intValue());  \n         cms.writeFile(newfile);\n\t    }\n\t\t\t\t \n     }","id":90167,"modified_method":"/**\n      * Move a file to another folder.\n      * If the file is a page, the content will be moved too.\n      * @param cms The CmsObject.\n      * @param file The file to be moved.\n      * @param newFolder The folder the file has to be moved to.\n      * @param lock Flag showing if the resource has to locked.\n      * @param flags Flags that indicate if the access flags have to be set to the default values.\n      */\n     private void moveFile(A_CmsObject cms, CmsFile file, String newFolder, String flags,\n                           boolean lock) \n        throws CmsException {\n        // check if the file type name is page\n\t\t// if so move the file body and content and change the content of content\n\t\t// else move only file\n        if( (cms.getResourceType(file.getType()).getResourceName()).equals(C_TYPE_PAGE_NAME) ){\n\t\t    String bodyPath = getBodyPath(cms, file);\n    \t    int help = C_CONTENTBODYPATH.lastIndexOf(\"/\");\n\t\t\tString hbodyPath=(C_CONTENTBODYPATH.substring(0,help))+(file.getAbsolutePath());\n\t\t\tif (hbodyPath.equals(bodyPath)){\n                if (lock) {\n                    cms.lockResource((C_CONTENTBODYPATH.substring(0,help))+file.getAbsolutePath());\n                }\n\t\t\t\tcheckFolders(cms, newFolder);\n\t\t\t\tcms.moveFile((C_CONTENTBODYPATH.substring(0,help))+file.getAbsolutePath(),(C_CONTENTBODYPATH.substring(0,help))+newFolder+file.getName());\n\t\t\t\tif (flags.equals(\"false\")) {\n\t\t\t\t\t // set access flags of the new file to the default flags\n\t\t\t\t\tCmsFile newfile=cms.readFile(newFolder,file.getName());\n\t\t\t\t\n                    Hashtable startSettings=null;\n                    Integer accessFlags=null;\n                    startSettings=(Hashtable)cms.getRequestContext().currentUser().getAdditionalInfo(C_ADDITIONAL_INFO_STARTSETTINGS);                    \n                    if (startSettings != null) {\n                        accessFlags=(Integer)startSettings.get(C_START_ACCESSFLAGS);\n                        if (accessFlags == null) {\n                            accessFlags=new Integer(C_ACCESS_DEFAULT_FLAGS);\n                        }\n                    }                           \n                    newfile.setAccessFlags(accessFlags.intValue());  \n\t\t\t\t \n\t\t\t\t \tcms.writeFile(newfile);\n                }\n                if (lock) {\n                    cms.unlockResource((C_CONTENTBODYPATH.substring(0,help))+newFolder+file.getName());\n                }\n            changeContent(cms, file, (C_CONTENTBODYPATH.substring(0,help))+newFolder+file.getName());\n\t\t\t}\n\t\t\t\t\n\t\t}\n        // moves the file and set the access flags if nescessary\n\t    cms.moveFile(file.getAbsolutePath(),newFolder+file.getName());\n\t\t\t \n       if (flags.equals(\"false\")) {\n        // set access flags of the new file to the default flags\n\t\tCmsFile newfile=cms.readFile(newFolder,file.getName());\n                \n        Hashtable startSettings=null;\n        Integer accessFlags=null;\n        startSettings=(Hashtable)cms.getRequestContext().currentUser().getAdditionalInfo(C_ADDITIONAL_INFO_STARTSETTINGS);                    \n            if (startSettings != null) {\n                accessFlags=(Integer)startSettings.get(C_START_ACCESSFLAGS);\n                    if (accessFlags == null) {\n                        accessFlags=new Integer(C_ACCESS_DEFAULT_FLAGS);\n                    }\n            }                           \n         newfile.setAccessFlags(accessFlags.intValue());  \n         cms.writeFile(newfile);\n\t    }\n\t\t\t\t \n     }","commit_id":"a5925e0f4f8a26ff7aba0051df8a95e28803290c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the move template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The move template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearre containgine the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n        \n        // the template to be displayed\n        String template=null;\n      \n        // get the lasturl parameter\n        String lasturl = getLastUrl(cms, parameters);\n                        \n        // get the file to be copied\n        String filename=(String)parameters.get(C_PARA_FILE);\n        if (filename != null) {\n            session.putValue(C_PARA_FILE,filename);        \n        }\n        filename=(String)session.getValue(C_PARA_FILE);\n        \n        // read all request parameters\n        String newFolder=(String)parameters.get(\"newfolder\");\n        String flags=(String)parameters.get(\"flags\");\n        \n        CmsFile file=(CmsFile)cms.readFileHeader(filename);\n        \n        // modify the folderaname if nescessary (the root folder is always given\n        // as a nice name)\n        if (newFolder!= null) {\n            CmsXmlLanguageFile lang=new CmsXmlLanguageFile(cms);\n            if (newFolder.equals(lang.getLanguageValue(\"title.rootfolder\"))) {\n                newFolder=\"/\";\n            }\n        }\n\n\t\t //check if the newFolder parameter was included in the request\n         //if not, the move page is shown for the first time\n         if (newFolder != null) {\n\t\t\t // check if the file type name is page\n\t\t\t // if so move the file body and content and change the content of content\n\t\t\t // else move only file\n             moveFile(cms,file,newFolder,flags);\n\t\t\t\n             // TODO: Error handling\n             try {\n                if(lasturl == null || \"\".equals(lasturl)) {\n                    cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                } else {\n                    ((HttpServletResponse)(cms.getRequestContext().getResponse().getOriginalResponse())).sendRedirect(lasturl);                       \n                }                            \n            } catch (Exception e) {\n                  throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,e);\n            } \n        }\n\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);          \n        // set the required datablocks\n        String title=cms.readProperty(file.getAbsolutePath(),C_PROPERTY_TITLE);\n        if (title==null) {\n            title=\"\";\n        }\n        A_CmsUser owner=cms.readOwner(file);\n        xmlTemplateDocument.setXmlData(\"TITLE\",title);\n        xmlTemplateDocument.setXmlData(\"STATE\",getState(cms,file,new CmsXmlLanguageFile(cms)));\n        xmlTemplateDocument.setXmlData(\"OWNER\",owner.getFirstname()+\" \"+owner.getLastname()+\"(\"+owner.getName()+\")\");\n        xmlTemplateDocument.setXmlData(\"GROUP\",cms.readGroup(file).getName());\n\t\txmlTemplateDocument.setXmlData(\"FILENAME\",file.getName());\n   \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template);   \n    }","id":90168,"modified_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the move template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The move template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearre containgine the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n        \n        // the template to be displayed\n        String template=null;\n      \n        // get the lasturl parameter\n        String lasturl = getLastUrl(cms, parameters);\n                        \n        // get the file to be copied\n        String filename=(String)parameters.get(C_PARA_FILE);\n        if (filename != null) {\n            session.putValue(C_PARA_FILE,filename);        \n        }\n        filename=(String)session.getValue(C_PARA_FILE);\n        \n        // read all request parameters\n        String newFolder=(String)parameters.get(C_PARA_NEWFOLDER);\n        if (newFolder != null) {\n            session.putValue(C_PARA_NEWFOLDER,newFolder);        \n        }\n        newFolder=(String)session.getValue(C_PARA_NEWFOLDER);\n\n        String flags=(String)parameters.get(C_PARA_FLAGS);\n        if (flags != null) {\n            session.putValue(C_PARA_FLAGS,flags);        \n        }\n        flags=(String)session.getValue(C_PARA_FLAGS);\n        \n        String action = (String)parameters.get(\"action\");\n        \n        A_CmsResource file=(A_CmsResource)cms.readFileHeader(filename);\n        \n        // modify the folderaname if nescessary (the root folder is always given\n        // as a nice name)\n        if (newFolder!= null) {\n            CmsXmlLanguageFile lang=new CmsXmlLanguageFile(cms);\n            if (newFolder.equals(lang.getLanguageValue(\"title.rootfolder\"))) {\n                newFolder=\"/\";\n            }\n        }\n\n        // select the template to be displayed\n        if (file.isFile()) {\n            template=\"file\";            \n        } else {\n            template=\"folder\";\n        }\n        \n\t\t //check if the newFolder parameter was included in the request\n         //if not, the move page is shown for the first time\n         if (newFolder != null) {\n            if (action== null) {\n                template=\"wait\";                \n            } else {\n                 if (file.isFile()) {\n                    // this is a file, so move it               \n                    try {\n                        moveFile(cms,(CmsFile)file,newFolder,flags,false);\n                    } catch (CmsException ex) {\n                        // something went wrong, so remove all session parameters\n                        session.removeValue(C_PARA_FILE);\n\t    \t\t        session.removeValue(C_PARA_NEWFOLDER);\n                        session.removeValue(C_PARA_FLAGS);\n                        throw ex;\n                    }\n                   \n                    // everything is done, so remove all session parameters\n                    session.removeValue(C_PARA_FILE);\n\t    \t\t    session.removeValue(C_PARA_NEWFOLDER);\n                    session.removeValue(C_PARA_FLAGS);\n                    \n                    // TODO: Error handling\n                    \n                    // return to the calling page\n                    try {\n                        if(lasturl == null || \"\".equals(lasturl)) {\n                            cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                        } else {\n                            ((HttpServletResponse)(cms.getRequestContext().getResponse().getOriginalResponse())).sendRedirect(lasturl);                       \n                        }                            \n                    } catch (Exception e) {\n                        throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,e);\n                    } \n                } else {\n                     // this is a folder\n                    // get all subfolders and files\n                    Vector allFolders=new Vector();\n                    Vector allFiles=new Vector();\n                    getAllResources(cms,filename,allFiles,allFolders);\n          \n                    try {     \n                    \n                        // first creatre the new folder\n                        cms.unlockResource(file.getAbsolutePath());\n                        cms.copyFolder(filename,newFolder+file.getName()+\"/\");\n                                    \n                        // then copy all folders\n                        for (int i=0;i<allFolders.size();i++) {                            \n                            CmsFolder folder=(CmsFolder)allFolders.elementAt(i);  \n                            String newname=newFolder+file.getName()+\"/\"+folder.getAbsolutePath().substring(file.getAbsolutePath().length());                                                                             \n                            System.err.println(\"Copy File \"+folder.getAbsolutePath()+ \"- > \"+newname);\n                            cms.copyFolder(folder.getAbsolutePath(), newname);\n                        }\n                     \n                        // now move the files\n                        for (int i=0;i<allFiles.size();i++) {\n                            CmsFile newfile=(CmsFile)allFiles.elementAt(i);\n                            String newname=newFolder+file.getName()+\"/\"+newfile.getAbsolutePath().substring(file.getAbsolutePath().length());                                                                       \n                            cms.lockResource(newfile.getAbsolutePath());\n                           // cms.moveFile(newfile.getAbsolutePath(),newname);\n                            System.err.println(\"Copy File \"+newfile.getAbsolutePath()+ \"- > \"+newFolder+file.getName()+\"/\");\n                           \n                            moveFile(cms,newfile,newFolder+file.getName()+\"/\",\"true\",true);\n                            cms.unlockResource(newname);\n                        }\n                        \n                       // finally remove the original folders\n                        for (int i=0;i<allFolders.size();i++) {\n                            CmsFolder folder=(CmsFolder)allFolders.elementAt(allFolders.size()-i-1);  \n                            cms.lockResource(folder.getAbsolutePath());\n                            System.err.println(\"Delete Folder \"+folder.getAbsolutePath());\n                           \n                            cms.deleteFolder(folder.getAbsolutePath());\n                        }\n                        \n                        // as the last step, delete the original folder\n                         cms.lockResource(filename);\n                         cms.deleteFolder(filename);        \n                         cms.lockResource(newFolder+file.getName()+\"/\");\n                       \n                    } catch (CmsException ex) {\n                        // something went wrong, so remove all session parameters\n                        session.removeValue(C_PARA_FILE);\n\t    \t\t        session.removeValue(C_PARA_NEWFOLDER);\n                        session.removeValue(C_PARA_FLAGS);\n                        throw ex;\n                    }\n                      \n                    // everything is done, so remove all session parameters\n                    session.removeValue(C_PARA_FILE);\n\t    \t\t    session.removeValue(C_PARA_NEWFOLDER);\n                    session.removeValue(C_PARA_FLAGS);\n                    template=\"update\";\n                }\n            }\n\t\t\t\n            \n        }\n\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);          \n        // set the required datablocks\n        if (action == null) {\n            String title=cms.readProperty(file.getAbsolutePath(),C_PROPERTY_TITLE);\n            if (title==null) {\n                title=\"\";\n            }            \n            \n            A_CmsUser owner=cms.readOwner(file);\n            xmlTemplateDocument.setXmlData(\"TITLE\",title);\n            xmlTemplateDocument.setXmlData(\"STATE\",getState(cms,file,new CmsXmlLanguageFile(cms)));\n            xmlTemplateDocument.setXmlData(\"OWNER\",owner.getFirstname()+\" \"+owner.getLastname()+\"(\"+owner.getName()+\")\");\n            xmlTemplateDocument.setXmlData(\"GROUP\",cms.readGroup(file).getName());\n\t\t    xmlTemplateDocument.setXmlData(\"FILENAME\",file.getName());\n        }\n        \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template);\n    }","commit_id":"a5925e0f4f8a26ff7aba0051df8a95e28803290c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the new resource othertype template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The lock template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearry containing the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n        // the template to be displayed\n        String template=null;\n        String filename=null;\n        String title=null;\n        String foldername=null;\n        String type=null;\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n  \n        \n        // get the current phase of this wizard\n        String step=cms.getRequestContext().getRequest().getParameter(\"step\");\n       \n        if (step != null) {\n            // step 1 - show the final selection screen\n            if (step.equals(\"1\")) {\n                template=\"step1\";\n                filename=cms.getRequestContext().getRequest().getParameter(C_PARA_FILE);\n                session.putValue(C_PARA_FILE,filename);\n                title=cms.getRequestContext().getRequest().getParameter(C_PARA_TITLE);\n                session.putValue(C_PARA_TITLE,title);\n            } else if (step.equals(\"2\")) {\n                // step 2 - create the file\n                // get folder- and filename\n                foldername=(String)session.getValue(C_PARA_FILELIST);\n                title=(String)session.getValue(C_PARA_TITLE);\n                if (foldername==null) {\n                   foldername=cms.getRequestContext().currentFolder().getAbsolutePath();\n                }   \n                filename=(String)session.getValue(C_PARA_FILE);\n                type=(String)cms.getRequestContext().getRequest().getParameter(\"type\");\n                // create the new file\n                cms.createFile(foldername,filename,new byte[0],type);\n                // lock the new file\n                cms.lockResource(foldername+filename);\n                cms.writeProperty(foldername+filename,C_PROPERTY_TITLE,title);\n                // remove values from session\n                session.removeValue(C_PARA_FILE);\n                session.removeValue(C_PARA_TITLE);     \n                // TODO: ErrorHandling\n                \n                // now return to filelist\n                try {\n                    cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                } catch (Exception e) {\n                      throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,e);\n                }\n            }\n        } else {\n            session.removeValue(C_PARA_FILE);\n        }\n\n        // get the document to display\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);          \n        \n        // set the size of the radiobox entrys\n        getResources(cms,null,null,null,null,null);\n        if (m_names != null) { \n             xmlTemplateDocument.setXmlData(C_RADIOSIZE,new Integer(m_names.size()).toString());\n        } \n        \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template);\n    \n    }","id":90169,"modified_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the new resource othertype template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The lock template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearry containing the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n        // the template to be displayed\n        String template=null;\n        String filename=null;\n        String title=null;\n        String foldername=null;\n        String type=null;\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n  \n        \n        // get the current phase of this wizard\n        String step=cms.getRequestContext().getRequest().getParameter(\"step\");\n       \n        if (step != null) {\n            // step 1 - show the final selection screen\n            if (step.equals(\"1\")) {\n                template=\"step1\";\n                filename=cms.getRequestContext().getRequest().getParameter(C_PARA_FILE);\n                session.putValue(C_PARA_FILE,filename);\n                title=cms.getRequestContext().getRequest().getParameter(C_PARA_TITLE);\n                session.putValue(C_PARA_TITLE,title);\n            } else if (step.equals(\"2\")) {\n                // step 2 - create the file\n                // get folder- and filename\n                foldername=(String)session.getValue(C_PARA_FILELIST);\n                title=(String)session.getValue(C_PARA_TITLE);\n                if (foldername==null) {\n                   foldername=cms.rootFolder().getAbsolutePath();\n                }   \n                filename=(String)session.getValue(C_PARA_FILE);\n                type=(String)cms.getRequestContext().getRequest().getParameter(\"type\");\n                // create the new file\n                cms.createFile(foldername,filename,new byte[0],type);\n                // lock the new file\n                System.err.println(\"Lock file\");\n                cms.lockResource(foldername+filename);\n                System.err.println(\"Write property\");        \n                cms.writeProperty(foldername+filename,C_PROPERTY_TITLE,title);\n                System.err.println(\"Done\");\n                // remove values from session\n                session.removeValue(C_PARA_FILE);\n                session.removeValue(C_PARA_TITLE);     \n                // TODO: ErrorHandling\n                \n                // now return to filelist\n                try {\n                    cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                } catch (Exception e) {\n                      throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,e);\n                }\n            }\n        } else {\n            session.removeValue(C_PARA_FILE);\n        }\n\n        // get the document to display\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);          \n        \n        // set the size of the radiobox entrys\n        getResources(cms,null,null,null,null,null);\n        if (m_names != null) { \n             xmlTemplateDocument.setXmlData(C_RADIOSIZE,new Integer(m_names.size()).toString());\n        } \n        \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template);\n    \n    }","commit_id":"a5925e0f4f8a26ff7aba0051df8a95e28803290c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the new resource upload page template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The upload template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearry containing the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n                      \n        // the template to be displayed\n        String template=null;\n\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n\n\n           // get the parameters from the request and session\n        String step=(String)parameters.get(\"STEP\");                  \n        String currentFolder=(String)session.getValue(C_PARA_FILELIST);\n        String title=(String)parameters.get(C_PARA_TITLE);       \n        String newname=(String)parameters.get(C_PARA_NAME);\n        \n        // get filename and file content if available\n        String filename=null;\n        byte[] filecontent=new byte[0];\n        \n        // get the filename\n        Enumeration files=cms.getRequestContext().getRequest().getFileNames();\n        while (files.hasMoreElements()) {\n           filename=(String)files.nextElement();\n        }             \n        if (filename != null) {\n            session.putValue(C_PARA_FILE,filename);\n        }        \n        filename=(String)session.getValue(C_PARA_FILE);\n        \n        // get the filecontent\n        if (filename != null) {\n            filecontent=cms.getRequestContext().getRequest().getFile(filename);\n        }        \n        if (filecontent != null) {\n            session.putValue(C_PARA_FILECONTENT,filecontent);          \n        }        \n        filecontent=(byte[])session.getValue(C_PARA_FILECONTENT);\n     \n        //get the filetype\n        String newtype=(String)parameters.get(C_PARA_NEWTYPE);  \n        if (newtype != null) {\n             session.putValue(C_PARA_NEWTYPE,newtype);        \n        }\n        newtype=(String)session.getValue(C_PARA_NEWTYPE);\n        \n        // get the document to display\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);       \n        \n        // there was a file uploaded, so select its type\n        if (step != null) {\n            if (step.equals(\"1\")) {\n                // display the select filetype screen\n                if (filename!= null) {\n                    template=\"step1\";   \n                }\n           } else if (step.equals(\"2\")) {\n                // get the selected resource and check if it is an image\n                A_CmsResourceType type=cms.getResourceType(newtype);\n                if (newtype.equals(C_TYPE_IMAGE_NAME)) {\n                    // the file type is an image\n                    template=\"image\";   \n                    xmlTemplateDocument.setXmlData(\"MIME\",filename);\n                    xmlTemplateDocument.setXmlData(\"SIZE\",\"Not yet available\");\n                    xmlTemplateDocument.setXmlData(\"FILESIZE\",new Integer(filecontent.length).toString()+\" Bytes\");\n        \n                } else {\n                    // create the new file.    \n                    // todo: error handling if file already exits      \n                    /*for (int i=10;i<100;i+=5) {\n                        filecontent=new byte[i*1000];\n                        for (int j=0;j<filecontent.length;j++) {\n                            filecontent[j]=65;\n                        }\n                        cms.createFile(currentFolder,\"test\"+i,filecontent,type.getResourceName());\n                        \n                    }*/                                        \n                    cms.createFile(currentFolder,filename,filecontent,type.getResourceName());\n                    // remove the values form the session\n                    session.removeValue(C_PARA_FILE);\n                    session.removeValue(C_PARA_FILECONTENT);\n                    session.removeValue(C_PARA_NEWTYPE);\n                    // return to the filelist\n                    try {\n                        cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                    } catch (Exception ex) {\n                        throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,ex);\n                    }                      \n                }\n            } else if (step.equals(\"3\")) {\n                // get the data from the special image upload dialog\n                \n                // check if a new filename is given\n                if (newname != null) {\n                    filename=newname;   \n                }\n                // create the new file.    \n                // todo: error handling if file already exits    \n                A_CmsResourceType type=cms.getResourceType(newtype);                                                           \n                CmsFile file=cms.createFile(currentFolder,filename,filecontent,type.getResourceName());\n                // check if a file title was given\n                if (title!= null) {\n                    cms.lockResource(file.getAbsolutePath());\n                    cms.writeProperty(file.getAbsolutePath(),C_PROPERTY_TITLE,title);                  \n                    cms.unlockResource(file.getAbsolutePath());                    \n                }\n                \n                // remove the values form the session\n                session.removeValue(C_PARA_FILE);\n                session.removeValue(C_PARA_FILECONTENT);\n                session.removeValue(C_PARA_NEWTYPE);\n                // return to the filelist\n                try {\n                    cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                } catch (Exception ex) {\n                    throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,ex);\n                }  \n            }\n  \n        }\n        \n       if (filename != null) {\n            xmlTemplateDocument.setXmlData(\"FILENAME\",filename);\n       }\n     \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template);\n    }","id":90170,"modified_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the new resource upload page template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The upload template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearry containing the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n                      \n        // the template to be displayed\n        String template=null;\n\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n\n\n        // get the parameters from the request and session\n        String step=(String)parameters.get(\"STEP\");                  \n        String currentFolder=(String)session.getValue(C_PARA_FILELIST);\n        if (currentFolder==null) {\n                   currentFolder=cms.rootFolder().getAbsolutePath();\n                }   \n        String title=(String)parameters.get(C_PARA_TITLE);       \n        String newname=(String)parameters.get(C_PARA_NAME);\n        \n        // get filename and file content if available\n        String filename=null;\n        byte[] filecontent=new byte[0];\n        \n        // get the filename\n        Enumeration files=cms.getRequestContext().getRequest().getFileNames();\n        while (files.hasMoreElements()) {\n           filename=(String)files.nextElement();\n        }             \n        if (filename != null) {\n            session.putValue(C_PARA_FILE,filename);\n        }        \n        filename=(String)session.getValue(C_PARA_FILE);\n        \n        // get the filecontent\n        if (filename != null) {\n            filecontent=cms.getRequestContext().getRequest().getFile(filename);\n        }        \n        if (filecontent != null) {\n            session.putValue(C_PARA_FILECONTENT,filecontent);          \n        }        \n        filecontent=(byte[])session.getValue(C_PARA_FILECONTENT);\n     \n        //get the filetype\n        String newtype=(String)parameters.get(C_PARA_NEWTYPE);  \n        if (newtype != null) {\n             session.putValue(C_PARA_NEWTYPE,newtype);        \n        }\n        newtype=(String)session.getValue(C_PARA_NEWTYPE);\n        \n        // get the document to display\n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);       \n        \n        // there was a file uploaded, so select its type\n        if (step != null) {\n            if (step.equals(\"1\")) {\n                // display the select filetype screen\n                if (filename!= null) {\n                    template=\"step1\";   \n                }\n           } else if (step.equals(\"2\")) {\n                // get the selected resource and check if it is an image\n                A_CmsResourceType type=cms.getResourceType(newtype);\n                if (newtype.equals(C_TYPE_IMAGE_NAME)) {\n                    // the file type is an image\n                    template=\"image\";   \n                    xmlTemplateDocument.setXmlData(\"MIME\",filename);\n                    xmlTemplateDocument.setXmlData(\"SIZE\",\"Not yet available\");\n                    xmlTemplateDocument.setXmlData(\"FILESIZE\",new Integer(filecontent.length).toString()+\" Bytes\");\n        \n                } else {\n                    // create the new file.    \n                    // todo: error handling if file already exits      \n                                                 \n                    cms.createFile(currentFolder,filename,filecontent,type.getResourceName());\n                    // remove the values form the session\n                    session.removeValue(C_PARA_FILE);\n                    session.removeValue(C_PARA_FILECONTENT);\n                    session.removeValue(C_PARA_NEWTYPE);\n                    // return to the filelist\n                    try {\n                        cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                    } catch (Exception ex) {\n                        throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,ex);\n                    }                      \n                }\n            } else if (step.equals(\"3\")) {\n                // get the data from the special image upload dialog\n                \n                // check if a new filename is given\n                if (newname != null) {\n                    filename=newname;   \n                }\n                // create the new file.    \n                // todo: error handling if file already exits    \n                A_CmsResourceType type=cms.getResourceType(newtype);                                                           \n                CmsFile file=cms.createFile(currentFolder,filename,filecontent,type.getResourceName());\n                // check if a file title was given\n                if (title!= null) {\n                    cms.lockResource(file.getAbsolutePath());\n                    cms.writeProperty(file.getAbsolutePath(),C_PROPERTY_TITLE,title);                  \n                    cms.unlockResource(file.getAbsolutePath());                    \n                }\n                \n                // remove the values form the session\n                session.removeValue(C_PARA_FILE);\n                session.removeValue(C_PARA_FILECONTENT);\n                session.removeValue(C_PARA_NEWTYPE);\n                // return to the filelist\n                try {\n                    cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                } catch (Exception ex) {\n                    throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,ex);\n                }  \n            }\n  \n        }\n        \n       if (filename != null) {\n            xmlTemplateDocument.setXmlData(\"FILENAME\",filename);\n       }\n     \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template);\n    }","commit_id":"a5925e0f4f8a26ff7aba0051df8a95e28803290c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the rename template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The lock template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearre containgine the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n        \n        // the template to be displayed\n        String template=null;\n        \n        // get the lasturl parameter\n        String lasturl = getLastUrl(cms, parameters);\n                        \n        System.err.println(\"\");\n        System.err.println(\"#############\");\n        String[] names=session.getValueNames();\n        for (int i=0;i<names.length;i++) {\n            System.err.print(names[i]+\" :\");\n            System.err.println(session.getValue(names[i]));\n        }\n        System.err.println(\"#############\");\n        \n        \n        // TODO: check, if this is neede: String lock=(String)parameters.get(C_PARA_LOCK);\n        String filename=(String)parameters.get(C_PARA_FILE);\n        if (filename != null) {\n            session.putValue(C_PARA_FILE,filename);        \n        }\n        filename=(String)session.getValue(C_PARA_FILE);\n        \n        String newFile=(String)parameters.get(C_PARA_NAME);\n        if (newFile != null) {\n            session.putValue(C_PARA_NAME,newFile);        \n        }\n        newFile=(String)session.getValue(C_PARA_NAME);\n        \n        String action = (String)parameters.get(\"action\");\n\n        A_CmsResource file=(A_CmsResource)cms.readFileHeader(filename);\n      \n        if (file.isFile()) {\n            template=\"file\";\n        } else {\n            template=\"folder\";\n        }       \n      \n        //check if the name parameter was included in the request\n        // if not, the lock page is shown for the first time    \n        if (newFile == null) {\n            session.putValue(C_PARA_NAME,file.getName());\n        } else {\n            if (action== null) {\n                template=\"wait\";                \n            } else {\n            \n                // now check if the resource is a file or a folder            \n                if (file.isFile()) {\n                    // this is a file, so rename it         \n                    try {\n                        renameFile(cms,file,newFile);\n                    } catch (CmsException ex) {\n                        // something went wrong, so remove all session parameters\n                        session.removeValue(C_PARA_FILE);\n\t    \t\t        session.removeValue(C_PARA_NAME);\n                        throw ex;\n                    }\n                    \n                    // everything is done, so remove all session parameters\n                    session.removeValue(C_PARA_FILE);\n\t    \t\t    session.removeValue(C_PARA_NAME);\n                \n                    try {\n                        if(lasturl == null || \"\".equals(lasturl)) {\n                            cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                        } else {\n                            ((HttpServletResponse)(cms.getRequestContext().getResponse().getOriginalResponse())).sendRedirect(lasturl);                       \n                        }                            \n                    } catch (Exception e) {\n                        throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,e);\n                    }   \n                    \n                } else {\n                    // this is a folder\n                    // get all subfolders and files\n                    Vector allFolders=new Vector();\n                    Vector allFiles=new Vector();\n                    getAllResources(cms,filename,allFiles,allFolders);\n                    \n                    String parent=file.getParent();\n                    try {     \n                    \n                        // first creatre the new folder\n                        cms.unlockResource(file.getAbsolutePath());\n                        cms.copyFolder(filename,parent+newFile+\"/\");\n                                    \n                        // then copy all folders\n                        for (int i=0;i<allFolders.size();i++) {                            \n                            CmsFolder folder=(CmsFolder)allFolders.elementAt(i);  \n                            String newname=parent+newFile+\"/\"+folder.getAbsolutePath().substring(file.getAbsolutePath().length());                                               \n                            cms.copyFolder(folder.getAbsolutePath(), newname);\n                        }\n                     \n                        // now move the files\n                        for (int i=0;i<allFiles.size();i++) {\n                            CmsFile newfile=(CmsFile)allFiles.elementAt(i);\n                            String newname=parent+newFile+\"/\"+newfile.getAbsolutePath().substring(file.getAbsolutePath().length());                                                                       \n                            cms.lockResource(newfile.getAbsolutePath());\n                           // cms.moveFile(newfile.getAbsolutePath(),newname);\n                            moveFile(cms,newfile,newname,\"true\",true);\n                            System.err.println(\"Unlock new file \"+newname);\n                            cms.unlockResource(newname);\n                        }\n                        \n                        // finally remove the original folders\n                        for (int i=0;i<allFolders.size();i++) {\n                            CmsFolder folder=(CmsFolder)allFolders.elementAt(allFolders.size()-i-1);  \n                            cms.lockResource(folder.getAbsolutePath());\n                            cms.deleteFolder(folder.getAbsolutePath());\n                        }\n                        \n                        // as the last step, delete the original folder\n                         cms.lockResource(filename);\n                         cms.deleteFolder(filename);        \n                         cms.lockResource(parent+newFile+\"/\");\n                        \n                    } catch (CmsException ex) {\n                        // something went wrong, so remove all session parameters\n                        session.removeValue(C_PARA_FILE);\n\t    \t\t        session.removeValue(C_PARA_NAME);\n                        throw ex;\n                    }\n                     // everything is done, so remove all session parameters\n                    session.removeValue(C_PARA_FILE);\n\t    \t\t    session.removeValue(C_PARA_NAME);\n                    template=\"update\";\n                }\n            }\n        }\n        \n  \n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);          \n        // set the required datablocks\n        if (action == null) {\n            String title=cms.readProperty(file.getAbsolutePath(),C_PROPERTY_TITLE);\n            if (title==null) {\n                title=\"\";\n            }            \n            \n            A_CmsUser owner=cms.readOwner(file);\n            xmlTemplateDocument.setXmlData(\"TITLE\",title);\n            xmlTemplateDocument.setXmlData(\"STATE\",getState(cms,file,new CmsXmlLanguageFile(cms)));\n            xmlTemplateDocument.setXmlData(\"OWNER\",owner.getFirstname()+\" \"+owner.getLastname()+\"(\"+owner.getName()+\")\");\n            xmlTemplateDocument.setXmlData(\"GROUP\",cms.readGroup(file).getName());\n\t\t    xmlTemplateDocument.setXmlData(\"FILENAME\",file.getName());\n        }\n        \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template);\n    \n    }","id":90171,"modified_method":"/**\n     * Overwrites the getContent method of the CmsWorkplaceDefault.<br>\n     * Gets the content of the rename template and processed the data input.\n     * @param cms The CmsObject.\n     * @param templateFile The lock template file\n     * @param elementName not used\n     * @param parameters Parameters of the request and the template.\n     * @param templateSelector Selector of the template tag to be displayed.\n     * @return Bytearre containgine the processed data of the template.\n     * @exception Throws CmsException if something goes wrong.\n     */\n    public byte[] getContent(A_CmsObject cms, String templateFile, String elementName, \n                             Hashtable parameters, String templateSelector)\n        throws CmsException {\n        HttpSession session= ((HttpServletRequest)cms.getRequestContext().getRequest().getOriginalRequest()).getSession(true);   \n        \n        // the template to be displayed\n        String template=null;\n        \n        // get the lasturl parameter\n        String lasturl = getLastUrl(cms, parameters);    \n        \n        // TODO: check, if this is neede: String lock=(String)parameters.get(C_PARA_LOCK);\n        String filename=(String)parameters.get(C_PARA_FILE);\n        if (filename != null) {\n            session.putValue(C_PARA_FILE,filename);        \n        }\n        filename=(String)session.getValue(C_PARA_FILE);\n        \n        String newFile=(String)parameters.get(C_PARA_NAME);\n        if (newFile != null) {\n            session.putValue(C_PARA_NAME,newFile);        \n        }\n        newFile=(String)session.getValue(C_PARA_NAME);\n        \n        String action = (String)parameters.get(\"action\");\n\n        A_CmsResource file=(A_CmsResource)cms.readFileHeader(filename);\n      \n        if (file.isFile()) {\n            template=\"file\";\n        } else {\n            template=\"folder\";\n        }       \n      \n        //check if the name parameter was included in the request\n        // if not, the lock page is shown for the first time    \n        if (newFile == null) {\n            session.putValue(C_PARA_NAME,file.getName());\n        } else {\n            if (action== null) {\n                template=\"wait\";                \n            } else {\n            \n                // now check if the resource is a file or a folder            \n                if (file.isFile()) {\n                    // this is a file, so rename it         \n                    try {\n                        renameFile(cms,file,newFile);\n                    } catch (CmsException ex) {\n                        // something went wrong, so remove all session parameters\n                        session.removeValue(C_PARA_FILE);\n\t    \t\t        session.removeValue(C_PARA_NAME);\n                        throw ex;\n                    }\n                    \n                    // everything is done, so remove all session parameters\n                    session.removeValue(C_PARA_FILE);\n\t    \t\t    session.removeValue(C_PARA_NAME);\n                \n                    try {\n                        if(lasturl == null || \"\".equals(lasturl)) {\n                            cms.getRequestContext().getResponse().sendCmsRedirect( getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST);\n                        } else {\n                            ((HttpServletResponse)(cms.getRequestContext().getResponse().getOriginalResponse())).sendRedirect(lasturl);                       \n                        }                            \n                    } catch (Exception e) {\n                        throw new CmsException(\"Redirect fails :\"+ getConfigFile(cms).getWorkplaceActionPath()+C_WP_EXPLORER_FILELIST,CmsException.C_UNKNOWN_EXCEPTION,e);\n                    }   \n                    \n                } else {\n                    // this is a folder\n                    // get all subfolders and files\n                    Vector allFolders=new Vector();\n                    Vector allFiles=new Vector();\n                    getAllResources(cms,filename,allFiles,allFolders);\n                    \n                    String parent=file.getParent();\n                    try {     \n                    \n                        // first creatre the new folder\n                        cms.unlockResource(file.getAbsolutePath());\n                        cms.copyFolder(filename,parent+newFile+\"/\");\n                                    \n                        // then copy all folders\n                        for (int i=0;i<allFolders.size();i++) {                            \n                            CmsFolder folder=(CmsFolder)allFolders.elementAt(i);  \n                            String newname=parent+newFile+\"/\"+folder.getAbsolutePath().substring(file.getAbsolutePath().length());                                               \n                            cms.copyFolder(folder.getAbsolutePath(), newname);\n                        }\n                     \n                        // now move the files\n                        for (int i=0;i<allFiles.size();i++) {\n                            CmsFile newfile=(CmsFile)allFiles.elementAt(i);\n                            String newname=parent+newFile+\"/\"+newfile.getAbsolutePath().substring(file.getAbsolutePath().length());                                                                       \n                            cms.lockResource(newfile.getAbsolutePath());\n                           // cms.moveFile(newfile.getAbsolutePath(),newname);\n                            moveFile(cms,newfile,newname,\"true\",true);          \n                            cms.unlockResource(newname);\n                        }\n                        \n                        // finally remove the original folders\n                        for (int i=0;i<allFolders.size();i++) {\n                            CmsFolder folder=(CmsFolder)allFolders.elementAt(allFolders.size()-i-1);  \n                            cms.lockResource(folder.getAbsolutePath());\n                            cms.deleteFolder(folder.getAbsolutePath());\n                        }\n                        \n                        // as the last step, delete the original folder\n                         cms.lockResource(filename);\n                         cms.deleteFolder(filename);        \n                         cms.lockResource(parent+newFile+\"/\");\n                        \n                    } catch (CmsException ex) {\n                        // something went wrong, so remove all session parameters\n                        session.removeValue(C_PARA_FILE);\n\t    \t\t        session.removeValue(C_PARA_NAME);\n                        throw ex;\n                    }\n                     // everything is done, so remove all session parameters\n                    session.removeValue(C_PARA_FILE);\n\t    \t\t    session.removeValue(C_PARA_NAME);\n                    template=\"update\";\n                }\n            }\n        }\n        \n  \n        CmsXmlWpTemplateFile xmlTemplateDocument = new CmsXmlWpTemplateFile(cms,templateFile);          \n        // set the required datablocks\n        if (action == null) {\n            String title=cms.readProperty(file.getAbsolutePath(),C_PROPERTY_TITLE);\n            if (title==null) {\n                title=\"\";\n            }            \n            \n            A_CmsUser owner=cms.readOwner(file);\n            xmlTemplateDocument.setXmlData(\"TITLE\",title);\n            xmlTemplateDocument.setXmlData(\"STATE\",getState(cms,file,new CmsXmlLanguageFile(cms)));\n            xmlTemplateDocument.setXmlData(\"OWNER\",owner.getFirstname()+\" \"+owner.getLastname()+\"(\"+owner.getName()+\")\");\n            xmlTemplateDocument.setXmlData(\"GROUP\",cms.readGroup(file).getName());\n\t\t    xmlTemplateDocument.setXmlData(\"FILENAME\",file.getName());\n        }\n        \n        // process the selected template \n        return startProcessing(cms,xmlTemplateDocument,\"\",parameters,template);\n    \n    }","commit_id":"a5925e0f4f8a26ff7aba0051df8a95e28803290c","url":"https://github.com/alkacon/opencms-core"},{"original_method":"private void deployDataGrid(final String applicationName, final String serviceName, final String[] agentZones,\n\t\t\tfinal File srcFile, final Properties contextProperties, final DataGrid dataGridConfig,\n\t\t\tfinal String templateName, final boolean locationAware)\n\t\t\tthrows AdminException, TimeoutException, DSLException {\n\n\t\tfinal int containerMemoryInMB = dataGridConfig.getSla().getMemoryCapacityPerContainer();\n\t\tfinal int maxMemoryInMB = dataGridConfig.getSla().getMaxMemoryCapacity();\n\t\tfinal int reservedMemoryCapacityPerMachineInMB = 256;\n\n\t\tlogger.finer(\"received request to install datagrid\");\n\n\t\tfinal ElasticSpaceDeployment deployment =\n\t\t\t\tnew ElasticSpaceDeployment(serviceName)\n\t\t\t\t\t\t.memoryCapacityPerContainer(containerMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.maxMemoryCapacity(maxMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)\n\t\t\t\t\t\t.highlyAvailable(dataGridConfig.getSla().getHighlyAvailable())\n\t\t\t\t\t\t// allow single machine for local development purposes\n\t\t\t\t\t\t.singleMachineDeployment();\n\n\t\tsetContextProperties(deployment, contextProperties);\n\n\t\tif (cloud == null) {\n\t\t\tsetSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\n\t\t\tif (isLocalCloud()) {\n\t\t\t\tdeployment.scale(new ManualCapacityScaleConfigurer().memoryCapacity(\n\t\t\t\tdataGridConfig.getSla().getMemoryCapacity(), MemoryUnit.MEGABYTES).create());\n\n\t\t\t} else {\n\t\t\t\t// eager scaling. 1 container per machine\n\t\t\t\tdeployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfinal CloudTemplate template = getComputeTemplate(cloud, templateName);\n\n\t\t\tvalidateAndPrepareStatefulSla(serviceName, dataGridConfig.getSla(), cloud, template);\n\n\t\t\tfinal long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);\n\n\t\t\tfinal CloudifyMachineProvisioningConfig config =\n\t\t\t\t\tnew CloudifyMachineProvisioningConfig(cloud, template, cloudFileContents, templateName);\n\t\t\t// CloudMachineProvisioningConfig config =\n\t\t\t// CloudDSLToCloudMachineProvisioningConfig.convert(cloud);\n\n\t\t\tfinal String locators = extractLocators(admin);\n\t\t\tconfig.setLocator(locators);\n\n\t\t\tsetDedicatedMachineProvisioning(deployment, config);\n\t\t\tdeployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);\n\n\t\t\t//TODO: [itaif] Why only capacity of one container ?\n\t\t\tdeployment.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig((int) cloudExternalProcessMemoryInMB, locationAware));\n\t\t}\n\n\t\tdeployAndWait(serviceName, deployment);\n\n\t}","id":90172,"modified_method":"private void deployDataGrid(final String applicationName, final String serviceName, final String[] agentZones,\n\t\t\tfinal File srcFile, final Properties contextProperties, final DataGrid dataGridConfig,\n\t\t\tfinal String templateName, final boolean locationAware)\n\t\t\tthrows AdminException, TimeoutException, DSLException {\n\n\t\tfinal int containerMemoryInMB = dataGridConfig.getSla().getMemoryCapacityPerContainer();\n\t\tfinal int maxMemoryInMB = dataGridConfig.getSla().getMaxMemoryCapacity();\n\t\tfinal int reservedMemoryCapacityPerMachineInMB = 256;\n\n\t\tlogger.finer(\"received request to install datagrid\");\n\n\t\tfinal ElasticSpaceDeployment deployment =\n\t\t\t\tnew ElasticSpaceDeployment(serviceName)\n\t\t\t\t\t\t.memoryCapacityPerContainer(containerMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.maxMemoryCapacity(maxMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)\n\t\t\t\t\t\t.highlyAvailable(dataGridConfig.getSla().getHighlyAvailable())\n\t\t\t\t\t\t// allow single machine for local development purposes\n\t\t\t\t\t\t.singleMachineDeployment();\n\n\t\tsetContextProperties(deployment, contextProperties);\n\n\t\tif (cloud == null) {\n\t\t\tif (isLocalCloud()) {\n\t\t\t    setPublicMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\t\t\t\tdeployment.scale(new ManualCapacityScaleConfigurer().memoryCapacity(\n\t\t\t\tdataGridConfig.getSla().getMemoryCapacity(), MemoryUnit.MEGABYTES).create());\n\n\t\t\t} else {\n\t\t\t    setSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\t\t\t\t// eager scaling. 1 container per machine\n\t\t\t\tdeployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfinal CloudTemplate template = getComputeTemplate(cloud, templateName);\n\n\t\t\tvalidateAndPrepareStatefulSla(serviceName, dataGridConfig.getSla(), cloud, template);\n\n\t\t\tfinal long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);\n\n\t\t\tfinal CloudifyMachineProvisioningConfig config =\n\t\t\t\t\tnew CloudifyMachineProvisioningConfig(cloud, template, cloudFileContents, templateName);\n\t\t\t// CloudMachineProvisioningConfig config =\n\t\t\t// CloudDSLToCloudMachineProvisioningConfig.convert(cloud);\n\n\t\t\tfinal String locators = extractLocators(admin);\n\t\t\tconfig.setLocator(locators);\n\n\t\t\tsetDedicatedMachineProvisioning(deployment, config);\n\t\t\tdeployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);\n\n\t\t\t//TODO: [itaif] Why only capacity of one container ?\n\t\t\tdeployment.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig((int) cloudExternalProcessMemoryInMB, locationAware));\n\t\t}\n\n\t\tdeployAndWait(serviceName, deployment);\n\n\t}","commit_id":"dc870103536348073f9244ed29434975de0c198e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void doDeploy(final String applicationName, final String serviceName, final String templateName,\n\t\t\tfinal String[] agentZones, final File serviceFile, final Properties contextProperties, final Service service, \n\t\t\tfinal byte[] serviceCloudConfigurationContents)\n\t\t\tthrows TimeoutException, DSLException{\n\n\t\t\n\t\tboolean locationAware = false;\n\t\tif (service != null) {\n\t\t\tlocationAware = service.isLocationAware();\n\t\t}\n\t\tfinal int externalProcessMemoryInMB = 512;\n\t\tfinal int containerMemoryInMB = 128;\n\t\tfinal int reservedMemoryCapacityPerMachineInMB = 256;\n\n\t\tcontextProperties.put(CloudifyConstants.CONTEXT_PROPERTY_ASYNC_INSTALL, \"true\");\n\t\t\n\t\tfinal ElasticStatelessProcessingUnitDeployment deployment =\n\t\t\t\tnew ElasticStatelessProcessingUnitDeployment(serviceFile)\n\t\t\t\t\t\t.memoryCapacityPerContainer(externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.addCommandLineArgument(\"-Xmx\" + containerMemoryInMB + \"m\")\n\t\t\t\t\t\t.addCommandLineArgument(\"-Xms\" + containerMemoryInMB + \"m\")\n\t\t\t\t\t\t.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)\n\t\t\t\t\t\t.name(serviceName);\n\t\t\n\t\t// All PUs on this role share the same machine. \n\t\t// Machines are identified by zone.\n\t\tsetSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\n\t\tif (cloud == null) {\n\t\t\tif (!isLocalCloud()) {\n\n\t\t\t\t// Azure: Eager scale (1 container per machine per PU)\n\t\t\t\tdeployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());\n\t\t\t} else {\n\t\t\t\t// local cloud\n\t\t\t\tif (service == null || service.getScalingRules() == null) {\n\n\t\t\t\t\tint totalMemoryInMB = calculateTotalMemoryInMB(serviceName, service, externalProcessMemoryInMB);\n\t\t\t\t\tfinal ManualCapacityScaleConfig scaleConfig =\n\t\t\t\t\t\t\tnew ManualCapacityScaleConfigurer().memoryCapacity(totalMemoryInMB,MemoryUnit.MEGABYTES).create();\n\t\t\t\t\tdeployment.scale(scaleConfig);\n\t\t\t\t} else {\n\t\t\t\t\tfinal AutomaticCapacityScaleConfig scaleConfig =\n\t\t\t\t\t\t\tElasticScaleConfigFactory.createAutomaticCapacityScaleConfig(serviceName, service,\n\t\t\t\t\t\t\t\t\texternalProcessMemoryInMB, false);\n\t\t\t\t\tdeployment.scale(scaleConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tfinal CloudTemplate template = getComputeTemplate(cloud, templateName);\n\n\t\t\tfinal long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);\n\n\t\t\tfinal CloudifyMachineProvisioningConfig config =\n\t\t\t\t\tnew CloudifyMachineProvisioningConfig(cloud, template, cloudFileContents, templateName);\n\n\t\t\tfinal String[] zones = new String[] { serviceName }; //TODO: [itaif] consider using agentZones\n\n\t\t\tconfig.setGridServiceAgentZones(zones);\n\n\t\t\tif (serviceCloudConfigurationContents != null) {\n\n\t\t\t\tconfig.setServiceCloudConfiguration(serviceCloudConfigurationContents);\n\t\t\t}\n\n\t\t\tfinal String locators = extractLocators(admin);\n\t\t\tconfig.setLocator(locators);\n\n\t\t\tsetDedicatedMachineProvisioning(deployment, config);\n\t\t\tdeployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);\n\n\t\t\tif (service == null || service.getScalingRules() == null) {\n\t\t\t\tint totalMemoryInMB = calculateTotalMemoryInMB(serviceName, service, (int) cloudExternalProcessMemoryInMB);\n\t\t\t\tfinal ManualCapacityScaleConfig scaleConfig =\n\t\t\t\t\t\tElasticScaleConfigFactory.createManualCapacityScaleConfig(totalMemoryInMB, locationAware);\n\n\t\t\t\tscaleConfig.setAtMostOneContainerPerMachine(true);\n\t\t\t\tdeployment.scale(scaleConfig);\n\t\t\t} else {\n\t\t\t\tfinal AutomaticCapacityScaleConfig scaleConfig =\n\t\t\t\t\t\tElasticScaleConfigFactory.createAutomaticCapacityScaleConfig(serviceName, service,\n\t\t\t\t\t\t\t\t(int) cloudExternalProcessMemoryInMB,locationAware);\n\t\t\t\tscaleConfig.setAtMostOneContainerPerMachine(true);\n\t\t\t\tdeployment.scale(scaleConfig);\n\t\t\t}\n\t\t}\n\n\t\t// add context properties\n\t\tsetContextProperties(deployment, contextProperties);\n\n\t\tverifyEsmExistsInCluster();\n\t\tdeployAndWait(serviceName, deployment);\n\n\t}","id":90173,"modified_method":"private void doDeploy(final String applicationName, final String serviceName, final String templateName,\n\t\t\tfinal String[] agentZones, final File serviceFile, final Properties contextProperties, final Service service, \n\t\t\tfinal byte[] serviceCloudConfigurationContents)\n\t\t\tthrows TimeoutException, DSLException{\n\n\t\t\n\t\tboolean locationAware = false;\n\t\tif (service != null) {\n\t\t\tlocationAware = service.isLocationAware();\n\t\t}\n\t\tfinal int externalProcessMemoryInMB = 512;\n\t\tfinal int containerMemoryInMB = 128;\n\t\tfinal int reservedMemoryCapacityPerMachineInMB = 256;\n\n\t\tcontextProperties.put(CloudifyConstants.CONTEXT_PROPERTY_ASYNC_INSTALL, \"true\");\n\t\t\n\t\tfinal ElasticStatelessProcessingUnitDeployment deployment =\n\t\t\t\tnew ElasticStatelessProcessingUnitDeployment(serviceFile)\n\t\t\t\t\t\t.memoryCapacityPerContainer(externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.addCommandLineArgument(\"-Xmx\" + containerMemoryInMB + \"m\")\n\t\t\t\t\t\t.addCommandLineArgument(\"-Xms\" + containerMemoryInMB + \"m\")\n\t\t\t\t\t\t.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)\n\t\t\t\t\t\t.name(serviceName);\n\t\t\n        if (isLocalCloud()) {\n            setPublicMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n        } else {\n\t\t// All PUs on this role share the same machine. \n\t\t// Machines are identified by zone.\n            setSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n        }\n\n\t\tif (cloud == null) {\n\t\t\tif (!isLocalCloud()) {\n\n\t\t\t\t// Azure: Eager scale (1 container per machine per PU)\n\t\t\t\tdeployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());\n\t\t\t} else {\n\t\t\t\t// local cloud\n\t\t\t\tif (service == null || service.getScalingRules() == null) {\n\n\t\t\t\t\tint totalMemoryInMB = calculateTotalMemoryInMB(serviceName, service, externalProcessMemoryInMB);\n\t\t\t\t\tfinal ManualCapacityScaleConfig scaleConfig =\n\t\t\t\t\t\t\tnew ManualCapacityScaleConfigurer().memoryCapacity(totalMemoryInMB,MemoryUnit.MEGABYTES).create();\n\t\t\t\t\tdeployment.scale(scaleConfig);\n\t\t\t\t} else {\n\t\t\t\t\tfinal AutomaticCapacityScaleConfig scaleConfig =\n\t\t\t\t\t\t\tElasticScaleConfigFactory.createAutomaticCapacityScaleConfig(serviceName, service,\n\t\t\t\t\t\t\t\t\texternalProcessMemoryInMB, false);\n\t\t\t\t\tdeployment.scale(scaleConfig);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\tfinal CloudTemplate template = getComputeTemplate(cloud, templateName);\n\n\t\t\tfinal long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);\n\n\t\t\tfinal CloudifyMachineProvisioningConfig config =\n\t\t\t\t\tnew CloudifyMachineProvisioningConfig(cloud, template, cloudFileContents, templateName);\n\n\t\t\tfinal String[] zones = new String[] { serviceName }; //TODO: [itaif] consider using agentZones\n\n\t\t\tconfig.setGridServiceAgentZones(zones);\n\n\t\t\tif (serviceCloudConfigurationContents != null) {\n\n\t\t\t\tconfig.setServiceCloudConfiguration(serviceCloudConfigurationContents);\n\t\t\t}\n\n\t\t\tfinal String locators = extractLocators(admin);\n\t\t\tconfig.setLocator(locators);\n\n\t\t\tsetDedicatedMachineProvisioning(deployment, config);\n\t\t\tdeployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);\n\n\t\t\tif (service == null || service.getScalingRules() == null) {\n\t\t\t\tint totalMemoryInMB = calculateTotalMemoryInMB(serviceName, service, (int) cloudExternalProcessMemoryInMB);\n\t\t\t\tfinal ManualCapacityScaleConfig scaleConfig =\n\t\t\t\t\t\tElasticScaleConfigFactory.createManualCapacityScaleConfig(totalMemoryInMB, locationAware);\n\n\t\t\t\tscaleConfig.setAtMostOneContainerPerMachine(true);\n\t\t\t\tdeployment.scale(scaleConfig);\n\t\t\t} else {\n\t\t\t\tfinal AutomaticCapacityScaleConfig scaleConfig =\n\t\t\t\t\t\tElasticScaleConfigFactory.createAutomaticCapacityScaleConfig(serviceName, service,\n\t\t\t\t\t\t\t\t(int) cloudExternalProcessMemoryInMB,locationAware);\n\t\t\t\tscaleConfig.setAtMostOneContainerPerMachine(true);\n\t\t\t\tdeployment.scale(scaleConfig);\n\t\t\t}\n\t\t}\n\n\t\t// add context properties\n\t\tsetContextProperties(deployment, contextProperties);\n\n\t\tverifyEsmExistsInCluster();\n\t\tdeployAndWait(serviceName, deployment);\n\n\t}","commit_id":"dc870103536348073f9244ed29434975de0c198e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void deployStatelessProcessingUnitAndWait(final String applicationName, final String serviceName,\n\t\t\tfinal String[] agentZones, final File extractedServiceFolder, final Properties contextProperties,\n\t\t\tfinal StatelessProcessingUnit puConfig, final String templateName, final int numberOfInstances, \n\t\t\tfinal boolean locationAware)\n\t\t\tthrows IOException, AdminException, TimeoutException, DSLException {\n\n\t\tfinal File jarFile = getJarFileFromDir(new File(puConfig.getBinaries()), extractedServiceFolder, serviceName);\n\t\t// TODO:if not specified use machine memory defined in DSL\n\t\tfinal int containerMemoryInMB = puConfig.getSla().getMemoryCapacityPerContainer();\n\t\t// TODO:Read from cloud DSL\n\t\tfinal int reservedMemoryCapacityPerMachineInMB = 256;\n\t\tfinal ElasticStatelessProcessingUnitDeployment deployment =\n\t\t\t\tnew ElasticStatelessProcessingUnitDeployment(jarFile)\n\t\t\t\t\t\t.memoryCapacityPerContainer(containerMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)\n\t\t\t\t\t\t.name(serviceName);\n\t\t// TODO:read from cloud DSL\n\n\t\tsetContextProperties(deployment, contextProperties);\n\n\t\tif (cloud == null) {\n\t\t\tsetSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\t\t\tverifyEsmExistsInCluster();\n\n\t\t\tif (isLocalCloud()) {\n\t\t\t\tdeployment.scale(new ManualCapacityScaleConfigurer().memoryCapacity(\n\t\t\t\t\t\tcontainerMemoryInMB * numberOfInstances, MemoryUnit.MEGABYTES).create());\n\t\t\t} else {\n\t\t\t\t// eager scaling. one container per machine\n\t\t\t\tdeployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());\n\t\t\t}\n\t\t} else {\n\t\t\tfinal CloudTemplate template = getComputeTemplate(cloud, templateName);\n\t\t\tvalidateAndPrepareStatelessSla(puConfig.getSla(), cloud, template);\n\t\t\tfinal long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);\n\n\t\t\tfinal CloudifyMachineProvisioningConfig config =\n\t\t\t\t\tnew CloudifyMachineProvisioningConfig(cloud, template, cloudFileContents, templateName);\n\t\t\t// CloudMachineProvisioningConfig config =\n\t\t\t// CloudDSLToCloudMachineProvisioningConfig.convert(cloud);\n\n\t\t\tfinal String locators = extractLocators(admin);\n\t\t\tconfig.setLocator(locators);\n\n\t\t\tsetDedicatedMachineProvisioning(deployment, config);\n\t\t\tdeployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);\n\n\t\t\tdeployment.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig(containerMemoryInMB * numberOfInstances, locationAware));\n\t\t}\n\t\tdeployAndWait(serviceName, deployment);\n\t\tjarFile.delete();\n\n\t}","id":90174,"modified_method":"private void deployStatelessProcessingUnitAndWait(final String applicationName, final String serviceName,\n\t\t\tfinal String[] agentZones, final File extractedServiceFolder, final Properties contextProperties,\n\t\t\tfinal StatelessProcessingUnit puConfig, final String templateName, final int numberOfInstances, \n\t\t\tfinal boolean locationAware)\n\t\t\tthrows IOException, AdminException, TimeoutException, DSLException {\n\n\t\tfinal File jarFile = getJarFileFromDir(new File(puConfig.getBinaries()), extractedServiceFolder, serviceName);\n\t\t// TODO:if not specified use machine memory defined in DSL\n\t\tfinal int containerMemoryInMB = puConfig.getSla().getMemoryCapacityPerContainer();\n\t\t// TODO:Read from cloud DSL\n\t\tfinal int reservedMemoryCapacityPerMachineInMB = 256;\n\t\tfinal ElasticStatelessProcessingUnitDeployment deployment =\n\t\t\t\tnew ElasticStatelessProcessingUnitDeployment(jarFile)\n\t\t\t\t\t\t.memoryCapacityPerContainer(containerMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)\n\t\t\t\t\t\t.name(serviceName);\n\t\t// TODO:read from cloud DSL\n\n\t\tsetContextProperties(deployment, contextProperties);\n\n\t\tif (cloud == null) {\n\t\t\tverifyEsmExistsInCluster();\n\n\t\t\tif (isLocalCloud()) {\n\t\t\t    setPublicMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\t\t\t\tdeployment.scale(new ManualCapacityScaleConfigurer().memoryCapacity(\n\t\t\t\t\t\tcontainerMemoryInMB * numberOfInstances, MemoryUnit.MEGABYTES).create());\n\t\t\t} else {\n\t\t\t    setSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\t\t\t\t// eager scaling. one container per machine\n\t\t\t\tdeployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());\n\t\t\t}\n\t\t} else {\n\t\t\tfinal CloudTemplate template = getComputeTemplate(cloud, templateName);\n\t\t\tvalidateAndPrepareStatelessSla(puConfig.getSla(), cloud, template);\n\t\t\tfinal long cloudExternalProcessMemoryInMB = calculateExternalProcessMemory(cloud, template);\n\n\t\t\tfinal CloudifyMachineProvisioningConfig config =\n\t\t\t\t\tnew CloudifyMachineProvisioningConfig(cloud, template, cloudFileContents, templateName);\n\t\t\t// CloudMachineProvisioningConfig config =\n\t\t\t// CloudDSLToCloudMachineProvisioningConfig.convert(cloud);\n\n\t\t\tfinal String locators = extractLocators(admin);\n\t\t\tconfig.setLocator(locators);\n\n\t\t\tsetDedicatedMachineProvisioning(deployment, config);\n\t\t\tdeployment.memoryCapacityPerContainer((int) cloudExternalProcessMemoryInMB, MemoryUnit.MEGABYTES);\n\n\t\t\tdeployment.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig(containerMemoryInMB * numberOfInstances, locationAware));\n\t\t}\n\t\tdeployAndWait(serviceName, deployment);\n\t\tjarFile.delete();\n\n\t}","commit_id":"dc870103536348073f9244ed29434975de0c198e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void deployStatefulProcessingUnit(final String applicationName, final String serviceName,\n\t\t\tfinal String[] agentZones, final File extractedServiceFolder, final Properties contextProperties,\n\t\t\tfinal StatefulProcessingUnit puConfig, final String templateName, final boolean locationAware)\n\t\t\tthrows IOException, AdminException, TimeoutException, DSLException {\n\n\t\tfinal File jarFile = getJarFileFromDir(new File(puConfig.getBinaries()), extractedServiceFolder, serviceName);\n\t\tfinal int containerMemoryInMB = puConfig.getSla().getMemoryCapacityPerContainer();\n\t\tfinal int maxMemoryCapacityInMB = puConfig.getSla().getMaxMemoryCapacity();\n\t\tfinal int reservedMemoryCapacityPerMachineInMB = 256;\n\n\t\tfinal ElasticStatefulProcessingUnitDeployment deployment =\n\t\t\t\tnew ElasticStatefulProcessingUnitDeployment(jarFile).name(serviceName)\n\t\t\t\t\t\t.memoryCapacityPerContainer(containerMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.maxMemoryCapacity(maxMemoryCapacityInMB + \"m\")\n\t\t\t\t\t\t.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)\n\t\t\t\t\t\t.highlyAvailable(puConfig.getSla().getHighlyAvailable()).singleMachineDeployment();\n\n\t\tsetContextProperties(deployment, contextProperties);\n\n\t\tif (cloud == null) {\n\t\t\tsetSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\t\t\tverifyEsmExistsInCluster();\n\t\t\tif (isLocalCloud()) {\n\t\t\t\tdeployment.scale(new ManualCapacityScaleConfigurer().memoryCapacity(\n\t\t\t\t\t\tpuConfig.getSla().getMemoryCapacity(), MemoryUnit.MEGABYTES).create());\n\t\t\t} else {\n\t\t\t\t// eager scaling. one container per machine\n\t\t\t\tdeployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());\n\t\t\t}\n\t\t} else {\n\n\t\t\tfinal CloudTemplate template = getComputeTemplate(cloud, templateName);\n\n\t\t\tvalidateAndPrepareStatefulSla(serviceName, puConfig.getSla(), cloud, template);\n\n\t\t\tfinal CloudifyMachineProvisioningConfig config =\n\t\t\t\t\tnew CloudifyMachineProvisioningConfig(cloud, template, cloudFileContents, templateName);\n\n\t\t\tfinal String locators = extractLocators(admin);\n\t\t\tconfig.setLocator(locators);\n\n\t\t\tsetDedicatedMachineProvisioning(deployment, config);\n\n\t\t\tdeployment.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig(puConfig.getSla().getMemoryCapacity(), locationAware));\n\n\t\t}\n\n\t\tdeployAndWait(serviceName, deployment);\n\t\tjarFile.delete();\n\n\t}","id":90175,"modified_method":"private void deployStatefulProcessingUnit(final String applicationName, final String serviceName,\n\t\t\tfinal String[] agentZones, final File extractedServiceFolder, final Properties contextProperties,\n\t\t\tfinal StatefulProcessingUnit puConfig, final String templateName, final boolean locationAware)\n\t\t\tthrows IOException, AdminException, TimeoutException, DSLException {\n\n\t\tfinal File jarFile = getJarFileFromDir(new File(puConfig.getBinaries()), extractedServiceFolder, serviceName);\n\t\tfinal int containerMemoryInMB = puConfig.getSla().getMemoryCapacityPerContainer();\n\t\tfinal int maxMemoryCapacityInMB = puConfig.getSla().getMaxMemoryCapacity();\n\t\tfinal int reservedMemoryCapacityPerMachineInMB = 256;\n\n\t\tfinal ElasticStatefulProcessingUnitDeployment deployment =\n\t\t\t\tnew ElasticStatefulProcessingUnitDeployment(jarFile).name(serviceName)\n\t\t\t\t\t\t.memoryCapacityPerContainer(containerMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t.maxMemoryCapacity(maxMemoryCapacityInMB + \"m\")\n\t\t\t\t\t\t.addContextProperty(CloudifyConstants.CONTEXT_PROPERTY_APPLICATION_NAME, applicationName)\n\t\t\t\t\t\t.highlyAvailable(puConfig.getSla().getHighlyAvailable()).singleMachineDeployment();\n\n\t\tsetContextProperties(deployment, contextProperties);\n\n\t\tif (cloud == null) {\n\t\t\tverifyEsmExistsInCluster();\n\t\t\tif (isLocalCloud()) {\n\t\t\t    setPublicMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\t\t\t\tdeployment.scale(new ManualCapacityScaleConfigurer().memoryCapacity(\n\t\t\t\t\t\tpuConfig.getSla().getMemoryCapacity(), MemoryUnit.MEGABYTES).create());\n\t\t\t} else {\n\t\t\t    setSharedMachineProvisioning(deployment, agentZones, reservedMemoryCapacityPerMachineInMB);\n\t\t\t\t// eager scaling. one container per machine\n\t\t\t\tdeployment.scale(ElasticScaleConfigFactory.createEagerScaleConfig());\n\t\t\t}\n\t\t} else {\n\n\t\t\tfinal CloudTemplate template = getComputeTemplate(cloud, templateName);\n\n\t\t\tvalidateAndPrepareStatefulSla(serviceName, puConfig.getSla(), cloud, template);\n\n\t\t\tfinal CloudifyMachineProvisioningConfig config =\n\t\t\t\t\tnew CloudifyMachineProvisioningConfig(cloud, template, cloudFileContents, templateName);\n\n\t\t\tfinal String locators = extractLocators(admin);\n\t\t\tconfig.setLocator(locators);\n\n\t\t\tsetDedicatedMachineProvisioning(deployment, config);\n\n\t\t\tdeployment.scale(ElasticScaleConfigFactory.createManualCapacityScaleConfig(puConfig.getSla().getMemoryCapacity(), locationAware));\n\n\t\t}\n\n\t\tdeployAndWait(serviceName, deployment);\n\t\tjarFile.delete();\n\n\t}","commit_id":"dc870103536348073f9244ed29434975de0c198e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private void setSharedMachineProvisioning(final ElasticDeploymentTopology deployment, final String[] agentZones,\n\t\t\tfinal int reservedMemoryCapacityPerMachineInMB) {\n\t\t// All PUs on this role share the same machine. Machines\n\t\t// are identified by zone.\n\t\tDiscoveredMachineProvisioningConfig machineProvisioning = \n\t\t\t\tnew DiscoveredMachineProvisioningConfigurer()\n\t\t\t\t.reservedMemoryCapacityPerMachine(reservedMemoryCapacityPerMachineInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t.create();\n\t\tmachineProvisioning.setGridServiceAgentZones(agentZones);\n\t\t\n\t\t\n\t\tdeployment.sharedMachineProvisioning(SHARED_ISOLATION_ID, machineProvisioning);\n\t}","id":90176,"modified_method":"private void setSharedMachineProvisioning(final ElasticDeploymentTopology deployment, final String[] agentZones,\n\t\t\tfinal int reservedMemoryCapacityPerMachineInMB) {\n\t\t// All PUs on this role share the same machine. Machines\n\t\t// are identified by zone.\n\t\tDiscoveredMachineProvisioningConfig machineProvisioning = \n\t\t\t\tnew DiscoveredMachineProvisioningConfigurer()\n\t\t\t\t.reservedMemoryCapacityPerMachine(reservedMemoryCapacityPerMachineInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t.create();\n\t\tmachineProvisioning.setGridServiceAgentZones(agentZones);\n\t\t\n\t\tif (isLocalCloud()) {\n\t\t    deployment.publicMachineProvisioning(machineProvisioning);\n\t\t} else {\n\t\t    deployment.sharedMachineProvisioning(SHARED_ISOLATION_ID, machineProvisioning);\n\t\t}\n\t}","commit_id":"dc870103536348073f9244ed29434975de0c198e","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private GrStatement findAnchor(PsiFile file, int offset) {\n    PsiElement element = file.findElementAt(offset);\n    while (element != null) {\n      element = element.getParent();\n      if (element.getParent().equals(myOwner)) return element instanceof GrStatement ? (GrStatement) element : null;\n    }\n    return null;\n  }","id":90177,"modified_method":"private GrStatement findAnchor(PsiFile file, int offset) {\n    PsiElement element = file.findElementAt(offset);\n    if (element == null && offset > 0) element = file.findElementAt(offset - 1); \n    while (element != null) {\n      element = element.getParent();\n      if (element.getParent().equals(myOwner)) return element instanceof GrStatement ? (GrStatement) element : null;\n    }\n    return null;\n  }","commit_id":"2f3eb303cb6727d6cbbd0cab51b9edee59fa0dbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrStatement addStatementBefore(@NotNull GrStatement statement, @NotNull GrStatement anchor) throws IncorrectOperationException {\n    final PsiElement result = addBefore(statement, anchor);\n    getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor.getNode());\n    return (GrStatement) result;\n  }","id":90178,"modified_method":"public GrStatement addStatementBefore(@NotNull GrStatement statement, @Nullable GrStatement anchor) throws IncorrectOperationException {\n    final PsiElement result = addBefore(statement, anchor);\n    if (anchor != null) {\n      getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor.getNode());\n    }\n    return (GrStatement) result;\n  }","commit_id":"2f3eb303cb6727d6cbbd0cab51b9edee59fa0dbd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GrImportStatement addImport(GrImportStatement statement) throws IncorrectOperationException {\n    PsiElement anchor = getAnchorToInsertImportAfter();\n    final PsiElement result = addBefore(statement, anchor);\n    getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor.getNode());\n    return (GrImportStatement) result;\n  }","id":90179,"modified_method":"public GrImportStatement addImport(GrImportStatement statement) throws IncorrectOperationException {\n    PsiElement anchor = getAnchorToInsertImportAfter();\n    final PsiElement result = addBefore(statement, anchor);\n    if (anchor != null) {\n      getNode().addLeaf(GroovyTokenTypes.mNLS, \"\\n\", anchor.getNode());\n    }\n    return (GrImportStatement) result;\n  }","commit_id":"c34b40e6271b3a7fc5eff9fbe9af98f14cbda55c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static List<SNode> virtual_getTestSet_1216130724401(SNode thisNode) {\n    SNode node = thisNode;\n    return ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(node, \"testMethodList\", true), \"testMethod\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode method) {\n        return (ListSequence.fromList(SLinkOperations.getTargets(method, \"annotation\", true)).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode annotation) {\n            return SLinkOperations.getTarget(annotation, \"annotation\", false).equals(SNodeOperations.getNode(\"f:java_stub#org.junit(org.junit@java_stub)\", \"~Ignore\"));\n          }\n        }) == null);\n      }\n    }).toListSequence();\n  }","id":90180,"modified_method":"public static List<SNode> virtual_getTestSet_1216130724401(SNode thisNode) {\n    SNode node = thisNode;\n    List<SNode> methods = new ArrayList<SNode>();\n    if ((SLinkOperations.getTarget(node, \"superclass\", true) != null) && SNodeOperations.isInstanceOf(SLinkOperations.getTarget(SLinkOperations.getTarget(node, \"superclass\", true), \"classifier\", false), \"jetbrains.mps.baseLanguage.unitTest.structure.ITestCase\")) {\n      List<SNode> superMethods = ITestCase_Behavior.call_getTestSet_1216130724401(SNodeOperations.cast(SLinkOperations.getTarget(SLinkOperations.getTarget(node, \"superclass\", true), \"classifier\", false), \"jetbrains.mps.baseLanguage.unitTest.structure.ITestCase\"));\n      ListSequence.fromList(methods).addSequence(ListSequence.fromList(superMethods));\n    }\n    ListSequence.fromList(methods).addSequence(ListSequence.fromList(SLinkOperations.getTargets(SLinkOperations.getTarget(node, \"testMethodList\", true), \"testMethod\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode method) {\n        return (ListSequence.fromList(SLinkOperations.getTargets(method, \"annotation\", true)).findFirst(new IWhereFilter<SNode>() {\n          public boolean accept(SNode annotation) {\n            return SLinkOperations.getTarget(annotation, \"annotation\", false).equals(SNodeOperations.getNode(\"f:java_stub#org.junit(org.junit@java_stub)\", \"~Ignore\"));\n          }\n        }) == null);\n      }\n    }));\n    return methods;\n  }","commit_id":"d50c9761dc9f234dea3adf0897bc36c95dfe7294","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static List<MigrationWizardStep> createSteps(final Project project, MigrationManager manager, MigrationProblemsContainer errorContainer) {\n    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();\n\n    InitialStep initialStep = new InitialStep(project, ListSequence.fromList(pMig).ofType(ProjectMigrationWithOptions.class).where(new IWhereFilter<ProjectMigrationWithOptions>() {\n      public boolean accept(ProjectMigrationWithOptions it) {\n        return it.shouldBeExecuted(ProjectHelper.fromIdeaProject(project));\n      }\n    }).translate(new ITranslator2<ProjectMigrationWithOptions, ProjectMigrationWithOptions.Option>() {\n      public Iterable<ProjectMigrationWithOptions.Option> translate(ProjectMigrationWithOptions it) {\n        return it.getOptions();\n      }\n    }).toListSequence());\n    MigrationsProgressWizardStep migrationsProgressWizardStep = new MigrationsProgressWizardStep(project, initialStep, manager, errorContainer, true);\n    MigrationErrorWizardStep migrationErrorWizardStep = new MigrationErrorWizardStep(project, errorContainer);\n    MigrationsProgressWizardStep fallBackProgressStep = new MigrationsProgressWizardStep(project, initialStep, manager, errorContainer, false);\n    return ListSequence.fromListAndArray(new ArrayList<MigrationWizardStep>(), initialStep, migrationsProgressWizardStep, migrationErrorWizardStep, fallBackProgressStep);\n  }","id":90181,"modified_method":"private static List<MigrationWizardStep> createSteps(final Project project, MigrationManager manager, MigrationProblemsContainer errorContainer) {\n    List<ProjectMigration> pMig = ProjectMigrationsRegistry.getInstance().getMigrations();\n    final MPSProject mpsPoject = ProjectHelper.fromIdeaProject(project);\n\n    final List<String> modulesToMigrate = ListSequence.fromList(new ArrayList<String>());\n    mpsPoject.getRepository().getModelAccess().runReadAction(new Runnable() {\n      public void run() {\n        ListSequence.fromList(modulesToMigrate).addSequence(Sequence.fromIterable(MigrationModuleUtil.getMigrateableModulesFromProject(mpsPoject)).where(new IWhereFilter<SModule>() {\n          public boolean accept(SModule module) {\n            return Sequence.fromIterable(MigrationsUtil.getAllSteps(module)).isNotEmpty();\n          }\n        }).select(new ISelector<SModule, String>() {\n          public String select(SModule module) {\n            return NameUtil.compactNamespace(module.getModuleName());\n          }\n        }));\n      }\n    });\n    final StringBuilder sb = new StringBuilder(\"<html><body><font face=\\\"Verdana\\\" \");\n    sb.append((SystemInfo.isMac ? \"\" : \"size=\\\"-1\\\"\")).append('>');\n    for (String m : modulesToMigrate) {\n      sb.append(m).append(\"<br />\");\n    }\n    sb.append(\"<\/font><\/body><\/html>\");\n    List<ProjectMigrationWithOptions.Option> options = ListSequence.fromList(new ArrayList<ProjectMigrationWithOptions.Option>());\n    ListSequence.fromList(options).addElement(new ProjectMigrationWithOptions.Option<Void>(\"viewModulesToMigrate\") {\n      @Override\n      public JComponent createComponent() {\n        JTextPane list = new JTextPane();\n        Messages.installHyperlinkSupport(list);\n        list.setText(sb.toString());\n        JPanel panel = new JPanel(new BorderLayout());\n        JBScrollPane scrollPane = new JBScrollPane(list);\n        panel.add(scrollPane, BorderLayout.CENTER);\n        panel.add(new JBLabel(\"Modules to be migrated:\"), BorderLayout.NORTH);\n        panel.setPreferredSize(new Dimension((int) panel.getPreferredSize().getWidth(), 100));\n        return panel;\n      }\n      @Override\n      public Void getValue(JComponent component) {\n        return null;\n      }\n    });\n    ListSequence.fromList(options).addSequence(ListSequence.fromList(pMig).ofType(ProjectMigrationWithOptions.class).where(new IWhereFilter<ProjectMigrationWithOptions>() {\n      public boolean accept(ProjectMigrationWithOptions it) {\n        return it.shouldBeExecuted(ProjectHelper.fromIdeaProject(project));\n      }\n    }).translate(new ITranslator2<ProjectMigrationWithOptions, ProjectMigrationWithOptions.Option>() {\n      public Iterable<ProjectMigrationWithOptions.Option> translate(ProjectMigrationWithOptions it) {\n        return it.getOptions();\n      }\n    }));\n    InitialStep initialStep = new InitialStep(project, options);\n    MigrationsProgressWizardStep migrationsProgressWizardStep = new MigrationsProgressWizardStep(project, initialStep, manager, errorContainer, true);\n    MigrationErrorWizardStep migrationErrorWizardStep = new MigrationErrorWizardStep(project, errorContainer);\n    MigrationsProgressWizardStep fallBackProgressStep = new MigrationsProgressWizardStep(project, initialStep, manager, errorContainer, false);\n    return ListSequence.fromListAndArray(new ArrayList<MigrationWizardStep>(), initialStep, migrationsProgressWizardStep, migrationErrorWizardStep, fallBackProgressStep);\n  }","commit_id":"47e3a8b7b4feadcf48e0fbe502600157d6868e67","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ConstraintsDescriptor() {\n    ListSequence.fromList(this.myConstraints).addElement(new BeanPropertyBuilder_setter_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new SimpleBuilderPropertyBuilder_declaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new SimpleBuilderParameterReference_parameter_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new BeanBuilder_constructor_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new SimpleBuilder_declaration_ReferentConstraint());\n  }","id":90182,"modified_method":"public ConstraintsDescriptor() {\n    ListSequence.fromList(this.myConstraints).addElement(new BeanPropertyBuilder_setter_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new SimpleBuilderPropertyBuilder_declaration_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new SimpleBuilderParameterReference_parameter_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new SimpleBuilderDeclaration_extends_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new BeanBuilder_constructor_ReferentConstraint());\n    ListSequence.fromList(this.myConstraints).addElement(new SimpleBuilder_declaration_ReferentConstraint());\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> call_getDescendants_3816167865390609214(final SNode thisNode) {\n    SNode builders = SNodeOperations.getAncestor(thisNode, \"jetbrains.mps.baseLanguage.builders.structure.SimpleBuilders\", false, false);\n    return ListSequence.fromList(SLinkOperations.getTargets(builders, \"builder\", true)).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SimpleBuilderDeclaration_Behavior.call_isDescendant_3816167865390595157(it, thisNode);\n      }\n    }).toListSequence();\n  }","id":90183,"modified_method":"public static List<SNode> call_getDescendants_3816167865390609214(final SNode thisNode, SModel model, IScope scope) {\n    List<SNode> result = new ArrayList<SNode>();\n    SNode container = SNodeOperations.getAncestor(thisNode, \"jetbrains.mps.baseLanguage.builders.structure.SimpleBuilders\", false, false);\n    for (SNode builder : SimpleBuilders_Behavior.call_getDescendands_5199967550912479741(container, model, scope)) {\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(SLinkOperations.getTargets(builder, \"builder\", true)).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SimpleBuilderDeclaration_Behavior.call_isDescendant_3816167865390595157(it, thisNode);\n        }\n      }));\n    }\n    return result;\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> call_getPossibleChildren_8969040284892300232(SNode thisNode) {\n    List<SNode> builders = new ArrayList<SNode>();\n    for (SNode child : SimpleBuilderDeclaration_Behavior.call_getChildren_3816167865390856298(SLinkOperations.getTarget(thisNode, \"declaration\", false))) {\n      ListSequence.fromList(builders).addSequence(ListSequence.fromList(SimpleBuilderDeclaration_Behavior.call_getDescendants_3816167865390609214(SLinkOperations.getTarget(child, \"child\", false))).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return !(SPropertyOperations.getBoolean(it, \"isAbstract\"));\n        }\n      }));\n    }\n    return builders;\n  }","id":90184,"modified_method":"public static List<SNode> call_getPossibleChildren_8969040284892300232(SNode thisNode, SModel model, IScope scope) {\n    List<SNode> builders = new ArrayList<SNode>();\n    for (SNode child : SimpleBuilderDeclaration_Behavior.call_getChildren_3816167865390856298(SLinkOperations.getTarget(thisNode, \"declaration\", false))) {\n      ListSequence.fromList(builders).addSequence(ListSequence.fromList(SimpleBuilderDeclaration_Behavior.call_getDescendants_3816167865390609214(SLinkOperations.getTarget(child, \"child\", false), model, scope)).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return !(SPropertyOperations.getBoolean(it, \"isAbstract\"));\n        }\n      }));\n    }\n    return builders;\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    SNode contextBuilder = Builder_Behavior.getContextBuilder_7057666463730366732(_context.getEnclosingNode());\n    if (SNodeOperations.isInstanceOf(contextBuilder, \"jetbrains.mps.baseLanguage.builders.structure.SimpleBuilder\")) {\n      return SimpleBuilder_Behavior.call_getPossibleChildren_8969040284892300232(SNodeOperations.cast(contextBuilder, \"jetbrains.mps.baseLanguage.builders.structure.SimpleBuilder\"));\n    } else if (contextBuilder == null && (SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.GenericNewExpression\") || SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.builders.structure.AsBuilderStatement\"))) {\n      return ListSequence.fromList(SModelOperations.getRootsIncludingImported(_context.getModel(), operationContext.getScope(), \"jetbrains.mps.baseLanguage.builders.structure.SimpleBuilders\")).translate(new ITranslator2<SNode, SNode>() {\n        public Iterable<SNode> translate(SNode it) {\n          return SLinkOperations.getTargets(it, \"builder\", true);\n        }\n      }).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SimpleBuilderDeclaration_Behavior.call_isRoot_8969040284892403078(it);\n        }\n      }).toListSequence();\n    } else {\n      return new ArrayList<SNode>();\n    }\n  }","id":90185,"modified_method":"public Object createSearchScopeOrListOfNodes(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    SNode contextBuilder = Builder_Behavior.getContextBuilder_7057666463730366732(_context.getEnclosingNode());\n    if (SNodeOperations.isInstanceOf(contextBuilder, \"jetbrains.mps.baseLanguage.builders.structure.SimpleBuilder\")) {\n      return SimpleBuilder_Behavior.call_getPossibleChildren_8969040284892300232(SNodeOperations.cast(contextBuilder, \"jetbrains.mps.baseLanguage.builders.structure.SimpleBuilder\"), _context.getModel(), operationContext.getScope());\n    } else if (contextBuilder == null && (SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.structure.GenericNewExpression\") || SNodeOperations.isInstanceOf(_context.getEnclosingNode(), \"jetbrains.mps.baseLanguage.builders.structure.AsBuilderStatement\"))) {\n      return ListSequence.fromList(SModelOperations.getRootsIncludingImported(_context.getModel(), operationContext.getScope(), \"jetbrains.mps.baseLanguage.builders.structure.SimpleBuilders\")).translate(new ITranslator2<SNode, SNode>() {\n        public Iterable<SNode> translate(SNode it) {\n          return SLinkOperations.getTargets(it, \"builder\", true);\n        }\n      }).where(new IWhereFilter<SNode>() {\n        public boolean accept(SNode it) {\n          return SimpleBuilderDeclaration_Behavior.call_isRoot_8969040284892403078(it);\n        }\n      }).toListSequence();\n    } else {\n      return new ArrayList<SNode>();\n    }\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_8386_0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_8386_0\");\n    editorCell.addEditorCell(this.createConstant_8386_0(editorContext, node));\n    editorCell.addEditorCell(this.createProperty_8386_0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_8386_1(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_8386_0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_8386_2(editorContext, node));\n    return editorCell;\n  }","id":90186,"modified_method":"private EditorCell createCollection_8386_0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_8386_0\");\n    editorCell.addEditorCell(this.createConstant_8386_1(editorContext, node));\n    editorCell.addEditorCell(this.createProperty_8386_1(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_8386_0(editorContext, node));\n    editorCell.addEditorCell(this.createRefCell_8386_0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_8386_2(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_8386_0(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_8386_3(editorContext, node));\n    return editorCell;\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_8386_0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"builders\");\n    editorCell.setCellId(\"Constant_8386_0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":90187,"modified_method":"private EditorCell createConstant_8386_0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"extends\");\n    editorCell.setCellId(\"Constant_8386_0\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_8386_1(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"{\");\n    editorCell.setCellId(\"Constant_8386_1\");\n    BaseLanguageStyle_StyleSheet.getLeftBrace(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":90188,"modified_method":"private EditorCell createConstant_8386_1(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"builders\");\n    editorCell.setCellId(\"Constant_8386_1\");\n    BaseLanguageStyle_StyleSheet.getKeyWord(editorCell).apply(editorCell);\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createConstant_8386_2(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"}\");\n    editorCell.setCellId(\"Constant_8386_2\");\n    BaseLanguageStyle_StyleSheet.getRightParen(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_ON_NEW_LINE, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":90189,"modified_method":"private EditorCell createConstant_8386_2(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \"{\");\n    editorCell.setCellId(\"Constant_8386_2\");\n    BaseLanguageStyle_StyleSheet.getLeftBrace(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.INDENT_LAYOUT_NEW_LINE, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createProperty_8386_0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"name\");\n    provider.setNoTargetText(\"<no name>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_name\");\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":90190,"modified_method":"private EditorCell createProperty_8386_1(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"name\");\n    provider.setNoTargetText(\"<no name>\");\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_name_1\");\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"9c82c9b92bdb58d67b9ba3ebd17eab28c070e6b2","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> replaceNodeMenu_FieldReference_getParameterObjects(SNode node) {\n    List<SNode> result = new LinkedList<SNode>();\n    SNode instance = SLinkOperations.getTarget(node, \"instance\", true);\n    if(instance == null) {\n      return result;\n    }\n    ClassifierType instanceType = BaseLanguageTypesUtil.tryObtain_ClassifierType((Expression)instance);\n    if(instanceType == null) {\n      return result;\n    }\n    ISearchScope classHierarchy = BaseLanguageSearchUtil.createClassifierHierarchyScope(instanceType, IClassifiersSearchScope.INSTANCE_METHOD);\n    result = (List)BaseLanguageSearchUtil.getMethodsExcludingOverridden(classHierarchy);\n    return result;\n  }","id":90191,"modified_method":"public static List<SNode> replaceNodeMenu_FieldReference_getParameterObjects(SNode node) {\n    List<SNode> result = new LinkedList<SNode>();\n    SNode instance = SLinkOperations.getTarget(node, \"instance\", true);\n    if(instance == null) {\n      return result;\n    }\n    ClassifierType instanceType = BaseLanguageTypesUtil.tryObtain_ClassifierType((Expression)instance);\n    if(instanceType == null) {\n      return result;\n    }\n    ISearchScope classHierarchy = BaseLanguageSearchUtil.createClassifierHierarchyScope(instanceType, IClassifiersSearchScope.INSTANCE_METHOD);\n    result = (List)BaseAdapter.toNodes(BaseLanguageSearchUtil_new.getMethodsExcludingOverridden(classHierarchy));\n    return result;\n  }","commit_id":"138e91e03b6d536e3fdf25b6df5eb408444d87ee","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> replaceNodeMenu_EnumConstantReference_getParameterObjects(SNode node) {\n    List<SNode> result = new LinkedList<SNode>();\n    SNode classifier = SLinkOperations.getTarget(node, \"enumClass\", false);\n    if(classifier == null) {\n      return result;\n    }\n    ISearchScope classHierarchy = BaseLanguageSearchUtil.createClassifierHierarchyScope((Classifier)classifier, IClassifiersSearchScope.STATIC_MEMBER);\n    List staticFields = BaseLanguageSearchUtil.getFieldsExcludingOverridden(classHierarchy);\n    ListOperations.addAllElements(result, (List<SNode>)staticFields);\n    List staticMethods = BaseLanguageSearchUtil.getMethodsExcludingOverridden(classHierarchy);\n    ListOperations.addAllElements(result, (List<SNode>)staticMethods);\n    return result;\n  }","id":90192,"modified_method":"public static List<SNode> replaceNodeMenu_EnumConstantReference_getParameterObjects(SNode node) {\n    List<SNode> result = new LinkedList<SNode>();\n    SNode classifier = SLinkOperations.getTarget(node, \"enumClass\", false);\n    if(classifier == null) {\n      return result;\n    }\n    ISearchScope classHierarchy = BaseLanguageSearchUtil.createClassifierHierarchyScope((Classifier)classifier, IClassifiersSearchScope.STATIC_MEMBER);\n    List staticFields = BaseAdapter.toNodes(BaseLanguageSearchUtil_new.getFieldsExcludingOverridden(classHierarchy));\n    ListOperations.addAllElements(result, (List<SNode>)staticFields);\n    List staticMethods = BaseAdapter.toNodes(BaseLanguageSearchUtil_new.getMethodsExcludingOverridden(classHierarchy));\n    ListOperations.addAllElements(result, (List<SNode>)staticMethods);\n    return result;\n  }","commit_id":"138e91e03b6d536e3fdf25b6df5eb408444d87ee","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<SNode> replaceNodeMenu_StaticFieldReference_getParameterObjects(SNode node) {\n    List<SNode> result = new LinkedList<SNode>();\n    SNode classifier = SLinkOperations.getTarget(node, \"classifier\", false);\n    if(classifier == null) {\n      return result;\n    }\n    ISearchScope classHierarchy = BaseLanguageSearchUtil.createClassifierHierarchyScope((Classifier)classifier, IClassifiersSearchScope.STATIC_MEMBER);\n    List staticMethods = BaseLanguageSearchUtil.getMethodsExcludingOverridden(classHierarchy);\n    ListOperations.addAllElements(result, (List<SNode>)staticMethods);\n    List<SNode> allStaticMembers = classHierarchy.getNodes();\n    ListOperations.addAllElements(result, SequenceOperations.where(allStaticMembers, new zPredicate(null, null)));\n    return result;\n  }","id":90193,"modified_method":"public static List<SNode> replaceNodeMenu_StaticFieldReference_getParameterObjects(SNode node) {\n    List<SNode> result = new LinkedList<SNode>();\n    SNode classifier = SLinkOperations.getTarget(node, \"classifier\", false);\n    if(classifier == null) {\n      return result;\n    }\n    ISearchScope classHierarchy = BaseLanguageSearchUtil.createClassifierHierarchyScope((Classifier)classifier, IClassifiersSearchScope.STATIC_MEMBER);\n    List staticMethods = BaseAdapter.toNodes(BaseLanguageSearchUtil_new.getMethodsExcludingOverridden(classHierarchy));\n    ListOperations.addAllElements(result, (List<SNode>)staticMethods);\n    List<SNode> allStaticMembers = classHierarchy.getNodes();\n    ListOperations.addAllElements(result, SequenceOperations.where(allStaticMembers, new zPredicate(null, null)));\n    return result;\n  }","commit_id":"138e91e03b6d536e3fdf25b6df5eb408444d87ee","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String execPropertyGet(SNode node, String propertyName, IScope scope) {\n    return SPropertyOperations.get(SLinkOperations.getTarget(node, \"classifier\", false), \"name\") + \"$anonymous\";\n  }","id":90194,"modified_method":"public String execPropertyGet(SNode node, String propertyName, IScope scope) {\n    return SPropertyOperations.getString(SLinkOperations.getTarget(node, \"classifier\", false), \"name\") + \"$anonymous\";\n  }","commit_id":"eccc0d4718c169c62b07e0db0dbf9f31b6fcbb91","url":"https://github.com/JetBrains/MPS"},{"original_method":"public String execPropertyGet(SNode node, String propertyName, IScope scope) {\n    SNode parent = SNodeOperations.getParent(node, null, false, false);\n    if(parent != null) {\n      return SPropertyOperations.get(parent, \"name\");\n    }\n    return \"?constructor?\";\n  }","id":90195,"modified_method":"public String execPropertyGet(SNode node, String propertyName, IScope scope) {\n    SNode parent = SNodeOperations.getParent(node, null, false, false);\n    if(parent != null) {\n      return SPropertyOperations.getString(parent, \"name\");\n    }\n    return \"?constructor?\";\n  }","commit_id":"eccc0d4718c169c62b07e0db0dbf9f31b6fcbb91","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ISearchScope createNodeReferentSearchScope(SModel model, SNode enclosingNode, SNode referenceNode, IScope scope) {\n    return BaseLanguageSearchUtil.createClassifierHierarchyScope((Classifier)SLinkOperations.getTarget(referenceNode, \"enumClass\", false), IClassifiersSearchScope.ENUM_CONSTANT);\n  }","id":90196,"modified_method":"public ISearchScope createNodeReferentSearchScope(SModel model, SNode enclosingNode, SNode referenceNode, IScope scope) {\n    return BaseLanguageSearchUtil_new.createClassifierHierarchyScope((Classifier)BaseAdapter.fromNode(SLinkOperations.getTarget(referenceNode, \"enumClass\", false)), IClassifiersSearchScope.ENUM_CONSTANT);\n  }","commit_id":"eccc0d4718c169c62b07e0db0dbf9f31b6fcbb91","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ISearchScope createNodeReferentSearchScope(SModel model, SNode enclosingNode, SNode referenceNode, IScope scope) {\n    ISearchScope hierarchyScope = BaseLanguageSearchUtil.createClassifierHierarchyScope((Classifier)SLinkOperations.getTarget(referenceNode, \"classifier\", false), IClassifiersSearchScope.STATIC_FIELD);\n    List fields = BaseLanguageSearchUtil.getFieldsExcludingOverridden(hierarchyScope);\n    return new SimpleSearchScope((List<SNode>)fields);\n  }","id":90197,"modified_method":"public ISearchScope createNodeReferentSearchScope(SModel model, SNode enclosingNode, SNode referenceNode, IScope scope) {\n    ISearchScope hierarchyScope = BaseLanguageSearchUtil_new.createClassifierHierarchyScope((Classifier)BaseAdapter.fromNode(SLinkOperations.getTarget(referenceNode, \"classifier\", false)), IClassifiersSearchScope.STATIC_FIELD);\n    List fields = BaseAdapter.toNodes(BaseLanguageSearchUtil_new.getFieldsExcludingOverridden(hierarchyScope));\n    return new SimpleSearchScope((List<SNode>)fields);\n  }","commit_id":"eccc0d4718c169c62b07e0db0dbf9f31b6fcbb91","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ISearchScope createNodeReferentSearchScope(SModel model, SNode enclosingNode, SNode referenceNode, IScope scope) {\n    ISearchScope hierarchyScope = BaseLanguageSearchUtil.createClassifierHierarchyScope((Classifier)SLinkOperations.getTarget(referenceNode, \"classConcept\", false), IClassifiersSearchScope.STATIC_METHOD);\n    List methods = BaseLanguageSearchUtil.getMethodsExcludingOverridden(hierarchyScope);\n    return new SimpleSearchScope((List<SNode>)methods);\n  }","id":90198,"modified_method":"public ISearchScope createNodeReferentSearchScope(SModel model, SNode enclosingNode, SNode referenceNode, IScope scope) {\n    ISearchScope hierarchyScope = BaseLanguageSearchUtil_new.createClassifierHierarchyScope((Classifier)BaseAdapter.fromNode(SLinkOperations.getTarget(referenceNode, \"classConcept\", false)), IClassifiersSearchScope.STATIC_METHOD);\n    List methods = BaseAdapter.toNodes(BaseLanguageSearchUtil_new.getMethodsExcludingOverridden(hierarchyScope));\n    return new SimpleSearchScope((List<SNode>)methods);\n  }","commit_id":"eccc0d4718c169c62b07e0db0dbf9f31b6fcbb91","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ISearchScope createNodeReferentSearchScope(SModel model, SNode enclosingNode, SNode referenceNode, IScope scope) {\n    SNode enclosingClass = SNodeOperations.getParent(enclosingNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", true, false);\n    ISearchScope hierarchyScope = BaseLanguageSearchUtil.createSuperClassesScope((ClassConcept)enclosingClass, IClassifiersSearchScope.INSTANCE_METHOD);\n    List methods = BaseLanguageSearchUtil.getMethodsExcludingOverridden(hierarchyScope);\n    return new SimpleSearchScope((List<SNode>)methods);\n  }","id":90199,"modified_method":"public ISearchScope createNodeReferentSearchScope(SModel model, SNode enclosingNode, SNode referenceNode, IScope scope) {\n    SNode enclosingClass = SNodeOperations.getParent(enclosingNode, \"jetbrains.mps.baseLanguage.structure.ClassConcept\", true, false);\n    ISearchScope hierarchyScope = BaseLanguageSearchUtil_new.createSuperClassesScope((ClassConcept)enclosingClass.getAdapter(), IClassifiersSearchScope.INSTANCE_METHOD);\n    List methods = BaseAdapter.toNodes(BaseLanguageSearchUtil_new.getMethodsExcludingOverridden(hierarchyScope));\n    return new SimpleSearchScope((List<SNode>)methods);\n  }","commit_id":"eccc0d4718c169c62b07e0db0dbf9f31b6fcbb91","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static GlobalSearchScope getScope(Project project, @Nullable Module module, @Nullable PsiFile psiFile) {\n    if (module == null || psiFile == null) {\n      return ProjectScope.getAllScope(project);\n     }\n     VirtualFile file = psiFile.getOriginalFile().getVirtualFile();\n     if (file == null) {\n       return ProjectScope.getAllScope(project);\n     }\n     final boolean inTests = ProjectRootManager.getInstance(project).getFileIndex().isInTestSourceContent(file);\n\n     return module.getModuleRuntimeScope(inTests).union(module.getModuleWithDependenciesAndLibrariesScope(inTests));\n  }","id":90200,"modified_method":"public static GlobalSearchScope getScope(Project project, @Nullable Module module, @Nullable PsiFile psiFile) {\n    if (module == null || psiFile == null) {\n      return ProjectScope.getAllScope(project);\n     }\n     VirtualFile file = psiFile.getOriginalFile().getVirtualFile();\n     if (file == null) {\n       return ProjectScope.getAllScope(project);\n     }\n     final boolean inTests = ProjectRootManager.getInstance(project).getFileIndex().isInTestSourceContent(file);\n\n     return module.getModuleRuntimeScope(inTests);\n  }","commit_id":"a5a4245c05450003438cec546236ee488a349043","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiClass findClass(@Nullable String name, @NotNull PsiFile file, @Nullable final Module module, @Nullable final GlobalSearchScope searchScope) {\n    if (name == null) return null;\n    if (name.indexOf('$')>=0) name = name.replace('$', '.');\n\n    final GlobalSearchScope scope;\n    if (searchScope == null) {\n\n      if (module != null) {\n        file = file.getOriginalFile();\n        VirtualFile virtualFile = file.getVirtualFile();\n        if (virtualFile == null) {\n          scope = GlobalSearchScope.moduleRuntimeScope(module, true);\n        }\n        else {\n          ProjectFileIndex fileIndex = ProjectRootManager.getInstance(file.getProject()).getFileIndex();\n          boolean tests = fileIndex.isInTestSourceContent(virtualFile);\n          scope = module.getModuleRuntimeScope(tests).union(module.getModuleWithDependenciesAndLibrariesScope(tests));\n        }\n      }\n      else {\n        scope = file.getResolveScope();\n      }\n    }\n    else {\n      scope = searchScope;\n    }\n\n    final PsiClass aClass = JavaPsiFacade.getInstance(file.getProject()).findClass(name, scope);\n    if (aClass != null) {\n      assert aClass.isValid() : name;\n    }\n    return aClass;\n  }","id":90201,"modified_method":"@Nullable\n  public static PsiClass findClass(@Nullable String name, @NotNull PsiFile file, @Nullable final Module module, @Nullable final GlobalSearchScope searchScope) {\n    if (name == null) return null;\n    if (name.indexOf('$')>=0) name = name.replace('$', '.');\n\n    final GlobalSearchScope scope;\n    if (searchScope == null) {\n\n      if (module != null) {\n        file = file.getOriginalFile();\n        VirtualFile virtualFile = file.getVirtualFile();\n        if (virtualFile == null) {\n          scope = GlobalSearchScope.moduleRuntimeScope(module, true);\n        }\n        else {\n          ProjectFileIndex fileIndex = ProjectRootManager.getInstance(file.getProject()).getFileIndex();\n          boolean tests = fileIndex.isInTestSourceContent(virtualFile);\n          scope = module.getModuleRuntimeScope(tests);\n        }\n      }\n      else {\n        scope = file.getResolveScope();\n      }\n    }\n    else {\n      scope = searchScope;\n    }\n\n    final PsiClass aClass = JavaPsiFacade.getInstance(file.getProject()).findClass(name, scope);\n    if (aClass != null) {\n      assert aClass.isValid() : name;\n    }\n    return aClass;\n  }","commit_id":"a5a4245c05450003438cec546236ee488a349043","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected GlobalSearchScope getScope(final GenericDomValue domValue) {\n    final Module module = domValue.getModule();\n    if (module == null) return null;\n    XmlElement element = domValue.getXmlElement();\n    if (element == null) return null;\n    PsiFile file = element.getContainingFile();\n    if (file == null) return null;\n    file = file.getOriginalFile();\n    VirtualFile virtualFile = file.getVirtualFile();\n    if (virtualFile == null) return null;\n    ProjectFileIndex fileIndex = ProjectRootManager.getInstance(file.getProject()).getFileIndex();\n    boolean tests = fileIndex.isInTestSourceContent(virtualFile);\n    return module.getModuleRuntimeScope(tests).union(module.getModuleWithDependenciesAndLibrariesScope(tests));\n  }","id":90202,"modified_method":"@Nullable\n  protected GlobalSearchScope getScope(final GenericDomValue domValue) {\n    final Module module = domValue.getModule();\n    if (module == null) return null;\n    XmlElement element = domValue.getXmlElement();\n    if (element == null) return null;\n    PsiFile file = element.getContainingFile();\n    if (file == null) return null;\n    file = file.getOriginalFile();\n    VirtualFile virtualFile = file.getVirtualFile();\n    if (virtualFile == null) return null;\n    ProjectFileIndex fileIndex = ProjectRootManager.getInstance(file.getProject()).getFileIndex();\n    boolean tests = fileIndex.isInTestSourceContent(virtualFile);\n    return module.getModuleRuntimeScope(tests);\n  }","commit_id":"a5a4245c05450003438cec546236ee488a349043","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dragOver(DropTargetDragEvent dtde) {\n    try {\n      if (myComponentDragObject == null) {\n        dtde.rejectDrag();\n        return;\n      }\n      final int dx = dtde.getLocation().x - myLastPoint.x;\n      final int dy = dtde.getLocation().y - myLastPoint.y;\n\n      if (myDraggedComponentsCopy != null && myDraggedComponentList != null) {\n        for (RadComponent aMySelection : myDraggedComponentsCopy) {\n          aMySelection.shift(dx, dy);\n        }\n      }\n\n      myLastPoint = dtde.getLocation();\n      myEditor.getDragLayer().repaint();\n\n      ComponentDropLocation location = myGridInsertProcessor.processDragEvent(dtde.getLocation(), myComponentDragObject);\n      if (!location.canDrop(myComponentDragObject) ||\n          (myDraggedComponentList != null && FormEditingUtil.isDropOnChild(myDraggedComponentList, location))) {\n        myComponentTree.setDropTargetComponent(null);\n        dtde.rejectDrag();\n      }\n      else {\n        myComponentTree.setDropTargetComponent(location.getContainer());\n        dtde.acceptDrag(dtde.getDropAction());\n      }\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","id":90203,"modified_method":"public void dragOver(DropTargetDragEvent dtde) {\n    try {\n      if (myComponentDragObject == null) {\n        dtde.rejectDrag();\n        return;\n      }\n      final int dx = dtde.getLocation().x - myLastPoint.x;\n      final int dy = dtde.getLocation().y - myLastPoint.y;\n\n      if (myDraggedComponentsCopy != null && myDraggedComponentList != null) {\n        for (RadComponent aMySelection : myDraggedComponentsCopy) {\n          aMySelection.shift(dx, dy);\n        }\n      }\n\n      myLastPoint = dtde.getLocation();\n      myEditor.getDragLayer().repaint();\n\n      ComponentDropLocation location = myGridInsertProcessor.processDragEvent(dtde.getLocation(), myComponentDragObject);\n      if (!location.canDrop(myComponentDragObject) ||\n          (myDraggedComponentList != null && FormEditingUtil.isDropOnChild(myDraggedComponentList, location))) {\n        if (myComponentTree != null) {\n          myComponentTree.setDropTargetComponent(null);\n        }\n        dtde.rejectDrag();\n      }\n      else {\n        if (myComponentTree != null) {\n          myComponentTree.setDropTargetComponent(location.getContainer());\n        }\n        dtde.acceptDrag(dtde.getDropAction());\n      }\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","commit_id":"33e85fb4f5b05f32c00187a6779e2a53f2665850","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void drop(final DropTargetDropEvent dtde) {\n    try {\n      myComponentTree.setDropTargetComponent(null);\n\n\n      final DraggedComponentList dcl = DraggedComponentList.fromTransferable(dtde.getTransferable());\n      if (dcl != null) {\n        CommandProcessor.getInstance().executeCommand(myEditor.getProject(),\n                                                      new Runnable() {\n                                                        public void run() {\n                                                          if (processDrop(dcl, dtde.getLocation(), dtde.getDropAction())) {\n                                                            myEditor.refreshAndSave(true);\n                                                          }\n                                                        }\n                                                      }, UIDesignerBundle.message(\"command.drop.components\"), null);\n      }\n      else {\n        ComponentItem componentItem = SimpleTransferable.getData(dtde.getTransferable(), ComponentItem.class);\n        if (componentItem != null) {\n          myEditor.getMainProcessor().setInsertFeedbackEnabled(false);\n          new InsertComponentProcessor(myEditor).processComponentInsert(dtde.getLocation(), componentItem);\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              PaletteManager.getInstance(myEditor.getProject()).clearActiveItem();\n              myEditor.getActiveDecorationLayer().removeFeedback();\n              myEditor.getLayeredPane().setCursor(null);\n              myEditor.getGlassLayer().requestFocus();\n              myEditor.getMainProcessor().setInsertFeedbackEnabled(true);\n            }\n          });\n        }\n      }\n      myDraggedComponentsCopy = null;\n      myEditor.repaintLayeredPane();\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","id":90204,"modified_method":"public void drop(final DropTargetDropEvent dtde) {\n    try {\n      if (myComponentTree != null) {\n        myComponentTree.setDropTargetComponent(null);\n      }\n\n\n      final DraggedComponentList dcl = DraggedComponentList.fromTransferable(dtde.getTransferable());\n      if (dcl != null) {\n        CommandProcessor.getInstance().executeCommand(myEditor.getProject(),\n                                                      new Runnable() {\n                                                        public void run() {\n                                                          if (processDrop(dcl, dtde.getLocation(), dtde.getDropAction())) {\n                                                            myEditor.refreshAndSave(true);\n                                                          }\n                                                        }\n                                                      }, UIDesignerBundle.message(\"command.drop.components\"), null);\n      }\n      else {\n        ComponentItem componentItem = SimpleTransferable.getData(dtde.getTransferable(), ComponentItem.class);\n        if (componentItem != null) {\n          myEditor.getMainProcessor().setInsertFeedbackEnabled(false);\n          new InsertComponentProcessor(myEditor).processComponentInsert(dtde.getLocation(), componentItem);\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            public void run() {\n              PaletteManager.getInstance(myEditor.getProject()).clearActiveItem();\n              myEditor.getActiveDecorationLayer().removeFeedback();\n              myEditor.getLayeredPane().setCursor(null);\n              myEditor.getGlassLayer().requestFocus();\n              myEditor.getMainProcessor().setInsertFeedbackEnabled(true);\n            }\n          });\n        }\n      }\n      myDraggedComponentsCopy = null;\n      myEditor.repaintLayeredPane();\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","commit_id":"c36fc8beb90b07a8fa251babf6986437fd402a09","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dragExit(DropTargetEvent dte) {\n    try {\n      myComponentTree.setDropTargetComponent(null);\n      myUseDragDelta = false;\n      if (myDraggedComponentList != null) {\n        cancelDrag();\n        setDraggingState(myDraggedComponentList, false);\n        myEditor.getActiveDecorationLayer().removeFeedback();\n        myDraggedComponentList = null;\n        myEditor.setDesignTimeInsets(2);\n      }\n      myDraggedComponentsCopy = null;\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","id":90205,"modified_method":"public void dragExit(DropTargetEvent dte) {\n    try {\n      if (myComponentTree != null) {\n        myComponentTree.setDropTargetComponent(null);\n      }\n      myUseDragDelta = false;\n      if (myDraggedComponentList != null) {\n        cancelDrag();\n        setDraggingState(myDraggedComponentList, false);\n        myEditor.getActiveDecorationLayer().removeFeedback();\n        myDraggedComponentList = null;\n        myEditor.setDesignTimeInsets(2);\n      }\n      myDraggedComponentsCopy = null;\n    }\n    catch (Exception e) {\n      LOG.error(e);\n    }\n  }","commit_id":"5ebbe78e62c1f1ac0a067a661dd4ddc2b1938ddc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void dispatch( String dest, Object msg ) throws Exception {\n    dest = ServiceContextManager.mapServiceToEndpoint( dest );\n    MuleContext muleCtx;\n    try {\n      muleCtx = ServiceContextManager.getContext( );\n    } catch ( Exception ex ) {\n      LOG.error( ex, ex );\n      throw new ServiceDispatchException( \"Failed to dispatch message to \" + dest + \" caused by failure to obtain service context reference: \"\n                                          + ex.getMessage( ), ex );\n    }\n    OutboundEndpoint endpoint;\n    try {\n      endpoint = muleCtx.getEndpointFactory( ).getOutboundEndpoint( dest );\n      perhapsConfigureConnector( endpoint.getConnector( ) );\n    } catch ( MuleException ex ) {\n      LOG.error( ex, ex );\n      throw new ServiceDispatchException( \"Failed to dispatch message to \" + dest + \" caused by failure to obtain service endpoint reference: \"\n                                          + ex.getMessage( ), ex );\n    }\n    MuleSession muleSession = new DefaultMuleSession( );\n    final Context ctx;\n    if( msg instanceof BaseMessage) {\n      msg = ((BaseMessage) msg).lookupAndSetCorrelationId();\n      ctx = Contexts.createWrapped( dest, ( BaseMessage ) msg );\n    }else\n      ctx = null;\n    \n    MessageDispatcher dispatcher = null;\n    try {\n      dispatcher = dispatcherFactory.create( endpoint );\n      dispatcher.initialise( );\n      dispatcher.start( );\n      MuleMessage muleMsg = dispatcher.createMuleMessage( msg );\n      MuleEvent muleEvent = new DefaultMuleEvent( muleMsg, endpoint.getExchangePattern(), (FlowConstruct) null, muleSession );\n      dispatcher.process( muleEvent );\n    } catch ( DispatchException ex ) {\n      LOG.error( ex, ex );\n      throw new ServiceDispatchException( \"Error while dispatching message (\" + msg + \") to \" + dest + \" caused by: \" + ex.getMessage( ), ex );\n    } catch ( MuleException ex ) {\n      LOG.error( ex, ex );\n      throw new ServiceDispatchException( \"Failed to dispatch message to \" + dest + \" caused by failure to obtain service dispatcher reference: \"\n                                          + ex.getMessage( ), ex );\n    } finally {\n      if ( dispatcher != null ) dispatcher.dispose( );\n    }\n    final long clearContextTime = System.currentTimeMillis( ) + TimeUnit.SECONDS.toMillis( CONTEXT_TIMEOUT );\n    Threads.enqueue( Empyrean.class, ServiceContext.class, new Callable<Boolean>( ) {\n      @Override\n      public Boolean call( ) {\n        try {\n          long sleepTime = clearContextTime - System.currentTimeMillis( );\n          if ( sleepTime > 1 ) {\n            Thread.sleep( sleepTime );\n          }\n          Contexts.clear( ctx );\n        } catch ( InterruptedException ex ) {\n          Thread.currentThread( ).interrupt( );\n        }\n        return true;\n      }\n    } );\n  }","id":90206,"modified_method":"public static void dispatch( String dest, Object msg ) throws Exception {\n    dest = ServiceContextManager.mapServiceToEndpoint( dest );\n    MuleContext muleCtx;\n    try {\n      muleCtx = ServiceContextManager.getContext( );\n    } catch ( Exception ex ) {\n      LOG.error( ex, ex );\n      throw new ServiceDispatchException( \"Failed to dispatch message to \" + dest + \" caused by failure to obtain service context reference: \"\n                                          + ex.getMessage( ), ex );\n    }\n    OutboundEndpoint endpoint;\n    try {\n      endpoint = muleCtx.getEndpointFactory( ).getOutboundEndpoint( dest );\n      perhapsConfigureConnector( endpoint.getConnector( ) );\n    } catch ( MuleException ex ) {\n      LOG.error( ex, ex );\n      throw new ServiceDispatchException( \"Failed to dispatch message to \" + dest + \" caused by failure to obtain service endpoint reference: \"\n                                          + ex.getMessage( ), ex );\n    }\n    MuleSession muleSession = new DefaultMuleSession( );\n    final Context ctx;\n    if( msg instanceof BaseMessage) {\n      msg = ((BaseMessage) msg).lookupAndSetCorrelationId();\n      ctx = Contexts.createWrapped( dest, ( BaseMessage ) msg );\n    }else\n      ctx = null;\n    \n    MessageDispatcher dispatcher = null;\n    try {\n      dispatcher = dispatcherFactory.create( endpoint );\n      dispatcher.initialise( );\n      dispatcher.start( );\n      MuleMessage muleMsg = dispatcher.createMuleMessage( msg );\n      MuleEvent muleEvent = new DefaultMuleEvent( muleMsg, endpoint.getExchangePattern(), (FlowConstruct) null, muleSession );\n      dispatcher.process( muleEvent );\n    } catch ( DispatchException ex ) {\n      LOG.error( ex, ex );\n      throw new ServiceDispatchException( \"Error while dispatching message (\" + msg + \") to \" + dest + \" caused by: \" + ex.getMessage( ), ex );\n    } catch ( MuleException ex ) {\n      LOG.error( ex, ex );\n      throw new ServiceDispatchException( \"Failed to dispatch message to \" + dest + \" caused by failure to obtain service dispatcher reference: \"\n                                          + ex.getMessage( ), ex );\n    } finally {\n      if ( dispatcher != null ) dispatcher.dispose( );\n    }\n    if ( ctx != null ) {\n      Threads.enqueue( Empyrean.class, ServiceContext.class, 8, new Callable<Boolean>( ) {\n        private final long clearContextTime = System.currentTimeMillis( ) + TimeUnit.SECONDS.toMillis( CONTEXT_TIMEOUT );\n        private final String contextCorrelationId = ctx.getCorrelationId( );\n\n        @Override\n        public Boolean call( ) {\n          try {\n            long sleepTime = clearContextTime - System.currentTimeMillis( );\n            if ( sleepTime > 1 ) {\n              Thread.sleep( sleepTime );\n            }\n            Contexts.clear( contextCorrelationId );\n          } catch ( InterruptedException ex ) {\n            Thread.currentThread( ).interrupt( );\n          }\n          return true;\n        }\n      } );\n    }\n  }","commit_id":"a483c35daeda02a6f467bcac23eb0d9a9a41d39b","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic boolean validateReference(\n\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\treturn validateReference(\n\t\t\tportletDataContext, referenceElement.attributeValue(\"uuid\"));\n\t}","id":90207,"modified_method":"@Override\n\tpublic boolean validateReference(\n\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\tString uuid = referenceElement.attributeValue(\"uuid\");\n\n\t\ttry {\n\t\t\tboolean valid = validateMissingReference(\n\t\t\t\tuuid, portletDataContext.getCompanyId(),\n\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\tif (!valid) {\n\t\t\t\tvalid = validateMissingReference(\n\t\t\t\t\tuuid, portletDataContext.getCompanyId(),\n\t\t\t\t\tportletDataContext.getCompanyGroupId());\n\t\t\t}\n\n\t\t\treturn valid;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"ab92a2d482b92eb6a68c9ba793d1e12d3b39b165","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean validateReference(\n\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\treturn validateReference(\n\t\t\tportletDataContext,\n\t\t\treferenceElement.attributeValue(\"article-resource-uuid\"));\n\t}","id":90208,"modified_method":"@Override\n\tpublic boolean validateReference(\n\t\tPortletDataContext portletDataContext, Element referenceElement) {\n\n\t\tString articleResourceUuid = referenceElement.attributeValue(\n\t\t\t\"article-resource-uuid\");\n\t\tString articleArticleId = referenceElement.attributeValue(\"article-id\");\n\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\treferenceElement.attributeValue(\"preloaded\"));\n\n\t\ttry {\n\t\t\tJournalArticle existingArticle = fetchExistingArticle(\n\t\t\t\tarticleResourceUuid, portletDataContext.getScopeGroupId(),\n\t\t\t\tarticleArticleId, null, 0.0, preloaded);\n\n\t\t\tif (existingArticle == null) {\n\t\t\t\texistingArticle = fetchExistingArticle(\n\t\t\t\t\tarticleResourceUuid, portletDataContext.getCompanyGroupId(),\n\t\t\t\t\tarticleArticleId, null, 0.0, preloaded);\n\t\t\t}\n\n\t\t\tif (existingArticle == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}","commit_id":"ab92a2d482b92eb6a68c9ba793d1e12d3b39b165","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Main event dispatching entry.\n     */\n    public void dispatchEvent(PipelineContext pipelineContext, XFormsEvent event) {\n\n        if (XFormsServer.logger.isDebugEnabled()) {\n            logDebug(\"event\", \"dispatching\", new String[] { \"name\", event.getEventName(), \"id\", event.getTargetObject().getEffectiveId(), \"location\", event.getLocationData().toString() });\n        }\n\n        final XFormsEventTarget targetObject = event.getTargetObject();\n        try {\n            if (targetObject == null)\n                throw new ValidationException(\"Target object null for event: \" + event.getEventName(), getLocationData());\n\n            // Find all event handler containers\n            final List containers = new ArrayList();\n            {\n                XFormsEventHandlerContainer container\n                        = (targetObject instanceof XFormsEventHandlerContainer) ? (XFormsEventHandlerContainer) targetObject : targetObject.getParentContainer(this);\n                while (container != null) {\n                    containers.add(container);\n                    container = container.getParentContainer(this);\n                }\n            }\n\n            boolean propagate = true;\n            boolean performDefaultAction = true;\n\n            // Go from root to leaf\n            Collections.reverse(containers);\n\n            // Capture phase\n            for (Iterator i = containers.iterator(); i.hasNext();) {\n                final XFormsEventHandlerContainer container = (XFormsEventHandlerContainer) i.next();\n                final List eventHandlers = container.getEventHandlers(this);\n\n                if (eventHandlers != null) {\n                    if (container != targetObject) {\n                        // Event listeners on the target which are in capture mode are not called\n\n                        for (Iterator j = eventHandlers.iterator(); j.hasNext();) {\n                            final XFormsEventHandler eventHandler = (XFormsEventHandler) j.next();\n\n                            if (!eventHandler.isPhase() && eventHandler.getEventName().equals(event.getEventName())\n                                    && (eventHandler.getTargetId() == null || eventHandler.getTargetId().equals(event.getTargetObject().getId()))) {\n                                // Capture phase match on event name and target is specified\n                                startHandleEvent(event);\n                                try {\n                                    eventHandler.handleEvent(pipelineContext, XFormsContainingDocument.this, container, event);\n                                } finally {\n                                    endHandleEvent();\n                                }\n                                propagate &= eventHandler.isPropagate();\n                                performDefaultAction &= eventHandler.isDefaultAction();\n                            }\n                        }\n                        // Cancel propagation if requested and if authorized by event\n                        if (!propagate && event.isCancelable())\n                            break;\n                    }\n                }\n            }\n\n            // Go from leaf to root\n            Collections.reverse(containers);\n\n            // Bubbling phase\n            if (propagate && event.isBubbles()) {\n                for (Iterator i = containers.iterator(); i.hasNext();) {\n                    final XFormsEventHandlerContainer container = (XFormsEventHandlerContainer) i.next();\n                    final List eventHandlers = container.getEventHandlers(this);\n\n                    if (eventHandlers != null) {\n                        for (Iterator j = eventHandlers.iterator(); j.hasNext();) {\n                            final XFormsEventHandler eventHandler = (XFormsEventHandler) j.next();\n\n                            if (eventHandler.isPhase() && eventHandler.getEventName().equals(event.getEventName())\n                                    && (eventHandler.getTargetId() == null || eventHandler.getTargetId().equals(event.getTargetObject().getId()))) {\n                                // Bubbling phase match on event name and target is specified\n                                startHandleEvent(event);\n                                try {\n                                    eventHandler.handleEvent(pipelineContext, XFormsContainingDocument.this, container, event);\n                                } finally {\n                                    endHandleEvent();\n                                }\n                                propagate &= eventHandler.isPropagate();\n                                performDefaultAction &= eventHandler.isDefaultAction();\n                            }\n                        }\n                        // Cancel propagation if requested and if authorized by event\n                        if (!propagate)\n                            break;\n                    }\n                }\n            }\n\n            // Perform default action is allowed to\n            if (performDefaultAction || !event.isCancelable()) {\n                startHandleEvent(event);\n                try {\n                    targetObject.performDefaultAction(pipelineContext, event);\n                } finally {\n                    endHandleEvent();\n                }\n            }\n        } catch (Exception e) {\n            // Add location information if possible\n            final LocationData locationData = (targetObject != null)\n                    ? ((targetObject.getLocationData() != null)\n                        ? targetObject.getLocationData()\n                        : getLocationData())\n                    : null;\n\n            throw ValidationException.wrapException(e, new ExtendedLocationData(locationData, \"dispatching XForms event\",\n                    new String[] { \"event\", event.getEventName(), \"target id\", targetObject.getEffectiveId() }));\n        }\n    }","id":90209,"modified_method":"/**\n     * Main event dispatching entry.\n     */\n    public void dispatchEvent(PipelineContext pipelineContext, XFormsEvent event) {\n\n        if (XFormsServer.logger.isDebugEnabled()) {\n            logDebug(\"event\", \"dispatching\", new String[] { \"name\", event.getEventName(), \"id\", event.getTargetObject().getEffectiveId(), \"location\", event.getLocationData().toString() });\n        }\n\n        final XFormsEventTarget targetObject = event.getTargetObject();\n        try {\n            if (targetObject == null)\n                throw new ValidationException(\"Target object null for event: \" + event.getEventName(), getLocationData());\n\n            // Find all event handler containers\n            final List containers = new ArrayList();\n            {\n                XFormsEventHandlerContainer container\n                        = (targetObject instanceof XFormsEventHandlerContainer) ? (XFormsEventHandlerContainer) targetObject : targetObject.getParentContainer(this);\n                while (container != null) {\n                    containers.add(container);\n                    container = container.getParentContainer(this);\n                }\n            }\n\n            boolean propagate = true;\n            boolean performDefaultAction = true;\n\n            // Go from root to leaf\n            Collections.reverse(containers);\n\n            // Capture phase\n            for (Iterator i = containers.iterator(); i.hasNext();) {\n                final XFormsEventHandlerContainer container = (XFormsEventHandlerContainer) i.next();\n                final List eventHandlers = container.getEventHandlers(this);\n\n                if (eventHandlers != null) {\n                    if (container != targetObject) {\n                        // Event listeners on the target which are in capture mode are not called\n\n                        for (Iterator j = eventHandlers.iterator(); j.hasNext();) {\n                            final XFormsEventHandler eventHandler = (XFormsEventHandler) j.next();\n\n                            if (!eventHandler.isBubblingPhase()\n                                    && eventHandler.isMatchEventName(event.getEventName())\n                                    && eventHandler.isMatchTarget(event.getTargetObject().getId())) {\n                                // Capture phase match on event name and target is specified\n                                startHandleEvent(event);\n                                try {\n                                    eventHandler.handleEvent(pipelineContext, XFormsContainingDocument.this, container, event);\n                                } finally {\n                                    endHandleEvent();\n                                }\n                                propagate &= eventHandler.isPropagate();\n                                performDefaultAction &= eventHandler.isPerformDefaultAction();\n                            }\n                        }\n                        // Cancel propagation if requested and if authorized by event\n                        if (!propagate && event.isCancelable())\n                            break;\n                    }\n                }\n            }\n\n            // Go from leaf to root\n            Collections.reverse(containers);\n\n            // Bubbling phase\n            if (propagate && event.isBubbles()) {\n                for (Iterator i = containers.iterator(); i.hasNext();) {\n                    final XFormsEventHandlerContainer container = (XFormsEventHandlerContainer) i.next();\n                    final List eventHandlers = container.getEventHandlers(this);\n\n                    if (eventHandlers != null) {\n                        for (Iterator j = eventHandlers.iterator(); j.hasNext();) {\n                            final XFormsEventHandler eventHandler = (XFormsEventHandler) j.next();\n\n                            if (eventHandler.isBubblingPhase()\n                                    && eventHandler.isMatchEventName(event.getEventName())\n                                    && eventHandler.isMatchTarget(event.getTargetObject().getId())) {\n                                // Bubbling phase match on event name and target is specified\n                                startHandleEvent(event);\n                                try {\n                                    eventHandler.handleEvent(pipelineContext, XFormsContainingDocument.this, container, event);\n                                } finally {\n                                    endHandleEvent();\n                                }\n                                propagate &= eventHandler.isPropagate();\n                                performDefaultAction &= eventHandler.isPerformDefaultAction();\n                            }\n                        }\n                        // Cancel propagation if requested and if authorized by event\n                        if (!propagate)\n                            break;\n                    }\n                }\n            }\n\n            // Perform default action is allowed to\n            if (performDefaultAction || !event.isCancelable()) {\n                startHandleEvent(event);\n                try {\n                    targetObject.performDefaultAction(pipelineContext, event);\n                } finally {\n                    endHandleEvent();\n                }\n            }\n        } catch (Exception e) {\n            // Add location information if possible\n            final LocationData locationData = (targetObject != null)\n                    ? ((targetObject.getLocationData() != null)\n                        ? targetObject.getLocationData()\n                        : getLocationData())\n                    : null;\n\n            throw ValidationException.wrapException(e, new ExtendedLocationData(locationData, \"dispatching XForms event\",\n                    new String[] { \"event\", event.getEventName(), \"target id\", targetObject.getEffectiveId() }));\n        }\n    }","commit_id":"e5102bcf99d13269e76e3128a61a2d32fe9a4953","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Utility method to extract event handlers.\n     *\n     * @param containingElement         element possibly containing event handlers\n     * @param eventNames                Map<String, String> of event name to \"\"\n     * @return                          Map<String, List<XFormsEventHandler>> of observer id to List of XFormsEventHandler\n     */\n    public static Map extractEventHandlers(Element containingElement, Map eventNames) {\n\n        // Nothing to do if there are no children elements\n        final List children = containingElement.elements();\n        if (children == null)\n            return null;\n\n        Map eventHandlersMap = null;\n        final String containerIdAttribute = containingElement.attributeValue(\"id\");\n        for (Iterator i = children.iterator(); i.hasNext();) {\n            final Element currentElement = (Element) i.next();\n\n            if (XFormsActions.isActionName(currentElement.getNamespaceURI(), currentElement.getName())) {\n                final String eventName = currentElement.attributeValue(XFormsConstants.XML_EVENTS_EVENT_ATTRIBUTE_QNAME);\n                if (eventName != null) {\n\n                    // Found an action with ev:event attribute\n                    if (eventHandlersMap == null)\n                        eventHandlersMap = new HashMap();\n\n                    // Get observers\n                    // NOTE: Supporting space-separated handlers is an extension of XML Events\n                    final String[] observerIds;\n                    {\n                        final String observerIdAttribute = currentElement.attributeValue(XFormsConstants.XML_EVENTS_OBSERVER_ATTRIBUTE_QNAME);\n                        if (observerIdAttribute == null) {\n                            observerIds = new String[] { containerIdAttribute };\n                        } else {\n                            observerIds = StringUtils.split(observerIdAttribute);\n                        }\n                    }\n\n                    final XFormsEventHandlerImpl newEventHandlerImpl = new XFormsEventHandlerImpl(currentElement, containerIdAttribute, observerIds);\n                    for (int j = 0; j < observerIds.length; j++) {\n                        final String currentObserverId = observerIds[j];\n                        // Get handlers for observer\n                        final List eventHandlersForObserver;\n                        {\n                            final Object currentList = eventHandlersMap.get(currentObserverId);\n                            if (currentList == null) {\n                                eventHandlersForObserver = new ArrayList();\n                                eventHandlersMap.put(currentObserverId, eventHandlersForObserver);\n                            } else {\n                                eventHandlersForObserver = (List) currentList;\n                            }\n                        }\n\n                        // Add event handler\n                        eventHandlersForObserver.add(newEventHandlerImpl);\n                    }\n                    \n                    // Remember that there is an event\n                    eventNames.put(eventName, \"\");\n                }\n            }\n        }\n        return eventHandlersMap;\n    }","id":90210,"modified_method":"/**\n     * Utility method to extract event handlers.\n     *\n     * @param containingElement         element possibly containing event handlers\n     * @param eventNames                Map<String, String> of event name to \"\"\n     * @return                          Map<String, List<XFormsEventHandler>> of observer id to List of XFormsEventHandler\n     */\n    public static Map extractEventHandlers(Element containingElement, Map eventNames) {\n\n        // Nothing to do if there are no children elements\n        final List children = containingElement.elements();\n        if (children == null)\n            return null;\n\n        Map eventHandlersMap = null;\n        final String containerIdAttribute = containingElement.attributeValue(\"id\");\n        for (Iterator i = children.iterator(); i.hasNext();) {\n            final Element currentElement = (Element) i.next();\n\n            if (XFormsActions.isActionName(currentElement.getNamespaceURI(), currentElement.getName())) {\n                final String eventName = currentElement.attributeValue(XFormsConstants.XML_EVENTS_EVENT_ATTRIBUTE_QNAME);\n                if (eventName != null) {\n\n                    // Found an action with ev:event attribute\n                    if (eventHandlersMap == null)\n                        eventHandlersMap = new HashMap();\n\n                    final XFormsEventHandlerImpl newEventHandlerImpl = new XFormsEventHandlerImpl(currentElement, containerIdAttribute);\n                    final String[] observerIds = newEventHandlerImpl.getObserverIds();\n                    for (int j = 0; j < observerIds.length; j++) {\n                        final String currentObserverId = observerIds[j];\n                        // Get handlers for observer\n                        final List eventHandlersForObserver;\n                        {\n                            final Object currentList = eventHandlersMap.get(currentObserverId);\n                            if (currentList == null) {\n                                eventHandlersForObserver = new ArrayList();\n                                eventHandlersMap.put(currentObserverId, eventHandlersForObserver);\n                            } else {\n                                eventHandlersForObserver = (List) currentList;\n                            }\n                        }\n\n                        // Add event handler\n                        eventHandlersForObserver.add(newEventHandlerImpl);\n                    }\n                    \n                    // Remember that there is an event\n                    eventNames.put(eventName, \"\");\n                }\n            }\n        }\n        return eventHandlersMap;\n    }","commit_id":"e5102bcf99d13269e76e3128a61a2d32fe9a4953","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public boolean isPropagate() {\n        return propagate;\n    }","id":90211,"modified_method":"public boolean isPropagate() {\n        return isPropagate;\n    }","commit_id":"e5102bcf99d13269e76e3128a61a2d32fe9a4953","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public XFormsEventHandlerImpl(Element eventHandlerElement, String containerId, String[] observerIds) {\n        this.eventHandlerElement = eventHandlerElement;\n        this.containerId = containerId;\n\n        this.observerIds = observerIds;\n        this.eventName = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_EVENT_ATTRIBUTE_QNAME);\n        this.targetId = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_TARGET_ATTRIBUTE_QNAME);\n\n        {\n            final String captureString = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_PHASE_ATTRIBUTE_QNAME);\n            this.phase = !\"capture\".equals(captureString);\n        }\n        {\n            final String propagateString = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_PROPAGATE_ATTRIBUTE_QNAME);\n            this.propagate = !\"stop\".equals(propagateString);\n        }\n        {\n            final String defaultActionString = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_DEFAULT_ACTION_ATTRIBUTE_QNAME);\n            this.defaultAction = !\"cancel\".equals(defaultActionString);\n        }\n    }","id":90212,"modified_method":"public XFormsEventHandlerImpl(Element eventHandlerElement, String containerId) {\n\n        this.eventHandlerElement = eventHandlerElement;\n        this.containerId = containerId;\n\n        // Gather observers\n        // NOTE: Supporting space-separated handlers is an extension\n        {\n            final String observerAttribute = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_OBSERVER_ATTRIBUTE_QNAME);\n            if (observerAttribute == null) {\n                observerIds = new String[] { containerId };\n            } else {\n                observerIds = StringUtils.split(observerAttribute);\n            }\n        }\n\n        // Gather event names\n        // NOTE: Supporting space-separated event names is an extension\n        {\n            final String eventAttribute = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_EVENT_ATTRIBUTE_QNAME);\n            eventNames = new HashMap();\n            final String[] eventNamesArray = StringUtils.split(eventAttribute);\n            for (int i = 0; i < eventNamesArray.length; i++) {\n                eventNames.put(eventNamesArray[i], \"\");\n            }\n        }\n\n        // Gather target ids\n        // NOTE: Supporting space-separated target ids is an extension\n        {\n            final String targetAttribute = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_TARGET_ATTRIBUTE_QNAME);\n            if (targetAttribute == null) {\n                targetIds = null;\n            } else {\n                targetIds = new HashMap();\n                final String[] targetIdsArray = StringUtils.split(targetAttribute);\n                for (int i = 0; i < targetIdsArray.length; i++) {\n                    targetIds.put(targetIdsArray[i], \"\");\n                }\n            }\n        }\n\n        {\n            final String captureString = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_PHASE_ATTRIBUTE_QNAME);\n            this.isBubblingPhase = !\"capture\".equals(captureString);\n        }\n        {\n            final String propagateString = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_PROPAGATE_ATTRIBUTE_QNAME);\n            this.isPropagate = !\"stop\".equals(propagateString);\n        }\n        {\n            final String defaultActionString = eventHandlerElement.attributeValue(XFormsConstants.XML_EVENTS_DEFAULT_ACTION_ATTRIBUTE_QNAME);\n            this.isPerformDefaultAction = !\"cancel\".equals(defaultActionString);\n        }\n    }","commit_id":"e5102bcf99d13269e76e3128a61a2d32fe9a4953","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public boolean isDefaultAction() {\n        return defaultAction;\n    }","id":90213,"modified_method":"public boolean isPerformDefaultAction() {\n        return isPerformDefaultAction;\n    }","commit_id":"e5102bcf99d13269e76e3128a61a2d32fe9a4953","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Find an effective object based on either the xxforms:repeat-indexes attribute, or on the current repeat indexes.\n     *\n     * @param propertyContext       current context\n     * @param actionElement         current action element\n     * @param targetStaticId        static id of the target to resolve\n     * @return                      effective control if found\n     */\n    public Object resolveEffectiveControl(PropertyContext propertyContext, Element actionElement, String targetStaticId) {\n\n        final XBLContainer resolutionScopeContainer = findResolutionScopeContainer(actionElement);\n\n        // Get indexes as space-separated list\n        final String repeatIndexes = resolveAVT(propertyContext, actionElement, XFormsConstants.XXFORMS_REPEAT_INDEXES_QNAME, false);\n        if (StringUtils.isBlank(repeatIndexes)) {\n            // Most common case: resolve effective id based on source and target\n            return resolutionScopeContainer.resolveObjectById(getSourceEffectiveId(), targetStaticId, null);\n        } else {\n            // Extension: effective id is provided through repeat indexes, modify appropriately and directly reach control\n            final Integer[] containerParts = XFormsUtils.getEffectiveIdSuffixParts(resolutionScopeContainer.getEffectiveId());\n            final String[] additionalParts = StringUtils.split(repeatIndexes);\n\n            final String[] parts = new String[containerParts.length + additionalParts.length];\n            for (int i = 0; i < containerParts.length; i++) {\n                parts[i] = Integer.toString(containerParts[i]);\n            }\n            System.arraycopy(additionalParts, 0, parts, containerParts.length, additionalParts.length);\n\n            return xformsControls.getObjectByEffectiveId(container.getFullPrefix() + targetStaticId + XFormsConstants.REPEAT_HIERARCHY_SEPARATOR_1 + StringUtils.join(parts, XFormsConstants.REPEAT_HIERARCHY_SEPARATOR_2));\n        }\n    }","id":90214,"modified_method":"/**\n     * Find an effective object based on either the xxforms:repeat-indexes attribute, or on the current repeat indexes.\n     *\n     * @param propertyContext       current context\n     * @param actionElement         current action element\n     * @param targetStaticId        static id of the target to resolve\n     * @return                      effective control if found\n     */\n    public Object resolveEffectiveControl(PropertyContext propertyContext, Element actionElement, String targetStaticId) {\n\n        final XBLContainer resolutionScopeContainer = findResolutionScopeContainer(actionElement);\n\n        // Get indexes as space-separated list\n        final String repeatIndexes = resolveAVT(propertyContext, actionElement, XFormsConstants.XXFORMS_REPEAT_INDEXES_QNAME, false);\n        if (StringUtils.isBlank(repeatIndexes)) {\n            // Most common case: resolve effective id based on source and target\n            return resolutionScopeContainer.resolveObjectById(getSourceEffectiveId(), targetStaticId, null);\n        } else {\n            // Extension: effective id is provided through repeat indexes, modify appropriately and directly reach control\n            final Integer[] containerParts = XFormsUtils.getEffectiveIdSuffixParts(resolutionScopeContainer.getEffectiveId());\n            final String[] additionalParts = StringUtils.split(repeatIndexes);\n\n            final String[] parts = new String[containerParts.length + additionalParts.length];\n            for (int i = 0; i < containerParts.length; i++) {\n                parts[i] = Integer.toString(containerParts[i]);\n            }\n            System.arraycopy(additionalParts, 0, parts, containerParts.length, additionalParts.length);\n\n            return xformsControls.getObjectByEffectiveId(resolutionScopeContainer.getFullPrefix() + targetStaticId + XFormsConstants.REPEAT_HIERARCHY_SEPARATOR_1 + StringUtils.join(parts, XFormsConstants.REPEAT_HIERARCHY_SEPARATOR_2));\n        }\n    }","commit_id":"957f3ab1bc783c1580ed848a211210ca4940b5bf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Resolve a value which may be an AVT.\n     *\n     * @param propertyContext   current context\n     * @param actionElement     action element\n     * @param attributeValue    raw value to resolve\n     * @param isNamespace       whether to namespace the resulting value\n     * @return                  resolved attribute value\n     */\n    public String resolveAVTProvideValue(PropertyContext propertyContext, Element actionElement, String attributeValue, boolean isNamespace) {\n\n        if (attributeValue == null)\n            return null;\n\n        // Whether this can't be an AVT\n        final boolean maybeAvt = attributeValue.indexOf('{') != -1;\n\n        final String resolvedAVTValue;\n        if (maybeAvt) {\n            // We have to go through AVT evaluation\n            final XFormsContextStack.BindingContext bindingContext = actionBlockContextStack.getCurrentBindingContext();\n\n            // We don't have an evaluation context so return\n            // CHECK: In the future we want to allow an empty evaluation context so do we really want this check?\n            if (bindingContext.getSingleNode() == null)\n                return null;\n\n            final Map<String, String> prefixToURIMap = getNamespaceMappings(actionElement);\n            final LocationData locationData = (LocationData) actionElement.getData();\n\n            // Setup function context\n            final XFormsFunction.Context functionContext = actionBlockContextStack.getFunctionContext(getSourceEffectiveId());\n\n            resolvedAVTValue = XFormsUtils.resolveAttributeValueTemplates(propertyContext, bindingContext.getNodeset(),\n                        bindingContext.getPosition(), actionBlockContextStack.getCurrentVariables(), XFormsContainingDocument.getFunctionLibrary(),\n                        functionContext, prefixToURIMap, locationData, attributeValue);\n\n            // Restore function context\n            actionBlockContextStack.returnFunctionContext();\n        } else {\n            // We optimize as this doesn't need AVT evaluation\n            resolvedAVTValue = attributeValue;\n        }\n\n        return isNamespace ? XFormsUtils.namespaceId(containingDocument, resolvedAVTValue) : resolvedAVTValue;\n    }","id":90215,"modified_method":"/**\n     * Resolve a value which may be an AVT.\n     *\n     * @param propertyContext   current context\n     * @param actionElement     action element\n     * @param attributeValue    raw value to resolve\n     * @param isNamespace       whether to namespace the resulting value\n     * @return                  resolved attribute value\n     */\n    public String resolveAVTProvideValue(PropertyContext propertyContext, Element actionElement, String attributeValue, boolean isNamespace) {\n\n        if (attributeValue == null)\n            return null;\n\n        // Whether this can't be an AVT\n        final boolean maybeAvt = attributeValue.indexOf('{') != -1;\n\n        final String resolvedAVTValue;\n        if (maybeAvt) {\n            // We have to go through AVT evaluation\n            final XFormsContextStack.BindingContext bindingContext = actionBlockContextStack.getCurrentBindingContext();\n\n            // We don't have an evaluation context so return\n            // CHECK: In the future we want to allow an empty evaluation context so do we really want this check?\n            if (bindingContext.getSingleItem() == null)\n                return null;\n\n            final Map<String, String> prefixToURIMap = getNamespaceMappings(actionElement);\n            final LocationData locationData = (LocationData) actionElement.getData();\n\n            // Setup function context\n            final XFormsFunction.Context functionContext = actionBlockContextStack.getFunctionContext(getSourceEffectiveId());\n\n            resolvedAVTValue = XFormsUtils.resolveAttributeValueTemplates(propertyContext, bindingContext.getNodeset(),\n                        bindingContext.getPosition(), actionBlockContextStack.getCurrentVariables(), XFormsContainingDocument.getFunctionLibrary(),\n                        functionContext, prefixToURIMap, locationData, attributeValue);\n\n            // Restore function context\n            actionBlockContextStack.returnFunctionContext();\n        } else {\n            // We optimize as this doesn't need AVT evaluation\n            resolvedAVTValue = attributeValue;\n        }\n\n        return isNamespace ? XFormsUtils.namespaceId(containingDocument, resolvedAVTValue) : resolvedAVTValue;\n    }","commit_id":"957f3ab1bc783c1580ed848a211210ca4940b5bf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PropertyContext propertyContext, String targetId,\n                        XFormsEventObserver eventObserver, Element actionElement,\n                        XBLBindings.Scope actionScope, boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n        final String controlIdAttributeValue = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"control\"));\n        if (controlIdAttributeValue == null)\n            throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n\n        final String resolvedControlStaticId;\n        {\n            // Resolve AVT\n            resolvedControlStaticId = actionInterpreter.resolveAVTProvideValue(propertyContext, actionElement, controlIdAttributeValue, true);\n            if (resolvedControlStaticId == null)\n                return;\n        }\n\n        final Object controlObject = actionInterpreter.resolveEffectiveControl(propertyContext, actionElement, resolvedControlStaticId);\n        if (controlObject instanceof XFormsControl) {\n            // Dispatch event to control object\n            containingDocument.dispatchEvent(propertyContext, new XFormsFocusEvent(containingDocument, (XFormsEventTarget) controlObject));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            final IndentedLogger indentedLogger = actionInterpreter.getIndentedLogger();\n            if (indentedLogger.isDebugEnabled())\n                indentedLogger.logDebug(\"xforms:setfocus\", \"control does not refer to an existing control element, ignoring action\",\n                        \"control id\", resolvedControlStaticId);\n        }\n    }","id":90216,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PropertyContext propertyContext, String targetId,\n                        XFormsEventObserver eventObserver, Element actionElement,\n                        XBLBindings.Scope actionScope, boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n\n        final String controlIdAttributeValue = actionElement.attributeValue(\"control\");\n        if (controlIdAttributeValue == null)\n            throw new OXFException(\"Missing mandatory 'control' attribute on xforms:control element.\");\n\n        final String resolvedControlStaticId;\n        {\n            // Resolve AVT\n            resolvedControlStaticId = actionInterpreter.resolveAVTProvideValue(propertyContext, actionElement, controlIdAttributeValue, true);\n            if (resolvedControlStaticId == null)\n                return;\n        }\n\n        final Object controlObject = actionInterpreter.resolveEffectiveControl(propertyContext, actionElement, resolvedControlStaticId);\n        if (controlObject instanceof XFormsControl) {\n            // Dispatch event to control object\n            containingDocument.dispatchEvent(propertyContext, new XFormsFocusEvent(containingDocument, (XFormsEventTarget) controlObject));\n        } else {\n            // \"If there is a null search result for the target object and the source object is an XForms action such as\n            // dispatch, send, setfocus, setindex or toggle, then the action is terminated with no effect.\"\n            final IndentedLogger indentedLogger = actionInterpreter.getIndentedLogger();\n            if (indentedLogger.isDebugEnabled())\n                indentedLogger.logDebug(\"xforms:setfocus\", \"control does not refer to an existing control element, ignoring action\",\n                        \"control id\", resolvedControlStaticId);\n        }\n    }","commit_id":"957f3ab1bc783c1580ed848a211210ca4940b5bf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void execute(XFormsActionInterpreter actionInterpreter, PropertyContext propertyContext, String targetId,\n                        XFormsEventObserver eventObserver, Element actionElement,\n                        XBLBindings.Scope actionScope, boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsContainingDocument containingDocument = actionInterpreter.getContainingDocument();\n        final XFormsContextStack contextStack = actionInterpreter.getContextStack();\n\n        final String repeatId = XFormsUtils.namespaceId(containingDocument, actionElement.attributeValue(\"repeat\"));\n        final String indexXPath = actionElement.attributeValue(\"index\");\n\n        final NodeInfo currentSingleNode = actionInterpreter.getContextStack().getCurrentSingleNode();\n        if (currentSingleNode == null)\n            return;\n\n        // Determine index\n        final String indexString = actionInterpreter.evaluateStringExpression(propertyContext, actionElement,\n                contextStack.getCurrentNodeset(), contextStack.getCurrentPosition(), \"number(\" + indexXPath + \")\");\n\n        actionInterpreter.getIndentedLogger().logDebug(\"xforms:setindex\", \"setting index\", \"index\", indexString);\n\n        // Execute\n        executeSetindexAction(actionInterpreter, propertyContext, eventObserver, actionElement, repeatId, indexString);\n    }","id":90217,"modified_method":"public void execute(XFormsActionInterpreter actionInterpreter, PropertyContext propertyContext, String targetId,\n                        XFormsEventObserver eventObserver, Element actionElement,\n                        XBLBindings.Scope actionScope, boolean hasOverriddenContext, Item overriddenContext) {\n\n        final XFormsContextStack contextStack = actionInterpreter.getContextStack();\n\n        // Check presence of attribute\n        final String repeatAttribute = actionElement.attributeValue(\"repeat\");\n        if (repeatAttribute == null)\n            throw new OXFException(\"Missing mandatory 'repeat' attribute on xforms:setindex element.\");\n\n        // Can't evaluate index XPath if no context\n        final Item currentSingleNode = actionInterpreter.getContextStack().getCurrentSingleItem();\n        if (currentSingleNode == null)\n            return;\n\n        // Get repeat static id\n        final String repeatStaticId = actionInterpreter.resolveAVTProvideValue(propertyContext, actionElement, repeatAttribute, true);\n\n        // Determine index\n        final String indexXPath = actionElement.attributeValue(\"index\");\n        final String indexString = actionInterpreter.evaluateStringExpression(propertyContext, actionElement,\n                contextStack.getCurrentNodeset(), contextStack.getCurrentPosition(), \"number(\" + indexXPath + \")\");\n\n        actionInterpreter.getIndentedLogger().logDebug(\"xforms:setindex\", \"setting index\", \"index\", indexString);\n\n        // Execute\n        executeSetindexAction(actionInterpreter, propertyContext, eventObserver, actionElement, repeatStaticId, indexString);\n    }","commit_id":"957f3ab1bc783c1580ed848a211210ca4940b5bf","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void rewriteModule()\n        throws MojoExecutionException\n    {\n        File moduleFile = new File( project.getBasedir(), project.getArtifactId() + \".iml\" );\n        try\n        {\n            Document document = readXmlDocument( moduleFile, \"module.xml\" );\n\n            Element module = document.getRootElement();\n\n            // TODO: how can we let the WAR/EJBs plugin hook in and provide this?\n            // TODO: merge in ejb-module, etc.\n            if ( \"war\".equals( project.getPackaging() ) )\n            {\n                addWebModule( module );\n            }\n            else if ( \"ejb\".equals( project.getPackaging() ) )\n            {\n                addEjbModule( module );\n            }\n\n            Element component = findComponent( module, \"NewModuleRootManager\" );\n            Element output = findElement( component, \"output\" );\n            output.addAttribute( \"url\", getModuleFileUrl( project.getBuild().getOutputDirectory() ) );\n\n            Element outputTest = findElement( component, \"output-test\" );\n            outputTest.addAttribute( \"url\", getModuleFileUrl( project.getBuild().getTestOutputDirectory() ) );\n\n            Element content = findElement( component, \"content\" );\n\n            removeOldElements( content, \"sourceFolder\" );\n\n            for ( Iterator i = executedProject.getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String directory = (String) i.next();\n                addSourceFolder( content, directory, false );\n            }\n            for ( Iterator i = executedProject.getTestCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String directory = (String) i.next();\n                addSourceFolder( content, directory, true );\n            }\n\n            List resourceDirectory = new ArrayList();\n            for ( Iterator i = project.getBuild().getResources().iterator(); i.hasNext(); )\n            {\n                Resource resource = (Resource) i.next();\n                resourceDirectory.add( resource.getDirectory() );\n            }\n\n            for ( Iterator i = project.getBuild().getTestResources().iterator(); i.hasNext(); )\n            {\n                Resource resource = (Resource) i.next();\n                String directory = resource.getDirectory();\n                addSourceFolder( content, directory, true );\n            }\n\n            removeOldElements( content, \"excludeFolder\" );\n\n            //For excludeFolder\n            File target = new File( project.getBuild().getDirectory() );\n            File classes = new File( project.getBuild().getOutputDirectory() );\n            File testClasses = new File( project.getBuild().getTestOutputDirectory() );\n\n            List sourceFolders = content.elements( \"sourceFolder\" );\n\n            List filteredExcludes = new ArrayList();\n            filteredExcludes.addAll( getExcludedDirectories( target, filteredExcludes, sourceFolders ) );\n            filteredExcludes.addAll( getExcludedDirectories( classes, filteredExcludes, sourceFolders ) );\n            filteredExcludes.addAll( getExcludedDirectories( testClasses, filteredExcludes, sourceFolders ) );\n\n            if ( exclude != null )\n            {\n                String[] dirs = exclude.split( \"[,\\\\s]+\" );\n                for ( int i = 0; i < dirs.length; i++ )\n                {\n                    File excludedDir = new File( dirs[i] );\n                    filteredExcludes.add( getExcludedDirectories( excludedDir, filteredExcludes, sourceFolders ) );\n                }\n            }\n\n            for ( Iterator i = filteredExcludes.iterator(); i.hasNext(); )\n            {\n                addExcludeFolder( content, i.next().toString() );\n            }\n\n            removeOldDependencies( component );\n\n            List testClasspathElements = project.getTestArtifacts();\n            for ( Iterator i = testClasspathElements.iterator(); i.hasNext(); )\n            {\n                Artifact a = (Artifact) i.next();\n\n                Library library = findLibrary( a );\n                if ( library != null && library.isExclude() )\n                {\n                    continue;\n                }\n\n                String moduleName;\n                if ( useFullNames )\n                {\n                    moduleName = a.getGroupId() + ':' + a.getArtifactId() + ':' + a.getType() + ':' + a.getVersion();\n                }\n                else\n                {\n                    moduleName = a.getArtifactId();\n                }\n\n                Element dep = null;\n\n                for ( Iterator children = component.elementIterator( \"orderEntry\" ); children.hasNext(); )\n                {\n                    Element orderEntry = (Element) children.next();\n\n                    if ( orderEntry.attributeValue( \"type\" ).equals( \"module\" ) )\n                    {\n                        if ( orderEntry.attributeValue( \"module-name\" ).equals( moduleName ) )\n                        {\n                            dep = orderEntry;\n                            break;\n                        }\n                    }\n                    else if ( orderEntry.attributeValue( \"type\" ).equals( \"module-library\" ) )\n                    {\n                        Element lib = orderEntry.element( \"library\" );\n                        if ( lib.attributeValue( \"name\" ).equals( moduleName ) )\n                        {\n                            dep = orderEntry;\n                            break;\n                        }\n                    }\n                }\n\n                if ( dep == null )\n                {\n                    dep = createElement( component, \"orderEntry\" );\n                }\n\n                boolean isIdeaModule = false;\n                if ( linkModules )\n                {\n                    isIdeaModule = isReactorProject( a.getGroupId(), a.getArtifactId() );\n\n                    if ( isIdeaModule )\n                    {\n                        dep.addAttribute( \"type\", \"module\" );\n                        dep.addAttribute( \"module-name\", moduleName );\n                    }\n                }\n\n                if ( a.getFile() != null && !isIdeaModule )\n                {\n                    dep.addAttribute( \"type\", \"module-library\" );\n                    removeOldElements( dep, \"library\" );\n                    dep = createElement( dep, \"library\" );\n                    dep.addAttribute( \"name\", moduleName );\n\n                    Element el = createElement( dep, \"CLASSES\" );\n                    if ( library != null && library.getSplitClasses().length > 0 )\n                    {\n                        String[] libraryClasses = library.getSplitClasses();\n                        for ( int k = 0; k < libraryClasses.length; k++ )\n                        {\n                            String classpath = libraryClasses[k];\n                            extractMacro( classpath );\n                            Element classEl = createElement( el, \"root\" );\n                            classEl.addAttribute( \"url\", classpath );\n                        }\n                    }\n                    else\n                    {\n                        el = createElement( el, \"root\" );\n                        File file = a.getFile();\n                        el.addAttribute( \"url\", \"jar://\" + file.getAbsolutePath().replace( '\\\\', '/' ) + \"!/\" );\n                    }\n\n                    boolean usedSources = false;\n                    if ( library != null && library.getSplitSources().length > 0 )\n                    {\n                        Element sourcesElement = createElement( dep, \"SOURCES\" );\n                        usedSources = true;\n                        String[] sources = library.getSplitSources();\n                        for ( int k = 0; k < sources.length; k++ )\n                        {\n                            String source = sources[k];\n                            extractMacro( source );\n                            Element sourceEl = createElement( sourcesElement, \"root\" );\n                            sourceEl.addAttribute( \"url\", source );\n                        }\n                    }\n\n                    if ( useClassifiers )\n                    {\n                        resolveClassifier( createElement( dep, \"JAVADOC\" ), a, javadocClassifier );\n                        if ( !usedSources )\n                        {\n                            resolveClassifier( createElement( dep, \"SOURCES\" ), a, sourceClassifier );\n                        }\n                    }\n                }\n            }\n\n            for ( Iterator resourceDirs = resourceDirectory.iterator(); resourceDirs.hasNext(); )\n            {\n                String resourceDir = (String) resourceDirs.next();\n\n                getLog().info( \"Adding resource directory: \" + resourceDir );\n\n                addResources( component, resourceDir );\n            }\n\n            writeXmlDocument( moduleFile, document );\n        }\n        catch ( DocumentException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IML file \" + moduleFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IML file \" + moduleFile.getAbsolutePath(), e );\n        }\n    }","id":90218,"modified_method":"public void rewriteModule()\n        throws MojoExecutionException\n    {\n        File moduleFile = new File( project.getBasedir(), project.getArtifactId() + \".iml\" );\n        try\n        {\n            Document document = readXmlDocument( moduleFile, \"module.xml\" );\n\n            Element module = document.getRootElement();\n\n            // TODO: how can we let the WAR/EJBs plugin hook in and provide this?\n            // TODO: merge in ejb-module, etc.\n            if ( \"war\".equals( project.getPackaging() ) )\n            {\n                addWebModule( module );\n            }\n            else if ( \"ejb\".equals( project.getPackaging() ) )\n            {\n                addEjbModule( module );\n            }\n\n            Element component = findComponent( module, \"NewModuleRootManager\" );\n            Element output = findElement( component, \"output\" );\n            output.addAttribute( \"url\", getModuleFileUrl( project.getBuild().getOutputDirectory() ) );\n\n            Element outputTest = findElement( component, \"output-test\" );\n            outputTest.addAttribute( \"url\", getModuleFileUrl( project.getBuild().getTestOutputDirectory() ) );\n\n            Element content = findElement( component, \"content\" );\n\n            removeOldElements( content, \"sourceFolder\" );\n\n            for ( Iterator i = executedProject.getCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String directory = (String) i.next();\n                addSourceFolder( content, directory, false );\n            }\n            for ( Iterator i = executedProject.getTestCompileSourceRoots().iterator(); i.hasNext(); )\n            {\n                String directory = (String) i.next();\n                addSourceFolder( content, directory, true );\n            }\n\n            List resourceDirectory = new ArrayList();\n            for ( Iterator i = project.getBuild().getResources().iterator(); i.hasNext(); )\n            {\n                Resource resource = (Resource) i.next();\n                resourceDirectory.add( resource.getDirectory() );\n            }\n\n            for ( Iterator i = project.getBuild().getTestResources().iterator(); i.hasNext(); )\n            {\n                Resource resource = (Resource) i.next();\n                String directory = resource.getDirectory();\n                addSourceFolder( content, directory, true );\n            }\n\n            removeOldElements( content, \"excludeFolder\" );\n\n            //For excludeFolder\n            File target = new File( project.getBuild().getDirectory() );\n            File classes = new File( project.getBuild().getOutputDirectory() );\n            File testClasses = new File( project.getBuild().getTestOutputDirectory() );\n\n            List sourceFolders = content.elements( \"sourceFolder\" );\n\n            List filteredExcludes = new ArrayList();\n            filteredExcludes.addAll( getExcludedDirectories( target, filteredExcludes, sourceFolders ) );\n            filteredExcludes.addAll( getExcludedDirectories( classes, filteredExcludes, sourceFolders ) );\n            filteredExcludes.addAll( getExcludedDirectories( testClasses, filteredExcludes, sourceFolders ) );\n\n            if ( exclude != null )\n            {\n                String[] dirs = exclude.split( \"[,\\\\s]+\" );\n                for ( int i = 0; i < dirs.length; i++ )\n                {\n                    File excludedDir = new File( dirs[i] );\n                    filteredExcludes.add( getExcludedDirectories( excludedDir, filteredExcludes, sourceFolders ) );\n                }\n            }\n\n            for ( Iterator i = filteredExcludes.iterator(); i.hasNext(); )\n            {\n                addExcludeFolder( content, i.next().toString() );\n            }\n\n            removeOldDependencies( component );\n\n            List testClasspathElements = project.getTestArtifacts();\n            for ( Iterator i = testClasspathElements.iterator(); i.hasNext(); )\n            {\n                Artifact a = (Artifact) i.next();\n\n                Library library = findLibrary( a );\n                if ( library != null && library.isExclude() )\n                {\n                    continue;\n                }\n\n                String moduleName;\n                if ( useFullNames )\n                {\n                    moduleName = a.getGroupId() + ':' + a.getArtifactId() + ':' + a.getType() + ':' + a.getVersion();\n                }\n                else\n                {\n                    moduleName = a.getArtifactId();\n                }\n\n                Element dep = null;\n\n                for ( Iterator children = component.elementIterator( \"orderEntry\" ); children.hasNext(); )\n                {\n                    Element orderEntry = (Element) children.next();\n\n                    if ( orderEntry.attributeValue( \"type\" ).equals( \"module\" ) )\n                    {\n                        if ( orderEntry.attributeValue( \"module-name\" ).equals( moduleName ) )\n                        {\n                            dep = orderEntry;\n                            break;\n                        }\n                    }\n                    else if ( orderEntry.attributeValue( \"type\" ).equals( \"module-library\" ) )\n                    {\n                        Element lib = orderEntry.element( \"library\" );\n                        String name = lib.attributeValue( \"name\" );\n                        if ( name != null )\n                        {\n                            if ( name.equals( moduleName ) )\n                            {\n                                dep = orderEntry;\n                                break;\n                            }\n                        }\n                        else\n                        {\n                            Element classesChild = lib.element( \"CLASSES\" );\n                            if ( classesChild != null )\n                            {\n                                Element rootChild = classesChild.element( \"root\" );\n                                if ( rootChild != null )\n                                {\n                                    String url = getLibraryUrl( a );\n                                    if ( url.equals( rootChild.getText() ) )\n                                    {\n                                        dep = orderEntry;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if ( dep == null )\n                {\n                    dep = createElement( component, \"orderEntry\" );\n                }\n\n                boolean isIdeaModule = false;\n                if ( linkModules )\n                {\n                    isIdeaModule = isReactorProject( a.getGroupId(), a.getArtifactId() );\n\n                    if ( isIdeaModule )\n                    {\n                        dep.addAttribute( \"type\", \"module\" );\n                        dep.addAttribute( \"module-name\", moduleName );\n                    }\n                }\n\n                if ( a.getFile() != null && !isIdeaModule )\n                {\n                    dep.addAttribute( \"type\", \"module-library\" );\n                    removeOldElements( dep, \"library\" );\n                    dep = createElement( dep, \"library\" );\n\n                    Element el = createElement( dep, \"CLASSES\" );\n                    if ( library != null && library.getSplitClasses().length > 0 )\n                    {\n                        dep.addAttribute( \"name\", moduleName );\n                        String[] libraryClasses = library.getSplitClasses();\n                        for ( int k = 0; k < libraryClasses.length; k++ )\n                        {\n                            String classpath = libraryClasses[k];\n                            extractMacro( classpath );\n                            Element classEl = createElement( el, \"root\" );\n                            classEl.addAttribute( \"url\", classpath );\n                        }\n                    }\n                    else\n                    {\n                        createElement( el, \"root\" ).addAttribute( \"url\", getLibraryUrl( a ) );\n                    }\n\n                    boolean usedSources = false;\n                    if ( library != null && library.getSplitSources().length > 0 )\n                    {\n                        Element sourcesElement = createElement( dep, \"SOURCES\" );\n                        usedSources = true;\n                        String[] sources = library.getSplitSources();\n                        for ( int k = 0; k < sources.length; k++ )\n                        {\n                            String source = sources[k];\n                            extractMacro( source );\n                            Element sourceEl = createElement( sourcesElement, \"root\" );\n                            sourceEl.addAttribute( \"url\", source );\n                        }\n                    }\n\n                    if ( useClassifiers )\n                    {\n                        resolveClassifier( createElement( dep, \"JAVADOC\" ), a, javadocClassifier );\n                        if ( !usedSources )\n                        {\n                            resolveClassifier( createElement( dep, \"SOURCES\" ), a, sourceClassifier );\n                        }\n                    }\n                }\n            }\n\n            for ( Iterator resourceDirs = resourceDirectory.iterator(); resourceDirs.hasNext(); )\n            {\n                String resourceDir = (String) resourceDirs.next();\n\n                getLog().info( \"Adding resource directory: \" + resourceDir );\n\n                addResources( component, resourceDir );\n            }\n\n            writeXmlDocument( moduleFile, document );\n        }\n        catch ( DocumentException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IML file \" + moduleFile.getAbsolutePath(), e );\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Error parsing existing IML file \" + moduleFile.getAbsolutePath(), e );\n        }\n    }","commit_id":"aa6d1e5092562681ed1cbb1caaf1a1cc48cf0075","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Adds the Web module to the (.iml) project file.\n     *\n     * @param module Xpp3Dom element\n     */\n    private void addWebModule( Element module )\n    {\n        // TODO: this is bad - reproducing war plugin defaults, etc!\n        //   --> this is where the OGNL out of a plugin would be helpful as we could run package first and\n        //       grab stuff from the mojo\n\n/*\nCan't run this anyway as Xpp3Dom is in both classloaders...\n                Xpp3Dom configuration = project.getGoalConfiguration( \"maven-war-plugin\", \"war\" );\n                String warWebapp = configuration.getChild( \"webappDirectory\" ).getValue();\n                if ( warWebapp == null )\n                {\n                    warWebapp = project.getBuild().getDirectory() + \"/\" + project.getArtifactId();\n                }\n                String warSrc = configuration.getChild( \"warSrc\" ).getValue();\n                if ( warSrc == null )\n                {\n                    warSrc = \"src/main/webapp\";\n                }\n                String webXml = configuration.getChild( \"webXml\" ).getValue();\n                if ( webXml == null )\n                {\n                    webXml = warSrc + \"/WEB-INF/web.xml\";\n                }\n*/\n        String warWebapp = project.getBuild().getDirectory() + \"/\" + project.getArtifactId();\n        String warSrc = \"src/main/webapp\";\n        String webXml = warSrc + \"/WEB-INF/web.xml\";\n\n        module.addAttribute( \"type\", \"J2EE_WEB_MODULE\" );\n\n        Element component = findComponent( module, \"WebModuleBuildComponent\" );\n        Element setting = findSetting( component, \"EXPLODED_URL\" );\n        setting.addAttribute( \"value\", getModuleFileUrl( warWebapp ) );\n\n        component = findComponent( module, \"WebModuleProperties\" );\n\n        removeOldElements( component, \"containerElement\" );\n        List artifacts = project.getTestArtifacts();\n        for ( Iterator i = artifacts.iterator(); i.hasNext(); )\n        {\n            Artifact artifact = (Artifact) i.next();\n\n            Element containerElement = createElement( component, \"containerElement\" );\n\n            boolean linkAsModule = false;\n            if ( linkModules )\n            {\n                linkAsModule = isReactorProject( artifact.getGroupId(), artifact.getArtifactId() );\n            }\n\n            if ( linkAsModule )\n            {\n                containerElement.addAttribute( \"type\", \"module\" );\n                containerElement.addAttribute( \"name\", artifact.getArtifactId() );\n                Element methodAttribute = createElement( containerElement, \"attribute\" );\n                methodAttribute.addAttribute( \"name\", \"method\" );\n                methodAttribute.addAttribute( \"value\", \"5\" );\n                Element uriAttribute = createElement( containerElement, \"attribute\" );\n                uriAttribute.addAttribute( \"name\", \"URI\" );\n                uriAttribute.addAttribute( \"value\", \"/WEB-INF/classes\" );\n            }\n            else if ( artifact.getFile() != null )\n            {\n                containerElement.addAttribute( \"type\", \"library\" );\n                containerElement.addAttribute( \"level\", \"module\" );\n                containerElement.addAttribute( \"name\", artifact.getArtifactId() );\n                Element methodAttribute = createElement( containerElement, \"attribute\" );\n                methodAttribute.addAttribute( \"name\", \"method\" );\n                methodAttribute.addAttribute( \"value\", \"1\" ); // IntelliJ 5.0.2 is bugged and doesn't read it\n                Element uriAttribute = createElement( containerElement, \"attribute\" );\n                uriAttribute.addAttribute( \"name\", \"URI\" );\n                uriAttribute.addAttribute( \"value\", \"/WEB-INF/lib/\" + artifact.getFile().getName() );\n            }\n        }\n\n        Element element = findElement( component, \"deploymentDescriptor\" );\n        if ( element.attributeValue( \"version\" ) == null )\n        {\n            // TODO: should derive from web.xml - does IDEA do this if omitted?\n//                    element.setAttribute( \"version\", \"2.3\" );\n        }\n        if ( element.attributeValue( \"name\" ) == null )\n        {\n            element.addAttribute( \"name\", \"web.xml\" );\n        }\n\n        element.addAttribute( \"url\", getModuleFileUrl( webXml ) );\n\n        element = findElement( component, \"webroots\" );\n        removeOldElements( element, \"root\" );\n\n        element = createElement( element, \"root\" );\n        element.addAttribute( \"relative\", \"/\" );\n        element.addAttribute( \"url\", getModuleFileUrl( warSrc ) );\n    }","id":90219,"modified_method":"/**\n     * Adds the Web module to the (.iml) project file.\n     *\n     * @param module Xpp3Dom element\n     */\n    private void addWebModule( Element module )\n    {\n        // TODO: this is bad - reproducing war plugin defaults, etc!\n        //   --> this is where the OGNL out of a plugin would be helpful as we could run package first and\n        //       grab stuff from the mojo\n\n/*\nCan't run this anyway as Xpp3Dom is in both classloaders...\n                Xpp3Dom configuration = project.getGoalConfiguration( \"maven-war-plugin\", \"war\" );\n                String warWebapp = configuration.getChild( \"webappDirectory\" ).getValue();\n                if ( warWebapp == null )\n                {\n                    warWebapp = project.getBuild().getDirectory() + \"/\" + project.getArtifactId();\n                }\n                String warSrc = configuration.getChild( \"warSrc\" ).getValue();\n                if ( warSrc == null )\n                {\n                    warSrc = \"src/main/webapp\";\n                }\n                String webXml = configuration.getChild( \"webXml\" ).getValue();\n                if ( webXml == null )\n                {\n                    webXml = warSrc + \"/WEB-INF/web.xml\";\n                }\n*/\n        String warWebapp = project.getBuild().getDirectory() + \"/\" + project.getArtifactId();\n        String warSrc = \"src/main/webapp\";\n        String webXml = warSrc + \"/WEB-INF/web.xml\";\n\n        module.addAttribute( \"type\", \"J2EE_WEB_MODULE\" );\n\n        Element component = findComponent( module, \"WebModuleBuildComponent\" );\n        Element setting = findSetting( component, \"EXPLODED_URL\" );\n        setting.addAttribute( \"value\", getModuleFileUrl( warWebapp ) );\n\n        component = findComponent( module, \"WebModuleProperties\" );\n\n        removeOldElements( component, \"containerElement\" );\n        List artifacts = project.getTestArtifacts();\n        for ( Iterator i = artifacts.iterator(); i.hasNext(); )\n        {\n            Artifact artifact = (Artifact) i.next();\n\n            Element containerElement = createElement( component, \"containerElement\" );\n\n            boolean linkAsModule = false;\n            if ( linkModules )\n            {\n                linkAsModule = isReactorProject( artifact.getGroupId(), artifact.getArtifactId() );\n            }\n\n            if ( linkAsModule )\n            {\n                containerElement.addAttribute( \"type\", \"module\" );\n                containerElement.addAttribute( \"name\", artifact.getArtifactId() );\n                Element methodAttribute = createElement( containerElement, \"attribute\" );\n                methodAttribute.addAttribute( \"name\", \"method\" );\n                methodAttribute.addAttribute( \"value\", \"5\" );\n                Element uriAttribute = createElement( containerElement, \"attribute\" );\n                uriAttribute.addAttribute( \"name\", \"URI\" );\n                uriAttribute.addAttribute( \"value\", \"/WEB-INF/classes\" );\n            }\n            else if ( artifact.getFile() != null )\n            {\n                containerElement.addAttribute( \"type\", \"library\" );\n                containerElement.addAttribute( \"level\", \"module\" );\n                Element methodAttribute = createElement( containerElement, \"attribute\" );\n                methodAttribute.addAttribute( \"name\", \"method\" );\n                methodAttribute.addAttribute( \"value\", \"1\" ); // IntelliJ 5.0.2 is bugged and doesn't read it\n                Element uriAttribute = createElement( containerElement, \"attribute\" );\n                uriAttribute.addAttribute( \"name\", \"URI\" );\n                uriAttribute.addAttribute( \"value\", \"/WEB-INF/lib/\" + artifact.getFile().getName() );\n                Element url = createElement( containerElement, \"url\" );\n                url.setText( getLibraryUrl( artifact ) );\n            }\n        }\n\n        Element element = findElement( component, \"deploymentDescriptor\" );\n        if ( element.attributeValue( \"version\" ) == null )\n        {\n            // TODO: should derive from web.xml - does IDEA do this if omitted?\n//                    element.setAttribute( \"version\", \"2.3\" );\n        }\n        if ( element.attributeValue( \"name\" ) == null )\n        {\n            element.addAttribute( \"name\", \"web.xml\" );\n        }\n\n        element.addAttribute( \"url\", getModuleFileUrl( webXml ) );\n\n        element = findElement( component, \"webroots\" );\n        removeOldElements( element, \"root\" );\n\n        element = createElement( element, \"root\" );\n        element.addAttribute( \"relative\", \"/\" );\n        element.addAttribute( \"url\", getModuleFileUrl( warSrc ) );\n    }","commit_id":"aa6d1e5092562681ed1cbb1caaf1a1cc48cf0075","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void loadSchemasIfNeeded(PipelineContext pipelineContext) {\n        final Element modelElement = modelDocument.getRootElement();\n        // Create Schema validator only if we have schemas specified\n        if (modelElement.attributeValue(\"schema\") != null && schemaValidator == null) {\n            if (!XFormsProperties.isSkipSchemaValidation(containingDocument)) {\n                schemaValidator = new XFormsModelSchemaValidator(modelElement);\n                schemaValidator.loadSchemas(pipelineContext);\n            }\n        }\n    }","id":90220,"modified_method":"private void loadSchemasIfNeeded(PipelineContext pipelineContext) {\n        final Element modelElement = modelDocument.getRootElement();\n        if (schemaValidator == null) {\n            if (!XFormsProperties.isSkipSchemaValidation(containingDocument)) {\n                schemaValidator = new XFormsModelSchemaValidator(modelElement);\n                schemaValidator.loadSchemas(pipelineContext);\n            }\n        }\n    }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public String getSchemaURI() {\n        if (schemaValidator != null) {\n            return schemaValidator.getSchemaURIs();\n        } else {\n            return null;\n        }\n    }","id":90221,"modified_method":"public String[] getSchemaURIs() {\n        if (schemaValidator != null) {\n            return schemaValidator.getSchemaURIs();\n        } else {\n            return null;\n        }\n    }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"boolean includesUpToDate() {\n            boolean ret = true;\n            final int size = includes.size();\n            for (int i = 0; ret && i < size; i++) {\n                final URL u = (URL) includes.get(i);\n                try {\n                    final Long crntTim = NetUtils.getLastModifiedAsLong(u);\n                    final Long lstTim = (Long) modTimes.get(i);\n                    ret = crntTim.equals(lstTim);\n                } catch (final java.io.IOException e) {\n                    // We won't propagate here.  Reason is that while an include may be missing\n                    // it may just be the case that it isn't included anymore _and_ it has been\n                    // removed.  So, we return false and then on a reparse we will find out the\n                    // truth.\n                    ret = false;\n                }\n            }\n            return ret;\n        }","id":90222,"modified_method":"boolean includesUpToDate() {\n            boolean ret = true;\n            final int size = includes.size();\n            for (int i = 0; ret && i < size; i++) {\n                final URL url = (URL) includes.get(i);\n                try {\n                    final Long lastModified = NetUtils.getLastModifiedAsLong(url);\n                    final Long lastTime = (Long) modTimes.get(i);\n                    ret = lastModified.equals(lastTime);\n                } catch (final IOException e) {\n                    // We won't propagate here. Reason is that while an include may be missing it may just be the case\n                    // that it isn't included anymore _and_ it has been removed. So, we return false and then on a\n                    // reparse we will find out the truth.\n                    ret = false;\n                }\n            }\n            return ret;\n        }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"void setGrammar(final Grammar g) {\n            grammar = g;\n        }","id":90223,"modified_method":"void setGrammar(final Grammar grammar) {\n            this.grammar = grammar;\n        }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public InputSource resolveEntity(final String pid, final String sid)\n                throws SAXException, IOException {\n            final java.net.URL u = URLFactory.createURL(baseURI, sid);\n            schemaInfo.addInclude(u);\n\n            final String surl = u.toString();\n            return XMLUtils.ENTITY_RESOLVER.resolveEntity(\"\", surl);\n        }","id":90224,"modified_method":"public InputSource resolveEntity(final String pid, final String sid) throws SAXException, IOException {\n            final URL url = URLFactory.createURL(baseURI, sid);\n            schemaInfo.addInclude(url);\n\n            final String urlString = url.toString();\n            return XMLUtils.ENTITY_RESOLVER.resolveEntity(\"\", urlString);\n        }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Return the value of the @schema attribute on the model.\n     *\n     * @return  value of the @schema attribute on the model\n     */\n    public String getSchemaURIs() {\n        return schemaURIs;\n    }","id":90225,"modified_method":"/**\n     * Return the schema URIs specified on the model.\n     *\n     * @return  array of schema URIs specified on the model, or null if none\n     */\n    public String[] getSchemaURIs() {\n        return schemaURIs;\n    }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public XFormsModelSchemaValidator(Element modelElement) {\n        this.modelElement = modelElement;\n        this.schemaURIs = XFormsUtils.encodeHRRI(modelElement.attributeValue(\"schema\"), false);\n    }","id":90226,"modified_method":"public XFormsModelSchemaValidator(Element modelElement) {\n        this.modelElement = modelElement;\n\n        // Check for external schemas\n        final String schemaAttribute = modelElement.attributeValue(\"schema\");\n        if (schemaAttribute != null)\n            this.schemaURIs = StringUtils.split(XFormsUtils.encodeHRRI(schemaAttribute, false));\n\n        // Check for inline schemas\n        // \"3.3.1 The model Element [...] xs:schema elements located inside the current model need not be listed.\"\n        for (Iterator i = modelElement.elements(XMLConstants.XML_SCHEMA_QNAME).iterator(); i.hasNext(); ) {\n            final Element currentSchemaElement = (Element) i.next();\n\n            if (schemaElements == null)\n                schemaElements = new ArrayList();\n\n            schemaElements.add(currentSchemaElement);\n        }\n    }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void error(final Locator[] locs, final String msg, final Exception ex) {\n            final LocationData ld = locs.length > 0 ? new LocationData(locs[0]) : null;\n            throw new ValidationException(msg, ex, ld);\n        }","id":90227,"modified_method":"public void error(final Locator[] locators, final String message, final Exception exception) {\n            final LocationData locationData = locators.length > 0 ? new LocationData(locators[0]) : null;\n            throw new ValidationException(message, exception, locationData);\n        }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Load XForms model schemas.\n     *\n     * @param pipelineContext       current PipelineContext\n     */\n    public void loadSchemas(final PipelineContext pipelineContext) {\n\n        final String schemaURI = schemaURIs;// TODO: check for multiple schemas\n\n        // External instance\n        final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n        // Resolve URL\n        // TODO: We do not support \"optimized\" access here, we always use an URL, because loadGrammar() wants a URL\n        final String resolvedURLString = XFormsUtils.resolveResourceURL(pipelineContext, modelElement, schemaURI);\n        final URL resolvedURL = XFormsSubmissionUtils.createAbsoluteURL(resolvedURLString, null, externalContext);\n\n        // Load associated grammar\n        schemaGrammar = loadCacheGrammar(pipelineContext, resolvedURL.toExternalForm());\n    }","id":90228,"modified_method":"/**\n     * Load XForms model schemas.\n     *\n     * @param pipelineContext       current PipelineContext\n     */\n    public void loadSchemas(final PipelineContext pipelineContext) {\n\n        // Check for external schemas\n        if (schemaURIs != null && schemaURIs.length > 0) {\n            // External context\n            final ExternalContext externalContext = (ExternalContext) pipelineContext.getAttribute(PipelineContext.EXTERNAL_CONTEXT);\n\n            // Resolve URL\n            // NOTE: We do not support \"optimized\" access here, we always use an URL, because loadGrammar() wants a URL\n            final String resolvedURLString = XFormsUtils.resolveResourceURL(pipelineContext, modelElement, schemaURIs[0]);\n            final URL resolvedURL = XFormsSubmissionUtils.createAbsoluteURL(resolvedURLString, null, externalContext);\n\n            // Load associated grammar\n            schemaGrammar = loadCacheGrammar(pipelineContext, resolvedURL.toExternalForm());\n        }\n\n        // Check for inline schemas\n        if (schemaElements != null && schemaElements.size() > 0) {\n            schemaGrammar = loadInlineGrammar(null, (Element) schemaElements.get(0)); // TODO: specify baseURI\n        }\n    }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"void addInclude(final URL u) throws java.io.IOException {\n            // Get the time first.  This way if there's a problem the array lengths will remain\n            // the same.\n            final Long modTim = NetUtils.getLastModifiedAsLong(u);\n            includes.add(u);\n            modTimes.add(modTim);\n        }","id":90229,"modified_method":"void addInclude(final URL url) throws IOException {\n            // Get the time first. This way if there's a problem the array lengths will remain the same.\n            final Long lastModified = NetUtils.getLastModifiedAsLong(url);\n            includes.add(url);\n            modTimes.add(lastModified);\n        }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public void warning(final Locator[] locs, final String msg) {\n            if (locs == null && locs.length == 0) {\n                logger.warn(msg);\n            } else {\n                final String frst = XMLUtils.toString(locs[0]);\n                final StringBuffer sb = new StringBuffer(frst);\n                for (int i = 1; i < locs.length; i++) {\n                    sb.append(',');\n                    final String locMsg = XMLUtils.toString(locs[i]);\n                    sb.append(locMsg);\n                }\n                sb.append(':');\n                sb.append(msg);\n                final String logMsg = sb.toString();\n                logger.warn(logMsg);\n            }\n        }","id":90230,"modified_method":"public void warning(final Locator[] locators, final String message) {\n            if (locators == null && locators.length == 0) {\n                logger.warn(message);\n            } else {\n                final String first = XMLUtils.toString(locators[0]);\n                final StringBuffer sb = new StringBuffer(first);\n                for (int i = 1; i < locators.length; i++) {\n                    sb.append(',');\n                    final String locMsg = XMLUtils.toString(locators[i]);\n                    sb.append(locMsg);\n                }\n                sb.append(':');\n                sb.append(message);\n                final String logMessage = sb.toString();\n                logger.warn(logMessage);\n            }\n        }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private void setCachingDependencies(XFormsContainingDocument containingDocument, InputDependencies inputDependencies) {\n\n        // If a submission took place during XForms initialization, we currently don't cache\n        // TODO: Some cases could be easily handled, like GET\n        if (containingDocument.isGotSubmission()) {\n            if (logger.isDebugEnabled())\n                logger.debug(\"XForms - submission occurred during XForms initialization, disabling caching of output.\");\n            inputDependencies.setNoCache();\n            return;\n        }\n\n        // Set caching dependencies if the input was actually read\n        for (Iterator i = containingDocument.getModels().iterator(); i.hasNext();) {\n            final XFormsModel currentModel = (XFormsModel) i.next();\n\n            // Add schema dependencies\n            final String schemaURI = currentModel.getSchemaURI();\n            if (schemaURI != null) {\n                if (logger.isDebugEnabled())\n                    logger.debug(\"XForms - adding document cache dependency for schema: \" + schemaURI);\n                inputDependencies.addReference(null, schemaURI, null, null);// TODO: support username / password on schema refs\n            }\n\n            // Add instance source dependencies\n            if (currentModel.getInstances() != null) {\n                for (Iterator j = currentModel.getInstances().iterator(); j.hasNext();) {\n                    final XFormsInstance currentInstance = (XFormsInstance) j.next();\n                    final String instanceSourceURI = currentInstance.getSourceURI();\n\n                    if (instanceSourceURI != null) {\n                        if (!currentInstance.isApplicationShared()) {\n                            // Add dependency only for instances that are not globally shared\n                            if (logger.isDebugEnabled())\n                                logger.debug(\"XForms - adding document cache dependency for instance: \" + instanceSourceURI);\n                            inputDependencies.addReference(null, instanceSourceURI, currentInstance.getUsername(), currentInstance.getPassword());\n                        } else {\n                            // Don't add the dependency as we don't want the instance URI to be hit\n                            // For all practical purposes, globally shared instances must remain constant!\n                            if (logger.isDebugEnabled())\n                                logger.debug(\"XForms - not adding document cache dependency for application shared instance: \" + instanceSourceURI);\n                        }\n                    }\n                }\n            }\n\n            // TODO: Add @src attributes from controls?\n        }\n    }","id":90231,"modified_method":"private void setCachingDependencies(XFormsContainingDocument containingDocument, InputDependencies inputDependencies) {\n\n        // If a submission took place during XForms initialization, we currently don't cache\n        // TODO: Some cases could be easily handled, like GET\n        if (containingDocument.isGotSubmission()) {\n            if (logger.isDebugEnabled())\n                logger.debug(\"XForms - submission occurred during XForms initialization, disabling caching of output.\");\n            inputDependencies.setNoCache();\n            return;\n        }\n\n        // Set caching dependencies if the input was actually read\n        for (Iterator i = containingDocument.getModels().iterator(); i.hasNext();) {\n            final XFormsModel currentModel = (XFormsModel) i.next();\n\n            // Add schema dependencies\n            final String[] schemaURIs = currentModel.getSchemaURIs();\n            // TODO: We should also use dependencies computed in XFormsModelSchemaValidator.SchemaInfo\n            if (schemaURIs != null) {\n                for (int j = 0; j < schemaURIs.length; j++) {\n                    final String currentSchemaURI = schemaURIs[j];\n                    if (logger.isDebugEnabled())\n                        logger.debug(\"XForms - adding document cache dependency for schema: \" + currentSchemaURI);\n                    inputDependencies.addReference(null, currentSchemaURI, null, null);// TODO: support username / password on schema refs\n                }\n            }\n\n            // Add instance source dependencies\n            if (currentModel.getInstances() != null) {\n                for (Iterator j = currentModel.getInstances().iterator(); j.hasNext();) {\n                    final XFormsInstance currentInstance = (XFormsInstance) j.next();\n                    final String instanceSourceURI = currentInstance.getSourceURI();\n\n                    if (instanceSourceURI != null) {\n                        if (!currentInstance.isApplicationShared()) {\n                            // Add dependency only for instances that are not globally shared\n                            if (logger.isDebugEnabled())\n                                logger.debug(\"XForms - adding document cache dependency for instance: \" + instanceSourceURI);\n                            inputDependencies.addReference(null, instanceSourceURI, currentInstance.getUsername(), currentInstance.getPassword());\n                        } else {\n                            // Don't add the dependency as we don't want the instance URI to be hit\n                            // For all practical purposes, globally shared instances must remain constant!\n                            if (logger.isDebugEnabled())\n                                logger.debug(\"XForms - not adding document cache dependency for application shared instance: \" + instanceSourceURI);\n                        }\n                    }\n                }\n            }\n\n            // TODO: Add @src attributes from controls?\n        }\n    }","commit_id":"74f01bfadf9db0ea913a21bede140a67f74a80ca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public String calculateCurrentStatus(OnmsLocationMonitor monitor,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        Set<PollStatus> pollStatuses = new HashSet<PollStatus>();\n        \n        for (OnmsMonitoredService service : applicationServices) {\n            boolean foundIt = false;\n            for (OnmsLocationSpecificStatus status : statuses) {\n                if (status.getMonitoredService().equals(service)\n                        && status.getLocationMonitor().equals(monitor)) {\n                    pollStatuses.add(status.getPollResult());\n                    foundIt = true;\n                    break;\n                }\n            }\n            if (!foundIt) {\n                pollStatuses.add(PollStatus.unknown());\n            }\n        }\n        \n        return calculateStatus(pollStatuses);\n    }","id":90232,"modified_method":"public Severity calculateCurrentStatus(OnmsLocationMonitor monitor,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        Set<PollStatus> pollStatuses = new HashSet<PollStatus>();\n        \n        for (OnmsMonitoredService service : applicationServices) {\n            boolean foundIt = false;\n            for (OnmsLocationSpecificStatus status : statuses) {\n                if (status.getMonitoredService().equals(service) && status.getLocationMonitor().equals(monitor)) {\n                    pollStatuses.add(status.getPollResult());\n                    foundIt = true;\n                    break;\n                }\n            }\n            if (!foundIt) {\n                pollStatuses.add(PollStatus.unknown(\"No status found for this service\"));\n                if (log().isDebugEnabled()) {\n                    log().debug(\"Did not find status for service \" + service + \" in application.  Setting status for it to unknown.\");\n                }\n            }\n        }\n        \n        return calculateStatus(pollStatuses);\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Calculate the percentage of time that all services are up for this\n     * application on this remote monitor.\n     * \n     * @param applicationServices services to report on\n     * @param statuses status entries to use for report\n     * @param startDate start date.  The report starts on this date.\n     * @param endDate end date.  The report ends the last millisecond prior\n     * this date.\n     * @return representation of the percentage uptime out to three decimal\n     * places.  Null is returned if there is no data.\n     */\n    public String calculatePercentageUptime(\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses,\n            Date startDate, Date endDate) {\n        /*\n         * The methodology is as such:\n         * 1) Sort the status entries by their timestamp;\n         * 2) Create a Map of each monitored service with a default\n         *    PollStatus of unknown.\n         * 3) Iterate through the sorted list of status entries until\n         *    we hit a timestamp that is not within our time range or\n         *    run out of entries.\n         *    a) Along the way, update the status Map with the current\n         *       entry's status, and calculate the current status.\n         *    b) If the current timestamp is before the start time, store\n         *       the current status so we can use it once we cross over\n         *       into our time range and then continue.\n         *    c) If the previous status is normal, then count up the number\n         *       of milliseconds since the previous state change entry in\n         *       the time range (or the beginning of the range if this is\n         *       the first entry in within the time range), and add that\n         *       a counter of \"normal\" millseconds.\n         *    d) Finally, save the current date and status for later use.\n         * 4) Perform the same computation in 3c, except count the number\n         *    of milliseconds since the last state change entry (or the\n         *    start time if there were no entries) and the end time, and add\n         *    that to the counter of \"normal\" milliseconds.\n         * 5) Divide the \"normal\" milliseconds counter by the total number\n         *    of milliseconds in our time range and compute and return a\n         *    percentage.\n         */\n\n        List<OnmsLocationSpecificStatus> sortedStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>(statuses);\n        Collections.sort(sortedStatuses, new Comparator<OnmsLocationSpecificStatus>(){\n            public int compare(OnmsLocationSpecificStatus o1, OnmsLocationSpecificStatus o2) {\n                return o1.getPollResult().getTimestamp().compareTo(o2.getPollResult().getTimestamp());\n            }\n        });\n\n        HashMap<OnmsMonitoredService,PollStatus> serviceStatus =\n            new HashMap<OnmsMonitoredService,PollStatus>();\n        for (OnmsMonitoredService service : applicationServices) {\n            serviceStatus.put(service, PollStatus.unknown(\"No history for this service from this location\"));\n        }\n        \n        float normalMilliseconds = 0f;\n        \n        Date lastDate = startDate;\n        String lastStatus = \"Critical\";\n        \n        for (OnmsLocationSpecificStatus status : sortedStatuses) {\n            Date currentDate = status.getPollResult().getTimestamp();\n\n            if (!currentDate.before(endDate)) {\n                // We're at or past the end date, so we're done processing\n                break;\n            }\n            \n            serviceStatus.put(status.getMonitoredService(), status.getPollResult());\n            String currentStatus = calculateStatus(serviceStatus.values());\n            \n            if (currentDate.before(startDate)) {\n                /*\n                 * We're not yet to a date that is inside our time period, so\n                 * we don't need to check the status and adjust the\n                 * normalMilliseconds variable, but we do need to save the\n                 * status so we have an up-to-date status when we cross the\n                 * start date.\n                 */\n                lastStatus = currentStatus;\n                continue;\n            }\n            \n            /*\n             * Because we *just* had a state change, we want to look at the\n             * value of the *last* status.\n             */\n            if (\"Normal\".equals(lastStatus)) {\n                long milliseconds = currentDate.getTime() - lastDate.getTime();\n                normalMilliseconds += milliseconds;\n            }\n            \n            lastDate = currentDate;\n            lastStatus = currentStatus;\n        }\n        \n        if (\"Normal\".equals(lastStatus)) {\n            long milliseconds = endDate.getTime() - lastDate.getTime();\n            normalMilliseconds += milliseconds;\n        }\n\n        float percentage = normalMilliseconds /\n            (endDate.getTime() - startDate.getTime()) * 100;\n        return new DecimalFormat(\"0.000\").format((double) percentage) + \"%\";\n    }","id":90233,"modified_method":"/**\n     * Calculate the percentage of time that all services are up for this\n     * application on this remote monitor.\n     * \n     * @param applicationServices services to report on\n     * @param statuses status entries to use for report\n     * @param startDate start date.  The report starts on this date.\n     * @param endDate end date.  The report ends the last millisecond prior\n     * this date.\n     * @return representation of the percentage uptime out to three decimal\n     * places.  Null is returned if there is no data.\n     */\n    public String calculatePercentageUptime(\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses,\n            Date startDate, Date endDate) {\n        /*\n         * The methodology is as such:\n         * 1) Sort the status entries by their timestamp;\n         * 2) Create a Map of each monitored service with a default\n         *    PollStatus of unknown.\n         * 3) Iterate through the sorted list of status entries until\n         *    we hit a timestamp that is not within our time range or\n         *    run out of entries.\n         *    a) Along the way, update the status Map with the current\n         *       entry's status, and calculate the current status.\n         *    b) If the current timestamp is before the start time, store\n         *       the current status so we can use it once we cross over\n         *       into our time range and then continue.\n         *    c) If the previous status is normal, then count up the number\n         *       of milliseconds since the previous state change entry in\n         *       the time range (or the beginning of the range if this is\n         *       the first entry in within the time range), and add that\n         *       a counter of \"normal\" millseconds.\n         *    d) Finally, save the current date and status for later use.\n         * 4) Perform the same computation in 3c, except count the number\n         *    of milliseconds since the last state change entry (or the\n         *    start time if there were no entries) and the end time, and add\n         *    that to the counter of \"normal\" milliseconds.\n         * 5) Divide the \"normal\" milliseconds counter by the total number\n         *    of milliseconds in our time range and compute and return a\n         *    percentage.\n         */\n\n        List<OnmsLocationSpecificStatus> sortedStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>(statuses);\n        Collections.sort(sortedStatuses, new Comparator<OnmsLocationSpecificStatus>(){\n            public int compare(OnmsLocationSpecificStatus o1, OnmsLocationSpecificStatus o2) {\n                return o1.getPollResult().getTimestamp().compareTo(o2.getPollResult().getTimestamp());\n            }\n        });\n\n        HashMap<OnmsMonitoredService,PollStatus> serviceStatus =\n            new HashMap<OnmsMonitoredService,PollStatus>();\n        for (OnmsMonitoredService service : applicationServices) {\n            serviceStatus.put(service, PollStatus.unknown(\"No history for this service from this location\"));\n        }\n        \n        float normalMilliseconds = 0f;\n        \n        Date lastDate = startDate;\n        Severity lastStatus = Severity.CRITICAL;\n        \n        for (OnmsLocationSpecificStatus status : sortedStatuses) {\n            Date currentDate = status.getPollResult().getTimestamp();\n\n            if (!currentDate.before(endDate)) {\n                // We're at or past the end date, so we're done processing\n                break;\n            }\n            \n            serviceStatus.put(status.getMonitoredService(), status.getPollResult());\n            Severity currentStatus = calculateStatus(serviceStatus.values());\n            \n            if (currentDate.before(startDate)) {\n                /*\n                 * We're not yet to a date that is inside our time period, so\n                 * we don't need to check the status and adjust the\n                 * normalMilliseconds variable, but we do need to save the\n                 * status so we have an up-to-date status when we cross the\n                 * start date.\n                 */\n                lastStatus = currentStatus;\n                continue;\n            }\n            \n            /*\n             * Because we *just* had a state change, we want to look at the\n             * value of the *last* status.\n             */\n            if (lastStatus == Severity.NORMAL) {\n                long milliseconds = currentDate.getTime() - lastDate.getTime();\n                normalMilliseconds += milliseconds;\n            }\n            \n            lastDate = currentDate;\n            lastStatus = currentStatus;\n        }\n        \n        if (lastStatus == Severity.NORMAL) {\n            long milliseconds = endDate.getTime() - lastDate.getTime();\n            normalMilliseconds += milliseconds;\n        }\n\n        float percentage = normalMilliseconds /\n            (endDate.getTime() - startDate.getTime()) * 100;\n        return new DecimalFormat(\"0.000\").format((double) percentage) + \"%\";\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String calculateCurrentStatus(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        int goodMonitors = 0;\n        int badMonitors = 0;\n        \n        for (OnmsLocationMonitor monitor : monitors) {\n            if (monitor == null || monitor.getStatus() != MonitorStatus.STARTED) {\n                continue;\n            }\n            \n            String status = calculateCurrentStatus(monitor, applicationServices, statuses);\n            \n            // FIXME: \"Normal\", etc. should be done with static variables\n            if (\"Normal\".equals(status)) {\n                goodMonitors++;\n            } else {\n                badMonitors++;\n            }\n        }\n        \n        if (goodMonitors == 0 && badMonitors == 0) {\n            return \"Indeterminate\"; // No current responses\n        } else if (goodMonitors != 0 && badMonitors == 0) {\n            return \"Normal\"; // No bad responses\n        } else if (goodMonitors == 0 && badMonitors != 0) {\n            return \"Critical\"; // All bad responses\n        } else if (goodMonitors != 0 && badMonitors != 0){\n            return \"Warning\"; // Some bad responses\n        } else {\n            throw new IllegalStateException(\"Shouldn't have gotten here. \"\n                                            + \"good monitors = \"\n                                            + goodMonitors\n                                            + \", bad monitors = \"\n                                            + badMonitors);\n        }\n    }","id":90234,"modified_method":"public Severity calculateCurrentStatus(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        int goodMonitors = 0;\n        int badMonitors = 0;\n        \n        for (OnmsLocationMonitor monitor : monitors) {\n            if (monitor == null || monitor.getStatus() != MonitorStatus.STARTED) {\n                continue;\n            }\n            \n            Severity status = calculateCurrentStatus(monitor, applicationServices, statuses);\n            \n            // FIXME: \"Normal\", etc. should be done with static variables\n            if (status == Severity.NORMAL) {\n                goodMonitors++;\n            } else if (status != Severity.INDETERMINATE) {\n                badMonitors++;\n            }\n        }\n        \n        if (goodMonitors == 0 && badMonitors == 0) {\n            return Severity.INDETERMINATE; // No current responses\n        } else if (goodMonitors != 0 && badMonitors == 0) {\n            return Severity.NORMAL; // No bad responses\n        } else if (goodMonitors == 0 && badMonitors != 0) {\n            return Severity.CRITICAL; // All bad responses\n        } else if (goodMonitors != 0 && badMonitors != 0){\n            return Severity.WARNING; // Some bad responses\n        } else {\n            throw new IllegalStateException(\"Shouldn't have gotten here. \"\n                                            + \"good monitors = \"\n                                            + goodMonitors\n                                            + \", bad monitors = \"\n                                            + badMonitors);\n        }\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String calculateStatus(Collection<PollStatus> pollStatuses) {\n        /*\n         * XXX We aren't doing anything for warning, because we don't\n         * have a warning state available, right now.  Should unknown\n         * be a warning state?\n         */\n        for (PollStatus pollStatus : pollStatuses) {\n            if (!pollStatus.isAvailable()) {\n                return \"Critical\";\n            }\n        }\n        \n        return \"Normal\";\n    }","id":90235,"modified_method":"public Severity calculateStatus(Collection<PollStatus> pollStatuses) {\n        /*\n         * XXX We aren't doing anything for warning, because we don't\n         * have a warning state available, right now.  Should unknown\n         * be a warning state?\n         */\n        \n        int goodStatuses = 0;\n        int badStatuses = 0;\n        \n        for (PollStatus pollStatus : pollStatuses) {\n            if (pollStatus.isAvailable()) {\n                goodStatuses++;\n            } else if (pollStatus.getStatusCode() != PollStatus.SERVICE_UNKNOWN) {\n                badStatuses++;\n            }\n        }\n\n        if (goodStatuses == 0 && badStatuses == 0) {\n            return Severity.INDETERMINATE;\n        } else if (goodStatuses > 0 && badStatuses == 0) {\n            return Severity.NORMAL;\n        } else {\n            return Severity.CRITICAL;\n        }\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SimpleWebTable createFacilityStatusTable(Date start, Date end) {\n        Assert.notNull(start, \"argument start cannot be null\");\n        Assert.notNull(end, \"argument end cannot be null\");\n        if (!start.before(end)) {\n            throw new IllegalArgumentException(\"start date (\" + start + \") must be older than end date (\" + end + \")\");\n        }\n        \n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = m_locationMonitorDao.getAllMostRecentStatusChanges();\n\n        Collection<OnmsLocationSpecificStatus> statusesPeriod = new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(m_locationMonitorDao.getAllStatusChangesAt(start));\n        statusesPeriod.addAll(m_locationMonitorDao.getStatusChangesBetween(start, end));\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n                String status = calculateCurrentStatus(monitors, memberServices, mostRecentStatuses);\n            \n                Set<OnmsLocationSpecificStatus> selectedStatuses = filterStatus(statusesPeriod, monitors, memberServices);\n                \n                if (selectedStatuses.size() > 0) {\n                    String percentage = calculatePercentageUptime(memberServices, selectedStatuses, start, end);\n                    table.addCell(percentage, status, createHistoryPageUrl(locationDefinition, application));\n                } else {\n                    table.addCell(\"No data\", status);\n                }\n            }\n        }\n        \n        if (isLayoutApplicationsVertically()) {\n            SimpleWebTable newTable = new SimpleWebTable();\n            newTable.setErrors(table.getErrors());\n            newTable.setTitle(table.getTitle());\n            \n            newTable.addColumn(\"Application\");\n            for (List<Cell> row : table.getRows()) {\n                // The location is in the second row\n                newTable.addColumn(row.get(1).getContent(), row.get(1).getStyleClass());\n            }\n            \n            for (Cell columnHeader : table.getColumnHeaders().subList(2, table.getColumnHeaders().size())) {\n                // This is the index into collumn list of the old table to get the data for the current application\n                int rowColumnIndex = newTable.getRows().size() + 2;\n                \n                newTable.newRow();\n                newTable.addCell(columnHeader.getContent(), columnHeader.getStyleClass());\n                \n                for (List<Cell> row : table.getRows()) {\n                    newTable.addCell(row.get(rowColumnIndex).getContent(), row.get(rowColumnIndex).getStyleClass(), row.get(rowColumnIndex).getLink());\n                }\n            }\n            \n            return newTable;\n        }\n        \n        return table;\n    }","id":90236,"modified_method":"public SimpleWebTable createFacilityStatusTable(Date start, Date end) {\n        Assert.notNull(start, \"argument start cannot be null\");\n        Assert.notNull(end, \"argument end cannot be null\");\n        if (!start.before(end)) {\n            throw new IllegalArgumentException(\"start date (\" + start + \") must be older than end date (\" + end + \")\");\n        }\n        \n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = m_locationMonitorDao.getAllMostRecentStatusChanges();\n\n        Collection<OnmsLocationSpecificStatus> statusesPeriod = new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(m_locationMonitorDao.getAllStatusChangesAt(start));\n        statusesPeriod.addAll(m_locationMonitorDao.getStatusChangesBetween(start, end));\n\n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors = m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n                Severity status = calculateCurrentStatus(monitors, memberServices, mostRecentStatuses);\n            \n                Set<OnmsLocationSpecificStatus> selectedStatuses = filterStatus(statusesPeriod, monitors, memberServices);\n                \n                if (selectedStatuses.size() > 0) {\n                    String percentage = calculatePercentageUptime(memberServices, selectedStatuses, start, end);\n                    table.addCell(percentage, status.getStyle(), createHistoryPageUrl(locationDefinition, application));\n                } else {\n                    table.addCell(\"No data\", status.getStyle());\n                }\n            }\n        }\n        \n        if (isLayoutApplicationsVertically()) {\n            SimpleWebTable newTable = new SimpleWebTable();\n            newTable.setErrors(table.getErrors());\n            newTable.setTitle(table.getTitle());\n            \n            newTable.addColumn(\"Application\");\n            for (List<Cell> row : table.getRows()) {\n                // The location is in the second row\n                newTable.addColumn(row.get(1).getContent(), row.get(1).getStyleClass());\n            }\n            \n            for (Cell columnHeader : table.getColumnHeaders().subList(2, table.getColumnHeaders().size())) {\n                // This is the index into collumn list of the old table to get the data for the current application\n                int rowColumnIndex = newTable.getRows().size() + 2;\n                \n                newTable.newRow();\n                newTable.addCell(columnHeader.getContent(), columnHeader.getStyleClass());\n                \n                for (List<Cell> row : table.getRows()) {\n                    newTable.addCell(row.get(rowColumnIndex).getContent(), row.get(rowColumnIndex).getStyleClass(), row.get(rowColumnIndex).getLink());\n                }\n            }\n            \n            return newTable;\n        }\n        \n        return table;\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPercentageCalculation() throws ParseException {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        m_easyMockUtils.replayAll();\n        String percentage = m_service.calculatePercentageUptime(m_applicationServices1, statuses,  startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","id":90237,"modified_method":"public void testPercentageCalculationAllAvailableStartInMiddleOfDay() throws ParseException {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        m_easyMockUtils.replayAll();\n        String percentage = m_service.calculatePercentageUptime(m_applicationServices1, statuses,  startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        assertEquals(\"percentage\", \"100.000%\", percentage);\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreateStatusNoLocationMonitor() {\n        // We run five times to catch sorting differences (if we don't sort)\n        for (int i = 0; i < 5; i++) {\n            runTestCreateStatusNoLocationMonitor();\n        }\n    }","id":90238,"modified_method":"public void testCreateStatusNoLocationMonitor() {\n        DistributedStatusDetailsCommand command = new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition3.getName());\n        command.setApplication(m_application2.getName());\n\n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(new HashSet<OnmsLocationMonitor>());\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createStatusTable(command, errors);\n\n        Errors errorsOut = table.getErrors();\n        assertEquals(\"Number of errors\", 1, errorsOut.getErrorCount());\n        assertEquals(\"Number of global errors\", 1, errorsOut.getGlobalErrorCount());\n        assertEquals(\"Number of field errors\", 0, errorsOut.getFieldErrorCount());\n        ObjectError e = (ObjectError) errorsOut.getGlobalErrors().get(0);\n        assertEquals(\"Error code 0\", \"location.no-monitors\", e.getCode());\n        assertEquals(\"Error 0 argument count\", 2, e.getArguments().length);\n        assertEquals(\"Error argument 0.0\", \"Application 2\", e.getArguments()[0]);\n        assertEquals(\"Error argument 0.0\", \"Columbus\", e.getArguments()[1]);\n\n        m_easyMockUtils.verifyAll();\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateFacilityStatusTable() throws Exception {\n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications = new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(new HashSet<OnmsLocationMonitor>());\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","id":90239,"modified_method":"public void testCreateFacilityStatusTableOneApplicationOneOfTwoLocationsReporting() throws Exception {\n        OnmsApplication app = m_application2;\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        \n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061011-00:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061011-00:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(Collections.singletonList(app));\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(Collections.singleton(m_locationMonitor2_1));\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(app)).andReturn(m_applicationServices2).times(2);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(app.getName(), \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"100.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreateFacilityStatusTable() throws Exception {\n        for (int i = 0; i < 5; i++) {\n            runTestCreateFacilityStatusTable();\n        }\n    }","id":90240,"modified_method":"public void testCreateFacilityStatusTable() throws Exception {\n         // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications = new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.unavailable(), \"20061012-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(new HashSet<OnmsLocationMonitor>());\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreateFacilityStatusTableLayoutApplicationsVertically() throws Exception {\n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications = new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(new HashSet<OnmsLocationMonitor>());\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n        \n        m_service.setLayoutApplicationsVertically(true);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Application\", \"\");\n        expectedTable.addColumn(\"Raleigh\", \"\");\n        expectedTable.addColumn(\"Durham\", \"\");\n        expectedTable.addColumn(\"Columbus\", \"\");\n        \n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Application 1\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Application 2\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","id":90241,"modified_method":"public void testCreateFacilityStatusTableLayoutApplicationsVertically() throws Exception {\n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications = new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.unavailable(), \"20061012-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(new HashSet<OnmsLocationMonitor>());\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n        \n        m_service.setLayoutApplicationsVertically(true);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Application\", \"\");\n        expectedTable.addColumn(\"Raleigh\", \"\");\n        expectedTable.addColumn(\"Durham\", \"\");\n        expectedTable.addColumn(\"Columbus\", \"\");\n        \n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Application 1\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Application 2\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"3dfde2de96fee3923003b138c4b76f38692e18f9","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * Calculate the percentage of time that all services are up for this\n     * application on this remote monitor.\n     * \n     * @param applicationServices services to report on\n     * @param statuses status entries to use for report\n     * @param startDate start date.  The report starts on this date.\n     * @param endDate end date.  The report ends the last millisecond prior\n     * this date.\n     * @return representation of the percentage uptime out to three decimal\n     * places.  Null is returned if there is no data.\n     */\n    public String calculatePercentageUptime(\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses,\n            Date startDate, Date endDate) {\n        /*\n         * The methodology is as such:\n         * 1) Sort the status entries by their timestamp;\n         * 2) Create a Map of each monitored service with a default\n         *    PollStatus of unknown.\n         * 3) Iterate through the sorted list of status entries until\n         *    we hit a timestamp that is not within our time range or\n         *    run out of entries.\n         *    a) Along the way, update the status Map with the current\n         *       entry's status, and calculate the current status.\n         *    b) If the current timestamp is before the start time, store\n         *       the current status so we can use it once we cross over\n         *       into our time range and then continue.\n         *    c) If the previous status is normal, then count up the number\n         *       of milliseconds since the previous state change entry in\n         *       the time range (or the beginning of the range if this is\n         *       the first entry in within the time range), and add that\n         *       a counter of \"normal\" millseconds.\n         *    d) Finally, save the current date and status for later use.\n         * 4) Perform the same computation in 3c, except count the number\n         *    of milliseconds since the last state change entry (or the\n         *    start time if there were no entries) and the end time, and add\n         *    that to the counter of \"normal\" milliseconds.\n         * 5) Divide the \"normal\" milliseconds counter by the total number\n         *    of milliseconds in our time range and compute and return a\n         *    percentage.\n         */\n\n        List<OnmsLocationSpecificStatus> sortedStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>(statuses);\n        Collections.sort(sortedStatuses, new Comparator<OnmsLocationSpecificStatus>(){\n            public int compare(OnmsLocationSpecificStatus o1, OnmsLocationSpecificStatus o2) {\n                return o1.getPollResult().getTimestamp().compareTo(o2.getPollResult().getTimestamp());\n            }\n        });\n\n        HashMap<OnmsMonitoredService,PollStatus> serviceStatus =\n            new HashMap<OnmsMonitoredService,PollStatus>();\n        for (OnmsMonitoredService service : applicationServices) {\n            serviceStatus.put(service, PollStatus.unknown(\"No history for this service from this location\"));\n        }\n        \n        float normalMilliseconds = 0f;\n        \n        Date lastDate = startDate;\n        String lastStatus = \"Critical\";\n        \n        for (OnmsLocationSpecificStatus status : sortedStatuses) {\n            Date currentDate = status.getPollResult().getTimestamp();\n\n            if (!currentDate.before(endDate)) {\n                // We're at or past the end date, so we're done processing\n                break;\n            }\n            \n            serviceStatus.put(status.getMonitoredService(), status.getPollResult());\n            String currentStatus = calculateStatus(serviceStatus.values());\n            \n            if (currentDate.before(startDate)) {\n                /*\n                 * We're not yet to a date that is inside our time period, so\n                 * we don't need to check the status and adjust the\n                 * normalMilliseconds variable, but we do need to save the\n                 * status so we have an up-to-date status when we cross the\n                 * start date.\n                 */\n                lastStatus = currentStatus;\n                continue;\n            }\n            \n            /*\n             * Because we *just* had a state change, we want to look at the\n             * value of the *last* status.\n             */\n            if (\"Normal\".equals(lastStatus)) {\n                long milliseconds = currentDate.getTime() - lastDate.getTime();\n                normalMilliseconds += milliseconds;\n            }\n            \n            lastDate = currentDate;\n            lastStatus = currentStatus;\n        }\n        \n        if (\"Normal\".equals(lastStatus)) {\n            long milliseconds = endDate.getTime() - lastDate.getTime();\n            normalMilliseconds += milliseconds;\n        }\n\n        float percentage = normalMilliseconds /\n            (endDate.getTime() - startDate.getTime()) * 100;\n        return new DecimalFormat(\"0.000\").format((double) percentage) + \"%\";\n    }","id":90242,"modified_method":"/**\n     * Calculate the percentage of time that all services are up for this\n     * application on this remote monitor.\n     * \n     * @param applicationServices services to report on\n     * @param statuses status entries to use for report\n     * @param startDate start date.  The report starts on this date.\n     * @param endDate end date.  The report ends the last millisecond prior\n     * this date.\n     * @return representation of the percentage uptime out to three decimal\n     * places.  Null is returned if there is no data.\n     */\n    public String calculatePercentageUptime(\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses,\n            Date startDate, Date endDate) {\n        /*\n         * The methodology is as such:\n         * 1) Sort the status entries by their timestamp;\n         * 2) Create a Map of each monitored service with a default\n         *    PollStatus of unknown.\n         * 3) Iterate through the sorted list of status entries until\n         *    we hit a timestamp that is not within our time range or\n         *    run out of entries.\n         *    a) Along the way, update the status Map with the current\n         *       entry's status, and calculate the current status.\n         *    b) If the current timestamp is before the start time, store\n         *       the current status so we can use it once we cross over\n         *       into our time range and then continue.\n         *    c) If the previous status is normal, then count up the number\n         *       of milliseconds since the previous state change entry in\n         *       the time range (or the beginning of the range if this is\n         *       the first entry in within the time range), and add that\n         *       a counter of \"normal\" millseconds.\n         *    d) Finally, save the current date and status for later use.\n         * 4) Perform the same computation in 3c, except count the number\n         *    of milliseconds since the last state change entry (or the\n         *    start time if there were no entries) and the end time, and add\n         *    that to the counter of \"normal\" milliseconds.\n         * 5) Divide the \"normal\" milliseconds counter by the total number\n         *    of milliseconds in our time range and compute and return a\n         *    percentage.\n         */\n\n        List<OnmsLocationSpecificStatus> sortedStatuses =\n            new LinkedList<OnmsLocationSpecificStatus>(statuses);\n        Collections.sort(sortedStatuses, new Comparator<OnmsLocationSpecificStatus>(){\n            public int compare(OnmsLocationSpecificStatus o1, OnmsLocationSpecificStatus o2) {\n                return o1.getPollResult().getTimestamp().compareTo(o2.getPollResult().getTimestamp());\n            }\n        });\n\n        HashMap<OnmsMonitoredService,PollStatus> serviceStatus =\n            new HashMap<OnmsMonitoredService,PollStatus>();\n        for (OnmsMonitoredService service : applicationServices) {\n            serviceStatus.put(service, PollStatus.unknown(\"No history for this service from this location\"));\n        }\n        \n        float normalMilliseconds = 0f;\n        \n        Date lastDate = startDate;\n        Severity lastStatus = Severity.CRITICAL;\n        \n        for (OnmsLocationSpecificStatus status : sortedStatuses) {\n            Date currentDate = status.getPollResult().getTimestamp();\n\n            if (!currentDate.before(endDate)) {\n                // We're at or past the end date, so we're done processing\n                break;\n            }\n            \n            serviceStatus.put(status.getMonitoredService(), status.getPollResult());\n            Severity currentStatus = calculateStatus(serviceStatus.values());\n            \n            if (currentDate.before(startDate)) {\n                /*\n                 * We're not yet to a date that is inside our time period, so\n                 * we don't need to check the status and adjust the\n                 * normalMilliseconds variable, but we do need to save the\n                 * status so we have an up-to-date status when we cross the\n                 * start date.\n                 */\n                lastStatus = currentStatus;\n                continue;\n            }\n            \n            /*\n             * Because we *just* had a state change, we want to look at the\n             * value of the *last* status.\n             */\n            if (lastStatus == Severity.NORMAL) {\n                long milliseconds = currentDate.getTime() - lastDate.getTime();\n                normalMilliseconds += milliseconds;\n            }\n            \n            lastDate = currentDate;\n            lastStatus = currentStatus;\n        }\n        \n        if (lastStatus == Severity.NORMAL) {\n            long milliseconds = endDate.getTime() - lastDate.getTime();\n            normalMilliseconds += milliseconds;\n        }\n\n        float percentage = normalMilliseconds /\n            (endDate.getTime() - startDate.getTime()) * 100;\n        return new DecimalFormat(\"0.000\").format((double) percentage) + \"%\";\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String calculateStatus(Collection<PollStatus> pollStatuses) {\n        /*\n         * XXX We aren't doing anything for warning, because we don't\n         * have a warning state available, right now.  Should unknown\n         * be a warning state?\n         */\n        for (PollStatus pollStatus : pollStatuses) {\n            if (!pollStatus.isAvailable()) {\n                return \"Critical\";\n            }\n        }\n        \n        return \"Normal\";\n    }","id":90243,"modified_method":"public Severity calculateStatus(Collection<PollStatus> pollStatuses) {\n        /*\n         * XXX We aren't doing anything for warning, because we don't\n         * have a warning state available, right now.  Should unknown\n         * be a warning state?\n         */\n        \n        int goodStatuses = 0;\n        int badStatuses = 0;\n        \n        for (PollStatus pollStatus : pollStatuses) {\n            if (pollStatus.isAvailable()) {\n                goodStatuses++;\n            } else if (pollStatus.getStatusCode() != PollStatus.SERVICE_UNKNOWN) {\n                badStatuses++;\n            }\n        }\n\n        if (goodStatuses == 0 && badStatuses == 0) {\n            return Severity.INDETERMINATE;\n        } else if (goodStatuses > 0 && badStatuses == 0) {\n            return Severity.NORMAL;\n        } else {\n            return Severity.CRITICAL;\n        }\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String calculateCurrentStatus(OnmsLocationMonitor monitor,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        Set<PollStatus> pollStatuses = new HashSet<PollStatus>();\n        \n        for (OnmsMonitoredService service : applicationServices) {\n            boolean foundIt = false;\n            for (OnmsLocationSpecificStatus status : statuses) {\n                if (status.getMonitoredService().equals(service)\n                        && status.getLocationMonitor().equals(monitor)) {\n                    pollStatuses.add(status.getPollResult());\n                    foundIt = true;\n                    break;\n                }\n            }\n            if (!foundIt) {\n                pollStatuses.add(PollStatus.unknown());\n            }\n        }\n        \n        return calculateStatus(pollStatuses);\n    }","id":90244,"modified_method":"public Severity calculateCurrentStatus(OnmsLocationMonitor monitor,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        Set<PollStatus> pollStatuses = new HashSet<PollStatus>();\n        \n        for (OnmsMonitoredService service : applicationServices) {\n            boolean foundIt = false;\n            for (OnmsLocationSpecificStatus status : statuses) {\n                if (status.getMonitoredService().equals(service) && status.getLocationMonitor().equals(monitor)) {\n                    pollStatuses.add(status.getPollResult());\n                    foundIt = true;\n                    break;\n                }\n            }\n            if (!foundIt) {\n                pollStatuses.add(PollStatus.unknown(\"No status found for this service\"));\n                if (log().isDebugEnabled()) {\n                    log().debug(\"Did not find status for service \" + service + \" in application.  Setting status for it to unknown.\");\n                }\n            }\n        }\n        \n        return calculateStatus(pollStatuses);\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String calculateCurrentStatus(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        int goodMonitors = 0;\n        int badMonitors = 0;\n        \n        for (OnmsLocationMonitor monitor : monitors) {\n            if (monitor == null || monitor.getStatus() != MonitorStatus.STARTED) {\n                continue;\n            }\n            \n            String status = calculateCurrentStatus(monitor, applicationServices, statuses);\n            \n            // FIXME: \"Normal\", etc. should be done with static variables\n            if (\"Normal\".equals(status)) {\n                goodMonitors++;\n            } else {\n                badMonitors++;\n            }\n        }\n        \n        if (goodMonitors == 0 && badMonitors == 0) {\n            return \"Indeterminate\"; // No current responses\n        } else if (goodMonitors != 0 && badMonitors == 0) {\n            return \"Normal\"; // No bad responses\n        } else if (goodMonitors == 0 && badMonitors != 0) {\n            return \"Critical\"; // All bad responses\n        } else if (goodMonitors != 0 && badMonitors != 0){\n            return \"Warning\"; // Some bad responses\n        } else {\n            throw new IllegalStateException(\"Shouldn't have gotten here. \"\n                                            + \"good monitors = \"\n                                            + goodMonitors\n                                            + \", bad monitors = \"\n                                            + badMonitors);\n        }\n    }","id":90245,"modified_method":"public Severity calculateCurrentStatus(\n            Collection<OnmsLocationMonitor> monitors,\n            Collection<OnmsMonitoredService> applicationServices,\n            Collection<OnmsLocationSpecificStatus> statuses) {\n        int goodMonitors = 0;\n        int badMonitors = 0;\n        \n        for (OnmsLocationMonitor monitor : monitors) {\n            if (monitor == null || monitor.getStatus() != MonitorStatus.STARTED) {\n                continue;\n            }\n            \n            Severity status = calculateCurrentStatus(monitor, applicationServices, statuses);\n            \n            // FIXME: \"Normal\", etc. should be done with static variables\n            if (status == Severity.NORMAL) {\n                goodMonitors++;\n            } else if (status != Severity.INDETERMINATE) {\n                badMonitors++;\n            }\n        }\n        \n        if (goodMonitors == 0 && badMonitors == 0) {\n            return Severity.INDETERMINATE; // No current responses\n        } else if (goodMonitors != 0 && badMonitors == 0) {\n            return Severity.NORMAL; // No bad responses\n        } else if (goodMonitors == 0 && badMonitors != 0) {\n            return Severity.CRITICAL; // All bad responses\n        } else if (goodMonitors != 0 && badMonitors != 0){\n            return Severity.WARNING; // Some bad responses\n        } else {\n            throw new IllegalStateException(\"Shouldn't have gotten here. \"\n                                            + \"good monitors = \"\n                                            + goodMonitors\n                                            + \", bad monitors = \"\n                                            + badMonitors);\n        }\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public SimpleWebTable createFacilityStatusTable(Date start, Date end) {\n        Assert.notNull(start, \"argument start cannot be null\");\n        Assert.notNull(end, \"argument end cannot be null\");\n        if (!start.before(end)) {\n            throw new IllegalArgumentException(\"start date (\" + start + \") must be older than end date (\" + end + \")\");\n        }\n        \n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = m_locationMonitorDao.getAllMostRecentStatusChanges();\n\n        Collection<OnmsLocationSpecificStatus> statusesPeriod = new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(m_locationMonitorDao.getAllStatusChangesAt(start));\n        statusesPeriod.addAll(m_locationMonitorDao.getStatusChangesBetween(start, end));\n        \n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors =\n                m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n                String status = calculateCurrentStatus(monitors, memberServices, mostRecentStatuses);\n            \n                Set<OnmsLocationSpecificStatus> selectedStatuses = filterStatus(statusesPeriod, monitors, memberServices);\n                \n                if (selectedStatuses.size() > 0) {\n                    String percentage = calculatePercentageUptime(memberServices, selectedStatuses, start, end);\n                    table.addCell(percentage, status, createHistoryPageUrl(locationDefinition, application));\n                } else {\n                    table.addCell(\"No data\", status);\n                }\n            }\n        }\n        \n        if (isLayoutApplicationsVertically()) {\n            SimpleWebTable newTable = new SimpleWebTable();\n            newTable.setErrors(table.getErrors());\n            newTable.setTitle(table.getTitle());\n            \n            newTable.addColumn(\"Application\");\n            for (List<Cell> row : table.getRows()) {\n                // The location is in the second row\n                newTable.addColumn(row.get(1).getContent(), row.get(1).getStyleClass());\n            }\n            \n            for (Cell columnHeader : table.getColumnHeaders().subList(2, table.getColumnHeaders().size())) {\n                // This is the index into collumn list of the old table to get the data for the current application\n                int rowColumnIndex = newTable.getRows().size() + 2;\n                \n                newTable.newRow();\n                newTable.addCell(columnHeader.getContent(), columnHeader.getStyleClass());\n                \n                for (List<Cell> row : table.getRows()) {\n                    newTable.addCell(row.get(rowColumnIndex).getContent(), row.get(rowColumnIndex).getStyleClass(), row.get(rowColumnIndex).getLink());\n                }\n            }\n            \n            return newTable;\n        }\n        \n        return table;\n    }","id":90246,"modified_method":"public SimpleWebTable createFacilityStatusTable(Date start, Date end) {\n        Assert.notNull(start, \"argument start cannot be null\");\n        Assert.notNull(end, \"argument end cannot be null\");\n        if (!start.before(end)) {\n            throw new IllegalArgumentException(\"start date (\" + start + \") must be older than end date (\" + end + \")\");\n        }\n        \n        SimpleWebTable table = new SimpleWebTable();\n        \n        List<OnmsMonitoringLocationDefinition> locationDefinitions = m_locationMonitorDao.findAllMonitoringLocationDefinitions();\n\n        Collection<OnmsApplication> applications = m_applicationDao.findAll();\n        if (applications.size() == 0) {\n            throw new IllegalArgumentException(\"there are no applications\");\n        }\n        \n        List<OnmsApplication> sortedApplications = new ArrayList<OnmsApplication>(applications);\n        Collections.sort(sortedApplications);\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = m_locationMonitorDao.getAllMostRecentStatusChanges();\n\n        Collection<OnmsLocationSpecificStatus> statusesPeriod = new HashSet<OnmsLocationSpecificStatus>();\n        statusesPeriod.addAll(m_locationMonitorDao.getAllStatusChangesAt(start));\n        statusesPeriod.addAll(m_locationMonitorDao.getStatusChangesBetween(start, end));\n\n        table.setTitle(\"Distributed Poller Status Summary\");\n        \n        table.addColumn(\"Area\", \"\");\n        table.addColumn(\"Location\", \"\");\n        for (OnmsApplication application : sortedApplications) {\n            table.addColumn(application.getName(), \"\");\n        }\n        \n        for (OnmsMonitoringLocationDefinition locationDefinition : locationDefinitions) {\n            Collection<OnmsLocationMonitor> monitors = m_locationMonitorDao.findByLocationDefinition(locationDefinition);\n            \n            table.newRow();\n            table.addCell(locationDefinition.getArea(), \"\");\n            table.addCell(locationDefinition.getName(), \"\");\n            \n            for (OnmsApplication application : sortedApplications) {\n                Collection<OnmsMonitoredService> memberServices = m_monitoredServiceDao.findByApplication(application);\n                Severity status = calculateCurrentStatus(monitors, memberServices, mostRecentStatuses);\n            \n                Set<OnmsLocationSpecificStatus> selectedStatuses = filterStatus(statusesPeriod, monitors, memberServices);\n                \n                if (selectedStatuses.size() > 0) {\n                    String percentage = calculatePercentageUptime(memberServices, selectedStatuses, start, end);\n                    table.addCell(percentage, status.getStyle(), createHistoryPageUrl(locationDefinition, application));\n                } else {\n                    table.addCell(\"No data\", status.getStyle());\n                }\n            }\n        }\n        \n        if (isLayoutApplicationsVertically()) {\n            SimpleWebTable newTable = new SimpleWebTable();\n            newTable.setErrors(table.getErrors());\n            newTable.setTitle(table.getTitle());\n            \n            newTable.addColumn(\"Application\");\n            for (List<Cell> row : table.getRows()) {\n                // The location is in the second row\n                newTable.addColumn(row.get(1).getContent(), row.get(1).getStyleClass());\n            }\n            \n            for (Cell columnHeader : table.getColumnHeaders().subList(2, table.getColumnHeaders().size())) {\n                // This is the index into collumn list of the old table to get the data for the current application\n                int rowColumnIndex = newTable.getRows().size() + 2;\n                \n                newTable.newRow();\n                newTable.addCell(columnHeader.getContent(), columnHeader.getStyleClass());\n                \n                for (List<Cell> row : table.getRows()) {\n                    newTable.addCell(row.get(rowColumnIndex).getContent(), row.get(rowColumnIndex).getStyleClass(), row.get(rowColumnIndex).getLink());\n                }\n            }\n            \n            return newTable;\n        }\n        \n        return table;\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreateFacilityStatusTableLayoutApplicationsVertically() throws Exception {\n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications = new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(new HashSet<OnmsLocationMonitor>());\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n        \n        m_service.setLayoutApplicationsVertically(true);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Application\", \"\");\n        expectedTable.addColumn(\"Raleigh\", \"\");\n        expectedTable.addColumn(\"Durham\", \"\");\n        expectedTable.addColumn(\"Columbus\", \"\");\n        \n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Application 1\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Application 2\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","id":90247,"modified_method":"public void testCreateFacilityStatusTableLayoutApplicationsVertically() throws Exception {\n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications = new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.unavailable(), \"20061012-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(new HashSet<OnmsLocationMonitor>());\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n        \n        m_service.setLayoutApplicationsVertically(true);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Application\", \"\");\n        expectedTable.addColumn(\"Raleigh\", \"\");\n        expectedTable.addColumn(\"Durham\", \"\");\n        expectedTable.addColumn(\"Columbus\", \"\");\n        \n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Application 1\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"Application 2\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreateStatusNoLocationMonitor() {\n        // We run five times to catch sorting differences (if we don't sort)\n        for (int i = 0; i < 5; i++) {\n            runTestCreateStatusNoLocationMonitor();\n        }\n    }","id":90248,"modified_method":"public void testCreateStatusNoLocationMonitor() {\n        DistributedStatusDetailsCommand command = new DistributedStatusDetailsCommand();\n        Errors errors = new BindException(command, \"command\");\n\n        command.setLocation(m_locationDefinition3.getName());\n        command.setApplication(m_application2.getName());\n\n        expect(m_applicationDao.findByName(\"Application 2\")).andReturn(m_application2);\n        expect(m_locationMonitorDao.findMonitoringLocationDefinition(m_locationDefinition3.getName())).andReturn(m_locationDefinition3);\n        expect(m_locationMonitorDao.findByLocationDefinition(m_locationDefinition3)).andReturn(new HashSet<OnmsLocationMonitor>());\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createStatusTable(command, errors);\n\n        Errors errorsOut = table.getErrors();\n        assertEquals(\"Number of errors\", 1, errorsOut.getErrorCount());\n        assertEquals(\"Number of global errors\", 1, errorsOut.getGlobalErrorCount());\n        assertEquals(\"Number of field errors\", 0, errorsOut.getFieldErrorCount());\n        ObjectError e = (ObjectError) errorsOut.getGlobalErrors().get(0);\n        assertEquals(\"Error code 0\", \"location.no-monitors\", e.getCode());\n        assertEquals(\"Error 0 argument count\", 2, e.getArguments().length);\n        assertEquals(\"Error argument 0.0\", \"Application 2\", e.getArguments()[0]);\n        assertEquals(\"Error argument 0.0\", \"Columbus\", e.getArguments()[1]);\n\n        m_easyMockUtils.verifyAll();\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testCreateFacilityStatusTable() throws Exception {\n        for (int i = 0; i < 5; i++) {\n            runTestCreateFacilityStatusTable();\n        }\n    }","id":90249,"modified_method":"public void testCreateFacilityStatusTable() throws Exception {\n         // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications = new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.unavailable(), \"20061012-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(new HashSet<OnmsLocationMonitor>());\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testPercentageCalculation() throws ParseException {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        m_easyMockUtils.replayAll();\n        String percentage = m_service.calculatePercentageUptime(m_applicationServices1, statuses,  startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        assertEquals(\"percentage\", \"75.000%\", percentage);\n    }","id":90250,"modified_method":"public void testPercentageCalculationAllAvailableStartInMiddleOfDay() throws ParseException {\n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n\n        Collection<OnmsLocationSpecificStatus> statuses = new HashSet<OnmsLocationSpecificStatus>();\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061012-00:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061013-00:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        m_easyMockUtils.replayAll();\n        String percentage = m_service.calculatePercentageUptime(m_applicationServices1, statuses,  startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        assertEquals(\"percentage\", \"100.000%\", percentage);\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void runTestCreateFacilityStatusTable() throws Exception {\n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        locationDefinitions.add(m_locationDefinition3);\n        \n        List<OnmsApplication> applications = new LinkedList<OnmsApplication>();\n        applications.add(m_application1);\n        applications.add(m_application2);\n        Collections.shuffle(applications);\n        \n        OnmsMonitoredService httpService = findMonitoredService(m_services, m_ip, \"HTTP\");\n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        OnmsMonitoredService icmpService = findMonitoredService(m_services, m_ip, \"ICMP\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        mostRecentStatuses.add(createStatus(m_locationMonitor2_2, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpService, PollStatus.available(), \"20061011-00:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061012-06:00:00\"));\n        statusChanges.add(createStatus(m_locationMonitor1_1, icmpService, PollStatus.down(), \"20061010-06:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(applications);\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        Collection<OnmsLocationMonitor> monitors2 = new HashSet<OnmsLocationMonitor>();\n        monitors2.add(m_locationMonitor2_1);\n        monitors2.add(m_locationMonitor2_2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(monitors2);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(2))).andReturn(new HashSet<OnmsLocationMonitor>());\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(m_application1)).andReturn(m_applicationServices1).times(3);\n        expect(m_monitoredServiceDao.findByApplication(m_application2)).andReturn(m_applicationServices2).times(3);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(\"Application 1\", \"\");\n        expectedTable.addColumn(\"Application 2\", \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+1\");\n        expectedTable.addCell(\"75.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        expectedTable.addCell(\"No data\", \"Normal\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS OH\", \"\");\n        expectedTable.addCell(\"Columbus\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","id":90251,"modified_method":"public void testCreateFacilityStatusTableOneApplicationOneOfTwoLocationsReporting() throws Exception {\n        OnmsApplication app = m_application2;\n        \n        // No need to shuffle, since this is a list\n        List<OnmsMonitoringLocationDefinition> locationDefinitions = new LinkedList<OnmsMonitoringLocationDefinition>();\n        locationDefinitions.add(m_locationDefinition1);\n        locationDefinitions.add(m_locationDefinition2);\n        \n        OnmsMonitoredService httpsService = findMonitoredService(m_services, m_ip, \"HTTPS\");\n        \n        Collection<OnmsLocationSpecificStatus> mostRecentStatuses = new LinkedList<OnmsLocationSpecificStatus>();\n        mostRecentStatuses.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061011-00:00:00\"));\n        \n        Collection<OnmsLocationSpecificStatus> statusChanges = new LinkedList<OnmsLocationSpecificStatus>();\n        statusChanges.add(createStatus(m_locationMonitor1_1, httpsService, PollStatus.available(), \"20061011-00:00:00\"));\n\n        Date startDate = s_dbDate.parse(\"2006-10-12 00:00:00.0\");\n        Date endDate = s_dbDate.parse(\"2006-10-13 00:00:00.0\");\n\n        expect(m_locationMonitorDao.findAllMonitoringLocationDefinitions()).andReturn(locationDefinitions);\n        expect(m_applicationDao.findAll()).andReturn(Collections.singletonList(app));\n        expect(m_locationMonitorDao.getAllMostRecentStatusChanges()).andReturn(mostRecentStatuses);\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(0))).andReturn(Collections.singleton(m_locationMonitor1_1));\n        expect(m_locationMonitorDao.findByLocationDefinition(locationDefinitions.get(1))).andReturn(Collections.singleton(m_locationMonitor2_1));\n        expect(m_locationMonitorDao.getStatusChangesBetween(startDate, endDate)).andReturn(statusChanges);\n        expect(m_locationMonitorDao.getAllStatusChangesAt(startDate)).andReturn(new HashSet<OnmsLocationSpecificStatus>());\n\n        expect(m_monitoredServiceDao.findByApplication(app)).andReturn(m_applicationServices2).times(2);\n\n        m_easyMockUtils.replayAll();\n        SimpleWebTable table = m_service.createFacilityStatusTable(startDate, endDate);\n        m_easyMockUtils.verifyAll();\n        \n        SimpleWebTable expectedTable = new SimpleWebTable();\n        expectedTable.setTitle(\"Distributed Poller Status Summary\");\n        expectedTable.addColumn(\"Area\", \"\");\n        expectedTable.addColumn(\"Location\", \"\");\n        expectedTable.addColumn(app.getName(), \"\");\n\n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Raleigh\", \"\");\n        expectedTable.addCell(\"100.000%\", \"Normal\", \"distributedStatusHistory.htm?location=Raleigh&application=Application+2\");\n        \n        expectedTable.newRow();\n        expectedTable.addCell(\"OpenNMS NC\", \"\");\n        expectedTable.addCell(\"Durham\", \"\");\n        expectedTable.addCell(\"No data\", \"Indeterminate\");\n        \n        assertTableEquals(expectedTable, table);\n    }","commit_id":"8731f78e4f4a533df4da7026a0951f57d7407b61","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private boolean add(TextMPSTreeNode root, MappingConfig_AbstractRef ref) {\n    if (ref == null) {\n      return false;\n    }\n    if (ref instanceof MappingConfig_RefAllLocal) {\n      root.add(new TextMPSTreeNode(\"*\", null));\n      return true;\n    } else\n    if (ref instanceof MappingConfig_RefAllGlobal) {\n      root.add(new TextMPSTreeNode(\"*.*\", null));\n      return true;\n    } else\n    if (ref instanceof MappingConfig_SimpleRef) {\n      MappingConfig_SimpleRef refC = (MappingConfig_SimpleRef) ref;\n      SModelReference modelRef = SModelReference.fromString(refC.getModelUID());\n      String nodeName = \"\";\n      if (refC.getNodeID().equals(\"*\")) {\n        nodeName = modelRef.getShortName() + \".*\";\n      } else {\n        final SNodePointer p = new SNodePointer(refC.getModelUID(), refC.getNodeID());\n        nodeName = ModelAccess.instance().runReadAction(new Computable<String>() {\n          public String compute() {\n            SModelDescriptor model = p.getModel();\n            SNode node = p.getNode();\n            if (model == null || node == null) {\n              return null;\n            }\n            return model.getName() + \".\" + node.getName();\n          }\n        });\n        if (nodeName == null) {\n          String nodeString = p.getModelReference().getSModelFqName().toString() + \":\" + p.getNodeId().toString();\n          root.add(new TextMPSTreeNode(\"NOT FOUND: \" + nodeString, null));\n          return false;\n        }\n      }\n      root.add(new TextMPSTreeNode(nodeName, null));\n      return true;\n    } else\n    if (ref instanceof MappingConfig_ExternalRef) {\n      MappingConfig_ExternalRef refC = (MappingConfig_ExternalRef) ref;\n      ModuleReference generatorReference = refC.getGenerator();\n      if (generatorReference == null) {\n        root.add(new TextMPSTreeNode(\"NOT FOUND: <bad generator reference>\", null));\n        return false;\n      }\n      ModuleReference moduleRef = generatorReference;\n      Generator generator = (Generator) MPSModuleRepository.getInstance().getModule(moduleRef);\n      if (generator == null) {\n        String genString = generatorReference.getModuleFqName();\n        root.add(new TextMPSTreeNode(\"NOT FOUND: \" + genString, null));\n        return false;\n      }\n      TextMPSTreeNode child = new TextMPSTreeNode(generator.getAlias(), null);\n      root.add(child);\n      return this.add(child, refC.getMappingConfig());\n    } else\n    if (ref instanceof MappingConfig_RefSet) {\n      boolean complete = true;\n      for (MappingConfig_AbstractRef mappingRef : ((MappingConfig_RefSet) ref).getMappingConfigs()) {\n        if (!(this.add(root, mappingRef))) {\n          complete = false;\n        }\n      }\n      return complete;\n    }\n    return false;\n  }","id":90252,"modified_method":"private boolean add(TextMPSTreeNode root, MappingConfig_AbstractRef ref) {\n    if (ref == null) {\n      return false;\n    }\n    if (ref instanceof MappingConfig_RefAllLocal) {\n      root.add(new TextMPSTreeNode(\"*\", null));\n      return true;\n    } else\n    if (ref instanceof MappingConfig_RefAllGlobal) {\n      root.add(new TextMPSTreeNode(\"*.*\", null));\n      return true;\n    } else\n    if (ref instanceof MappingConfig_SimpleRef) {\n      MappingConfig_SimpleRef refC = (MappingConfig_SimpleRef) ref;\n      SModelReference modelRef = SModelReference.fromString(refC.getModelUID());\n      String nodeName;\n      if (refC.getNodeID().equals(\"*\")) {\n        nodeName = modelRef.getShortName() + \".*\";\n      } else {\n        final SNodePointer p = new SNodePointer(refC.getModelUID(), refC.getNodeID());\n        nodeName = ModelAccess.instance().runReadAction(new Computable<String>() {\n          public String compute() {\n            SModelDescriptor model = p.getModel();\n            SNode node = p.getNode();\n            if (model == null || node == null) {\n              return null;\n            }\n            return model.getName() + \".\" + node.getName();\n          }\n        });\n        if (nodeName == null) {\n          String nodeString = p.getModelReference().getSModelFqName().toString() + \":\" + p.getNodeId().toString();\n          root.add(new TextMPSTreeNode(\"NOT FOUND: \" + nodeString, null));\n          return false;\n        }\n      }\n      root.add(new TextMPSTreeNode(nodeName, null));\n      return true;\n    } else\n    if (ref instanceof MappingConfig_ExternalRef) {\n      MappingConfig_ExternalRef refC = (MappingConfig_ExternalRef) ref;\n      ModuleReference generatorReference = refC.getGenerator();\n      if (generatorReference == null) {\n        root.add(new TextMPSTreeNode(\"NOT FOUND: <bad generator reference>\", null));\n        return false;\n      }\n      ModuleReference moduleRef = generatorReference;\n      Generator generator = (Generator) MPSModuleRepository.getInstance().getModule(moduleRef);\n      if (generator == null) {\n        String genString = generatorReference.getModuleFqName();\n        root.add(new TextMPSTreeNode(\"NOT FOUND: \" + genString, null));\n        return false;\n      }\n      TextMPSTreeNode child = new TextMPSTreeNode(generator.getAlias(), null);\n      root.add(child);\n      return this.add(child, refC.getMappingConfig());\n    } else\n    if (ref instanceof MappingConfig_RefSet) {\n      boolean complete = true;\n      for (MappingConfig_AbstractRef mappingRef : ((MappingConfig_RefSet) ref).getMappingConfigs()) {\n        if (!(this.add(root, mappingRef))) {\n          complete = false;\n        }\n      }\n      return complete;\n    }\n    return false;\n  }","commit_id":"b4eb3d6d783000d274ad737ac22259f620493db0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static int compare(ModuleReference moduleRef1, ModuleReference moduleRef2) {\n    boolean isAvailable1 = isAvailable(moduleRef1);\n    boolean isAvailable2 = isAvailable(moduleRef2);\n    if (isAvailable1 && !(isAvailable2)) {\n      return 1;\n    }\n    if (isAvailable2 && !(isAvailable1)) {\n      return -1;\n    }\n    return 0;\n  }","id":90253,"modified_method":"public static int compare(ModuleReference moduleRef1, ModuleReference moduleRef2) {\n    return compare(isAvailable(moduleRef1), isAvailable(moduleRef2));\n  }","commit_id":"b4eb3d6d783000d274ad737ac22259f620493db0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static int compare(final SModelReference ref1, final SModelReference ref2, final IScope scope) {\n    boolean isAvailable1 = isAvailable(ref1);\n    boolean isAvailable2 = isAvailable(ref2);\n    if (isAvailable1 && !(isAvailable2)) {\n      return 1;\n    }\n    if (isAvailable2 && !(isAvailable1)) {\n      return -1;\n    }\n    boolean isInScope1 = isInScope(scope, ref1);\n    boolean isInScope2 = isInScope(scope, ref2);\n    if (isInScope1 && !(isInScope2)) {\n      return 1;\n    }\n    if (isInScope2 && !(isInScope1)) {\n      return -1;\n    }\n    return 0;\n  }","id":90254,"modified_method":"public static int compare(final SModelReference ref1, final SModelReference ref2, final IScope scope) {\n    int result = compare(isAvailable(ref1), isAvailable(ref2));\n    if (result != 0) {\n      return result;\n    }\n    return compare(isInScope(scope, ref1), isInScope(scope, ref2));\n  }","commit_id":"b4eb3d6d783000d274ad737ac22259f620493db0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Component getListCellRendererComponent(JList list, final Object value, int index, boolean isSelected, boolean cellHasFocus) {\n    String path = (String) value;\n    Component result = super.getListCellRendererComponent(list, path, index, isSelected, cellHasFocus);\n    if (path == null) {\n      return result;\n    }\n    if (isSelected) {\n      return result;\n    }\n    VirtualFile file = VFileSystem.getFile(path);\n    if (file == null || !(file.exists())) {\n      this.setForeground(Color.RED);\n    }\n    return result;\n  }","id":90255,"modified_method":"public Component getListCellRendererComponent(JList list, final Object value, int index, boolean isSelected, boolean cellHasFocus) {\n    String path = (String) value;\n    Component result = super.getListCellRendererComponent(list, path, index, isSelected, cellHasFocus);\n    if (path == null) {\n      return result;\n    }\n    if (isSelected) {\n      return result;\n    }\n    if (!(StateUtil.isAvailable(path))) {\n      this.setForeground(Color.RED);\n    }\n    return result;\n  }","commit_id":"b4eb3d6d783000d274ad737ac22259f620493db0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void sawOpcode(int seen) {\n\n\t\tif (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) {\n\t\t\tlastCallClass = getDottedClassConstantOperand();\n\t\t\tlastCallMethod = getNameConstantOperand();\n\t\t\tlastCallSig = getDottedSigConstantOperand();\n\t\t}\n\n\t\tif ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t        && getNameConstantOperand().equals(\"available\")\n\t\t        && getSigConstantOperand().equals(\"()I\")\n\t\t        || (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t        && getNameConstantOperand().startsWith(\"get\")\n\t\t        && getNameConstantOperand().endsWith(\"Length\")\n\t\t        && getSigConstantOperand().equals(\"()I\")\n\t\t        || (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t        && getClassConstantOperand().equals(\"java/io/File\")\n\t\t        && getNameConstantOperand().equals(\"length\")\n\t\t        && getSigConstantOperand().equals(\"()J\")) {\n\t\t\tsawAvailable = 70;\n\t\t\treturn;\n\t\t}\n\t\tsawAvailable--;\n\t\tif ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t        && !getClassConstantOperand().equals(\"java/io/ByteArrayInputStream\")\n\t\t        && getNameConstantOperand().equals(\"read\")\n\t\t        && (getSigConstantOperand().startsWith(\"([B\")\n\t\t        || getSigConstantOperand().startsWith(\"([C\"))\n\t\t        && sawAvailable <= 0) {\n\t\t\t/*\n\t\t\tSystem.out.println(\"Saw invocation of \"\n\t\t\t\t+ getNameConstantOperand() + \"(\"\n\t\t\t\t+ getSigConstantOperand()\n\t\t\t\t+\"), available = \" + sawAvailable);\n\t\t\t*/\n\n\t\t\tboolean b = false;\n\t\t\ttry {\n\t\t\t\tb = Repository.instanceOf(getDottedClassConstantOperand(), \"java.io.ByteArrayInputStream\");\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t}\n\t\t\tif (!b) {\n\t\t\t\tsawRead = true;\n\t\t\t\treadPC = getPC();\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else if ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t        && !getClassConstantOperand().equals(\"java/io/ByteArrayInputStream\")\n\t\t        && getNameConstantOperand().equals(\"skip\")) {\n\t\t\tboolean bais = false;\n\t\t\tboolean bis = false;\n\t\t\ttry {\n\t\t\t\tbais = Repository.instanceOf(getDottedClassConstantOperand(), \"java.io.ByteArrayInputStream\");\n\t\t\t\tbis = Repository.instanceOf(getDottedClassConstantOperand(), \"java.io.BufferedInputStream\");\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t}\n\t\t\t// if not ByteArrayInput Stream\n\t\t\t//  and either no recent calls to length\n\t\t\t//        or it is a BufferedInputStream\n\t\t\tif (!bais && (sawAvailable <= 0 || bis)) {\n\t\t\t\tisBufferedInputStream = bis;\n\t\t\t\tsawSkip = true;\n\t\t\t\tskipPC = getPC();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ((seen == POP) || (seen == POP2)) {\n\t\t\tif (sawRead) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"RR_NOT_CHECKED\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t        .addCalledMethod(lastCallClass, lastCallMethod, lastCallSig)\n\t\t\t\t        .addSourceLine(this, readPC));\n\t\t\t} else if (sawSkip) {\n\t\t\t\tboolean isBufferedInputStream = false;\n\t\t\t\ttry {\n\t\t\t\t\tisBufferedInputStream = Repository.instanceOf(lastCallClass, \"java.io.BufferedInputStream\");\n\t\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\t}\n\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"SR_NOT_CHECKED\",\n\t\t\t\t        (isBufferedInputStream ? HIGH_PRIORITY : NORMAL_PRIORITY))\n\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t        .addCalledMethod(lastCallClass, lastCallMethod, lastCallSig)\n\t\t\t\t        .addSourceLine(this, skipPC));\n\t\t\t}\n\t\t}\n\t\tsawRead = false;\n\t\tsawSkip = false;\n\t}","id":90256,"modified_method":"public void sawOpcode(int seen) {\n\n\t\tboolean isInputStream = false;\n\t\tboolean isBufferedInputStream = false;\n\t\tif (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) {\n\t\t\tlastCallClass = getDottedClassConstantOperand();\n\t\t\tlastCallMethod = getNameConstantOperand();\n\t\t\tlastCallSig = getDottedSigConstantOperand();\n\t        if (!lastCallClass.startsWith(\"[\")) \n\t\ttry {\n\t\t   isInputStream \n\t\t\t= (Repository.instanceOf(lastCallClass,\n\t\t\t\t\"java.io.InputStream\")\n\t\t\t || Repository.implementationOf(lastCallClass,\n\t\t\t\t\"java.io.DataInput\")\n\t\t\t || Repository.instanceOf(lastCallClass,\n\t\t\t\t\"java.io.Reader\"))\n\t\t\t&& !Repository.instanceOf(lastCallClass, \n\t\t\t\t\"java.io.ByteArrayInputStream\");\n\t\t    isBufferedInputStream = Repository.instanceOf(getDottedClassConstantOperand(), \"java.io.BufferedInputStream\");\n\t\t} catch (ClassNotFoundException e) {\n\t\t}\n\t\t}\n\n\t\tif (seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE) \n\t\t  if (getNameConstantOperand().equals(\"available\")\n\t\t        && getSigConstantOperand().equals(\"()I\")\n\t\t      || getNameConstantOperand().startsWith(\"get\")\n\t\t        && getNameConstantOperand().endsWith(\"Length\")\n\t\t        && getSigConstantOperand().equals(\"()I\")\n\t\t      ||  getClassConstantOperand().equals(\"java/io/File\")\n\t\t        && getNameConstantOperand().equals(\"length\")\n\t\t        && getSigConstantOperand().equals(\"()J\")) {\n\t\t\tsawAvailable = 70;\n\t\t\treturn;\n\t\t}\n\t\tsawAvailable--;\n\t\tif ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t        && isInputStream\n\t\t        && getNameConstantOperand().equals(\"read\")\n\t\t        && (\n\t\t\t\tgetSigConstantOperand().equals(\"([B)I\")\n\t\t\t\t|| getSigConstantOperand().equals(\"([BII)I\")\n\t\t            || getSigConstantOperand().equals(\"([C)I\")\n\t\t            || getSigConstantOperand().equals(\"([CII)I\")\n\t\t\t\t)\n\t\t        && sawAvailable <= 0) {\n\t\t\tsawRead = true;\n\t\t\treadPC = getPC();\n\t\t\treturn;\n\t\t\t}\n\t\tif ((seen == INVOKEVIRTUAL || seen == INVOKEINTERFACE)\n\t\t        && isInputStream\n\t\t        && getNameConstantOperand().equals(\"skip\")\n\t\t        && getSigConstantOperand().equals(\"(J)J\")) {\n\t\t\t// if not ByteArrayInput Stream\n\t\t\t//  and either no recent calls to length\n\t\t\t//        or it is a BufferedInputStream\n\t\t\tif (sawAvailable <= 0 || isBufferedInputStream) {\n\t\t\t\twasBufferedInputStream = isBufferedInputStream;\n\t\t\t\tsawSkip = true;\n\t\t\t\tskipPC = getPC();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ((seen == POP) || (seen == POP2)) {\n\t\t\tif (sawRead) {\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"RR_NOT_CHECKED\", NORMAL_PRIORITY)\n\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t        .addCalledMethod(lastCallClass, lastCallMethod, lastCallSig)\n\t\t\t\t        .addSourceLine(this, readPC));\n\t\t\t} else if (sawSkip) {\n\n\t\t\t\tbugReporter.reportBug(new BugInstance(this, \"SR_NOT_CHECKED\",\n\t\t\t\t        (wasBufferedInputStream ? HIGH_PRIORITY : NORMAL_PRIORITY))\n\t\t\t\t        .addClassAndMethod(this)\n\t\t\t\t        .addCalledMethod(lastCallClass, lastCallMethod, lastCallSig)\n\t\t\t\t        .addSourceLine(this, skipPC));\n\t\t\t}\n\t\t}\n\t\tsawRead = false;\n\t\tsawSkip = false;\n\t}","commit_id":"577238da7a881f4d0656172016906911f68d5a0f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(JavaClass obj) {\n\t\tint flags = obj.getAccessFlags();\n\t\tisAbstract = (flags & ACC_ABSTRACT) != 0\n\t\t        || (flags & ACC_INTERFACE) != 0;\n\t\tsawSerialVersionUID = false;\n\t\tisSerializable = implementsSerializableDirectly = false;\n\t\tisExternalizable = false;\n\t\tdirectlyImplementsExternalizable = false;\n\t\tisGUIClass = false;\n\t\t//isRemote = false;\n\n\t\t// Does this class directly implement Serializable?\n\t\tString[] interface_names = obj.getInterfaceNames();\n\t\tfor (int i = 0; i < interface_names.length; i++) {\n\t\t\tif (interface_names[i].equals(\"java.io.Externalizable\")) {\n\t\t\t\tdirectlyImplementsExternalizable = true;\n\t\t\t\tisExternalizable = true;\n\t\t\t\t// System.out.println(\"Directly implements Externalizable: \" + betterClassName);\n\t\t\t} else if (interface_names[i].equals(\"java.io.Serializable\")) {\n\t\t\t\timplementsSerializableDirectly = true;\n\t\t\t\tisSerializable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Does this class indirectly implement Serializable?\n\t\tif (!isSerializable) {\n\t\t\ttry {\n\t\t\t\tif (Repository.instanceOf(obj, \"java.io.Externalizable\"))\n\t\t\t\t\tisExternalizable = true;\n\t\t\t\tif (Repository.instanceOf(obj, \"java.io.Serializable\"))\n\t\t\t\t\tisSerializable = true;\n/*\n\t        if (Repository.instanceOf(obj,\"java.rmi.Remote\")) {\n\t\t    isRemote = true;\n\t\t    }\n*/\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\n\t\thasPublicVoidConstructor = false;\n\t\tsuperClassHasVoidConstructor = true;\n\t\tsuperClassImplementsSerializable = isSerializable && !implementsSerializableDirectly;\n\t\ttry {\n\t\t\tJavaClass superClass = obj.getSuperClass();\n\t\t\tif (superClass != null) {\n\t\t\t\tMethod[] superClassMethods = superClass.getMethods();\n\t\t\t\tsuperClassImplementsSerializable = Repository.instanceOf(superClass,\n\t\t\t\t        \"java.io.Serializable\");\n\t\t\t\tsuperClassHasVoidConstructor = false;\n\t\t\t\tfor (int i = 0; i < superClassMethods.length; i++) {\n\t\t\t\t\tMethod m = superClassMethods[i];\n\t\t\t\t\t/*\n\t\t\t\t\tif (!m.isPrivate())\n\t\t\t\t\tSystem.out.println(\"Supercase of \" + className\n\t\t\t\t\t\t+ \" has an accessible method named \" + m.getName()\n\t\t\t\t\t\t+ \" with sig \" + m.getSignature());\n\t\t\t\t\t*/\n\t\t\t\t\tif (m.getName().equals(\"<init>\")\n\t\t\t\t\t        && m.getSignature().equals(\"()V\")\n\t\t\t\t\t        && !m.isPrivate()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// System.out.println(\"  super has void constructor\");\n\t\t\t\t\t\tsuperClassHasVoidConstructor = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\n\n\t\t// Is this a GUI class?\n\t\ttry {\n\t\t\tisGUIClass = Repository.instanceOf(obj, \"java.awt.Component\");\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\n\t\tfoundSynthetic = false;\n\t\tfoundSynchronizedMethods = false;\n\t\twriteObjectIsSynchronized = false;\n\n\t\tsawReadExternal = sawWriteExternal = sawReadObject = sawWriteObject = false;\n\t}","id":90257,"modified_method":"public void visit(JavaClass obj) {\n\t\tint flags = obj.getAccessFlags();\n\t\tisAbstract = (flags & ACC_ABSTRACT) != 0\n\t\t        || (flags & ACC_INTERFACE) != 0;\n\t\tisAnonymousInnerClass \n\t\t  = anonymousInnerClassNamePattern\n\t\t\t.matcher(getClassName()).matches();\n\t\t\n\t\t\n\t\tsawSerialVersionUID = false;\n\t\tisSerializable = implementsSerializableDirectly = false;\n\t\tisExternalizable = false;\n\t\tdirectlyImplementsExternalizable = false;\n\t\tisGUIClass = false;\n\t\t\n\t\t//isRemote = false;\n\n\t\t// Does this class directly implement Serializable?\n\t\tString[] interface_names = obj.getInterfaceNames();\n\t\tfor (int i = 0; i < interface_names.length; i++) {\n\t\t\tif (interface_names[i].equals(\"java.io.Externalizable\")) {\n\t\t\t\tdirectlyImplementsExternalizable = true;\n\t\t\t\tisExternalizable = true;\n\t\t\t\t// System.out.println(\"Directly implements Externalizable: \" + betterClassName);\n\t\t\t} else if (interface_names[i].equals(\"java.io.Serializable\")) {\n\t\t\t\timplementsSerializableDirectly = true;\n\t\t\t\tisSerializable = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// Does this class indirectly implement Serializable?\n\t\tif (!isSerializable) {\n\t\t\ttry {\n\t\t\t\tif (Repository.instanceOf(obj, \"java.io.Externalizable\"))\n\t\t\t\t\tisExternalizable = true;\n\t\t\t\tif (Repository.instanceOf(obj, \"java.io.Serializable\"))\n\t\t\t\t\tisSerializable = true;\n/*\n\t        if (Repository.instanceOf(obj,\"java.rmi.Remote\")) {\n\t\t    isRemote = true;\n\t\t    }\n*/\n\t\t\t} catch (ClassNotFoundException e) {\n\t\t\t\tbugReporter.reportMissingClass(e);\n\t\t\t}\n\t\t}\n\n\t\thasPublicVoidConstructor = false;\n\t\tsuperClassHasVoidConstructor = true;\n\t\tsuperClassImplementsSerializable = isSerializable && !implementsSerializableDirectly;\n\t\ttry {\n\t\t\tJavaClass superClass = obj.getSuperClass();\n\t\t\tif (superClass != null) {\n\t\t\t\tMethod[] superClassMethods = superClass.getMethods();\n\t\t\t\tsuperClassImplementsSerializable = Repository.instanceOf(superClass,\n\t\t\t\t        \"java.io.Serializable\");\n\t\t\t\tsuperClassHasVoidConstructor = false;\n\t\t\t\tfor (int i = 0; i < superClassMethods.length; i++) {\n\t\t\t\t\tMethod m = superClassMethods[i];\n\t\t\t\t\t/*\n\t\t\t\t\tif (!m.isPrivate())\n\t\t\t\t\tSystem.out.println(\"Supercase of \" + className\n\t\t\t\t\t\t+ \" has an accessible method named \" + m.getName()\n\t\t\t\t\t\t+ \" with sig \" + m.getSignature());\n\t\t\t\t\t*/\n\t\t\t\t\tif (m.getName().equals(\"<init>\")\n\t\t\t\t\t        && m.getSignature().equals(\"()V\")\n\t\t\t\t\t        && !m.isPrivate()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// System.out.println(\"  super has void constructor\");\n\t\t\t\t\t\tsuperClassHasVoidConstructor = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\n\n\t\t// Is this a GUI  or other class that is rarely serialized?\n\t\ttry {\n\t\t\tisGUIClass = \n\t\t\t Repository.instanceOf(obj, \"java.lang.Throwable\")\n\t\t\t|| Repository.instanceOf(obj, \"java.awt.Component\")\n\t\t\t|| Repository.implementationOf(obj, \"java.awt.event.ActionListener\")\n\t\t\t|| Repository.implementationOf(obj, \"java.util.EventListener\")\n\t\t\t;\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\n\t\tfoundSynthetic = false;\n\t\tfoundSynchronizedMethods = false;\n\t\twriteObjectIsSynchronized = false;\n\n\t\tsawReadExternal = sawWriteExternal = sawReadObject = sawWriteObject = false;\n\t}","commit_id":"3e6373814d765c3a13d53344350878d451b9cc0f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visitAfter(JavaClass obj) {\n\t\tif (false) {\n\t\t\tSystem.out.println(getDottedClassName());\n\t\t\tSystem.out.println(\"  hasPublicVoidConstructor: \" + hasPublicVoidConstructor);\n\t\t\tSystem.out.println(\"  superClassHasVoidConstructor: \" + superClassHasVoidConstructor);\n\t\t\tSystem.out.println(\"  isExternalizable: \" + isExternalizable);\n\t\t\tSystem.out.println(\"  isSerializable: \" + isSerializable);\n\t\t\tSystem.out.println(\"  isAbstract: \" + isAbstract);\n\t\t\tSystem.out.println(\"  superClassImplementsSerializable: \" + superClassImplementsSerializable);\n\t\t}\n\t\tif (isSerializable && !isExternalizable\n\t\t        && !superClassHasVoidConstructor\n\t\t        && !superClassImplementsSerializable)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"SE_NO_SUITABLE_CONSTRUCTOR\",\n\t\t\t        (implementsSerializableDirectly || sawSerialVersionUID)\n\t\t\t        ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t        .addClass(getThisClass().getClassName()));\n\t\t// Downgrade class-level warnings if it's a GUI class.\n\t\tint priority = isGUIClass ? LOW_PRIORITY : NORMAL_PRIORITY;\n\t\tif (obj.getClassName().endsWith(\"_Stub\")) priority++;\n\n\t\tif (isExternalizable && !hasPublicVoidConstructor && !isAbstract)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION\",\n\t\t\t        directlyImplementsExternalizable ?\n\t\t\t        HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t        .addClass(getThisClass().getClassName()));\n\t\tif (foundSynthetic && !isExternalizable && !isGUIClass\n\t\t        && isSerializable && !isAbstract && !sawSerialVersionUID)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"SE_NO_SERIALVERSIONID\", priority).addClass(this));\n\n\t\tif (writeObjectIsSynchronized && !foundSynchronizedMethods)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"WS_WRITEOBJECT_SYNC\", LOW_PRIORITY).addClass(this));\n\t}","id":90258,"modified_method":"public void visitAfter(JavaClass obj) {\n\t\tif (false) {\n\t\t\tSystem.out.println(getDottedClassName());\n\t\t\tSystem.out.println(\"  hasPublicVoidConstructor: \" + hasPublicVoidConstructor);\n\t\t\tSystem.out.println(\"  superClassHasVoidConstructor: \" + superClassHasVoidConstructor);\n\t\t\tSystem.out.println(\"  isExternalizable: \" + isExternalizable);\n\t\t\tSystem.out.println(\"  isSerializable: \" + isSerializable);\n\t\t\tSystem.out.println(\"  isAbstract: \" + isAbstract);\n\t\t\tSystem.out.println(\"  superClassImplementsSerializable: \" + superClassImplementsSerializable);\n\t\t}\n\t\tif (isSerializable && !isExternalizable\n\t\t        && !superClassHasVoidConstructor\n\t\t        && !superClassImplementsSerializable)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"SE_NO_SUITABLE_CONSTRUCTOR\",\n\t\t\t        (implementsSerializableDirectly || sawSerialVersionUID)\n\t\t\t        ? HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t        .addClass(getThisClass().getClassName()));\n\t\t// Downgrade class-level warnings if it's a GUI class.\n\t\tint priority = isGUIClass ? LOW_PRIORITY : NORMAL_PRIORITY;\n\t\tif (obj.getClassName().endsWith(\"_Stub\")) priority++;\n\n\t\tif (isExternalizable && !hasPublicVoidConstructor && !isAbstract)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION\",\n\t\t\t        directlyImplementsExternalizable ?\n\t\t\t        HIGH_PRIORITY : NORMAL_PRIORITY)\n\t\t\t        .addClass(getThisClass().getClassName()));\n\t\tif (foundSynthetic \n\t\t\t&& !isAnonymousInnerClass \n\t\t\t&& !isExternalizable && !isGUIClass\n\t\t        && isSerializable && !isAbstract && !sawSerialVersionUID)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"SE_NO_SERIALVERSIONID\", priority).addClass(this));\n\n\t\tif (writeObjectIsSynchronized && !foundSynchronizedMethods)\n\t\t\tbugReporter.reportBug(new BugInstance(this, \"WS_WRITEOBJECT_SYNC\", LOW_PRIORITY).addClass(this));\n\t}","commit_id":"3e6373814d765c3a13d53344350878d451b9cc0f","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void visit(Field obj) {\n\tint flags = obj.getAccessFlags();\n\n\tif (isSerializable && fieldSig.indexOf(\"L\")  >= 0 && !obj.isTransient() && !obj.isStatic()) {\n\t\ttry {\n\t\t\tString fieldClassName = fieldSig.substring(fieldSig.indexOf(\"L\")+1, fieldSig.length() - 1).replace('/', '.');\n\t\t\tJavaClass fieldClass = Repository.lookupClass(fieldClassName);\n\n\t\t\tif (!fieldClassName.equals(\"java.lang.Object\") &&\n\t\t\t    !Repository.instanceOf(fieldClass, \"java.io.Serializable\")) {\n\t\t\t\t// Priority is higher if the class directly\n\t\t\t\t// implements Serializable.\n\t\t\t\tint priority = implementsSerializableDirectly ? HIGH_PRIORITY : NORMAL_PRIORITY;\n\n\t\t\t\t// Lower the priority for fields which are of an interface\n\t\t\t\t// or abstract type, since the user may know that all subtypes of\n\t\t\t\t// the interface will be Serializable.\n\t\t\t\tif (fieldClass.isInterface() || fieldClass.isAbstract())\n\t\t\t\t    priority = Math.max(LOW_PRIORITY, priority + 1);\n\n\t\t\t\t// Report is queued until after the entire class has been seen.\n\t\t\t\tfieldWarningList.add(new BugInstance(\"SE_BAD_FIELD\", priority)\n\t\t\t\t\t.addClass(thisClass.getClassName())\n\t\t\t\t\t.addField(fieldClassName, obj.getName(), fieldSig, false)\n\t\t\t\t\t.addUnknownSourceLine(thisClass.getClassName(), thisClass.getSourceFileName()));\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\t}\n\n\tif (!fieldName.startsWith(\"this\") \n\t\t&& isSynthetic(obj)) foundSynthetic = true;\n\tif (!fieldName.equals(\"serialVersionUID\")) return;\n\tint mask = ACC_STATIC | ACC_FINAL;\n\tif ( !fieldSig.equals(\"I\")\n\t\t\t && !fieldSig.equals(\"J\")) return;\n\tif ((flags & mask) == mask \n\t\t&& fieldSig.equals(\"I\")) {\n\t\tbugReporter.reportBug(new BugInstance(\"SE_NONLONG_SERIALVERSIONID\", LOW_PRIORITY)\n\t\t\t.addClass(this)\n\t\t\t.addVisitedField(this));\n\t\tsawSerialVersionUID = true;\n\t\treturn;\n\t\t}\n\telse if ((flags & ACC_STATIC) == 0) {\n\t\tbugReporter.reportBug(new BugInstance(\"SE_NONSTATIC_SERIALVERSIONID\", NORMAL_PRIORITY)\n\t\t\t.addClass(this)\n\t\t\t.addVisitedField(this));\n\t\treturn;\n\t\t}\n\telse if ((flags & ACC_FINAL) == 0) {\n\t\tbugReporter.reportBug(new BugInstance(\"SE_NONFINAL_SERIALVERSIONID\", NORMAL_PRIORITY)\n\t\t\t.addClass(this)\n\t\t\t.addVisitedField(this));\n\t\treturn;\n\t\t}\n\tsawSerialVersionUID = true;\n\t}","id":90259,"modified_method":"public void visit(Field obj) {\n\tint flags = obj.getAccessFlags();\n\n\tif (className.indexOf(\"ObjectStreamClass\") == -1\n\t    && isSerializable && fieldSig.indexOf(\"L\")  >= 0 && !obj.isTransient() && !obj.isStatic()) {\n\t\ttry {\n\t\t\tString fieldClassName = fieldSig.substring(fieldSig.indexOf(\"L\")+1, fieldSig.length() - 1).replace('/', '.');\n\t\t\tJavaClass fieldClass = Repository.lookupClass(fieldClassName);\n\n\t\t\tif (!fieldClassName.equals(\"java.lang.Object\") &&\n\t\t\t    !(Repository.instanceOf(fieldClass, \"java.io.Serializable\")\n\t\t\t\t|| Repository.instanceOf(fieldClass, \"java.io.Externalizable\"))) {\n\t\t\t\t// Priority is higher if the class directly\n\t\t\t\t// implements Serializable.\n\t\t\t\tint priority = implementsSerializableDirectly ? HIGH_PRIORITY : NORMAL_PRIORITY;\n\n\t\t\t\t// Lower the priority for fields which are of an interface\n\t\t\t\t// or abstract type, since the user may know that all subtypes of\n\t\t\t\t// the interface will be Serializable.\n\t\t\t\tif (fieldClass.isInterface() || fieldClass.isAbstract())\n\t\t\t\t    priority = Math.max(LOW_PRIORITY, priority + 1);\n\n\t\t\t\t// Report is queued until after the entire class has been seen.\n\t\t\t\tfieldWarningList.add(new BugInstance(\"SE_BAD_FIELD\", priority)\n\t\t\t\t\t.addClass(thisClass.getClassName())\n\t\t\t\t\t.addField(fieldClassName, obj.getName(), fieldSig, false)\n\t\t\t\t\t.addUnknownSourceLine(thisClass.getClassName(), thisClass.getSourceFileName()));\n\t\t\t}\n\t\t} catch (ClassNotFoundException e) {\n\t\t\tbugReporter.reportMissingClass(e);\n\t\t}\n\t}\n\n\tif (!fieldName.startsWith(\"this\") \n\t\t&& isSynthetic(obj)) foundSynthetic = true;\n\tif (!fieldName.equals(\"serialVersionUID\")) return;\n\tint mask = ACC_STATIC | ACC_FINAL;\n\tif ( !fieldSig.equals(\"I\")\n\t\t\t && !fieldSig.equals(\"J\")) return;\n\tif ((flags & mask) == mask \n\t\t&& fieldSig.equals(\"I\")) {\n\t\tbugReporter.reportBug(new BugInstance(\"SE_NONLONG_SERIALVERSIONID\", LOW_PRIORITY)\n\t\t\t.addClass(this)\n\t\t\t.addVisitedField(this));\n\t\tsawSerialVersionUID = true;\n\t\treturn;\n\t\t}\n\telse if ((flags & ACC_STATIC) == 0) {\n\t\tbugReporter.reportBug(new BugInstance(\"SE_NONSTATIC_SERIALVERSIONID\", NORMAL_PRIORITY)\n\t\t\t.addClass(this)\n\t\t\t.addVisitedField(this));\n\t\treturn;\n\t\t}\n\telse if ((flags & ACC_FINAL) == 0) {\n\t\tbugReporter.reportBug(new BugInstance(\"SE_NONFINAL_SERIALVERSIONID\", NORMAL_PRIORITY)\n\t\t\t.addClass(this)\n\t\t\t.addVisitedField(this));\n\t\treturn;\n\t\t}\n\tsawSerialVersionUID = true;\n\t}","commit_id":"b85604eb4f1cd3c6c0d48015cc14b0a6c4fbc920","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"private static String sendJSonPostRequest(String url, String json, Map<String, String> headers) {\n    SimpleAsyncHttpClient.Builder builder = new SimpleAsyncHttpClient.Builder()\n      .setUrl(url)\n      .setRequestTimeoutInMs((int) METRICS_SERVER_RESPONSE_TIMEOUT)\n      .setHeader(\"Content-Type\", \"application/json\");\n    if (headers != null) {\n      for (Map.Entry<String, String> header: headers.entrySet()) {\n        builder.addHeader(header.getKey(), header.getValue());\n      }\n    }\n    SimpleAsyncHttpClient asyncClient = builder.build();\n\n    try {\n      Future<Response> future =\n        asyncClient.post(new InputStreamBodyGenerator(new ByteArrayInputStream(json.getBytes())));\n      Response response = future.get(REQUEST_TIMEOUT, TimeUnit.MILLISECONDS);\n      String body =  response.getResponseBody();\n      if (response.getStatusCode() != 200) {\n        throw new RuntimeException(\"Status code \" + response.getStatusCode() + \":\" + body);\n      }\n      return body;\n    } catch (IOException e) {\n      throw Throwables.propagate(e);\n    } catch (InterruptedException e) {\n      throw Throwables.propagate(e);\n    } catch (ExecutionException e) {\n      throw Throwables.propagate(e);\n    } catch (TimeoutException e) {\n      throw Throwables.propagate(e);\n    } finally {\n      asyncClient.close();\n    }\n  }","id":90260,"modified_method":"private static String sendJSonPostRequest(String url, String json, Map<String, String> headers) {\n    SimpleAsyncHttpClient.Builder builder = new SimpleAsyncHttpClient.Builder()\n      .setUrl(url)\n      .setRequestTimeoutInMs((int) METRICS_SERVER_RESPONSE_TIMEOUT)\n      .setHeader(\"Content-Type\", \"application/json\");\n    if (headers != null) {\n      for (Map.Entry<String, String> header: headers.entrySet()) {\n        builder.addHeader(header.getKey(), header.getValue());\n      }\n    }\n    SimpleAsyncHttpClient asyncClient = builder.build();\n\n    try {\n      Future<Response> future =\n        asyncClient.post(new InputStreamBodyGenerator(new ByteArrayInputStream(json.getBytes())));\n      Response response = future.get(REQUEST_TIMEOUT, TimeUnit.MILLISECONDS);\n      String body =  response.getResponseBody();\n      if (response.getStatusCode() != 200) {\n        throw new RuntimeException(\"Status code \" + response.getStatusCode() + \":\" + body);\n      }\n      return body;\n    } catch (Exception e) {\n      throw Throwables.propagate(e);\n    } finally {\n      asyncClient.close();\n    }\n  }","commit_id":"7f5ca0651646f7cee286609e8c90f6984686a356","url":"https://github.com/caskdata/cdap"},{"original_method":"private static MetricsClient getMetricsClient() {\n    CConfiguration config = CConfiguration.create();\n\n    String hostname = config.get(MetricsConstants.ConfigKeys.SERVER_ADDRESS, \"localhost\");\n    int port = config.getInt(MetricsConstants.ConfigKeys.SERVER_PORT, 45005);\n    return new MetricsClient(hostname, port);\n  }","id":90261,"modified_method":"private static MetricsClient getMetricsClient() {\n    int attempts = 0;\n    Iterable<Discoverable> it =\n      PerformanceTestRunner.getDiscoveryServiceClient().discover(Constants.SERVICE_METRICS);\n    while (Iterables.isEmpty(it) && (attempts++ < 10)) {\n      try {\n        TimeUnit.MILLISECONDS.sleep(1000);\n      } catch (InterruptedException e) {\n        throw new RuntimeException(String.format(\"Interrupted when trying to locate service '%s'\",\n                                                 Constants.SERVICE_METRICS));\n      }\n    }\n    if (!Iterables.isEmpty(it)) {\n      Discoverable discoverable = it.iterator().next();\n      return new MetricsClient(discoverable.getSocketAddress().getHostName(),\n                               discoverable.getSocketAddress().getPort());\n    } else {\n      throw new RuntimeException(String.format(\"Could not locate service '%s'\", Constants.SERVICE_METRICS));\n    }\n  }","commit_id":"7f5ca0651646f7cee286609e8c90f6984686a356","url":"https://github.com/caskdata/cdap"},{"original_method":"private static void stopAll() {\n      for (MultiThreadedStreamWriter streamWriter : getInstance().streamWriters) {\n        streamWriter.shutdown();\n      }\n      for (MensaMetricsReporter reporter : getInstance().mensaReporters) {\n        reporter.shutdown();\n      }\n    }","id":90262,"modified_method":"private static void stopAll() {\n      for (MultiThreadedStreamWriter streamWriter : getInstance().streamWriters) {\n        streamWriter.shutdown();\n      }\n      for (MensaMetricsReporter reporter : getInstance().mensaReporters) {\n        reporter.shutdown();\n      }\n      if (zkClientService != null) {\n        zkClientService.stopAndWait();\n      }\n    }","commit_id":"7f5ca0651646f7cee286609e8c90f6984686a356","url":"https://github.com/caskdata/cdap"},{"original_method":"private void beforeClass() throws ClassNotFoundException {\n    // initializes Reactor\n    init();\n    Context.getInstance(this);\n\n    if (\"true\".equalsIgnoreCase(config.get(\"perf.reporter.enabled\"))) {\n      String metrics = config.get(\"perf.report.metrics\");\n      if (StringUtils.isNotEmpty(metrics)) {\n        List<String> metricList = ImmutableList.copyOf(metrics.replace(\" \", \"\").split(\",\"));\n        String tags = \"\";\n        int interval = 10;\n        if (StringUtils.isNotEmpty(config.get(\"perf.report.interval\"))) {\n          interval = Integer.valueOf(config.get(\"perf.report.interval\"));\n        }\n        Context.report(metricList, tags, interval);\n      }\n    }\n  }","id":90263,"modified_method":"private void beforeClass() throws ClassNotFoundException {\n    // initializes Reactor\n    init();\n    Context.getInstance(this);\n\n    if (\"true\".equalsIgnoreCase(config.get(\"perf.reporter.enabled\"))) {\n      String metrics = config.get(\"perf.report.metrics\");\n      if (StringUtils.isNotEmpty(metrics)) {\n        List<String> metricList = ImmutableList.copyOf(metrics.replace(\" \", \"\").split(\",\"));\n        String tags = \"\";\n        int interval = 10;\n        if (StringUtils.isNotEmpty(config.get(\"perf.report.interval\"))) {\n          interval = Integer.valueOf(config.get(\"perf.report.interval\"));\n        }\n        Context.report(metricList, tags, interval);\n      }\n    }\n    if (zkClientService != null) {\n      zkClientService.startAndWait();\n    }\n  }","commit_id":"7f5ca0651646f7cee286609e8c90f6984686a356","url":"https://github.com/caskdata/cdap"},{"original_method":"private void init() {\n    LOG.debug(\"Initializing Continuuity Reactor for a performance test.\");\n    File testAppDir = Files.createTempDir();\n\n    File outputDir = new File(testAppDir, \"app\");\n    File tmpDir = new File(testAppDir, \"tmp\");\n    tmpDir.deleteOnExit();\n    outputDir.mkdirs();\n    tmpDir.mkdirs();\n\n    config.set(\"app.output.dir\", outputDir.getAbsolutePath());\n    config.set(\"app.tmp.dir\", tmpDir.getAbsolutePath());\n\n    try {\n      appFabricServer = getAppFabricClient(config);\n    } catch (TTransportException e) {\n      LOG.error(\"Error when trying to open connection with remote AppFabric.\");\n      Throwables.propagate(e);\n    }\n\n    Module dataFabricModule;\n    if (config.get(\"perf.datafabric.mode\") != null\n      && config.get(\"perf.datafabric.mode\").equals(\"distributed\")) {\n      dataFabricModule = new DataFabricModules().getDistributedModules();\n    } else {\n      dataFabricModule = new DataFabricModules().getSingleNodeModules();\n    }\n\n    try {\n      injector = Guice\n        .createInjector(dataFabricModule,\n                        new ConfigModule(config),\n                        new IOModule(),\n                        new LocationRuntimeModule().getInMemoryModules(),\n                        new DiscoveryRuntimeModule().getInMemoryModules(),\n                        new ProgramRunnerRuntimeModule().getInMemoryModules(),\n                        new MetricsClientRuntimeModule().getInMemoryModules(),\n                        new AbstractModule() {\n            @Override\n            protected void configure() {\n              install(new FactoryModuleBuilder().implement(ApplicationManager.class,\n                                                           DefaultBenchmarkManager.class).build\n                (BenchmarkManagerFactory.class));\n              install(new FactoryModuleBuilder().implement(StreamWriter.class,\n                                                           MultiThreadedStreamWriter.class).build\n                (BenchmarkStreamWriterFactory.class));\n              install(new FactoryModuleBuilder().implement(ProcedureClient.class,\n                                                           DefaultProcedureClient.class).build\n                (ProcedureClientFactory.class));\n            }\n          }, new Module() {\n            @Override\n            public void configure(Binder binder) {\n              binder.bind(new TypeLiteral<PipelineFactory<?>>() {\n              }).to(new TypeLiteral<SynchronousPipelineFactory<?>>() {\n              });\n              binder.bind(ManagerFactory.class).to(SyncManagerFactory.class);\n\n              binder.bind(AuthorizationFactory.class).to(PassportAuthorizationFactory.class);\n              binder.bind(MetadataService.Iface.class).to(com.continuuity.metadata.MetadataService.class);\n              binder.bind(AppFabricService.Iface.class).toInstance(appFabricServer);\n              binder.bind(MetaDataStore.class).to(SerializingMetaDataStore.class);\n              binder.bind(StoreFactory.class).to(MDSStoreFactory.class);\n              binder.bind(AuthToken.class).toInstance(TestHelper.DUMMY_AUTH_TOKEN);\n            }\n            @Provides\n            @Named(Constants.CFG_APP_FABRIC_SERVER_ADDRESS)\n            public InetAddress providesHostname(CConfiguration cConf) {\n              return Networks.resolve(cConf.get(Constants.CFG_APP_FABRIC_SERVER_ADDRESS),\n                                      new InetSocketAddress(\"localhost\", 0).getAddress());\n            }\n          }\n        );\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n\n    locationFactory = injector.getInstance(LocationFactory.class);\n    discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n  }","id":90264,"modified_method":"private void init() {\n    LOG.debug(\"Initializing Continuuity Reactor for a performance test.\");\n    File testAppDir = Files.createTempDir();\n\n    File outputDir = new File(testAppDir, \"app\");\n    File tmpDir = new File(testAppDir, \"tmp\");\n    tmpDir.deleteOnExit();\n    outputDir.mkdirs();\n    tmpDir.mkdirs();\n\n    config.set(\"app.output.dir\", outputDir.getAbsolutePath());\n    config.set(\"app.tmp.dir\", tmpDir.getAbsolutePath());\n\n    try {\n      appFabricServer = getAppFabricClient(config);\n    } catch (TTransportException e) {\n      LOG.error(\"Error when trying to open connection with remote AppFabric.\");\n      Throwables.propagate(e);\n    }\n\n    Module dataFabricModule;\n    Module discoveryServiceModule;\n    Module locationModule;\n    Module programRunnerModule;\n    Module metricsClientModule;\n\n    try {\n      if (config.get(\"perf.reactor.mode\") != null\n        && config.get(\"perf.reactor.mode\").equals(\"distributed\")) {\n        dataFabricModule = new DataFabricModules().getDistributedModules();\n        locationModule = new LocationRuntimeModule().getDistributedModules();\n        programRunnerModule = new ProgramRunnerRuntimeModule().getDistributedModules();\n        metricsClientModule = new MetricsClientRuntimeModule().getInMemoryModules();\n        zkClientService =\n          ZKClientServices.delegate(\n            ZKClients.reWatchOnExpire(\n              ZKClients.retryOnFailure(\n                ZKClientService.Builder.of(\n                  config.get(Constants.CFG_ZOOKEEPER_ENSEMBLE)).setSessionTimeout(10000).build(),\n                RetryStrategies.fixDelay(2, TimeUnit.SECONDS))));\n        discoveryServiceModule = new DiscoveryRuntimeModule(zkClientService).getDistributedModules();\n      } else {\n        dataFabricModule = new DataFabricModules().getSingleNodeModules();\n        locationModule = new LocationRuntimeModule().getInMemoryModules();\n        programRunnerModule = new ProgramRunnerRuntimeModule().getInMemoryModules();\n        metricsClientModule = new MetricsClientRuntimeModule().getInMemoryModules();\n        discoveryServiceModule = new AbstractModule() {\n          @Override\n          protected void configure() {\n            final String host = config.get(MetricsConstants.ConfigKeys.SERVER_ADDRESS, \"localhost\");\n            final int port = config.getInt(MetricsConstants.ConfigKeys.SERVER_PORT, 45005);\n\n            bind(DiscoveryServiceClient.class).toInstance(new DiscoveryServiceClient() {\n              @Override\n              public Iterable<Discoverable> discover(final String name) {\n                if (Constants.SERVICE_METRICS.equals(name)) {\n                  return ImmutableList.<Discoverable>of(new Discoverable() {\n                    @Override\n                    public String getName() {\n                      return name;\n                    }\n\n                    @Override\n                    public InetSocketAddress getSocketAddress() {\n                      return new InetSocketAddress(host, port);\n                    }\n                  });\n                } else {\n                  return ImmutableList.of();\n                }\n              }\n            });\n            bind(DiscoveryService.class).toInstance(new InMemoryDiscoveryService());\n          }\n        };\n      }\n\n      injector = Guice\n        .createInjector(dataFabricModule,\n                        discoveryServiceModule,\n                        new ConfigModule(config),\n                        new IOModule(),\n                        locationModule,\n                        programRunnerModule,\n                        metricsClientModule,\n                        new AbstractModule() {\n                          @Override\n                          protected void configure() {\n                            install(new FactoryModuleBuilder().implement(ApplicationManager.class,\n                                                                         DefaultBenchmarkManager.class).build\n                              (BenchmarkManagerFactory.class));\n                            install(new FactoryModuleBuilder().implement(StreamWriter.class,\n                                                                         MultiThreadedStreamWriter.class).build\n                              (BenchmarkStreamWriterFactory.class));\n                            install(new FactoryModuleBuilder().implement(ProcedureClient.class,\n                                                                         DefaultProcedureClient.class).build\n                              (ProcedureClientFactory.class));\n                          }\n                        }, new Module() {\n            @Override\n            public void configure(Binder binder) {\n              binder.bind(new TypeLiteral<PipelineFactory<?>>() {\n              }).to(new TypeLiteral<SynchronousPipelineFactory<?>>() {\n              });\n              binder.bind(ManagerFactory.class).to(SyncManagerFactory.class);\n\n              binder.bind(AuthorizationFactory.class).to(PassportAuthorizationFactory.class);\n              binder.bind(MetadataService.Iface.class).to(com.continuuity.metadata.MetadataService.class);\n              binder.bind(AppFabricService.Iface.class).toInstance(appFabricServer);\n              binder.bind(MetaDataStore.class).to(SerializingMetaDataStore.class);\n              binder.bind(StoreFactory.class).to(MDSStoreFactory.class);\n              binder.bind(AuthToken.class).toInstance(TestHelper.DUMMY_AUTH_TOKEN);\n            }\n            @Provides\n            @Named(Constants.CFG_APP_FABRIC_SERVER_ADDRESS)\n            @SuppressWarnings(value = \"unused\")\n            public InetAddress providesHostname(CConfiguration cConf) {\n              return Networks.resolve(cConf.get(Constants.CFG_APP_FABRIC_SERVER_ADDRESS),\n                                      new InetSocketAddress(\"localhost\", 0).getAddress());\n            }\n          }\n        );\n    } catch (Exception e) {\n      LOG.error(\"Failure during initial bind and injection : \" + e.getMessage(), e);\n      Throwables.propagate(e);\n    }\n    locationFactory = injector.getInstance(LocationFactory.class);\n    discoveryServiceClient = injector.getInstance(DiscoveryServiceClient.class);\n  }","commit_id":"7f5ca0651646f7cee286609e8c90f6984686a356","url":"https://github.com/caskdata/cdap"},{"original_method":"public void setMacroURI(String uri) {\n\t\tif (!Objects.equals(_uri, uri)) {\n\t\t\tif (uri != null && uri.length() == 0)\n\t\t\t\tthrow new IllegalArgumentException(\"empty uri\");\n\t\t\t_uri = uri;\n\t\t\trecreate();\n\t\t}\n\t}","id":90265,"modified_method":"public void setMacroURI(String uri) {\n\t\tif (!Objects.equals(_uri, uri)) {\n\t\t\tif (uri != null && uri.length() == 0)\n\t\t\t\tthrow new IllegalArgumentException(\"empty uri\");\n\t\t\t_uri = uri;\n\t\t\tif (getParent() != null)\n\t\t\t\trecreate();\n\t\t}\n\t}","commit_id":"dcb0d2951fdf04ad03443aba055af4c76c78c61a","url":"https://github.com/zkoss/zk"},{"original_method":"protected Object getFromNamespace(String name) {\n\t\t\treturn BSHInterpreter.this.getFromNamespace(name);\n\t\t}","id":90266,"modified_method":"protected Object getFromNamespace(String name) {\n\t\t\treturn BSHInterpreter.this.getFromNamespace(name, true);\n\t\t\t\t//local-only since getVariableImpl will look up its parent\n\t\t}","commit_id":"d7fb0c4e112392517c61d9b584564110292574b3","url":"https://github.com/zkoss/zk"},{"original_method":"/** Search _ns instead. */\n\t\tprotected Object getFromNamespace(String name) {\n\t\t\tfinal BSHInterpreter ip = getInterpreter();\n\t\t\treturn ip != null ? ip.getFromNamespace(_ns, name):\n\t\t\t\t_ns.getVariable(name, false);\n\t\t}","id":90267,"modified_method":"/** Search _ns instead. */\n\t\tprotected Object getFromNamespace(String name) {\n\t\t\tfinal BSHInterpreter ip = getInterpreter();\n\t\t\tif (ip != null)\n\t\t\t\treturn ip.getFromNamespace(_ns, name, true);\n\t\t\t\t//local-only since getVariableImpl will look up its parent\n\t\t\tObject v = _ns.getVariable(name, true);\n\t\t\treturn v != null || _ns.containsVariable(name, true) ? v: UNDEFINED; \n\t\t\t\t//local-only since getVariableImpl will look up its parent\n\t\t}","commit_id":"d7fb0c4e112392517c61d9b584564110292574b3","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the variable through the specified namespaces and\n\t * variable resolvers, or {@link #UNDEFINED} if the variable is not\n\t * defined.\n\t *\n\t * <p>It is usually called to search namespaces and variable resolvers,\n\t * when the real interpreter failed to find a variable in its own scope.\n\t *\n\t * <p>This method is used with the interpreter that supports\n\t * hierachical scopes ({@link org.zkoss.zk.scripting.HierachicalAware}).\n\t *\n\t * @param ns the namespace to search from (never null).\n\t * Note: if {@link #getCurrent} returns null, this method simply returns\n\t * null (i.e., ignoring ns).\n\t */\n\tprotected Object getFromNamespace(Namespace ns, String name) {\n\t\tif (getCurrent() != null) {\n\t\t\tObject val = ns.getVariable(name, false);\n\t\t\tif (val != null || ns.containsVariable(name, false))\n\t\t\t\treturn val;\n\t\t}\n\t\treturn getImplicit(name);\n\t}","id":90268,"modified_method":"/** It is a shortcut of getFromNamespace(ns, name, false).\n\t * @see #getFromNamespace(Namespace, String, boolean)\n\t */\n\tprotected Object getFromNamespace(Namespace ns, String name) {\n\t\treturn getFromNamespace(ns, name, false);\n\t}","commit_id":"d7fb0c4e112392517c61d9b584564110292574b3","url":"https://github.com/zkoss/zk"},{"original_method":"/** Returns the variable through namespaces and variable resolvers,\n\t * or {@link #UNDEFINED} if the variable not defined.\n\t *\n\t * <p>It is usually called to search namespaces and variable resolvers,\n\t * when the real interpreter failed to find a variable in its own scope.\n\t *\n\t * <p>Note: We use {@link #UNDEFINED} to denote undefined since 2.4.0,\n\t * while null is a valid value.\n\t */\n\tprotected Object getFromNamespace(String name) {\n\t\tfinal Namespace ns = getCurrent();\n\t\tif (ns != null) {\n\t\t\tObject val = ns.getVariable(name, false);\n\t\t\tif (val != null || ns.containsVariable(name, false))\n\t\t\t\treturn val;\n\t\t}\n\t\treturn getImplicit(name);\n\t}","id":90269,"modified_method":"/** It is a shortcut of getFromNamespace(name, false).\n\t * @see #getFromNamespace(String, boolean)\n\t */\n\tprotected Object getFromNamespace(String name) {\n\t\treturn getFromNamespace(name, false);\n\t}","commit_id":"d7fb0c4e112392517c61d9b584564110292574b3","url":"https://github.com/zkoss/zk"},{"original_method":"public void setMacroURI(String uri) {\n\t\tif (!Objects.equals(_uri, uri)) {\n\t\t\tif (uri != null && uri.length() == 0)\n\t\t\t\tthrow new IllegalArgumentException(\"empty uri\");\n\t\t\t_uri = uri;\n\t\t\trecreate();\n\t\t}\n\t}","id":90270,"modified_method":"public void setMacroURI(String uri) {\n\t\tif (!Objects.equals(_uri, uri)) {\n\t\t\tif (uri != null && uri.length() == 0)\n\t\t\t\tthrow new IllegalArgumentException(\"empty uri\");\n\t\t\t_uri = uri;\n\t\t\tif (getParent() != null)\n\t\t\t\trecreate();\n\t\t}\n\t}","commit_id":"d7fb0c4e112392517c61d9b584564110292574b3","url":"https://github.com/zkoss/zk"},{"original_method":"public void setMacroURI(String uri) {\n\t\tif (!Objects.equals(_uri, uri)) {\n\t\t\tif (uri != null && uri.length() == 0)\n\t\t\t\tthrow new IllegalArgumentException(\"empty uri\");\n\t\t\t_uri = uri;\n\t\t\trecreate();\n\t\t}\n\t}","id":90271,"modified_method":"public void setMacroURI(String uri) {\n\t\tif (!Objects.equals(_uri, uri)) {\n\t\t\tif (uri != null && uri.length() == 0)\n\t\t\t\tthrow new IllegalArgumentException(\"empty uri\");\n\t\t\t_uri = uri;\n\t\t\tif (getParent() != null)\n\t\t\t\trecreate();\n\t\t}\n\t}","commit_id":"a41e70d0f836201d721786125bafe128eed3bf96","url":"https://github.com/zkoss/zk"},{"original_method":"public long receiveData(long value, byte[] buffer) {\n        long diff=System.currentTimeMillis() - value;\n        tot+=diff;\n        num_reqs++;\n\n        long new_val=current_value.incrementAndGet();\n        total_bytes.addAndGet(buffer.length);\n        if(print > 0 && new_val % print == 0)\n            System.out.println(\"received \" + current_value);\n        if(new_val >= num_values) {\n            stop=System.currentTimeMillis();\n            long total_time=stop - start;\n            long msgs_per_sec=(long)(num_values / (total_time / 1000.0));\n            double throughput=total_bytes.get() / (total_time / 1000.0);\n            System.out.println(\"\\n-- received \" + num_values + \" messages in \" + total_time +\n                    \" ms (\" + msgs_per_sec + \" messages/sec, \" + Util.printBytes(throughput) + \" / sec)\");\n\n\n\n            double time_per_req=(double)tot / num_reqs;\n            System.out.println(\"received \" + num_reqs + \"requests in =\" + tot + \" ms, \" + time_per_req + \" ms / req (only request)\\n\");\n\n            started=false;\n            if(exit_on_end)\n                System.exit(0);\n        }\n        return System.currentTimeMillis();\n    }","id":90272,"modified_method":"public long receiveData(long value, byte[] buffer) {\n        long diff=System.currentTimeMillis() - value;\n        tot+=diff;\n        num_reqs++;\n\n        long new_val=current_value.incrementAndGet();\n        total_bytes.addAndGet(buffer.length);\n        if(print > 0 && new_val % print == 0)\n            System.out.println(\"received \" + current_value);\n        if(new_val >= num_values) {\n            stop=System.currentTimeMillis();\n            long total_time=stop - start;\n            long msgs_per_sec=(long)(num_values / (total_time / 1000.0));\n            double throughput=total_bytes.get() / (total_time / 1000.0);\n            System.out.println(\"\\n-- received \" + num_values + \" messages in \" + total_time +\n                    \" ms (\" + msgs_per_sec + \" messages/sec, \" + Util.printBytes(throughput) + \" / sec)\");\n\n\n\n            double time_per_req=(double)tot / num_reqs;\n            System.out.println(\"received \" + num_reqs + \" requests in \" + tot + \" ms, \" + time_per_req +\n                    \" ms / req (only request)\\n\");\n\n            started=false;\n            if(exit_on_end)\n                System.exit(0);\n        }\n        return System.currentTimeMillis();\n    }","commit_id":"d9eb4a9bd7a83d1e51d936e838fdbc9d9bff933f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init(String props, long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob) throws Exception {\n        this.sleep_time=sleep_time;\n        this.exit_on_end=exit_on_end;\n        this.busy_sleep=busy_sleep;\n        this.sync=sync;\n        this.oob=oob;\n        channel=new JChannel(props);\n        disp=new RpcDispatcher(channel, null, this, this);\n        disp.setMethodLookup(new MethodLookup() {\n            public Method findMethod(short id) {\n                return METHODS[id];\n            }\n        });\n        disp.setRequestMarshaller(new CustomMarshaller());\n        channel.connect(groupname);\n\n        try {\n            MBeanServer server=Util.getMBeanServer();\n            JmxConfigurator.registerChannel(channel, server, \"jgroups\", channel.getClusterName(), true);\n        }\n        catch(Throwable ex) {\n            System.err.println(\"registering the channel in JMX failed: \" + ex);\n        }\n    }","id":90273,"modified_method":"public void init(String props, long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob) throws Exception {\n        this.sleep_time=sleep_time;\n        this.exit_on_end=exit_on_end;\n        this.busy_sleep=busy_sleep;\n        this.sync=sync;\n        this.oob=oob;\n        channel=new JChannel(props);\n        disp=new RpcDispatcher(channel, null, this, this);\n        disp.setMethodLookup(new MethodLookup() {\n            public Method findMethod(short id) {\n                return METHODS[id];\n            }\n        });\n        disp.setRequestMarshaller(new CustomMarshaller());\n        channel.connect(groupname);\n        local_addr=channel.getAddress();\n\n        try {\n            MBeanServer server=Util.getMBeanServer();\n            JmxConfigurator.registerChannel(channel, server, \"jgroups\", channel.getClusterName(), true);\n        }\n        catch(Throwable ex) {\n            System.err.println(\"registering the channel in JMX failed: \" + ex);\n        }\n    }","commit_id":"d9eb4a9bd7a83d1e51d936e838fdbc9d9bff933f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            byte[] buf=new byte[msg_size];\n            Object[] args=new Object[]{0, buf};\n            MethodCall call=new MethodCall((short)1, args);\n\n            for(int i=1; i <= number_of_msgs; i++) {\n                args[0]=System.currentTimeMillis();\n                try {\n                    long start=System.currentTimeMillis();\n                    Object retval=disp.callRemoteMethod(destination, call, options);\n                    long current_time=System.currentTimeMillis();\n                    long diff=current_time - start;\n                    total_req+=diff;\n\n                    if(sync) {\n                        if(retval instanceof Long) {\n                            diff=System.currentTimeMillis() - (Long)retval;\n                            total_rsp+=diff;\n                        }\n                    }\n\n                    if(print > 0 && i % print == 0)\n                        System.out.println(\"-- invoked \" + i);\n                    if(sleep_time > 0)\n                        Util.sleep(sleep_time, busy_sleep);\n                }\n                catch(Throwable throwable) {\n                    throwable.printStackTrace();\n                }\n            }\n\n            double time_per_req=total_req / (double)number_of_msgs;\n            System.out.println(\"\\ninvoked \" + number_of_msgs + \" requests in \" + total_req + \" ms: \" + time_per_req +\n                    \" ms / req (entire request)\");\n\n            if(sync) {\n                double time_per_rsp=total_rsp / (double)number_of_msgs;\n                System.out.println(\"received \" + number_of_msgs + \" responses in \" + total_rsp + \" ms: \" + time_per_rsp +\n                        \" ms / rsp (only response)\\n\");\n            }\n\n\n        }","id":90274,"modified_method":"public void run() {\n            byte[] buf=new byte[msg_size];\n            Object[] args=new Object[]{0, buf};\n            MethodCall call=new MethodCall((short)1, args);\n\n            for(int i=1; i <= number_of_msgs; i++) {\n                args[0]=System.currentTimeMillis();\n                Object retval=null;\n                try {\n                    long start=System.currentTimeMillis();\n                    if(dests != null)\n                        disp.callRemoteMethods(dests, call, options);\n                    else\n                        retval=disp.callRemoteMethod(dest, call, options);\n                    long current_time=System.currentTimeMillis();\n                    long diff=current_time - start;\n                    total_req+=diff;\n\n                    if(sync) {\n                        if(retval instanceof Long) {\n                            diff=System.currentTimeMillis() - (Long)retval;\n                            total_rsp+=diff;\n                        }\n                    }\n\n                    if(print > 0 && i % print == 0)\n                        System.out.println(\"-- invoked \" + i);\n                    if(sleep_time > 0)\n                        Util.sleep(sleep_time, busy_sleep);\n                }\n                catch(Throwable throwable) {\n                    throwable.printStackTrace();\n                }\n            }\n\n            double time_per_req=total_req / (double)number_of_msgs;\n            System.out.println(\"\\ninvoked \" + number_of_msgs + \" requests in \" + total_req + \" ms: \" + time_per_req +\n                    \" ms / req (entire request)\");\n\n            if(sync) {\n                double time_per_rsp=total_rsp / (double)number_of_msgs;\n                System.out.println(\"received \" + number_of_msgs + \" responses in \" + total_rsp + \" ms: \" + time_per_rsp +\n                        \" ms / rsp (only response)\\n\");\n            }\n\n\n        }","commit_id":"d9eb4a9bd7a83d1e51d936e838fdbc9d9bff933f","url":"https://github.com/belaban/JGroups"},{"original_method":"public Invoker(Address destination, RequestOptions options, int number_of_msgs) {\n            this.destination=destination;\n            this.options=options;\n            this.number_of_msgs=number_of_msgs;\n        }","id":90275,"modified_method":"public Invoker(Address dest, RequestOptions options, int number_of_msgs) {\n            this.dest=dest;\n            this.dests=null;\n            this.options=options;\n            this.number_of_msgs=number_of_msgs;\n        }","commit_id":"d9eb4a9bd7a83d1e51d936e838fdbc9d9bff933f","url":"https://github.com/belaban/JGroups"},{"original_method":"void invokeRpcs() throws Throwable {\n        Address destination=getReceiver();\n\n        if(num_threads > 1 && num_msgs % num_threads != 0) {\n            System.err.println(\"num_msgs (\" + num_msgs + \" ) has to be divisible by num_threads (\" + num_threads + \")\");\n            return;\n        }\n\n        if(destination == null) {\n            System.err.println(\"UnicastTest.invokeRpcs(): receiver is null, cannot send messages\");\n            return;\n        }\n\n        System.out.println(\"invoking \" + num_msgs + \" RPCs of \" + Util.printBytes(msg_size) + \" on \" +\n                destination + \", sync=\" + sync + \", oob=\" + oob);\n        \n        // The first call needs to be synchronous with OOB !\n        RequestOptions options=new RequestOptions(Request.GET_ALL, 0, false, null);\n        if(sync) options.setFlags(Message.DONT_BUNDLE);\n        if(oob) options.setFlags(Message.OOB);\n\n        disp.callRemoteMethod(destination, new MethodCall((short)0, new Object[]{num_msgs}), options);\n        options.setMode(sync? Request.GET_ALL : Request.GET_NONE);\n\n        Invoker[] invokers=new Invoker[num_threads];\n        for(int i=0; i < invokers.length; i++)\n            invokers[i]=new Invoker(destination, options, num_msgs / num_threads);\n        for(Invoker invoker: invokers)\n            invoker.start();\n        for(Invoker invoker: invokers)\n            invoker.join();\n\n        System.out.println(\"done sending \" + num_msgs + \" to \" + destination);\n    }","id":90276,"modified_method":"void invokeRpcs() throws Throwable {\n        if(num_threads > 1 && num_msgs % num_threads != 0) {\n            System.err.println(\"num_msgs (\" + num_msgs + \" ) has to be divisible by num_threads (\" + num_threads + \")\");\n            return;\n        }\n\n        if(anycasting) {\n            populateAnycastList(channel.getView());\n        }\n        else {\n            if((destination=getReceiver()) == null) {\n                System.err.println(\"UnicastTest.invokeRpcs(): receiver is null, cannot send messages\");\n                return;\n            }\n        }\n\n        System.out.println(\"invoking \" + num_msgs + \" RPCs of \" + Util.printBytes(msg_size) + \" on \" +\n                (anycasting? anycast_mbrs : destination) + \", sync=\" + sync + \", oob=\" + oob + \", anycasting=\" + anycasting);\n        \n        // The first call needs to be synchronous with OOB !\n        RequestOptions options=new RequestOptions(Request.GET_ALL, 0, anycasting, null);\n        if(sync) options.setFlags(Message.DONT_BUNDLE);\n        if(oob) options.setFlags(Message.OOB);\n\n        if(anycasting)\n            disp.callRemoteMethods(anycast_mbrs, new MethodCall((short)0, new Object[]{num_msgs}), options);\n        else\n            disp.callRemoteMethod(destination, new MethodCall((short)0, new Object[]{num_msgs}), options);\n        options.setMode(sync? Request.GET_ALL : Request.GET_NONE);\n\n        Invoker[] invokers=new Invoker[num_threads];\n        for(int i=0; i < invokers.length; i++) {\n            if(anycasting)\n                invokers[i]=new Invoker(anycast_mbrs, options, num_msgs / num_threads);\n            else\n                invokers[i]=new Invoker(destination, options, num_msgs / num_threads);\n        }\n        for(Invoker invoker: invokers)\n            invoker.start();\n        for(Invoker invoker: invokers)\n            invoker.join();\n\n        System.out.println(\"done invoking \" + num_msgs + \" in \" + destination);\n    }","commit_id":"d9eb4a9bd7a83d1e51d936e838fdbc9d9bff933f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void eventLoop() throws Throwable {\n        int c;\n\n        while(true) {\n            System.out.print(\"[1] Send msgs [2] Print view [3] Print conns \" +\n                    \"[4] Trash conn [5] Trash all conns\" +\n                    \"\\n[6] Set sender threads (\" + num_threads + \") [7] Set num msgs (\" + num_msgs + \") \" +\n                    \"[8] Set msg size (\" + Util.printBytes(msg_size) + \")\" +\n                    \"\\n[o] Toggle OOB (\" + oob + \") [s] Toggle sync (\" + sync + \")\" +\n                    \"\\n[q] Quit\\n\");\n            System.out.flush();\n            c=System.in.read();\n            switch(c) {\n            case -1:\n                break;\n            case '1':\n                try {\n                    invokeRpcs();\n                }\n                catch(Throwable t) {\n                    System.err.println(t);\n                }\n                break;\n            case '2':\n                printView();\n                break;\n            case '3':\n                printConnections();\n                break;\n            case '4':\n                removeConnection();\n                break;\n            case '5':\n                removeAllConnections();\n                break;\n            case '6':\n                setSenderThreads();\n                break;\n            case '7':\n                setNumMessages();\n                break;\n            case '8':\n                setMessageSize();\n                break;\n            case 'o':\n                oob=!oob;\n                System.out.println(\"oob=\" + oob);\n                break;\n            case 's':\n                sync=!sync;\n                System.out.println(\"sync=\" + sync);\n                break;\n            case 'q':\n                channel.close();\n                return;\n            default:\n                break;\n            }\n        }\n    }","id":90277,"modified_method":"public void eventLoop() throws Throwable {\n        int c;\n\n        while(true) {\n            System.out.print(\"[1] Send msgs [2] Print view [3] Print conns \" +\n                    \"[4] Trash conn [5] Trash all conns\" +\n                    \"\\n[6] Set sender threads (\" + num_threads + \") [7] Set num msgs (\" + num_msgs + \") \" +\n                    \"[8] Set msg size (\" + Util.printBytes(msg_size) + \")\" +\n                    \" [9] Set anycast count (\" + anycast_count + \")\" +\n                    \"\\n[o] Toggle OOB (\" + oob + \") [s] Toggle sync (\" + sync + \") [a] Toggle anycasting (\" + anycasting + \")\" +\n                    \"\\n[q] Quit\\n\");\n            System.out.flush();\n            c=System.in.read();\n            switch(c) {\n            case -1:\n                break;\n            case '1':\n                try {\n                    invokeRpcs();\n                }\n                catch(Throwable t) {\n                    System.err.println(t);\n                }\n                break;\n            case '2':\n                printView();\n                break;\n            case '3':\n                printConnections();\n                break;\n            case '4':\n                removeConnection();\n                break;\n            case '5':\n                removeAllConnections();\n                break;\n            case '6':\n                setSenderThreads();\n                break;\n            case '7':\n                setNumMessages();\n                break;\n            case '8':\n                setMessageSize();\n                break;\n            case '9':\n                setAnycastCount();\n                break;\n            case 'o':\n                oob=!oob;\n                System.out.println(\"oob=\" + oob);\n                break;\n            case 's':\n                sync=!sync;\n                System.out.println(\"sync=\" + sync);\n                break;\n            case 'a':\n                anycasting=!anycasting;\n                System.out.println(\"anycasting=\" + anycasting);\n                break;\n            case 'q':\n                channel.close();\n                return;\n            default:\n                break;\n            }\n        }\n    }","commit_id":"d9eb4a9bd7a83d1e51d936e838fdbc9d9bff933f","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            byte[] buf=new byte[msg_size];\n            Object[] args=new Object[]{0, buf};\n            MethodCall call=new MethodCall((short)1, args);\n\n            for(int i=1; i <= number_of_msgs; i++) {\n                args[0]=System.currentTimeMillis();\n                try {\n                    long start=System.currentTimeMillis();\n                    Object retval=disp.callRemoteMethod(destination, call, options);\n                    long current_time=System.currentTimeMillis();\n                    long diff=current_time - start;\n                    total_req+=diff;\n\n                    if(sync) {\n                        if(retval instanceof Long) {\n                            diff=System.currentTimeMillis() - (Long)retval;\n                            total_rsp+=diff;\n                        }\n                    }\n\n                    if(print > 0 && i % print == 0)\n                        System.out.println(\"-- invoked \" + i);\n                    if(sleep_time > 0)\n                        Util.sleep(sleep_time, busy_sleep);\n                }\n                catch(Throwable throwable) {\n                    throwable.printStackTrace();\n                }\n            }\n\n            double time_per_req=total_req / (double)number_of_msgs;\n            System.out.println(\"\\ninvoked \" + number_of_msgs + \" requests in \" + total_req + \" ms: \" + time_per_req +\n                    \" ms / req (entire request)\");\n\n            if(sync) {\n                double time_per_rsp=total_rsp / (double)number_of_msgs;\n                System.out.println(\"received \" + number_of_msgs + \" responses in \" + total_rsp + \" ms: \" + time_per_rsp +\n                        \" ms / rsp (only response)\\n\");\n            }\n\n\n        }","id":90278,"modified_method":"public void run() {\n            byte[] buf=new byte[msg_size];\n            Object[] args=new Object[]{0, buf};\n            MethodCall call=new MethodCall((short)1, args);\n\n            for(int i=1; i <= number_of_msgs; i++) {\n                args[0]=System.currentTimeMillis();\n                Object retval=null;\n                try {\n                    long start=System.currentTimeMillis();\n                    if(dests != null)\n                        disp.callRemoteMethods(dests, call, options);\n                    else\n                        retval=disp.callRemoteMethod(dest, call, options);\n                    long current_time=System.currentTimeMillis();\n                    long diff=current_time - start;\n                    total_req+=diff;\n\n                    if(sync) {\n                        if(retval instanceof Long) {\n                            diff=System.currentTimeMillis() - (Long)retval;\n                            total_rsp+=diff;\n                        }\n                    }\n\n                    if(print > 0 && i % print == 0)\n                        System.out.println(\"-- invoked \" + i);\n                    if(sleep_time > 0)\n                        Util.sleep(sleep_time, busy_sleep);\n                }\n                catch(Throwable throwable) {\n                    throwable.printStackTrace();\n                }\n            }\n\n            double time_per_req=total_req / (double)number_of_msgs;\n            System.out.println(\"\\ninvoked \" + number_of_msgs + \" requests in \" + total_req + \" ms: \" + time_per_req +\n                    \" ms / req (entire request)\");\n\n            if(sync) {\n                double time_per_rsp=total_rsp / (double)number_of_msgs;\n                System.out.println(\"received \" + number_of_msgs + \" responses in \" + total_rsp + \" ms: \" + time_per_rsp +\n                        \" ms / rsp (only response)\\n\");\n            }\n\n\n        }","commit_id":"368129702c29ae4d6d68ccc656aa82636aff5d87","url":"https://github.com/belaban/JGroups"},{"original_method":"public void eventLoop() throws Throwable {\n        int c;\n\n        while(true) {\n            System.out.print(\"[1] Send msgs [2] Print view [3] Print conns \" +\n                    \"[4] Trash conn [5] Trash all conns\" +\n                    \"\\n[6] Set sender threads (\" + num_threads + \") [7] Set num msgs (\" + num_msgs + \") \" +\n                    \"[8] Set msg size (\" + Util.printBytes(msg_size) + \")\" +\n                    \"\\n[o] Toggle OOB (\" + oob + \") [s] Toggle sync (\" + sync + \")\" +\n                    \"\\n[q] Quit\\n\");\n            System.out.flush();\n            c=System.in.read();\n            switch(c) {\n            case -1:\n                break;\n            case '1':\n                try {\n                    invokeRpcs();\n                }\n                catch(Throwable t) {\n                    System.err.println(t);\n                }\n                break;\n            case '2':\n                printView();\n                break;\n            case '3':\n                printConnections();\n                break;\n            case '4':\n                removeConnection();\n                break;\n            case '5':\n                removeAllConnections();\n                break;\n            case '6':\n                setSenderThreads();\n                break;\n            case '7':\n                setNumMessages();\n                break;\n            case '8':\n                setMessageSize();\n                break;\n            case 'o':\n                oob=!oob;\n                System.out.println(\"oob=\" + oob);\n                break;\n            case 's':\n                sync=!sync;\n                System.out.println(\"sync=\" + sync);\n                break;\n            case 'q':\n                channel.close();\n                return;\n            default:\n                break;\n            }\n        }\n    }","id":90279,"modified_method":"public void eventLoop() throws Throwable {\n        int c;\n\n        while(true) {\n            System.out.print(\"[1] Send msgs [2] Print view [3] Print conns \" +\n                    \"[4] Trash conn [5] Trash all conns\" +\n                    \"\\n[6] Set sender threads (\" + num_threads + \") [7] Set num msgs (\" + num_msgs + \") \" +\n                    \"[8] Set msg size (\" + Util.printBytes(msg_size) + \")\" +\n                    \" [9] Set anycast count (\" + anycast_count + \")\" +\n                    \"\\n[o] Toggle OOB (\" + oob + \") [s] Toggle sync (\" + sync + \") [a] Toggle anycasting (\" + anycasting + \")\" +\n                    \"\\n[q] Quit\\n\");\n            System.out.flush();\n            c=System.in.read();\n            switch(c) {\n            case -1:\n                break;\n            case '1':\n                try {\n                    invokeRpcs();\n                }\n                catch(Throwable t) {\n                    System.err.println(t);\n                }\n                break;\n            case '2':\n                printView();\n                break;\n            case '3':\n                printConnections();\n                break;\n            case '4':\n                removeConnection();\n                break;\n            case '5':\n                removeAllConnections();\n                break;\n            case '6':\n                setSenderThreads();\n                break;\n            case '7':\n                setNumMessages();\n                break;\n            case '8':\n                setMessageSize();\n                break;\n            case '9':\n                setAnycastCount();\n                break;\n            case 'o':\n                oob=!oob;\n                System.out.println(\"oob=\" + oob);\n                break;\n            case 's':\n                sync=!sync;\n                System.out.println(\"sync=\" + sync);\n                break;\n            case 'a':\n                anycasting=!anycasting;\n                System.out.println(\"anycasting=\" + anycasting);\n                break;\n            case 'q':\n                channel.close();\n                return;\n            default:\n                break;\n            }\n        }\n    }","commit_id":"368129702c29ae4d6d68ccc656aa82636aff5d87","url":"https://github.com/belaban/JGroups"},{"original_method":"public void init(String props, long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob) throws Exception {\n        this.sleep_time=sleep_time;\n        this.exit_on_end=exit_on_end;\n        this.busy_sleep=busy_sleep;\n        this.sync=sync;\n        this.oob=oob;\n        channel=new JChannel(props);\n        disp=new RpcDispatcher(channel, null, this, this);\n        disp.setMethodLookup(new MethodLookup() {\n            public Method findMethod(short id) {\n                return METHODS[id];\n            }\n        });\n        disp.setRequestMarshaller(new CustomMarshaller());\n        channel.connect(groupname);\n\n        try {\n            MBeanServer server=Util.getMBeanServer();\n            JmxConfigurator.registerChannel(channel, server, \"jgroups\", channel.getClusterName(), true);\n        }\n        catch(Throwable ex) {\n            System.err.println(\"registering the channel in JMX failed: \" + ex);\n        }\n    }","id":90280,"modified_method":"public void init(String props, long sleep_time, boolean exit_on_end, boolean busy_sleep, boolean sync, boolean oob) throws Exception {\n        this.sleep_time=sleep_time;\n        this.exit_on_end=exit_on_end;\n        this.busy_sleep=busy_sleep;\n        this.sync=sync;\n        this.oob=oob;\n        channel=new JChannel(props);\n        disp=new RpcDispatcher(channel, null, this, this);\n        disp.setMethodLookup(new MethodLookup() {\n            public Method findMethod(short id) {\n                return METHODS[id];\n            }\n        });\n        disp.setRequestMarshaller(new CustomMarshaller());\n        channel.connect(groupname);\n        local_addr=channel.getAddress();\n\n        try {\n            MBeanServer server=Util.getMBeanServer();\n            JmxConfigurator.registerChannel(channel, server, \"jgroups\", channel.getClusterName(), true);\n        }\n        catch(Throwable ex) {\n            System.err.println(\"registering the channel in JMX failed: \" + ex);\n        }\n    }","commit_id":"368129702c29ae4d6d68ccc656aa82636aff5d87","url":"https://github.com/belaban/JGroups"},{"original_method":"public Invoker(Address destination, RequestOptions options, int number_of_msgs) {\n            this.destination=destination;\n            this.options=options;\n            this.number_of_msgs=number_of_msgs;\n        }","id":90281,"modified_method":"public Invoker(Address dest, RequestOptions options, int number_of_msgs) {\n            this.dest=dest;\n            this.dests=null;\n            this.options=options;\n            this.number_of_msgs=number_of_msgs;\n        }","commit_id":"368129702c29ae4d6d68ccc656aa82636aff5d87","url":"https://github.com/belaban/JGroups"},{"original_method":"void invokeRpcs() throws Throwable {\n        Address destination=getReceiver();\n\n        if(num_threads > 1 && num_msgs % num_threads != 0) {\n            System.err.println(\"num_msgs (\" + num_msgs + \" ) has to be divisible by num_threads (\" + num_threads + \")\");\n            return;\n        }\n\n        if(destination == null) {\n            System.err.println(\"UnicastTest.invokeRpcs(): receiver is null, cannot send messages\");\n            return;\n        }\n\n        System.out.println(\"invoking \" + num_msgs + \" RPCs of \" + Util.printBytes(msg_size) + \" on \" +\n                destination + \", sync=\" + sync + \", oob=\" + oob);\n        \n        // The first call needs to be synchronous with OOB !\n        RequestOptions options=new RequestOptions(Request.GET_ALL, 0, false, null);\n        if(sync) options.setFlags(Message.DONT_BUNDLE);\n        if(oob) options.setFlags(Message.OOB);\n\n        disp.callRemoteMethod(destination, new MethodCall((short)0, new Object[]{num_msgs}), options);\n        options.setMode(sync? Request.GET_ALL : Request.GET_NONE);\n\n        Invoker[] invokers=new Invoker[num_threads];\n        for(int i=0; i < invokers.length; i++)\n            invokers[i]=new Invoker(destination, options, num_msgs / num_threads);\n        for(Invoker invoker: invokers)\n            invoker.start();\n        for(Invoker invoker: invokers)\n            invoker.join();\n\n        System.out.println(\"done sending \" + num_msgs + \" to \" + destination);\n    }","id":90282,"modified_method":"void invokeRpcs() throws Throwable {\n        if(num_threads > 1 && num_msgs % num_threads != 0) {\n            System.err.println(\"num_msgs (\" + num_msgs + \" ) has to be divisible by num_threads (\" + num_threads + \")\");\n            return;\n        }\n\n        if(anycasting) {\n            populateAnycastList(channel.getView());\n        }\n        else {\n            if((destination=getReceiver()) == null) {\n                System.err.println(\"UnicastTest.invokeRpcs(): receiver is null, cannot send messages\");\n                return;\n            }\n        }\n\n        System.out.println(\"invoking \" + num_msgs + \" RPCs of \" + Util.printBytes(msg_size) + \" on \" +\n                (anycasting? anycast_mbrs : destination) + \", sync=\" + sync + \", oob=\" + oob + \", anycasting=\" + anycasting);\n        \n        // The first call needs to be synchronous with OOB !\n        RequestOptions options=new RequestOptions(Request.GET_ALL, 0, anycasting, null);\n        if(sync) options.setFlags(Message.DONT_BUNDLE);\n        if(oob) options.setFlags(Message.OOB);\n\n        if(anycasting)\n            disp.callRemoteMethods(anycast_mbrs, new MethodCall((short)0, new Object[]{num_msgs}), options);\n        else\n            disp.callRemoteMethod(destination, new MethodCall((short)0, new Object[]{num_msgs}), options);\n        options.setMode(sync? Request.GET_ALL : Request.GET_NONE);\n\n        Invoker[] invokers=new Invoker[num_threads];\n        for(int i=0; i < invokers.length; i++) {\n            if(anycasting)\n                invokers[i]=new Invoker(anycast_mbrs, options, num_msgs / num_threads);\n            else\n                invokers[i]=new Invoker(destination, options, num_msgs / num_threads);\n        }\n        for(Invoker invoker: invokers)\n            invoker.start();\n        for(Invoker invoker: invokers)\n            invoker.join();\n\n        System.out.println(\"done invoking \" + num_msgs + \" in \" + destination);\n    }","commit_id":"368129702c29ae4d6d68ccc656aa82636aff5d87","url":"https://github.com/belaban/JGroups"},{"original_method":"public long receiveData(long value, byte[] buffer) {\n        long diff=System.currentTimeMillis() - value;\n        tot+=diff;\n        num_reqs++;\n\n        long new_val=current_value.incrementAndGet();\n        total_bytes.addAndGet(buffer.length);\n        if(print > 0 && new_val % print == 0)\n            System.out.println(\"received \" + current_value);\n        if(new_val >= num_values) {\n            stop=System.currentTimeMillis();\n            long total_time=stop - start;\n            long msgs_per_sec=(long)(num_values / (total_time / 1000.0));\n            double throughput=total_bytes.get() / (total_time / 1000.0);\n            System.out.println(\"\\n-- received \" + num_values + \" messages in \" + total_time +\n                    \" ms (\" + msgs_per_sec + \" messages/sec, \" + Util.printBytes(throughput) + \" / sec)\");\n\n\n\n            double time_per_req=(double)tot / num_reqs;\n            System.out.println(\"received \" + num_reqs + \"requests in =\" + tot + \" ms, \" + time_per_req + \" ms / req (only request)\\n\");\n\n            started=false;\n            if(exit_on_end)\n                System.exit(0);\n        }\n        return System.currentTimeMillis();\n    }","id":90283,"modified_method":"public long receiveData(long value, byte[] buffer) {\n        long diff=System.currentTimeMillis() - value;\n        tot+=diff;\n        num_reqs++;\n\n        long new_val=current_value.incrementAndGet();\n        total_bytes.addAndGet(buffer.length);\n        if(print > 0 && new_val % print == 0)\n            System.out.println(\"received \" + current_value);\n        if(new_val >= num_values) {\n            stop=System.currentTimeMillis();\n            long total_time=stop - start;\n            long msgs_per_sec=(long)(num_values / (total_time / 1000.0));\n            double throughput=total_bytes.get() / (total_time / 1000.0);\n            System.out.println(\"\\n-- received \" + num_values + \" messages in \" + total_time +\n                    \" ms (\" + msgs_per_sec + \" messages/sec, \" + Util.printBytes(throughput) + \" / sec)\");\n\n\n\n            double time_per_req=(double)tot / num_reqs;\n            System.out.println(\"received \" + num_reqs + \" requests in \" + tot + \" ms, \" + time_per_req +\n                    \" ms / req (only request)\\n\");\n\n            started=false;\n            if(exit_on_end)\n                System.exit(0);\n        }\n        return System.currentTimeMillis();\n    }","commit_id":"368129702c29ae4d6d68ccc656aa82636aff5d87","url":"https://github.com/belaban/JGroups"},{"original_method":"@NotNull\n  @Override\n  protected AsyncResult<RunProfileStarter> prepare(@NotNull ExecutionEnvironment environment, @NotNull RunProfileState state) throws ExecutionException {\n    JstdRunProfileState jstdState = JstdRunProfileState.cast(state);\n    if (jstdState.getRunSettings().isExternalServerType()) {\n      return AsyncResult.<RunProfileStarter>done(new MyStarter(null));\n    }\n    JstdToolWindowManager jstdToolWindowManager = JstdToolWindowManager.getInstance(environment.getProject());\n    jstdToolWindowManager.setAvailable(true);\n    JstdServer server = JstdServerRegistry.getInstance().getServer();\n    if (server != null && !server.isStopped()) {\n      return AsyncResult.<RunProfileStarter>done(new MyStarter(server));\n    }\n    final AsyncResult<RunProfileStarter> result = new AsyncResult<RunProfileStarter>();\n    jstdToolWindowManager.restartServer(new NullableConsumer<JstdServer>() {\n      @Override\n      public void consume(@Nullable JstdServer server) {\n        result.setDone(server != null ? new MyStarter(server) : null);\n      }\n    });\n    return result;\n  }","id":90284,"modified_method":"@NotNull\n  @Override\n  protected Promise<RunProfileStarter> prepare(@NotNull ExecutionEnvironment environment, @NotNull RunProfileState state) throws ExecutionException {\n    JstdRunProfileState jstdState = JstdRunProfileState.cast(state);\n    if (jstdState.getRunSettings().isExternalServerType()) {\n      return Promise.<RunProfileStarter>resolve(new MyStarter(null));\n    }\n    JstdToolWindowManager jstdToolWindowManager = JstdToolWindowManager.getInstance(environment.getProject());\n    jstdToolWindowManager.setAvailable(true);\n    JstdServer server = JstdServerRegistry.getInstance().getServer();\n    if (server != null && !server.isStopped()) {\n      return Promise.<RunProfileStarter>resolve(new MyStarter(server));\n    }\n    return jstdToolWindowManager.restartServer()\n      .then(new Function<JstdServer, RunProfileStarter>() {\n        @Override\n        public RunProfileStarter fun(JstdServer server) {\n          return server != null ? new MyStarter(server) : null;\n        }\n      });\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  protected AsyncResult<RunProfileStarter> prepare(@NotNull final ExecutionEnvironment environment, @NotNull RunProfileState state) throws ExecutionException {\n    JstdRunProfileState jstdState = JstdRunProfileState.cast(state);\n    final JstdRunSettings runSettings = jstdState.getRunSettings();\n    if (runSettings.isExternalServerType()) {\n      throw new ExecutionException(\"Local JsTestDriver server running in IDE required for tests debugging\");\n    }\n    JstdToolWindowManager jstdToolWindowManager = JstdToolWindowManager.getInstance(environment.getProject());\n    jstdToolWindowManager.setAvailable(true);\n    JstdServer server = JstdServerRegistry.getInstance().getServer();\n    final AsyncResult<RunProfileStarter> result = new AsyncResult<RunProfileStarter>();\n    if (server != null && !server.isStopped()) {\n      prepareWithServer(environment.getProject(), result, server, runSettings);\n      return result;\n    }\n    jstdToolWindowManager.restartServer(new NullableConsumer<JstdServer>() {\n      @Override\n      public void consume(@Nullable JstdServer server) {\n        if (server != null) {\n          prepareWithServer(environment.getProject(), result, server, runSettings);\n        }\n        else {\n          result.setDone(null);\n        }\n      }\n    });\n    return result;\n  }","id":90285,"modified_method":"@NotNull\n  @Override\n  protected Promise<RunProfileStarter> prepare(@NotNull final ExecutionEnvironment environment, @NotNull RunProfileState state) throws ExecutionException {\n    JstdRunProfileState jstdState = JstdRunProfileState.cast(state);\n    final JstdRunSettings runSettings = jstdState.getRunSettings();\n    if (runSettings.isExternalServerType()) {\n      throw new ExecutionException(\"Local JsTestDriver server running in IDE required for tests debugging\");\n    }\n    JstdToolWindowManager jstdToolWindowManager = JstdToolWindowManager.getInstance(environment.getProject());\n    jstdToolWindowManager.setAvailable(true);\n    JstdServer server = JstdServerRegistry.getInstance().getServer();\n    if (server != null && !server.isStopped()) {\n      return prepareWithServer(environment.getProject(), server, runSettings);\n    }\n\n    return jstdToolWindowManager.restartServer().then(new AsyncFunction<JstdServer, RunProfileStarter>() {\n      @NotNull\n      @Override\n      public Promise<RunProfileStarter> fun(JstdServer server) {\n        return server == null ? Promise.<RunProfileStarter>resolve(null) : prepareWithServer(environment.getProject(), server, runSettings);\n      }\n    });\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void prepareWithServer(@NotNull final Project project,\n                                        @NotNull final AsyncResult<RunProfileStarter> result,\n                                        @NotNull final JstdServer server,\n                                        @NotNull final JstdRunSettings runSettings) {\n    if (server.isReadyForRunningTests()) {\n      final JstdDebugBrowserInfo debugBrowserInfo = JstdDebugBrowserInfo.build(server, runSettings);\n      if (debugBrowserInfo != null) {\n        ActionCallback prepareDebuggerCallback = debugBrowserInfo.getDebugEngine().prepareDebugger(project, debugBrowserInfo.getBrowser());\n        prepareDebuggerCallback.notifyWhenRejected(result).doWhenDone(new Runnable() {\n          @Override\n          public void run() {\n            result.setDone(new MyDebugStarter(server, debugBrowserInfo));\n          }\n        });\n      }\n      else {\n        result.setDone(new RunProfileStarter() {\n          @Nullable\n          @Override\n          public RunContentDescriptor execute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment environment) throws ExecutionException {\n            throw new ExecutionException(\"Please capture Chrome or Firefox and try again\");\n          }\n        });\n      }\n    }\n    else {\n      result.setDone(new JstdRunProgramRunner.JstdRunStarter(server, true));\n    }\n  }","id":90286,"modified_method":"@NotNull\n  private static Promise<RunProfileStarter> prepareWithServer(@NotNull Project project, @NotNull final JstdServer server, @NotNull JstdRunSettings runSettings) {\n    if (server.isReadyForRunningTests()) {\n      final JstdDebugBrowserInfo debugBrowserInfo = JstdDebugBrowserInfo.build(server, runSettings);\n      if (debugBrowserInfo != null) {\n        return debugBrowserInfo.getDebugEngine().prepareDebugger(project, debugBrowserInfo.getBrowser()).then(new Function<Void, RunProfileStarter>() {\n          @Override\n          public RunProfileStarter fun(Void aVoid) {\n            return new MyDebugStarter(server, debugBrowserInfo);\n          }\n        });\n      }\n      else {\n        return Promise.<RunProfileStarter>resolve(new RunProfileStarter() {\n          @Nullable\n          @Override\n          public RunContentDescriptor execute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment environment) throws ExecutionException {\n            throw new ExecutionException(\"Please capture Chrome or Firefox and try again\");\n          }\n        });\n      }\n    }\n    else {\n      return Promise.<RunProfileStarter>resolve(new JstdRunProgramRunner.JstdRunStarter(server, true));\n    }\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  protected AsyncResult<RunProfileStarter> prepare(@NotNull ExecutionEnvironment environment, @NotNull RunProfileState state) throws ExecutionException {\n    JstdRunProfileState jstdState = JstdRunProfileState.cast(state);\n    if (jstdState.getRunSettings().isExternalServerType()) {\n      return AsyncResult.<RunProfileStarter>done(new JstdRunStarter(null, false));\n    }\n    JstdToolWindowManager jstdToolWindowManager = JstdToolWindowManager.getInstance(environment.getProject());\n    jstdToolWindowManager.setAvailable(true);\n    JstdServer server = JstdServerRegistry.getInstance().getServer();\n    if (server != null && !server.isStopped()) {\n      return AsyncResult.<RunProfileStarter>done(new JstdRunStarter(server, false));\n    }\n    final AsyncResult<RunProfileStarter> result = new AsyncResult<RunProfileStarter>();\n    jstdToolWindowManager.restartServer(new NullableConsumer<JstdServer>() {\n      @Override\n      public void consume(@Nullable JstdServer server) {\n        if (server != null) {\n          result.setDone(new JstdRunStarter(server, false));\n        }\n        else {\n          result.setDone(null);\n        }\n      }\n    });\n    return result;\n  }","id":90287,"modified_method":"@NotNull\n  @Override\n  protected Promise<RunProfileStarter> prepare(@NotNull ExecutionEnvironment environment, @NotNull RunProfileState state) throws ExecutionException {\n    JstdRunProfileState jstdState = JstdRunProfileState.cast(state);\n    if (jstdState.getRunSettings().isExternalServerType()) {\n      return Promise.<RunProfileStarter>resolve(new JstdRunStarter(null, false));\n    }\n    JstdToolWindowManager jstdToolWindowManager = JstdToolWindowManager.getInstance(environment.getProject());\n    jstdToolWindowManager.setAvailable(true);\n    JstdServer server = JstdServerRegistry.getInstance().getServer();\n    if (server != null && !server.isStopped()) {\n      return Promise.<RunProfileStarter>resolve(new JstdRunStarter(server, false));\n    }\n    return jstdToolWindowManager.restartServer().then(new Function<JstdServer, RunProfileStarter>() {\n      @Override\n      public RunProfileStarter fun(JstdServer server) {\n        return server == null ? null : new JstdRunStarter(server, false);\n      }\n    });\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void showServerStartupError(@NotNull Exception ex) {\n    myConsoleView.clear();\n    StringWriter buffer = new StringWriter();\n    PrintWriter printer = new PrintWriter(buffer);\n    try {\n      ex.printStackTrace(printer);\n    }\n    finally {\n      printer.close();\n    }\n    myConsoleView.print(buffer.getBuffer().toString(), ConsoleViewContentType.ERROR_OUTPUT);\n  }","id":90288,"modified_method":"public void showServerStartupError(@NotNull Throwable error) {\n    myConsoleView.clear();\n    StringWriter buffer = new StringWriter();\n    PrintWriter printer = new PrintWriter(buffer);\n    try {\n      error.printStackTrace(printer);\n    }\n    finally {\n      printer.close();\n    }\n    myConsoleView.print(buffer.getBuffer().toString(), ConsoleViewContentType.ERROR_OUTPUT);\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void restartServer(@NotNull final JstdServerSettings settings, @NotNull final CatchingConsumer<JstdServer, Exception> consumer) {\n    JstdServer server = myServer;\n    if (server != null && server.isProcessRunning()) {\n      server.addLifeCycleListener(new JstdServerLifeCycleAdapter() {\n        @Override\n        public void onServerStopped() {\n          myServer = null;\n          doStart(settings, consumer);\n        }\n      }, ApplicationManager.getApplication());\n      server.shutdownAsync();\n    }\n    else {\n      doStart(settings, consumer);\n    }\n  }","id":90289,"modified_method":"@NotNull\n  public Promise<JstdServer> restartServer(@NotNull final JstdServerSettings settings) {\n    JstdServer server = myServer;\n    final AsyncPromise<JstdServer> promise = new AsyncPromise<JstdServer>();\n    if (server != null && server.isProcessRunning()) {\n      server.addLifeCycleListener(new JstdServerLifeCycleAdapter() {\n        @Override\n        public void onServerStopped() {\n          myServer = null;\n          doStart(settings, promise);\n        }\n      }, ApplicationManager.getApplication());\n      server.shutdownAsync();\n      return promise;\n    }\n    else {\n      doStart(settings, promise);\n    }\n    return promise;\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    mySession.saveSettings();\n    mySession.restart(JstdServerSettingsManager.loadSettings(), null);\n  }","id":90290,"modified_method":"@Override\n  public void actionPerformed(AnActionEvent e) {\n    mySession.saveSettings();\n    mySession.restart(JstdServerSettingsManager.loadSettings());\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void showServerStartupError(@NotNull Exception ex) {\n    JstdServerConsoleTab consoleView = getOrRegisterConsoleContent();\n    consoleView.showServerStartupError(ex);\n  }","id":90291,"modified_method":"private void showServerStartupError(@NotNull Throwable error) {\n    JstdServerConsoleTab consoleView = getOrRegisterConsoleContent();\n    consoleView.showServerStartupError(error);\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void restart(@NotNull JstdServerSettings settings, @Nullable final NullableConsumer<JstdServer> callback) {\n    JstdServerRegistry.getInstance().restartServer(settings, new CatchingConsumer<JstdServer, Exception>() {\n      @Override\n      public void consume(JstdServer server) {\n        attachToServer(server);\n        if (callback != null) {\n          callback.consume(server);\n        }\n      }\n\n      @Override\n      public void consume(Exception e) {\n        showServerStartupError(e);\n        if (callback != null) {\n          callback.consume(null);\n        }\n      }\n    });\n  }","id":90292,"modified_method":"@NotNull\n  public Promise<JstdServer> restart(@NotNull JstdServerSettings settings) {\n    return JstdServerRegistry.getInstance().restartServer(settings)\n      .rejected(new Consumer<Throwable>() {\n        @Override\n        public void consume(Throwable error) {\n          showServerStartupError(error);\n        }\n      })\n      .then(new Function<JstdServer, JstdServer>() {\n        @Override\n        public JstdServer fun(JstdServer server) {\n          attachToServer(server);\n          return server;\n        }\n      });\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@NotNull\n  @Override\n  protected AsyncResult<RunProfileStarter> prepare(@NotNull ExecutionEnvironment environment, @NotNull RunProfileState state) throws ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n    final ExecutionResult executionResult = state.execute(environment.getExecutor(), this);\n    if (executionResult == null) {\n      return AsyncResult.done(null);\n    }\n\n    final KarmaConsoleView consoleView = KarmaConsoleView.get(executionResult);\n    if (consoleView == null) {\n      throw new RuntimeException(\"KarmaConsoleView was expected!\");\n    }\n\n    final KarmaServer karmaServer = consoleView.getKarmaExecutionSession().getKarmaServer();\n    if (karmaServer.areBrowsersReady()) {\n      KarmaDebugBrowserSelector browserSelector = new KarmaDebugBrowserSelector(\n        karmaServer.getCapturedBrowsers(),\n        environment,\n        consoleView\n      );\n      final DebuggableWebBrowser debuggableWebBrowser = browserSelector.selectDebugEngine();\n      return prepareDebugger(environment.getProject(), debuggableWebBrowser, new RunProfileStarter() {\n        @Nullable\n        @Override\n        public RunContentDescriptor execute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env) throws ExecutionException {\n          if (debuggableWebBrowser == null) {\n            return new RunContentBuilder(executionResult, env).showRunContent(env.getContentToReuse());\n          }\n          final Url url = Urls.newFromEncoded(karmaServer.formatUrl(\"/debug.html\"));\n          final DebuggableFileFinder fileFinder = getDebuggableFileFinder(karmaServer);\n          XDebugSession session = XDebuggerManager.getInstance(env.getProject()).startSession(\n            env,\n            new XDebugProcessStarter() {\n              @Override\n              @NotNull\n              public XDebugProcess start(@NotNull final XDebugSession session) {\n                JavaScriptDebugEngine debugEngine = debuggableWebBrowser.getDebugEngine();\n                WebBrowser browser = debuggableWebBrowser.getWebBrowser();\n                JavaScriptDebugProcess<? extends VmConnection> debugProcess = debugEngine.createDebugProcess(session, browser, fileFinder, url, executionResult, true);\n                debugProcess.setElementsInspectorEnabled(false);\n                debugProcess.setLayouter(consoleView.createDebugLayouter(debugProcess));\n                return debugProcess;\n              }\n            }\n          );\n          return session.getRunContentDescriptor();\n        }\n      });\n    }\n    else {\n      return AsyncResult.<RunProfileStarter>done(new RunProfileStarter() {\n        @Nullable\n        @Override\n        public RunContentDescriptor execute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env) {\n          RunContentBuilder contentBuilder = new RunContentBuilder(executionResult, env);\n          final RunContentDescriptor descriptor = contentBuilder.showRunContent(env.getContentToReuse());\n          karmaServer.onBrowsersReady(new Runnable() {\n            @Override\n            public void run() {\n              ExecutionUtil.restartIfActive(descriptor);\n            }\n          });\n          return descriptor;\n        }\n      });\n    }\n  }","id":90293,"modified_method":"@NotNull\n  @Override\n  protected Promise<RunProfileStarter> prepare(@NotNull ExecutionEnvironment environment, @NotNull RunProfileState state) throws ExecutionException {\n    FileDocumentManager.getInstance().saveAllDocuments();\n    final ExecutionResult executionResult = state.execute(environment.getExecutor(), this);\n    if (executionResult == null) {\n      return Promise.resolve(null);\n    }\n\n    final KarmaConsoleView consoleView = KarmaConsoleView.get(executionResult);\n    if (consoleView == null) {\n      throw new RuntimeException(\"KarmaConsoleView was expected!\");\n    }\n\n    final KarmaServer karmaServer = consoleView.getKarmaExecutionSession().getKarmaServer();\n    if (karmaServer.areBrowsersReady()) {\n      KarmaDebugBrowserSelector browserSelector = new KarmaDebugBrowserSelector(\n        karmaServer.getCapturedBrowsers(),\n        environment,\n        consoleView\n      );\n      final DebuggableWebBrowser debuggableWebBrowser = browserSelector.selectDebugEngine();\n      return prepareDebugger(environment.getProject(), debuggableWebBrowser, new RunProfileStarter() {\n        @Nullable\n        @Override\n        public RunContentDescriptor execute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env) throws ExecutionException {\n          if (debuggableWebBrowser == null) {\n            return new RunContentBuilder(executionResult, env).showRunContent(env.getContentToReuse());\n          }\n          final Url url = Urls.newFromEncoded(karmaServer.formatUrl(\"/debug.html\"));\n          final DebuggableFileFinder fileFinder = getDebuggableFileFinder(karmaServer);\n          XDebugSession session = XDebuggerManager.getInstance(env.getProject()).startSession(\n            env,\n            new XDebugProcessStarter() {\n              @Override\n              @NotNull\n              public XDebugProcess start(@NotNull final XDebugSession session) {\n                JavaScriptDebugEngine debugEngine = debuggableWebBrowser.getDebugEngine();\n                WebBrowser browser = debuggableWebBrowser.getWebBrowser();\n                JavaScriptDebugProcess<? extends VmConnection> debugProcess = debugEngine.createDebugProcess(session, browser, fileFinder, url, executionResult, true);\n                debugProcess.setElementsInspectorEnabled(false);\n                debugProcess.setLayouter(consoleView.createDebugLayouter(debugProcess));\n                return debugProcess;\n              }\n            }\n          );\n          return session.getRunContentDescriptor();\n        }\n      });\n    }\n    else {\n      return Promise.<RunProfileStarter>resolve(new RunProfileStarter() {\n        @Nullable\n        @Override\n        public RunContentDescriptor execute(@NotNull RunProfileState state, @NotNull ExecutionEnvironment env) {\n          RunContentBuilder contentBuilder = new RunContentBuilder(executionResult, env);\n          final RunContentDescriptor descriptor = contentBuilder.showRunContent(env.getContentToReuse());\n          karmaServer.onBrowsersReady(new Runnable() {\n            @Override\n            public void run() {\n              ExecutionUtil.restartIfActive(descriptor);\n            }\n          });\n          return descriptor;\n        }\n      });\n    }\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static AsyncResult<RunProfileStarter> prepareDebugger(@NotNull final Project project,\n                                                               @Nullable final DebuggableWebBrowser debuggableWebBrowser,\n                                                               @NotNull final RunProfileStarter starter) {\n    if (debuggableWebBrowser == null) {\n      return AsyncResult.done(starter);\n    }\n    else {\n      final AsyncResult<RunProfileStarter> result = new AsyncResult<RunProfileStarter>();\n      JavaScriptDebugEngine debugEngine = debuggableWebBrowser.getDebugEngine();\n      WebBrowser browser = debuggableWebBrowser.getWebBrowser();\n      debugEngine.prepareDebugger(project, browser).notifyWhenRejected(result).doWhenDone(new Runnable() {\n        @Override\n        public void run() {\n          result.setDone(starter);\n        }\n      });\n      return result;\n    }\n  }","id":90294,"modified_method":"public static Promise<RunProfileStarter> prepareDebugger(@NotNull Project project, @Nullable DebuggableWebBrowser debuggableWebBrowser, @NotNull final RunProfileStarter starter) {\n    if (debuggableWebBrowser == null) {\n      return Promise.resolve(starter);\n    }\n    else {\n      return debuggableWebBrowser.getDebugEngine().prepareDebugger(project, debuggableWebBrowser.getWebBrowser())\n        .then(new Function<Void, RunProfileStarter>() {\n          @Override\n          public RunProfileStarter fun(Void aVoid) {\n            return starter;\n          }\n        });\n    }\n  }","commit_id":"76579bc434c092a3d5cdb8b7e17be857de413c2b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\r\n\tpublic void putInteger (String key, int val) {\r\n\t\tEditor edit = this.sharedPrefs.edit();\r\n\t\tedit.putInt(key, val);\r\n\t\tedit.commit();\r\n\t}","id":90295,"modified_method":"@Override\r\n\tpublic void putInteger (String key, int val) {\r\n\t\tedit();\r\n\t\teditor.putInt(key, val);\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void putString (String key, String val) {\r\n\t\tEditor edit = this.sharedPrefs.edit();\r\n\t\tedit.putString(key, val);\r\n\t\tedit.commit();\r\n\t}","id":90296,"modified_method":"@Override\r\n\tpublic void putString (String key, String val) {\r\n\t\tedit();\r\n\t\teditor.putString(key, val);\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void putBoolean (String key, boolean val) {\r\n\t\tEditor edit = this.sharedPrefs.edit();\r\n\t\tedit.putBoolean(key, val);\r\n\t\tedit.commit();\r\n\t}","id":90297,"modified_method":"@Override\r\n\tpublic void putBoolean (String key, boolean val) {\r\n\t\tedit();\r\n\t\teditor.putBoolean(key, val);\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void putFloat (String key, float val) {\r\n\t\tEditor edit = this.sharedPrefs.edit();\r\n\t\tedit.putFloat(key, val);\r\n\t\tedit.commit();\r\n\t}","id":90298,"modified_method":"@Override\r\n\tpublic void putFloat (String key, float val) {\r\n\t\tedit();\r\n\t\teditor.putFloat(key, val);\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void put (Map<String, ?> vals) {\r\n\t\tEditor edit = this.sharedPrefs.edit();\r\n\t\tfor (Entry<String, ?> val : vals.entrySet()) {\r\n\t\t\tif (val.getValue() instanceof Boolean) putBoolean(val.getKey(), (Boolean)val.getValue());\r\n\t\t\tif (val.getValue() instanceof Integer) putInteger(val.getKey(), (Integer)val.getValue());\r\n\t\t\tif (val.getValue() instanceof Long) putLong(val.getKey(), (Long)val.getValue());\r\n\t\t\tif (val.getValue() instanceof String) putString(val.getKey(), (String)val.getValue());\r\n\t\t\tif (val.getValue() instanceof Float) putFloat(val.getKey(), (Float)val.getValue());\r\n\t\t}\r\n\t\tedit.commit();\r\n\t}","id":90299,"modified_method":"@Override\r\n\tpublic void put (Map<String, ?> vals) {\r\n\t\tedit();\r\n\t\tfor (Entry<String, ?> val : vals.entrySet()) {\r\n\t\t\tif (val.getValue() instanceof Boolean) putBoolean(val.getKey(), (Boolean)val.getValue());\r\n\t\t\tif (val.getValue() instanceof Integer) putInteger(val.getKey(), (Integer)val.getValue());\r\n\t\t\tif (val.getValue() instanceof Long) putLong(val.getKey(), (Long)val.getValue());\r\n\t\t\tif (val.getValue() instanceof String) putString(val.getKey(), (String)val.getValue());\r\n\t\t\tif (val.getValue() instanceof Float) putFloat(val.getKey(), (Float)val.getValue());\r\n\t\t}\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void flush () {\r\n\t}","id":90300,"modified_method":"@Override\r\n\tpublic void flush () {\r\n\t\tif (editor != null) {\r\n\t\t\teditor.commit();\r\n\t\t\teditor = null;\r\n\t\t}\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void putLong (String key, long val) {\r\n\t\tEditor edit = this.sharedPrefs.edit();\r\n\t\tedit.putLong(key, val);\r\n\t\tedit.commit();\r\n\t}","id":90301,"modified_method":"@Override\r\n\tpublic void putLong (String key, long val) {\r\n\t\tedit();\r\n\t\teditor.putLong(key, val);\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void remove (String key) {\r\n\t\tEditor edit = sharedPrefs.edit();\r\n\t\tedit.remove(key);\r\n\t\tedit.commit();\r\n\t}","id":90302,"modified_method":"@Override\r\n\tpublic void remove (String key) {\r\n\t\tedit();\r\n\t\teditor.remove(key);\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\r\n\tpublic void clear () {\r\n\t\tEditor edit = sharedPrefs.edit();\r\n\t\tedit.clear();\r\n\t\tedit.commit();\r\n\t}","id":90303,"modified_method":"@Override\r\n\tpublic void clear () {\r\n\t\tedit();\r\n\t\teditor.clear();\r\n\t}","commit_id":"bf327ea729c819646a852845eb997bc6e2bc5301","url":"https://github.com/libgdx/libgdx"},{"original_method":"@Override\n    public Object getValue(EvaluationContext ctx)\n            throws ELException {\n\n        FunctionMapper fnMapper = ctx.getFunctionMapper();\n\n        // quickly validate again for this request\n        if (fnMapper == null) {\n            throw new ELException(MessageFactory.get(\"error.fnMapper.null\"));\n        }\n        Method m = fnMapper.resolveFunction(this.prefix, this.localName);\n        if (m == null) {\n            throw new ELException(MessageFactory.get(\"error.fnMapper.method\",\n                    this.getOutputName()));\n        }\n\n        Class<?>[] paramTypes = m.getParameterTypes();\n        Object[] params = null;\n        Object result = null;\n        int numParams = this.jjtGetNumChildren();\n        if (numParams > 0) {\n            params = new Object[numParams];\n            try {\n                for (int i = 0; i < numParams; i++) {\n                    params[i] = this.children[i].getValue(ctx);\n                    params[i] = coerceToType(params[i], paramTypes[i]);\n                }\n            } catch (ELException ele) {\n                throw new ELException(MessageFactory.get(\"error.function\", this\n                        .getOutputName()), ele);\n            }\n        }\n        try {\n            result = m.invoke(null, params);\n        } catch (IllegalAccessException iae) {\n            throw new ELException(MessageFactory.get(\"error.function\", this\n                    .getOutputName()), iae);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause instanceof ThreadDeath) {\n                throw (ThreadDeath) cause;\n            }\n            if (cause instanceof VirtualMachineError) {\n                throw (VirtualMachineError) cause;\n            }\n            throw new ELException(MessageFactory.get(\"error.function\", this\n                    .getOutputName()), cause);\n        }\n        return result;\n    }","id":90304,"modified_method":"@Override\n    public Object getValue(EvaluationContext ctx)\n            throws ELException {\n\n        FunctionMapper fnMapper = ctx.getFunctionMapper();\n\n        // quickly validate again for this request\n        if (fnMapper == null) {\n            throw new ELException(MessageFactory.get(\"error.fnMapper.null\"));\n        }\n        Method m = fnMapper.resolveFunction(this.prefix, this.localName);\n\n        if (m == null && this.prefix.length() == 0) {\n            // Handle case of lambda expression being set to an EL variable for\n            // later use\n            Object obj =\n                    ctx.getELResolver().getValue(ctx, null, this.localName);\n            if (obj instanceof LambdaExpression) {\n                LambdaExpression le = (LambdaExpression) obj;\n                // Build arguments\n                int numArgs = this.jjtGetNumChildren();\n                Object[] args = new Object[numArgs];\n                for (int i = 0; i < numArgs; i++) {\n                    args[i] = children[i].getValue(ctx);\n                }\n                return le.invoke(ctx, args);\n            }\n        }\n\n        if (m == null) {\n            throw new ELException(MessageFactory.get(\"error.fnMapper.method\",\n                    this.getOutputName()));\n        }\n\n        Class<?>[] paramTypes = m.getParameterTypes();\n        Object[] params = null;\n        Object result = null;\n        int numParams = this.jjtGetNumChildren();\n        if (numParams > 0) {\n            params = new Object[numParams];\n            try {\n                for (int i = 0; i < numParams; i++) {\n                    params[i] = this.children[i].getValue(ctx);\n                    params[i] = coerceToType(params[i], paramTypes[i]);\n                }\n            } catch (ELException ele) {\n                throw new ELException(MessageFactory.get(\"error.function\", this\n                        .getOutputName()), ele);\n            }\n        }\n        try {\n            result = m.invoke(null, params);\n        } catch (IllegalAccessException iae) {\n            throw new ELException(MessageFactory.get(\"error.function\", this\n                    .getOutputName()), iae);\n        } catch (InvocationTargetException ite) {\n            Throwable cause = ite.getCause();\n            if (cause instanceof ThreadDeath) {\n                throw (ThreadDeath) cause;\n            }\n            if (cause instanceof VirtualMachineError) {\n                throw (VirtualMachineError) cause;\n            }\n            throw new ELException(MessageFactory.get(\"error.function\", this\n                    .getOutputName()), cause);\n        }\n        return result;\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Object getValue(EvaluationContext ctx) throws ELException {\n\n        AstLambdaExpression lambdaExpression =\n                (AstLambdaExpression) children[0];\n\n        Object[] args;\n        if (children.length == 2) {\n            args = ((AstMethodParameters) children[1]).getParameters(ctx);\n        } else {\n            // No parameters - just the expression\n            args = null;\n        }\n        return lambdaExpression.invoke(ctx, null, args);\n    }","id":90305,"modified_method":"@Override\n    public Object getValue(EvaluationContext ctx) throws ELException {\n\n        AstLambdaExpression lambdaExpression =\n                (AstLambdaExpression) children[0];\n\n        Object[] args;\n        if (children.length == 2) {\n            args = ((AstMethodParameters) children[1]).getParameters(ctx);\n        } else {\n            // No parameters. AstLambdaExpression contains the logic to handle\n            // this in getValue()\n            return lambdaExpression.getValue(ctx);\n        }\n        return lambdaExpression.invoke(ctx, null, args);\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public VariableMapper getVariableMapper() {\n        return this.varMapper;\n    }","id":90306,"modified_method":"@Override\n    public VariableMapper getVariableMapper() {\n        return varMapper;\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void setPropertyResolved(boolean resolved) {\n        this.elContext.setPropertyResolved(resolved);\n    }","id":90307,"modified_method":"@Override\n    public void setPropertyResolved(boolean resolved) {\n        elContext.setPropertyResolved(resolved);\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void setLocale(Locale locale) {\n        this.elContext.setLocale(locale);\n    }","id":90308,"modified_method":"@Override\n    public void setLocale(Locale locale) {\n        elContext.setLocale(locale);\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public FunctionMapper getFunctionMapper() {\n        return this.fnMapper;\n    }","id":90309,"modified_method":"@Override\n    public FunctionMapper getFunctionMapper() {\n        return fnMapper;\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    // Can't use Class<?> because API needs to match specification in superclass\n    public void putContext(Class key, Object contextObject) {\n        this.elContext.putContext(key, contextObject);\n    }","id":90310,"modified_method":"@Override\n    // Can't use Class<?> because API needs to match specification in superclass\n    public void putContext(Class key, Object contextObject) {\n        elContext.putContext(key, contextObject);\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public ELResolver getELResolver() {\n        return this.elContext.getELResolver();\n    }","id":90311,"modified_method":"@Override\n    public ELResolver getELResolver() {\n        return elContext.getELResolver();\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public Locale getLocale() {\n        return this.elContext.getLocale();\n        }","id":90312,"modified_method":"@Override\n    public Locale getLocale() {\n        return elContext.getLocale();\n        }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    // Can't use Class<?> because API needs to match specification in superclass\n    public Object getContext(Class key) {\n        return this.elContext.getContext(key);\n    }","id":90313,"modified_method":"@Override\n    // Can't use Class<?> because API needs to match specification in superclass\n    public Object getContext(Class key) {\n        return elContext.getContext(key);\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public boolean isPropertyResolved() {\n        return this.elContext.isPropertyResolved();\n    }","id":90314,"modified_method":"@Override\n    public boolean isPropertyResolved() {\n        return elContext.isPropertyResolved();\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"public ELContext getELContext() {\n        return this.elContext;\n    }","id":90315,"modified_method":"public ELContext getELContext() {\n        return elContext;\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public void visit(Node node) throws ELException {\n        if (node instanceof AstFunction) {\n\n            AstFunction funcNode = (AstFunction) node;\n\n            if (this.fnMapper == null) {\n                throw new ELException(MessageFactory.get(\"error.fnMapper.null\"));\n            }\n            Method m = fnMapper.resolveFunction(funcNode.getPrefix(), funcNode\n                    .getLocalName());\n            if (m == null) {\n                throw new ELException(MessageFactory.get(\n                        \"error.fnMapper.method\", funcNode.getOutputName()));\n            }\n            int pcnt = m.getParameterTypes().length;\n            if (node.jjtGetNumChildren() != pcnt) {\n                throw new ELException(MessageFactory.get(\n                        \"error.fnMapper.paramcount\", funcNode.getOutputName(),\n                        \"\" + pcnt, \"\" + node.jjtGetNumChildren()));\n            }\n        } else if (node instanceof AstIdentifier && this.varMapper != null) {\n            String variable = ((AstIdentifier) node).getImage();\n\n            // simply capture it\n            this.varMapper.resolveVariable(variable);\n        }\n    }","id":90316,"modified_method":"@Override\n    public void visit(Node node) throws ELException {\n        if (node instanceof AstFunction) {\n\n            AstFunction funcNode = (AstFunction) node;\n\n            Method m = null;\n\n            if (this.fnMapper != null) {\n                m = fnMapper.resolveFunction(funcNode.getPrefix(), funcNode\n                        .getLocalName());\n            }\n\n            // References to variables that refer to lambda expressions will be\n            // parsed as functions. This is handled at runtime but at this point\n            // need to treat it as a variable rather than a function.\n            if (m == null && this.varMapper != null &&\n                    funcNode.getPrefix().length() == 0) {\n                this.varMapper.resolveVariable(funcNode.getLocalName());\n                return;\n            }\n\n            if (this.fnMapper == null) {\n                throw new ELException(MessageFactory.get(\"error.fnMapper.null\"));\n            }\n\n            if (m == null) {\n                throw new ELException(MessageFactory.get(\n                        \"error.fnMapper.method\", funcNode.getOutputName()));\n            }\n\n            int pcnt = m.getParameterTypes().length;\n            if (node.jjtGetNumChildren() != pcnt) {\n                throw new ELException(MessageFactory.get(\n                        \"error.fnMapper.paramcount\", funcNode.getOutputName(),\n                        \"\" + pcnt, \"\" + node.jjtGetNumChildren()));\n            }\n        } else if (node instanceof AstIdentifier && this.varMapper != null) {\n            String variable = ((AstIdentifier) node).getImage();\n\n            // simply capture it\n            this.varMapper.resolveVariable(variable);\n        }\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"public Object invoke(ELContext context , Object... args)\n            throws ELException {\n\n        if (context == null) {\n            throw new NullPointerException();\n        }\n\n        // TODO\n        return null;\n    }","id":90317,"modified_method":"@SuppressWarnings(\"null\") // args[i] can't be null due to earlier checks\n    public Object invoke(ELContext context, Object... args)\n            throws ELException {\n\n        if (context == null) {\n            throw new NullPointerException();\n        }\n\n        int formalParamCount = 0;\n        if (formalParameters != null) {\n            formalParamCount = formalParameters.size();\n        }\n\n        int argCount = 0;\n        if (args != null) {\n            argCount = args.length;\n        }\n\n        if (formalParamCount > argCount) {\n            throw new ELException(Util.message(context,\n                    \"error.lambda.args.tooFew\",\n                    Integer.valueOf(argCount),\n                    Integer.valueOf(formalParamCount)));\n        }\n\n        // Build the argument map\n        Map<String,Object> lambdaArguments = new HashMap<>();\n        for (int i = 0; i < formalParamCount; i++) {\n            lambdaArguments.put(formalParameters.get(i), args[i]);\n        }\n\n        context.enterLambdaScope(lambdaArguments);\n\n        try {\n            return expression.getValue(context);\n        } finally {\n            context.exitLambdaScope();\n        }\n    }","commit_id":"6e4cb72d7ae577e723f31b00a8e36fde8dd31fd0","url":"https://github.com/apache/tomcat"},{"original_method":"public Function resolveFunction(String prefix, String name) {\n\t\tFunction m = _first.resolveFunction(prefix, name);\n\t\treturn m != null ? m: _second.resolveFunction(prefix, name);\n\t}","id":90318,"modified_method":"public Function resolveFunction(String prefix, String name) {\n\t\tFunction m = _first != null ? _first.resolveFunction(prefix, name): null;\n\t\treturn m != null ? m:\n\t\t\t_second != null ? _second.resolveFunction(prefix, name): null;\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"public boolean isSupported(int feature) {\n\t\treturn feature == FEATURE_IMPORT;\n\t}","id":90319,"modified_method":"public boolean isSupported(int feature) {\n\t\treturn feature == FEATURE_CLASS;\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"public Function resolveFunction(String prefix, String name) {\n\t\tfinal Map mtds = _maps != null ? (Map)_maps.get(prefix): null;\n\t\treturn mtds != null ? (Function)mtds.get(name):\n\t\t\t_parent != null ? _parent.resolveFunction(prefix, name): null;\n\t}","id":90320,"modified_method":"public Function resolveFunction(String prefix, String name) {\n\t\tFunction m = super.resolveFunction(prefix, name);\n\t\treturn m != null ? m:\n\t\t\t_parent != null ? _parent.resolveFunction(prefix, name): null;\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"public SimpleMapper(FunctionMapper parent) {\n\t\tif (parent == this)\n\t\t\tthrow new IllegalArgumentException(\"parent cannot be itself\");\n\t\t_parent = parent;\n\t}","id":90321,"modified_method":"public SimpleMapper(FunctionMapper parent) {\n\t\t_parent = parent;\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"public SimpleMapper() {\n\t\tthis(null);\n\t}","id":90322,"modified_method":"public SimpleMapper() {\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"/** Loads the default TLD files defined in /metainfo/tld/config.xml\n\t */\n\tprivate static final Map getDefaultTLDs() {\n\t\tif (_defUrls != null)\n\t\t\treturn _defUrls;\n\n\t\tsynchronized (Taglibs.class) {\n\t\t\tif (_defUrls != null)\n\t\t\t\treturn _defUrls;\n\n\t\t\tfinal Map urls = new HashMap();\n\t\t\ttry {\n\t\t\t\tfinal ClassLocator loc = new ClassLocator();\n\t\t\t\tfor (Enumeration en = loc.getResources(\"metainfo/tld/config.xml\");\n\t\t\t\ten.hasMoreElements();) {\n\t\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\t\t\tif (checkVersion(url, doc))\n\t\t\t\t\t\t\tparseConfig(urls, doc.getRootElement(), loc);\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tlog.error(\"Failed to parse \"+url, ex); //keep running\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tlog.error(ex); //keep running\n\t\t\t}\n\t\t\treturn _defUrls = urls.isEmpty() ? Collections.EMPTY_MAP: urls;\n\t\t}\n\t}","id":90323,"modified_method":"/** Loads the default TLD files defined in /metainfo/tld/config.xml\n\t */\n\tprivate static final Map getDefaultTLDs() {\n\t\tif (_defURLs != null)\n\t\t\treturn _defURLs;\n\n\t\tsynchronized (Taglibs.class) {\n\t\t\tif (_defURLs != null)\n\t\t\t\treturn _defURLs;\n\n\t\t\tfinal Map urls = new HashMap();\n\t\t\ttry {\n\t\t\t\tfinal ClassLocator loc = new ClassLocator();\n\t\t\t\tfor (Enumeration en = loc.getResources(\"metainfo/tld/config.xml\");\n\t\t\t\ten.hasMoreElements();) {\n\t\t\t\t\tfinal URL url = (URL)en.nextElement();\n\t\t\t\t\tif (log.debugable()) log.debug(\"Loading \"+url);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfinal Document doc = new SAXBuilder(false, false, true).build(url);\n\t\t\t\t\t\tif (checkVersion(url, doc))\n\t\t\t\t\t\t\tparseConfig(urls, doc.getRootElement(), loc);\n\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\tlog.error(\"Failed to parse \"+url, ex); //keep running\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (Exception ex) {\n\t\t\t\tlog.error(ex); //keep running\n\t\t\t}\n\t\t\treturn _defURLs = urls.isEmpty() ? Collections.EMPTY_MAP: urls;\n\t\t}\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"/** Loads functions defined in the specified URL.\n\t * @return a map of function: (String name, Function mtd).\n\t */\n\tpublic static final Map loadFunctions(URL xmlUrl) throws Exception {\n//\t\tif (log.debugable()) log.debug(MCommon.FILE_OPENING, xmlUrl);\n\t\tfinal Element root =\n\t\t\tnew SAXBuilder(true, false, true).build(xmlUrl).getRootElement();\n\t\t\t//We have to turn on namespace because xml schema might be used\n\t\treturn loadFunctions(root);\n\t}","id":90324,"modified_method":"/** Loads functions defined in the specified URL.\n\t *\n\t * <p>Note: this method will cache the result, so next invocation\n\t * with the same xmlURL will read directly from the cache.\n\t *\n\t * @return a map of functions: (String name, Function mtd).\n\t */\n\tpublic static final Map loadFunctions(URL xmlURL) throws Exception {\n\t\treturn load(xmlURL)[0];\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"public Object load(Object src) throws Exception {\n\t\t\treturn loadFunctions((URL)src);\n\t\t}","id":90325,"modified_method":"public Object load(Object src) throws Exception {\n\t\t\tfinal Element root =\n\t\t\t\tnew SAXBuilder(true, false, true).build((URL)src).getRootElement();\n\t\t\treturn Taglibs.load(root);\n\t\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"/** Loads functions defined in the specified DOM.\n\t * @return a map of function: (String name, Function mtd).\n\t */\n\tpublic static final Map loadFunctions(Element root) throws Exception {\n\t\tfinal Map mtds = new HashMap();\n\t\tException excp = null;\n\t\tfor (Iterator it = root.getElements(\"function\").iterator();\n\t\tit.hasNext();) {\n\t\t\tfinal Element e = (Element)it.next();\n\n\t\t\tfinal String name = IDOMs.getRequiredElementValue(e, \"name\");\n\t\t\tfinal String clsName = IDOMs.getRequiredElementValue(e, \"function-class\");\n\t\t\tfinal String sig = IDOMs.getRequiredElementValue(e, \"function-signature\");\n\t\t\tfinal Class cls;\n\t\t\ttry {\n\t\t\t\tcls = Classes.forNameByThread(clsName);\n\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\tlog.error(\"Class not found: \"+clsName+\", \"+e.getLocator(), ex);\n\t\t\t\texcp = ex;\n\t\t\t\tcontinue; //to report as many errors as possible\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tfinal Method mtd = Classes.getMethodBySignature(cls, sig, null);\n\t\t\t\tif ((mtd.getModifiers() & Modifier.STATIC) != 0)\n\t\t\t\t\tmtds.put(name, new MethodFunction(mtd));\n\t\t\t\telse\n\t\t\t\t\tlog.error(\"Not a static method: \"+mtd);\n\t\t\t} catch (ClassNotFoundException ex) {\n\t\t\t\tlog.error(\"Relavant class not found when loading \"+clsName+\", \"+e.getLocator(), ex);\n\t\t\t\texcp = ex;\n\t\t\t\tcontinue;\n\t\t\t} catch (NoSuchMethodException ex) {\n\t\t\t\tlog.error(\"Method not found in \"+clsName+\": \"+sig+\" \"+e.getLocator(), ex);\n\t\t\t\texcp = ex;\n\t\t\t\tcontinue;\n\t\t\t} catch (IllegalSyntaxException ex) {\n\t\t\t\tlog.error(\"Illegal Signature: \"+sig+\" \"+e.getLocator(), ex);\n\t\t\t\texcp = ex;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (excp != null)\n\t\t\tthrow excp;\n\t\treturn mtds;\n\t}","id":90326,"modified_method":"/** Loads functions defined in the specified DOM.\n\t *\n\t * <p>Unlike {@link #loadFunctions(URL)}, this method\n\t * doesn't use cache.\n\t *\n\t * @return a map of function: (String name, Function mtd).\n\t */\n\tpublic static final Map loadFunctions(Element root) throws Exception {\n\t\treturn load(root)[0];\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"/** Retursn the function mapper representing a list of {@link Taglib},\n\t * or null if taglibs is null or empty.\n\t *\n\t * <p>The returned mapper is serializable.\n\t *\n\t * @param loc the locator used to load taglib\n\t */\n\tpublic static final\n\tFunctionMapper getFunctionMapper(List taglibs, Locator loc) {\n\t\tif (taglibs == null || taglibs.isEmpty())\n\t\t\treturn null;\n\n\t\tfinal Map mappers = new HashMap();\n\t\tfor (Iterator it = taglibs.iterator(); it.hasNext();) {\n\t\t\tfinal Taglib taglib = (Taglib)it.next();\n\t\t\tfinal String uri = taglib.getURI();\n\t\t\tURL url = uri.indexOf(\"://\") > 0 ? null: loc.getResource(uri);\n\t\t\tif (url == null) {\n\t\t\t\turl = Taglibs.getDefaultURL(uri);\n\t\t\t\tif (url == null)\n\t\t\t\t\tthrow new MissingResourceException(\n\t\t\t\t\t\t\"Taglib not found: \"+uri, loc.getClass().getName(), uri);\n\t\t\t}\n\n\t\t\tfinal Map mtds = (Map)_reces.get(url);\n//\t\t\tif (D.ON && log.finerable()) log.finer(\"Methods for \"+taglib.getPrefix()+\": \"+mtds);\n\t\t\tif (!mtds.isEmpty())\n\t\t\t\tmappers.put(taglib.getPrefix(), mtds);\n\t\t}\n\t\treturn new Mapper(mappers);\n\t}","id":90327,"modified_method":"/** Retursn the function mapper representing a list of {@link Taglib},\n\t * or null if taglibs is null or empty.\n\t *\n\t * <p>The returned mapper is serializable.\n\t *\n\t * @param loc the locator used to load taglib\n\t */\n\tpublic static final\n\tFunctionMapper getFunctionMapper(List taglibs, Locator loc) {\n\t\tif (taglibs == null || taglibs.isEmpty())\n\t\t\treturn null;\n\n\t\tfinal TaglibMapper mapper = new TaglibMapper();\n\t\tfor (Iterator it = taglibs.iterator(); it.hasNext();)\n\t\t\tmapper.load((Taglib)it.next(), loc);\n\t\treturn mapper;\n\t}","commit_id":"ab31f44a334fc93331b0207fada87b2d2eae3f94","url":"https://github.com/zkoss/zk"},{"original_method":"public Orient startup() {\r\n    acquireExclusiveLock();\r\n    try {\r\n      if (active)\r\n        // ALREADY ACTIVE\r\n        return this;\r\n\r\n      profiler = new OJVMProfiler();\r\n\r\n      // REGISTER THE EMBEDDED ENGINE\r\n      registerEngine(new OEngineLocal());\r\n      registerEngine(new OEngineLocalPaginated());\r\n      registerEngine(new OEngineMemory());\r\n      registerEngine(\"com.orientechnologies.orient.client.remote.OEngineRemote\");\r\n\r\n      if (OGlobalConfiguration.PROFILER_ENABLED.getValueAsBoolean())\r\n        // ACTIVATE RECORDING OF THE PROFILER\r\n        profiler.startRecording();\r\n\r\n      if (OGlobalConfiguration.ENVIRONMENT_DUMP_CFG_AT_STARTUP.getValueAsBoolean())\r\n        OGlobalConfiguration.dumpConfiguration(System.out);\r\n\r\n      memoryWatchDog = new OMemoryWatchDog();\r\n\r\n      active = true;\r\n      return this;\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":90328,"modified_method":"public Orient startup() {\r\n    acquireExclusiveLock();\r\n    try {\r\n      if (active)\r\n        // ALREADY ACTIVE\r\n        return this;\r\n\r\n      shutdownHook = new OrientShutdownHook();\r\n      profiler = new OJVMProfiler();\r\n\r\n      // REGISTER THE EMBEDDED ENGINE\r\n      registerEngine(new OEngineLocal());\r\n      registerEngine(new OEngineLocalPaginated());\r\n      registerEngine(new OEngineMemory());\r\n      registerEngine(\"com.orientechnologies.orient.client.remote.OEngineRemote\");\r\n\r\n      if (OGlobalConfiguration.PROFILER_ENABLED.getValueAsBoolean())\r\n        // ACTIVATE RECORDING OF THE PROFILER\r\n        profiler.startRecording();\r\n\r\n      if (OGlobalConfiguration.ENVIRONMENT_DUMP_CFG_AT_STARTUP.getValueAsBoolean())\r\n        OGlobalConfiguration.dumpConfiguration(System.out);\r\n\r\n      memoryWatchDog = new OMemoryWatchDog();\r\n\r\n      active = true;\r\n      return this;\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"e569345e32b595b35c18db362ae31bc686688a41","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void removeShutdownHook() {\r\n    Runtime.getRuntime().removeShutdownHook(shutdownHook);\r\n  }","id":90329,"modified_method":"public void removeShutdownHook() {\r\n    if (shutdownHook != null)\r\n      Runtime.getRuntime().removeShutdownHook(shutdownHook);\r\n  }","commit_id":"e569345e32b595b35c18db362ae31bc686688a41","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Asks the app server to stop and waits for it to finish up.\n     */\n    public synchronized void stop() throws Exception {\n        if (server==null) return;\n        String root = getRootUrl();\n        Threads.removeShutdownHook(shutdownHook);\n        if (log.isDebugEnabled())\n            log.debug(\"Stopping Brooklyn web console at \"+root+ \" (\" + war + (wars != null ? \" and \" + wars.values() : \"\") + \")\");\n\n        server.stop();\n        try {\n            server.join();\n        } catch (Exception e) {\n            /* NPE may be thrown e.g. if threadpool not started */\n        }\n        server = null;\n        LocalhostMachineProvisioningLocation.releasePort(getAddress(), actualPort);\n        actualPort = -1;\n        if (log.isDebugEnabled())\n            log.debug(\"Stopped Brooklyn web console at \"+root);\n    }","id":90330,"modified_method":"/**\n     * Asks the app server to stop and waits for it to finish up.\n     */\n    public synchronized void stop() throws Exception {\n        if (server==null) return;\n        String root = getRootUrl();\n        if (shutdownHook != null) Threads.removeShutdownHook(shutdownHook);\n        if (log.isDebugEnabled())\n            log.debug(\"Stopping Brooklyn web console at \"+root+ \" (\" + war + (wars != null ? \" and \" + wars.values() : \"\") + \")\");\n\n        server.stop();\n        try {\n            server.join();\n        } catch (Exception e) {\n            /* NPE may be thrown e.g. if threadpool not started */\n        }\n        server = null;\n        LocalhostMachineProvisioningLocation.releasePort(getAddress(), actualPort);\n        actualPort = -1;\n        if (log.isDebugEnabled())\n            log.debug(\"Stopped Brooklyn web console at \"+root);\n    }","commit_id":"bb28e29cc0f6b1f4eeea1a26d018375ca5a14d33","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected AbstractNamedDomainObjectContainer(Class<T> type, Instantiator instantiator) {\n        super(type, instantiator, Named.Namer.forType(type));\n    }","id":90331,"modified_method":"protected AbstractNamedDomainObjectContainer(Class<? extends T> type, Instantiator instantiator) {\n        super(type, instantiator, Named.Namer.forType(type));\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"protected AbstractNamedDomainObjectContainer(Class<T> type, Instantiator instantiator, Namer<? super T> namer) {\n        super(type, instantiator, namer);\n    }","id":90332,"modified_method":"protected AbstractNamedDomainObjectContainer(Class<? extends T> type, Instantiator instantiator, Namer<? super T> namer) {\n        super(type, instantiator, namer);\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultPublishingExtension(RepositoryHandler repositories, PublicationContainer publications) {\n        this.repositories = repositories;\n        this.publications = publications;\n    }","id":90333,"modified_method":"public DefaultPublishingExtension(PublicationRepositoryContainer repositories, PublicationContainer publications) {\n        this.repositories = repositories;\n        this.publications = publications;\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"public RepositoryHandler getRepositories() {\n        return repositories;\n    }","id":90334,"modified_method":"public PublicationRepositoryContainer getRepositories() {\n        return repositories;\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"public void repositories(Action<? super RepositoryHandler> configure) {\n        configure.execute(repositories);\n    }","id":90335,"modified_method":"public void repositories(Action<? super NamedDomainObjectContainer<ArtifactRepository>> configure) {\n        configure.execute(repositories);\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"public void monitor(final PublicationContainer publications, final ArtifactRepositoryContainer repositories) {\n        publications.all(new Action<Publication>() {\n            public void execute(Publication publication) {\n                for (ArtifactRepository repository : repositories) {\n                    maybeCreate(publication, repository);\n                }\n            }\n        });\n\n        repositories.whenObjectAdded(new Action<ArtifactRepository>() {\n            public void execute(ArtifactRepository repository) {\n                for (Publication publication : publications) {\n                    maybeCreate(publication, repository);\n                }\n            }\n        });\n\n        // Note: we aren't supporting removal of repositories or publications\n        // Note: we also aren't considering that repos have a setName, so their name can change\n        //       (though this is a violation of the Named contract)\n    }","id":90336,"modified_method":"public void monitor(final PublicationContainer publications, final NamedDomainObjectContainer<ArtifactRepository> repositories) {\n        publications.all(new Action<Publication>() {\n            public void execute(Publication publication) {\n                for (ArtifactRepository repository : repositories) {\n                    maybeCreate(publication, repository);\n                }\n            }\n        });\n\n        repositories.whenObjectAdded(new Action<ArtifactRepository>() {\n            public void execute(ArtifactRepository repository) {\n                for (Publication publication : publications) {\n                    maybeCreate(publication, repository);\n                }\n            }\n        });\n\n        // Note: we aren't supporting removal of repositories or publications\n        // Note: we also aren't considering that repos have a setName, so their name can change\n        //       (though this is a violation of the Named contract)\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"@Inject\n    public IvyPublishPlugin(\n            Instantiator instantiator, DependencyMetaDataProvider dependencyMetaDataProvider, FileResolver fileResolver\n    ) {\n        this.instantiator = instantiator;\n        this.dependencyMetaDataProvider = dependencyMetaDataProvider;\n        this.fileResolver = fileResolver;\n    }","id":90337,"modified_method":"@Inject\n    public IvyPublishPlugin(\n            Instantiator instantiator, DependencyMetaDataProvider dependencyMetaDataProvider, FileResolver fileResolver,\n            DependencyResolutionServices dependencyResolutionServices\n    ) {\n        this.instantiator = instantiator;\n        this.dependencyMetaDataProvider = dependencyMetaDataProvider;\n        this.fileResolver = fileResolver;\n        this.dependencyResolutionServices = dependencyResolutionServices;\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project) {\n        project.getPlugins().apply(PublishingPlugin.class);\n        PublishingExtension extension = project.getExtensions().getByType(PublishingExtension.class);\n\n        Set<Configuration> visibleConfigurations = project.getConfigurations().matching(new Spec<Configuration>() {\n            public boolean isSatisfiedBy(Configuration configuration) {\n                return configuration.isVisible();\n            }\n        });\n\n        extension.getPublications().add(createPublication(\"main\", project, visibleConfigurations));\n        extension.getRepositories().ivy(new Action<IvyArtifactRepository>() {\n            public void execute(IvyArtifactRepository ivyArtifactRepository) {\n                ivyArtifactRepository.setName(\"main\");\n            }\n        });\n\n        // Create publish tasks automatically for any Ivy publication and repository combinations\n        new IvyPublishDynamicTaskCreator(project.getTasks(), new DefaultIvyPublishTaskNamer()).monitor(extension.getPublications(), extension.getRepositories());\n    }","id":90338,"modified_method":"public void apply(Project project) {\n        project.getPlugins().apply(PublishingPlugin.class);\n        DefaultPublishingExtension extension = (DefaultPublishingExtension) project.getExtensions().getByType(PublishingExtension.class);\n\n        Set<Configuration> visibleConfigurations = project.getConfigurations().matching(new Spec<Configuration>() {\n            public boolean isSatisfiedBy(Configuration configuration) {\n                return configuration.isVisible();\n            }\n        });\n\n        PublicationContainer publications = extension.getPublications();\n        publications.add(createPublication(\"main\", project, visibleConfigurations));\n\n        final BaseRepositoryFactory baseRepositoryFactory = dependencyResolutionServices.getBaseRepositoryFactory();\n        PublicationRepositoryContainer repositories = extension.getRepositories();\n        repositories.setFactory(new IvyArtifactRepositoryFactory(baseRepositoryFactory));\n\n        // Create publish tasks automatically for any Ivy publication and repository combinations\n        new IvyPublishDynamicTaskCreator(project.getTasks(), new DefaultIvyPublishTaskNamer()).monitor(publications, repositories);\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project) {\n        RepositoryHandler repositories = artifactPublicationServicesFactory.create().getRepositoryHandler();\n        PublicationContainer publications = instantiator.newInstance(DefaultPublicationContainer.class, instantiator);\n        project.getExtensions().create(PublishingExtension.NAME, DefaultPublishingExtension.class, repositories, publications);\n    }","id":90339,"modified_method":"public void apply(Project project) {\n        PublicationRepositoryContainer repositories = instantiator.newInstance(PublicationRepositoryContainer.class, instantiator);\n        PublicationContainer publications = instantiator.newInstance(DefaultPublicationContainer.class, instantiator);\n        project.getExtensions().create(PublishingExtension.NAME, DefaultPublishingExtension.class, repositories, publications);\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"@Inject\n    public PublishingPlugin(Factory<ArtifactPublicationServices> artifactPublicationServicesFactory, Instantiator instantiator) {\n        this.artifactPublicationServicesFactory = artifactPublicationServicesFactory;\n        this.instantiator = instantiator;\n    }","id":90340,"modified_method":"@Inject\n    public PublishingPlugin(Instantiator instantiator) {\n        this.instantiator = instantiator;\n    }","commit_id":"2a45f47d88797f4fe68e8953a340898d8a6ef29c","url":"https://github.com/gradle/gradle"},{"original_method":"protected AbstractNamedDomainObjectContainer(Class<T> type, Instantiator instantiator, Namer<? super T> namer) {\n        super(type, instantiator, namer);\n    }","id":90341,"modified_method":"protected AbstractNamedDomainObjectContainer(Class<? extends T> type, Instantiator instantiator, Namer<? super T> namer) {\n        super(type, instantiator, namer);\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"protected AbstractNamedDomainObjectContainer(Class<T> type, Instantiator instantiator) {\n        super(type, instantiator, Named.Namer.forType(type));\n    }","id":90342,"modified_method":"protected AbstractNamedDomainObjectContainer(Class<? extends T> type, Instantiator instantiator) {\n        super(type, instantiator, Named.Namer.forType(type));\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"public void repositories(Action<? super RepositoryHandler> configure) {\n        configure.execute(repositories);\n    }","id":90343,"modified_method":"public void repositories(Action<? super NamedDomainObjectContainer<ArtifactRepository>> configure) {\n        configure.execute(repositories);\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"public RepositoryHandler getRepositories() {\n        return repositories;\n    }","id":90344,"modified_method":"public PublicationRepositoryContainer getRepositories() {\n        return repositories;\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultPublishingExtension(RepositoryHandler repositories, PublicationContainer publications) {\n        this.repositories = repositories;\n        this.publications = publications;\n    }","id":90345,"modified_method":"public DefaultPublishingExtension(PublicationRepositoryContainer repositories, PublicationContainer publications) {\n        this.repositories = repositories;\n        this.publications = publications;\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"public void monitor(final PublicationContainer publications, final ArtifactRepositoryContainer repositories) {\n        publications.all(new Action<Publication>() {\n            public void execute(Publication publication) {\n                for (ArtifactRepository repository : repositories) {\n                    maybeCreate(publication, repository);\n                }\n            }\n        });\n\n        repositories.whenObjectAdded(new Action<ArtifactRepository>() {\n            public void execute(ArtifactRepository repository) {\n                for (Publication publication : publications) {\n                    maybeCreate(publication, repository);\n                }\n            }\n        });\n\n        // Note: we aren't supporting removal of repositories or publications\n        // Note: we also aren't considering that repos have a setName, so their name can change\n        //       (though this is a violation of the Named contract)\n    }","id":90346,"modified_method":"public void monitor(final PublicationContainer publications, final NamedDomainObjectContainer<ArtifactRepository> repositories) {\n        publications.all(new Action<Publication>() {\n            public void execute(Publication publication) {\n                for (ArtifactRepository repository : repositories) {\n                    maybeCreate(publication, repository);\n                }\n            }\n        });\n\n        repositories.whenObjectAdded(new Action<ArtifactRepository>() {\n            public void execute(ArtifactRepository repository) {\n                for (Publication publication : publications) {\n                    maybeCreate(publication, repository);\n                }\n            }\n        });\n\n        // Note: we aren't supporting removal of repositories or publications\n        // Note: we also aren't considering that repos have a setName, so their name can change\n        //       (though this is a violation of the Named contract)\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"@Inject\n    public IvyPublishPlugin(\n            Instantiator instantiator, DependencyMetaDataProvider dependencyMetaDataProvider, FileResolver fileResolver\n    ) {\n        this.instantiator = instantiator;\n        this.dependencyMetaDataProvider = dependencyMetaDataProvider;\n        this.fileResolver = fileResolver;\n    }","id":90347,"modified_method":"@Inject\n    public IvyPublishPlugin(\n            Instantiator instantiator, DependencyMetaDataProvider dependencyMetaDataProvider, FileResolver fileResolver,\n            DependencyResolutionServices dependencyResolutionServices\n    ) {\n        this.instantiator = instantiator;\n        this.dependencyMetaDataProvider = dependencyMetaDataProvider;\n        this.fileResolver = fileResolver;\n        this.dependencyResolutionServices = dependencyResolutionServices;\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project) {\n        project.getPlugins().apply(PublishingPlugin.class);\n        PublishingExtension extension = project.getExtensions().getByType(PublishingExtension.class);\n\n        Set<Configuration> visibleConfigurations = project.getConfigurations().matching(new Spec<Configuration>() {\n            public boolean isSatisfiedBy(Configuration configuration) {\n                return configuration.isVisible();\n            }\n        });\n\n        extension.getPublications().add(createPublication(\"main\", project, visibleConfigurations));\n        extension.getRepositories().ivy(new Action<IvyArtifactRepository>() {\n            public void execute(IvyArtifactRepository ivyArtifactRepository) {\n                ivyArtifactRepository.setName(\"main\");\n            }\n        });\n\n        // Create publish tasks automatically for any Ivy publication and repository combinations\n        new IvyPublishDynamicTaskCreator(project.getTasks(), new DefaultIvyPublishTaskNamer()).monitor(extension.getPublications(), extension.getRepositories());\n    }","id":90348,"modified_method":"public void apply(Project project) {\n        project.getPlugins().apply(PublishingPlugin.class);\n        DefaultPublishingExtension extension = (DefaultPublishingExtension) project.getExtensions().getByType(PublishingExtension.class);\n\n        Set<Configuration> visibleConfigurations = project.getConfigurations().matching(new Spec<Configuration>() {\n            public boolean isSatisfiedBy(Configuration configuration) {\n                return configuration.isVisible();\n            }\n        });\n\n        PublicationContainer publications = extension.getPublications();\n        publications.add(createPublication(\"main\", project, visibleConfigurations));\n\n        final BaseRepositoryFactory baseRepositoryFactory = dependencyResolutionServices.getBaseRepositoryFactory();\n        PublicationRepositoryContainer repositories = extension.getRepositories();\n        repositories.setFactory(new IvyArtifactRepositoryFactory(baseRepositoryFactory));\n\n        // Create publish tasks automatically for any Ivy publication and repository combinations\n        new IvyPublishDynamicTaskCreator(project.getTasks(), new DefaultIvyPublishTaskNamer()).monitor(publications, repositories);\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"public void apply(Project project) {\n        RepositoryHandler repositories = artifactPublicationServicesFactory.create().getRepositoryHandler();\n        PublicationContainer publications = instantiator.newInstance(DefaultPublicationContainer.class, instantiator);\n        project.getExtensions().create(PublishingExtension.NAME, DefaultPublishingExtension.class, repositories, publications);\n    }","id":90349,"modified_method":"public void apply(Project project) {\n        PublicationRepositoryContainer repositories = instantiator.newInstance(PublicationRepositoryContainer.class, instantiator);\n        PublicationContainer publications = instantiator.newInstance(DefaultPublicationContainer.class, instantiator);\n        project.getExtensions().create(PublishingExtension.NAME, DefaultPublishingExtension.class, repositories, publications);\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"@Inject\n    public PublishingPlugin(Factory<ArtifactPublicationServices> artifactPublicationServicesFactory, Instantiator instantiator) {\n        this.artifactPublicationServicesFactory = artifactPublicationServicesFactory;\n        this.instantiator = instantiator;\n    }","id":90350,"modified_method":"@Inject\n    public PublishingPlugin(Instantiator instantiator) {\n        this.instantiator = instantiator;\n    }","commit_id":"438fc6411224a68690bddd7687d84ac6331f05c9","url":"https://github.com/gradle/gradle"},{"original_method":"protected void createDeadDbs( int numSlaves ) throws IOException\n    {\n        FileUtils.deleteDirectory( PARENT_PATH );\n        File firstDbPath = dbPath( 0 );\n        new EmbeddedGraphDatabase( firstDbPath.getAbsolutePath() ).shutdown();\n        for ( int i = 1; i <= numSlaves; i++ )\n        {\n            FileUtils.copyDirectory( firstDbPath, dbPath( i ) );\n        }\n    }","id":90351,"modified_method":"protected void createDeadDbs( int numSlaves ) throws IOException\n    {\n        FileUtils.deleteDirectory( PARENT_PATH );\n        new EmbeddedGraphDatabase( SKELETON_DB_PATH.getAbsolutePath() ).shutdown();\n        for ( int i = 0; i <= numSlaves; i++ )\n        {\n            FileUtils.copyDirectory( SKELETON_DB_PATH, dbPath( i ) );\n        }\n    }","commit_id":"8df6773ebf88fe7cfeea38957eb2474d2c97aafb","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static String buildZooKeeperServersConfigValue( int zooKeeperClusterSize )\n    {\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < zooKeeperClusterSize; i++ )\n        {\n            builder.append( (i > 0 ? \",\" : \"\") + \"localhost:\" + clientPort( i+1 ) );\n        }\n        return builder.toString();\n    }","id":90352,"modified_method":"private static String buildZooKeeperServersConfigValue( int zooKeeperClusterSize )\n    {\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < zooKeeperClusterSize; i++ )\n        {\n            builder.append( (i > 0 ? \",\" : \"\") + \"localhost:\" +\n                    zooKeeperCluster.getClientPortPolicy().getPort( i+1 ) );\n        }\n        return builder.toString();\n    }","commit_id":"8df6773ebf88fe7cfeea38957eb2474d2c97aafb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@AfterClass\n    public static void shutdownZooKeeperCluster()\n    {\n        for ( Runnable hook : zooKeeperClusterShutdownHooks )\n        {\n            hook.run();\n        }\n    }","id":90353,"modified_method":"@AfterClass\n    public static void shutdownZooKeeperCluster()\n    {\n        zooKeeperCluster.shutdown();\n    }","commit_id":"8df6773ebf88fe7cfeea38957eb2474d2c97aafb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@BeforeClass\n    public static void startZooKeeperCluster() throws Exception\n    {\n        FileUtils.deleteDirectory( BASE_ZOO_KEEPER_DATA_DIR );\n        zooKeeperClusterShutdownHooks = new ArrayList<Runnable>();\n        BASE_ZOO_KEEPER_DATA_DIR.mkdirs();\n        for ( int i = 0; i < ZOO_KEEPER_CLUSTER_SIZE; i++ )\n        {\n            File configFile = writeZooKeeperConfigFile( ZOO_KEEPER_CLUSTER_SIZE, i+1 );\n            final Process process = Runtime.getRuntime().exec( new String[] { \"java\", \"-cp\",\n                    System.getProperty( \"java.class.path\" ),\n                    \"org.apache.zookeeper.server.quorum.QuorumPeerMain\",\n                    configFile.getAbsolutePath() } );\n            zooKeeperClusterShutdownHooks.add( new Runnable()\n            {\n                public void run()\n                {\n                    process.destroy();\n                }\n            } );\n        }\n        Thread.sleep( 5000 );\n    }","id":90354,"modified_method":"@BeforeClass\n    public static void startZooKeeperCluster() throws Exception\n    {\n        FileUtils.deleteDirectory( BASE_ZOO_KEEPER_DATA_DIR );\n        zooKeeperCluster = new ZooKeeperClusterLifecycle( ZOO_KEEPER_CLUSTER_SIZE,\n                ZooKeeperClusterLifecycle.defaultDataDirectoryPolicy( BASE_ZOO_KEEPER_DATA_DIR ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 2181 ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 2888 ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 3888 ) );\n    }","commit_id":"8df6773ebf88fe7cfeea38957eb2474d2c97aafb","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected StandaloneDbCom spawnJvm( int numServers, File path, int port, int machineId,\n            String... extraArgs ) throws Exception\n    {\n        List<String> myExtraArgs = new ArrayList<String>();\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID );\n        myExtraArgs.add( \"\" + (machineId+1) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS );\n        myExtraArgs.add( buildZooKeeperServersConfigValue( ZOO_KEEPER_CLUSTER_SIZE ) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS );\n        myExtraArgs.add( buildHaServersConfigValue( numServers ) );\n        myExtraArgs.addAll( Arrays.asList( extraArgs ) );\n        return super.spawnJvm( numServers, path, port, machineId, myExtraArgs.toArray(\n                new String[myExtraArgs.size()] ) );\n    }","id":90355,"modified_method":"@Override\n    protected StandaloneDbCom spawnJvm( int numServers, File path, int port, int machineId,\n            String... extraArgs ) throws Exception\n    {\n        List<String> myExtraArgs = new ArrayList<String>();\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID );\n        myExtraArgs.add( \"\" + (machineId+1) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS );\n        myExtraArgs.add( buildZooKeeperServersConfigValue( ZOO_KEEPER_CLUSTER_SIZE ) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS );\n        myExtraArgs.add( buildHaServersConfigValue( numServers ) );\n        myExtraArgs.addAll( Arrays.asList( extraArgs ) );\n        StandaloneDbCom com = super.spawnJvm( numServers, path, port, machineId,\n                myExtraArgs.toArray( new String[myExtraArgs.size()] ) );\n        com.awaitStarted();\n        jvmByMachineId.put( com.getMachineId(), com );\n        return com;\n    }","commit_id":"8df6773ebf88fe7cfeea38957eb2474d2c97aafb","url":"https://github.com/neo4j/neo4j"},{"original_method":"NeoStoreUtil( String storeDir )\n    {\n        try\n        {\n            FileChannel fileChannel = new RandomAccessFile( storeDir + \"/neostore\", \"r\" ).getChannel();\n            ByteBuffer buf = ByteBuffer.allocate( 32 );\n            if ( fileChannel.read( buf ) != 32 )\n            {\n                throw new RuntimeException( \"Unable to read neo store header information\" );\n            }\n            buf.flip();\n            creationTime = buf.getLong();\n            storeId = buf.getLong();\n            buf.getLong(); // skip log version\n            txId = buf.getLong();\n            fileChannel.close();\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":90356,"modified_method":"public NeoStoreUtil( String storeDir )\n    {\n        try\n        {\n            FileChannel fileChannel = new RandomAccessFile( storeDir + \"/neostore\", \"r\" ).getChannel();\n            ByteBuffer buf = ByteBuffer.allocate( 32 );\n            if ( fileChannel.read( buf ) != 32 )\n            {\n                throw new RuntimeException( \"Unable to read neo store header information\" );\n            }\n            buf.flip();\n            creationTime = buf.getLong();\n            storeId = buf.getLong();\n            buf.getLong(); // skip log version\n            txId = buf.getLong();\n            fileChannel.close();\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"8df6773ebf88fe7cfeea38957eb2474d2c97aafb","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS, null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                int machineId = args.getNumber( \"id\", null ).intValue();\n                AbstractBroker broker = isMaster ? new FakeMasterBroker() :\n                        new FakeSlaveBroker();\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + machineId ),\n                        broker );\n                broker.setDb( haDb );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.db = haDb;\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","id":90357,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS, null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                AbstractBroker broker = isMaster ? new FakeMasterBroker() :\n                        new FakeSlaveBroker();\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId ),\n                        broker );\n                broker.setDb( haDb );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"8df6773ebf88fe7cfeea38957eb2474d2c97aafb","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void createDeadDbs( int numSlaves ) throws IOException\n    {\n        FileUtils.deleteDirectory( PARENT_PATH );\n        File firstDbPath = dbPath( 0 );\n        new EmbeddedGraphDatabase( firstDbPath.getAbsolutePath() ).shutdown();\n        for ( int i = 1; i <= numSlaves; i++ )\n        {\n            FileUtils.copyDirectory( firstDbPath, dbPath( i ) );\n        }\n    }","id":90358,"modified_method":"protected void createDeadDbs( int numSlaves ) throws IOException\n    {\n        FileUtils.deleteDirectory( PARENT_PATH );\n        new EmbeddedGraphDatabase( SKELETON_DB_PATH.getAbsolutePath() ).shutdown();\n        for ( int i = 0; i <= numSlaves; i++ )\n        {\n            FileUtils.copyDirectory( SKELETON_DB_PATH, dbPath( i ) );\n        }\n    }","commit_id":"c6f576223e8e11ac6ee3e7114c55a62c1cf6c663","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected StandaloneDbCom spawnJvm( int numServers, File path, int port, int machineId,\n            String... extraArgs ) throws Exception\n    {\n        List<String> myExtraArgs = new ArrayList<String>();\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID );\n        myExtraArgs.add( \"\" + (machineId+1) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS );\n        myExtraArgs.add( buildZooKeeperServersConfigValue( ZOO_KEEPER_CLUSTER_SIZE ) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS );\n        myExtraArgs.add( buildHaServersConfigValue( numServers ) );\n        myExtraArgs.addAll( Arrays.asList( extraArgs ) );\n        return super.spawnJvm( numServers, path, port, machineId, myExtraArgs.toArray(\n                new String[myExtraArgs.size()] ) );\n    }","id":90359,"modified_method":"@Override\n    protected StandaloneDbCom spawnJvm( int numServers, File path, int port, int machineId,\n            String... extraArgs ) throws Exception\n    {\n        List<String> myExtraArgs = new ArrayList<String>();\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID );\n        myExtraArgs.add( \"\" + (machineId+1) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS );\n        myExtraArgs.add( buildZooKeeperServersConfigValue( ZOO_KEEPER_CLUSTER_SIZE ) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS );\n        myExtraArgs.add( buildHaServersConfigValue( numServers ) );\n        myExtraArgs.addAll( Arrays.asList( extraArgs ) );\n        StandaloneDbCom com = super.spawnJvm( numServers, path, port, machineId,\n                myExtraArgs.toArray( new String[myExtraArgs.size()] ) );\n        com.awaitStarted();\n        jvmByMachineId.put( com.getMachineId(), com );\n        return com;\n    }","commit_id":"c6f576223e8e11ac6ee3e7114c55a62c1cf6c663","url":"https://github.com/neo4j/neo4j"},{"original_method":"@BeforeClass\n    public static void startZooKeeperCluster() throws Exception\n    {\n        FileUtils.deleteDirectory( BASE_ZOO_KEEPER_DATA_DIR );\n        zooKeeperClusterShutdownHooks = new ArrayList<Runnable>();\n        BASE_ZOO_KEEPER_DATA_DIR.mkdirs();\n        for ( int i = 0; i < ZOO_KEEPER_CLUSTER_SIZE; i++ )\n        {\n            File configFile = writeZooKeeperConfigFile( ZOO_KEEPER_CLUSTER_SIZE, i+1 );\n            final Process process = Runtime.getRuntime().exec( new String[] { \"java\", \"-cp\",\n                    System.getProperty( \"java.class.path\" ),\n                    \"org.apache.zookeeper.server.quorum.QuorumPeerMain\",\n                    configFile.getAbsolutePath() } );\n            zooKeeperClusterShutdownHooks.add( new Runnable()\n            {\n                public void run()\n                {\n                    process.destroy();\n                }\n            } );\n        }\n        Thread.sleep( 5000 );\n    }","id":90360,"modified_method":"@BeforeClass\n    public static void startZooKeeperCluster() throws Exception\n    {\n        FileUtils.deleteDirectory( BASE_ZOO_KEEPER_DATA_DIR );\n        zooKeeperCluster = new ZooKeeperClusterLifecycle( ZOO_KEEPER_CLUSTER_SIZE,\n                ZooKeeperClusterLifecycle.defaultDataDirectoryPolicy( BASE_ZOO_KEEPER_DATA_DIR ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 2181 ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 2888 ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 3888 ) );\n    }","commit_id":"c6f576223e8e11ac6ee3e7114c55a62c1cf6c663","url":"https://github.com/neo4j/neo4j"},{"original_method":"@AfterClass\n    public static void shutdownZooKeeperCluster()\n    {\n        for ( Runnable hook : zooKeeperClusterShutdownHooks )\n        {\n            hook.run();\n        }\n    }","id":90361,"modified_method":"@AfterClass\n    public static void shutdownZooKeeperCluster()\n    {\n        zooKeeperCluster.shutdown();\n    }","commit_id":"c6f576223e8e11ac6ee3e7114c55a62c1cf6c663","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static String buildZooKeeperServersConfigValue( int zooKeeperClusterSize )\n    {\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < zooKeeperClusterSize; i++ )\n        {\n            builder.append( (i > 0 ? \",\" : \"\") + \"localhost:\" + clientPort( i+1 ) );\n        }\n        return builder.toString();\n    }","id":90362,"modified_method":"private static String buildZooKeeperServersConfigValue( int zooKeeperClusterSize )\n    {\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < zooKeeperClusterSize; i++ )\n        {\n            builder.append( (i > 0 ? \",\" : \"\") + \"localhost:\" +\n                    zooKeeperCluster.getClientPortPolicy().getPort( i+1 ) );\n        }\n        return builder.toString();\n    }","commit_id":"c6f576223e8e11ac6ee3e7114c55a62c1cf6c663","url":"https://github.com/neo4j/neo4j"},{"original_method":"NeoStoreUtil( String storeDir )\n    {\n        try\n        {\n            FileChannel fileChannel = new RandomAccessFile( storeDir + \"/neostore\", \"r\" ).getChannel();\n            ByteBuffer buf = ByteBuffer.allocate( 32 );\n            if ( fileChannel.read( buf ) != 32 )\n            {\n                throw new RuntimeException( \"Unable to read neo store header information\" );\n            }\n            buf.flip();\n            creationTime = buf.getLong();\n            storeId = buf.getLong();\n            buf.getLong(); // skip log version\n            txId = buf.getLong();\n            fileChannel.close();\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":90363,"modified_method":"public NeoStoreUtil( String storeDir )\n    {\n        try\n        {\n            FileChannel fileChannel = new RandomAccessFile( storeDir + \"/neostore\", \"r\" ).getChannel();\n            ByteBuffer buf = ByteBuffer.allocate( 32 );\n            if ( fileChannel.read( buf ) != 32 )\n            {\n                throw new RuntimeException( \"Unable to read neo store header information\" );\n            }\n            buf.flip();\n            creationTime = buf.getLong();\n            storeId = buf.getLong();\n            buf.getLong(); // skip log version\n            txId = buf.getLong();\n            fileChannel.close();\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"c6f576223e8e11ac6ee3e7114c55a62c1cf6c663","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS, null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                int machineId = args.getNumber( \"id\", null ).intValue();\n                AbstractBroker broker = isMaster ? new FakeMasterBroker() :\n                        new FakeSlaveBroker();\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + machineId ),\n                        broker );\n                broker.setDb( haDb );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.db = haDb;\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","id":90364,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS, null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                AbstractBroker broker = isMaster ? new FakeMasterBroker() :\n                        new FakeSlaveBroker();\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId ),\n                        broker );\n                broker.setDb( haDb );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"c6f576223e8e11ac6ee3e7114c55a62c1cf6c663","url":"https://github.com/neo4j/neo4j"},{"original_method":"protected void createDeadDbs( int numSlaves ) throws IOException\n    {\n        FileUtils.deleteDirectory( PARENT_PATH );\n        File firstDbPath = dbPath( 0 );\n        new EmbeddedGraphDatabase( firstDbPath.getAbsolutePath() ).shutdown();\n        for ( int i = 1; i <= numSlaves; i++ )\n        {\n            FileUtils.copyDirectory( firstDbPath, dbPath( i ) );\n        }\n    }","id":90365,"modified_method":"protected void createDeadDbs( int numSlaves ) throws IOException\n    {\n        FileUtils.deleteDirectory( PARENT_PATH );\n        new EmbeddedGraphDatabase( SKELETON_DB_PATH.getAbsolutePath() ).shutdown();\n        for ( int i = 0; i <= numSlaves; i++ )\n        {\n            FileUtils.copyDirectory( SKELETON_DB_PATH, dbPath( i ) );\n        }\n    }","commit_id":"c4408234699cabd549a7f48aea3114e8379d87ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"@BeforeClass\n    public static void startZooKeeperCluster() throws Exception\n    {\n        FileUtils.deleteDirectory( BASE_ZOO_KEEPER_DATA_DIR );\n        zooKeeperClusterShutdownHooks = new ArrayList<Runnable>();\n        BASE_ZOO_KEEPER_DATA_DIR.mkdirs();\n        for ( int i = 0; i < ZOO_KEEPER_CLUSTER_SIZE; i++ )\n        {\n            File configFile = writeZooKeeperConfigFile( ZOO_KEEPER_CLUSTER_SIZE, i+1 );\n            final Process process = Runtime.getRuntime().exec( new String[] { \"java\", \"-cp\",\n                    System.getProperty( \"java.class.path\" ),\n                    \"org.apache.zookeeper.server.quorum.QuorumPeerMain\",\n                    configFile.getAbsolutePath() } );\n            zooKeeperClusterShutdownHooks.add( new Runnable()\n            {\n                public void run()\n                {\n                    process.destroy();\n                }\n            } );\n        }\n        Thread.sleep( 5000 );\n    }","id":90366,"modified_method":"@BeforeClass\n    public static void startZooKeeperCluster() throws Exception\n    {\n        FileUtils.deleteDirectory( BASE_ZOO_KEEPER_DATA_DIR );\n        zooKeeperCluster = new ZooKeeperClusterLifecycle( ZOO_KEEPER_CLUSTER_SIZE,\n                ZooKeeperClusterLifecycle.defaultDataDirectoryPolicy( BASE_ZOO_KEEPER_DATA_DIR ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 2181 ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 2888 ),\n                ZooKeeperClusterLifecycle.defaultPortPolicy( 3888 ) );\n    }","commit_id":"c4408234699cabd549a7f48aea3114e8379d87ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"private static String buildZooKeeperServersConfigValue( int zooKeeperClusterSize )\n    {\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < zooKeeperClusterSize; i++ )\n        {\n            builder.append( (i > 0 ? \",\" : \"\") + \"localhost:\" + clientPort( i+1 ) );\n        }\n        return builder.toString();\n    }","id":90367,"modified_method":"private static String buildZooKeeperServersConfigValue( int zooKeeperClusterSize )\n    {\n        StringBuilder builder = new StringBuilder();\n        for ( int i = 0; i < zooKeeperClusterSize; i++ )\n        {\n            builder.append( (i > 0 ? \",\" : \"\") + \"localhost:\" +\n                    zooKeeperCluster.getClientPortPolicy().getPort( i+1 ) );\n        }\n        return builder.toString();\n    }","commit_id":"c4408234699cabd549a7f48aea3114e8379d87ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected StandaloneDbCom spawnJvm( int numServers, File path, int port, int machineId,\n            String... extraArgs ) throws Exception\n    {\n        List<String> myExtraArgs = new ArrayList<String>();\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID );\n        myExtraArgs.add( \"\" + (machineId+1) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS );\n        myExtraArgs.add( buildZooKeeperServersConfigValue( ZOO_KEEPER_CLUSTER_SIZE ) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS );\n        myExtraArgs.add( buildHaServersConfigValue( numServers ) );\n        myExtraArgs.addAll( Arrays.asList( extraArgs ) );\n        return super.spawnJvm( numServers, path, port, machineId, myExtraArgs.toArray(\n                new String[myExtraArgs.size()] ) );\n    }","id":90368,"modified_method":"@Override\n    protected StandaloneDbCom spawnJvm( int numServers, File path, int port, int machineId,\n            String... extraArgs ) throws Exception\n    {\n        List<String> myExtraArgs = new ArrayList<String>();\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID );\n        myExtraArgs.add( \"\" + (machineId+1) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS );\n        myExtraArgs.add( buildZooKeeperServersConfigValue( ZOO_KEEPER_CLUSTER_SIZE ) );\n        myExtraArgs.add( \"-\" + HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS );\n        myExtraArgs.add( buildHaServersConfigValue( numServers ) );\n        myExtraArgs.addAll( Arrays.asList( extraArgs ) );\n        StandaloneDbCom com = super.spawnJvm( numServers, path, port, machineId,\n                myExtraArgs.toArray( new String[myExtraArgs.size()] ) );\n        com.awaitStarted();\n        jvmByMachineId.put( com.getMachineId(), com );\n        return com;\n    }","commit_id":"c4408234699cabd549a7f48aea3114e8379d87ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"@AfterClass\n    public static void shutdownZooKeeperCluster()\n    {\n        for ( Runnable hook : zooKeeperClusterShutdownHooks )\n        {\n            hook.run();\n        }\n    }","id":90369,"modified_method":"@AfterClass\n    public static void shutdownZooKeeperCluster()\n    {\n        zooKeeperCluster.shutdown();\n    }","commit_id":"c4408234699cabd549a7f48aea3114e8379d87ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"NeoStoreUtil( String storeDir )\n    {\n        try\n        {\n            FileChannel fileChannel = new RandomAccessFile( storeDir + \"/neostore\", \"r\" ).getChannel();\n            ByteBuffer buf = ByteBuffer.allocate( 32 );\n            if ( fileChannel.read( buf ) != 32 )\n            {\n                throw new RuntimeException( \"Unable to read neo store header information\" );\n            }\n            buf.flip();\n            creationTime = buf.getLong();\n            storeId = buf.getLong();\n            buf.getLong(); // skip log version\n            txId = buf.getLong();\n            fileChannel.close();\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","id":90370,"modified_method":"public NeoStoreUtil( String storeDir )\n    {\n        try\n        {\n            FileChannel fileChannel = new RandomAccessFile( storeDir + \"/neostore\", \"r\" ).getChannel();\n            ByteBuffer buf = ByteBuffer.allocate( 32 );\n            if ( fileChannel.read( buf ) != 32 )\n            {\n                throw new RuntimeException( \"Unable to read neo store header information\" );\n            }\n            buf.flip();\n            creationTime = buf.getLong();\n            storeId = buf.getLong();\n            buf.getLong(); // skip log version\n            txId = buf.getLong();\n            fileChannel.close();\n        }\n        catch ( IOException e )\n        {\n            throw new RuntimeException( e );\n        }\n    }","commit_id":"c4408234699cabd549a7f48aea3114e8379d87ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS, null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                int machineId = args.getNumber( \"id\", null ).intValue();\n                AbstractBroker broker = isMaster ? new FakeMasterBroker() :\n                        new FakeSlaveBroker();\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + machineId ),\n                        broker );\n                broker.setDb( haDb );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.db = haDb;\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","id":90371,"modified_method":"public StandaloneDb( Args args, RmiLocation location ) throws Exception\n    {\n        super();\n        \n        storeDir = args.get( \"path\", null );\n        out = new PrintStream( new File( new File( storeDir ), \"output\" ) );\n        System.setOut( out );\n        System.setErr( out );\n        try\n        {\n            int tempMachineId;\n            println( \"About to start\" );\n            \n            HighlyAvailableGraphDatabase haDb = null;\n            println( args.asMap().toString() );\n            if ( args.has( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID ) )\n            {\n                new EmbeddedGraphDatabase( storeDir ).shutdown();\n                tempMachineId = args.getNumber(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, null ).intValue();\n                Map<String, String> config = MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId,\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_ZOO_KEEPER_SERVERS, null ),\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS,\n                        args.get( HighlyAvailableGraphDatabase.CONFIG_KEY_HA_SERVERS, null ) );\n                haDb = new HighlyAvailableGraphDatabase( storeDir, config );\n                println( \"Started HA db (w/ zoo keeper)\" );\n            }\n            else\n            {\n                boolean isMaster = args.getBoolean( \"master\", false ).booleanValue();\n                tempMachineId = args.getNumber( \"id\", null ).intValue();\n                AbstractBroker broker = isMaster ? new FakeMasterBroker() :\n                        new FakeSlaveBroker();\n                haDb = new HighlyAvailableGraphDatabase( storeDir, MapUtil.stringMap(\n                        HighlyAvailableGraphDatabase.CONFIG_KEY_HA_MACHINE_ID, \"\" + tempMachineId ),\n                        broker );\n                broker.setDb( haDb );\n                println( \"Started HA db (w/o zoo keeper)\" );\n            }\n            this.location = location;\n            this.location.ensureRegistryCreated();\n            this.location.bind( this );\n            this.machineId = tempMachineId;\n            this.db = haDb;\n            println( \"RMI object bound\" );\n        }\n        catch ( Exception e )\n        {\n            println( \"Exception\", e );\n            throw e;\n        }\n    }","commit_id":"c4408234699cabd549a7f48aea3114e8379d87ca","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * Retrieves the real location of a GSP within a Grails project.\n     * @param location The location of the GSP at deployment time\n     * @return The location of the GSP at development time\n     */\n    protected String getRealLocationInProject(String location) {\n\n        if (!location.startsWith(SLASH)) location = SLASH + location;\n\n        if (!location.startsWith(GrailsResourceUtils.WEB_INF)) {\n            return GrailsResourceUtils.WEB_APP_DIR+location;\n        }\n\n        final String noWebInf = location.substring(GrailsResourceUtils.WEB_INF.length() + 1);\n        final String defaultPath = \"file:\" + baseLocation + SLASH + noWebInf;\n        if (!noWebInf.startsWith(PLUGINS_PREFIX)) {\n            return defaultPath;\n        }\n\n        if (application != null) {\n\n            BuildSettings settings = BuildSettingsHolder.getSettings();\n            PluginBuildSettings pluginBuildSettings = org.codehaus.groovy.grails.plugins.GrailsPluginUtils.getPluginBuildSettings();\n            String pluginPath = StringUtils.substringAfter(noWebInf, SLASH);\n            String pluginName = StringUtils.substringBefore(pluginPath, SLASH);\n            String remainingPath = StringUtils.substringAfter(pluginPath, SLASH);\n            Resource r = pluginBuildSettings.getPluginDirForName(pluginName);\n            if (r != null) {\n                try {\n                    return \"file:\" + r.getFile().getAbsolutePath() + SLASH + remainingPath;\n                }\n                catch (IOException e) {\n                    return defaultPath;\n                }\n            }\n\n            if (settings != null) {\n                return \"file:\" + settings.getProjectPluginsDir().getAbsolutePath() + SLASH + pluginName + SLASH + remainingPath;\n            }\n        }\n\n        return defaultPath;\n    }","id":90372,"modified_method":"/**\n     * Retrieves the real location of a GSP within a Grails project.\n     * @param location The location of the GSP at deployment time\n     * @return The location of the GSP at development time\n     */\n    protected String getRealLocationInProject(String location) {\n\n        if (!location.startsWith(SLASH)) location = SLASH + location;\n\n\t\t// If the location (minus the \"grails-app/.*\" ending so that it matches the key value used in BuildSettings for\n\t\t// the inline plugin map) matches an \"inline\" plugin, use the location as-is\n\t\t// for the resource location.  Otherwise, perform the logic to \"normalize\" the resource location based on\n\t\t// its relativity to the application (i.e. is it from a non-inline plugin, etc).\n\t\tif(BuildSettingsHolder.getSettings().isInlinePluginLocation(new File(location.replaceAll(GRAILS_APP_DIR_PATTERN, \"\")))) {\n\t\t\treturn \"file:\" + location;\n\t\t} else {\n\t        if (!location.startsWith(GrailsResourceUtils.WEB_INF)) {\n\t            return GrailsResourceUtils.WEB_APP_DIR+location;\n\t        }\n\n\t        final String noWebInf = location.substring(GrailsResourceUtils.WEB_INF.length() + 1);\n\t        final String defaultPath = \"file:\" + baseLocation + SLASH + noWebInf;\n\t        if (!noWebInf.startsWith(PLUGINS_PREFIX)) {\n\t            return defaultPath;\n\t        }\n\n\t        if (application != null) {\n\n\t            BuildSettings settings = BuildSettingsHolder.getSettings();\n\t            PluginBuildSettings pluginBuildSettings = org.codehaus.groovy.grails.plugins.GrailsPluginUtils.getPluginBuildSettings();\n\t            String pluginPath = StringUtils.substringAfter(noWebInf, SLASH);\n\t            String pluginName = StringUtils.substringBefore(pluginPath, SLASH);\n\t            String remainingPath = StringUtils.substringAfter(pluginPath, SLASH);\n\t            Resource r = pluginBuildSettings.getPluginDirForName(pluginName);\n\t            if (r != null) {\n\t                try {\n\t                    return \"file:\" + r.getFile().getAbsolutePath() + SLASH + remainingPath;\n\t                }\n\t                catch (IOException e) {\n\t\t\t\t\t\tLOG.debug(\"Unable to locate plugin resource -- returning default path \" + defaultPath + \".\", e);\n\t                    return defaultPath;\n\t                }\n\t            }\n\n\t            if (settings != null) {\n\t                return \"file:\" + settings.getProjectPluginsDir().getAbsolutePath() + SLASH + pluginName + SLASH + remainingPath;\n\t            }\n\t        }\n\n\t        return defaultPath;\n\t\t}\n    }","commit_id":"f98a2a1f414538f81a36e4d7beef1f6ab0325afe","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Get a PropertiesHolder that contains the actually visible properties\n     * for a Locale, after merging all specified resource bundles.\n     * Either fetches the holder from the cache or freshly loads it.\n     * <p>Only used when caching resource bundle contents forever, i.e.\n     * with cacheSeconds < 0. Therefore, merged properties are always\n     * cached forever.\n     */\n    protected PropertiesHolder getMergedPluginProperties(Locale locale) {\n        PropertiesHolder mergedHolder = cachedMergedPluginProperties.get(locale);\n        if (mergedHolder != null) {\n            return mergedHolder;\n        }\n\n        Properties mergedProps = new Properties();\n        mergedHolder = new PropertiesHolder(mergedProps, -1);\n        for (String basename : pluginBaseNames) {\n            List<String> filenames = calculateAllFilenames(basename, locale);\n            for (int j = filenames.size() - 1; j >= 0; j--) {\n                String filename = filenames.get(j);\n                PropertiesHolder propHolder = getProperties(filename);\n                if (propHolder.getProperties() != null) {\n                    mergedProps.putAll(propHolder.getProperties());\n                }\n            }\n        }\n        final GrailsPlugin[] allPlugins = pluginManager.getAllPlugins();\n        for (GrailsPlugin plugin : allPlugins) {\n            if (plugin instanceof BinaryGrailsPlugin) {\n                BinaryGrailsPlugin binaryPlugin = (BinaryGrailsPlugin) plugin;\n                final Properties binaryPluginProperties = binaryPlugin.getProperties(locale);\n                if (binaryPluginProperties != null) {\n                    mergedProps.putAll(binaryPluginProperties);\n                }\n            }\n        }\n        cachedMergedPluginProperties.put(locale, mergedHolder);\n        return mergedHolder;\n    }","id":90373,"modified_method":"/**\n\t * Returns the i18n message bundles for the provided plugin or an empty\n\t * array if the plugin does not contain any .properties files in its\n\t * grails-app/i18n folder.\n\t * @param grailsPlugin The grails plugin that may or may not contain i18n internationalization files.\n\t * @returns An array of {@code Resource} objects representing the internationalization files or\n\t *    an empty array if no files are found.\n\t */\n    protected Resource[] getPluginBundles(GrailsPlugin grailsPlugin) {\n        try {\n\t\t\tString basePath = null;\n\t\t\t\n\t\t\t// If the plugin is inline, use the absolute path to the internationalization files\n\t\t\t// in order to convert to resources.  Otherwise, use the relative WEB-INF path.\n\t\t\tif(isInlinePlugin(grailsPlugin)) {\n\t\t\t\tbasePath = getInlinePluginPath(grailsPlugin);\n\t\t\t} else {\n\t\t\t\tbasePath = WEB_INF_PLUGINS_PATH + grailsPlugin.getFileSystemName();\n\t\t\t}\n\t\t\t\n            return resourceResolver.getResources(basePath + \"/grails-app/i18n/*.properties\");\n        }\n        catch (Exception e) {\n\t\t\tLOG.debug(\"Could not resolve any resources for plugin \" + grailsPlugin.getFileSystemName(), e);\n            return new Resource[0];\n        }\n    }","commit_id":"f98a2a1f414538f81a36e4d7beef1f6ab0325afe","url":"https://github.com/grails/grails-core"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        if (pluginManager != null && localResourceLoader != null) {\n            GrailsPlugin[] plugins = pluginManager.getAllPlugins();\n            for (GrailsPlugin plugin : plugins) {\n                Resource[] pluginBundles;\n\n                final String pluginName = plugin.getFileSystemName();\n                pluginBundles = getPluginBundles(pluginName);\n                for (Resource pluginBundle : pluginBundles) {\n                    String baseName = FilenameUtils.getBaseName(pluginBundle.getFilename());\n                    baseName = StringUtils.substringBefore(baseName,\"_\");\n                    pluginBaseNames.add(WEB_INF_PLUGINS_PATH.substring(1) + pluginName + \"/grails-app/i18n/\" + baseName);\n                }\n            }\n        }\n    }","id":90374,"modified_method":"public void afterPropertiesSet() throws Exception {\n        if (pluginManager != null && localResourceLoader != null) {\n\n            GrailsPlugin[] plugins = pluginManager.getAllPlugins();\n            for (GrailsPlugin plugin : plugins) {\n                Resource[] pluginBundles;\n                pluginBundles = getPluginBundles(plugin);\n                for (Resource pluginBundle : pluginBundles) {\n\t\t\t\t\tString basePath = null;\n\t\t\t\t\tfinal String baseName = StringUtils.substringBefore(FilenameUtils.getBaseName(pluginBundle.getFilename()), \"_\");\n\n\t\t\t\t\t// If the plugin is an inline plugin, use the abosolute path to the plugin's i18n files.\n\t\t\t\t\t// Otherwise, use the relative path to the plugin from the application's perspective.\n\t\t\t\t\tif(isInlinePlugin(plugin)) {\n\t\t\t\t\t\tbasePath = getInlinePluginPath(plugin);\n\t\t\t\t\t} else {\n                    \tbasePath = WEB_INF_PLUGINS_PATH.substring(1) + plugin.getFileSystemName();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpluginBaseNames.add(basePath + \"/grails-app/i18n/\" + baseName);\n                }\n            }\n        }\n    }","commit_id":"f98a2a1f414538f81a36e4d7beef1f6ab0325afe","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Expand the WAR file found at the specified URL into an unpacked\n     * directory structure.\n     *\n     * @param host Host war is being installed for\n     * @param war URL of the web application archive to be expanded\n     *  (must start with \"jar:\")\n     * @param pathname Context path name for web application\n     *\n     * @exception IllegalArgumentException if this is not a \"jar:\" URL or if the\n     *            WAR file is invalid\n     * @exception IOException if an input/output error was encountered\n     *  during expansion\n     *\n     * @return The absolute path to the expanded directory foe the given WAR\n     */\n    public static String expand(Host host, URL war, String pathname)\n        throws IOException {\n\n        // Open the connection to the WAR. There is no explicit close method.\n        // You have to get the JarFile and close that.\n        JarURLConnection juc = (JarURLConnection) war.openConnection();\n        juc.setUseCaches(false);\n\n        // Set up the variables used in the finally block of the following try\n        boolean success = false;\n        File docBase = new File(host.getAppBaseFile(), pathname);\n\n        try (JarFile jarFile = juc.getJarFile()) {\n\n            // Get the last modified time for the WAR\n            long warLastModified = juc.getLastModified();\n\n            // Check to see of the WAR has been expanded previously\n            if (docBase.exists()) {\n                // A WAR was expanded. Tomcat will have set the last modified\n                // time of the expanded directory to the last modified time of\n                // the WAR so changes to the WAR while Tomcat is stopped can be\n                // detected\n                long dirLastModified = docBase.lastModified();\n\n                if (dirLastModified == warLastModified) {\n                    // No changes to the WAR\n                    return (docBase.getAbsolutePath());\n                }\n\n                // WAR must have been modified. Remove expanded directory.\n                log.info(sm.getString(\"expandWar.deleteOld\", docBase));\n                if (!delete(docBase)) {\n                    throw new IOException(sm.getString(\"expandWar.deleteFailed\", docBase));\n                }\n            }\n\n            // Create the new document base directory\n            if(!docBase.mkdir() && !docBase.isDirectory()) {\n                throw new IOException(sm.getString(\"expandWar.createFailed\", docBase));\n            }\n\n            // Expand the WAR into the new document base directory\n            String canonicalDocBasePrefix = docBase.getCanonicalPath();\n            if (!canonicalDocBasePrefix.endsWith(File.separator)) {\n                canonicalDocBasePrefix += File.separator;\n            }\n\n            Enumeration<JarEntry> jarEntries = jarFile.entries();\n            while (jarEntries.hasMoreElements()) {\n                JarEntry jarEntry = jarEntries.nextElement();\n                String name = jarEntry.getName();\n                File expandedFile = new File(docBase, name);\n                if (!expandedFile.getCanonicalPath().startsWith(\n                        canonicalDocBasePrefix)) {\n                    // Trying to expand outside the docBase\n                    // Throw an exception to stop the deployment\n                    throw new IllegalArgumentException(\n                            sm.getString(\"expandWar.illegalPath\",war, name,\n                                    expandedFile.getCanonicalPath(),\n                                    canonicalDocBasePrefix));\n                }\n                int last = name.lastIndexOf('/');\n                if (last >= 0) {\n                    File parent = new File(docBase,\n                                           name.substring(0, last));\n                    if (!parent.mkdirs() && !parent.isDirectory()) {\n                        throw new IOException(\n                                sm.getString(\"expandWar.createFailed\", parent));\n                    }\n                }\n                if (name.endsWith(\"/\")) {\n                    continue;\n                }\n\n                try (InputStream input = jarFile.getInputStream(jarEntry)) {\n                    if (null == input)\n                        throw new ZipException(sm.getString(\"expandWar.missingJarEntry\",\n                                jarEntry.getName()));\n\n                    // Bugzilla 33636\n                    expand(input, expandedFile);\n                    long lastModified = jarEntry.getTime();\n                    if ((lastModified != -1) && (lastModified != 0)) {\n                        expandedFile.setLastModified(lastModified);\n                    }\n                }\n\n                // Align the last modified time of the directory with the WAR so\n                // changes to the WAR while Tomcat is stopped can be detected\n                docBase.setLastModified(warLastModified);\n            }\n            success = true;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (!success) {\n                // If something went wrong, delete expanded dir to keep things\n                // clean\n                deleteDir(docBase);\n            }\n        }\n\n        // Return the absolute path to our new document base directory\n        return docBase.getAbsolutePath();\n    }","id":90375,"modified_method":"/**\n     * Expand the WAR file found at the specified URL into an unpacked\n     * directory structure.\n     *\n     * @param host Host war is being installed for\n     * @param war URL of the web application archive to be expanded\n     *  (must start with \"jar:\")\n     * @param pathname Context path name for web application\n     *\n     * @exception IllegalArgumentException if this is not a \"jar:\" URL or if the\n     *            WAR file is invalid\n     * @exception IOException if an input/output error was encountered\n     *  during expansion\n     *\n     * @return The absolute path to the expanded directory foe the given WAR\n     */\n    public static String expand(Host host, URL war, String pathname)\n        throws IOException {\n\n        // Open the connection to the WAR. There is no explicit close method.\n        // You have to get the JarFile and close that.\n        JarURLConnection juc = (JarURLConnection) war.openConnection();\n        juc.setUseCaches(false);\n\n        // Set up the variables used in the finally block of the following try\n        boolean success = false;\n        File docBase = new File(host.getAppBaseFile(), pathname);\n        File warTracker = new File(host.getAppBaseFile(), pathname + Constants.WarTracker);\n\n        try (JarFile jarFile = juc.getJarFile()) {\n\n            // Get the last modified time for the WAR\n            long warLastModified = juc.getLastModified();\n\n            // Check to see of the WAR has been expanded previously\n            if (docBase.exists()) {\n                // A WAR was expanded. Tomcat will have set the last modified\n                // time of the expanded directory to the last modified time of\n                // the WAR so changes to the WAR while Tomcat is stopped can be\n                // detected\n                if (!warTracker.exists() || warTracker.lastModified() == warLastModified) {\n                    // No (detectable) changes to the WAR\n                    success = true;\n                    return (docBase.getAbsolutePath());\n                }\n\n                // WAR must have been modified. Remove expanded directory.\n                log.info(sm.getString(\"expandWar.deleteOld\", docBase));\n                if (!delete(docBase)) {\n                    throw new IOException(sm.getString(\"expandWar.deleteFailed\", docBase));\n                }\n            }\n\n            // Create the new document base directory\n            if(!docBase.mkdir() && !docBase.isDirectory()) {\n                throw new IOException(sm.getString(\"expandWar.createFailed\", docBase));\n            }\n\n            // Expand the WAR into the new document base directory\n            String canonicalDocBasePrefix = docBase.getCanonicalPath();\n            if (!canonicalDocBasePrefix.endsWith(File.separator)) {\n                canonicalDocBasePrefix += File.separator;\n            }\n\n            Enumeration<JarEntry> jarEntries = jarFile.entries();\n            while (jarEntries.hasMoreElements()) {\n                JarEntry jarEntry = jarEntries.nextElement();\n                String name = jarEntry.getName();\n                File expandedFile = new File(docBase, name);\n                if (!expandedFile.getCanonicalPath().startsWith(\n                        canonicalDocBasePrefix)) {\n                    // Trying to expand outside the docBase\n                    // Throw an exception to stop the deployment\n                    throw new IllegalArgumentException(\n                            sm.getString(\"expandWar.illegalPath\",war, name,\n                                    expandedFile.getCanonicalPath(),\n                                    canonicalDocBasePrefix));\n                }\n                int last = name.lastIndexOf('/');\n                if (last >= 0) {\n                    File parent = new File(docBase,\n                                           name.substring(0, last));\n                    if (!parent.mkdirs() && !parent.isDirectory()) {\n                        throw new IOException(\n                                sm.getString(\"expandWar.createFailed\", parent));\n                    }\n                }\n                if (name.endsWith(\"/\")) {\n                    continue;\n                }\n\n                try (InputStream input = jarFile.getInputStream(jarEntry)) {\n                    if (null == input)\n                        throw new ZipException(sm.getString(\"expandWar.missingJarEntry\",\n                                jarEntry.getName()));\n\n                    // Bugzilla 33636\n                    expand(input, expandedFile);\n                    long lastModified = jarEntry.getTime();\n                    if ((lastModified != -1) && (lastModified != 0)) {\n                        expandedFile.setLastModified(lastModified);\n                    }\n                }\n\n                // Create the warTracker file and align the last modified time\n                // with the last modified time of the WAR\n                warTracker.createNewFile();\n                warTracker.setLastModified(warLastModified);\n            }\n            success = true;\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (!success) {\n                // If something went wrong, delete expanded dir to keep things\n                // clean\n                deleteDir(docBase);\n            }\n        }\n\n        // Return the absolute path to our new document base directory\n        return docBase.getAbsolutePath();\n    }","commit_id":"517f398e163ab7abc90dce0a577b1918ee0742e8","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * @param cn\n     * @param war\n     */\n    protected void deployWAR(ContextName cn, File war) {\n\n        File xml = new File(host.getAppBaseFile(),\n                cn.getBaseName() + \"/\" + Constants.ApplicationContextXml);\n\n        boolean xmlInWar = false;\n        JarEntry entry = null;\n        try (JarFile jar = new JarFile(war)) {\n            entry = jar.getJarEntry(Constants.ApplicationContextXml);\n            if (entry != null) {\n                xmlInWar = true;\n            }\n        } catch (IOException e) {\n            /* Ignore */\n        } finally {\n            entry = null;\n        }\n\n        // If there is an expanded directory then any xml in that directory\n        // should only be used if the directory is not out of date and\n        // unpackWARs is true. Note the code below may apply further limits\n        boolean useXml = false;\n        File expandedDir = new File(host.getAppBaseFile(), cn.getBaseName());\n        // If the xml file exists then expandedDir must exists so no need to\n        // test that here\n        if (xml.exists() && unpackWARs && expandedDir.lastModified() == war.lastModified()) {\n            useXml = true;\n        }\n\n        Context context = null;\n        try {\n            if (deployXML && useXml && !copyXML) {\n                synchronized (digesterLock) {\n                    try {\n                        context = (Context) digester.parse(xml);\n                    } catch (Exception e) {\n                        log.error(sm.getString(\n                                \"hostConfig.deployDescriptor.error\",\n                                war.getAbsolutePath()), e);\n                    } finally {\n                        if (context == null) {\n                            context = new FailedContext();\n                        }\n                        digester.reset();\n                    }\n                }\n                context.setConfigFile(xml.toURI().toURL());\n            } else if (deployXML && xmlInWar) {\n                synchronized (digesterLock) {\n                    try (JarFile jar = new JarFile(war)) {\n                        entry = jar.getJarEntry(Constants.ApplicationContextXml);\n                        try (InputStream istream = jar.getInputStream(entry)) {\n                            context = (Context) digester.parse(istream);\n                        }\n                    } catch (Exception e) {\n                        log.error(sm.getString(\n                                \"hostConfig.deployDescriptor.error\",\n                                war.getAbsolutePath()), e);\n                    } finally {\n                        if (context == null) {\n                            context = new FailedContext();\n                        }\n                        context.setConfigFile(new URL(\"jar:\" +\n                                war.toURI().toString() + \"!/\" +\n                                Constants.ApplicationContextXml));\n                        entry = null;\n                        digester.reset();\n                    }\n                }\n            } else if (!deployXML && xmlInWar) {\n                // Block deployment as META-INF/context.xml may contain security\n                // configuration necessary for a secure deployment.\n                log.error(sm.getString(\"hostConfig.deployDescriptor.blocked\",\n                        cn.getPath(), Constants.ApplicationContextXml,\n                        new File(host.getConfigBaseFile(), cn.getBaseName() + \".xml\")));\n            } else {\n                context = (Context) Class.forName(contextClass).newInstance();\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployWar.error\",\n                    war.getAbsolutePath()), t);\n        } finally {\n            if (context == null) {\n                context = new FailedContext();\n            }\n        }\n\n        boolean copyThisXml = false;\n        if (deployXML) {\n            if (host instanceof StandardHost) {\n                copyThisXml = ((StandardHost) host).isCopyXML();\n            }\n\n            // If Host is using default value Context can override it.\n            if (!copyThisXml && context instanceof StandardContext) {\n                copyThisXml = ((StandardContext) context).getCopyXML();\n            }\n\n            if (xmlInWar && copyThisXml) {\n                // Change location of XML file to config base\n                xml = new File(host.getConfigBaseFile(),\n                        cn.getBaseName() + \".xml\");\n                entry = null;\n                try (JarFile jar = new JarFile(war)) {\n                    entry = jar.getJarEntry(Constants.ApplicationContextXml);\n                    try (InputStream istream = jar.getInputStream(entry);\n                            FileOutputStream fos = new FileOutputStream(xml);\n                            BufferedOutputStream ostream = new BufferedOutputStream(fos, 1024)) {\n                        byte buffer[] = new byte[1024];\n                        while (true) {\n                            int n = istream.read(buffer);\n                            if (n < 0) {\n                                break;\n                            }\n                            ostream.write(buffer, 0, n);\n                        }\n                        ostream.flush();\n                    }\n                } catch (IOException e) {\n                    /* Ignore */\n                }\n            }\n        }\n\n        DeployedApplication deployedApp = new DeployedApplication(cn.getName(),\n                xml.exists() && deployXML && copyThisXml);\n\n        long startTime = 0;\n        // Deploy the application in this WAR file\n        if(log.isInfoEnabled()) {\n            startTime = System.currentTimeMillis();\n            log.info(sm.getString(\"hostConfig.deployWar\",\n                    war.getAbsolutePath()));\n        }\n\n        try {\n            // Populate redeploy resources with the WAR file\n            deployedApp.redeployResources.put\n                (war.getAbsolutePath(), Long.valueOf(war.lastModified()));\n\n            if (deployXML && xml.exists() && copyThisXml) {\n                deployedApp.redeployResources.put(xml.getAbsolutePath(),\n                        Long.valueOf(xml.lastModified()));\n            } else {\n                // In case an XML file is added to the config base later\n                deployedApp.redeployResources.put(\n                        (new File(host.getConfigBaseFile(),\n                                cn.getBaseName() + \".xml\")).getAbsolutePath(),\n                        Long.valueOf(0));\n            }\n\n            Class<?> clazz = Class.forName(host.getConfigClass());\n            LifecycleListener listener =\n                (LifecycleListener) clazz.newInstance();\n            context.addLifecycleListener(listener);\n\n            context.setName(cn.getName());\n            context.setPath(cn.getPath());\n            context.setWebappVersion(cn.getVersion());\n            context.setDocBase(cn.getBaseName() + \".war\");\n            host.addChild(context);\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployWar.error\",\n                    war.getAbsolutePath()), t);\n        } finally {\n            // If we're unpacking WARs, the docBase will be mutated after\n            // starting the context\n            boolean unpackWAR = unpackWARs;\n            if (unpackWAR && context instanceof StandardContext) {\n                unpackWAR = ((StandardContext) context).getUnpackWAR();\n            }\n            if (unpackWAR && context != null && context.getDocBase() != null) {\n                File docBase = new File(host.getAppBaseFile(), cn.getBaseName());\n                deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                        Long.valueOf(docBase.lastModified()));\n                addWatchedResources(deployedApp, docBase.getAbsolutePath(),\n                        context);\n                if (deployXML && !copyThisXml && (xmlInWar || xml.exists())) {\n                    deployedApp.redeployResources.put(xml.getAbsolutePath(),\n                            Long.valueOf(xml.lastModified()));\n                }\n            } else {\n                // Passing null for docBase means that no resources will be\n                // watched. This will be logged at debug level.\n                addWatchedResources(deployedApp, null, context);\n            }\n            // Add the global redeploy resources (which are never deleted) at\n            // the end so they don't interfere with the deletion process\n            addGlobalRedeployResources(deployedApp);\n        }\n\n        deployed.put(cn.getName(), deployedApp);\n\n        if (log.isInfoEnabled()) {\n            log.info(sm.getString(\"hostConfig.deployWar.finished\",\n                war.getAbsolutePath(), Long.valueOf(System.currentTimeMillis() - startTime)));\n        }\n    }","id":90376,"modified_method":"/**\n     * @param cn\n     * @param war\n     */\n    protected void deployWAR(ContextName cn, File war) {\n\n        File xml = new File(host.getAppBaseFile(),\n                cn.getBaseName() + \"/\" + Constants.ApplicationContextXml);\n\n        File warTracker = new File(host.getAppBaseFile(),\n                cn.getBaseName() + \"/\" + Constants.WarTracker);\n\n        boolean xmlInWar = false;\n        JarEntry entry = null;\n        try (JarFile jar = new JarFile(war)) {\n            entry = jar.getJarEntry(Constants.ApplicationContextXml);\n            if (entry != null) {\n                xmlInWar = true;\n            }\n        } catch (IOException e) {\n            /* Ignore */\n        } finally {\n            entry = null;\n        }\n\n        // If there is an expanded directory then any xml in that directory\n        // should only be used if the directory is not out of date and\n        // unpackWARs is true. Note the code below may apply further limits\n        boolean useXml = false;\n        // If the xml file exists then expandedDir must exists so no need to\n        // test that here\n        if (xml.exists() && unpackWARs &&\n                (!warTracker.exists() || warTracker.lastModified() == war.lastModified())) {\n            useXml = true;\n        }\n\n        Context context = null;\n        try {\n            if (deployXML && useXml && !copyXML) {\n                synchronized (digesterLock) {\n                    try {\n                        context = (Context) digester.parse(xml);\n                    } catch (Exception e) {\n                        log.error(sm.getString(\n                                \"hostConfig.deployDescriptor.error\",\n                                war.getAbsolutePath()), e);\n                    } finally {\n                        if (context == null) {\n                            context = new FailedContext();\n                        }\n                        digester.reset();\n                    }\n                }\n                context.setConfigFile(xml.toURI().toURL());\n            } else if (deployXML && xmlInWar) {\n                synchronized (digesterLock) {\n                    try (JarFile jar = new JarFile(war)) {\n                        entry = jar.getJarEntry(Constants.ApplicationContextXml);\n                        try (InputStream istream = jar.getInputStream(entry)) {\n                            context = (Context) digester.parse(istream);\n                        }\n                    } catch (Exception e) {\n                        log.error(sm.getString(\n                                \"hostConfig.deployDescriptor.error\",\n                                war.getAbsolutePath()), e);\n                    } finally {\n                        if (context == null) {\n                            context = new FailedContext();\n                        }\n                        context.setConfigFile(new URL(\"jar:\" +\n                                war.toURI().toString() + \"!/\" +\n                                Constants.ApplicationContextXml));\n                        entry = null;\n                        digester.reset();\n                    }\n                }\n            } else if (!deployXML && xmlInWar) {\n                // Block deployment as META-INF/context.xml may contain security\n                // configuration necessary for a secure deployment.\n                log.error(sm.getString(\"hostConfig.deployDescriptor.blocked\",\n                        cn.getPath(), Constants.ApplicationContextXml,\n                        new File(host.getConfigBaseFile(), cn.getBaseName() + \".xml\")));\n            } else {\n                context = (Context) Class.forName(contextClass).newInstance();\n            }\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployWar.error\",\n                    war.getAbsolutePath()), t);\n        } finally {\n            if (context == null) {\n                context = new FailedContext();\n            }\n        }\n\n        boolean copyThisXml = false;\n        if (deployXML) {\n            if (host instanceof StandardHost) {\n                copyThisXml = ((StandardHost) host).isCopyXML();\n            }\n\n            // If Host is using default value Context can override it.\n            if (!copyThisXml && context instanceof StandardContext) {\n                copyThisXml = ((StandardContext) context).getCopyXML();\n            }\n\n            if (xmlInWar && copyThisXml) {\n                // Change location of XML file to config base\n                xml = new File(host.getConfigBaseFile(),\n                        cn.getBaseName() + \".xml\");\n                entry = null;\n                try (JarFile jar = new JarFile(war)) {\n                    entry = jar.getJarEntry(Constants.ApplicationContextXml);\n                    try (InputStream istream = jar.getInputStream(entry);\n                            FileOutputStream fos = new FileOutputStream(xml);\n                            BufferedOutputStream ostream = new BufferedOutputStream(fos, 1024)) {\n                        byte buffer[] = new byte[1024];\n                        while (true) {\n                            int n = istream.read(buffer);\n                            if (n < 0) {\n                                break;\n                            }\n                            ostream.write(buffer, 0, n);\n                        }\n                        ostream.flush();\n                    }\n                } catch (IOException e) {\n                    /* Ignore */\n                }\n            }\n        }\n\n        DeployedApplication deployedApp = new DeployedApplication(cn.getName(),\n                xml.exists() && deployXML && copyThisXml);\n\n        long startTime = 0;\n        // Deploy the application in this WAR file\n        if(log.isInfoEnabled()) {\n            startTime = System.currentTimeMillis();\n            log.info(sm.getString(\"hostConfig.deployWar\",\n                    war.getAbsolutePath()));\n        }\n\n        try {\n            // Populate redeploy resources with the WAR file\n            deployedApp.redeployResources.put\n                (war.getAbsolutePath(), Long.valueOf(war.lastModified()));\n\n            if (deployXML && xml.exists() && copyThisXml) {\n                deployedApp.redeployResources.put(xml.getAbsolutePath(),\n                        Long.valueOf(xml.lastModified()));\n            } else {\n                // In case an XML file is added to the config base later\n                deployedApp.redeployResources.put(\n                        (new File(host.getConfigBaseFile(),\n                                cn.getBaseName() + \".xml\")).getAbsolutePath(),\n                        Long.valueOf(0));\n            }\n\n            Class<?> clazz = Class.forName(host.getConfigClass());\n            LifecycleListener listener =\n                (LifecycleListener) clazz.newInstance();\n            context.addLifecycleListener(listener);\n\n            context.setName(cn.getName());\n            context.setPath(cn.getPath());\n            context.setWebappVersion(cn.getVersion());\n            context.setDocBase(cn.getBaseName() + \".war\");\n            host.addChild(context);\n        } catch (Throwable t) {\n            ExceptionUtils.handleThrowable(t);\n            log.error(sm.getString(\"hostConfig.deployWar.error\",\n                    war.getAbsolutePath()), t);\n        } finally {\n            // If we're unpacking WARs, the docBase will be mutated after\n            // starting the context\n            boolean unpackWAR = unpackWARs;\n            if (unpackWAR && context instanceof StandardContext) {\n                unpackWAR = ((StandardContext) context).getUnpackWAR();\n            }\n            if (unpackWAR && context != null && context.getDocBase() != null) {\n                File docBase = new File(host.getAppBaseFile(), cn.getBaseName());\n                deployedApp.redeployResources.put(docBase.getAbsolutePath(),\n                        Long.valueOf(docBase.lastModified()));\n                addWatchedResources(deployedApp, docBase.getAbsolutePath(),\n                        context);\n                if (deployXML && !copyThisXml && (xmlInWar || xml.exists())) {\n                    deployedApp.redeployResources.put(xml.getAbsolutePath(),\n                            Long.valueOf(xml.lastModified()));\n                }\n            } else {\n                // Passing null for docBase means that no resources will be\n                // watched. This will be logged at debug level.\n                addWatchedResources(deployedApp, null, context);\n            }\n            // Add the global redeploy resources (which are never deleted) at\n            // the end so they don't interfere with the deletion process\n            addGlobalRedeployResources(deployedApp);\n        }\n\n        deployed.put(cn.getName(), deployedApp);\n\n        if (log.isInfoEnabled()) {\n            log.info(sm.getString(\"hostConfig.deployWar.finished\",\n                war.getAbsolutePath(), Long.valueOf(System.currentTimeMillis() - startTime)));\n        }\n    }","commit_id":"517f398e163ab7abc90dce0a577b1918ee0742e8","url":"https://github.com/apache/tomcat"},{"original_method":"/**\n     * Retrieves the real location of a GSP within a Grails project.\n     * @param location The location of the GSP at deployment time\n     * @return The location of the GSP at development time\n     */\n    protected String getRealLocationInProject(String location) {\n\n        if (!location.startsWith(SLASH)) location = SLASH + location;\n\n        if (!location.startsWith(GrailsResourceUtils.WEB_INF)) {\n            return GrailsResourceUtils.WEB_APP_DIR+location;\n        }\n\n        final String noWebInf = location.substring(GrailsResourceUtils.WEB_INF.length() + 1);\n        final String defaultPath = \"file:\" + baseLocation + SLASH + noWebInf;\n        if (!noWebInf.startsWith(PLUGINS_PREFIX)) {\n            return defaultPath;\n        }\n\n        if (application != null) {\n\n            BuildSettings settings = BuildSettingsHolder.getSettings();\n            PluginBuildSettings pluginBuildSettings = org.codehaus.groovy.grails.plugins.GrailsPluginUtils.getPluginBuildSettings();\n            String pluginPath = StringUtils.substringAfter(noWebInf, SLASH);\n            String pluginName = StringUtils.substringBefore(pluginPath, SLASH);\n            String remainingPath = StringUtils.substringAfter(pluginPath, SLASH);\n            Resource r = pluginBuildSettings.getPluginDirForName(pluginName);\n            if (r != null) {\n                try {\n                    return \"file:\" + r.getFile().getAbsolutePath() + SLASH + remainingPath;\n                }\n                catch (IOException e) {\n                    return defaultPath;\n                }\n            }\n\n            if (settings != null) {\n                return \"file:\" + settings.getProjectPluginsDir().getAbsolutePath() + SLASH + pluginName + SLASH + remainingPath;\n            }\n        }\n\n        return defaultPath;\n    }","id":90377,"modified_method":"/**\n     * Retrieves the real location of a GSP within a Grails project.\n     * @param location The location of the GSP at deployment time\n     * @return The location of the GSP at development time\n     */\n    protected String getRealLocationInProject(String location) {\n\n        if (!location.startsWith(SLASH)) location = SLASH + location;\n\n\t\t// If the location (minus the \"grails-app/.*\" ending so that it matches the key value used in BuildSettings for\n\t\t// the inline plugin map) matches an \"inline\" plugin, use the location as-is\n\t\t// for the resource location.  Otherwise, perform the logic to \"normalize\" the resource location based on\n\t\t// its relativity to the application (i.e. is it from a non-inline plugin, etc).\n\t\tif(BuildSettingsHolder.getSettings().isInlinePluginLocation(new File(location.replaceAll(GRAILS_APP_DIR_PATTERN, \"\")))) {\n\t\t\treturn \"file:\" + location;\n\t\t} else {\n\t        if (!location.startsWith(GrailsResourceUtils.WEB_INF)) {\n\t            return GrailsResourceUtils.WEB_APP_DIR+location;\n\t        }\n\n\t        final String noWebInf = location.substring(GrailsResourceUtils.WEB_INF.length() + 1);\n\t        final String defaultPath = \"file:\" + baseLocation + SLASH + noWebInf;\n\t        if (!noWebInf.startsWith(PLUGINS_PREFIX)) {\n\t            return defaultPath;\n\t        }\n\n\t        if (application != null) {\n\n\t            BuildSettings settings = BuildSettingsHolder.getSettings();\n\t            PluginBuildSettings pluginBuildSettings = org.codehaus.groovy.grails.plugins.GrailsPluginUtils.getPluginBuildSettings();\n\t            String pluginPath = StringUtils.substringAfter(noWebInf, SLASH);\n\t            String pluginName = StringUtils.substringBefore(pluginPath, SLASH);\n\t            String remainingPath = StringUtils.substringAfter(pluginPath, SLASH);\n\t            Resource r = pluginBuildSettings.getPluginDirForName(pluginName);\n\t            if (r != null) {\n\t                try {\n\t                    return \"file:\" + r.getFile().getAbsolutePath() + SLASH + remainingPath;\n\t                }\n\t                catch (IOException e) {\n\t\t\t\t\t\tLOG.debug(\"Unable to locate plugin resource -- returning default path \" + defaultPath + \".\", e);\n\t                    return defaultPath;\n\t                }\n\t            }\n\n\t            if (settings != null) {\n\t                return \"file:\" + settings.getProjectPluginsDir().getAbsolutePath() + SLASH + pluginName + SLASH + remainingPath;\n\t            }\n\t        }\n\n\t        return defaultPath;\n\t\t}\n    }","commit_id":"c4ccd00fe153113a29476f37cd361c6ccea919b4","url":"https://github.com/grails/grails-core"},{"original_method":"public void afterPropertiesSet() throws Exception {\n        if (pluginManager != null && localResourceLoader != null) {\n            GrailsPlugin[] plugins = pluginManager.getAllPlugins();\n            for (GrailsPlugin plugin : plugins) {\n                Resource[] pluginBundles;\n\n                final String pluginName = plugin.getFileSystemName();\n                pluginBundles = getPluginBundles(pluginName);\n                for (Resource pluginBundle : pluginBundles) {\n                    String baseName = FilenameUtils.getBaseName(pluginBundle.getFilename());\n                    baseName = StringUtils.substringBefore(baseName,\"_\");\n                    pluginBaseNames.add(WEB_INF_PLUGINS_PATH.substring(1) + pluginName + \"/grails-app/i18n/\" + baseName);\n                }\n            }\n        }\n    }","id":90378,"modified_method":"public void afterPropertiesSet() throws Exception {\n        if (pluginManager != null && localResourceLoader != null) {\n\n            GrailsPlugin[] plugins = pluginManager.getAllPlugins();\n            for (GrailsPlugin plugin : plugins) {\n                Resource[] pluginBundles;\n                pluginBundles = getPluginBundles(plugin);\n                for (Resource pluginBundle : pluginBundles) {\n\t\t\t\t\tString basePath = null;\n\t\t\t\t\tfinal String baseName = StringUtils.substringBefore(FilenameUtils.getBaseName(pluginBundle.getFilename()), \"_\");\n\n\t\t\t\t\t// If the plugin is an inline plugin, use the abosolute path to the plugin's i18n files.\n\t\t\t\t\t// Otherwise, use the relative path to the plugin from the application's perspective.\n\t\t\t\t\tif(isInlinePlugin(plugin)) {\n\t\t\t\t\t\tbasePath = getInlinePluginPath(plugin);\n\t\t\t\t\t} else {\n                    \tbasePath = WEB_INF_PLUGINS_PATH.substring(1) + plugin.getFileSystemName();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tpluginBaseNames.add(basePath + \"/grails-app/i18n/\" + baseName);\n                }\n            }\n        }\n    }","commit_id":"c4ccd00fe153113a29476f37cd361c6ccea919b4","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n     * Get a PropertiesHolder that contains the actually visible properties\n     * for a Locale, after merging all specified resource bundles.\n     * Either fetches the holder from the cache or freshly loads it.\n     * <p>Only used when caching resource bundle contents forever, i.e.\n     * with cacheSeconds < 0. Therefore, merged properties are always\n     * cached forever.\n     */\n    protected PropertiesHolder getMergedPluginProperties(Locale locale) {\n        PropertiesHolder mergedHolder = cachedMergedPluginProperties.get(locale);\n        if (mergedHolder != null) {\n            return mergedHolder;\n        }\n\n        Properties mergedProps = new Properties();\n        mergedHolder = new PropertiesHolder(mergedProps, -1);\n        for (String basename : pluginBaseNames) {\n            List<String> filenames = calculateAllFilenames(basename, locale);\n            for (int j = filenames.size() - 1; j >= 0; j--) {\n                String filename = filenames.get(j);\n                PropertiesHolder propHolder = getProperties(filename);\n                if (propHolder.getProperties() != null) {\n                    mergedProps.putAll(propHolder.getProperties());\n                }\n            }\n        }\n        final GrailsPlugin[] allPlugins = pluginManager.getAllPlugins();\n        for (GrailsPlugin plugin : allPlugins) {\n            if (plugin instanceof BinaryGrailsPlugin) {\n                BinaryGrailsPlugin binaryPlugin = (BinaryGrailsPlugin) plugin;\n                final Properties binaryPluginProperties = binaryPlugin.getProperties(locale);\n                if (binaryPluginProperties != null) {\n                    mergedProps.putAll(binaryPluginProperties);\n                }\n            }\n        }\n        cachedMergedPluginProperties.put(locale, mergedHolder);\n        return mergedHolder;\n    }","id":90379,"modified_method":"/**\n\t * Returns the i18n message bundles for the provided plugin or an empty\n\t * array if the plugin does not contain any .properties files in its\n\t * grails-app/i18n folder.\n\t * @param grailsPlugin The grails plugin that may or may not contain i18n internationalization files.\n\t * @returns An array of {@code Resource} objects representing the internationalization files or\n\t *    an empty array if no files are found.\n\t */\n    protected Resource[] getPluginBundles(GrailsPlugin grailsPlugin) {\n        try {\n\t\t\tString basePath = null;\n\t\t\t\n\t\t\t// If the plugin is inline, use the absolute path to the internationalization files\n\t\t\t// in order to convert to resources.  Otherwise, use the relative WEB-INF path.\n\t\t\tif(isInlinePlugin(grailsPlugin)) {\n\t\t\t\tbasePath = getInlinePluginPath(grailsPlugin);\n\t\t\t} else {\n\t\t\t\tbasePath = WEB_INF_PLUGINS_PATH + grailsPlugin.getFileSystemName();\n\t\t\t}\n\t\t\t\n            return resourceResolver.getResources(basePath + \"/grails-app/i18n/*.properties\");\n        }\n        catch (Exception e) {\n\t\t\tLOG.debug(\"Could not resolve any resources for plugin \" + grailsPlugin.getFileSystemName(), e);\n            return new Resource[0];\n        }\n    }","commit_id":"c4ccd00fe153113a29476f37cd361c6ccea919b4","url":"https://github.com/grails/grails-core"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws URISyntaxException {\n                \n                JettyHttpComponent componentJetty = (JettyHttpComponent) context.getComponent(\"jetty\");\n                Map<Integer, SslSocketConnector> connectors = new HashMap<Integer, SslSocketConnector>();\n                connectors.put(9080, createSslSocketConnector());\n                connectors.put(9090, createSslSocketConnector());\n                \n                componentJetty.setSslSocketConnectors(connectors);\n                \n                from(\"jetty:https://localhost:9080/test\").to(\"mock:a\");\n\n                Processor proc = new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\"<b>Hello World<\/b>\");\n                    }\n                };\n                from(\"jetty:https://localhost:9080/hello\").process(proc);\n                \n                from(\"jetty:https://localhost:9090/test\").to(\"mock:b\");\n            }\n        };\n    }","id":90380,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws URISyntaxException {\n                // START SNIPPET: e1\n                // create SSL socket connectors for port 9080 and 9090\n                Map<Integer, SslSocketConnector> connectors = new HashMap<Integer, SslSocketConnector>();\n                connectors.put(9080, createSslSocketConnector());\n                connectors.put(9090, createSslSocketConnector());\n\n                // create jetty component\n                JettyHttpComponent jetty = new JettyHttpComponent();\n                // add connectors\n                jetty.setSslSocketConnectors(connectors);\n                // add jetty to camel context\n                context.addComponent(\"jetty\", jetty);\n                // END SNIPPET: e1\n\n                from(\"jetty:https://localhost:9080/test\").to(\"mock:a\");\n\n                Processor proc = new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\"<b>Hello World<\/b>\");\n                    }\n                };\n                from(\"jetty:https://localhost:9080/hello\").process(proc);\n                \n                from(\"jetty:https://localhost:9090/test\").to(\"mock:b\");\n            }\n        };\n    }","commit_id":"9983c854ca6f42b249a5ecced81d5abcc9e25079","url":"https://github.com/apache/camel"},{"original_method":"protected Server createServer() throws Exception {\n        Server server = new Server();\n        ContextHandlerCollection collection = new ContextHandlerCollection();\n        server.setHandler(collection);\n        return server;\n    }","id":90381,"modified_method":"protected Server createServer() throws Exception {\n        Server server = new Server();\n        ContextHandlerCollection collection = new ContextHandlerCollection();\n        server.setHandler(collection);\n\n        // configure thread pool if min/max given\n        if (minThreads != null || maxThreads != null) {\n            if (getThreadPool() != null) {\n                throw new IllegalArgumentException(\"You cannot configure both minThreads/maxThreads and a custom threadPool on JettyHttpComponent: \" + this);\n            }\n            QueuedThreadPool qtp = new QueuedThreadPool();\n            if (minThreads != null) {\n                qtp.setMinThreads(minThreads.intValue());\n            }\n            if (maxThreads != null) {\n                qtp.setMaxThreads(maxThreads.intValue());\n            }\n            try {\n                qtp.start();\n            } catch (Exception e) {\n                throw new RuntimeCamelException(\"Error starting JettyServer thread pool: \" + qtp, e);\n            }\n            server.setThreadPool(qtp);\n        }\n\n        if (getThreadPool() != null) {\n            server.setThreadPool(getThreadPool());\n        }\n\n        return server;\n    }","commit_id":"9983c854ca6f42b249a5ecced81d5abcc9e25079","url":"https://github.com/apache/camel"},{"original_method":"public SslSocketConnector getSslSocketConnector(int port) {\n        SslSocketConnector answer = null;\n        if (sslSocketConnectors != null) {\n            answer = sslSocketConnectors.get(port);\n        }\n        if (answer == null) {\n            answer = createSslSocketConnector();\n        } else {\n            // try the keystore system property as a backup, jetty doesn't seem\n            // to read this property anymore\n            String keystoreProperty = System.getProperty(JETTY_SSL_KEYSTORE);\n            if (keystoreProperty != null) {\n                answer.setKeystore(keystoreProperty);\n            }\n\n        }\n        return answer;\n    }","id":90382,"modified_method":"protected SslSocketConnector getSslSocketConnector(int port) throws Exception {\n        SslSocketConnector answer = null;\n        if (sslSocketConnectors != null) {\n            answer = sslSocketConnectors.get(port);\n        }\n        if (answer == null) {\n            answer = createSslSocketConnector();\n        }\n        return answer;\n    }","commit_id":"9983c854ca6f42b249a5ecced81d5abcc9e25079","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    @Override\n    public void connect(HttpConsumer consumer) throws Exception {\n        // Make sure that there is a connector for the requested endpoint.\n        JettyHttpEndpoint endpoint = (JettyHttpEndpoint)consumer.getEndpoint();\n        String connectorKey = getConnectorKey(endpoint);\n\n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef == null) {\n                Connector connector;\n                if (\"https\".equals(endpoint.getProtocol())) {\n                    connector = getSslSocketConnector(endpoint.getPort());\n                } else {\n                    connector = new SelectChannelConnector();\n                }\n                connector.setPort(endpoint.getPort());\n                connector.setHost(endpoint.getHttpUri().getHost());\n                if (\"localhost\".equalsIgnoreCase(endpoint.getHttpUri().getHost())) {\n                    LOG.warn(\"You use localhost interface! It means that no external connections will be available.\"\n                            + \" Don't you want to use 0.0.0.0 instead (all network interfaces)? \" + endpoint);\n                }\n                Server server = createServer();\n                if (endpoint.isEnableJmx()) {\n                    enableJmx(server);\n                }\n                server.addConnector(connector);\n\n                connectorRef = new ConnectorRef(server, connector, createServletForConnector(server, connector, endpoint.getHandlers()));\n                // must enable session before we start\n                if (endpoint.isSessionSupport()) {\n                    enableSessionSupport(connectorRef.server, connectorKey);\n                }\n                connectorRef.server.start();\n                \n                CONNECTORS.put(connectorKey, connectorRef);\n                \n            } else {\n                // ref track the connector\n                connectorRef.increment();\n            }\n            // check the session support\n            if (endpoint.isSessionSupport()) {\n                enableSessionSupport(connectorRef.server, connectorKey);\n            }\n            connectorRef.servlet.connect(consumer);\n        }\n    }","id":90383,"modified_method":"/**\n     * Connects the URL specified on the endpoint to the specified processor.\n     */\n    @Override\n    public void connect(HttpConsumer consumer) throws Exception {\n        // Make sure that there is a connector for the requested endpoint.\n        JettyHttpEndpoint endpoint = (JettyHttpEndpoint)consumer.getEndpoint();\n        String connectorKey = getConnectorKey(endpoint);\n\n        synchronized (CONNECTORS) {\n            ConnectorRef connectorRef = CONNECTORS.get(connectorKey);\n            if (connectorRef == null) {\n                Connector connector;\n                if (\"https\".equals(endpoint.getProtocol())) {\n                    connector = getSslSocketConnector(endpoint.getPort());\n                } else {\n                    connector = getSocketConnector(endpoint.getPort());\n                }\n                connector.setPort(endpoint.getPort());\n                connector.setHost(endpoint.getHttpUri().getHost());\n                if (\"localhost\".equalsIgnoreCase(endpoint.getHttpUri().getHost())) {\n                    LOG.warn(\"You use localhost interface! It means that no external connections will be available.\"\n                            + \" Don't you want to use 0.0.0.0 instead (all network interfaces)? \" + endpoint);\n                }\n                Server server = createServer();\n                if (endpoint.isEnableJmx()) {\n                    enableJmx(server);\n                }\n                server.addConnector(connector);\n\n                connectorRef = new ConnectorRef(server, connector, createServletForConnector(server, connector, endpoint.getHandlers()));\n                // must enable session before we start\n                if (endpoint.isSessionSupport()) {\n                    enableSessionSupport(connectorRef.server, connectorKey);\n                }\n                connectorRef.server.start();\n                \n                CONNECTORS.put(connectorKey, connectorRef);\n                \n            } else {\n                // ref track the connector\n                connectorRef.increment();\n            }\n            // check the session support\n            if (endpoint.isSessionSupport()) {\n                enableSessionSupport(connectorRef.server, connectorKey);\n            }\n            connectorRef.servlet.connect(consumer);\n        }\n    }","commit_id":"9983c854ca6f42b249a5ecced81d5abcc9e25079","url":"https://github.com/apache/camel"},{"original_method":"public SslSocketConnector createSslSocketConnector() {\n        SslSocketConnector answer = new SslSocketConnector();\n        // with default null values, jetty ssl system properties\n        // and console will be read by jetty implementation\n        answer.setPassword(sslPassword);\n        answer.setKeyPassword(sslKeyPassword);\n        if (sslKeystore != null) {\n            answer.setKeystore(sslKeystore);\n        } else {\n            // try the keystore system property as a backup, jetty doesn't seem\n            // to read this property anymore\n            String keystoreProperty = System.getProperty(JETTY_SSL_KEYSTORE);\n            if (keystoreProperty != null) {\n                answer.setKeystore(keystoreProperty);\n            }\n        }\n        \n        return answer;\n    }","id":90384,"modified_method":"protected SslSocketConnector createSslSocketConnector() throws Exception {\n        SslSocketConnector answer = new SslSocketConnector();\n        // with default null values, jetty ssl system properties\n        // and console will be read by jetty implementation\n\n        String keystoreProperty = System.getProperty(JETTY_SSL_KEYSTORE);\n        if (keystoreProperty != null) {\n            answer.setKeystore(keystoreProperty);\n        } else if (sslKeystore != null) {\n            answer.setKeystore(sslKeystore);\n        }\n\n        String keystorePassword = System.getProperty(JETTY_SSL_KEYPASSWORD);\n        if (keystorePassword != null) {\n            answer.setKeyPassword(keystorePassword);\n        } else if (sslKeyPassword != null) {\n            answer.setKeyPassword(sslKeyPassword);\n        }\n\n        String password = System.getProperty(JETTY_SSL_PASSWORD);\n        if (password != null) {\n            answer.setPassword(password);\n        } else if (sslPassword != null) {\n            answer.setPassword(sslPassword);\n        }\n\n        if (getSslSocketConnectorProperties() != null) {\n            // must copy the map otherwise it will be deleted\n            Map<String, Object> properties = new HashMap<String, Object>(getSslSocketConnectorProperties());\n            IntrospectionSupport.setProperties(answer, properties);\n            if (properties.size() > 0) {\n                throw new IllegalArgumentException(\"There are \" + properties.size()\n                    + \" parameters that couldn't be set on the SslSocketConnector.\"\n                    + \" Check the uri if the parameters are spelt correctly and that they are properties of the SslSocketConnector.\"\n                    + \" Unknown parameters=[\" + properties + \"]\");\n            }\n        }\n        return answer;\n    }","commit_id":"9983c854ca6f42b249a5ecced81d5abcc9e25079","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public boolean updateAccount(final Account account) throws PermissionDeniedException, EXistException {\n        \n        //make sure we have permission to modify this account\n        final Account user = getDatabase().getSubject();\n        account.assertCanModifyAccount(user);\n        \n        //modify the account\n        final Account updatingAccount = getAccount(account.getName());\n        if(updatingAccount == null) {\n            throw new PermissionDeniedException(\"account \" + account.getName() + \" does not exist\");\n        }\n\n        //check: add account to group\n        String[] groups = account.getGroups();\n        for (int i = 0; i < groups.length; i++) {\n            if (!(updatingAccount.hasGroup(groups[i]))) {\n                updatingAccount.addGroup(groups[i]);\n            }\n        }\n        //check: remove account from group\n        groups = updatingAccount.getGroups();\n\n        for (int i = 0; i < groups.length; i++) {\n            if(!(account.hasGroup(groups[i]))) {\n                updatingAccount.remGroup(groups[i]);\n            }\n        }\n\n        updatingAccount.setPassword(account.getPassword());\n        updatingAccount.setUserMask(account.getUserMask());\n        \n        //update the metadata\n        if(account.hashCode() != updatingAccount.hashCode()) {\n            updatingAccount.clearMetadata();\n            for(final SchemaType key : account.getMetadataKeys()) {\n                updatingAccount.setMetadataValue(key, account.getMetadataValue(key));\n            }\n        }\n        \n\n        ((AbstractPrincipal)updatingAccount).save();\n\n        return true;\n    }","id":90385,"modified_method":"@Override\n    public boolean updateAccount(final Account account) throws PermissionDeniedException, EXistException {\n        \n        //make sure we have permission to modify this account\n        final Account user = getDatabase().getSubject();\n        account.assertCanModifyAccount(user);\n        \n        //modify the account\n        final Account updatingAccount = getAccount(account.getName());\n        if(updatingAccount == null) {\n            throw new PermissionDeniedException(\"account \" + account.getName() + \" does not exist\");\n        }\n\n        //check: add account to group\n        String[] groups = account.getGroups();\n        for (int i = 0; i < groups.length; i++) {\n            if (!(updatingAccount.hasGroup(groups[i]))) {\n                updatingAccount.addGroup(groups[i]);\n            }\n        }\n        //check: remove account from group\n        groups = updatingAccount.getGroups();\n\n        for (int i = 0; i < groups.length; i++) {\n            if(!(account.hasGroup(groups[i]))) {\n                updatingAccount.remGroup(groups[i]);\n            }\n        }\n\n        final String passwd = account.getPassword();\n        if (passwd != null) {\n            // if password is empty, ignore it to keep the old one\n            // assumes that empty passwords should never be allowed\n            updatingAccount.setPassword(account.getPassword());\n        }\n        updatingAccount.setUserMask(account.getUserMask());\n        \n        //update the metadata\n        if(account.hashCode() != updatingAccount.hashCode()) {\n            updatingAccount.clearMetadata();\n            for(final SchemaType key : account.getMetadataKeys()) {\n                updatingAccount.setMetadataValue(key, account.getMetadataValue(key));\n            }\n        }\n        \n\n        ((AbstractPrincipal)updatingAccount).save();\n\n        return true;\n    }","commit_id":"80d313594cc65deb9f1117dbccd5cfaa317f11b8","url":"https://github.com/eXist-db/exist"},{"original_method":"@Override\n  public void reset() {\n    Project project = StudyUtils.getStudyProject();\n    if (project != null) {\n      final StepicUser user = StudyTaskManager.getInstance(project).getUser();\n      setLogin(user.getEmail());\n      setPassword(DEFAULT_PASSWORD_TEXT);\n\n      resetCredentialsModification();\n    }\n    else {\n      LOG.warn(\"No study object is opened\");\n    }\n  }","id":90386,"modified_method":"@Override\n  public void reset() {\n    Project project = StudyUtils.getStudyProject();\n    if (project != null) {\n      final StepicUser user = StudyTaskManager.getInstance(project).getUser();\n      if (user != null) {\n        setLogin(user.getEmail());\n        setPassword(DEFAULT_PASSWORD_TEXT);\n      }\n      resetCredentialsModification();\n    }\n    else {\n      LOG.warn(\"No study object is opened\");\n    }\n  }","commit_id":"5553e9a6f30dde77dfd2c91ad2e3cf027039149b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void endTimer(WOContext aContext, String aString) {\n\t\t\ttry {\n\t\t\t\tlong requestTime = 0;\n\t\t\t\tif (hasTimerStarted()) {\n\t\t\t\t\trequestTime = System.currentTimeMillis() - time();\n\t\t\t\t}\n\t\t\t\tThread currentThread = Thread.currentThread();\n\t\t\t\tMap<Thread, StackTraceElement[]> traces = _fatalTraces.remove(currentThread);\n\t\t\t\tMap<Thread, String> names = _fatalTracesNames.remove(currentThread);\n\t\t\t\tif (traces == null) {\n\t\t\t\t\ttraces = _errorTraces.remove(currentThread);\n\t\t\t\t\tnames = _errorTracesNames.remove(currentThread);\n\t\t\t\t}\n\t\t\t\tif (traces == null) {\n\t\t\t\t\ttraces = _warnTraces.remove(currentThread);\n\t\t\t\t\tnames = _warnTracesNames.remove(currentThread);\n\t\t\t\t}\n\t\t\t\tString trace = stringFromTraces(traces, names);\n\t\t\t\tsynchronized (_requestThreads) {\n\t\t\t\t\t_requestThreads.remove(Thread.currentThread());\n\t\t\t\t}\n\t\t\t\tif (requestTime > maximumRequestFatalTime) {\n\t\t\t\t\tString requestDescription = aContext == null ? aString : descriptionForContext(aContext);\n\t\t\t\t\tlog.fatal(\"Request did take too long : \" + requestTime + \"ms request was: \" + requestDescription + trace);\n\t\t\t\t}\n\t\t\t\telse if (requestTime > maximumRequestErrorTime) {\n\t\t\t\t\tString requestDescription = aContext == null ? aString : descriptionForContext(aContext);\n\t\t\t\t\tlog.error(\"Request did take too long : \" + requestTime + \"ms request was: \" + requestDescription + trace);\n\t\t\t\t}\n\t\t\t\telse if (requestTime > maximumRequestWarnTime) {\n\t\t\t\t\tString requestDescription = aContext == null ? aString : descriptionForContext(aContext);\n\t\t\t\t\tlog.warn(\"Request did take too long : \" + requestTime + \"ms request was: \" + requestDescription + trace);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// AK: pretty important we don't mess up here\n\t\t\t\tlog.error(ex, ex);\n\t\t\t}\n\t\t}","id":90387,"modified_method":"protected void endTimer(WOContext aContext, String aString) {\n\t\t\ttry {\n\t\t\t\tlong requestTime = 0;\n\t\t\t\tif (hasTimerStarted()) {\n\t\t\t\t\trequestTime = System.currentTimeMillis() - time();\n\t\t\t\t}\n\t\t\t\tThread currentThread = Thread.currentThread();\n\t\t\t\tMap<Thread, StackTraceElement[]> traces = _fatalTraces.remove(currentThread);\n\t\t\t\tMap<Thread, String> names = _fatalTracesNames.remove(currentThread);\n\t\t\t\tif (traces == null) {\n\t\t\t\t\ttraces = _errorTraces.remove(currentThread);\n\t\t\t\t\tnames = _errorTracesNames.remove(currentThread);\n\t\t\t\t}\n\t\t\t\tif (traces == null) {\n\t\t\t\t\ttraces = _warnTraces.remove(currentThread);\n\t\t\t\t\tnames = _warnTracesNames.remove(currentThread);\n\t\t\t\t}\n\t\t\t\tString trace = stringFromTraces(traces, names);\n\t\t\t\tsynchronized (_requestThreads) {\n\t\t\t\t\t_requestThreads.remove(Thread.currentThread());\n\t\t\t\t}\n\t\t\t\tlong currentTime = System.currentTimeMillis();\n\t\t\t\tif(currentTime - _lastLog > 10000) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t_lastLog = currentTime;\n\t\t\t\tif (requestTime > _maximumRequestFatalTime) {\n\t\t\t\t\tString requestDescription = aContext == null ? aString : descriptionForContext(aContext);\n\t\t\t\t\tlog.fatal(\"Request did take too long : \" + requestTime + \"ms request was: \" + requestDescription + trace);\n\t\t\t\t}\n\t\t\t\telse if (requestTime > _maximumRequestErrorTime) {\n\t\t\t\t\tString requestDescription = aContext == null ? aString : descriptionForContext(aContext);\n\t\t\t\t\tlog.error(\"Request did take too long : \" + requestTime + \"ms request was: \" + requestDescription + trace);\n\t\t\t\t}\n\t\t\t\telse if (requestTime > _maximumRequestWarnTime) {\n\t\t\t\t\tString requestDescription = aContext == null ? aString : descriptionForContext(aContext);\n\t\t\t\t\tlog.warn(\"Request did take too long : \" + requestTime + \"ms request was: \" + requestDescription + trace);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// AK: pretty important we don't mess up here\n\t\t\t\tlog.error(ex, ex);\n\t\t\t}\n\t\t}","commit_id":"e5e34bc4f4d5226ed8d57d31acee0dee888665ec","url":"https://github.com/wocommunity/wonder"},{"original_method":"public StopWatchTimer() {\n\t\t\tThread timerThread = new Thread(this);\n\t\t\ttimerThread.setDaemon(true);\n\t\t\ttimerThread.start();\n\t\t\tmaximumRequestWarnTime = ERXProperties.longForKeyWithDefault(\"er.extensions.ERXStatisticsStore.milliSeconds.warn\", 2000L);\n\t\t\tmaximumRequestErrorTime = ERXProperties.longForKeyWithDefault(\"er.extensions.ERXStatisticsStore.milliSeconds.error\", 10000L);\n\t\t\tmaximumRequestFatalTime = ERXProperties.longForKeyWithDefault(\"er.extensions.ERXStatisticsStore.milliSeconds.fatal\", 5 * 60 * 1000L);\n\t\t}","id":90388,"modified_method":"public StopWatchTimer() {\n\t\t\tThread timerThread = new Thread(this);\n\t\t\ttimerThread.setDaemon(true);\n\t\t\ttimerThread.start();\n\t\t\t_maximumRequestWarnTime = ERXProperties.longForKeyWithDefault(\"er.extensions.ERXStatisticsStore.milliSeconds.warn\", 2000L);\n\t\t\t_maximumRequestErrorTime = ERXProperties.longForKeyWithDefault(\"er.extensions.ERXStatisticsStore.milliSeconds.error\", 10000L);\n\t\t\t_maximumRequestFatalTime = ERXProperties.longForKeyWithDefault(\"er.extensions.ERXStatisticsStore.milliSeconds.fatal\", 5 * 60 * 1000L);\n\t\t}","commit_id":"e5e34bc4f4d5226ed8d57d31acee0dee888665ec","url":"https://github.com/wocommunity/wonder"},{"original_method":"private void checkThreads() {\n\t\t\tMap<Thread, Long> requestThreads = new HashMap<Thread, Long>();\n\t\t\tsynchronized (_requestThreads) {\n\t            requestThreads.putAll(_requestThreads);\n\t\t\t}\n\t\t\tif (!requestThreads.isEmpty()) {\n\t\t\t\tfor (Iterator iterator = requestThreads.keySet().iterator(); iterator.hasNext();) {\n\t\t\t\t\tThread thread = (Thread) iterator.next();\n\t\t\t\t\tLong time = requestThreads.get(thread);\n\t\t\t\t\tif (time != null) {\n\t\t\t\t\t\ttime = System.currentTimeMillis() - time;\n\t\t\t\t\t\tif (time > maximumRequestWarnTime/2 && _warnTraces.get(thread) == null) {\n\t\t\t\t\t\t\tMap traces = Thread.getAllStackTraces();\n\t\t\t\t\t\t\tMap names = getCurrentThreadNames(traces.keySet());\n\t\t\t\t\t\t\t_warnTraces.put(thread, traces);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (time > maximumRequestErrorTime/2 && _errorTraces.get(thread) == null) {\n\t\t\t\t\t\t\tMap traces = Thread.getAllStackTraces();\n\t\t\t\t\t\t\tMap names = getCurrentThreadNames(traces.keySet());\n\t\t\t\t\t\t\t_errorTraces.put(thread, traces);\n\t\t\t\t\t\t\t_errorTracesNames.put(thread, names);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (time > maximumRequestFatalTime && _fatalTraces.get(thread) == null) {\n\t\t\t\t\t\t\tMap traces = Thread.getAllStackTraces();\n\t\t\t\t\t\t\tMap names = getCurrentThreadNames(traces.keySet());\n\t\t\t\t\t\t\t_fatalTraces.put(thread, traces);\n\t\t\t\t\t\t\t_fatalTracesNames.put(thread, names);\n\t\t\t\t\t\t\tString message = \"Request is taking too long, possible deadlock: \" + time + \" ms \";\n\t\t\t\t\t\t\tmessage += stringFromTraces(traces, names);\n\t\t\t\t\t\t\tmessage += \"EC info:\\n\" + ERXEC.outstandingLockDescription();\n\t\t\t\t\t\t\tmessage += \"OSC info:\\n\" + ERXObjectStoreCoordinator.outstandingLockDescription();\n\t\t\t\t\t\t\tlog.fatal(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","id":90389,"modified_method":"private void checkThreads() {\n\t\t\tMap<Thread, Long> requestThreads = new HashMap<Thread, Long>();\n\t\t\tsynchronized (_requestThreads) {\n\t            requestThreads.putAll(_requestThreads);\n\t\t\t}\n\t\t\tif (!requestThreads.isEmpty()) {\n\t\t\t\tMap traces = null; \n\t\t\t\tfor (Iterator iterator = requestThreads.keySet().iterator(); iterator.hasNext();) {\n\t\t\t\t\tThread thread = (Thread) iterator.next();\n\t\t\t\t\tLong time = requestThreads.get(thread);\n\t\t\t\t\tif (time != null) {\n\t\t\t\t\t\ttime = System.currentTimeMillis() - time;\n\t\t\t\t\t\tif (time > _maximumRequestWarnTime/2 && _warnTraces.get(thread) == null) {\n\t\t\t\t\t\t\tif(traces == null) {\n\t\t\t\t\t\t\t\ttraces = Thread.getAllStackTraces();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tMap names = getCurrentThreadNames(traces.keySet());\n\t\t\t\t\t\t\t_warnTraces.put(thread, traces);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (time > _maximumRequestErrorTime/2 && _errorTraces.get(thread) == null) {\n\t\t\t\t\t\t\tif(traces == null) {\n\t\t\t\t\t\t\t\ttraces = Thread.getAllStackTraces();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tMap names = getCurrentThreadNames(traces.keySet());\n\t\t\t\t\t\t\t_errorTraces.put(thread, traces);\n\t\t\t\t\t\t\t_errorTracesNames.put(thread, names);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (time > _maximumRequestFatalTime && _fatalTraces.get(thread) == null) {\n\t\t\t\t\t\t\tif(traces == null) {\n\t\t\t\t\t\t\t\ttraces = Thread.getAllStackTraces();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tMap names = getCurrentThreadNames(traces.keySet());\n\t\t\t\t\t\t\t_fatalTraces.put(thread, traces);\n\t\t\t\t\t\t\t_fatalTracesNames.put(thread, names);\n\t\t\t\t\t\t\tString message = \"Request is taking too long, possible deadlock: \" + time + \" ms \";\n\t\t\t\t\t\t\tmessage += stringFromTraces(traces, names);\n\t\t\t\t\t\t\tmessage += \"EC info:\\n\" + ERXEC.outstandingLockDescription();\n\t\t\t\t\t\t\tmessage += \"OSC info:\\n\" + ERXObjectStoreCoordinator.outstandingLockDescription();\n\t\t\t\t\t\t\tlog.fatal(message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"e5e34bc4f4d5226ed8d57d31acee0dee888665ec","url":"https://github.com/wocommunity/wonder"},{"original_method":"public List<DebtCharacteristic> characteristics() {\n    return toCharacteristics(dao.selectEnabledCharacteristics());\n  }","id":90390,"modified_method":"public List<DebtCharacteristic> allCharacteristics() {\n    return toCharacteristics(dao.selectEnabledCharacteristics());\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void find_characteristics() {\n    when(dao.selectEnabledCharacteristics()).thenReturn(newArrayList(characteristicDto));\n    assertThat(service.characteristics()).hasSize(1);\n  }","id":90391,"modified_method":"@Test\n  public void find_all_characteristics() {\n    when(dao.selectEnabledCharacteristics()).thenReturn(newArrayList(characteristicDto));\n    assertThat(service.allCharacteristics()).hasSize(1);\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private DebtCharacteristic move(int characteristicId, boolean moveUpOrDown) {\n    checkPermission();\n\n    SqlSession session = mybatis.openSession();\n    try {\n      CharacteristicDto dto = findCharacteristic(characteristicId, session);\n      int currentOrder = dto.getOrder();\n      CharacteristicDto dtoToSwitchOrderWith = moveUpOrDown ? dao.selectPrevious(currentOrder, session) : dao.selectNext(currentOrder, session);\n\n      // Do nothing when characteristic is already to the new location\n      if (dtoToSwitchOrderWith == null) {\n        return toCharacteristic(dto);\n      }\n      int nextOrder = dtoToSwitchOrderWith.getOrder();\n      dtoToSwitchOrderWith.setOrder(currentOrder);\n      dtoToSwitchOrderWith.setUpdatedAt(new Date(system2.now()));\n      dao.update(dtoToSwitchOrderWith, session);\n\n      dto.setOrder(nextOrder);\n      dto.setUpdatedAt(new Date(system2.now()));\n      dao.update(dto, session);\n\n      session.commit();\n      return toCharacteristic(dto);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","id":90392,"modified_method":"private DebtCharacteristic move(int characteristicId, boolean moveUpOrDown) {\n    checkPermission();\n\n    SqlSession session = mybatis.openSession();\n    try {\n      final CharacteristicDto dto = findCharacteristic(characteristicId, session);\n      int currentOrder = dto.getOrder();\n\n      // characteristics should be order by 'order'\n      List<CharacteristicDto> rootCharacteristics = dao.selectEnabledRootCharacteristics(session);\n      int currentPosition = Iterables.indexOf(rootCharacteristics, new Predicate<CharacteristicDto>() {\n        @Override\n        public boolean apply(CharacteristicDto input) {\n          return input.getKey().equals(dto.getKey());\n        }\n      });\n      Integer nextMove = moveUpOrDown ? (currentPosition > 0 ? currentPosition - 1 : null) : (currentPosition < rootCharacteristics.size()-1 ? currentPosition + 1 : null);\n\n      // Do nothing when characteristic is already to the good location\n      if (nextMove == null) {\n        return toCharacteristic(dto);\n      }\n\n      CharacteristicDto dtoToSwitchOrderWith = Iterables.get(rootCharacteristics, nextMove);\n      int nextOrder = dtoToSwitchOrderWith.getOrder();\n      dtoToSwitchOrderWith.setOrder(currentOrder);\n      dtoToSwitchOrderWith.setUpdatedAt(new Date(system2.now()));\n      dao.update(dtoToSwitchOrderWith, session);\n\n      dto.setOrder(nextOrder);\n      dto.setUpdatedAt(new Date(system2.now()));\n      dao.update(dto, session);\n\n      session.commit();\n      return toCharacteristic(dto);\n    } finally {\n      MyBatis.closeQuietly(session);\n    }\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void do_nothing_when_move_up_and_already_on_top() {\n    CharacteristicDto dto = new CharacteristicDto().setId(10).setOrder(1);\n    when(dao.selectById(10, session)).thenReturn(dto);\n    when(dao.selectPrevious(1, session)).thenReturn(null);\n\n    service.moveUp(10);\n\n    verify(dao, never()).update(any(CharacteristicDto.class), eq(session));\n  }","id":90393,"modified_method":"@Test\n  public void do_nothing_when_move_up_and_already_on_top() {\n    when(dao.selectById(10, session)).thenReturn(new CharacteristicDto().setId(10).setKey(\"MEMORY_EFFICIENCY\").setOrder(1));\n    when(dao.selectEnabledRootCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(10).setKey(\"MEMORY_EFFICIENCY\").setOrder(1),\n      new CharacteristicDto().setId(2).setKey(\"PORTABILITY\").setOrder(2)\n    ));\n\n    service.moveUp(10);\n\n    verify(dao, never()).update(any(CharacteristicDto.class), eq(session));\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void do_nothing_when_move_down_and_already_on_bottom() {\n    CharacteristicDto dto = new CharacteristicDto().setId(10).setOrder(5);\n    when(dao.selectById(10, session)).thenReturn(dto);\n    when(dao.selectNext(5, session)).thenReturn(null);\n\n    service.moveDown(10);\n\n    verify(dao, never()).update(any(CharacteristicDto.class), eq(session));\n  }","id":90394,"modified_method":"@Test\n  public void do_nothing_when_move_down_and_already_on_bottom() {\n    when(dao.selectById(10, session)).thenReturn(new CharacteristicDto().setId(10).setKey(\"MEMORY_EFFICIENCY\").setOrder(2));\n    when(dao.selectEnabledRootCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(2).setKey(\"PORTABILITY\").setOrder(1),\n      new CharacteristicDto().setId(10).setKey(\"MEMORY_EFFICIENCY\").setOrder(2)\n    ));\n\n    service.moveDown(10);\n\n    verify(dao, never()).update(any(CharacteristicDto.class), eq(session));\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void move_down() {\n    when(dao.selectById(10, session)).thenReturn(new CharacteristicDto().setId(10).setOrder(2));\n    when(dao.selectNext(2, session)).thenReturn(new CharacteristicDto().setId(2).setOrder(3));\n\n    DebtCharacteristic result = service.moveDown(10);\n\n    ArgumentCaptor<CharacteristicDto> argument = ArgumentCaptor.forClass(CharacteristicDto.class);\n    verify(dao, times(2)).update(argument.capture(), eq(session));\n\n    assertThat(result.order()).isEqualTo(3);\n    assertThat(argument.getAllValues().get(0).getOrder()).isEqualTo(2);\n    assertThat(argument.getAllValues().get(0).getUpdatedAt()).isEqualTo(now);\n    assertThat(argument.getAllValues().get(1).getOrder()).isEqualTo(3);\n    assertThat(argument.getAllValues().get(1).getUpdatedAt()).isEqualTo(now);\n  }","id":90395,"modified_method":"@Test\n  public void move_down() {\n    when(dao.selectById(10, session)).thenReturn(new CharacteristicDto().setId(10).setKey(\"MEMORY_EFFICIENCY\").setOrder(2));\n    when(dao.selectEnabledRootCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(10).setKey(\"MEMORY_EFFICIENCY\").setOrder(2),\n      new CharacteristicDto().setId(2).setKey(\"PORTABILITY\").setOrder(3)\n    ));\n\n    DebtCharacteristic result = service.moveDown(10);\n\n    ArgumentCaptor<CharacteristicDto> argument = ArgumentCaptor.forClass(CharacteristicDto.class);\n    verify(dao, times(2)).update(argument.capture(), eq(session));\n\n    assertThat(result.order()).isEqualTo(3);\n    assertThat(argument.getAllValues().get(0).getOrder()).isEqualTo(2);\n    assertThat(argument.getAllValues().get(0).getUpdatedAt()).isEqualTo(now);\n    assertThat(argument.getAllValues().get(1).getOrder()).isEqualTo(3);\n    assertThat(argument.getAllValues().get(1).getUpdatedAt()).isEqualTo(now);\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void move_up() {\n    when(dao.selectById(10, session)).thenReturn(new CharacteristicDto().setId(10).setOrder(2));\n    when(dao.selectPrevious(2, session)).thenReturn(new CharacteristicDto().setId(2).setOrder(1));\n\n    DebtCharacteristic result = service.moveUp(10);\n\n    ArgumentCaptor<CharacteristicDto> argument = ArgumentCaptor.forClass(CharacteristicDto.class);\n    verify(dao, times(2)).update(argument.capture(), eq(session));\n\n    assertThat(result.order()).isEqualTo(1);\n    assertThat(argument.getAllValues().get(0).getOrder()).isEqualTo(2);\n    assertThat(argument.getAllValues().get(0).getUpdatedAt()).isEqualTo(now);\n    assertThat(argument.getAllValues().get(1).getOrder()).isEqualTo(1);\n    assertThat(argument.getAllValues().get(1).getUpdatedAt()).isEqualTo(now);\n  }","id":90396,"modified_method":"@Test\n  public void move_up() {\n    when(dao.selectById(10, session)).thenReturn(new CharacteristicDto().setId(10).setKey(\"MEMORY_EFFICIENCY\").setOrder(2));\n    when(dao.selectEnabledRootCharacteristics(session)).thenReturn(newArrayList(\n      new CharacteristicDto().setId(2).setKey(\"PORTABILITY\").setOrder(1),\n      new CharacteristicDto().setId(10).setKey(\"MEMORY_EFFICIENCY\").setOrder(2)\n    ));\n\n    DebtCharacteristic result = service.moveUp(10);\n\n    ArgumentCaptor<CharacteristicDto> argument = ArgumentCaptor.forClass(CharacteristicDto.class);\n    verify(dao, times(2)).update(argument.capture(), eq(session));\n\n    assertThat(result.order()).isEqualTo(1);\n    assertThat(argument.getAllValues().get(0).getOrder()).isEqualTo(2);\n    assertThat(argument.getAllValues().get(0).getUpdatedAt()).isEqualTo(now);\n    assertThat(argument.getAllValues().get(1).getOrder()).isEqualTo(1);\n    assertThat(argument.getAllValues().get(1).getUpdatedAt()).isEqualTo(now);\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<DebtCharacteristic> rootCharacteristics() {\n    return debtModelLookup.rootCharacteristics();\n  }","id":90397,"modified_method":"public List<DebtCharacteristic> allCharacteristics() {\n    return debtModelLookup.allCharacteristics();\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<DebtCharacteristic> characteristics() {\n    return debtModelLookup.characteristics();\n  }","id":90398,"modified_method":"public List<DebtCharacteristic> characteristics() {\n    return debtModelLookup.rootCharacteristics();\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void find_characteristics() {\n    service.characteristics();\n    verify(debtModelLookup).characteristics();\n  }","id":90399,"modified_method":"@Test\n  public void find_all_characteristics() {\n    service.allCharacteristics();\n    verify(debtModelLookup).allCharacteristics();\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void find_root_characteristics() {\n    service.rootCharacteristics();\n    verify(debtModelLookup).rootCharacteristics();\n  }","id":90400,"modified_method":"@Test\n  public void find_root_characteristics() {\n    service.characteristics();\n    verify(debtModelLookup).rootCharacteristics();\n  }","commit_id":"dd1478fd1c40ceca4382eda011c3f093ba75dfe5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public StructureViewComponent(final FileEditor editor,\n                                final StructureViewModel structureViewModel,\n                                final Project project,\n                                final boolean showRootNode) {\n    super(new BorderLayout());\n\n    myProject = project;\n    myFileEditor = editor;\n    myTreeModel = structureViewModel;\n    myShowRootNode = showRootNode;\n    myTreeModelWrapper = new TreeModelWrapper(myTreeModel, this);\n\n    SmartTreeStructure treeStructure = new SmartTreeStructure(project, myTreeModelWrapper){\n      public void rebuildTree() {\n        storeState();\n        super.rebuildTree();\n        restoreState();\n      }\n\n      protected TreeElementWrapper createTree() {\n        return new StructureViewTreeElementWrapper(myProject, myModel.getRoot(), myModel);\n      }\n    };\n\n    final DefaultTreeModel model = new DefaultTreeModel(new DefaultMutableTreeNode(treeStructure.getRootElement()));\n    JTree tree = new Tree(model);\n    tree.setRootVisible(myShowRootNode);\n\n    myAbstractTreeBuilder = new StructureTreeBuilder(project, tree,\n                                                     (DefaultTreeModel)tree.getModel(),treeStructure,myTreeModelWrapper);\n    myAbstractTreeBuilder.updateFromRoot();\n    Disposer.register(this, myAbstractTreeBuilder);\n    Disposer.register(myAbstractTreeBuilder, new Disposable() {\n      public void dispose() {\n        storeState();\n      }\n    });\n\n    add(new JScrollPane(myAbstractTreeBuilder.getTree()), BorderLayout.CENTER);\n\n    myAbstractTreeBuilder.getTree().setCellRenderer(new NodeRenderer());\n\n    myAutoScrollToSourceHandler = new MyAutoScrollToSourceHandler();\n    myAutoScrollFromSourceHandler = new MyAutoScrollFromSourceHandler(myProject);\n\n    JComponent toolbarComponent =\n    ActionManager.getInstance().createActionToolbar(ActionPlaces.STRUCTURE_VIEW_TOOLBAR,\n                                                    createActionGroup(),\n                                                    true)\n      .getComponent();\n    add(toolbarComponent, BorderLayout.NORTH);\n\n    installTree();\n\n    myCopyPasteDelegator = new CopyPasteManagerEx.CopyPasteDelegator(myProject, getTree()) {\n      protected PsiElement[] getSelectedElements() {\n        return StructureViewComponent.this.getSelectedPsiElements();\n      }\n    };\n  }","id":90401,"modified_method":"public StructureViewComponent(final FileEditor editor,\n                                final StructureViewModel structureViewModel,\n                                final Project project,\n                                final boolean showRootNode) {\n    super(new BorderLayout());\n\n    myProject = project;\n    myFileEditor = editor;\n    myTreeModel = structureViewModel;\n    myShowRootNode = showRootNode;\n    myTreeModelWrapper = new TreeModelWrapper(myTreeModel, this);\n\n    SmartTreeStructure treeStructure = new SmartTreeStructure(project, myTreeModelWrapper){\n      public void rebuildTree() {\n        if (isDisposed()) return;\n        storeState();\n        super.rebuildTree();\n        restoreState();\n      }\n\n      protected TreeElementWrapper createTree() {\n        return new StructureViewTreeElementWrapper(myProject, myModel.getRoot(), myModel);\n      }\n    };\n\n    final DefaultTreeModel model = new DefaultTreeModel(new DefaultMutableTreeNode(treeStructure.getRootElement()));\n    JTree tree = new Tree(model);\n    tree.setRootVisible(myShowRootNode);\n\n    myAbstractTreeBuilder = new StructureTreeBuilder(project, tree,\n                                                     (DefaultTreeModel)tree.getModel(),treeStructure,myTreeModelWrapper);\n    myAbstractTreeBuilder.updateFromRoot();\n    Disposer.register(this, myAbstractTreeBuilder);\n    Disposer.register(myAbstractTreeBuilder, new Disposable() {\n      public void dispose() {\n        storeState();\n      }\n    });\n\n    add(new JScrollPane(myAbstractTreeBuilder.getTree()), BorderLayout.CENTER);\n\n    myAbstractTreeBuilder.getTree().setCellRenderer(new NodeRenderer());\n\n    myAutoScrollToSourceHandler = new MyAutoScrollToSourceHandler();\n    myAutoScrollFromSourceHandler = new MyAutoScrollFromSourceHandler(myProject);\n\n    JComponent toolbarComponent =\n    ActionManager.getInstance().createActionToolbar(ActionPlaces.STRUCTURE_VIEW_TOOLBAR,\n                                                    createActionGroup(),\n                                                    true)\n      .getComponent();\n    add(toolbarComponent, BorderLayout.NORTH);\n\n    installTree();\n\n    myCopyPasteDelegator = new CopyPasteManagerEx.CopyPasteDelegator(myProject, getTree()) {\n      protected PsiElement[] getSelectedElements() {\n        return StructureViewComponent.this.getSelectedPsiElements();\n      }\n    };\n  }","commit_id":"a9475ee4622ef0ddc32a7227eef7b8b7a7cb8a32","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object[] getSelectedElements() {\n    return convertPathsToValues(getTree().getSelectionPaths());\n  }","id":90402,"modified_method":"private Object[] getSelectedElements() {\n    final JTree tree = getTree();\n    return tree != null ? convertPathsToValues(tree.getSelectionPaths()): ArrayUtil.EMPTY_OBJECT_ARRAY;\n  }","commit_id":"a9475ee4622ef0ddc32a7227eef7b8b7a7cb8a32","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object[] getExpandedElements() {\n    final JTree tree = getTree();\n    if (tree == null) return new Object[0];\n    final List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(tree);\n    return convertPathsToValues(expandedPaths.toArray(new TreePath[expandedPaths.size()]));\n  }","id":90403,"modified_method":"private Object[] getExpandedElements() {\n    final JTree tree = getTree();\n    if (tree == null) return ArrayUtil.EMPTY_OBJECT_ARRAY;\n    final List<TreePath> expandedPaths = TreeUtil.collectExpandedPaths(tree);\n    return convertPathsToValues(expandedPaths.toArray(new TreePath[expandedPaths.size()]));\n  }","commit_id":"a9475ee4622ef0ddc32a7227eef7b8b7a7cb8a32","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean isGranted(@Nonnull Tree tree, long permissions) {\n        if (isVersionContent(tree)) {\n            return compiledPermissions.isGranted(getVersionablePath(tree, null), permissions);\n        } else {\n            return compiledPermissions.isGranted(tree, permissions);\n        }\n    }","id":90404,"modified_method":"@Override\n    public boolean isGranted(@Nonnull Tree tree, long permissions) {\n        if (isVersionContent(tree)) {\n            String path = getVersionablePath(tree, null);\n            return path != null && compiledPermissions.isGranted(path, permissions);\n        } else {\n            return compiledPermissions.isGranted(tree, permissions);\n        }\n    }","commit_id":"f390bc62f40fad6a5621f36e48322b1d37eba04e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@CheckForNull\n    private String getVersionablePath(@Nonnull Tree versionStoreTree, @Nullable PropertyState property) {\n        String relPath = \"\";\n        String propName = (property == null) ? \"\" : property.getName();\n        String versionablePath = null;\n        Tree t = versionStoreTree;\n        while (t != null && !JcrConstants.JCR_VERSIONSTORAGE.equals(t.getName())) {\n            String name = t.getName();\n            String ntName = TreeUtil.getPrimaryTypeName(t);\n            if (VersionConstants.JCR_FROZENNODE.equals(name) && t != versionStoreTree) {\n                relPath = PathUtils.relativize(t.getPath(), versionStoreTree.getPath());\n            } else if (JcrConstants.NT_VERSIONHISTORY.equals(ntName)) {\n                PropertyState prop = t.getProperty(workspaceName);\n                if (prop != null) {\n                    versionablePath = PathUtils.concat(prop.getValue(Type.PATH), relPath, propName);\n                }\n                break;\n            }\n            t = t.getParent();\n        }\n\n        if (versionablePath == null || versionablePath.length() == 0) {\n            log.warn(\"Unable to determine path of the version controlled node.\");\n        }\n        return Strings.emptyToNull(versionablePath);\n    }","id":90405,"modified_method":"@CheckForNull\n    private String getVersionablePath(@Nonnull Tree versionStoreTree, @Nullable PropertyState property) {\n        String relPath = \"\";\n        String propName = (property == null) ? \"\" : property.getName();\n        String versionablePath = null;\n        Tree t = versionStoreTree;\n        while (t != null && !JcrConstants.JCR_VERSIONSTORAGE.equals(t.getName())) {\n            String name = t.getName();\n            String ntName = checkNotNull(TreeUtil.getPrimaryTypeName(t));\n            if (VersionConstants.JCR_FROZENNODE.equals(name) && t != versionStoreTree) {\n                relPath = PathUtils.relativize(t.getPath(), versionStoreTree.getPath());\n            } else if (JcrConstants.NT_VERSIONHISTORY.equals(ntName)) {\n                PropertyState prop = t.getProperty(workspaceName);\n                if (prop != null) {\n                    versionablePath = PathUtils.concat(prop.getValue(Type.PATH), relPath, propName);\n                }\n                break;\n            }\n            t = t.getParent();\n        }\n\n        if (versionablePath == null || versionablePath.length() == 0) {\n            log.warn(\"Unable to determine path of the version controlled node.\");\n        }\n        return Strings.emptyToNull(versionablePath);\n    }","commit_id":"f390bc62f40fad6a5621f36e48322b1d37eba04e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean hasPermission(@Nonnull String oakPath, @Nonnull String jcrActions) {\n        TreeLocation location = root.getLocation(oakPath);\n        long permissions = Permissions.getPermissions(jcrActions, location);\n        if (!location.exists()) {\n            // TODO: deal with version content\n            return compiledPermissions.isGranted(oakPath, permissions);\n        } else if (location.getProperty() != null) {\n            return isGranted(location.getTree(), location.getProperty(), permissions);\n        } else {\n            return isGranted(location.getTree(), permissions);\n        }\n    }","id":90406,"modified_method":"@Override\n    public boolean hasPermission(@Nonnull String oakPath, @Nonnull String jcrActions) {\n        TreeLocation location = root.getLocation(oakPath);\n        long permissions = Permissions.getPermissions(jcrActions, location);\n        if (!location.exists()) {\n            // TODO: deal with version content\n            return compiledPermissions.isGranted(oakPath, permissions);\n        }\n\n        PropertyState property = location.getProperty();\n        if (property != null) {\n            Tree parent = location.getParent().getTree();\n            return parent != null && isGranted(parent, property, permissions);\n        } else {\n            Tree tree = location.getTree();\n            return tree != null && isGranted(tree, permissions);\n        }\n    }","commit_id":"f390bc62f40fad6a5621f36e48322b1d37eba04e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public boolean isGranted(@Nonnull Tree parent, @Nonnull PropertyState property, long permissions) {\n        if (isVersionContent(parent)) {\n            return compiledPermissions.isGranted(getVersionablePath(parent, property), permissions);\n        } else {\n            return compiledPermissions.isGranted(parent, property, permissions);\n        }\n    }","id":90407,"modified_method":"@Override\n    public boolean isGranted(@Nonnull Tree parent, @Nonnull PropertyState property, long permissions) {\n        if (isVersionContent(parent)) {\n            String path = getVersionablePath(parent, property);\n            return path != null && compiledPermissions.isGranted(path, permissions);\n        } else {\n            return compiledPermissions.isGranted(parent, property, permissions);\n        }\n    }","commit_id":"f390bc62f40fad6a5621f36e48322b1d37eba04e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n        Tree child = parentAfter.getChild(name);\n        return checkPermissions(child, false, Permissions.ADD_NODE);\n    }","id":90408,"modified_method":"@Override\n    public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n        Tree child = checkNotNull(parentAfter.getChild(name));\n        return checkPermissions(child, false, Permissions.ADD_NODE);\n    }","commit_id":"f390bc62f40fad6a5621f36e48322b1d37eba04e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\n        Tree child = parentBefore.getChild(name);\n        return checkPermissions(child, true, Permissions.REMOVE_NODE);\n    }","id":90409,"modified_method":"@Override\n    public Validator childNodeDeleted(String name, NodeState before) throws CommitFailedException {\n        Tree child = checkNotNull(parentBefore.getChild(name));\n        return checkPermissions(child, true, Permissions.REMOVE_NODE);\n    }","commit_id":"f390bc62f40fad6a5621f36e48322b1d37eba04e","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * The path of the tree identified by the specified {@code identifier} or {@code null}.\n     *\n     * @param identifier The identifier of the Tree such as exposed by {@link javax.jcr.Node#getIdentifier()}\n     * @return The tree with the given {@code identifier} or {@code null} if no\n     * such tree exists or isn't accessible to the content session.\n     */\n    @CheckForNull\n    public String getPath(String identifier) {\n        if (isValidUUID(identifier)) {\n            return resolveUUID(identifier);\n        } else {\n            // TODO as stated in NodeDelegate#getIdentifier() a non-uuid ID should\n            // TODO consisting of closest referenceable parent and a relative path\n            // TODO irrespective of the accessibility of the parent node(s)\n            return root.getTree(identifier).getPath();\n        }\n    }","id":90410,"modified_method":"/**\n     * The path of the tree identified by the specified {@code identifier} or {@code null}.\n     *\n     * @param identifier The identifier of the Tree such as exposed by {@link javax.jcr.Node#getIdentifier()}\n     * @return The tree with the given {@code identifier} or {@code null} if no\n     * such tree exists or isn't accessible to the content session.\n     */\n    @CheckForNull\n    public String getPath(String identifier) {\n        if (isValidUUID(identifier)) {\n            return resolveUUID(identifier);\n        } else {\n            // TODO as stated in NodeDelegate#getIdentifier() a non-uuid ID should\n            // TODO consisting of closest referenceable parent and a relative path\n            // TODO irrespective of the accessibility of the parent node(s)\n            Tree tree = root.getTree(identifier);\n            return tree == null ? null : tree.getPath();\n        }\n    }","commit_id":"ea1c11e18dab2b13fc396059f42939a06d4a1efa","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      // check all models in model \n      List<SModel> modelsToCheck = new ArrayList<SModel>();\n      if (((List<SModel>) MapSequence.fromMap(_params).get(\"models\")) != null) {\n        modelsToCheck.addAll(((List<SModel>) MapSequence.fromMap(_params).get(\"models\")));\n      }\n      if (((SModel) MapSequence.fromMap(_params).get(\"model\")) != null && !(modelsToCheck.contains(((SModel) MapSequence.fromMap(_params).get(\"model\"))))) {\n        modelsToCheck.add(((SModel) MapSequence.fromMap(_params).get(\"model\")));\n      }\n      if (modelsToCheck.isEmpty()) {\n        return;\n      }\n\n      for (SModel model : modelsToCheck.toArray(new SModel[modelsToCheck.size()])) {\n        String name = SNodeOperations.getModelLongName(model);\n        boolean isStub = SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(model));\n        for (SModel innerModel : Sequence.fromIterable(model.getModule().getModels())) {\n          if (SNodeOperations.getModelLongName(innerModel).startsWith(name + \".\")) {\n            if (isStub == SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(innerModel))) {\n              modelsToCheck.add(innerModel);\n            }\n          }\n        }\n      }\n      if (modelsToCheck.size() > 1) {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModels(modelsToCheck, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      } else {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModel(modelsToCheck.get(0), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"CheckModel\", t);\n      }\n    }\n  }","id":90411,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      // check all models in model \n      List<SModel> modelsToCheck = new ArrayList<SModel>();\n      if (((List<SModel>) MapSequence.fromMap(_params).get(\"models\")) != null) {\n        modelsToCheck.addAll(((List<SModel>) MapSequence.fromMap(_params).get(\"models\")));\n      }\n      if (((SModel) MapSequence.fromMap(_params).get(\"model\")) != null && !(modelsToCheck.contains(((SModel) MapSequence.fromMap(_params).get(\"model\"))))) {\n        modelsToCheck.add(((SModel) MapSequence.fromMap(_params).get(\"model\")));\n      }\n      if (modelsToCheck.isEmpty()) {\n        return;\n      }\n\n      for (SModel model : modelsToCheck.toArray(new SModel[modelsToCheck.size()])) {\n        String name = SNodeOperations.getModelLongName(model);\n        boolean isStub = SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(model));\n        for (SModel innerModel : Sequence.fromIterable(model.getModule().getModels())) {\n          if (SNodeOperations.getModelLongName(innerModel).startsWith(name + \".\")) {\n            if (isStub == SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(innerModel))) {\n              modelsToCheck.add(innerModel);\n            }\n          }\n        }\n      }\n      if (modelsToCheck.size() > 1) {\n        ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelsToCheck, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      } else {\n        ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModel(modelsToCheck.get(0), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"CheckModel\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModule> modulesToCheck = new ArrayList<SModule>();\n      if (((List<SModule>) MapSequence.fromMap(_params).get(\"modules\")) != null) {\n        modulesToCheck.addAll(((List<SModule>) MapSequence.fromMap(_params).get(\"modules\")));\n      }\n      if (((SModule) MapSequence.fromMap(_params).get(\"module\")) != null && !(modulesToCheck.contains(((SModule) MapSequence.fromMap(_params).get(\"module\"))))) {\n        modulesToCheck.add(((SModule) MapSequence.fromMap(_params).get(\"module\")));\n      }\n\n      if (modulesToCheck.isEmpty()) {\n        return;\n      }\n\n      if (modulesToCheck.size() > 1) {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModules(ListSequence.fromListWithValues(new ArrayList<SModule>(), (Iterable<SModule>) modulesToCheck), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      } else {\n        ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModule(modulesToCheck.get(0), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"CheckModule\", t);\n      }\n    }\n  }","id":90412,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModule> modulesToCheck = new ArrayList<SModule>();\n      if (((List<SModule>) MapSequence.fromMap(_params).get(\"modules\")) != null) {\n        modulesToCheck.addAll(((List<SModule>) MapSequence.fromMap(_params).get(\"modules\")));\n      }\n      if (((SModule) MapSequence.fromMap(_params).get(\"module\")) != null && !(modulesToCheck.contains(((SModule) MapSequence.fromMap(_params).get(\"module\"))))) {\n        modulesToCheck.add(((SModule) MapSequence.fromMap(_params).get(\"module\")));\n      }\n\n      if (modulesToCheck.isEmpty()) {\n        return;\n      }\n\n      if (modulesToCheck.size() > 1) {\n        ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModules(ListSequence.fromListWithValues(new ArrayList<SModule>(), (Iterable<SModule>) modulesToCheck), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      } else {\n        ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModule(modulesToCheck.get(0), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"CheckModule\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModule> modules = ListSequence.fromList(new ArrayList<SModule>());\n      for (TreeNode node : ListSequence.fromList(((List<TreeNode>) MapSequence.fromMap(_params).get(\"treeNodes\")))) {\n        ListSequence.fromList(modules).addSequence(ListSequence.fromList(((NamespaceTextNode) node).getModulesUnder()));\n      }\n      ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModules(modules, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"CheckNamespace\", t);\n      }\n    }\n  }","id":90413,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModule> modules = ListSequence.fromList(new ArrayList<SModule>());\n      for (TreeNode node : ListSequence.fromList(((List<TreeNode>) MapSequence.fromMap(_params).get(\"treeNodes\")))) {\n        ListSequence.fromList(modules).addSequence(ListSequence.fromList(((NamespaceTextNode) node).getModulesUnder()));\n      }\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModules(modules, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"CheckNamespace\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkProject(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"CheckProject\", t);\n      }\n    }\n  }","id":90414,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkProject(((Project) MapSequence.fromMap(_params).get(\"project\")), ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true);\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"CheckProject\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n      ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new AdapterUsagesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindAllAdapterUsages\", t);\n      }\n    }\n  }","id":90415,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new AdapterUsagesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindAllAdapterUsages\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isGeneratorModel(md) && SNodeOperations.isGeneratable(md);\n        }\n      }));\n\n      ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder() {\n        @Override\n        protected List<SpecificChecker> getSpecificCheckers() {\n          return ListSequence.fromListAndArray(new ArrayList<SpecificChecker>(), new GeneratorTemplatesChecker());\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindCrossTemplateReferences\", t);\n      }\n    }\n  }","id":90416,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isGeneratorModel(md) && SNodeOperations.isGeneratable(md);\n        }\n      }));\n\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder() {\n        @Override\n        protected List<SpecificChecker> getSpecificCheckers() {\n          return ListSequence.fromListAndArray(new ArrayList<SpecificChecker>(), new GeneratorTemplatesChecker());\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindCrossTemplateReferences\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n\n      ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder() {\n        @Override\n        protected List<SpecificChecker> getSpecificCheckers() {\n          return ListSequence.fromListAndArray(new ArrayList<SpecificChecker>(), new ReferenceableConceptsChecker());\n        }\n      });\n\n      // extra debug \n      final Wrappers._int total = new Wrappers._int();\n      final Wrappers._int referenceable = new Wrappers._int();\n      final Map<String, Integer> used = MapSequence.fromMap(new HashMap<String, Integer>());\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modelDescriptors).visitAll(new IVisitor<SModel>() {\n            public void visit(SModel it) {\n              for (SNode n : it.getRootNodes()) {\n                for (SNode i : SNodeOperations.getDescendants(n, null, true, new String[]{})) {\n                  SNode ccp = SNodeOperations.as(((SNode) ((jetbrains.mps.smodel.SNode) i).getConceptDeclarationNode()), \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\");\n                  if (ccp != null) {\n                    total.value++;\n                    if (!(SPropertyOperations.hasValue(ccp, \"staticScope\", \"none\", null))) {\n                      referenceable.value++;\n                      String cname = BehaviorReflection.invokeVirtual(String.class, ccp, \"virtual_getFqName_1213877404258\", new Object[]{});\n                      if (MapSequence.fromMap(used).containsKey(cname)) {\n                        MapSequence.fromMap(used).put(cname, MapSequence.fromMap(used).get(cname) + 1);\n                      } else {\n                        MapSequence.fromMap(used).put(cname, 1);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n      String[] usedNames = SetSequence.fromSet(MapSequence.fromMap(used).keySet()).toGenericArray(String.class);\n      Arrays.sort(usedNames, new Comparator<String>() {\n        public int compare(String a, String b) {\n          return new Integer(MapSequence.fromMap(used).get(a)).compareTo(MapSequence.fromMap(used).get(b));\n        }\n      });\n      System.out.println(\"\" + referenceable.value + \" out of \" + total.value + \" nodes are referenceable\");\n      for (String s : usedNames) {\n        System.out.println(MapSequence.fromMap(used).get(s) + \"  \" + s);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindReferencesToNonReferenceable\", t);\n      }\n    }\n  }","id":90417,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      final List<SModel> modelDescriptors = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(modelDescriptors, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new ModelCheckerIssueFinder() {\n        @Override\n        protected List<SpecificChecker> getSpecificCheckers() {\n          return ListSequence.fromListAndArray(new ArrayList<SpecificChecker>(), new ReferenceableConceptsChecker());\n        }\n      });\n\n      // extra debug \n      final Wrappers._int total = new Wrappers._int();\n      final Wrappers._int referenceable = new Wrappers._int();\n      final Map<String, Integer> used = MapSequence.fromMap(new HashMap<String, Integer>());\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        public void run() {\n          ListSequence.fromList(modelDescriptors).visitAll(new IVisitor<SModel>() {\n            public void visit(SModel it) {\n              for (SNode n : it.getRootNodes()) {\n                for (SNode i : SNodeOperations.getDescendants(n, null, true, new String[]{})) {\n                  SNode ccp = SNodeOperations.as(((SNode) ((jetbrains.mps.smodel.SNode) i).getConceptDeclarationNode()), \"jetbrains.mps.lang.structure.structure.ConceptDeclaration\");\n                  if (ccp != null) {\n                    total.value++;\n                    if (!(SPropertyOperations.hasValue(ccp, \"staticScope\", \"none\", null))) {\n                      referenceable.value++;\n                      String cname = BehaviorReflection.invokeVirtual(String.class, ccp, \"virtual_getFqName_1213877404258\", new Object[]{});\n                      if (MapSequence.fromMap(used).containsKey(cname)) {\n                        MapSequence.fromMap(used).put(cname, MapSequence.fromMap(used).get(cname) + 1);\n                      } else {\n                        MapSequence.fromMap(used).put(cname, 1);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          });\n        }\n      });\n      String[] usedNames = SetSequence.fromSet(MapSequence.fromMap(used).keySet()).toGenericArray(String.class);\n      Arrays.sort(usedNames, new Comparator<String>() {\n        public int compare(String a, String b) {\n          return new Integer(MapSequence.fromMap(used).get(a)).compareTo(MapSequence.fromMap(used).get(b));\n        }\n      });\n      System.out.println(\"\" + referenceable.value + \" out of \" + total.value + \" nodes are referenceable\");\n      for (String s : usedNames) {\n        System.out.println(MapSequence.fromMap(used).get(s) + \"  \" + s);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindReferencesToNonReferenceable\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return FindWrongAspectDependencies_Action.this.needsProcessing(md, _params);\n        }\n      }));\n      ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new WrongAspectDependenciesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindWrongAspectDependencies\", t);\n      }\n    }\n  }","id":90418,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return FindWrongAspectDependencies_Action.this.needsProcessing(md, _params);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new WrongAspectDependenciesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindWrongAspectDependencies\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n      ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new BrokenReferencesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindlAllBrokenReferences\", t);\n      }\n    }\n  }","id":90419,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      List<SModel> models = ListSequence.fromListWithValues(new ArrayList<SModel>(), Sequence.fromIterable(((Iterable<SModel>) SModelRepository.getInstance().getModelDescriptors())).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel md) {\n          return SModelStereotype.isUserModel(md);\n        }\n      }));\n      ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).checkModels(models, ((IOperationContext) MapSequence.fromMap(_params).get(\"operationContext\")), true, new BrokenReferencesFinder());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"FindlAllBrokenReferences\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public CheckinHandler.ReturnResult beforeCheckin() {\n    if (!(ModelCheckerSettings.getInstance().isCheckBeforeCommit())) {\n      return CheckinHandler.ReturnResult.COMMIT;\n    }\n\n    return myProject.getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).checkModelsBeforeCommit(new ProjectOperationContext(ProjectHelper.toMPSProject(myProject)), getModelsByFiles(myPanel.getFiles()));\n  }","id":90420,"modified_method":"@Override\n  public CheckinHandler.ReturnResult beforeCheckin() {\n    if (!(ModelCheckerSettings.getInstance().isCheckBeforeCommit())) {\n      return CheckinHandler.ReturnResult.COMMIT;\n    }\n\n    return ModelCheckerTool.getInstance(myProject).checkModelsBeforeCommit(new ProjectOperationContext(ProjectHelper.toMPSProject(myProject)), getModelsByFiles(myPanel.getFiles()));\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean check(@NotNull Project p, @NotNull IOperationContext operationContext, List<SModel> modelDescriptors, Runnable regenerationRunnable) {\n    ProjectPluginManager component = p.getComponent(ProjectPluginManager.class);\n    if (component == null) {\n      return true;\n    }\n\n    ModelCheckerTool_Tool tool = component.getTool(ModelCheckerTool_Tool.class);\n    if (tool == null) {\n      return true;\n    }\n    return tool.checkModelsBeforeGenerationIfNeeded(operationContext, modelDescriptors, regenerationRunnable);\n  }","id":90421,"modified_method":"@Override\n  public boolean check(@NotNull Project p, @NotNull IOperationContext operationContext, List<SModel> modelDescriptors, Runnable regenerationRunnable) {\n    ModelCheckerTool tool = ModelCheckerTool.getInstance(ProjectHelper.toIdeaProject(p));\n    if (tool == null) {\n      return true;\n    }\n    return tool.checkModelsBeforeGenerationIfNeeded(operationContext, modelDescriptors, regenerationRunnable);\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Modelchecker_PluginInitializer() {\n    PluginFactoriesRegistry.registerPluginFactory(new AbstractPluginFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T> T create(Class<T> klass) {\n        if (BaseApplicationPlugin.class == klass) {\n          return (T) new Modelchecker_ApplicationPlugin();\n        }\n        if (BaseProjectPlugin.class == klass) {\n          return (T) new Modelchecker_ProjectPlugin();\n        }\n        return null;\n      }\n    });\n  }","id":90422,"modified_method":"public Modelchecker_PluginInitializer() {\n    PluginFactoriesRegistry.registerPluginFactory(new AbstractPluginFactory() {\n      @SuppressWarnings(\"unchecked\")\n      public <T> T create(Class<T> klass) {\n        if (BaseApplicationPlugin.class == klass) {\n          return (T) new Modelchecker_ApplicationPlugin();\n        }\n        return null;\n      }\n    });\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {\n    return ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class).isAvailable();\n  }","id":90423,"modified_method":"public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {\n    return ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\"))).isAvailable();\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModelCheckerTool_Tool tool = ((Project) MapSequence.fromMap(_params).get(\"project\")).getComponent(ProjectPluginManager.class).getTool(ModelCheckerTool_Tool.class);\n      if (!(tool.isAvailable()) || !(tool.toolIsOpened())) {\n        // Not visible: open \n        tool.openToolLater(true);\n      } else if (tool.getToolWindow().isActive()) {\n        // Visible and active: hide \n        tool.getToolWindow().hide(null);\n      } else {\n        // Visible and not active: activate \n        tool.getToolWindow().activate(null);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ShowModelChecker\", t);\n      }\n    }\n  }","id":90424,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      ModelCheckerTool tool = ModelCheckerTool.getInstance(((Project) MapSequence.fromMap(_params).get(\"project\")));\n      if (!(tool.isAvailable()) || !(tool.toolIsOpened())) {\n        // Not visible: open \n        tool.openToolLater(true);\n      } else if (tool.getToolWindow().isActive()) {\n        // Visible and active: hide \n        tool.getToolWindow().hide(null);\n      } else {\n        // Visible and not active: activate \n        tool.getToolWindow().activate(null);\n      }\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Priority.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ShowModelChecker\", t);\n      }\n    }\n  }","commit_id":"cf4ded6f64d28ceea707e1ed465c2a80363a258d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void doHacks() {\n        try {\n            // Use the system classloader as the victim for all this\n            // ClassLoader pinning we're about to do.\n            ClassLoaderHolder orig = ClassLoaderUtils\n                .setThreadContextClassloader(ClassLoader.getSystemClassLoader());\n            try {\n                \n                try {\n                    //Trigger a call to sun.awt.AppContext.getAppContext()\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.imageIO\")) {\n                        ImageIO.getCacheDirectory();\n                    }\n                } catch (Throwable t) {\n                    //ignore\n                }\n                try {\n                    //DocumentBuilderFactory seems to SOMETIMES pin the classloader\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.documentBuilderFactory\")) {\n                        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n                        factory.newDocumentBuilder();\n                    }\n                } catch (Throwable e) {\n                    //ignore\n                }\n                // Several components end up calling:\n                // sun.misc.GC.requestLatency(long)\n                //\n                // Those libraries / components known to trigger memory leaks due to\n                // eventual calls to requestLatency(long) are:\n                // - javax.management.remote.rmi.RMIConnectorServer.start()\n                try {\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.gcRequestLatency\")) {\n                        Class<?> clazz = Class.forName(\"sun.misc.GC\");\n                        Method method = clazz.getDeclaredMethod(\"requestLatency\",\n                                new Class[] {Long.TYPE});\n                        method.invoke(null, Long.valueOf(36000000));\n                    }                    \n                } catch (Throwable e) {\n                    //ignore\n                }\n                \n                // Calling getPolicy retains a static reference to the context \n                // class loader.\n                try {\n                    // Policy.getPolicy();\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.policy\")) {\n                        Class<?> policyClass = Class\n                            .forName(\"javax.security.auth.Policy\");\n                        Method method = policyClass.getMethod(\"getPolicy\");\n                        method.invoke(null);\n                    }\n                } catch (Throwable e) {\n                    // ignore\n                }\n                try {\n                    // Initializing javax.security.auth.login.Configuration retains a static reference \n                    // to the context class loader.\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.authConfiguration\")) {\n                        Class.forName(\"javax.security.auth.login.Configuration\", true, \n                                      ClassLoader.getSystemClassLoader());\n                    }\n                } catch (Throwable e) {\n                    // Ignore\n                }\n                // Creating a MessageDigest during web application startup\n                // initializes the Java Cryptography Architecture. Under certain\n                // conditions this starts a Token poller thread with TCCL equal\n                // to the web application class loader.\n                if (!skipHack(\"org.apache.cxf.JDKBugHacks.securityProviders\")) {\n                    java.security.Security.getProviders();\n                }\n                \n                try {\n                    // Several components end up opening JarURLConnections without first\n                    // disabling caching. This effectively locks the file.\n                    // JAXB does this and thus affects us pretty badly.\n                    // Doesn't matter that this JAR doesn't exist - just as long as\n                    // the URL is well-formed\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.defaultUsesCaches\")) {\n                        URL url = new URL(\"jar:file://dummy.jar!/\");\n                        URLConnection uConn = new URLConnection(url) {\n                            @Override\n                            public void connect() throws IOException {\n                                // NOOP\n                            }\n                        };\n                        uConn.setDefaultUseCaches(false);\n                    }\n                } catch (Throwable e) {\n                    //ignore\n                }                \n            } finally {\n                if (orig != null) {\n                    orig.reset();\n                }\n            }\n        } catch (Throwable t) {\n            //ignore\n        }\n    }","id":90425,"modified_method":"public static void doHacks() {\n        if (skipHack(\"org.apache.cxf.JDKBugHacks.all\")) {\n            return;\n        }                \n        try {\n            // Use the system classloader as the victim for all this\n            // ClassLoader pinning we're about to do.\n            ClassLoaderHolder orig = ClassLoaderUtils\n                .setThreadContextClassloader(ClassLoader.getSystemClassLoader());\n            try {\n                try {\n                    //Trigger a call to sun.awt.AppContext.getAppContext()\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.imageIO\")) {\n                        ImageIO.getCacheDirectory();\n                    }\n                } catch (Throwable t) {\n                    //ignore\n                }\n                try {\n                    //DocumentBuilderFactory seems to SOMETIMES pin the classloader\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.documentBuilderFactory\")) {\n                        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n                        factory.newDocumentBuilder();\n                    }\n                } catch (Throwable e) {\n                    //ignore\n                }\n                // Several components end up calling:\n                // sun.misc.GC.requestLatency(long)\n                //\n                // Those libraries / components known to trigger memory leaks due to\n                // eventual calls to requestLatency(long) are:\n                // - javax.management.remote.rmi.RMIConnectorServer.start()\n                try {\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.gcRequestLatency\")) {\n                        Class<?> clazz = Class.forName(\"sun.misc.GC\");\n                        Method method = clazz.getDeclaredMethod(\"currentLatencyTarget\");\n                        Long l = (Long)method.invoke(null);\n                        if (l != null && l.longValue() == 0) {\n                            //something already set it, move on\n                            method = clazz.getDeclaredMethod(\"requestLatency\",\n                                new Class[] {Long.TYPE});\n                            method.invoke(null, Long.valueOf(36000000));\n                        }\n                    }                    \n                } catch (Throwable e) {\n                    //ignore\n                }\n                \n                // Calling getPolicy retains a static reference to the context \n                // class loader.\n                try {\n                    // Policy.getPolicy();\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.policy\")) {\n                        Class<?> policyClass = Class\n                            .forName(\"javax.security.auth.Policy\");\n                        Method method = policyClass.getMethod(\"getPolicy\");\n                        method.invoke(null);\n                    }\n                } catch (Throwable e) {\n                    // ignore\n                }\n                try {\n                    // Initializing javax.security.auth.login.Configuration retains a static reference \n                    // to the context class loader.\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.authConfiguration\")) {\n                        Class.forName(\"javax.security.auth.login.Configuration\", true, \n                                      ClassLoader.getSystemClassLoader());\n                    }\n                } catch (Throwable e) {\n                    // Ignore\n                }\n                // Creating a MessageDigest during web application startup\n                // initializes the Java Cryptography Architecture. Under certain\n                // conditions this starts a Token poller thread with TCCL equal\n                // to the web application class loader.\n                if (!skipHack(\"org.apache.cxf.JDKBugHacks.securityProviders\")) {\n                    java.security.Security.getProviders();\n                }\n                \n                try {\n                    // Several components end up opening JarURLConnections without first\n                    // disabling caching. This effectively locks the file.\n                    // JAXB does this and thus affects us pretty badly.\n                    // Doesn't matter that this JAR doesn't exist - just as long as\n                    // the URL is well-formed\n                    if (!skipHack(\"org.apache.cxf.JDKBugHacks.defaultUsesCaches\")) {\n                        URL url = new URL(\"jar:file://dummy.jar!/\");\n                        URLConnection uConn = new URLConnection(url) {\n                            @Override\n                            public void connect() throws IOException {\n                                // NOOP\n                            }\n                        };\n                        uConn.setDefaultUseCaches(false);\n                    }\n                } catch (Throwable e) {\n                    //ignore\n                }                \n            } finally {\n                if (orig != null) {\n                    orig.reset();\n                }\n            }\n        } catch (Throwable t) {\n            //ignore\n        }\n    }","commit_id":"dd757d092a55cc8aa8aeb9ddce9e156d6733f3d2","url":"https://github.com/apache/cxf"},{"original_method":"/**\n     * Creates a POJO objects.\n     * This method is not synchronized and does not require any locks.\n     * If a {@link InstanceManager#m_factoryMethod} is specified,\n     * this method called this static method to creates the object.\n     * Otherwise, the methods uses the regular constructor.\n     * All those methods can receive the {@link BundleContext} in\n     * argument.\n     * @return the created object or <code>null<\/code> if an error\n     * occurs during the creation.\n     */\n    protected Object createObject() {\n        if (m_clazz == null) {\n            load();\n        }\n\n        // The following code doesn't need to be synchronized as is deal only with immutable fields.\n        Object instance = null;\n        if (m_factoryMethod == null) {\n            // No factory-method, we use the constructor.\n            try {\n            \t// Try to find the correct constructor.\n            \tif (m_constructorRegistration != null) {\n            \t\t// Initialize the injected values and types\n            \t\t// We have the IM first.\n            \t\tObject[] values = new Object[m_constructorRegistration.size() + 1];\n            \t\tClass[] types = new Class[m_constructorRegistration.size() + 1];\n            \t\tvalues[0] = this;\n            \t\ttypes[0] = InstanceManager.class;\n\n            \t\t// Iterate over the constructor injector\n            \t\tfor (int i = 0; i < m_constructorRegistration.size(); i++) {\n        \t\t\t\tConstructorInjector injector = (ConstructorInjector)\n        \t\t\t\t\tm_constructorRegistration.get(new Integer(i));\n        \t\t\t\tObject v = injector.getConstructorParameter(i);\n        \t\t\t\tif (v != null) {\n        \t\t\t\t\tvalues[i + 1] = v;\n        \t\t\t\t\tClass t = injector.getConstructorParameterType(i);\n        \t\t\t\t\tif (t == null) {\n        \t\t\t\t\t\tt = v.getClass();\n        \t\t\t\t\t}\n        \t\t\t\t\ttypes[i + 1] = t;\n        \t\t\t\t}\n            \t\t}\n            \t\t// Find the constructor.\n            \t\tConstructor cst = m_clazz.getDeclaredConstructor(types);\n            \t\tif (! cst.isAccessible()) {\n                        cst.setAccessible(true);\n                    }\n            \t\tString methodId = MethodMetadata.computeMethodId(cst);\n                    onEntry(null, methodId,  values);\n            \t\tinstance = cst.newInstance(values);\n            \t\tonExit(instance, methodId, instance);\n            \t} else {\n            \t\t// Old semantic\n            \t\t// Try to find if there is a constructor with a bundle context as parameter :\n                    try {\n                        Constructor cst = m_clazz.getDeclaredConstructor(new Class[] { InstanceManager.class, BundleContext.class });\n                        if (! cst.isAccessible()) {\n                            cst.setAccessible(true);\n                        }\n                        Object[] args = new Object[] { this, m_context };\n                        onEntry(null, MethodMetadata.BC_CONSTRUCTOR_ID,  new Object[] {m_context});\n                        instance = cst.newInstance(args);\n                        onExit(instance, MethodMetadata.BC_CONSTRUCTOR_ID, instance);\n                    } catch (NoSuchMethodException e) {\n                        // Create an instance if no instance are already created with <init>()BundleContext\n                        if (instance == null) {\n                            Constructor cst = m_clazz.getDeclaredConstructor(new Class[] { InstanceManager.class });\n                            if (! cst.isAccessible()) {\n                                cst.setAccessible(true);\n                            }\n                            Object[] args = new Object[] {this};\n                            onEntry(null, MethodMetadata.EMPTY_CONSTRUCTOR_ID, new Object[0]);\n                            instance = cst.newInstance(args);\n                            onExit(instance, MethodMetadata.EMPTY_CONSTRUCTOR_ID, instance);\n                        }\n                    }\n            \t}\n\n            } catch (IllegalAccessException e) {\n                m_logger.log(Logger.ERROR,\n                                          \"[\" + m_name + \"] createInstance -> The POJO constructor is not accessible : \" + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor is not accessible : \" + e.getMessage());\n            } catch (SecurityException e) {\n                m_logger.log(\n                                          Logger.ERROR,\n                                          \"[\"\n                                                  + m_name\n                                                  + \"] createInstance -> The POJO constructor is not accessible (security reason) : \"\n                                                  + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor is not accessible : \" + e.getMessage());\n            } catch (InvocationTargetException e) {\n                m_logger.log(\n                                          Logger.ERROR,\n                                          \"[\"\n                                                  + m_name\n                                                  + \"] createInstance -> Cannot invoke the constructor method - the constructor throws an exception : \"\n                                                  + e.getTargetException().getMessage(), e.getTargetException());\n                onError(null, m_className, e.getTargetException());\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor has thrown an exception: \" + e.getTargetException().getMessage());\n            } catch (NoSuchMethodException e) {\n                m_logger.log(Logger.ERROR,\n                                          \"[\" + m_name + \"] createInstance -> Cannot invoke the constructor (method not found) : \" + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor cannot be found : \" + e.getMessage());\n            } catch (Throwable e) {\n                // Catch every other possible error and runtime exception.\n                m_logger.log(Logger.ERROR,\n                        \"[\" + m_name + \"] createInstance -> The POJO constructor invocation failed : \" + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor invocation has thrown an exception : \" + e.getMessage());\n            }\n        } else {\n            try {\n                // Build the pojo object with the factory-method.\n                Method factory = null;\n                // Try with the bundle context\n                try {\n                    factory = m_clazz.getDeclaredMethod(m_factoryMethod, new Class[] { BundleContext.class });\n                    if (! factory.isAccessible()) {\n                        factory.setAccessible(true);\n                    }\n                    Object[] args = new Object[] { m_context };\n                    onEntry(null, m_className, args);\n                    instance = factory.invoke(null, new Object[] { m_context });\n                } catch (NoSuchMethodException e1) {\n                    // Try without the bundle context\n                    try {\n                        factory = m_clazz.getDeclaredMethod(m_factoryMethod, new Class[0]);\n                        if (! factory.isAccessible()) {\n                            factory.setAccessible(true);\n                        }\n                        Object[] args = new Object[0];\n                        onEntry(null, m_className, args);\n                        instance = factory.invoke(null, args);\n                    } catch (NoSuchMethodException e2) {\n                        // Error : factory-method not found\n                        m_logger.log(\n                                                  Logger.ERROR,\n                                                  \"[\"\n                                                          + m_name\n                                                          + \"] createInstance -> Cannot invoke the factory-method (method not found) : \"\n                                                          + e2.getMessage(), e2);\n                        stop();\n                        throw new RuntimeException(\"Cannot create a POJO instance, the factory-method cannot be found : \" + e2.getMessage());\n                    }\n                }\n\n                // Now call the setInstanceManager method.\n                Method method = instance.getClass().getDeclaredMethod(\"_setInstanceManager\", new Class[] { InstanceManager.class });\n                if (!method.isAccessible()) {\n                    method.setAccessible(true);\n                }\n                method.invoke(instance, new Object[] { this });\n                onExit(null, m_className, instance);\n\n            } catch (InvocationTargetException e) {\n                // Error : invocation failed\n                m_logger.log(Logger.ERROR,\n                                          \"[\" + m_name + \"] createInstance -> The factory-method throws an exception : \" + e.getTargetException(), e.getTargetException());\n                onError(null, m_className, e.getTargetException());\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the factory-method has thrown an exception: \" + e.getTargetException().getMessage());\n            } catch (NoSuchMethodException e) {\n                // Error : _setInstanceManager method is missing\n                m_logger\n                        .log(\n                             Logger.ERROR,\n                             \"[\"\n                                     + m_name\n                                     + \"] createInstance -> Cannot invoke the factory-method (the _setInstanceManager method does not exist) : \"\n                                     + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the factory-method cannot be found : \" + e.getMessage());\n            } catch (Throwable e) {\n                // Catch every other possible error and runtime exception.\n                m_logger.log(Logger.ERROR,\n                        \"[\" + m_name + \"] createInstance -> The factory-method invocation failed : \" + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the factory-method invocation has thrown an exception : \" + e.getMessage());\n            }\n        }\n        return instance;\n    }","id":90426,"modified_method":"/**\n     * Creates a POJO objects.\n     * This method is not synchronized and does not require any locks.\n     * If a {@link InstanceManager#m_factoryMethod} is specified,\n     * this method called this static method to creates the object.\n     * Otherwise, the methods uses the regular constructor.\n     * All those methods can receive the {@link BundleContext} in\n     * argument.\n     * @return the created object or <code>null<\/code> if an error\n     * occurs during the creation.\n     */\n    protected Object createObject() {\n        if (m_clazz == null) {\n            load();\n        }\n\n        // The following code doesn't need to be synchronized as is deal only with immutable fields.\n        Object instance = null;\n        if (m_factoryMethod == null) {\n            // No factory-method, we use the constructor.\n            try {\n                // Try to find the correct constructor.\n                if (m_constructorRegistration != null) {\n                    // Initialize the injected values and types\n                    // We have the IM first.\n                    Object[] values = new Object[m_constructorRegistration.size() + 1];\n                    Class[] types = new Class[m_constructorRegistration.size() + 1];\n                    values[0] = this;\n                    types[0] = InstanceManager.class;\n\n                    // Iterate over the constructor injector\n                    for (int i = 0; i < m_constructorRegistration.size(); i++) {\n                        ConstructorInjector injector = (ConstructorInjector)\n                            m_constructorRegistration.get(new Integer(i));\n                        Object v = injector.getConstructorParameter(i);\n                        if (v != null) {\n                            values[i + 1] = v;\n                            Class t = injector.getConstructorParameterType(i);\n                            if (t == null) {\n                                t = v.getClass();\n                            }\n                            types[i + 1] = t;\n                        }\n                    }\n                    // Find the constructor.\n                    Constructor cst = m_clazz.getDeclaredConstructor(types);\n                    if (! cst.isAccessible()) {\n                        cst.setAccessible(true);\n                    }\n                    String methodId = MethodMetadata.computeMethodId(cst);\n                    onEntry(null, methodId,  values);\n                    instance = cst.newInstance(values);\n                    onExit(instance, methodId, instance);\n                } else {\n                    // Old semantic\n                    // Try to find if there is a constructor with a bundle context as parameter :\n                    try {\n                        Constructor cst = m_clazz.getDeclaredConstructor(new Class[] { InstanceManager.class, BundleContext.class });\n                        if (! cst.isAccessible()) {\n                            cst.setAccessible(true);\n                        }\n                        Object[] args = new Object[] { this, m_context };\n                        onEntry(null, MethodMetadata.BC_CONSTRUCTOR_ID,  new Object[] {m_context});\n                        instance = cst.newInstance(args);\n                        onExit(instance, MethodMetadata.BC_CONSTRUCTOR_ID, instance);\n                    } catch (NoSuchMethodException e) {\n                        // Create an instance if no instance are already created with <init>()BundleContext\n                        if (instance == null) {\n                            Constructor cst = m_clazz.getDeclaredConstructor(new Class[] { InstanceManager.class });\n                            if (! cst.isAccessible()) {\n                                cst.setAccessible(true);\n                            }\n                            Object[] args = new Object[] {this};\n                            onEntry(null, MethodMetadata.EMPTY_CONSTRUCTOR_ID, new Object[0]);\n                            instance = cst.newInstance(args);\n                            onExit(instance, MethodMetadata.EMPTY_CONSTRUCTOR_ID, instance);\n                        }\n                    }\n                }\n\n            } catch (IllegalAccessException e) {\n                m_logger.log(Logger.ERROR,\n                                          \"[\" + m_name + \"] createInstance -> The POJO constructor is not accessible : \" + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor is not accessible : \" + e.getMessage());\n            } catch (SecurityException e) {\n                m_logger.log(\n                                          Logger.ERROR,\n                                          \"[\"\n                                                  + m_name\n                                                  + \"] createInstance -> The POJO constructor is not accessible (security reason) : \"\n                                                  + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor is not accessible : \" + e.getMessage());\n            } catch (InvocationTargetException e) {\n                m_logger.log(\n                                          Logger.ERROR,\n                                          \"[\"\n                                                  + m_name\n                                                  + \"] createInstance -> Cannot invoke the constructor method - the constructor throws an exception : \"\n                                                  + e.getTargetException().getMessage(), e.getTargetException());\n                onError(null, m_className, e.getTargetException());\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor has thrown an exception: \" + e.getTargetException().getMessage());\n            } catch (NoSuchMethodException e) {\n                m_logger.log(Logger.ERROR,\n                                          \"[\" + m_name + \"] createInstance -> Cannot invoke the constructor (method not found) : \" + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor cannot be found : \" + e.getMessage());\n            } catch (Throwable e) {\n                // Catch every other possible error and runtime exception.\n                m_logger.log(Logger.ERROR,\n                        \"[\" + m_name + \"] createInstance -> The POJO constructor invocation failed : \" + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the POJO constructor invocation has thrown an exception : \" + e.getMessage());\n            }\n        } else {\n            try {\n                // Build the pojo object with the factory-method.\n                Method factory = null;\n                // Try with the bundle context\n                try {\n                    factory = m_clazz.getDeclaredMethod(m_factoryMethod, new Class[] { BundleContext.class });\n                    if (! factory.isAccessible()) {\n                        factory.setAccessible(true);\n                    }\n                    Object[] args = new Object[] { m_context };\n                    onEntry(null, m_className, args);\n                    instance = factory.invoke(null, new Object[] { m_context });\n                } catch (NoSuchMethodException e1) {\n                    // Try without the bundle context\n                    try {\n                        factory = m_clazz.getDeclaredMethod(m_factoryMethod, new Class[0]);\n                        if (! factory.isAccessible()) {\n                            factory.setAccessible(true);\n                        }\n                        Object[] args = new Object[0];\n                        onEntry(null, m_className, args);\n                        instance = factory.invoke(null, args);\n                    } catch (NoSuchMethodException e2) {\n                        // Error : factory-method not found\n                        m_logger.log(\n                                                  Logger.ERROR,\n                                                  \"[\"\n                                                          + m_name\n                                                          + \"] createInstance -> Cannot invoke the factory-method (method not found) : \"\n                                                          + e2.getMessage(), e2);\n                        stop();\n                        throw new RuntimeException(\"Cannot create a POJO instance, the factory-method cannot be found : \" + e2.getMessage());\n                    }\n                }\n\n                // Now call the setInstanceManager method.\n                // Find declaring super class.\n                Class declaringClass = instance.getClass();\n                Method method = null;\n                while (declaringClass != null && method == null) {\n                    try {\n                        method = declaringClass.getDeclaredMethod(\"_setInstanceManager\",\n                                new Class[] { InstanceManager.class });\n                    } catch (NoSuchMethodException e) {\n                        //Do nothing\n                    }\n\n                    declaringClass = declaringClass.getSuperclass();\n                }\n\n                if (method == null) {\n                    // Error : _setInstanceManager method is missing\n                    m_logger\n                            .log(\n                                 Logger.ERROR,\n                                 \"[\"\n                                         + m_name\n                                         + \"] createInstance -> Cannot invoke the factory-method (the _setInstanceManager method does not exist\");\n                    stop();\n                    throw new RuntimeException(\"Cannot create a POJO instance, the factory-method cannot be found\");\n                }\n\n                if (!method.isAccessible()) {\n                    method.setAccessible(true);\n                }\n                method.invoke(instance, new Object[] { this });\n                onExit(null, m_className, instance);\n\n            } catch (InvocationTargetException e) {\n                // Error : invocation failed\n                m_logger.log(Logger.ERROR,\n                                          \"[\" + m_name + \"] createInstance -> The factory-method throws an exception : \" + e.getTargetException(), e.getTargetException());\n                onError(null, m_className, e.getTargetException());\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the factory-method has thrown an exception: \" + e.getTargetException().getMessage());\n            } catch (Throwable e) {\n                // Catch every other possible error and runtime exception.\n                m_logger.log(Logger.ERROR,\n                        \"[\" + m_name + \"] createInstance -> The factory-method invocation failed : \" + e.getMessage(), e);\n                stop();\n                throw new RuntimeException(\"Cannot create a POJO instance, the factory-method invocation has thrown an exception : \" + e.getMessage());\n            }\n        }\n        return instance;\n    }","commit_id":"c1f12e9d2d634ca25633eeb2180858fda558d2fc","url":"https://github.com/apache/felix"},{"original_method":"@Nullable\n  public static String getRootTagName(final PsiFile file) throws IOException {\n    final NanoXmlUtil.RootTagNameBuilder builder = new NanoXmlUtil.RootTagNameBuilder();\n    NanoXmlUtil.parseFile(file, builder);\n    return builder.getResult();\n  }","id":90427,"modified_method":"@Nullable\n  public static String getRootTagName(final PsiFile file) throws IOException {\n    final VirtualFile virtualFile = file.getVirtualFile();\n    if (virtualFile instanceof LightVirtualFile && file instanceof XmlFile && FileDocumentManager.getInstance().getCachedDocument(virtualFile) == null) {\n      final XmlDocument document = ((XmlFile)file).getDocument();\n      if (document != null) {\n        final XmlTag tag = document.getRootTag();\n        if (tag != null) {\n          return tag.getLocalName();\n        }\n      }\n      return null;\n    }\n\n    final NanoXmlUtil.RootTagNameBuilder builder = new NanoXmlUtil.RootTagNameBuilder();\n    NanoXmlUtil.parseFile(file, builder);\n    return builder.getResult();\n  }","commit_id":"9ca757e62fd022fbab73360c99d4aeb0bc9d9f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static JavaMethod findGetter(Class aClass, String propertyName) {\n    final String capitalized = StringUtil.capitalize(propertyName);\n    try {\n      return JavaMethod.getMethod(aClass, aClass.getMethod(\"get\" + capitalized));\n    }\n    catch (NoSuchMethodException e) {\n      try {\n        final JavaMethod javaMethod = JavaMethod.getMethod(aClass, aClass.getMethod(\"is\" + capitalized));\n        return canHaveIsPropertyGetterPrefix(javaMethod.getGenericReturnType()) ? javaMethod : null;\n      }\n      catch (NoSuchMethodException e1) {\n        return null;\n      }\n    }\n  }","id":90428,"modified_method":"@Nullable\n  public static JavaMethod findGetter(Class aClass, String propertyName) {\n    final String capitalized = StringUtil.capitalize(propertyName);\n    Method method = ReflectionUtil.getMethod(aClass, \"get\" + capitalized);\n    if (method != null) return JavaMethod.getMethod(aClass, method);\n\n    method = ReflectionUtil.getMethod(aClass, \"is\" + capitalized);\n    if (method == null) return null;\n\n    final JavaMethod javaMethod = JavaMethod.getMethod(aClass, method);\n    return canHaveIsPropertyGetterPrefix(javaMethod.getGenericReturnType()) ? javaMethod : null;\n  }","commit_id":"9ca757e62fd022fbab73360c99d4aeb0bc9d9f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Method findMethod(Class clazz, @NonNls String methodName) {\n    final Method[] methods = clazz.getMethods();\n    for (Method method : methods) {\n      if (methodName.equals(method.getName())) {\n        return method;\n      }\n    }\n    return null;\n  }","id":90429,"modified_method":"@Nullable\n  public static Method findMethod(Class clazz, @NonNls String methodName) {\n    for (Method method : clazz.getMethods()) {\n      if (methodName.equals(method.getName())) {\n        return method;\n      }\n    }\n    return null;\n  }","commit_id":"9ca757e62fd022fbab73360c99d4aeb0bc9d9f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private String getRootTag() {\n    return ourRootTagCache.get(ROOT_TAG_NS_KEY, myXmlFile, null).getValue();\n  }","id":90430,"modified_method":"@Nullable\n  private String getRootTag() {\n    return myXmlFile.isValid() ? ourRootTagCache.get(ROOT_TAG_NS_KEY, myXmlFile, null).getValue() : null;\n  }","commit_id":"9ca757e62fd022fbab73360c99d4aeb0bc9d9f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Method getDeclaredMethod(final Class aClass) {\n    try {\n      return aClass.getMethod(myMethodName, myMethodParameters);\n    }\n    catch (NoSuchMethodException e) {\n      try {\n        return aClass.getDeclaredMethod(myMethodName, myMethodParameters);\n      }\n      catch (NoSuchMethodException e1) {\n        return null;\n      }\n    }\n  }","id":90431,"modified_method":"@Nullable\n  private Method getDeclaredMethod(final Class aClass) {\n    final Method method = ReflectionUtil.getMethod(aClass, myMethodName, myMethodParameters);\n    return method == null ? ReflectionUtil.getDeclaredMethod(aClass, myMethodName, myMethodParameters) : method;\n  }","commit_id":"9ca757e62fd022fbab73360c99d4aeb0bc9d9f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public final Object invoke(final Object instance, final Object... args) throws IllegalAccessException, InvocationTargetException {\n    final Class<? extends Object> aClass = instance.getClass();\n    final Method method = findMethod(aClass);\n    assert method != null : \"No method \" + this + \" in \" + aClass;\n    return method.invoke(instance, args);\n  }","id":90432,"modified_method":"public final Object invoke(final Object instance, final Object... args) throws IllegalAccessException, InvocationTargetException {\n    final Class<?> aClass = instance.getClass();\n    final Method method = findMethod(aClass);\n    assert method != null : \"No method \" + this + \" in \" + aClass;\n    return method.invoke(instance, args);\n  }","commit_id":"9ca757e62fd022fbab73360c99d4aeb0bc9d9f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static Method getMethod(Class aClass, @NonNls String name, Class... paramTypes) {\n    try {\n      return aClass.getMethod(name, paramTypes);\n    }\n    catch (NoSuchMethodException e) {\n      LOG.error(e);\n      return null;\n    }\n  }","id":90433,"modified_method":"@Nullable\n  public static Method getMethod(@NotNull Class aClass, @NonNls @NotNull String name, Class... parameters) {\n    return findMethod(ReflectionCache.getMethods(aClass), name, parameters);\n  }","commit_id":"9ca757e62fd022fbab73360c99d4aeb0bc9d9f84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JCClassDecl convert(final CeylonTree.ClassDeclaration cdecl) {\n        final ListBuffer<JCVariableDecl> params = \n            new ListBuffer<JCVariableDecl>();\n        final ListBuffer<JCTree> defs =\n            new ListBuffer<JCTree>();\n        final ListBuffer<JCStatement> annotations = \n            new ListBuffer<JCStatement>();\n\t\tfinal ListBuffer<JCAnnotation> langAnnotations =\n\t\t\tnew ListBuffer<JCAnnotation>();\n\n        \n        cdecl.visitChildren(new CeylonTree.Visitor () {\n            public void visit(CeylonTree.FormalParameter param) {\n                JCExpression vartype = makeIdent(param.type().name().components());\n                JCVariableDecl var = at(cdecl).VarDef(make.Modifiers(PUBLIC), \n                \t\tmakeName(param.names), vartype, null);\n                System.out.println(var);\n                params.append(var);\n            }\n            \n            public void visit(CeylonTree.Block b) {\n                b.visitChildren(this);\n            }\n            \n            public void visit(CeylonTree.MethodDeclaration meth) {\n                defs.appendList(convert(meth));\n            }\n            \n            public void visit(CeylonTree.LanguageAnnotation ann) {\n                // Handled in processAnnotations\n            }\n            \n            public void visit(CeylonTree.UserAnnotation userAnn) {\n                // Handled in processAnnotations\n            }\n            \n            public void visit(CeylonTree.MemberDeclaration mem) {\n            \tfor (JCTree def: convert(mem))\n            \t\tdefs.append(def);\n            }\n         });\n        \n        processAnnotations(cdecl.annotations, annotations, langAnnotations, \n                           cdecl.nameAsString());\n        \n        if (annotations.length() > 0) {\n            defs.append(registerAnnotations(annotations.toList()));\n        }\n        \n        JCClassDecl classDef = \n            at(cdecl).ClassDef(at(cdecl).Modifiers(PUBLIC, langAnnotations.toList()),\n                    names.fromString(cdecl.nameAsString()),\n                    List.<JCTypeParameter>nil(), makeSelect(\"ceylon\", \"Object\"),\n                    List.<JCExpression>nil(),\n                    defs.toList());\n\n        System.out.println(classDef);\n\n        return classDef;\n    }","id":90434,"modified_method":"public JCClassDecl convert(final CeylonTree.ClassDeclaration cdecl) {\n        final ListBuffer<JCVariableDecl> params = \n            new ListBuffer<JCVariableDecl>();\n        final ListBuffer<JCTree> defs =\n            new ListBuffer<JCTree>();\n        final ListBuffer<JCStatement> annotations = \n            new ListBuffer<JCStatement>();\n\t\tfinal ListBuffer<JCAnnotation> langAnnotations =\n\t\t\tnew ListBuffer<JCAnnotation>();\n\t\tfinal ListBuffer<JCStatement> stmts =\n\t\t\tnew ListBuffer<JCStatement>();\n\n        \n        cdecl.visitChildren(new CeylonTree.Visitor () {\n            public void visit(CeylonTree.FormalParameter param) {\n                JCExpression vartype = makeIdent(param.type().name().components());\n                JCVariableDecl var = at(cdecl).VarDef(make.Modifiers(0), \n                \t\tmakeName(param.names), vartype, null);\n                System.out.println(var);\n                params.append(var);\n            }\n            \n            public void visit(CeylonTree.Block b) {\n                b.visitChildren(this);\n            }\n            \n            public void visit(CeylonTree.MethodDeclaration meth) {\n                defs.appendList(convert(meth));\n            }\n            \n            public void visit(CeylonTree.LanguageAnnotation ann) {\n                // Handled in processAnnotations\n            }\n            \n            public void visit(CeylonTree.UserAnnotation userAnn) {\n                // Handled in processAnnotations\n            }\n            \n            public void visit(CeylonTree.MemberDeclaration mem) {\n            \tfor (JCStatement def: convert(mem)) {\n            \t\tif (def instanceof JCVariableDecl &&\n            \t\t\t\t((JCVariableDecl) def).init != null) {\n            \t\t\tJCVariableDecl decl = (JCVariableDecl)def;\n            \t\t\tName name = decl.name;\n            \t\t\tJCExpression init = decl.init;\n            \t\t\tdecl.init = null;\n            \t\t\tdefs.append(decl);\n            \t\t\tstmts.append(at(mem).Exec(at(mem).Assign(at(mem).Ident(name), init)));\n            \t\t} else {\n            \t\t\tdefs.append(def);\n            \t\t}\n            \t}\n            }\n            \n            // FIXME: Just a placeholder for all the control structures\n            public void visit(CeylonTree.IfStatement stmt) {\n            \tstmts.append(convert(stmt));\n            }\n            \n            public void visit(CeylonTree.Operator op) {\n            \tstmts.append(at(op).Exec(convert(op)));\n            }\n         });\n        \n        processAnnotations(cdecl.annotations, annotations, langAnnotations, \n                           cdecl.nameAsString());\n        \n        JCMethodDecl meth = at(cdecl).MethodDef(make.Modifiers(PUBLIC),\n                names.fromString(cdecl.nameAsString()),\n                at(cdecl).TypeIdent(VOID),\n                List.<JCTypeParameter>nil(),\n                params.toList(),\n                List.<JCExpression>nil(),\n                at(cdecl).Block(0, stmts.toList()), null);\n        \n        defs.append(meth);\n        \n        if (annotations.length() > 0) {\n            defs.append(registerAnnotations(annotations.toList()));\n        }\n        \n        JCClassDecl classDef = \n            at(cdecl).ClassDef(at(cdecl).Modifiers(PUBLIC, langAnnotations.toList()),\n                    names.fromString(cdecl.nameAsString()),\n                    List.<JCTypeParameter>nil(), makeSelect(\"ceylon\", \"Object\"),\n                    List.<JCExpression>nil(),\n                    defs.toList());\n\n        System.out.println(classDef);\n\n        return classDef;\n    }","commit_id":"512fe10f433ac3d3c6e5c4c931471b34e6f8033e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"public JCBlock convert(CeylonTree.Block block) {\n        return at(block).Block(0, convertStmts(block.getStmts()));\n    }","id":90435,"modified_method":"public JCBlock convert(CeylonTree.Block block) {\n        return block == null ? null :\n        \tat(block).Block(0, convertStmts(block.getStmts()));\n    }","commit_id":"512fe10f433ac3d3c6e5c4c931471b34e6f8033e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"JCExpression convert(CeylonTree.Operator op) {\n        boolean unary_operator  = false;\n        boolean binary_operator = false;\n        boolean lose_comparison = false;\n\n        int operator = op.operatorKind;\n        switch (operator) {\n        case CeylonParser.MINUS:\n            if (op.operands.length() == 1)\n                unary_operator = true;\n            else\n                binary_operator = true;\n            break;\n            \n        case CeylonParser.BITWISENOT:\n        case CeylonParser.RENDER:\n            unary_operator = true;\n            break;\n\n        case CeylonParser.PLUS:\n        case CeylonParser.TIMES:\n        case CeylonParser.POWER:\n        case CeylonParser.DIVIDED:\n        case CeylonParser.REMAINDER:\n        case CeylonParser.BITWISEAND:\n        case CeylonParser.BITWISEOR:\n        case CeylonParser.BITWISEXOR:\n        //case CeylonParser.EQEQ:\n        //case CeylonParser.IDENTICAL:\n        //case CeylonParser.NOTEQ:\n        case CeylonParser.COMPARE:\n            binary_operator = true;\n            break;\n\n        case CeylonParser.LT:\n        case CeylonParser.GT:\n        case CeylonParser.LTEQ:\n        case CeylonParser.GTEQ:\n            operator = CeylonParser.COMPARE;\n            binary_operator = true;\n            lose_comparison = true;\n            break;\n\n        default:\n            throw new RuntimeException(CeylonParser.tokenNames[op.operatorKind]);\n        }\n\n        assert unary_operator ^ binary_operator;\n        CeylonTree[] operands = op.toArray();\n\n        JCExpression result = null;\n        if (unary_operator) {\n    \t\tassert operands.length == 1;\n        \tif (operands[0] instanceof CeylonTree.NaturalLiteral && operator == CeylonParser.MINUS) {\n        \t\tCeylonTree.NaturalLiteral lit = (CeylonTree.NaturalLiteral)operands[0];\n        \t\tresult = at(op).Apply(null, makeSelect(\"ceylon\", \"Integer\", \"instance\"),\n                        List.<JCExpression>of(make.Literal(-lit.value.longValue())));\n        \t\t\n        \t} else {\n        \t\tresult = at(op).Apply(null,\n        \t\t\t\tat(op).Select(convertExpression(operands[0]),\n        \t\t\t\t\t\tnames.fromString(unaryOperators.get(operator))),\n        \t\t\t\t\t\tList.<JCExpression>nil());\n        \t}\n        }\n        if (binary_operator) {\n            assert operands.length == 2;\n            result = at(op).Apply(null,\n                                  at(op).Select(convertExpression(operands[0]),\n                                                names.fromString(binaryOperators.get(operator))),\n                                  List.of(convertExpression(operands[1])));\n\n            if (lose_comparison) {\n                result = at(op).Apply(null,\n                                      at(op).Select(result,\n                                                    names.fromString(binaryOperators.get(op.operatorKind))),\n                                      List.<JCExpression>nil());\n            }\n        }\n\n        return result;\n    }","id":90436,"modified_method":"JCExpression convert(CeylonTree.Operator op) {\n        boolean unary_operator  = false;\n        boolean binary_operator = false;\n        boolean lose_comparison = false;\n\n        CeylonTree[] operands = op.toArray();\n\n        int operator = op.operatorKind;\n        switch (operator) {\n        case CeylonParser.MINUS:\n            if (op.operands.length() == 1)\n                unary_operator = true;\n            else\n                binary_operator = true;\n            break;\n            \n        case CeylonParser.BITWISENOT:\n        case CeylonParser.RENDER:\n            unary_operator = true;\n            break;\n\n        case CeylonParser.PLUS:\n        case CeylonParser.TIMES:\n        case CeylonParser.POWER:\n        case CeylonParser.DIVIDED:\n        case CeylonParser.REMAINDER:\n        case CeylonParser.BITWISEAND:\n        case CeylonParser.BITWISEOR:\n        case CeylonParser.BITWISEXOR:\n        //case CeylonParser.EQEQ:\n        //case CeylonParser.IDENTICAL:\n        //case CeylonParser.NOTEQ:\n        case CeylonParser.COMPARE:\n            binary_operator = true;\n            break;\n\n        case CeylonParser.LT:\n        case CeylonParser.GT:\n        case CeylonParser.LTEQ:\n        case CeylonParser.GTEQ:\n            operator = CeylonParser.COMPARE;\n            binary_operator = true;\n            lose_comparison = true;\n            break;\n\n        case CeylonParser.COLONEQ:\n        \treturn at(op).Assign(convertExpression(operands[0]), convertExpression(operands[1]));\n            \n        default:\n            throw new RuntimeException(CeylonParser.tokenNames[op.operatorKind]);\n        }\n\n        assert unary_operator ^ binary_operator;\n\n        JCExpression result = null;\n        if (unary_operator) {\n    \t\tassert operands.length == 1;\n        \tif (operands[0] instanceof CeylonTree.NaturalLiteral && operator == CeylonParser.MINUS) {\n        \t\tCeylonTree.NaturalLiteral lit = (CeylonTree.NaturalLiteral)operands[0];\n        \t\tresult = at(op).Apply(null, makeSelect(\"ceylon\", \"Integer\", \"instance\"),\n                        List.<JCExpression>of(make.Literal(-lit.value.longValue())));\n        \t\t\n        \t} else {\n        \t\tresult = at(op).Apply(null,\n        \t\t\t\tat(op).Select(convertExpression(operands[0]),\n        \t\t\t\t\t\tnames.fromString(unaryOperators.get(operator))),\n        \t\t\t\t\t\tList.<JCExpression>nil());\n        \t}\n        }\n        if (binary_operator) {\n            assert operands.length == 2;\n            result = at(op).Apply(null,\n                                  at(op).Select(convertExpression(operands[0]),\n                                                names.fromString(binaryOperators.get(operator))),\n                                  List.of(convertExpression(operands[1])));\n\n            if (lose_comparison) {\n                result = at(op).Apply(null,\n                                      at(op).Select(result,\n                                                    names.fromString(binaryOperators.get(op.operatorKind))),\n                                      List.<JCExpression>nil());\n            }\n        }\n\n        return result;\n    }","commit_id":"512fe10f433ac3d3c6e5c4c931471b34e6f8033e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"List<JCStatement> convertStmts(List<CeylonTree> stmts) {\n        final ListBuffer<JCStatement> buf =\n            new ListBuffer<JCStatement>();\n        \n        CeylonTree.Visitor v = new CeylonTree.Visitor () {\n            public void visit(CeylonTree.CallExpression expr) {\n                buf.append(at(expr).Exec(convert(expr)));\n            }\n            public void visit(CeylonTree.ReturnStatement ret) {\n                buf.append(convert(ret));\n            }\n            public void visit(CeylonTree.IfStatement stat) {\n                buf.append(convert(stat));\n            }\n            public void visit(CeylonTree.MemberDeclaration decl) {\n               \tfor (JCTree def: convert(decl))\n                     buf.append((JCStatement)def);\n            }};\n            \n        for (CeylonTree stmt: stmts) \n        \tstmt.accept(v);\n            \n        return buf.toList();\n    }","id":90437,"modified_method":"List<JCStatement> convertStmts(List<CeylonTree> stmts) {\n        final ListBuffer<JCStatement> buf =\n            new ListBuffer<JCStatement>();\n        \n        CeylonTree.Visitor v = new CeylonTree.Visitor () {\n            public void visit(CeylonTree.CallExpression expr) {\n                buf.append(at(expr).Exec(convert(expr)));\n            }\n            public void visit(CeylonTree.ReturnStatement ret) {\n                buf.append(convert(ret));\n            }\n            public void visit(CeylonTree.IfStatement stat) {\n                buf.append(convert(stat));\n            }\n            public void visit(CeylonTree.MemberDeclaration decl) {\n               \tfor (JCTree def: convert(decl))\n                     buf.append((JCStatement)def);\n            }\n            public void visit(CeylonTree.Operator op) {\n               \tbuf.append(at(op).Exec(convert(op)));\n           }\n            };\n            \n        for (CeylonTree stmt: stmts) \n        \tstmt.accept(v);\n            \n        return buf.toList();\n    }","commit_id":"512fe10f433ac3d3c6e5c4c931471b34e6f8033e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"/**\n         * Appends to <tt>defs<\/tt> the definitions that would go into the class generated by {@link #build()}\n         * @param defs a {@link ListBuffer} to which the definitions will be appended.\n         */\n        public void appendDefinitionsTo(ListBuffer<JCTree> defs) {\n            defs.append(generateField());\n\n            if (readable) {\n                defs.append(generateGetter());\n            }\n\n            if (writable) {\n                defs.append(generateSetter());\n            }\n            \n            if(!skipConstructor){\n                // make a private constructor\n                defs.append(make().MethodDef(make().Modifiers(Flags.PRIVATE),\n                        names().init,\n                        make().TypeIdent(VOID),\n                        List.<JCTree.JCTypeParameter>nil(),\n                        List.<JCTree.JCVariableDecl>nil(),\n                        List.<JCTree.JCExpression>nil(),\n                        make().Block(0, List.<JCTree.JCStatement>nil()),\n                        null));\n            }\n        }","id":90438,"modified_method":"/**\n         * Appends to <tt>defs<\/tt> the definitions that would go into the class generated by {@link #build()}\n         * @param defs a {@link ListBuffer} to which the definitions will be appended.\n         */\n        public void appendDefinitionsTo(ListBuffer<JCTree> defs) {\n            if (getterBlock == null) {\n                defs.append(generateField());\n            }\n\n            if (readable) {\n                defs.append(generateGetter());\n            }\n\n            if (writable) {\n                defs.append(generateSetter());\n            }\n            \n            if(!skipConstructor){\n                // make a private constructor\n                defs.append(make().MethodDef(make().Modifiers(Flags.PRIVATE),\n                        names().init,\n                        make().TypeIdent(VOID),\n                        List.<JCTree.JCTypeParameter>nil(),\n                        List.<JCTree.JCVariableDecl>nil(),\n                        List.<JCTree.JCExpression>nil(),\n                        make().Block(0, List.<JCTree.JCStatement>nil()),\n                        null));\n            }\n        }","commit_id":"21b619d83cccfbf23ed790a1a1d8a09be733607e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCTree generateGetter() {\n            JCTree.JCBlock body = make().Block(0L, List.<JCTree.JCStatement>of(\n                    make().Return(make().Ident(fieldName))\n            ));\n            return make().MethodDef(\n                    make().Modifiers(Flags.STATIC | getterVisibility, valueAnnotations),\n                    getGetterName(variableName),\n                    variableType,\n                    List.<JCTree.JCTypeParameter>nil(),\n                    List.<JCTree.JCVariableDecl>nil(),\n                    List.<JCTree.JCExpression>nil(),\n                    body,\n                    null\n            );\n        }","id":90439,"modified_method":"private JCTree generateGetter() {\n            JCTree.JCBlock body = (getterBlock != null) ? getterBlock : make().Block(0L, List.<JCTree.JCStatement>of(\n                    make().Return(make().Ident(fieldName))\n            ));\n            return make().MethodDef(\n                    make().Modifiers(Flags.STATIC | getterVisibility, valueAnnotations),\n                    getGetterName(variableName),\n                    variableType,\n                    List.<JCTree.JCTypeParameter>nil(),\n                    List.<JCTree.JCVariableDecl>nil(),\n                    List.<JCTree.JCExpression>nil(),\n                    body,\n                    null\n            );\n        }","commit_id":"21b619d83cccfbf23ed790a1a1d8a09be733607e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private JCTree generateSetter() {\n            Name paramName = names().fromString(\"newValue\");\n\n            JCTree.JCBlock body = make().Block(0L, List.<JCTree.JCStatement>of(\n                    make().Exec(\n                            make().Assign(\n                                    make().Ident(fieldName),\n                                    make().Ident(paramName)))\n            ));\n            return make().MethodDef(\n                    make().Modifiers(Flags.STATIC | setterVisibility),\n                    getSetterName(variableName),\n                    make().TypeIdent(TypeTags.VOID),\n                    List.<JCTree.JCTypeParameter>nil(),\n                    List.<JCTree.JCVariableDecl>of(\n                            make().VarDef(make().Modifiers(0, valueAnnotations), paramName, variableType, null)\n                    ),\n                    List.<JCTree.JCExpression>nil(),\n                    body,\n                    null\n            );\n        }","id":90440,"modified_method":"private JCTree generateSetter() {\n            Name paramName = names().fromString(\"newValue\");\n\n            JCTree.JCBlock body = (getterBlock != null) ?\n                    ((setterBlock != null) ? setterBlock : make().Block(0L, List.<JCTree.JCStatement>nil()))\n                :\n                    make().Block(0L, List.<JCTree.JCStatement>of(\n                        make().Exec(\n                                make().Assign(\n                                        make().Ident(fieldName),\n                                        make().Ident(paramName)))\n            ));\n            return make().MethodDef(\n                    make().Modifiers(Flags.STATIC | setterVisibility),\n                    getSetterName(variableName),\n                    make().TypeIdent(TypeTags.VOID),\n                    List.<JCTree.JCTypeParameter>nil(),\n                    List.<JCTree.JCVariableDecl>of(\n                            make().VarDef(make().Modifiers(0, valueAnnotations), paramName, variableType, null)\n                    ),\n                    List.<JCTree.JCExpression>nil(),\n                    body,\n                    null\n            );\n        }","commit_id":"21b619d83cccfbf23ed790a1a1d8a09be733607e","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"private void updateNodeCache() {\r\n            if (this.handle == null) return;\r\n            if (this.headChunk == null) return;\r\n            \r\n            if (XcacheSize != 0) {\r\n                synchronized (XcacheHeaders) {\r\n                    // remember size to evaluate a cache size check need\r\n                    int sizeBefore = XcacheHeaders.size();\r\n                    //long memBefore = Runtime.getRuntime().freeMemory();\r\n                    // generate cache entry\r\n                    byte[] cacheEntry = new byte[headchunksize];\r\n                    System.arraycopy(headChunk, 0, cacheEntry, 0, headchunksize);\r\n                    Handle cacheHandle = new Handle(this.handle.index);\r\n                    \r\n                    // store the cache entry\r\n                    //XcacheHeaders.remove(cacheHandle);\r\n                    XcacheHeaders.put(cacheHandle, cacheEntry);\r\n                    XcacheScore.setScore(cacheHandle, (int) ((System.currentTimeMillis() - XcacheStartup) / 1000));\r\n\r\n                    // delete the cache entry buffer\r\n                    cacheEntry = null;\r\n                    cacheHandle = null;\r\n                    //System.out.println(\"kelondroRecords cache4\" + filename + \": cache record size = \" + (memBefore - Runtime.getRuntime().freeMemory()) + \" bytes\" + ((newentry) ? \" new\" : \"\"));\r\n                    // check cache size\r\n                    if (XcacheHeaders.size() > sizeBefore) checkCacheSpace();\r\n                    //System.out.println(\"kelondroRecords cache4\" + filename + \": \" + XcacheHeaders.size() + \" entries, \" + XcacheSize + \" allowed.\");\r\n                    //printCache();\r\n                }\r\n            }\r\n        }","id":90441,"modified_method":"private void updateNodeCache() {\r\n            if (this.handle == null) return; // wrong access\r\n            if (this.headChunk == null) return; // nothing there to cache\r\n            if (XcacheSize == 0) return; // we do not use the cache\r\n            if ((XcacheScore == null) && (XcacheSize <= XcacheHeaders.size())) return; // no cache control and cache is full\r\n            \r\n            synchronized (XcacheHeaders) {\r\n                // remember size to evaluate a cache size check need\r\n                int sizeBefore = XcacheHeaders.size();\r\n                //long memBefore = Runtime.getRuntime().freeMemory();\r\n                // generate cache entry\r\n                byte[] cacheEntry = new byte[headchunksize];\r\n                System.arraycopy(headChunk, 0, cacheEntry, 0, headchunksize);\r\n                Handle cacheHandle = new Handle(this.handle.index);\r\n                \r\n                // store the cache entry\r\n                //XcacheHeaders.remove(cacheHandle);\r\n                XcacheHeaders.put(cacheHandle, cacheEntry);\r\n                if (XcacheScore != null) XcacheScore.setScore(cacheHandle, (int) ((System.currentTimeMillis() - XcacheStartup) / 1000));\r\n                \r\n                // delete the cache entry buffer\r\n                cacheEntry = null;\r\n                cacheHandle = null;\r\n                //System.out.println(\"kelondroRecords cache4\" + filename + \": cache record size = \" + (memBefore - Runtime.getRuntime().freeMemory()) + \" bytes\" + ((newentry) ? \" new\" : \"\"));\r\n                // check cache size\r\n                if (XcacheHeaders.size() > sizeBefore) checkCacheSpace();\r\n                //System.out.println(\"kelondroRecords cache4\" + filename + \": \" + XcacheHeaders.size() + \" entries, \" + XcacheSize + \" allowed.\");\r\n                //printCache();\r\n            }\r\n        }","commit_id":"2d2262638689c52897ca312623f4ef79782aed85","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void checkCacheSpace() {\r\n        // check for space in cache\r\n        // should be only called within a synchronized(XcacheHeaders) environment\r\n        if (XcacheSize == 0) return;\r\n        Handle delkey;\r\n        long free = Runtime.getRuntime().freeMemory();\r\n        int count = 0;\r\n        while ((count++ < 100) && (free < memKcolb) &&\r\n               ((XcacheHeaders.size() >= XcacheSize) ||\r\n                ((XcacheHeaders.size() > 0) && (free < memBlock)))) {\r\n            // delete one entry\r\n            try {\r\n                delkey = (Handle) XcacheScore.getMinObject(); // error (see below) here\r\n                XcacheScore.deleteScore(delkey);\r\n                XcacheHeaders.remove(delkey);\r\n            } catch (NoSuchElementException e) {\r\n                System.out.println(\"strange kelondroRecords error: \" + e.getMessage() + \"; cachesize=\" + XcacheSize + \", cache.size()=\" + XcacheHeaders.size() + \", cacheScore.size()=\" + XcacheScore.size());\r\n                // this is a strange error and could be caused by internal java problems\r\n                // we simply clear the cache\r\n                this.XcacheScore = new kelondroMScoreCluster();\r\n                this.XcacheHeaders = new HashMap();\r\n            }\r\n            delkey = null;\r\n        }\r\n    }","id":90442,"modified_method":"private void checkCacheSpace() {\r\n        // check for space in cache\r\n        // should be only called within a synchronized(XcacheHeaders) environment\r\n        if (XcacheSize == 0) return; // no caching\r\n        if (XcacheScore == null) return; // no cache control\r\n        Handle delkey;\r\n        long free = Runtime.getRuntime().freeMemory();\r\n        int count = 0;\r\n        while ((count++ < 100) && (free < memKcolb) &&\r\n               ((XcacheHeaders.size() >= XcacheSize) ||\r\n                ((XcacheHeaders.size() > 0) && (free < memBlock)))) {\r\n            // delete one entry\r\n            try {\r\n                delkey = (Handle) XcacheScore.getMinObject(); // error (see below) here\r\n                XcacheScore.deleteScore(delkey);\r\n                XcacheHeaders.remove(delkey);\r\n            } catch (NoSuchElementException e) {\r\n                System.out.println(\"strange kelondroRecords error: \" + e.getMessage() + \"; cachesize=\" + XcacheSize + \", cache.size()=\" + XcacheHeaders.size() + \", cacheScore.size()=\" + XcacheScore.size());\r\n                // this is a strange error and could be caused by internal java problems\r\n                // we simply clear the cache\r\n                this.XcacheScore = new kelondroMScoreCluster();\r\n                this.XcacheHeaders = new HashMap();\r\n            }\r\n            delkey = null;\r\n        }\r\n    }","commit_id":"2d2262638689c52897ca312623f4ef79782aed85","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public kelondroRecords(kelondroRA ra, long buffersize) throws IOException{\r\n        this.filename = null;\r\n        init(ra);\r\n        this.XcacheSize = (int) (buffersize / ((long) (overhead + COLWIDTHS[0])));\r\n        if (XcacheSize <= 0) {\r\n            XcacheSize = 0;\r\n            this.XcacheHeaders = null;\r\n            this.XcacheScore = null;\r\n        } else {\r\n            this.XcacheHeaders = new HashMap();\r\n            this.XcacheScore = new kelondroMScoreCluster();\r\n        }\r\n        this.XcacheStartup = System.currentTimeMillis();\r\n    }","id":90443,"modified_method":"public kelondroRecords(kelondroRA ra, long buffersize) throws IOException{\r\n        this.filename = null;\r\n        init(ra);\r\n        this.XcacheSize = (int) (buffersize / ((long) (overhead + COLWIDTHS[0])));\r\n        if (this.XcacheSize > size()) this.XcacheSize = size() + 1; // do not waste too much memory\r\n        if (XcacheSize <= 0) {\r\n            XcacheSize = 0;\r\n            this.XcacheHeaders = null;\r\n            this.XcacheScore = null;\r\n        } else {\r\n            this.XcacheHeaders = new HashMap();\r\n            this.XcacheScore = (this.XcacheSize > size()) ? null : new kelondroMScoreCluster();\r\n        }\r\n        this.XcacheStartup = System.currentTimeMillis();\r\n    }","commit_id":"2d2262638689c52897ca312623f4ef79782aed85","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public kelondroRecords(File file, long buffersize) throws IOException{\r\n\t// opens an existing tree\r\n\tif (!file.exists()) throw new IOException(\"kelondroRecords: file \" + file.getAbsoluteFile().toString() + \" does not exist\");\r\n\r\n        this.filename = file.getCanonicalPath();\r\n        kelondroRA raf = new kelondroFileRA(this.filename);\r\n        //kelondroRA raf = new kelondroBufferedRA(new kelondroFileRA(this.filename));\r\n        //kelondroRA raf = new kelondroCachedRA(new kelondroFileRA(this.filename), 5000000, 1000);\r\n        //kelondroRA raf = new kelondroNIOFileRA(this.filename, (file.length() < 4000000), 10000);\r\n        init(raf);\r\n        this.XcacheSize = (int) (buffersize / ((long) (overhead + COLWIDTHS[0])));\r\n        if (XcacheSize <= 0) {\r\n            XcacheSize = 0;\r\n            this.XcacheHeaders = null;\r\n            this.XcacheScore = null;\r\n        } else {\r\n            this.XcacheHeaders = new HashMap();\r\n            this.XcacheScore = new kelondroMScoreCluster();\r\n        }\r\n        this.XcacheStartup = System.currentTimeMillis();\r\n    }","id":90444,"modified_method":"public kelondroRecords(File file, long buffersize) throws IOException{\r\n\t// opens an existing tree\r\n\tif (!file.exists()) throw new IOException(\"kelondroRecords: file \" + file.getAbsoluteFile().toString() + \" does not exist\");\r\n\r\n        this.filename = file.getCanonicalPath();\r\n        kelondroRA raf = new kelondroFileRA(this.filename);\r\n        //kelondroRA raf = new kelondroBufferedRA(new kelondroFileRA(this.filename));\r\n        //kelondroRA raf = new kelondroCachedRA(new kelondroFileRA(this.filename), 5000000, 1000);\r\n        //kelondroRA raf = new kelondroNIOFileRA(this.filename, (file.length() < 4000000), 10000);\r\n        init(raf);\r\n        this.XcacheSize = (int) (buffersize / ((long) (overhead + COLWIDTHS[0])));\r\n        if (this.XcacheSize > size()) this.XcacheSize = size() + 1; // do not waste too much memory\r\n        if (XcacheSize <= 0) {\r\n            XcacheSize = 0;\r\n            this.XcacheHeaders = null;\r\n            this.XcacheScore = null;\r\n        } else {\r\n            this.XcacheHeaders = new HashMap();\r\n            this.XcacheScore = (this.XcacheSize > size()) ? null : new kelondroMScoreCluster();\r\n        }\r\n        this.XcacheStartup = System.currentTimeMillis();\r\n    }","commit_id":"2d2262638689c52897ca312623f4ef79782aed85","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public kelondroRecords(File file, long buffersize /* bytes */,\r\n                           short ohbytec, short ohhandlec,\r\n\t\t\t   int[] columns, int FHandles, int txtProps, int txtPropWidth) throws IOException {\r\n\t// creates a new file\r\n\t// file: the file that shall be created\r\n\t// oha : overhead size array of four bytes: oha[0]=# of bytes, oha[1]=# of shorts, oha[2]=# of ints, oha[3]=# of longs, \r\n\t// columns: array with size of column width; columns.length is number of columns\r\n\t// FHandles: number of integer properties\r\n\t// txtProps: number of text properties\r\n\r\n\tif (file.exists()) throw new IOException(\"kelondroRecords: file \" + file + \" already exist\");\r\n\tthis.filename   = file.getCanonicalPath();\r\n        kelondroRA raf = new kelondroFileRA(this.filename);\r\n        //kelondroRA raf = new kelondroBufferedRA(new kelondroFileRA(this.filename));\r\n        //kelondroRA raf = new kelondroNIOFileRA(this.filename, false, 10000);\r\n        init(raf, ohbytec, ohhandlec, columns, FHandles, txtProps, txtPropWidth);\r\n        this.XcacheSize = (int) (buffersize / ((long) (overhead + columns[0])));\r\n        if (XcacheSize <= 0) {\r\n            XcacheSize = 0;\r\n            this.XcacheHeaders = null;\r\n            this.XcacheScore = null;\r\n        } else {\r\n            this.XcacheHeaders = new HashMap();\r\n            this.XcacheScore = new kelondroMScoreCluster();\r\n        }\r\n        this.XcacheStartup = System.currentTimeMillis();\r\n    }","id":90445,"modified_method":"public kelondroRecords(File file, long buffersize /* bytes */,\r\n                           short ohbytec, short ohhandlec,\r\n\t\t\t   int[] columns, int FHandles, int txtProps, int txtPropWidth) throws IOException {\r\n\t// creates a new file\r\n\t// file: the file that shall be created\r\n\t// oha : overhead size array of four bytes: oha[0]=# of bytes, oha[1]=# of shorts, oha[2]=# of ints, oha[3]=# of longs, \r\n\t// columns: array with size of column width; columns.length is number of columns\r\n\t// FHandles: number of integer properties\r\n\t// txtProps: number of text properties\r\n\r\n\tif (file.exists()) throw new IOException(\"kelondroRecords: file \" + file + \" already exist\");\r\n\tthis.filename   = file.getCanonicalPath();\r\n        kelondroRA raf = new kelondroFileRA(this.filename);\r\n        //kelondroRA raf = new kelondroBufferedRA(new kelondroFileRA(this.filename));\r\n        //kelondroRA raf = new kelondroNIOFileRA(this.filename, false, 10000);\r\n        init(raf, ohbytec, ohhandlec, columns, FHandles, txtProps, txtPropWidth);\r\n        this.XcacheSize = (int) (buffersize / ((long) (overhead + columns[0])));\r\n        if (this.XcacheSize > size()) this.XcacheSize = size() + 1; // do not waste too much memory\r\n        if (XcacheSize <= 0) {\r\n            XcacheSize = 0;\r\n            this.XcacheHeaders = null;\r\n            this.XcacheScore = null;\r\n        } else {\r\n            // initialize cache\r\n            // in case that we have more cache space than elements\r\n            // we dont need cache control by the XcacheScore\r\n            this.XcacheHeaders = new HashMap();\r\n            this.XcacheScore = (this.XcacheSize > size()) ? null : new kelondroMScoreCluster();\r\n        }\r\n        this.XcacheStartup = System.currentTimeMillis();\r\n    }","commit_id":"2d2262638689c52897ca312623f4ef79782aed85","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected void deleteNode(Handle handle) throws IOException {\r\n        if (XcacheSize != 0) {\r\n            synchronized (XcacheHeaders) {\r\n                if (XcacheHeaders.get(handle) != null) {\r\n                    XcacheScore.deleteScore(handle);\r\n                    XcacheHeaders.remove(handle);\r\n                }\r\n            }\r\n        }\r\n        dispose(handle);\r\n    }","id":90446,"modified_method":"protected void deleteNode(Handle handle) throws IOException {\r\n        if (XcacheSize != 0) {\r\n            synchronized (XcacheHeaders) {\r\n                if (XcacheScore == null) {\r\n                    XcacheHeaders.remove(handle);\r\n                } else if (XcacheHeaders.get(handle) != null) {\r\n                    XcacheScore.deleteScore(handle);\r\n                    XcacheHeaders.remove(handle);\r\n                }\r\n            }\r\n        }\r\n        dispose(handle);\r\n    }","commit_id":"2d2262638689c52897ca312623f4ef79782aed85","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public kelondroRecords(kelondroRA ra, long buffersize /* bytes */,\r\n                           short ohbytec, short ohhandlec,\r\n\t\t\t   int[] columns, int FHandles, int txtProps, int txtPropWidth) throws IOException {\r\n        this.filename = null;\r\n        init(ra, ohbytec, ohhandlec, columns, FHandles, txtProps, txtPropWidth);\r\n        this.XcacheSize = (int) (buffersize / ((long) (overhead + columns[0])));\r\n        if (XcacheSize <= 0) {\r\n            XcacheSize = 0;\r\n            this.XcacheHeaders = null;\r\n            this.XcacheScore = null;\r\n        } else {\r\n            this.XcacheHeaders = new HashMap();\r\n            this.XcacheScore = new kelondroMScoreCluster();\r\n        }\r\n        this.XcacheStartup = System.currentTimeMillis();\r\n    }","id":90447,"modified_method":"public kelondroRecords(kelondroRA ra, long buffersize /* bytes */,\r\n                           short ohbytec, short ohhandlec,\r\n\t\t\t   int[] columns, int FHandles, int txtProps, int txtPropWidth) throws IOException {\r\n        this.filename = null;\r\n        init(ra, ohbytec, ohhandlec, columns, FHandles, txtProps, txtPropWidth);\r\n        this.XcacheSize = (int) (buffersize / ((long) (overhead + columns[0])));\r\n        if (this.XcacheSize > size()) this.XcacheSize = size() + 1; // do not waste too much memory\r\n        if (XcacheSize <= 0) {\r\n            XcacheSize = 0;\r\n            this.XcacheHeaders = null;\r\n            this.XcacheScore = null;\r\n        } else {\r\n            this.XcacheHeaders = new HashMap();\r\n            this.XcacheScore = (this.XcacheSize > size()) ? null : new kelondroMScoreCluster();\r\n        }\r\n        this.XcacheStartup = System.currentTimeMillis();\r\n    }","commit_id":"2d2262638689c52897ca312623f4ef79782aed85","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void initContent() throws IOException {\r\n            // create chunks; read them from file or cache\r\n            this.tailChunk = null;\r\n            if (XcacheSize == 0) {\r\n                // read overhead and key\r\n                //System.out.println(\"**NO CACHE for \" + this.handle.index + \"**\");\r\n                this.headChunk = new byte[headchunksize];\r\n                synchronized (entryFile) {\r\n                    entryFile.seek(seekpos(this.handle));\r\n                    entryFile.readFully(this.headChunk, 0, this.headChunk.length);\r\n                }\r\n                this.headChanged = false;\r\n            } else synchronized(XcacheHeaders) {\r\n                byte[] cacheEntry = (byte[]) XcacheHeaders.get(this.handle);\r\n                if (cacheEntry == null) {\r\n                    // read overhead and key\r\n                    //System.out.println(\"**CACHE miss for \" + this.handle.index + \"**\");\r\n                    this.headChunk = new byte[headchunksize];\r\n                    //this.tailChunk = new byte[tailchunksize];\r\n                    synchronized (entryFile) {\r\n                        entryFile.seek(seekpos(this.handle));\r\n                        entryFile.readFully(this.headChunk, 0, this.headChunk.length);\r\n                        //entryFile.read(this.tailChunk, 0, this.tailChunk.length);\r\n                    }\r\n                    this.headChanged = true; // provoke a cache store\r\n                    checkCacheSpace();\r\n                    updateNodeCache();\r\n                } else {\r\n                    //System.out.println(\"**CACHE HIT for \" + this.handle.index + \"**\");\r\n                    // copy cache entry\r\n                    this.headChunk = new byte[headchunksize];\r\n                    System.arraycopy(cacheEntry, 0, this.headChunk, 0, headchunksize);\r\n                    // update cache scores to announce this cache hit\r\n                    XcacheScore.setScore(this.handle, (int) ((System.currentTimeMillis() - XcacheStartup) / 1000));\r\n                    this.headChanged = false;\r\n                }\r\n            }\r\n        }","id":90448,"modified_method":"private void initContent() throws IOException {\r\n            // create chunks; read them from file or cache\r\n            this.tailChunk = null;\r\n            if (XcacheSize == 0) {\r\n                // read overhead and key\r\n                //System.out.println(\"**NO CACHE for \" + this.handle.index + \"**\");\r\n                this.headChunk = new byte[headchunksize];\r\n                synchronized (entryFile) {\r\n                    entryFile.seek(seekpos(this.handle));\r\n                    entryFile.readFully(this.headChunk, 0, this.headChunk.length);\r\n                }\r\n                this.headChanged = false;\r\n            } else synchronized(XcacheHeaders) {\r\n                byte[] cacheEntry = (byte[]) XcacheHeaders.get(this.handle);\r\n                if (cacheEntry == null) {\r\n                    // read overhead and key\r\n                    //System.out.println(\"**CACHE miss for \" + this.handle.index + \"**\");\r\n                    this.headChunk = new byte[headchunksize];\r\n                    //this.tailChunk = new byte[tailchunksize];\r\n                    synchronized (entryFile) {\r\n                        entryFile.seek(seekpos(this.handle));\r\n                        entryFile.readFully(this.headChunk, 0, this.headChunk.length);\r\n                        //entryFile.read(this.tailChunk, 0, this.tailChunk.length);\r\n                    }\r\n                    this.headChanged = true; // provoke a cache store\r\n                    checkCacheSpace();\r\n                    updateNodeCache();\r\n                } else {\r\n                    //System.out.println(\"**CACHE HIT for \" + this.handle.index + \"**\");\r\n                    // copy cache entry\r\n                    this.headChunk = new byte[headchunksize];\r\n                    System.arraycopy(cacheEntry, 0, this.headChunk, 0, headchunksize);\r\n                    // update cache scores to announce this cache hit\r\n                    if (XcacheScore != null) XcacheScore.setScore(this.handle, (int) ((System.currentTimeMillis() - XcacheStartup) / 1000));\r\n                    this.headChanged = false;\r\n                }\r\n            }\r\n        }","commit_id":"2d2262638689c52897ca312623f4ef79782aed85","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private Tree doOneSentence(List<ParserConstraint> constraints,\n                             List<CoreLabel> words) {\n    ParserQuery pq = parser.parserQuery();\n    pq.setConstraints(constraints);\n    pq.parse(words);\n    Tree tree = null;\n    try {\n      tree = pq.getBestParse();\n      // -10000 denotes unknown words\n      tree.setScore(pq.getPCFGScore() % -10000.0);\n    } catch (OutOfMemoryError e) {\n      System.err.println(\"WARNING: Parsing of sentence ran out of memory.  \" +\n                         \"Will ignore and continue: \" +\n                         Sentence.listToString(words));\n    } catch (NoSuchParseException e) {\n      System.err.println(\"WARNING: Parsing of sentence failed, possibly because of out of memory.  \" +\n                         \"Will ignore and continue: \" +\n                         Sentence.listToString(words));\n    }\n    return tree;\n  }","id":90449,"modified_method":"private Tree doOneSentence(List<ParserConstraint> constraints,\n                             List<CoreLabel> words) {\n    ParserQuery pq = parser.parserQuery();\n    pq.setConstraints(constraints);\n    pq.parse(words);\n    Tree tree = null;\n    try {\n      tree = pq.getBestParse();\n      if (tree == null) {\n        System.err.println(\"WARNING: Parsing of sentence failed.  \" +\n                         \"Will ignore and continue: \" +\n                         Sentence.listToString(words));\n      } else {\n        // -10000 denotes unknown words\n        tree.setScore(pq.getPCFGScore() % -10000.0);\n      }\n    } catch (OutOfMemoryError e) {\n      System.err.println(\"WARNING: Parsing of sentence ran out of memory.  \" +\n                         \"Will ignore and continue: \" +\n                         Sentence.listToString(words));\n    } catch (NoSuchParseException e) {\n      System.err.println(\"WARNING: Parsing of sentence failed, possibly because of out of memory.  \" +\n                         \"Will ignore and continue: \" +\n                         Sentence.listToString(words));\n    }\n    return tree;\n  }","commit_id":"2be0a37d8af066eca06f2bee5dbd6ded62d21d3f","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public void handleMessage(Message message) {\n        BindingOperationInfo bop = message.getExchange().get(BindingOperationInfo.class);\n\n        if (bop != null && bop.isUnwrapped()) {\n            XMLStreamWriter xmlWriter = message.getContent(XMLStreamWriter.class);\n\n            MessageInfo messageInfo;\n            if (isRequestor(message)) {\n                messageInfo = bop.getWrappedOperation().getOperationInfo().getInput();\n            } else {\n                messageInfo = bop.getWrappedOperation().getOperationInfo().getOutput();\n            }\n\n            MessagePartInfo part = messageInfo.getMessageParts().get(0);\n            QName name = part.getConcreteName();\n\n            try {\n                \n                int x = 1;\n                while (xmlWriter.getNamespaceContext().getNamespaceURI(\"ns\" + x) != null) {\n                    x++;\n                }\n                xmlWriter.setPrefix(\"ns\" + x, name.getNamespaceURI());\n                xmlWriter.writeStartElement(\"ns\" + x, name.getLocalPart(), name.getNamespaceURI());\n                xmlWriter.writeNamespace(\"ns\" + x, name.getNamespaceURI());\n            } catch (XMLStreamException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"STAX_WRITE_EXC\", BUNDLE), e);\n            }\n\n            // Add a final interceptor to write end element\n            message.getInterceptorChain().add(ending);\n        }\n    }","id":90450,"modified_method":"public void handleMessage(Message message) {\n        BindingOperationInfo bop = message.getExchange().get(BindingOperationInfo.class);\n\n        if (bop != null && bop.isUnwrapped()) {\n            XMLStreamWriter xmlWriter = message.getContent(XMLStreamWriter.class);\n\n            MessageInfo messageInfo;\n            if (isRequestor(message)) {\n                messageInfo = bop.getWrappedOperation().getOperationInfo().getInput();\n            } else {\n                messageInfo = bop.getWrappedOperation().getOperationInfo().getOutput();\n            }\n\n            MessagePartInfo part = messageInfo.getMessageParts().get(0);\n            QName name = part.getConcreteName();\n\n            try {\n                String pfx = null;\n                Service service = message.getExchange().get(Service.class);\n                if (service.getDataBinding().getDeclaredNamespaceMappings() != null) {\n                    pfx = service.getDataBinding().getDeclaredNamespaceMappings().get(name.getNamespaceURI());\n                }\n                if (pfx == null) {\n                    int x = 1;\n                    while (xmlWriter.getNamespaceContext().getNamespaceURI(\"ns\" + x) != null) {\n                        x++;\n                    }\n                    pfx = \"ns\" + x;\n                }\n                xmlWriter.setPrefix(pfx, name.getNamespaceURI());\n                xmlWriter.writeStartElement(pfx, name.getLocalPart(), name.getNamespaceURI());\n                xmlWriter.writeNamespace(pfx, name.getNamespaceURI());\n            } catch (XMLStreamException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"STAX_WRITE_EXC\", BUNDLE), e);\n            }\n\n            // Add a final interceptor to write end element\n            message.getInterceptorChain().add(ending);\n        }\n    }","commit_id":"57a3f76530211ca6831e27afc434b457671e8d74","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testDerby() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"jdbcDataSource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n        String refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"jdbcDataSource\\\" name=\\\"Bean\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"org.apache.derby.jdbc.EmbeddedDriver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\"/>\"\n                + \"<\/spring:bean>\";\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"jdbcDataSource\", refDef));\n\n        doTest(document, callback);\n        doTest(document, callback);\n        doTest(document, callback);\n    }","id":90451,"modified_method":"@Test\n    public void verifiesDerby() throws SAXException, IOException, MuleArtifactFactoryException\n    {\n        String config = \"<jdbc:connector name=\\\"jdbcConnector\\\" pollingFrequency=\\\"1000\\\" dataSource-ref=\\\"jdbcDataSource\\\" queryTimeout=\\\"3000\\\" xmlns:jdbc=\\\"http://www.mulesoft.org/schema/mule/jdbc\\\"/>\";\n        Document document = XMLUnit.buildControlDocument(config);\n        String refDef =\n                \"<spring:bean xmlns:spring=\\\"http://www.springframework.org/schema/beans\\\" class=\\\"org.apache.commons.dbcp.BasicDataSource\\\" destroy-method=\\\"close\\\" id=\\\"jdbcDataSource\\\" name=\\\"Bean\\\">\"\n                + \"<spring:property name=\\\"driverClassName\\\" value=\\\"org.apache.derby.jdbc.EmbeddedDriver\\\"/>\"\n                + \"<spring:property name=\\\"url\\\" value=\\\"jdbc:derby:muleEmbeddedDB;create=true\\\"/>\"\n                + \"<\/spring:bean>\";\n        XmlConfigurationCallback callback = new DatabaseConfigurationCallback(Collections.singletonMap(\"jdbcDataSource\", refDef));\n\n        doTest(document, callback);\n    }","commit_id":"5abfc315259462111466b1e39e768a4e150d51fd","url":"https://github.com/mulesoft/mule"},{"original_method":"private void processGlobalReferencesInChildElements(org.w3c.dom.Element element, XmlConfigurationCallback callback, Element rootElement) throws ParserConfigurationException\n    {\n        if (element != null && element.getChildNodes() != null)\n        {\n            // Look for references in first level of child nodes\n            for (int i = 0; i < element.getChildNodes().getLength(); i++)\n            {\n                processGlobalReferencesInAttributes(element.getChildNodes().item(i), callback, rootElement);\n            }\n        }\n    }","id":90452,"modified_method":"private void processGlobalReferencesInChildElements(org.w3c.dom.Element element, XmlConfigurationCallback callback, Element rootElement, Map<String, String> schemaLocations) throws ParserConfigurationException\n    {\n        if (element != null && element.getChildNodes() != null)\n        {\n            // Look for references in first level of child nodes\n            for (int i = 0; i < element.getChildNodes().getLength(); i++)\n            {\n                processGlobalReferencesInAttributes(element.getChildNodes().item(i), callback, rootElement, schemaLocations);\n            }\n        }\n    }","commit_id":"5abfc315259462111466b1e39e768a4e150d51fd","url":"https://github.com/mulesoft/mule"},{"original_method":"private void processGlobalReferences(org.w3c.dom.Element element, XmlConfigurationCallback callback, Element rootElement) throws ParserConfigurationException\n    {\n        processGlobalReferencesInAttributes(element, callback, rootElement);\n\n        processGlobalReferencesInChildElements(element, callback, rootElement);\n    }","id":90453,"modified_method":"private void processGlobalReferences(org.w3c.dom.Element element, XmlConfigurationCallback callback, Element rootElement, Map<String, String> schemaLocations) throws ParserConfigurationException\n    {\n        processGlobalReferencesInAttributes(element, callback, rootElement, schemaLocations);\n\n        processGlobalReferencesInChildElements(element, callback, rootElement, schemaLocations);\n    }","commit_id":"5abfc315259462111466b1e39e768a4e150d51fd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected String getArtifactMuleConfig(String flowName, org.w3c.dom.Element element, final XmlConfigurationCallback callback, boolean embedInFlow) throws MuleArtifactFactoryException\n    {\n        Document document = DocumentHelper.createDocument();\n\n        // the rootElement is the root of the document\n        Element rootElement = document.addElement(\"mule\", \"http://www.mulesoft.org/schema/mule/core\");\n\n        org.w3c.dom.Element[] placeholders = callback.getPropertyPlaceholders();\n        int noIgnoreUnresolvableCount = 0;\n        for (org.w3c.dom.Element placeholder : placeholders)\n        {\n            try\n            {\n                Element newPlaceHolder = convert(placeholder);\n                String ignoreUnresolvable = newPlaceHolder.attributeValue(IGNORE_UNRESOLVABLE_ATTR);\n                if (!\"true\".equalsIgnoreCase(ignoreUnresolvable))\n                {\n                    noIgnoreUnresolvableCount++;\n                }\n                // There are more than one property placeholder and configuration is prune to failure\n                if (noIgnoreUnresolvableCount > 1)\n                {\n                    throw new MuleArtifactFactoryException(\"There are multiple property-placeholder elements with attribute \" + IGNORE_UNRESOLVABLE_ATTR + \" missing or set to false. It may be not possible to find all property values. Please fix your Mule configuration file.\");\n                }\n                rootElement.add(newPlaceHolder);\n            }\n            catch (ParserConfigurationException e)\n            {\n                throw new MuleArtifactFactoryException(\"Error parsing XML\", e);\n            }\n\n        }\n\n\n        // the parentElement is the parent of the element we are adding\n        Element parentElement = rootElement;\n        addSchemaLocation(rootElement, element, callback);\n        if (embedInFlow)\n        {\n            // Need to put the message processor in a valid flow. Our default flow is:\n            //            \"<flow name=\\\"CreateSingle\\\">\"\n            //          + \"<\/flow>\"\n            parentElement = rootElement.addElement(\"flow\", \"http://www.mulesoft.org/schema/mule/core\");\n            parentElement.addAttribute(\"name\", flowName);\n        }\n        try\n        {\n            parentElement.add(convert(element));\n\n            processGlobalReferences(element, callback, rootElement);\n\n            // For message sources to work, the flow should be valid, this means needs to have a MP\n            if (embedInFlow)\n            {\n                parentElement.addElement(\"logger\", \"http://www.mulesoft.org/schema/mule/core\");\n            }\n\n            return document.asXML();\n        }\n        catch (Throwable t)\n        {\n            throw new MuleArtifactFactoryException(\"Error generating minimal XML configuration.\", t);\n        }\n\n    }","id":90454,"modified_method":"protected String getArtifactMuleConfig(String flowName, org.w3c.dom.Element element, final XmlConfigurationCallback callback, boolean embedInFlow) throws MuleArtifactFactoryException\n    {\n        Map<String, String> schemaLocations = new HashMap<String, String>();\n        schemaLocations.put(\"http://www.mulesoft.org/schema/mule/core\", \"http://www.mulesoft.org/schema/mule/core/current/mule.xsd\");\n\n        Document document = DocumentHelper.createDocument();\n\n        // the rootElement is the root of the document\n        Element rootElement = document.addElement(\"mule\", \"http://www.mulesoft.org/schema/mule/core\");\n\n        org.w3c.dom.Element[] placeholders = callback.getPropertyPlaceholders();\n        int noIgnoreUnresolvableCount = 0;\n        for (org.w3c.dom.Element placeholder : placeholders)\n        {\n            try\n            {\n                Element newPlaceHolder = convert(placeholder);\n                String ignoreUnresolvable = newPlaceHolder.attributeValue(IGNORE_UNRESOLVABLE_ATTR);\n                if (!\"true\".equalsIgnoreCase(ignoreUnresolvable))\n                {\n                    noIgnoreUnresolvableCount++;\n                }\n                // There are more than one property placeholder and configuration is prune to failure\n                if (noIgnoreUnresolvableCount > 1)\n                {\n                    throw new MuleArtifactFactoryException(\"There are multiple property-placeholder elements with attribute \" + IGNORE_UNRESOLVABLE_ATTR + \" missing or set to false. It may be not possible to find all property values. Please fix your Mule configuration file.\");\n                }\n                rootElement.add(newPlaceHolder);\n            }\n            catch (ParserConfigurationException e)\n            {\n                throw new MuleArtifactFactoryException(\"Error parsing XML\", e);\n            }\n\n        }\n\n\n        // the parentElement is the parent of the element we are adding\n        Element parentElement = rootElement;\n        addSchemaLocation(element, callback, schemaLocations);\n        if (embedInFlow)\n        {\n            // Need to put the message processor in a valid flow. Our default flow is:\n            //            \"<flow name=\\\"CreateSingle\\\">\"\n            //          + \"<\/flow>\"\n            parentElement = rootElement.addElement(\"flow\", \"http://www.mulesoft.org/schema/mule/core\");\n            parentElement.addAttribute(\"name\", flowName);\n        }\n        try\n        {\n            parentElement.add(convert(element));\n\n            processGlobalReferences(element, callback, rootElement, schemaLocations);\n\n            // For message sources to work, the flow should be valid, this means needs to have a MP\n            if (embedInFlow)\n            {\n                parentElement.addElement(\"logger\", \"http://www.mulesoft.org/schema/mule/core\");\n            }\n\n            setSchemaLocation(rootElement, schemaLocations);\n\n            return document.asXML();\n        }\n        catch (Throwable t)\n        {\n            throw new MuleArtifactFactoryException(\"Error generating minimal XML configuration.\", t);\n        }\n\n    }","commit_id":"5abfc315259462111466b1e39e768a4e150d51fd","url":"https://github.com/mulesoft/mule"},{"original_method":"private void processGlobalReferencesInAttributes(Node element, XmlConfigurationCallback callback, Element rootElement) throws ParserConfigurationException\n    {\n        if (element != null && element.getAttributes() != null)\n        {\n            for (int i = 0; i < element.getAttributes().getLength(); i++)\n            {\n                String attributeName = element.getAttributes().item(i).getLocalName();\n                if (attributeName != null && ((attributeName.endsWith(REF_SUFFIX) || attributeName.equals(REF_ATTRIBUTE_NAME)) || (element.getNodeName().endsWith(REF_SUFFIX) && attributeName.equals(NAME_ATTRIBUTE_NAME))))\n                {\n                    org.w3c.dom.Element dependentElement = callback.getGlobalElement(element.getAttributes()\n                                                                                             .item(i)\n                                                                                             .getNodeValue());\n                    addReferencedGlobalElement(callback, rootElement, dependentElement);\n                }\n            }\n        }\n\n    }","id":90455,"modified_method":"private void processGlobalReferencesInAttributes(Node element, XmlConfigurationCallback callback, Element rootElement, Map<String, String> schemaLocations) throws ParserConfigurationException\n    {\n        if (element != null && element.getAttributes() != null)\n        {\n            for (int i = 0; i < element.getAttributes().getLength(); i++)\n            {\n                String attributeName = element.getAttributes().item(i).getLocalName();\n                if (attributeName != null && ((attributeName.endsWith(REF_SUFFIX) || attributeName.equals(REF_ATTRIBUTE_NAME)) || (element.getNodeName().endsWith(REF_SUFFIX) && attributeName.equals(NAME_ATTRIBUTE_NAME))))\n                {\n                    org.w3c.dom.Element dependentElement = callback.getGlobalElement(element.getAttributes()\n                                                                                             .item(i)\n                                                                                             .getNodeValue());\n                    addReferencedGlobalElement(callback, rootElement, dependentElement, schemaLocations);\n                }\n                else if (attributeName != null && attributeName.endsWith(REFS_SUFFIX))\n                {\n                    StringTokenizer refs = new StringTokenizer(element.getAttributes().item(i).getNodeValue(), REFS_TOKENS);\n\n                    while(refs.hasMoreTokens())\n                    {\n                        String referenceName = refs.nextToken();\n                        if (StringUtils.isNotBlank(referenceName))\n                        {\n                            org.w3c.dom.Element dependentElement = callback.getGlobalElement(referenceName);\n                            addReferencedGlobalElement(callback, rootElement, dependentElement, schemaLocations);\n                        }\n\n                    }\n                }\n\n            }\n        }\n\n    }","commit_id":"5abfc315259462111466b1e39e768a4e150d51fd","url":"https://github.com/mulesoft/mule"},{"original_method":"private void addReferencedGlobalElement(XmlConfigurationCallback callback, Element rootElement, org.w3c.dom.Element dependentElement) throws ParserConfigurationException\n    {\n        if (dependentElement != null)\n        {\n            if (isSpringBean(dependentElement))\n            {\n                wrapElementInSpringBeanContainer(rootElement, dependentElement);\n            }\n            else\n            {\n                rootElement.add(convert(dependentElement));\n                addSchemaLocation(rootElement, dependentElement, callback);\n            }\n            processGlobalReferences(dependentElement, callback, rootElement);\n        }\n    }","id":90456,"modified_method":"private void addReferencedGlobalElement(XmlConfigurationCallback callback, Element rootElement, org.w3c.dom.Element dependentElement, Map<String, String> schemaLocations) throws ParserConfigurationException\n    {\n        if (dependentElement != null)\n        {\n            if (isSpringBean(dependentElement))\n            {\n                wrapElementInSpringBeanContainer(rootElement, dependentElement);\n            }\n            else\n            {\n                rootElement.add(convert(dependentElement));\n                addSchemaLocation(dependentElement, callback, schemaLocations);\n            }\n            processGlobalReferences(dependentElement, callback, rootElement, schemaLocations);\n        }\n    }","commit_id":"5abfc315259462111466b1e39e768a4e150d51fd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void addSchemaLocation(Element rootElement,\n                                     org.w3c.dom.Element element,\n                                     XmlConfigurationCallback callback)\n    {\n        StringBuffer schemaLocation = new StringBuffer();\n        schemaLocation.append(\"http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd\\n\");\n        schemaLocation.append(element.getNamespaceURI() + \" \"\n                              + callback.getSchemaLocation(element.getNamespaceURI()));\n        rootElement.addAttribute(\n                org.dom4j.QName.get(\"schemaLocation\", \"xsi\", \"http://www.w3.org/2001/XMLSchema-instance\"),\n                schemaLocation.toString());\n    }","id":90457,"modified_method":"protected void addSchemaLocation(org.w3c.dom.Element element, XmlConfigurationCallback callback,\n                                     Map<String, String> schemaLocations)\n    {\n        String key = element.getNamespaceURI();\n        if (key != null && !schemaLocations.containsKey(key))\n        {\n            schemaLocations.put(element.getNamespaceURI(), callback.getSchemaLocation(element.getNamespaceURI()));\n        }\n    }","commit_id":"5abfc315259462111466b1e39e768a4e150d51fd","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Extract a QName from an Element's string value. The prefix of the QName must be in scope.\n     * Return null if the text is empty.\n     *\n     * @param element       Element containing the attribute\n     * @param qNameString   QName to analyze\n     * @return              a QName object or null if not found\n     */\n    public static QName extractTextValueQName(Element element, String qNameString) {\n        if (qNameString == null)\n            return null;\n        qNameString = qNameString.trim();\n        if (qNameString.length() == 0)\n            return null;\n        Map namespaces = getNamespaceContext(element);\n        int colonIndex = qNameString.indexOf(':');\n        final String prefix;\n        final String localName;\n        final String namespaceURI;\n        if (colonIndex == -1) {\n            prefix = \"\";\n            localName = qNameString;\n            final String nsURI = (String) namespaces.get(prefix);\n            namespaceURI = nsURI == null ? \"\" : nsURI;\n        } else {\n            prefix = qNameString.substring(0, colonIndex);\n            localName = qNameString.substring(colonIndex + 1);\n            namespaceURI = (String) namespaces.get(prefix);\n            if (namespaceURI == null) {\n                throw new OXFException(\"No namespace declaration found for prefix: \" + prefix);\n            }\n        }\n        return new QName(localName, new Namespace(prefix, namespaceURI));\n    }","id":90458,"modified_method":"/**\n     * Extract a QName from an Element's string value. The prefix of the QName must be in scope.\n     * Return null if the text is empty.\n     *\n     * @param element       Element containing the attribute\n     * @param qNameString   QName to analyze\n     * @return              a QName object or null if not found\n     */\n    public static QName extractTextValueQName(Element element, String qNameString) {\n        if (qNameString == null)\n            return null;\n        qNameString = qNameString.trim();\n        if (qNameString.length() == 0)\n            return null;\n        final Map namespaces = getNamespaceContext(element);\n        final int colonIndex = qNameString.indexOf(':');\n        final String prefix;\n        final String localName;\n        final String namespaceURI;\n        if (colonIndex == -1) {\n            prefix = \"\";\n            localName = qNameString;\n            final String nsURI = (String) namespaces.get(prefix);\n            namespaceURI = nsURI == null ? \"\" : nsURI;\n        } else {\n            prefix = qNameString.substring(0, colonIndex);\n            localName = qNameString.substring(colonIndex + 1);\n            namespaceURI = (String) namespaces.get(prefix);\n            if (namespaceURI == null) {\n                throw new OXFException(\"No namespace declaration found for prefix: \" + prefix);\n            }\n        }\n        return new QName(localName, new Namespace(prefix, namespaceURI));\n    }","commit_id":"cda49ca679cc07415a9c397ff2223f3f81e10eca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Return a new document with a copy of newRoot as its root and all parent namespaces copied to\n     * the new root element, assuming they are not already declared on the new root element.\n     */\n    public static Document createDocumentCopyParentNamespaces(final Element newRoot) {\n\n        final Document document = Dom4jUtils.createDocument(newRoot);\n        final Element rootElement = document.getRootElement();\n\n        final Element parentElement = newRoot.getParent();\n        final Map parentNamespaceContext = Dom4jUtils.getNamespaceContext(parentElement);\n\n        for (Iterator k = parentNamespaceContext.keySet().iterator(); k.hasNext();) {\n            final String prefix = (String) k.next();\n            final String uri = (String) parentNamespaceContext.get(prefix);\n            if (rootElement.getNamespaceForPrefix(prefix) == null)\n                rootElement.addNamespace(prefix, uri);\n        }\n\n        return document;\n    }","id":90459,"modified_method":"/**\n     * Return a new document with a copy of newRoot as its root and all parent namespaces copied to\n     * the new root element, assuming they are not already declared on the new root element.\n     */\n    public static Document createDocumentCopyParentNamespaces(final Element newRoot) {\n\n        final Document document = Dom4jUtils.createDocument(newRoot);\n        final Element rootElement = document.getRootElement();\n\n        final Element parentElement = newRoot.getParent();\n        final Map parentNamespaceContext = Dom4jUtils.getNamespaceContext(parentElement);\n        final Map rootElementNamespaceContext = Dom4jUtils.getNamespaceContext(rootElement);\n\n        for (Iterator k = parentNamespaceContext.keySet().iterator(); k.hasNext();) {\n            final String prefix = (String) k.next();\n            // NOTE: Don't use rootElement.getNamespaceForPrefix() because that will return the element prefix's\n            // namespace even if there are no namespace nodes\n            if (rootElementNamespaceContext.get(prefix) == null) {\n                final String uri = (String) parentNamespaceContext.get(prefix);\n                rootElement.addNamespace(prefix, uri);\n            }\n        }\n\n        return document;\n    }","commit_id":"cda49ca679cc07415a9c397ff2223f3f81e10eca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Check whether a node's value satisfies a simple schema type definition given by namespace URI and local name.\n     *\n     * @param containingNodeInfo    node containing the value (to update validation MIPs)\n     * @param value                 value to validate\n     * @param typeNamespaceURI      namespace URI of the type (\"\" if no namespace)\n     * @param typeLocalname         local name of the type\n     * @param typeQName             QName of type type (for error handling)\n     * @param locationData          LocationData to use in case of error\n     * @param modelBindId           id of model bind to use in case of error\n     * @return                      validation error message, null if no error\n     */\n    public String validateDatatype(NodeInfo containingNodeInfo, String value, String typeNamespaceURI, String typeLocalname, String typeQName, LocationData locationData, String modelBindId) {\n\n        if (typeNamespaceURI == null)\n            typeNamespaceURI = \"\";\n\n        // Create REDocumentDeclaration if needed\n        if (documentDeclaration == null) {\n            documentDeclaration = new REDocumentDeclaration(schemaGrammar);\n        }\n\n        // Find expression to use to validate\n        final Expression contentModelExpression;\n        {\n            if (typeNamespaceURI.equals(XSAcceptor.XMLSchemaNamespace) ) {\n                // Handle built-in schema type\n                try {\n                    contentModelExpression = schemaGrammar.getPool().createData(DatatypeFactory.getTypeByName(typeLocalname) );\n                } catch (DatatypeException e) {\n                    throw new ValidationException(\"Built-in schema type not found: \" + typeLocalname, locationData);\n                }\n            } else {\n                // Find schema for type namespace\n                final XMLSchemaSchema schema = ((XMLSchemaGrammar) schemaGrammar).getByNamespace(typeNamespaceURI);\n                if (schema == null)\n                    throw new ValidationException(\"No schema found for namespace: \" + typeNamespaceURI, locationData);\n\n                // Find simple type in schema\n                final SimpleTypeExp simpleTypeExpression = schema.simpleTypes.get(typeLocalname);\n                if (simpleTypeExpression != null) {\n                    // There is a simple type definition\n                    contentModelExpression = simpleTypeExpression;\n                } else {\n                    // Find complex type in schema\n                    final ComplexTypeExp complexTypeExpression = schema.complexTypes.get(typeLocalname);\n                    if (complexTypeExpression != null) {\n                        // There is a complex type definition\n                        if (complexTypeExpression != null && complexTypeExpression.simpleBaseType != null) {\n                            // Complex type with simple content\n                            // Here, we only validate the datatype part\n                            // NOTE: Here we are guessing a little bit from MSV by looking at simpleBaseType. Is this 100% correct?\n                            contentModelExpression = complexTypeExpression;\n                        } else {\n                            // XForms mandates simple types or complex types with simple content\n                            throw new ValidationException(\"Simple type or complex type with simple content required for type: \" + typeQName, locationData);\n                        }\n                    } else {\n                        // Find element declaration in schema\n                        final ElementDeclExp elementDeclExp = schema.elementDecls.get(typeLocalname);\n                        if (elementDeclExp != null) {\n                            // There is an element type definition\n                            final ElementDeclExp.XSElementExp xsElementExp = elementDeclExp.getElementExp();\n                            final Expression contentModel = xsElementExp.contentModel;\n                            if (contentModel instanceof ComplexTypeExp && ((ComplexTypeExp) contentModel).simpleBaseType != null) {\n                                // Element complex type with simple content\n                                // Here, we only validate the datatype part\n                                // NOTE: Here again, we do some guesswork from MSV. Is this 100% correct?\n                                contentModelExpression = contentModel;\n                            } else {\n                                throw new ValidationException(\"Simple type or complex type with simple content required for type: \" + typeQName, locationData);\n                            }\n                        } else {\n                            // XForms mandates simple types or complex types with simple content\n                            throw new ValidationException(\"Simple type or complex type with simple content required for type: \" + typeQName, locationData);\n                        }\n                    }\n                    // TODO: Must also look at schema.attributeDecls?\n                }\n            }\n        }\n\n        // Create a simple acceptor\n        final ExpressionAcceptor expressionAcceptor = new SimpleAcceptor(documentDeclaration, contentModelExpression, null, null);\n\n        // Validate text\n        final StringRef errorStringRef = new StringRef();\n        final DatatypeRef datatypeRef = new DatatypeRef();\n        if (!expressionAcceptor.onText2(value, validationContext, errorStringRef, datatypeRef)) {\n            if (errorStringRef.str == null) // not sure if this can happen\n                errorStringRef.str = \"Error validating simple type\";\n            return errorStringRef.str;\n        }\n\n        // Check final acceptor state\n        if (!expressionAcceptor.isAcceptState(errorStringRef)) {\n            if (errorStringRef.str == null) // not sure if this can happen\n                errorStringRef.str = \"Error validating simple type\";\n            return errorStringRef.str;\n        }\n\n        // Value is valid\n        return null;\n    }","id":90460,"modified_method":"/**\n     * Check whether a node's value satisfies a simple schema type definition given by namespace URI and local name.\n     *\n     * @param containingNodeInfo    node containing the value (to update validation MIPs)\n     * @param value                 value to validate\n     * @param typeNamespaceURI      namespace URI of the type (\"\" if no namespace)\n     * @param typeLocalname         local name of the type\n     * @param typeQName             QName of type type (for error handling)\n     * @param locationData          LocationData to use in case of error\n     * @param modelBindId           id of model bind to use in case of error\n     * @return                      validation error message, null if no error\n     */\n    public String validateDatatype(NodeInfo containingNodeInfo, String value, String typeNamespaceURI, String typeLocalname, String typeQName, LocationData locationData, String modelBindId) {\n\n        if (typeNamespaceURI == null)\n            typeNamespaceURI = \"\";\n\n        // Create REDocumentDeclaration if needed\n        if (documentDeclaration == null) {\n            documentDeclaration = createDocumentDeclaration(schemaGrammar);\n        }\n\n        // Find expression to use to validate\n        final Expression contentModelExpression;\n        {\n            if (typeNamespaceURI.equals(XSAcceptor.XMLSchemaNamespace) ) {\n                // Handle built-in schema type\n                try {\n                    contentModelExpression = schemaGrammar.getPool().createData(DatatypeFactory.getTypeByName(typeLocalname) );\n                } catch (DatatypeException e) {\n                    throw new ValidationException(\"Built-in schema type not found: \" + typeLocalname, locationData);\n                }\n            } else {\n                // Find schema for type namespace\n                final XMLSchemaSchema schema = ((XMLSchemaGrammar) schemaGrammar).getByNamespace(typeNamespaceURI);\n                if (schema == null)\n                    throw new ValidationException(\"No schema found for namespace: \" + typeNamespaceURI, locationData);\n\n                // Find simple type in schema\n                final SimpleTypeExp simpleTypeExpression = schema.simpleTypes.get(typeLocalname);\n                if (simpleTypeExpression != null) {\n                    // There is a simple type definition\n                    contentModelExpression = simpleTypeExpression;\n                } else {\n                    // Find complex type in schema\n                    final ComplexTypeExp complexTypeExpression = schema.complexTypes.get(typeLocalname);\n                    if (complexTypeExpression != null) {\n                        // There is a complex type definition\n                        if (complexTypeExpression != null && complexTypeExpression.simpleBaseType != null) {\n                            // Complex type with simple content\n                            // Here, we only validate the datatype part\n                            // NOTE: Here we are guessing a little bit from MSV by looking at simpleBaseType. Is this 100% correct?\n                            contentModelExpression = complexTypeExpression;\n                        } else {\n                            // XForms mandates simple types or complex types with simple content\n                            throw new ValidationException(\"Simple type or complex type with simple content required for type: \" + typeQName, locationData);\n                        }\n                    } else {\n                        // Find element declaration in schema\n                        final ElementDeclExp elementDeclExp = schema.elementDecls.get(typeLocalname);\n                        if (elementDeclExp != null) {\n                            // There is an element type definition\n                            final ElementDeclExp.XSElementExp xsElementExp = elementDeclExp.getElementExp();\n                            final Expression contentModel = xsElementExp.contentModel;\n                            if (contentModel instanceof ComplexTypeExp && ((ComplexTypeExp) contentModel).simpleBaseType != null) {\n                                // Element complex type with simple content\n                                // Here, we only validate the datatype part\n                                // NOTE: Here again, we do some guesswork from MSV. Is this 100% correct?\n                                contentModelExpression = contentModel;\n                            } else {\n                                throw new ValidationException(\"Simple type or complex type with simple content required for type: \" + typeQName, locationData);\n                            }\n                        } else {\n                            // XForms mandates simple types or complex types with simple content\n                            throw new ValidationException(\"Simple type or complex type with simple content required for type: \" + typeQName, locationData);\n                        }\n                    }\n                    // TODO: Must also look at schema.attributeDecls?\n                }\n            }\n        }\n\n        // Create a simple acceptor\n        final ExpressionAcceptor expressionAcceptor = new SimpleAcceptor(documentDeclaration, contentModelExpression, null, null);\n\n        // Validate text\n        final StringRef errorStringRef = new StringRef();\n        final DatatypeRef datatypeRef = new DatatypeRef();\n        if (!expressionAcceptor.onText2(value, validationContext, errorStringRef, datatypeRef)) {\n            if (errorStringRef.str == null) // not sure if this can happen\n                errorStringRef.str = \"Error validating simple type\";\n            return errorStringRef.str;\n        }\n\n        // Check final acceptor state\n        if (!expressionAcceptor.isAcceptState(errorStringRef)) {\n            if (errorStringRef.str == null) // not sure if this can happen\n                errorStringRef.str = \"Error validating simple type\";\n            return errorStringRef.str;\n        }\n\n        // Value is valid\n        return null;\n    }","commit_id":"cda49ca679cc07415a9c397ff2223f3f81e10eca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public String resolveNamespacePrefix(final String s) {\n            return null;\n        }","id":90461,"modified_method":"public String resolveNamespacePrefix(final String prefix) {\n            return (String) Dom4jUtils.getNamespaceContext(currentElement).get(prefix);\n        }","commit_id":"cda49ca679cc07415a9c397ff2223f3f81e10eca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"private boolean validateElement(final Element element, final Acceptor acceptor, final IDConstraintChecker icc, final boolean isReportErrors) {\n\n        // Create StartTagInfo\n        final StartTagInfo startTagInfo;\n        {\n            final String uri = element.getNamespaceURI();\n            final String name = element.getName();\n            final String qName = element.getQualifiedName();\n            final List attributesList = element.attributes();\n            final AttributesImpl attributes = new AttributesImpl();\n\n            for (final Iterator iterator = attributesList.iterator(); iterator.hasNext();) {\n                final Attribute attribute = (Attribute) iterator.next();\n                final String attributeURI = attribute.getNamespaceURI();\n                final String attributeName = attribute.getName();\n                final String attributeQName = attribute.getQualifiedName();\n                final String attributeValue = attribute.getValue();\n                attributes.addAttribute(attributeURI, attributeName, attributeQName, null, attributeValue);\n            }\n            startTagInfo = new StartTagInfo(uri, name, qName, attributes, validationContext);\n        }\n\n        final StringRef stringRef = new StringRef();\n\n        // Get child acceptor\n        final Acceptor childAcceptor;\n        {\n            Acceptor tempChildAcceptor = acceptor.createChildAcceptor(startTagInfo, null);\n            if (tempChildAcceptor == null) {\n                if (isReportErrors) {\n                    tempChildAcceptor = acceptor.createChildAcceptor(startTagInfo, stringRef);\n                    addSchemaError(element, stringRef.str);\n                } else {\n                    return false;\n                }\n            }\n            childAcceptor = tempChildAcceptor;\n        }\n\n        // Handle id errors\n        if (icc != null && isReportErrors) {\n            icc.onNextAcceptorReady(startTagInfo, childAcceptor, element);\n            handleIDErrors(icc);\n        }\n\n        // Validate children\n        final int stringCareLevel = childAcceptor.getStringCareLevel();\n        final DatatypeRef datatypeRef = new DatatypeRef();\n        final boolean childrenValid = validateChildren(element, childAcceptor, startTagInfo, stringCareLevel, icc, datatypeRef, isReportErrors);\n        if (!childrenValid && !isReportErrors)\n            return false;\n\n        if (!childAcceptor.isAcceptState(null)) {\n            if (isReportErrors) {\n                childAcceptor.isAcceptState(stringRef);\n                addSchemaError(element, stringRef.str);\n            } else {\n                return false;\n            }\n        } else if (datatypeRef.types != null && datatypeRef.types.length > 0) {\n            // This element is valid and has at least one assigned datatype\n\n            // Attempt to set datatype name\n            final InstanceData instanceData = XFormsUtils.getLocalInstanceData(element);\n            final Datatype datatype = datatypeRef.types[0];\n            if (datatype instanceof XSDatatype) {\n                final XSDatatype xsDatatype = (XSDatatype) datatype;\n                final String datatTypeURI = xsDatatype.getNamespaceUri();\n                final String datatTypeName = xsDatatype.getName();\n\n                if (datatTypeName != null && !datatTypeName.equals(\"\"))\n                    instanceData.getType().set(XMLUtils.buildExplodedQName(datatTypeURI, datatTypeName));\n            }\n        }\n\n        // Handle id errors\n        if (icc != null && isReportErrors) {\n            icc.endElement(element, datatypeRef.types);\n            handleIDErrors(icc);\n        }\n\n        // Get back to parent acceptor\n        if (!acceptor.stepForward(childAcceptor, null)) {\n            if (isReportErrors) {\n                acceptor.stepForward(childAcceptor, stringRef);\n                addSchemaError(element, stringRef.str);\n            } else {\n                return false;\n            }\n        }\n\n        // This element is valid\n        return true;\n    }","id":90462,"modified_method":"private boolean validateElement(final Element element, final Acceptor acceptor, final IDConstraintChecker icc, final boolean isReportErrors) {\n\n        // Create StartTagInfo\n        final StartTagInfo startTagInfo;\n        {\n            final String uri = element.getNamespaceURI();\n            final String name = element.getName();\n            final String qName = element.getQualifiedName();\n            final List attributesList = element.attributes();\n            final AttributesImpl attributes = new AttributesImpl();\n\n            for (final Iterator iterator = attributesList.iterator(); iterator.hasNext();) {\n                final Attribute attribute = (Attribute) iterator.next();\n                final String attributeURI = attribute.getNamespaceURI();\n                final String attributeName = attribute.getName();\n                final String attributeQName = attribute.getQualifiedName();\n                final String attributeValue = attribute.getValue();\n                attributes.addAttribute(attributeURI, attributeName, attributeQName, null, attributeValue);\n            }\n            validationContext.setCurrentElement(element);\n            startTagInfo = new StartTagInfo(uri, name, qName, attributes, validationContext);\n        }\n\n        final StringRef stringRef = new StringRef();\n\n        // Get child acceptor\n        final Acceptor childAcceptor;\n        {\n            Acceptor tempChildAcceptor = acceptor.createChildAcceptor(startTagInfo, null);\n            if (tempChildAcceptor == null) {\n                if (isReportErrors) {\n                    tempChildAcceptor = acceptor.createChildAcceptor(startTagInfo, stringRef);\n                    addSchemaError(element, stringRef.str);\n                } else {\n                    return false;\n                }\n            }\n            childAcceptor = tempChildAcceptor;\n        }\n\n        // Handle id errors\n        if (icc != null && isReportErrors) {\n            icc.onNextAcceptorReady(startTagInfo, childAcceptor, element);\n            handleIDErrors(icc);\n        }\n\n        // Validate children\n        final int stringCareLevel = childAcceptor.getStringCareLevel();\n        final DatatypeRef datatypeRef = new DatatypeRef();\n        final boolean childrenValid = validateChildren(element, childAcceptor, startTagInfo, stringCareLevel, icc, datatypeRef, isReportErrors);\n        if (!childrenValid && !isReportErrors)\n            return false;\n\n        if (!childAcceptor.isAcceptState(null)) {\n            if (isReportErrors) {\n                childAcceptor.isAcceptState(stringRef);\n                addSchemaError(element, stringRef.str);\n            } else {\n                return false;\n            }\n        } else if (datatypeRef.types != null && datatypeRef.types.length > 0) {\n            // This element is valid and has at least one assigned datatype\n\n            // Attempt to set datatype name\n            final InstanceData instanceData = XFormsUtils.getLocalInstanceData(element);\n            final Datatype datatype = datatypeRef.types[0];\n            if (datatype instanceof XSDatatype) {\n                final XSDatatype xsDatatype = (XSDatatype) datatype;\n                final String datatTypeURI = xsDatatype.getNamespaceUri();\n                final String datatTypeName = xsDatatype.getName();\n\n                if (datatTypeName != null && !datatTypeName.equals(\"\"))\n                    instanceData.getType().set(XMLUtils.buildExplodedQName(datatTypeURI, datatTypeName));\n            }\n        }\n\n        // Handle id errors\n        if (icc != null && isReportErrors) {\n            icc.endElement(element, datatypeRef.types);\n            handleIDErrors(icc);\n        }\n\n        // Get back to parent acceptor\n        if (!acceptor.stepForward(childAcceptor, null)) {\n            if (isReportErrors) {\n                acceptor.stepForward(childAcceptor, stringRef);\n                addSchemaError(element, stringRef.str);\n            } else {\n                return false;\n            }\n        }\n\n        // This element is valid\n        return true;\n    }","commit_id":"cda49ca679cc07415a9c397ff2223f3f81e10eca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Apply schema validation to an instance. The instance may content a hint specifying whether to perform \"lax\",\n     * \"strict\", or \"skip\" validation.\n     *\n     * @param instance          instance to validate\n     */\n    public void validateInstance(XFormsInstance instance) {\n        if (!isSkipInstanceSchemaValidation() && schemaGrammar != null) {\n\n            // Create REDocumentDeclaration if needed\n            if (documentDeclaration == null) {\n                documentDeclaration = new REDocumentDeclaration(schemaGrammar);\n            }\n\n            // Get validation mode (\"lax\" is the default)\n            final String validation = (instance.getValidation() == null) ? \"lax\" : instance.getValidation();\n            if (\"lax\".equals(validation)) {\n                // Lax validation\n                final Element instanceRootElement = instance.getDocument().getRootElement();\n                validateElementLax(instanceRootElement);\n            } else if (\"strict\".equals(instance.getValidation())) {\n                // Strict validation\n                final Acceptor acceptor = documentDeclaration.createAcceptor();\n                final Element instanceRootElement = instance.getDocument().getRootElement();\n                final IDConstraintChecker idConstraintChecker = new IDConstraintChecker();\n\n                validateElement(instanceRootElement, acceptor, idConstraintChecker, true);\n                idConstraintChecker.endDocument();\n                handleIDErrors(idConstraintChecker);\n            } else {\n                // Skip validation\n            }\n        }\n    }","id":90463,"modified_method":"/**\n     * Apply schema validation to an instance. The instance may content a hint specifying whether to perform \"lax\",\n     * \"strict\", or \"skip\" validation.\n     *\n     * @param instance          instance to validate\n     */\n    public void validateInstance(XFormsInstance instance) {\n        if (!isSkipInstanceSchemaValidation() && schemaGrammar != null) {\n\n            // Create REDocumentDeclaration if needed\n            if (documentDeclaration == null) {\n                documentDeclaration = createDocumentDeclaration(schemaGrammar);\n            }\n\n            // Get validation mode (\"lax\" is the default)\n            final String validation = (instance.getValidation() == null) ? \"lax\" : instance.getValidation();\n            if (\"lax\".equals(validation)) {\n                // Lax validation\n                final Element instanceRootElement = instance.getDocument().getRootElement();\n                validateElementLax(instanceRootElement);\n            } else if (\"strict\".equals(instance.getValidation())) {\n                // Strict validation\n                final Acceptor acceptor = documentDeclaration.createAcceptor();\n                final Element instanceRootElement = instance.getDocument().getRootElement();\n                final IDConstraintChecker idConstraintChecker = new IDConstraintChecker();\n\n                validateElement(instanceRootElement, acceptor, idConstraintChecker, true);\n                idConstraintChecker.endDocument();\n                handleIDErrors(idConstraintChecker);\n            } else {\n                // Skip validation\n            }\n        }\n    }","commit_id":"cda49ca679cc07415a9c397ff2223f3f81e10eca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Validate an element following the XML Schema \"lax\" mode.\n     *\n     * @param element   element to validate\n     */\n    private void validateElementLax(final Element element) {\n\n        final String elementURI = element.getNamespaceURI();\n        final String elementName = element.getName();\n//        final String elementQName = element.getQualifiedName();\n        {\n            // Find expression for element type\n            final Expression expression;\n            {\n                // Find schema for type namespace\n                final XMLSchemaSchema schema = ((XMLSchemaGrammar) schemaGrammar).getByNamespace(elementURI);\n                if (schema != null) {\n                    // Try to find the expression in the schema\n                    expression = schema.elementDecls.get(elementName);\n                } else {\n                    // No schema so no expression\n                    expression = null;\n                }\n            }\n\n            if (expression != null) {\n                // Found type for element, so validate element\n                final Acceptor acceptor = documentDeclaration.createAcceptor();\n                validateElement(element, acceptor, null, true);\n            } else {\n                // Element does not have type, so try to validate attributes and children elements\n\n                // Attributes\n                {\n                    final List attributesList = element.attributes();\n                    for (final Iterator iterator = attributesList.iterator(); iterator.hasNext();)   {\n                        final Attribute attribute = (Attribute) iterator.next();\n                        final String attributeURI = attribute.getNamespaceURI();\n                        final String attributeName = attribute.getName();\n//                        final String attributeQName = attribute.getQualifiedName();\n//                        final String attributeValue = attribute.getValue();\n\n                        // Find expression for element type\n                        final Expression attributeExpression;\n                        {\n                            // Find schema for type namespace\n                            final XMLSchemaSchema schema = ((XMLSchemaGrammar) schemaGrammar).getByNamespace(attributeURI);\n                            if (schema != null) {\n                                attributeExpression = schema.attributeDecls.get(attributeName);\n                            } else {\n                                attributeExpression = null;\n                            }\n                        }\n                        if (attributeExpression != null) {\n                            // TODO: find out way of validating an attribute only\n\n//                            final ExpressionAcceptor expressionAcceptor = new SimpleAcceptor(documentDeclaration, attributeExpression, null, null);\n//                            // Validate attribute value\n//                            final StringRef errorStringRef = new StringRef();\n//                            final DatatypeRef datatypeRef = new DatatypeRef();\n//\n//                            if (!expressionAcceptor.onAttribute2(attributeURI, attributeName, attributeQName, attributeValue, validationContext, errorStringRef, datatypeRef)) {\n//                                if (errorStringRef.str == null) // not sure if this can happen\n//                                    errorStringRef.str = \"Error validating attribute\";\n//                                addSchemaError(attribute, errorStringRef.str);\n//                            }\n\n//                            if (!expressionAcceptor.onText2(attributeValue, validationContext, errorStringRef, datatypeRef)) {\n//                                if (errorStringRef.str == null) // not sure if this can happen\n//                                    errorStringRef.str = \"Error validating attribute\";\n//                                addSchemaError(attribute, errorStringRef.str);\n//                            }\n//\n//                            // Check final acceptor state\n//                            if (!expressionAcceptor.isAcceptState(errorStringRef)) {\n//                                if (errorStringRef.str == null) // not sure if this can happen\n//                                    errorStringRef.str = \"Error validating attribute\";\n//                                addSchemaError(attribute, errorStringRef.str);\n//                            }\n                        }\n                    }\n                }\n\n                // Validate children elements\n                for (final Iterator iterator = element.elementIterator(); iterator.hasNext();) {\n                    final Element childElement = (Element) iterator.next();\n                    validateElementLax(childElement);\n                }\n            }\n        }\n    }","id":90464,"modified_method":"/**\n     * Validate an element following the XML Schema \"lax\" mode.\n     *\n     * @param element   element to validate\n     */\n    private void validateElementLax(final Element element) {\n\n        final String elementURI;\n        final String elementName;\n\n        // NOTE: We do some special processing for xsi:type to find if there is a type declared for it. If not, we do\n        // lax processing. However, it is not clear whether we should apply lax processing in this case or not. Maybe if\n        // an xsi:type is specified and not found, the element should just be invalid.\n        final QName xsiType = Dom4jUtils.extractAttributeValueQName(element, XMLConstants.XSI_TYPE_QNAME);\n        if (xsiType != null) {\n            // Honor xsi:type\n            elementURI = xsiType.getNamespaceURI();\n            elementName = xsiType.getName();\n        } else {\n            // Use element name\n            elementURI = element.getNamespaceURI();\n            elementName = element.getName();\n        }\n\n        {\n            // Find expression for element type\n            final Expression expression;\n            {\n                // Find schema for type namespace\n                final XMLSchemaSchema schema = ((XMLSchemaGrammar) schemaGrammar).getByNamespace(elementURI);\n                if (schema != null) {\n                    // Try to find the expression in the schema\n                    final ElementDeclExp elementDeclExp = schema.elementDecls.get(elementName);\n                    if (elementDeclExp != null) {\n                        // Found element type\n                        expression = elementDeclExp;\n                    } else if (xsiType != null) {\n                        // Try also complex type\n                        expression = schema.complexTypes.get(elementName);\n                    } else {\n                        // No type found\n                        expression = null;\n                    }\n                } else {\n                    // No schema so no expression\n                    expression = null;\n                }\n            }\n\n            if (expression != null) {\n                // Found type for element, so validate element\n                final Acceptor acceptor = documentDeclaration.createAcceptor();\n                validateElement(element, acceptor, null, true);\n            } else {\n                // Element does not have type, so try to validate attributes and children elements\n\n                // Attributes\n                {\n                    final List attributesList = element.attributes();\n                    for (final Iterator iterator = attributesList.iterator(); iterator.hasNext();)   {\n                        final Attribute attribute = (Attribute) iterator.next();\n                        final String attributeURI = attribute.getNamespaceURI();\n                        final String attributeName = attribute.getName();\n//                        final String attributeQName = attribute.getQualifiedName();\n//                        final String attributeValue = attribute.getValue();\n\n                        // Find expression for element type\n                        final Expression attributeExpression;\n                        {\n                            // Find schema for type namespace\n                            final XMLSchemaSchema schema = ((XMLSchemaGrammar) schemaGrammar).getByNamespace(attributeURI);\n                            if (schema != null) {\n                                attributeExpression = schema.attributeDecls.get(attributeName);\n                            } else {\n                                attributeExpression = null;\n                            }\n                        }\n                        if (attributeExpression != null) {\n                            // TODO: find out way of validating an attribute only\n\n//                            final ExpressionAcceptor expressionAcceptor = new SimpleAcceptor(documentDeclaration, attributeExpression, null, null);\n//                            // Validate attribute value\n//                            final StringRef errorStringRef = new StringRef();\n//                            final DatatypeRef datatypeRef = new DatatypeRef();\n//\n//                            if (!expressionAcceptor.onAttribute2(attributeURI, attributeName, attributeQName, attributeValue, validationContext, errorStringRef, datatypeRef)) {\n//                                if (errorStringRef.str == null) // not sure if this can happen\n//                                    errorStringRef.str = \"Error validating attribute\";\n//                                addSchemaError(attribute, errorStringRef.str);\n//                            }\n\n//                            if (!expressionAcceptor.onText2(attributeValue, validationContext, errorStringRef, datatypeRef)) {\n//                                if (errorStringRef.str == null) // not sure if this can happen\n//                                    errorStringRef.str = \"Error validating attribute\";\n//                                addSchemaError(attribute, errorStringRef.str);\n//                            }\n//\n//                            // Check final acceptor state\n//                            if (!expressionAcceptor.isAcceptState(errorStringRef)) {\n//                                if (errorStringRef.str == null) // not sure if this can happen\n//                                    errorStringRef.str = \"Error validating attribute\";\n//                                addSchemaError(attribute, errorStringRef.str);\n//                            }\n                        }\n                    }\n                }\n\n                // Validate children elements\n                for (final Iterator iterator = element.elementIterator(); iterator.hasNext();) {\n                    final Element childElement = (Element) iterator.next();\n                    validateElementLax(childElement);\n                }\n            }\n        }\n    }","commit_id":"cda49ca679cc07415a9c397ff2223f3f81e10eca","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"/**\n     * Checks whether the expression to be compiled is allowed\n     */\n    @Override\n    public boolean isAuthorized(Expression expression) {\n        if (expression instanceof MethodCallExpression) {\n            MethodCallExpression mce = (MethodCallExpression) expression;\n            if (methodBlacklist.contains(mce.getMethodAsString())) {\n                return false;\n            }\n        } else if (expression instanceof ConstructorCallExpression) {\n            ConstructorCallExpression cce = (ConstructorCallExpression) expression;\n            ClassNode type = cce.getType();\n            if (!packageWhitelist.contains(type.getPackageName())) {\n                return false;\n            }\n            if (!classWhitelist.contains(type.getName())) {\n                return false;\n            }\n        }\n        return true;\n    }","id":90465,"modified_method":"/**\n     * Checks whether the expression to be compiled is allowed\n     */\n    @Override\n    public boolean isAuthorized(Expression expression) {\n        if (expression instanceof MethodCallExpression) {\n            MethodCallExpression mce = (MethodCallExpression) expression;\n            String methodName = mce.getMethodAsString();\n            if (methodBlacklist.contains(methodName)) {\n                return false;\n            } else if (methodName == null && mce.getMethod() instanceof GStringExpression) {\n                // We do not allow GStrings for method invocation, they are a security risk\n                return false;\n            }\n        } else if (expression instanceof ConstructorCallExpression) {\n            ConstructorCallExpression cce = (ConstructorCallExpression) expression;\n            ClassNode type = cce.getType();\n            if (!packageWhitelist.contains(type.getPackageName())) {\n                return false;\n            }\n            if (!classWhitelist.contains(type.getName())) {\n                return false;\n            }\n        }\n        return true;\n    }","commit_id":"47856ec4cdbe5fdd33cc1927af832c130c4ae06b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testSandboxedGroovyScript() {\n        client().prepareIndex(\"test\", \"doc\", \"1\").setSource(\"foo\", 5).setRefresh(true).get();\n\n        // Plain test\n        testSuccess(\"\");\n        // List\n        testSuccess(\"def list = [doc['foo'].value, 3, 4]; def v = list.get(1); list.add(10)\");\n        // Ranges\n        testSuccess(\"def range = 1..doc['foo'].value; def v = range.get(0)\");\n        // Maps\n        testSuccess(\"def v = doc['foo'].value; def m = [:]; m.put(\\\\\\\"value\\\\\\\", v)\");\n        // Times\n        testSuccess(\"def t = Instant.now().getMillis()\");\n\n        // Fail cases\n        testFailure(\"pr = Runtime.getRuntime().exec(\\\\\\\"touch /tmp/gotcha\\\\\\\"); pr.waitFor()\",\n                \"Method calls not allowed on [java.lang.Runtime]\");\n\n        testFailure(\"d = new DateTime(); d.getClass().getDeclaredMethod(\\\\\\\"plus\\\\\\\").setAccessible(true)\",\n                \"Expression [MethodCallExpression] is not allowed: d.getClass()\");\n\n        testFailure(\"Class.forName(\\\\\\\"DateTime\\\\\\\").getDeclaredMethod(\\\\\\\"plus\\\\\\\").setAccessible(true)\",\n                \"Method calls not allowed on [java.lang.Class]\");\n\n        testFailure(\"Eval.me('2 + 2')\", \"Method calls not allowed on [groovy.util.Eval]\");\n\n        testFailure(\"Eval.x(5, 'x + 2')\", \"Method calls not allowed on [groovy.util.Eval]\");\n\n        testFailure(\"t = new java.util.concurrent.ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS, \" +\n                \"new java.util.concurrent.LinkedBlockingQueue<Runnable>()); t.execute({ println 5 })\",\n                \"Expression [ConstructorCallExpression] is not allowed: new java.util.concurrent.ThreadPoolExecutor\");\n\n        testFailure(\"d = new Date(); java.lang.reflect.Field f = Date.class.getDeclaredField(\\\\\\\"fastTime\\\\\\\");\" +\n                \" f.setAccessible(true); f.get(\\\\\\\"fastTime\\\\\\\")\",\n                \"Method calls not allowed on [java.lang.reflect.Field]\");\n\n        testFailure(\"t = new Thread({ println 3 }); t.start(); t.join()\",\n                \"Expression [ConstructorCallExpression] is not allowed: new java.lang.Thread\");\n\n        testFailure(\"Thread.start({ println 4 })\", \"Method calls not allowed on [java.lang.Thread]\");\n\n        testFailure(\"import java.util.concurrent.ThreadPoolExecutor;\",\n                \"Importing [java.util.concurrent.ThreadPoolExecutor] is not allowed\");\n\n        testFailure(\"s = new java.net.URL();\", \"Expression [ConstructorCallExpression] is not allowed: new java.net.URL()\");\n    }","id":90466,"modified_method":"@Test\n    public void testSandboxedGroovyScript() {\n        client().prepareIndex(\"test\", \"doc\", \"1\").setSource(\"foo\", 5).setRefresh(true).get();\n\n        // Plain test\n        testSuccess(\"\");\n        // List\n        testSuccess(\"def list = [doc['foo'].value, 3, 4]; def v = list.get(1); list.add(10)\");\n        // Ranges\n        testSuccess(\"def range = 1..doc['foo'].value; def v = range.get(0)\");\n        // Maps\n        testSuccess(\"def v = doc['foo'].value; def m = [:]; m.put(\\\\\\\"value\\\\\\\", v)\");\n        // Times\n        testSuccess(\"def t = Instant.now().getMillis()\");\n\n        // Fail cases\n        testFailure(\"pr = Runtime.getRuntime().exec(\\\\\\\"touch /tmp/gotcha\\\\\\\"); pr.waitFor()\",\n                \"Method calls not allowed on [java.lang.Runtime]\");\n\n        testFailure(\"d = new DateTime(); d.getClass().getDeclaredMethod(\\\\\\\"plus\\\\\\\").setAccessible(true)\",\n                \"Expression [MethodCallExpression] is not allowed: d.getClass()\");\n\n        testFailure(\"d = new DateTime(); d.\\\\\\\"${'get' + 'Class'}\\\\\\\"().\" +\n                        \"\\\\\\\"${'getDeclared' + 'Method'}\\\\\\\"(\\\\\\\"now\\\\\\\").\\\\\\\"${'set' + 'Accessible'}\\\\\\\"(false)\",\n                \"Expression [MethodCallExpression] is not allowed: d.$(get + Class)().$(getDeclared + Method)(now).$(set + Accessible)(false)\");\n\n        testFailure(\"Class.forName(\\\\\\\"DateTime\\\\\\\").getDeclaredMethod(\\\\\\\"plus\\\\\\\").setAccessible(true)\",\n                \"Method calls not allowed on [java.lang.Class]\");\n\n        testFailure(\"Eval.me('2 + 2')\", \"Method calls not allowed on [groovy.util.Eval]\");\n\n        testFailure(\"Eval.x(5, 'x + 2')\", \"Method calls not allowed on [groovy.util.Eval]\");\n\n        testFailure(\"t = new java.util.concurrent.ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS, \" +\n                \"new java.util.concurrent.LinkedBlockingQueue<Runnable>()); t.execute({ println 5 })\",\n                \"Expression [ConstructorCallExpression] is not allowed: new java.util.concurrent.ThreadPoolExecutor\");\n\n        testFailure(\"d = new Date(); java.lang.reflect.Field f = Date.class.getDeclaredField(\\\\\\\"fastTime\\\\\\\");\" +\n                \" f.setAccessible(true); f.get(\\\\\\\"fastTime\\\\\\\")\",\n                \"Method calls not allowed on [java.lang.reflect.Field]\");\n\n        testFailure(\"t = new Thread({ println 3 }); t.start(); t.join()\",\n                \"Expression [ConstructorCallExpression] is not allowed: new java.lang.Thread\");\n\n        testFailure(\"Thread.start({ println 4 })\", \"Method calls not allowed on [java.lang.Thread]\");\n\n        testFailure(\"import java.util.concurrent.ThreadPoolExecutor;\",\n                \"Importing [java.util.concurrent.ThreadPoolExecutor] is not allowed\");\n\n        testFailure(\"s = new java.net.URL();\", \"Expression [ConstructorCallExpression] is not allowed: new java.net.URL()\");\n\n        testFailure(\"def methodName = 'ex'; Runtime.\\\\\\\"${'get' + 'Runtime'}\\\\\\\"().\\\\\\\"${methodName}ec\\\\\\\"(\\\\\\\"touch /tmp/gotcha2\\\\\\\")\",\n                \"Expression [MethodCallExpression] is not allowed: java.lang.Runtime.$(get + Runtime)().$methodNameec(touch /tmp/gotcha2)\");\n    }","commit_id":"47856ec4cdbe5fdd33cc1927af832c130c4ae06b","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void visitMethodCallExpression(MethodCallExpression call) {\n            super.visitMethodCallExpression(call);\n            if (call.getMethodAsString()==null) {\n                addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            } else {\n                ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()), classNode);\n                MethodNode mn = findMethodOrFail(call, getType(call.getObjectExpression(), classNode), call.getMethodAsString(), args);\n                if (mn==null) return;\n                storeType(call, mn.getReturnType());\n            }\n        }","id":90467,"modified_method":"@Override\n        public void visitMethodCallExpression(MethodCallExpression call) {\n            super.visitMethodCallExpression(call);\n            final String name = call.getMethodAsString();\n            if (name==null) {\n                addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            } else {\n                ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()), classNode);\n                final Expression objectExpression = call.getObjectExpression();\n                final ClassNode receiver = getType(objectExpression, classNode);\n                MethodNode mn = findMethod(call, receiver, name, args);\n                if (mn==null) {\n                    if (objectExpression instanceof VariableExpression) {\n                        VariableExpression variableExpression = (VariableExpression) objectExpression;\n                        if (!temporaryIfBranchTypeInformation.isEmpty()) {\n                            final Map<Expression, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                            List<ClassNode> potentialReceiverType = tempo.get(findTargetVariable(variableExpression));\n                            if (potentialReceiverType!=null) {\n                                for (ClassNode potentialReceiver : potentialReceiverType) {\n                                    mn = findMethod(call, potentialReceiver, name, args);\n                                    if (mn!=null) break;\n                                }\n                            }\n                        }\n                    }\n                    if (mn==null) {\n                        addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                        return;\n                    }\n                }\n                storeType(call, mn.getReturnType());\n            }\n        }","commit_id":"a853335cb0bffa50a3e17cfee66f9292807754ac","url":"https://github.com/apache/groovy"},{"original_method":"private MethodNode findMethodOrFail(\n                Expression expr,\n                ClassNode receiver, String name, ClassNode... args)\n        {\n            List<MethodNode> methods;\n            if (\"<init>\".equals(name)) {\n                methods = new ArrayList<MethodNode>(receiver.getDeclaredConstructors());\n                if (methods.isEmpty()) {\n                    return new MethodNode(\"<init>\", Opcodes.ACC_PUBLIC, receiver, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n                }\n            } else {\n                methods = receiver.getMethods(name);\n            }\n            Set<MethodNode> fromDGM = findDGMMethodsForClassNode(receiver);\n\n            for (MethodNode methodNode : fromDGM) {\n                if (methodNode.getName().equals(name)) methods.add(methodNode);\n            }\n\n            for (MethodNode m : methods) {\n                // we return the first method that may match\n                // we don't need the exact match here for now\n\n                // todo : corner case\n                /*\n                    class B extends A {}\n\n                    Animal foo(A o) {...}\n                    Person foo(B i){...}\n\n                    B  a = new B()\n                    Person p = foo(b)\n                 */\n\n                Parameter[] params = m.getParameters();\n                if (params.length == args.length) {\n                    if (    allParametersAndArgumentsMatch(params,args) ||\n                            lastArgMatchesVarg(params,args))\n                    {\n                        return m;\n                    }\n                } else if (isVargs(params)) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length+1) return m;\n                    // (2) last argument is put in the vargs array\n                    //      that case is handled above already\n                    // (3) there is more than one argument for the vargs array\n                    if (    params.length < args.length &&\n                            excessArgumentsMatchesVargsParameter(params,args))\n                    {\n                        return m;\n                    }\n                }\n            }\n            if (receiver==ClassHelper.GSTRING_TYPE) return findMethodOrFail(expr, ClassHelper.STRING_TYPE, name, args);\n            addStaticTypeError(\"Cannot find matching method \"+receiver.getName()+\"#\" + toMethodParametersString(name, args), expr);\n            return null;\n        }","id":90468,"modified_method":"private MethodNode findMethodOrFail(\n                Expression expr,\n                ClassNode receiver, String name, ClassNode... args) {\n            final MethodNode method = findMethod(expr, receiver, name, args);\n            if (method ==null) {\n                addStaticTypeError(\"Cannot find matching method \"+receiver.getName()+\"#\" + toMethodParametersString(name, args), expr);\n            }\n            return method;\n        }","commit_id":"a853335cb0bffa50a3e17cfee66f9292807754ac","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            }\n        }","id":90469,"modified_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                Expression left = expression.getLeftExpression();\n                if (left instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    final Map<Expression, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                    VariableExpression target = findTargetVariable((VariableExpression) left);\n                    List<ClassNode> potentialTypes = tempo.get(target);\n                    if (potentialTypes==null) {\n                        potentialTypes = new LinkedList<ClassNode>();\n                        tempo.put(target, potentialTypes);\n                    }\n                    potentialTypes.add(rightExpression.getType());\n                }\n            }\n        }","commit_id":"a853335cb0bffa50a3e17cfee66f9292807754ac","url":"https://github.com/apache/groovy"},{"original_method":"public Visitor(SourceUnit source, ClassNode cn){\n            this.source = source;\n            this.classNode = cn;\n        }","id":90470,"modified_method":"public Visitor(SourceUnit source, ClassNode cn){\n            this.source = source;\n            this.classNode = cn;\n            this.temporaryIfBranchTypeInformation  = new Stack<Map<Expression, List<ClassNode>>>();\n            pushTemporaryTypeInfo();\n        }","commit_id":"a853335cb0bffa50a3e17cfee66f9292807754ac","url":"https://github.com/apache/groovy"},{"original_method":"private MethodNode findMethodOrFail(\n                Expression expr,\n                ClassNode receiver, String name, ClassNode... args)\n        {\n            List<MethodNode> methods;\n            if (\"<init>\".equals(name)) {\n                methods = new ArrayList<MethodNode>(receiver.getDeclaredConstructors());\n                if (methods.isEmpty()) {\n                    return new MethodNode(\"<init>\", Opcodes.ACC_PUBLIC, receiver, Parameter.EMPTY_ARRAY, ClassNode.EMPTY_ARRAY, EmptyStatement.INSTANCE);\n                }\n            } else {\n                methods = receiver.getMethods(name);\n            }\n            Set<MethodNode> fromDGM = findDGMMethodsForClassNode(receiver);\n\n            for (MethodNode methodNode : fromDGM) {\n                if (methodNode.getName().equals(name)) methods.add(methodNode);\n            }\n\n            for (MethodNode m : methods) {\n                // we return the first method that may match\n                // we don't need the exact match here for now\n\n                // todo : corner case\n                /*\n                    class B extends A {}\n\n                    Animal foo(A o) {...}\n                    Person foo(B i){...}\n\n                    B  a = new B()\n                    Person p = foo(b)\n                 */\n\n                Parameter[] params = m.getParameters();\n                if (params.length == args.length) {\n                    if (    allParametersAndArgumentsMatch(params,args) ||\n                            lastArgMatchesVarg(params,args))\n                    {\n                        return m;\n                    }\n                } else if (isVargs(params)) {\n                    // there are three case for vargs\n                    // (1) varg part is left out\n                    if (params.length == args.length+1) return m;\n                    // (2) last argument is put in the vargs array\n                    //      that case is handled above already\n                    // (3) there is more than one argument for the vargs array\n                    if (    params.length < args.length &&\n                            excessArgumentsMatchesVargsParameter(params,args))\n                    {\n                        return m;\n                    }\n                }\n            }\n            if (receiver==ClassHelper.GSTRING_TYPE) return findMethodOrFail(expr, ClassHelper.STRING_TYPE, name, args);\n            addStaticTypeError(\"Cannot find matching method \"+receiver.getName()+\"#\" + toMethodParametersString(name, args), expr);\n            return null;\n        }","id":90471,"modified_method":"private MethodNode findMethodOrFail(\n                Expression expr,\n                ClassNode receiver, String name, ClassNode... args) {\n            final MethodNode method = findMethod(expr, receiver, name, args);\n            if (method ==null) {\n                addStaticTypeError(\"Cannot find matching method \"+receiver.getName()+\"#\" + toMethodParametersString(name, args), expr);\n            }\n            return method;\n        }","commit_id":"09a367d2002927bd281a67afef577668be672ac3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            }\n        }","id":90472,"modified_method":"@Override\n        public void visitBinaryExpression(BinaryExpression expression) {\n            super.visitBinaryExpression(expression);\n            ClassNode lType = getType(expression.getLeftExpression(), classNode);\n            final Expression rightExpression = expression.getRightExpression();\n            ClassNode rType = getType(rightExpression, classNode);\n            int op = expression.getOperation().getType();\n            ClassNode resultType = getResultType(lType, op, rType, expression);\n            if (resultType==null) {\n                addStaticTypeError(\"tbd...\", expression);\n                resultType = lType;\n            }\n            // todo : if assignment of a primitive to an object (def, Object, whatever),\n            // the type inference engine should return an Object (not a primitive type)\n            storeType(expression, resultType);\n            if (isAssignment(op)) {\n                ClassNode leftRedirect;\n                if (isArrayAccessExpression(expression.getLeftExpression())) {\n                    // in case the left expression is in the form of an array access, we should use\n                    // the inferred type instead of the left expression type\n                    leftRedirect = lType;\n                }\n                else {\n                    leftRedirect = expression.getLeftExpression().getType().redirect();\n                }\n                final boolean compatible = checkCompatibleAssignmentTypes(leftRedirect, resultType);\n                if (!compatible) {\n                    addStaticTypeError(\"Cannot assign value of type \" + resultType + \" to variable of type \" + lType, expression);\n                } else {\n                    // if left type is array, we should check the right component types\n                    if (lType.isArray()) {\n                        ClassNode leftComponentType = lType.getComponentType();\n                        ClassNode rightRedirect = rightExpression.getType().redirect();\n                        if (rightRedirect.isArray()) {\n                            ClassNode rightComponentType = rightRedirect.getComponentType();\n                            if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                            }\n                        } else if (rightExpression instanceof ListExpression) {\n                            for (Expression element : ((ListExpression) rightExpression).getExpressions()) {\n                                ClassNode rightComponentType = element.getType().redirect();\n                                if (!checkCompatibleAssignmentTypes(leftComponentType, rightComponentType)) {\n                                    addStaticTypeError(\"Cannot assign value of type \" + rightComponentType + \" into array of type \" + lType, expression);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                storeType(expression.getLeftExpression(), resultType);\n            } else if (op==KEYWORD_INSTANCEOF) {\n                Expression left = expression.getLeftExpression();\n                if (left instanceof VariableExpression && rightExpression instanceof ClassExpression) {\n                    final Map<Expression, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                    VariableExpression target = findTargetVariable((VariableExpression) left);\n                    List<ClassNode> potentialTypes = tempo.get(target);\n                    if (potentialTypes==null) {\n                        potentialTypes = new LinkedList<ClassNode>();\n                        tempo.put(target, potentialTypes);\n                    }\n                    potentialTypes.add(rightExpression.getType());\n                }\n            }\n        }","commit_id":"09a367d2002927bd281a67afef577668be672ac3","url":"https://github.com/apache/groovy"},{"original_method":"public Visitor(SourceUnit source, ClassNode cn){\n            this.source = source;\n            this.classNode = cn;\n        }","id":90473,"modified_method":"public Visitor(SourceUnit source, ClassNode cn){\n            this.source = source;\n            this.classNode = cn;\n            this.temporaryIfBranchTypeInformation  = new Stack<Map<Expression, List<ClassNode>>>();\n            pushTemporaryTypeInfo();\n        }","commit_id":"09a367d2002927bd281a67afef577668be672ac3","url":"https://github.com/apache/groovy"},{"original_method":"@Override\n        public void visitMethodCallExpression(MethodCallExpression call) {\n            super.visitMethodCallExpression(call);\n            if (call.getMethodAsString()==null) {\n                addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            } else {\n                ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()), classNode);\n                MethodNode mn = findMethodOrFail(call, getType(call.getObjectExpression(), classNode), call.getMethodAsString(), args);\n                if (mn==null) return;\n                storeType(call, mn.getReturnType());\n            }\n        }","id":90474,"modified_method":"@Override\n        public void visitMethodCallExpression(MethodCallExpression call) {\n            super.visitMethodCallExpression(call);\n            final String name = call.getMethodAsString();\n            if (name==null) {\n                addStaticTypeError(\"cannot resolve dynamic method name at compile time.\", call.getMethod());\n            } else {\n                ClassNode[] args = getArgumentTypes(InvocationWriter.makeArgumentList(call.getArguments()), classNode);\n                final Expression objectExpression = call.getObjectExpression();\n                final ClassNode receiver = getType(objectExpression, classNode);\n                MethodNode mn = findMethod(call, receiver, name, args);\n                if (mn==null) {\n                    if (objectExpression instanceof VariableExpression) {\n                        VariableExpression variableExpression = (VariableExpression) objectExpression;\n                        if (!temporaryIfBranchTypeInformation.isEmpty()) {\n                            final Map<Expression, List<ClassNode>> tempo = temporaryIfBranchTypeInformation.peek();\n                            List<ClassNode> potentialReceiverType = tempo.get(findTargetVariable(variableExpression));\n                            if (potentialReceiverType!=null) {\n                                for (ClassNode potentialReceiver : potentialReceiverType) {\n                                    mn = findMethod(call, potentialReceiver, name, args);\n                                    if (mn!=null) break;\n                                }\n                            }\n                        }\n                    }\n                    if (mn==null) {\n                        addStaticTypeError(\"Cannot find matching method \" + receiver.getName() + \"#\" + toMethodParametersString(name, args), call);\n                        return;\n                    }\n                }\n                storeType(call, mn.getReturnType());\n            }\n        }","commit_id":"09a367d2002927bd281a67afef577668be672ac3","url":"https://github.com/apache/groovy"},{"original_method":"private static boolean isNewEditor() {\n\t    // 2.8 and later are new editor calling \n\n\t    String sakaiVersion = ServerConfigurationService.getString(\"version.sakai\", \"2.6\");\n\n\t    boolean isNew = false;\n\t    int cle = 2;\n\t    int major = 6;\n\t    int minor = 0;\n\t    if (sakaiVersion != null) {\n\t\tString []parts = sakaiVersion.split(\"\\\\.\");\n\t\tif (parts.length >= 1) {\n\t\t    try {\n\t\t\tcle = Integer.parseInt(parts[0]);\n\t\t    } catch (Exception e) {\n\t\t    };\n\t\t}\n\t\tif (parts.length >= 2) {\n\t\t    try {\n\t\t\tmajor = Integer.parseInt(parts[1]);\n\t\t    } catch (Exception e) {\n\t\t    };\n\t\t}\n\t\t// may be something like 2.8.1-foo, so must terminate on non-digit\n\t\tif (parts.length >= 3) {\n\t\t    try {\n\t\t\tString[] s = parts[2].split(\"\\\\D\");\n\t\t\tminor = Integer.parseInt(s[0]);\n\t\t    } catch (Exception e) {\n\t\t    };\n\t\t}\n\n\t\t//System.out.println(\"EditPage thinks CLE is \" + cle + \" major \" + major);\n\n\t\t// samigo starting with 2.8.0 has the new editor calling protocol\n\t\tif (cle == 2 && major >= 8)\n\t\t    isNew = true;\n\n\t    }\n\t    //System.out.println(\"isnew \" + isNew);\n\t    return isNew;\n\t}","id":90475,"modified_method":"private static boolean isNewEditor() {\n\t    // 2.8 and later are new editor calling \n\n\t    String sakaiVersion = ServerConfigurationService.getString(\"version.sakai\", \"2.6\");\n\n\t    boolean isNew = false;\n\t    int cle = 2;\n\t    int major = 6;\n\t    int minor = 0;\n\t    if (sakaiVersion != null) {\n\t\tString []parts = sakaiVersion.split(\"\\\\.\");\n\t\tif (parts.length >= 1) {\n\t\t    try {\n\t\t\tcle = Integer.parseInt(parts[0]);\n\t\t    } catch (Exception e) {\n\t\t    };\n\t\t}\n\t\tif (parts.length >= 2) {\n\t\t    try {\n\t\t\tString[] s = parts[1].split(\"\\\\D\");\n\t\t\tmajor = Integer.parseInt(s[0]);\n\t\t    } catch (Exception e) {\n\t\t    };\n\t\t}\n\t\t// may be something like 2.8.1-foo, so must terminate on non-digit\n\t\tif (parts.length >= 3) {\n\t\t    try {\n\t\t\tString[] s = parts[2].split(\"\\\\D\");\n\t\t\tminor = Integer.parseInt(s[0]);\n\t\t    } catch (Exception e) {\n\t\t    };\n\t\t}\n\n\t\t// samigo starting with 2.8.0 has the new editor calling protocol\n\t\tif (cle > 2 || (cle == 2 && major >= 8))\n\t\t    isNew = true;\n\t\tSystem.out.println(\"EditPage thinks CLE is \" + cle + \" major \" + major + \" isNew=\" + isNew);\n\t    }\n\t    //System.out.println(\"isnew \" + isNew);\n\t    return isNew;\n\t}","commit_id":"43aee63ada2283dff52ae6d04ae2ddca52d42014","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void init () {\n\tassessmentCache = memoryService\n\t    .newCache(\"org.sakaiproject.lessonbuildertool.service.SamigoEntity.cache\");\n\tString sakaiVersion = ServerConfigurationService.getString(\"version.sakai\", \"2.6\");\n\n\t// the samigo distributed with 2.8 final has the link\n\tboolean defaultEditLink = false;\n\tint cle = 2;\n\tint major = 6;\n\tint minor = 0;\n\tif (sakaiVersion != null) {\n\t    String []parts = sakaiVersion.split(\"\\\\.\");\n\t    if (parts.length >= 1) {\n\t\ttry {\n\t\t    cle = Integer.parseInt(parts[0]);\n\t\t} catch (Exception e) {\n\t\t};\n\t    }\n\t    if (parts.length >= 2) {\n\t\ttry {\n\t\t    major = Integer.parseInt(parts[1]);\n\t\t} catch (Exception e) {\n\t\t};\n\t    }\n\t    // may be something like 2.8.1-foo, so must terminate on non-digit\n\t    if (parts.length >= 3) {\n\t\ttry {\n\t\t    String[] s = parts[2].split(\"\\\\D\");\n\t\t    minor = Integer.parseInt(s[0]);\n\t\t} catch (Exception e) {\n\t\t};\n\t    }\n\t    // samigo starting with 2.8.1 has the edit link\n\t    if (cle == 2 && (major == 8 && minor > 0 || major > 8))\n\t\tdefaultEditLink = true;\n\t}\n\tSystem.out.println(\"SamigoEntity thinks this is Sakai verison \" + cle + \".\" + major + \".\" + minor + \", defaulting Samigo edit link to \" + defaultEditLink);\n\n\tsamigo_linked = ServerConfigurationService.getBoolean(\"lessonbuilder.samigo.editlink\", defaultEditLink);\n\n\tlog.info(\"init()\");\n\n    }","id":90476,"modified_method":"public void init () {\n\tassessmentCache = memoryService\n\t    .newCache(\"org.sakaiproject.lessonbuildertool.service.SamigoEntity.cache\");\n\tString sakaiVersion = ServerConfigurationService.getString(\"version.sakai\", \"2.6\");\n\n\t// the samigo distributed with 2.8 final has the link\n\tboolean defaultEditLink = false;\n\tint cle = 2;\n\tint major = 6;\n\tint minor = 0;\n\tif (sakaiVersion != null) {\n\t    String []parts = sakaiVersion.split(\"\\\\.\");\n\t    if (parts.length >= 1) {\n\t\ttry {\n\t\t    cle = Integer.parseInt(parts[0]);\n\t\t} catch (Exception e) {\n\t\t};\n\t    }\n\t    if (parts.length >= 2) {\n\t\ttry {\n\t\t    String[] s = parts[1].split(\"\\\\D\");\n\t\t    major = Integer.parseInt(s[0]);\n\t\t} catch (Exception e) {\n\t\t};\n\t    }\n\t    // may be something like 2.8.1-foo, so must terminate on non-digit\n\t    if (parts.length >= 3) {\n\t\ttry {\n\t\t    String[] s = parts[2].split(\"\\\\D\");\n\t\t    minor = Integer.parseInt(s[0]);\n\t\t} catch (Exception e) {\n\t\t};\n\t    }\n\t    // samigo starting with 2.8.1 has the edit link\n\t    if (cle > 2 || (cle == 2 && (major == 8 && minor > 0 || major > 8)))\n\t\tdefaultEditLink = true;\n\t}\n\tSystem.out.println(\"SamigoEntity thinks this is Sakai verison \" + cle + \".\" + major + \".\" + minor + \", defaulting Samigo edit link to \" + defaultEditLink);\n\n\tsamigo_linked = ServerConfigurationService.getBoolean(\"lessonbuilder.samigo.editlink\", defaultEditLink);\n\n\tlog.info(\"init()\");\n\n    }","commit_id":"43aee63ada2283dff52ae6d04ae2ddca52d42014","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void startElementLine(String qName, Attributes atts, LineElemStyle line) {\n        for (int count=0; count<atts.getLength(); count++)\n        {\n            if(atts.getQName(count).equals(\"width\"))\n            {\n                String val = atts.getValue(count);\n                if(val.startsWith(\"+\"))\n                {\n                    line.width = Integer.parseInt(val.substring(1));\n                    line.widthMode = LineElemStyle.WidthMode.OFFSET;\n                }\n                else if(val.startsWith(\"-\"))\n                {\n                    line.width = Integer.parseInt(val);\n                    line.widthMode = LineElemStyle.WidthMode.OFFSET;\n                }\n                else if(val.endsWith(\"%\"))\n                {\n                    line.width = Integer.parseInt(val.substring(0, val.length()-1));\n                    line.widthMode = LineElemStyle.WidthMode.PERCENT;\n                }\n                else\n                    line.width = Integer.parseInt(val);\n            }\n            else if (atts.getQName(count).equals(\"colour\"))\n                line.color=convertColor(atts.getValue(count));\n            else if (atts.getQName(count).equals(\"realwidth\"))\n                line.realWidth=Integer.parseInt(atts.getValue(count));\n            else if (atts.getQName(count).equals(\"dashed\")) {\n                try\n                {\n                    line.dashed=Integer.parseInt(atts.getValue(count));\n                } catch (NumberFormatException nfe) {\n                    boolean dashed=Boolean.parseBoolean(atts.getValue(count));\n                    if(dashed) {\n                        line.dashed = 9;\n                    }\n                }\n            } else if (atts.getQName(count).equals(\"dashedcolour\"))\n                line.dashedColor=convertColor(atts.getValue(count));\n            else if(atts.getQName(count).equals(\"priority\"))\n                line.priority = Integer.parseInt(atts.getValue(count));\n            else if(atts.getQName(count).equals(\"mode\"))\n                line.over = !atts.getValue(count).equals(\"under\");\n            else\n                error(\"The element \\\"\" + qName + \"\\\" has unknown attribute \\\"\" + atts.getQName(count) + \"\\\"!\");\n        }\n    }","id":90477,"modified_method":"private void startElementLine(String qName, Attributes atts, LineElemStyle line) {\n        for (int count=0; count<atts.getLength(); count++)\n        {\n            if(atts.getQName(count).equals(\"width\"))\n            {\n                String val = atts.getValue(count);\n                if(val.startsWith(\"+\"))\n                {\n                    line.width = Integer.parseInt(val.substring(1));\n                    line.widthMode = LineElemStyle.WidthMode.OFFSET;\n                }\n                else if(val.startsWith(\"-\"))\n                {\n                    line.width = Integer.parseInt(val);\n                    line.widthMode = LineElemStyle.WidthMode.OFFSET;\n                }\n                else if(val.endsWith(\"%\"))\n                {\n                    line.width = Integer.parseInt(val.substring(0, val.length()-1));\n                    line.widthMode = LineElemStyle.WidthMode.PERCENT;\n                }\n                else\n                    line.width = Integer.parseInt(val);\n            }\n            else if (atts.getQName(count).equals(\"colour\"))\n                line.color=convertColor(atts.getValue(count));\n            else if (atts.getQName(count).equals(\"realwidth\"))\n                line.realWidth=Integer.parseInt(atts.getValue(count));\n            else if (atts.getQName(count).equals(\"dashed\")) {\n                try\n                {\n                    String[] parts = atts.getValue(count).split(\",\");\n                    line.dashed = new float[parts.length];\n                    for (int i = 0; i < parts.length; i++) {\n                        line.dashed[i] = (float)(Integer.parseInt(parts[i]));\n                    }\n                } catch (NumberFormatException nfe) {\n                    boolean dashed=Boolean.parseBoolean(atts.getValue(count));\n                    if(dashed) {\n                        line.dashed = new float[]{9};\n                    }\n                }\n            } else if (atts.getQName(count).equals(\"dashedcolour\"))\n                line.dashedColor=convertColor(atts.getValue(count));\n            else if(atts.getQName(count).equals(\"priority\"))\n                line.priority = Integer.parseInt(atts.getValue(count));\n            else if(atts.getQName(count).equals(\"mode\"))\n                line.over = !atts.getValue(count).equals(\"under\");\n            else\n                error(\"The element \\\"\" + qName + \"\\\" has unknown attribute \\\"\" + atts.getQName(count) + \"\\\"!\");\n        }\n    }","commit_id":"6f25cc27ffb0f9605183a18ab536015417d5fa41","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void init()\n    {\n        width = 1;\n        realWidth = 0;\n        dashed = 0;\n        dashedColor = null;\n        priority = 0;\n        color = null;\n        over = true; // only used for line modifications\n        widthMode = WidthMode.ABSOLUTE;\n        overlays = null;\n    }","id":90478,"modified_method":"public void init()\n    {\n        width = 1;\n        realWidth = 0;\n        dashed = new float[0];\n        dashedColor = null;\n        priority = 0;\n        color = null;\n        over = true; // only used for line modifications\n        widthMode = WidthMode.ABSOLUTE;\n        overlays = null;\n    }","commit_id":"6f25cc27ffb0f9605183a18ab536015417d5fa41","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void displaySegments(Color newColor, int newWidth, int newDash, Color newDashedColor) {\n        if (currentPath != null) {\n            Graphics2D g2d = (Graphics2D)g;\n            g2d.setColor(inactive ? inactiveColor : currentColor);\n            if (currentStroke == null && useStrokes > dist) {\n                if (currentDashed != 0)\n                    g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_BUTT,BasicStroke.JOIN_ROUND,0,new float[] {currentDashed},0));\n                else\n                    g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND));\n            }\n            g2d.draw(currentPath);\n\n            if(currentDashedColor != null) {\n                g2d.setColor(currentDashedColor);\n                if (currentStroke == null && useStrokes > dist) {\n                    if (currentDashed != 0)\n                        g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_BUTT,BasicStroke.JOIN_ROUND,0,new float[] {currentDashed},currentDashed));\n                    else\n                        g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND));\n                }\n                g2d.draw(currentPath);\n            }\n\n            if(useStrokes > dist)\n                g2d.setStroke(new BasicStroke(1));\n\n            currentPath = new GeneralPath();\n            currentColor = newColor;\n            currentWidth = newWidth;\n            currentDashed = newDash;\n            currentDashedColor = newDashedColor;\n            currentStroke = null;\n        }\n    }","id":90479,"modified_method":"protected void displaySegments(Color newColor, int newWidth, float newDash[], Color newDashedColor) {\n        if (currentPath != null) {\n            Graphics2D g2d = (Graphics2D)g;\n            g2d.setColor(inactive ? inactiveColor : currentColor);\n            if (currentStroke == null && useStrokes > dist) {\n                if (currentDashed.length > 0) {\n                    try {\n                        g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_BUTT,BasicStroke.JOIN_ROUND,0,currentDashed,0));\n                    } catch (IllegalArgumentException e) {\n                        g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND));\n                    }\n                }\n                else\n                    g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND));\n            }\n            g2d.draw(currentPath);\n\n            if(currentDashedColor != null) {\n                g2d.setColor(currentDashedColor);\n                if (currentStroke == null && useStrokes > dist) {\n                    if (currentDashed.length > 0) {\n                        float[] currentDashedOffset = new float[currentDashed.length];\n                        System.arraycopy(currentDashed, 1, currentDashedOffset, 0, currentDashed.length - 1);\n                        currentDashedOffset[currentDashed.length-1] = currentDashed[0];\n                        float offset = currentDashedOffset[0];\n                        try {\n                            g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_BUTT,BasicStroke.JOIN_ROUND,0,currentDashedOffset,offset));\n                        } catch (IllegalArgumentException e) {\n                            g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND));\n                        }\n                    }\n                    else\n                        g2d.setStroke(new BasicStroke(currentWidth,BasicStroke.CAP_ROUND,BasicStroke.JOIN_ROUND));\n                }\n                g2d.draw(currentPath);\n            }\n\n            if(useStrokes > dist)\n                g2d.setStroke(new BasicStroke(1));\n\n            currentPath = new GeneralPath();\n            currentColor = newColor;\n            currentWidth = newWidth;\n            currentDashed = newDash;\n            currentDashedColor = newDashedColor;\n            currentStroke = null;\n        }\n    }","commit_id":"6f25cc27ffb0f9605183a18ab536015417d5fa41","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void drawWay(Way w, LineElemStyle l, Color color, Boolean selected) {\n        /* show direction arrows, if draw.segment.relevant_directions_only is not set,\n           the way is tagged with a direction key\n           (even if the tag is negated as in oneway=false) or the way is selected */\n        boolean showDirection = w.selected || ((!useRealWidth) && (showDirectionArrow\n        && (!showRelevantDirectionsOnly || w.hasDirectionKeys())));\n        /* head only takes over control if the option is true,\n           the direction should be shown at all and not only because it's selected */\n        boolean showOnlyHeadArrowOnly = showDirection && !w.selected && showHeadArrowOnly;\n        int width = defaultSegmentWidth;\n        int realWidth = 0; /* the real width of the element in meters */\n        int dashed = 0;\n        Color dashedColor = null;\n        Node lastN;\n\n        if(l != null)\n        {\n            if (l.color != null) color = l.color;\n            width = l.width;\n            realWidth = l.realWidth;\n            dashed = l.dashed;\n            dashedColor = l.dashedColor;\n        }\n        if(selected)\n            color = selectedColor;\n        if (realWidth > 0 && useRealWidth && !showDirection)\n        {\n            int tmpWidth = (int) (100 /  (float) (circum / realWidth));\n            if (tmpWidth > width) width = tmpWidth;\n            \n            /* if we have a \"width\" tag, try use it */\n            /* (this might be slow and could be improved by caching the value in the Way, on the other hand only used if \"real width\" is enabled) */\n            String widthTag = w.get(\"width\");\n            if(widthTag == null) {\n                widthTag = w.get(\"est_width\");\n            }\n            if(widthTag != null) {\n                try {\n                    width = Integer.parseInt(widthTag);\n                }\n                catch(NumberFormatException nfe) {\n                }\n            }\n        }\n\n        if(w.highlighted)\n            color = highlightColor;\n        else if(w.selected)\n            color = selectedColor;\n\n        /* draw overlays under the way */\n        if(l != null && l.overlays != null)\n        {\n            for(LineElemStyle s : l.overlays)\n            {\n                if(!s.over)\n                {\n                    lastN = null;\n                    for(Node n : w.nodes)\n                    {\n                        if(lastN != null)\n                        {\n                            drawSeg(lastN, n, s.color != null  && !w.selected ? s.color : color,\n                            false, s.getWidth(width), s.dashed, s.dashedColor);\n                        }\n                        lastN = n;\n                    }\n                }\n            }\n        }\n\n        /* draw the way */\n        lastN = null;\n        Iterator<Node> it = w.nodes.iterator();\n        while (it.hasNext())\n        {\n            Node n = it.next();\n            if(lastN != null)\n                drawSeg(lastN, n, color,\n                    showOnlyHeadArrowOnly ? !it.hasNext() : showDirection, width, dashed, dashedColor);\n            lastN = n;\n        }\n\n        /* draw overlays above the way */\n        if(l != null && l.overlays != null)\n        {\n            for(LineElemStyle s : l.overlays)\n            {\n                if(s.over)\n                {\n                    lastN = null;\n                    for(Node n : w.nodes)\n                    {\n                        if(lastN != null)\n                        {\n                            drawSeg(lastN, n, s.color != null && !w.selected ? s.color : color,\n                            false, s.getWidth(width), s.dashed, s.dashedColor);\n                        }\n                        lastN = n;\n                    }\n                }\n            }\n        }\n\n        if(showOrderNumber)\n        {\n            int orderNumber = 0;\n            lastN = null;\n            for(Node n : w.nodes)\n            {\n                if(lastN != null)\n                {\n                    orderNumber++;\n                    drawOrderNumber(lastN, n, orderNumber);\n                }\n                lastN = n;\n            }\n        }\n        displaySegments();\n    }","id":90480,"modified_method":"public void drawWay(Way w, LineElemStyle l, Color color, Boolean selected) {\n        /* show direction arrows, if draw.segment.relevant_directions_only is not set,\n           the way is tagged with a direction key\n           (even if the tag is negated as in oneway=false) or the way is selected */\n        boolean showDirection = w.selected || ((!useRealWidth) && (showDirectionArrow\n        && (!showRelevantDirectionsOnly || w.hasDirectionKeys())));\n        /* head only takes over control if the option is true,\n           the direction should be shown at all and not only because it's selected */\n        boolean showOnlyHeadArrowOnly = showDirection && !w.selected && showHeadArrowOnly;\n        int width = defaultSegmentWidth;\n        int realWidth = 0; /* the real width of the element in meters */\n        float dashed[] = new float[0];\n        Color dashedColor = null;\n        Node lastN;\n\n        if(l != null)\n        {\n            if (l.color != null) color = l.color;\n            width = l.width;\n            realWidth = l.realWidth;\n            dashed = l.dashed;\n            dashedColor = l.dashedColor;\n        }\n        if(selected)\n            color = selectedColor;\n        if (realWidth > 0 && useRealWidth && !showDirection)\n        {\n            int tmpWidth = (int) (100 /  (float) (circum / realWidth));\n            if (tmpWidth > width) width = tmpWidth;\n            \n            /* if we have a \"width\" tag, try use it */\n            /* (this might be slow and could be improved by caching the value in the Way, on the other hand only used if \"real width\" is enabled) */\n            String widthTag = w.get(\"width\");\n            if(widthTag == null) {\n                widthTag = w.get(\"est_width\");\n            }\n            if(widthTag != null) {\n                try {\n                    width = Integer.parseInt(widthTag);\n                }\n                catch(NumberFormatException nfe) {\n                }\n            }\n        }\n\n        if(w.highlighted)\n            color = highlightColor;\n        else if(w.selected)\n            color = selectedColor;\n\n        /* draw overlays under the way */\n        if(l != null && l.overlays != null)\n        {\n            for(LineElemStyle s : l.overlays)\n            {\n                if(!s.over)\n                {\n                    lastN = null;\n                    for(Node n : w.nodes)\n                    {\n                        if(lastN != null)\n                        {\n                            drawSeg(lastN, n, s.color != null  && !w.selected ? s.color : color,\n                            false, s.getWidth(width), s.dashed, s.dashedColor);\n                        }\n                        lastN = n;\n                    }\n                }\n            }\n        }\n\n        /* draw the way */\n        lastN = null;\n        Iterator<Node> it = w.nodes.iterator();\n        while (it.hasNext())\n        {\n            Node n = it.next();\n            if(lastN != null)\n                drawSeg(lastN, n, color,\n                    showOnlyHeadArrowOnly ? !it.hasNext() : showDirection, width, dashed, dashedColor);\n            lastN = n;\n        }\n\n        /* draw overlays above the way */\n        if(l != null && l.overlays != null)\n        {\n            for(LineElemStyle s : l.overlays)\n            {\n                if(s.over)\n                {\n                    lastN = null;\n                    for(Node n : w.nodes)\n                    {\n                        if(lastN != null)\n                        {\n                            drawSeg(lastN, n, s.color != null && !w.selected ? s.color : color,\n                            false, s.getWidth(width), s.dashed, s.dashedColor);\n                        }\n                        lastN = n;\n                    }\n                }\n            }\n        }\n\n        if(showOrderNumber)\n        {\n            int orderNumber = 0;\n            lastN = null;\n            for(Node n : w.nodes)\n            {\n                if(lastN != null)\n                {\n                    orderNumber++;\n                    drawOrderNumber(lastN, n, orderNumber);\n                }\n                lastN = n;\n            }\n        }\n        displaySegments();\n    }","commit_id":"6f25cc27ffb0f9605183a18ab536015417d5fa41","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void displaySegments() {\n        displaySegments(null, 0, 0, null);\n    }","id":90481,"modified_method":"protected void displaySegments() {\n        displaySegments(null, 0, new float[0], null);\n    }","commit_id":"6f25cc27ffb0f9605183a18ab536015417d5fa41","url":"https://github.com/openstreetmap/josm"},{"original_method":"private void drawSeg(Node n1, Node n2, Color col, boolean showDirection, int width, int dashed, Color dashedColor) {\n        //profilerSegments++;\n        if (col != currentColor || width != currentWidth || dashed != currentDashed || dashedColor != currentDashedColor) {\n            displaySegments(col, width, dashed, dashedColor);\n        }\n        Point p1 = nc.getPoint(n1.eastNorth);\n        Point p2 = nc.getPoint(n2.eastNorth);\n\n        if (!isSegmentVisible(p1, p2)) {\n            return;\n        }\n        //profilerVisibleSegments++;\n        currentPath.moveTo(p1.x, p1.y);\n        currentPath.lineTo(p2.x, p2.y);\n\n        if (showDirection) {\n            double t = Math.atan2(p2.y-p1.y, p2.x-p1.x) + Math.PI;\n            currentPath.lineTo((int)(p2.x + 10*Math.cos(t-PHI)), (int)(p2.y + 10*Math.sin(t-PHI)));\n            currentPath.moveTo((int)(p2.x + 10*Math.cos(t+PHI)), (int)(p2.y + 10*Math.sin(t+PHI)));\n            currentPath.lineTo(p2.x, p2.y);\n        }\n    }","id":90482,"modified_method":"private void drawSeg(Node n1, Node n2, Color col, boolean showDirection, int width, float dashed[], Color dashedColor) {\n        //profilerSegments++;\n        if (col != currentColor || width != currentWidth || !Arrays.equals(dashed,currentDashed) || dashedColor != currentDashedColor) {\n            displaySegments(col, width, dashed, dashedColor);\n        }\n        Point p1 = nc.getPoint(n1.eastNorth);\n        Point p2 = nc.getPoint(n2.eastNorth);\n\n        if (!isSegmentVisible(p1, p2)) {\n            return;\n        }\n        //profilerVisibleSegments++;\n        currentPath.moveTo(p1.x, p1.y);\n        currentPath.lineTo(p2.x, p2.y);\n\n        if (showDirection) {\n            double t = Math.atan2(p2.y-p1.y, p2.x-p1.x) + Math.PI;\n            currentPath.lineTo((int)(p2.x + 10*Math.cos(t-PHI)), (int)(p2.y + 10*Math.sin(t-PHI)));\n            currentPath.moveTo((int)(p2.x + 10*Math.cos(t+PHI)), (int)(p2.y + 10*Math.sin(t+PHI)));\n            currentPath.lineTo(p2.x, p2.y);\n        }\n    }","commit_id":"6f25cc27ffb0f9605183a18ab536015417d5fa41","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        used = true;\r\n        return true;\r\n    }","id":90483,"modified_method":"@Override\r\n    public boolean replaceEvent(GameEvent event, Ability source, Game game) {\r\n        return true;\r\n    }","commit_id":"5fb2afc5f3bb3c60b374c63f0114438c0522821c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(getTargetPointer().getFirst(game, source));\r\n        if (player != null) {\r\n            for (Permanent creature: game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(), player.getId(), game)) {\r\n                game.addEffect(new BlindingBeamEffect2(creature.getId()), source);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":90484,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player player = game.getPlayer(getTargetPointer().getFirst(game, source));\r\n        if (player != null) {\r\n            game.addEffect(new BlindingBeamEffect2(player.getId()), source);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"5fb2afc5f3bb3c60b374c63f0114438c0522821c","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        if (game.getTurn().getStepType() == PhaseStep.UNTAP &&\r\n                event.getType() == EventType.UNTAP &&\r\n                event.getTargetId().equals(creatureId)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":90485,"modified_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        // replace untap event of creatures of target player\r\n        if (game.getTurn().getStepType() == PhaseStep.UNTAP && event.getType() == EventType.UNTAP) {\r\n            Permanent permanent = game.getPermanent(event.getTargetId());\r\n            if (permanent != null && permanent.getControllerId().equals(targetPlayerId) && filter.match(permanent, game)) {\r\n                return true;\r\n            }\r\n        }\r\n        // discard effect at end of next untap step of target player\r\n        if (event.getType().equals(EventType.UNTAP_STEP_POST)) {\r\n            if (targetPlayerId.equals(event.getPlayerId())) {\r\n                discard();\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"5fb2afc5f3bb3c60b374c63f0114438c0522821c","url":"https://github.com/magefree/mage"},{"original_method":"public BlindingBeamEffect2(UUID creatureId) {\r\n        super(Duration.OneUse, Outcome.Detriment);\r\n        this.creatureId = creatureId;\r\n    }","id":90486,"modified_method":"public BlindingBeamEffect2(UUID targetPlayerId) {\r\n        super(Duration.Custom, Outcome.Detriment);\r\n        this.targetPlayerId = targetPlayerId;\r\n    }","commit_id":"5fb2afc5f3bb3c60b374c63f0114438c0522821c","url":"https://github.com/magefree/mage"},{"original_method":"public BlindingBeamEffect2(final BlindingBeamEffect2 effect) {\r\n        super(effect);\r\n        creatureId = effect.creatureId;\r\n    }","id":90487,"modified_method":"public BlindingBeamEffect2(final BlindingBeamEffect2 effect) {\r\n        super(effect);\r\n        this.targetPlayerId = effect.targetPlayerId;\r\n    }","commit_id":"5fb2afc5f3bb3c60b374c63f0114438c0522821c","url":"https://github.com/magefree/mage"},{"original_method":"public Curiosity(UUID ownerId) {\r\n        super(ownerId, 49, \"Curiosity\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{U}\");\r\n        this.expansionSetCode = \"ISD\";\r\n        this.subtype.add(\"Aura\");\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Enchant creature\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Constants.Outcome.Neutral));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n        // Whenever enchanted creature deals damage to an opponent, you may draw a card.\r\n        this.addAbility(new DealsCombatDamageToAPlayerAttachedTriggeredAbility(new DrawCardControllerEffect(1), \"equipped\", true));\r\n    }","id":90488,"modified_method":"public Curiosity(UUID ownerId) {\r\n        super(ownerId, 49, \"Curiosity\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{U}\");\r\n        this.expansionSetCode = \"ISD\";\r\n        this.subtype.add(\"Aura\");\r\n\r\n        this.color.setBlue(true);\r\n\r\n        // Enchant creature\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Constants.Outcome.Neutral));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n\r\n        // Whenever enchanted creature deals damage to an opponent, you may draw a card.\r\n        this.addAbility(new CuriosityAbility());\r\n    }","commit_id":"d02ed7a03d0e4f5b77ab5896fb6603215c6a2baf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event instanceof DamagedPlayerEvent) {\r\n            DamagedPlayerEvent damageEvent = (DamagedPlayerEvent) event;\r\n            if (damageEvent.isCombatDamage() && this.sourceId.equals(event.getSourceId())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":90489,"modified_method":"@Override\r\n    public boolean checkTrigger(GameEvent event, Game game) {\r\n        if (event instanceof DamagedPlayerEvent) {\r\n            Permanent permanent = game.getPermanent(event.getSourceId());\r\n            if (permanent != null && game.getOpponents(this.controllerId).contains(event.getTargetId()) && permanent.getAttachments().contains(this.getSourceId())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"d02ed7a03d0e4f5b77ab5896fb6603215c6a2baf","url":"https://github.com/magefree/mage"},{"original_method":"public CuriosityAbility() {\r\n        super(Constants.Zone.BATTLEFIELD, new DrawCardControllerEffect(1));\r\n    }","id":90490,"modified_method":"public CuriosityAbility() {\r\n        super(Constants.Zone.BATTLEFIELD, new DrawCardControllerEffect(1), true);\r\n    }","commit_id":"d02ed7a03d0e4f5b77ab5896fb6603215c6a2baf","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(Permanent permanent, Ability source, Game game) {\r\n        if (permanent.getId().equals(source.getSourceId())) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":90491,"modified_method":"@Override\r\n    public boolean applies(Permanent permanent, Ability source, Game game) {\r\n        Permanent equipment = game.getPermanent(source.getSourceId());\r\n        if (equipment != null && equipment.getAttachedTo() != null) {\r\n            Permanent equipped = game.getPermanent(equipment.getAttachedTo());\r\n            if (permanent.getId().equals(equipped.getId())) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"public BlazingTorchEvasionEffect() {\r\n        super(Duration.WhileOnBattlefield);\r\n    }","id":90492,"modified_method":"public BlazingTorchEvasionEffect() {\r\n        super(Duration.WhileOnBattlefield);\r\n        staticText = \"Equipped creature can't be blocked by Vampires or Zombies\";\r\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"public BlazingTorch(UUID ownerId) {\r\n        super(ownerId, 197, \"Blazing Torch\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{1}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature can't be blocked by Vampires or Zombies.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new BlazingTorchEvasionAbility(), AttachmentType.EQUIPMENT)));\r\n        // Equipped creature has \"{tap}, Sacrifice Blazing Torch: Blazing Torch deals 2 damage to target creature or player.\")\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BlazingTorchDamageEffect(), new TapSourceCost());\r\n        ability.addCost(new BlazingTorchCost());\r\n        ability.addTarget(new TargetCreatureOrPlayer());\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.EQUIPMENT)));\r\n        // Equip {1}\r\n        this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(1)));\r\n    }","id":90493,"modified_method":"public BlazingTorch(UUID ownerId) {\r\n        super(ownerId, 197, \"Blazing Torch\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{1}\");\r\n        this.expansionSetCode = \"ZEN\";\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature can't be blocked by Vampires or Zombies. (!this is a static ability of the equipment)\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BlazingTorchEvasionEffect()));\r\n        // Equipped creature has \"{tap}, Sacrifice Blazing Torch: Blazing Torch deals 2 damage to target creature or player.\")\r\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new BlazingTorchDamageEffect(), new TapSourceCost());\r\n        ability.addCost(new BlazingTorchCost());\r\n        ability.addTarget(new TargetCreatureOrPlayer());\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability, AttachmentType.EQUIPMENT)));\r\n        // Equip {1}\r\n        this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(1)));\r\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean applies(Permanent permanent, Ability source, Game game) {\n        if (permanent.getAbilities().containsKey(OrchardSpiritAbility.getInstance().getId())) {\n            return true;\n        }\n        return false;\n    }","id":90494,"modified_method":"@Override\n    public boolean applies(Permanent permanent, Ability source, Game game) {\n        Permanent equipment = game.getPermanent(source.getSourceId());\n        if (equipment != null && equipment.getAttachedTo() != null) {\n            Permanent equipped = game.getPermanent(equipment.getAttachedTo());\n            if (permanent.getId().equals(equipped.getId())) {\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"public CanopyCover(UUID ownerId) {\n        super(ownerId, 98, \"Canopy Cover\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{G}\");\n        this.expansionSetCode = \"WWK\";\n        this.subtype.add(\"Aura\");\n\n        this.color.setGreen(true);\n\n        // Enchant creature\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Constants.Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n\n        // Enchanted creature can't be blocked except by creatures with flying or reach.\n        this.addAbility(new SimpleStaticAbility(Constants.Zone.BATTLEFIELD, new GainAbilityAttachedEffect(OrchardSpiritAbility.getInstance(), Constants.AttachmentType.AURA)));\n\n        // Enchanted creature can't be the target of spells or abilities your opponents control.\n        this.addAbility(new SimpleStaticAbility(Constants.Zone.BATTLEFIELD, new GainAbilityAttachedEffect(HexproofAbility.getInstance(), Constants.AttachmentType.AURA)));\n    }","id":90495,"modified_method":"public CanopyCover(UUID ownerId) {\n        super(ownerId, 98, \"Canopy Cover\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{G}\");\n        this.expansionSetCode = \"WWK\";\n        this.subtype.add(\"Aura\");\n\n        this.color.setGreen(true);\n\n        // Enchant creature\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n\n        // Enchanted creature can't be blocked except by creatures with flying or reach. (!this is a static ability of the enchantment)\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new OrchardSpiritEffect()));\n\n        // Enchanted creature can't be the target of spells or abilities your opponents control.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(HexproofAbility.getInstance(), AttachmentType.AURA)));\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"public OrchardSpiritEffect() {\n        super(Constants.Duration.WhileOnBattlefield);\n    }","id":90496,"modified_method":"public OrchardSpiritEffect() {\n        super(Duration.WhileOnBattlefield);\n        staticText = \"Enchanted creature can't be blocked except by creatures with flying or reach\";\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        if (game.getTurn().getStepType() == PhaseStep.UNTAP\r\n                && event.getType() == EventType.UNTAP\r\n                && event.getTargetId().equals(source.getSourceId())) {\r\n            Permanent p = game.getPermanent(source.getSourceId());\r\n            for (Ability ability : p.getAbilities()) {\r\n                if (ability.getRule().startsWith(staticText)) {\r\n                    return true;\r\n                }\r\n            }\r\n            used = true;\r\n        }\r\n        return false;\r\n    }","id":90497,"modified_method":"@Override\r\n    public boolean applies(GameEvent event, Ability source, Game game) {\r\n        if (game.getTurn().getStepType() == PhaseStep.UNTAP\r\n                && event.getType() == EventType.UNTAP ) {\r\n            Permanent equipment = game.getPermanent(source.getSourceId());\r\n            if (equipment != null && equipment.getAttachedTo() != null) {\r\n                Permanent equipped = game.getPermanent(equipment.getAttachedTo());\r\n                if (equipped.getId().equals(event.getTargetId())) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"public HeavyArbalest(UUID ownerId) {\r\n        super(ownerId, 164, \"Heavy Arbalest\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{3}\");\r\n        this.expansionSetCode = \"SOM\";\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equip {4}\r\n        this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(4)));\r\n\r\n        SimpleStaticAbility ability1 = new SimpleStaticAbility(Zone.BATTLEFIELD, new HeavyArbalestEffect());\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability1, AttachmentType.EQUIPMENT)));\r\n\r\n        SimpleActivatedAbility ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new TapSourceCost());\r\n        ability2.addTarget(new TargetCreatureOrPlayer());\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability2, AttachmentType.EQUIPMENT)));\r\n    }","id":90498,"modified_method":"public HeavyArbalest(UUID ownerId) {\r\n        super(ownerId, 164, \"Heavy Arbalest\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{3}\");\r\n        this.expansionSetCode = \"SOM\";\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Equipped creature doesn't untap during its controller's untap step.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new HeavyArbalestEffect()));\r\n\r\n        // Equipped creature has \"{T}: This creature deals 2 damage to target creature or player.\"\r\n        SimpleActivatedAbility ability2 = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DamageTargetEffect(2), new TapSourceCost());\r\n        ability2.addTarget(new TargetCreatureOrPlayer());\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(ability2, AttachmentType.EQUIPMENT)));\r\n\r\n        // Equip {4)\r\n        this.addAbility(new EquipAbility(Outcome.BoostCreature, new GenericManaCost(4)));\r\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"public InfiltrationLens(UUID ownerId) {\r\n        super(ownerId, 167, \"Infiltration Lens\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{1}\");\r\n        this.expansionSetCode = \"SOM\";\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new BecomesBlockedTriggeredAbility(new DrawCardControllerEffect(2), true), AttachmentType.EQUIPMENT)));\r\n    }","id":90499,"modified_method":"public InfiltrationLens(UUID ownerId) {\r\n        super(ownerId, 167, \"Infiltration Lens\", Rarity.UNCOMMON, new CardType[]{CardType.ARTIFACT}, \"{1}\");\r\n        this.expansionSetCode = \"SOM\";\r\n        this.subtype.add(\"Equipment\");\r\n\r\n        // Whenever equipped creature becomes blocked by a creature, you may draw two cards.\r\n        this.addAbility(new EquippedBecomesBlockedTriggeredAbility(new DrawCardControllerEffect(2), true));\r\n\r\n        // Equip {1}\r\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(1)));\r\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"public Lure (UUID ownerId) {\r\n        super(ownerId, 226, \"Lure\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{G}{G}\");\r\n        this.expansionSetCode = \"CHK\";\r\n        this.subtype.add(\"Aura\");\r\n        this.color.setGreen(true);\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new GainAbilityAttachedEffect(new SimpleStaticAbility(Zone.BATTLEFIELD, new MustBlockSourceEffect()), AttachmentType.AURA)));\r\n    }","id":90500,"modified_method":"public Lure (UUID ownerId) {\r\n        super(ownerId, 226, \"Lure\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{1}{G}{G}\");\r\n        this.expansionSetCode = \"CHK\";\r\n        this.subtype.add(\"Aura\");\r\n        this.color.setGreen(true);\r\n\r\n        // Enchant creature\r\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\r\n        this.getSpellAbility().addTarget(auraTarget);\r\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));\r\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\r\n        this.addAbility(ability);\r\n\r\n        // All creatures able to block enchanted creature do so.\r\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new MustBlockAttachedEffect(AttachmentType.AURA)));\r\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"public SlowMotion(UUID ownerId) {\n        super(ownerId, 42, \"Slow Motion\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{U}\");\n        this.expansionSetCode = \"ULG\";\n        this.subtype.add(\"Aura\");\n\n        this.color.setBlue(true);\n\n        // Enchant creature\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Constants.Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n        // At the beginning of the upkeep of enchanted creature's controller, that player sacrifices that creature unless he or she pays {2}.\n        Ability gainedAbility = new BeginningOfUpkeepTriggeredAbility(new SacrificeSourceUnlessPaysEffect(new GenericManaCost(2)), Constants.TargetController.YOU, false);\n        this.addAbility(new SimpleStaticAbility(Constants.Zone.BATTLEFIELD, new GainAbilityAttachedEffect(gainedAbility, Constants.AttachmentType.AURA)));\n        // When Slow Motion is put into a graveyard from the battlefield, return Slow Motion to its owner's hand.\n        this.addAbility(new PutIntoGraveFromBattlefieldTriggeredAbility(new ReturnToHandSourceEffect()));\n    }","id":90501,"modified_method":"public SlowMotion(UUID ownerId) {\n        super(ownerId, 42, \"Slow Motion\", Rarity.COMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{U}\");\n        this.expansionSetCode = \"ULG\";\n        this.subtype.add(\"Aura\");\n\n        this.color.setBlue(true);\n\n        // Enchant creature\n        TargetPermanent auraTarget = new TargetCreaturePermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Constants.Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n\n        // At the beginning of the upkeep of enchanted creature's controller, that player sacrifices that creature unless he or she pays {2}.\n        this.addAbility(new BeginningOfUpkeepTriggeredAbility(new SacrificeEquipedUnlessPaysEffect(new GenericManaCost(2)), Constants.TargetController.CONTROLLER_ATTACHED_TO, false ));\n\n        // When Slow Motion is put into a graveyard from the battlefield, return Slow Motion to its owner's hand.\n        this.addAbility(new PutIntoGraveFromBattlefieldTriggeredAbility(new ReturnToHandSourceEffect()));\n    }","commit_id":"07ba5a200e981dfe7133b6b723e5106a7a162131","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n  public void highlightInEditor() {\n    if (!isValid()) return;\n\n    Segment marker = getFirstSegment();\n    SelectInEditorManager.getInstance(getProject()).selectInEditor(getFile(), marker.getStartOffset(), marker.getEndOffset(), false, false);\n  }","id":90502,"modified_method":"@Override\n  public void highlightInEditor() {\n    if (!isValid()) return;\n\n    Segment marker = getFirstSegment();\n    if (marker != null) {\n      SelectInEditorManager.getInstance(getProject()).selectInEditor(getFile(), marker.getStartOffset(), marker.getEndOffset(), false, false);\n    }\n  }","commit_id":"0b81e364266027d7f69f6655c3cd1ecead1ce506","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void selectInEditor() {\n    if (!isValid()) return;\n    Editor editor = openTextEditor(true);\n    Segment marker = getFirstSegment();\n    editor.getSelectionModel().setSelection(marker.getStartOffset(), marker.getEndOffset());\n  }","id":90503,"modified_method":"@Override\n  public void selectInEditor() {\n    if (!isValid()) return;\n    Editor editor = openTextEditor(true);\n    Segment marker = getFirstSegment();\n    if (marker != null) {\n      editor.getSelectionModel().setSelection(marker.getStartOffset(), marker.getEndOffset());\n    }\n  }","commit_id":"0b81e364266027d7f69f6655c3cd1ecead1ce506","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static Pair<Integer, Integer> duplicateLinesRange(Editor editor, Document document, VisualPosition rangeStart, VisualPosition rangeEnd) {\n    Pair<LogicalPosition, LogicalPosition> lines = EditorUtil.calcSurroundingRange(editor, rangeStart, rangeEnd);\n    int offset = editor.getCaretModel().getOffset();\n\n    LogicalPosition lineStart = lines.first;\n    LogicalPosition nextLineStart = lines.second;\n    int start = editor.logicalPositionToOffset(lineStart);\n    int end = editor.logicalPositionToOffset(nextLineStart);\n    String s = document.getCharsSequence().subSequence(start, end).toString();\n    final int lineToCheck = nextLineStart.line - 1;\n\n    int newOffset = end + offset - start;\n    if(lineToCheck == document.getLineCount () /*empty document*/ ||\n       document.getLineSeparatorLength(lineToCheck) == 0) {\n      s = \"\\n\"+s;\n      newOffset++;\n    }\n    document.insertString(end, s);\n\n    editor.getCaretModel().moveToOffset(newOffset);\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    return new Pair<Integer, Integer>(end, end+s.length()-1);   // don't include separator of last line in range to select\n  }","id":90504,"modified_method":"@Nullable\n  static Pair<Integer, Integer> duplicateLinesRange(Editor editor, Document document, VisualPosition rangeStart, VisualPosition rangeEnd) {\n    Pair<LogicalPosition, LogicalPosition> lines = EditorUtil.calcSurroundingRange(editor, rangeStart, rangeEnd);\n    int offset = editor.getCaretModel().getOffset();\n\n    LogicalPosition lineStart = lines.first;\n    LogicalPosition nextLineStart = lines.second;\n    int start = editor.logicalPositionToOffset(lineStart);\n    int end = editor.logicalPositionToOffset(nextLineStart);\n    if (end <= start) {\n      return null;\n    }\n    String s = document.getCharsSequence().subSequence(start, end).toString();\n    final int lineToCheck = nextLineStart.line - 1;\n\n    int newOffset = end + offset - start;\n    if(lineToCheck == document.getLineCount () /*empty document*/ ||\n       document.getLineSeparatorLength(lineToCheck) == 0) {\n      s = \"\\n\"+s;\n      newOffset++;\n    }\n    document.insertString(end, s);\n\n    editor.getCaretModel().moveToOffset(newOffset);\n    editor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n    return new Pair<Integer, Integer>(end, end+s.length()-1);   // don't include separator of last line in range to select\n  }","commit_id":"09cc895da6007e1033135ad2e49e223591b7e067","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void executeWriteAction(Editor editor, DataContext dataContext) {\n      if (editor.getSelectionModel().hasSelection()) {\n        int selStart = editor.getSelectionModel().getSelectionStart();\n        int selEnd = editor.getSelectionModel().getSelectionEnd();\n        VisualPosition rangeStart = editor.offsetToVisualPosition(Math.min(selStart, selEnd));\n        VisualPosition rangeEnd = editor.offsetToVisualPosition(Math.max(selStart, selEnd));\n        final Pair<Integer,Integer> copiedRange =\n          DuplicateAction.duplicateLinesRange(editor, editor.getDocument(), rangeStart, rangeEnd);\n        editor.getSelectionModel().setSelection(copiedRange.first, copiedRange.second);\n      }\n      else {\n        VisualPosition caretPos = editor.getCaretModel().getVisualPosition();\n        DuplicateAction.duplicateLinesRange(editor, editor.getDocument(), caretPos, caretPos);\n      }\n    }","id":90505,"modified_method":"@Override\n    public void executeWriteAction(Editor editor, DataContext dataContext) {\n      if (editor.getSelectionModel().hasSelection()) {\n        int selStart = editor.getSelectionModel().getSelectionStart();\n        int selEnd = editor.getSelectionModel().getSelectionEnd();\n        VisualPosition rangeStart = editor.offsetToVisualPosition(Math.min(selStart, selEnd));\n        VisualPosition rangeEnd = editor.offsetToVisualPosition(Math.max(selStart, selEnd));\n        final Pair<Integer,Integer> copiedRange =\n          DuplicateAction.duplicateLinesRange(editor, editor.getDocument(), rangeStart, rangeEnd);\n        if (copiedRange != null) {\n          editor.getSelectionModel().setSelection(copiedRange.first, copiedRange.second);\n        }\n      }\n      else {\n        VisualPosition caretPos = editor.getCaretModel().getVisualPosition();\n        DuplicateAction.duplicateLinesRange(editor, editor.getDocument(), caretPos, caretPos);\n      }\n    }","commit_id":"09cc895da6007e1033135ad2e49e223591b7e067","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static ManualCapacityScaleConfig createManualCapacityScaleConfig(int totalMemoryInMB, boolean locationAware) {\n\t\tManualCapacityScaleConfig config = new ManualCapacityScaleConfigurer()\n\t\t\t   .memoryCapacity(totalMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t   .atMostOneContainerPerMachine()\n\t\t\t   .create();\n\t\tconfig.setGridServiceAgentZonesAware(locationAware);\n\t\treturn config;\n\t}","id":90506,"modified_method":"public static ManualCapacityScaleConfig createManualCapacityScaleConfig(int totalMemoryInMB, \n\t\t\tdouble totalCpuCores,\n\t\t\tboolean locationAware, boolean shared) {\n\t\tManualCapacityScaleConfig config = new ManualCapacityScaleConfigurer()\n\t\t\t   .memoryCapacity(totalMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t   .numberOfCpuCores(totalCpuCores)\n\t\t\t   .create();\n\t\tif (!shared) {\n\t\t\tconfig.setAtMostOneContainerPerMachine(true);\n\t\t}\n\t\tconfig.setGridServiceAgentZonesAware(locationAware);\n\t\treturn config;\n\t}","commit_id":"220b6ca5d40e407544379c954b93faa1f52706b6","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/**\n\t * @param serviceName - the absolute name of the service\n\t * @param service - the service DSL or null if not exists\n\t * @param externalProcessMemoryInMB - MB memory allocated for the GSC plus the external service.\n\t * @param locationAware \n\t * @return a @{link AutomaticCapacityScaleConfig} based on the specified service and memory.\n\t */\n\tpublic static AutomaticCapacityScaleConfig createAutomaticCapacityScaleConfig(\n\t\t\tfinal String serviceName,\n\t\t\tfinal Service service, \n\t\t\tfinal int externalProcessMemoryInMB, boolean locationAware)\n\t\t\tthrows DSLException {\n\n\t\tif (externalProcessMemoryInMB <=0) {\n\t\t\tthrow new IllegalArgumentException(\"externalProcessMemoryInMB must be positive\");\n\t\t}\n\t\t\n\t\tList<ScalingRuleDetails> scalingRules = service.getScalingRules();\n\t\tif (scalingRules.isEmpty()) {\n\t\t\tthrow new DSLException(\"scalingRules cannot be empty\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() <= 0) {\n\t\t\tthrow new DSLException(\"Minimum number of instances (\" + service.getMinAllowedInstances()\n\t\t\t\t\t+ \") must be 1 or higher.\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() > service.getMaxAllowedInstances()) {\n\t\t\tthrow new DSLException(\"maximum number of instances (\" + service.getMaxAllowedInstances()\n\t\t\t\t\t+ \") must be equal or greater than the minimum number of instances (\"\n\t\t\t\t\t+ service.getMinAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() > service.getNumInstances()) {\n\t\t\tthrow new DSLException(\"number of instances (\" + service.getNumInstances()\n\t\t\t\t\t+ \") must be equal or greater than the minimum number of instances (\"\n\t\t\t\t\t+ service.getMinAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tif (service.getNumInstances() > service.getMaxAllowedInstances()) {\n\t\t\tthrow new DSLException(\"number of instances (\" + service.getNumInstances()\n\t\t\t\t\t+ \") must be equal or less than the maximum number of instances (\"\n\t\t\t\t\t+ service.getMaxAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tCapacityRequirementsConfig minCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getMinAllowedInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.create();\n\t\t\n\t\tCapacityRequirementsConfig initialCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getNumInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.create();\n\t\n\t\t\n\t\tCapacityRequirementsConfig maxCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getMaxAllowedInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.create();\n\t\n\t\tCapacityRequirementsConfig minCapacityPerZone = \n\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t.memoryCapacity((service.getMinAllowedInstancesPerLocation() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t\t.create();\n\t\t\n\t\tCapacityRequirementsConfig maxCapacityPerZone = \n\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t.memoryCapacity((service.getMaxAllowedInstancesPerLocation() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t\t.create();\n\t\t\n\t\tAutomaticCapacityScaleConfigurer scaleConfigurer = \n\t\t\tnew AutomaticCapacityScaleConfigurer()\n\t\t\t.minCapacity(minCapacity)\n\t\t\t.initialCapacity(initialCapacity)\n\t\t\t.maxCapacity(maxCapacity)\n\t\t\t.minCapacityPerZone(minCapacityPerZone)\n\t\t\t.maxCapacityPerZone(maxCapacityPerZone)\n\t\t\t.statisticsPollingInterval(service.getSamplingPeriodInSeconds(), TimeUnit.SECONDS)\n\t\t\t.cooldownAfterScaleOut(service.getScaleOutCooldownInSeconds(),TimeUnit.SECONDS)\n\t\t\t.cooldownAfterScaleIn(service.getScaleInCooldownInSeconds(),TimeUnit.SECONDS);\n\t\t\n\t\tif (locationAware) {\n\t\t\tscaleConfigurer.enableGridServiceAgentZonesAware();\n\t\t}\n\t\t\t\n\t\tMap<String, ServiceStatisticsDetails> serviceStatisticsByName = new HashMap<String, ServiceStatisticsDetails>();\n\t\tif (service.getServiceStatistics() != null) {\n\t\t\tfor (AbstractStatisticsDetails calculatedStatistics : service.getServiceStatistics()) {\n\t\t\t\tif (calculatedStatistics instanceof ServiceStatisticsDetails) {\n\t\t\t\t\tserviceStatisticsByName.put(calculatedStatistics.getName(), (ServiceStatisticsDetails)calculatedStatistics);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tfor (ScalingRuleDetails scalingRule : scalingRules) {\n\t\t\t\n\t\t\tObject serviceStatisticsObject = scalingRule.getServiceStatistics();\n\t\t\tif (serviceStatisticsObject == null) {\n\t\t\t\tthrow new DSLException(SCALING_RULE_MUST_SPECIFY_SERVICE_STATISTICS_ERROR_MSG);\n\t\t\t}\n\t\t\t\n\t\t\tServiceStatisticsDetails serviceStatistics = null;\n\t\t\t\n\t\t\tif (serviceStatisticsObject instanceof String) {\n\t\t\t\tString serviceStatisticsName = (String)serviceStatisticsObject;\n\t\t\t\tserviceStatistics = serviceStatisticsByName.get(serviceStatisticsName);\n\t\t\t\t\n\t\t\t\tif (serviceStatistics == null) {\n\t\t\t\t\tthrow new DSLException(SCALING_RULE_MUST_SPECIFY_SERVICE_STATISTICS_ERROR_MSG + \" \" + serviceStatisticsName + \" is not recognized. Possible values are: \"+ serviceStatisticsByName.keySet());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (serviceStatisticsObject instanceof ServiceStatisticsDetails) {\n\t\t\t\tserviceStatistics = (ServiceStatisticsDetails) serviceStatisticsObject;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new DSLException(SCALING_RULE_MUST_SPECIFY_SERVICE_STATISTICS_ERROR_MSG +\" Unsupported type \" + serviceStatisticsObject.getClass() );\n\t\t\t}\n\t\t\t\n\t\t\tProcessingUnitStatisticsId statisticsId = new ProcessingUnitStatisticsId();\n\t\t\tstatisticsId.setMonitor(CloudifyConstants.USM_MONITORS_SERVICE_ID);\n\t\t\tstatisticsId.setMetric(serviceStatistics.getMetric());\n\t\t\tstatisticsId.setInstancesStatistics(serviceStatistics.getInstancesStatistics().createInstancesStatistics());\n\t\n\t\t\tif (serviceStatistics.getMovingTimeRangeInSeconds() <= service.getSamplingPeriodInSeconds()) {\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(\"Deploying service \" + serviceName + \" with auto scaling that monitors the last sample of \"\n\t\t\t\t\t\t\t+ serviceStatistics.getMetric());\n\t\t\t\t}\n\t\t\t\tstatisticsId.setTimeWindowStatistics(new LastSampleTimeWindowStatisticsConfig());\n\t\t\t} else {\n\t\t\t\tstatisticsId.setTimeWindowStatistics(serviceStatistics.getTimeStatistics().createTimeWindowStatistics(\n\t\t\t\t\t\tserviceStatistics.getMovingTimeRangeInSeconds(), TimeUnit.SECONDS));\n\t\t\t}\n\t\t\t\n\t\t\tstatisticsId.setAgentZones(new AnyZonesConfig());\n\t\t\t\n\t\t\tAutomaticCapacityScaleRuleConfig rule = new AutomaticCapacityScaleRuleConfig();\n\t\t\trule.setStatistics(statisticsId);\n\t\t\t\n\t\t\tif (scalingRule.getLowThreshold() == null){\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" lowThreshold is undefined\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tComparable<?> threshold = scalingRule.getLowThreshold().getValue();\n\t\t\t\tif (threshold == null) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" lowThreshold value is missing\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint instancesDecrease = scalingRule.getLowThreshold().getInstancesDecrease ();\n\t\t\t\tif (instancesDecrease < 0) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" lowThreshold instancesDecrease cannot be a negative number (\"+instancesDecrease+\")\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (instancesDecrease == 0) {\n\t\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" lowThreshold instancesDecrease is 0\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trule.setLowThreshold(threshold);\n\t\t\t\t\trule.setLowThresholdBreachedDecrease(\n\t\t\t\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t\t\t\t.memoryCapacity(instancesDecrease * externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t\t.create());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (scalingRule.getHighThreshold() == null) {\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" highThreshold is undefined\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tComparable<?> threshold = scalingRule.getHighThreshold().getValue();\n\t\t\t\tif (threshold == null) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" highThreshold value is missing\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint instancesIncrease = scalingRule.getHighThreshold().getInstancesIncrease();\n\t\t\t\tif (instancesIncrease < 0) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" highThreshold instancesIncrease cannot be a negative number (\"+instancesIncrease+\")\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (instancesIncrease == 0) {\n\t\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" highThreshold instancesIncrease is 0\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trule.setHighThreshold(threshold);\n\t\t\t\t\trule.setHighThresholdBreachedIncrease(\n\t\t\t\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t\t\t\t.memoryCapacity(instancesIncrease * externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t\t.create());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tscaleConfigurer.addRule(rule);\n\t\t}\n\t\t\n\t\treturn scaleConfigurer.create();\n\t}","id":90507,"modified_method":"/**\n\t * @param serviceName - the absolute name of the service\n\t * @param service - the service DSL or null if not exists\n\t * @param externalProcessMemoryInMB - MB memory allocated for the GSC plus the external service.\n\t * @param locationAware \n\t * @return a @{link AutomaticCapacityScaleConfig} based on the specified service and memory.\n\t */\n\tpublic static AutomaticCapacityScaleConfig createAutomaticCapacityScaleConfig(\n\t\t\tfinal String serviceName,\n\t\t\tfinal Service service, \n\t\t\tfinal int externalProcessMemoryInMB, boolean locationAware)\n\t\t\tthrows DSLException {\n\n\t\tif (externalProcessMemoryInMB <=0) {\n\t\t\tthrow new IllegalArgumentException(\"externalProcessMemoryInMB must be positive\");\n\t\t}\n\t\t\n\t\tList<ScalingRuleDetails> scalingRules = service.getScalingRules();\n\t\tif (scalingRules.isEmpty()) {\n\t\t\tthrow new DSLException(\"scalingRules cannot be empty\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() <= 0) {\n\t\t\tthrow new DSLException(\"Minimum number of instances (\" + service.getMinAllowedInstances()\n\t\t\t\t\t+ \") must be 1 or higher.\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() > service.getMaxAllowedInstances()) {\n\t\t\tthrow new DSLException(\"maximum number of instances (\" + service.getMaxAllowedInstances()\n\t\t\t\t\t+ \") must be equal or greater than the minimum number of instances (\"\n\t\t\t\t\t+ service.getMinAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tif (service.getMinAllowedInstances() > service.getNumInstances()) {\n\t\t\tthrow new DSLException(\"number of instances (\" + service.getNumInstances()\n\t\t\t\t\t+ \") must be equal or greater than the minimum number of instances (\"\n\t\t\t\t\t+ service.getMinAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tif (service.getNumInstances() > service.getMaxAllowedInstances()) {\n\t\t\tthrow new DSLException(\"number of instances (\" + service.getNumInstances()\n\t\t\t\t\t+ \") must be equal or less than the maximum number of instances (\"\n\t\t\t\t\t+ service.getMaxAllowedInstances() + \")\");\n\t\t}\n\t\t\n\t\tdouble instanceCpuCores = service.getInstanceCpuCores();\n\t\tCapacityRequirementsConfig minCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getMinAllowedInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.numberOfCpuCores(service.getMinAllowedInstances() * instanceCpuCores)\n\t\t\t.create();\n\t\t\n\t\tCapacityRequirementsConfig initialCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getNumInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.numberOfCpuCores(service.getNumInstances() * instanceCpuCores)\n\t\t\t.create();\n\t\n\t\t\n\t\tCapacityRequirementsConfig maxCapacity = \n\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t.memoryCapacity((service.getMaxAllowedInstances() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t.numberOfCpuCores(service.getMaxAllowedInstances() * instanceCpuCores)\n\t\t\t.create();\n\t\n\t\tCapacityRequirementsConfig minCapacityPerZone = \n\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t.memoryCapacity((service.getMinAllowedInstancesPerLocation() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t\t.numberOfCpuCores(service.getMinAllowedInstancesPerLocation() * instanceCpuCores)\n\t\t\t\t.create();\n\t\t\n\t\tCapacityRequirementsConfig maxCapacityPerZone = \n\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t.memoryCapacity((service.getMaxAllowedInstancesPerLocation() * externalProcessMemoryInMB), MemoryUnit.MEGABYTES)\n\t\t\t\t.numberOfCpuCores(service.getMaxAllowedInstancesPerLocation() * instanceCpuCores)\n\t\t\t\t.create();\n\t\t\n\t\tAutomaticCapacityScaleConfigurer scaleConfigurer = \n\t\t\tnew AutomaticCapacityScaleConfigurer()\n\t\t\t.minCapacity(minCapacity)\n\t\t\t.initialCapacity(initialCapacity)\n\t\t\t.maxCapacity(maxCapacity)\n\t\t\t.minCapacityPerZone(minCapacityPerZone)\n\t\t\t.maxCapacityPerZone(maxCapacityPerZone)\n\t\t\t.statisticsPollingInterval(service.getSamplingPeriodInSeconds(), TimeUnit.SECONDS)\n\t\t\t.cooldownAfterScaleOut(service.getScaleOutCooldownInSeconds(),TimeUnit.SECONDS)\n\t\t\t.cooldownAfterScaleIn(service.getScaleInCooldownInSeconds(),TimeUnit.SECONDS)\n\t\t\t.atMostOneContainerPerMachine();\n\t\t\n\t\tif (locationAware) {\n\t\t\tscaleConfigurer.enableGridServiceAgentZonesAware();\n\t\t}\n\t\t\t\n\t\tMap<String, ServiceStatisticsDetails> serviceStatisticsByName = new HashMap<String, ServiceStatisticsDetails>();\n\t\tif (service.getServiceStatistics() != null) {\n\t\t\tfor (AbstractStatisticsDetails calculatedStatistics : service.getServiceStatistics()) {\n\t\t\t\tif (calculatedStatistics instanceof ServiceStatisticsDetails) {\n\t\t\t\t\tserviceStatisticsByName.put(calculatedStatistics.getName(), (ServiceStatisticsDetails)calculatedStatistics);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tfor (ScalingRuleDetails scalingRule : scalingRules) {\n\t\t\t\n\t\t\tObject serviceStatisticsObject = scalingRule.getServiceStatistics();\n\t\t\tif (serviceStatisticsObject == null) {\n\t\t\t\tthrow new DSLException(SCALING_RULE_MUST_SPECIFY_SERVICE_STATISTICS_ERROR_MSG);\n\t\t\t}\n\t\t\t\n\t\t\tServiceStatisticsDetails serviceStatistics = null;\n\t\t\t\n\t\t\tif (serviceStatisticsObject instanceof String) {\n\t\t\t\tString serviceStatisticsName = (String)serviceStatisticsObject;\n\t\t\t\tserviceStatistics = serviceStatisticsByName.get(serviceStatisticsName);\n\t\t\t\t\n\t\t\t\tif (serviceStatistics == null) {\n\t\t\t\t\tthrow new DSLException(SCALING_RULE_MUST_SPECIFY_SERVICE_STATISTICS_ERROR_MSG + \" \" + serviceStatisticsName + \" is not recognized. Possible values are: \"+ serviceStatisticsByName.keySet());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (serviceStatisticsObject instanceof ServiceStatisticsDetails) {\n\t\t\t\tserviceStatistics = (ServiceStatisticsDetails) serviceStatisticsObject;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new DSLException(SCALING_RULE_MUST_SPECIFY_SERVICE_STATISTICS_ERROR_MSG +\" Unsupported type \" + serviceStatisticsObject.getClass() );\n\t\t\t}\n\t\t\t\n\t\t\tProcessingUnitStatisticsId statisticsId = new ProcessingUnitStatisticsId();\n\t\t\tstatisticsId.setMonitor(CloudifyConstants.USM_MONITORS_SERVICE_ID);\n\t\t\tstatisticsId.setMetric(serviceStatistics.getMetric());\n\t\t\tstatisticsId.setInstancesStatistics(serviceStatistics.getInstancesStatistics().createInstancesStatistics());\n\t\n\t\t\tif (serviceStatistics.getMovingTimeRangeInSeconds() <= service.getSamplingPeriodInSeconds()) {\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(\"Deploying service \" + serviceName + \" with auto scaling that monitors the last sample of \"\n\t\t\t\t\t\t\t+ serviceStatistics.getMetric());\n\t\t\t\t}\n\t\t\t\tstatisticsId.setTimeWindowStatistics(new LastSampleTimeWindowStatisticsConfig());\n\t\t\t} else {\n\t\t\t\tstatisticsId.setTimeWindowStatistics(serviceStatistics.getTimeStatistics().createTimeWindowStatistics(\n\t\t\t\t\t\tserviceStatistics.getMovingTimeRangeInSeconds(), TimeUnit.SECONDS));\n\t\t\t}\n\t\t\t\n\t\t\tstatisticsId.setAgentZones(new AnyZonesConfig());\n\t\t\t\n\t\t\tAutomaticCapacityScaleRuleConfig rule = new AutomaticCapacityScaleRuleConfig();\n\t\t\trule.setStatistics(statisticsId);\n\t\t\t\n\t\t\tif (scalingRule.getLowThreshold() == null){\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" lowThreshold is undefined\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tComparable<?> threshold = scalingRule.getLowThreshold().getValue();\n\t\t\t\tif (threshold == null) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" lowThreshold value is missing\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint instancesDecrease = scalingRule.getLowThreshold().getInstancesDecrease ();\n\t\t\t\tif (instancesDecrease < 0) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" lowThreshold instancesDecrease cannot be a negative number (\"+instancesDecrease+\")\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (instancesDecrease == 0) {\n\t\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" lowThreshold instancesDecrease is 0\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trule.setLowThreshold(threshold);\n\t\t\t\t\trule.setLowThresholdBreachedDecrease(\n\t\t\t\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t\t\t\t.memoryCapacity(instancesDecrease * externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t\t.create());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (scalingRule.getHighThreshold() == null) {\n\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" highThreshold is undefined\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tComparable<?> threshold = scalingRule.getHighThreshold().getValue();\n\t\t\t\tif (threshold == null) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" highThreshold value is missing\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint instancesIncrease = scalingRule.getHighThreshold().getInstancesIncrease();\n\t\t\t\tif (instancesIncrease < 0) {\n\t\t\t\t\tthrow new DSLException(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" highThreshold instancesIncrease cannot be a negative number (\"+instancesIncrease+\")\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (instancesIncrease == 0) {\n\t\t\t\t\tif (logger.isLoggable(Level.FINE)) {\n\t\t\t\t\t\tlogger.fine(serviceName + \" scalingRule for \" + serviceStatistics.getMetric() +\" highThreshold instancesIncrease is 0\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\trule.setHighThreshold(threshold);\n\t\t\t\t\trule.setHighThresholdBreachedIncrease(\n\t\t\t\t\t\t\tnew CapacityRequirementsConfigurer()\n\t\t\t\t\t\t\t.memoryCapacity(instancesIncrease * externalProcessMemoryInMB, MemoryUnit.MEGABYTES)\n\t\t\t\t\t\t\t.create());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tscaleConfigurer.addRule(rule);\n\t\t}\n\t\t\n\t\treturn scaleConfigurer.create();\n\t}","commit_id":"220b6ca5d40e407544379c954b93faa1f52706b6","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private IndexCountPlanNode(IndexScanPlanNode isp, AggregatePlanNode apn,\n                               IndexLookupType endType, List<AbstractExpression> endKeys)\n    {\n        super();\n\n        m_catalogIndex = isp.m_catalogIndex;\n\n        m_estimatedOutputTupleCount = 1;\n        m_tableSchema = isp.m_tableSchema;\n        m_tableScanSchema = isp.m_tableScanSchema.clone();\n\n        m_targetTableAlias = isp.m_targetTableAlias;\n        m_targetTableName = isp.m_targetTableName;\n        m_targetIndexName = isp.m_targetIndexName;\n\n        m_lookupType = isp.m_lookupType;\n        m_searchkeyExpressions = isp.m_searchkeyExpressions;\n        m_predicate = null;\n        m_bindings = isp.getBindings();\n\n        m_outputSchema = apn.getOutputSchema().clone();\n        m_hasSignificantOutputSchema = true;\n\n        m_endType = endType;\n        m_endkeyExpressions.addAll(endKeys);\n    }","id":90508,"modified_method":"private IndexCountPlanNode(IndexScanPlanNode isp, AggregatePlanNode apn,\n                               IndexLookupType endType, List<AbstractExpression> endKeys)\n    {\n        super();\n\n        m_catalogIndex = isp.m_catalogIndex;\n\n        m_estimatedOutputTupleCount = 1;\n        m_tableSchema = isp.m_tableSchema;\n        m_tableScanSchema = isp.m_tableScanSchema.clone();\n\n        m_targetTableAlias = isp.m_targetTableAlias;\n        m_targetTableName = isp.m_targetTableName;\n        m_targetIndexName = isp.m_targetIndexName;\n\n        m_predicate = null;\n        m_bindings = isp.getBindings();\n\n        m_outputSchema = apn.getOutputSchema().clone();\n        m_hasSignificantOutputSchema = true;\n\n        if (isp.getSortDirection() != SortDirectionType.DESC) {\n            m_lookupType = isp.m_lookupType;\n            m_searchkeyExpressions = isp.m_searchkeyExpressions;\n\n            m_endType = endType;\n            m_endkeyExpressions.addAll(endKeys);\n        } else {\n            // for reverse scan, swap everything of searchkey and endkey\n            // because we added the last < / <= to searchkey but not endExpr\n            m_lookupType = endType;     // must be EQ, but doesn't matter, since previous lookup type is not GT\n            m_searchkeyExpressions.addAll(endKeys);\n            m_endType = isp.m_lookupType;\n            m_endkeyExpressions = isp.getSearchKeyExpressions();\n        }\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static IndexCountPlanNode createOrNull(IndexScanPlanNode isp, AggregatePlanNode apn)\n    {\n        List<AbstractExpression> endKeys = new ArrayList<AbstractExpression>();\n        // Initially assume that there will be an equality filter on all key components.\n        IndexLookupType endType = IndexLookupType.EQ;\n        List<AbstractExpression> endComparisons = ExpressionUtil.uncombine(isp.getEndExpression());\n        for (AbstractExpression ae: endComparisons) {\n            // There should be no more end expressions after an LT or LTE has reset the end type.\n            assert(endType == IndexLookupType.EQ);\n\n            if (ae.getExpressionType() == ExpressionType.COMPARE_LESSTHAN) {\n                endType = IndexLookupType.LT;\n            }\n            else if (ae.getExpressionType() == ExpressionType.COMPARE_LESSTHANOREQUALTO) {\n                endType = IndexLookupType.LTE;\n            } else {\n                assert(ae.getExpressionType() == ExpressionType.COMPARE_EQUAL);\n            }\n\n            // PlanNodes all need private deep copies of expressions\n            // so that the resolveColumnIndexes results\n            // don't get bashed by other nodes or subsequent planner runs\n            endKeys.add((AbstractExpression)ae.getRight().clone());\n        }\n\n        // Avoid the cases that would cause undercounts for prefix matches.\n        // A prefix-only key exists and does not use LT.\n        if ((endType != IndexLookupType.LT) &&\n            (endKeys.size() > 0) &&\n            (endKeys.size() < isp.getCatalogIndex().getColumns().size())) {\n            return null;\n        }\n        return new IndexCountPlanNode(isp, apn, endType, endKeys);\n    }","id":90509,"modified_method":"public static IndexCountPlanNode createOrNull(IndexScanPlanNode isp, AggregatePlanNode apn)\n    {\n        // add support for reserve scan\n        // for ASC scan, check endExpression; for DESC scan, need to check searchkeys\n        List<AbstractExpression> endKeys = new ArrayList<AbstractExpression>();\n        // Initially assume that there will be an equality filter on all key components.\n        IndexLookupType endType = IndexLookupType.EQ;\n        List<AbstractExpression> endComparisons = ExpressionUtil.uncombine(isp.getEndExpression());\n        for (AbstractExpression ae: endComparisons) {\n            // There should be no more end expressions after an LT or LTE has reset the end type.\n            assert(endType == IndexLookupType.EQ);\n\n            if (ae.getExpressionType() == ExpressionType.COMPARE_LESSTHAN) {\n                endType = IndexLookupType.LT;\n            }\n            else if (ae.getExpressionType() == ExpressionType.COMPARE_LESSTHANOREQUALTO) {\n                endType = IndexLookupType.LTE;\n            } else {\n                assert(ae.getExpressionType() == ExpressionType.COMPARE_EQUAL);\n            }\n\n            // PlanNodes all need private deep copies of expressions\n            // so that the resolveColumnIndexes results\n            // don't get bashed by other nodes or subsequent planner runs\n            endKeys.add((AbstractExpression)ae.getRight().clone());\n        }\n\n        // check endkey for ASC or searchkey for DESC case separately\n\n        // Avoid the cases that would cause undercounts for prefix matches.\n        // A prefix-only key exists and does not use LT.\n        if (isp.getSortDirection() != SortDirectionType.DESC &&\n            (endType != IndexLookupType.LT) &&\n            (endKeys.size() > 0) &&\n            (endKeys.size() < isp.getCatalogIndex().getColumns().size())) {\n            return null;\n        }\n\n        // DESC case\n        if ((isp.getSearchKeyExpressions().size() > 0) &&\n                (isp.getSearchKeyExpressions().size() < isp.getCatalogIndex().getColumns().size())) {\n            return null;\n        }\n        return new IndexCountPlanNode(isp, apn, endType, endKeys);\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"AbstractPlanNode recursivelyApply(AbstractPlanNode plan)\n    {\n        assert(plan != null);\n\n        // depth first:\n        //     find AggregatePlanNode with exactly one child\n        //     where that child is an AbstractScanPlanNode.\n        //     Replace any qualifying AggregatePlanNode / AbstractScanPlanNode pair\n        //     with an IndexCountPlanNode or TableCountPlanNode\n\n        ArrayList<AbstractPlanNode> children = new ArrayList<AbstractPlanNode>();\n\n        for (int i = 0; i < plan.getChildCount(); i++)\n            children.add(plan.getChild(i));\n\n        for (AbstractPlanNode child : children) {\n            // TODO this will break when children feed multiple parents\n            AbstractPlanNode newChild = recursivelyApply(child);\n            // Do a graft into the (parent) plan only if a replacement for a child was found.\n            if (newChild == child) {\n                continue;\n            }\n            child.removeFromGraph();\n            plan.addAndLinkChild(newChild);\n        }\n\n        // check for an aggregation of the right form\n        if ((plan instanceof AggregatePlanNode) == false)\n            return plan;\n        assert(plan.getChildCount() == 1);\n        AggregatePlanNode aggplan = (AggregatePlanNode)plan;\n        if (aggplan.isTableCountStar() == false) {\n            return plan;\n        }\n\n        AbstractPlanNode child = plan.getChild(0);\n\n        // A table count can replace a seq scan only if it has no predicates.\n        if (child instanceof SeqScanPlanNode) {\n            if (((SeqScanPlanNode)child).getPredicate() != null) {\n                return plan;\n            }\n            return new TableCountPlanNode((AbstractScanPlanNode)child, aggplan);\n        }\n\n        // Otherwise, optimized counts only replace particular cases of index scan.\n        if ((child instanceof IndexScanPlanNode) == false)\n            return plan;\n\n        IndexScanPlanNode isp = (IndexScanPlanNode)child;\n\n        // An index count or table count can replace an index scan only if it has no (post-)predicates.\n        if (isp.getPredicate() != null) {\n            return plan;\n        }\n\n        // With no start or end keys, there's not much a counting index can do.\n        if (isp.getEndExpression() == null && isp.getSearchKeyExpressions().size() == 0) {\n            // An indexed query without a where clause can fall back to a plain old table count.\n            // This can only happen when a confused query like\n            // \"select count(*) from table order by index_key;\"\n            // meets a naive planner that doesn't just cull the no-op ORDER BY. Who, us?\n            return new TableCountPlanNode(isp, aggplan);\n        }\n\n        // Eliminate one last bizarre edge case - a reverse scan like\n        // \"select count(*) from table where index_key > ? order by index_key DESC;\".\n        // This time, hold out for the planner to develop the smarts to cull the ORDER BY\n        // -- the alternative would be the code clutter of trying to swap start and end keys.\n        if (isp.getSortDirection() == SortDirectionType.DESC) {\n            return plan;\n        }\n\n        // check for the index's support for counting\n        Index idx = isp.getCatalogIndex();\n        if ( ! idx.getCountable()) {\n            return plan;\n        }\n\n        // The core idea is that counting index needs to know the start key and end key to\n        // jump to to get counts instead of actually doing any scanning.\n        // Options to be determined are:\n        // - whether each of the start/end keys is missing, partial (a prefix of a compund key), or complete,\n        // - whether the count should include or exclude entries exactly matching each of the start/end keys.\n        // Not all combinations of these options are supported;\n        // unsupportable cases cause the factory method to return null.\n        IndexCountPlanNode countingPlan = IndexCountPlanNode.createOrNull(isp, aggplan);\n        if (countingPlan == null) {\n            return plan;\n        }\n        return countingPlan;\n    }","id":90510,"modified_method":"AbstractPlanNode recursivelyApply(AbstractPlanNode plan)\n    {\n        assert(plan != null);\n\n        // depth first:\n        //     find AggregatePlanNode with exactly one child\n        //     where that child is an AbstractScanPlanNode.\n        //     Replace any qualifying AggregatePlanNode / AbstractScanPlanNode pair\n        //     with an IndexCountPlanNode or TableCountPlanNode\n\n        ArrayList<AbstractPlanNode> children = new ArrayList<AbstractPlanNode>();\n\n        for (int i = 0; i < plan.getChildCount(); i++)\n            children.add(plan.getChild(i));\n\n        for (AbstractPlanNode child : children) {\n            // TODO this will break when children feed multiple parents\n            AbstractPlanNode newChild = recursivelyApply(child);\n            // Do a graft into the (parent) plan only if a replacement for a child was found.\n            if (newChild == child) {\n                continue;\n            }\n            child.removeFromGraph();\n            plan.addAndLinkChild(newChild);\n        }\n\n        // check for an aggregation of the right form\n        if ((plan instanceof AggregatePlanNode) == false)\n            return plan;\n        assert(plan.getChildCount() == 1);\n        AggregatePlanNode aggplan = (AggregatePlanNode)plan;\n        if (aggplan.isTableCountStar() == false) {\n            return plan;\n        }\n\n        AbstractPlanNode child = plan.getChild(0);\n\n        // A table count can replace a seq scan only if it has no predicates.\n        if (child instanceof SeqScanPlanNode) {\n            if (((SeqScanPlanNode)child).getPredicate() != null) {\n                return plan;\n            }\n            return new TableCountPlanNode((AbstractScanPlanNode)child, aggplan);\n        }\n\n        // Otherwise, optimized counts only replace particular cases of index scan.\n        if ((child instanceof IndexScanPlanNode) == false)\n            return plan;\n\n        IndexScanPlanNode isp = (IndexScanPlanNode)child;\n\n        // An index count or table count can replace an index scan only if it has no (post-)predicates.\n        if (isp.getPredicate() != null) {\n            // for reverse scan, need to examine \"added\" predicates\n            List<AbstractExpression> predicates = ExpressionUtil.uncombine(isp.getPredicate());\n            // if the size of predicates doesn't equal 2, can't be our added artifact predicates\n            if (predicates.size() != 2) {\n                return plan;\n            }\n            // examin each possible \"added\" predicates\n            // the 1st predicate must matches the last searchKey and the 2nd is NOT NULL expr\n            AbstractExpression expr = predicates.get(0);\n            if (expr.getExpressionType() != ExpressionType.COMPARE_LESSTHAN &&\n                    expr.getExpressionType() != ExpressionType.COMPARE_LESSTHANOREQUALTO) {\n                return plan;\n            }\n            int searchKeyCount = isp.getSearchKeyExpressions().size();\n            String exprsjson = isp.getCatalogIndex().getExpressionsjson();\n            AbstractExpression left = expr.getLeft();\n            if (exprsjson.isEmpty()) {\n                if (left.getExpressionType() != ExpressionType.VALUE_TUPLE) {\n                    return plan;\n                }\n                if (((TupleValueExpression)left).getColumnIndex() !=\n                        CatalogUtil.getSortedCatalogItems(isp.getCatalogIndex().getColumns(), \"index\").get(searchKeyCount - 1).getColumn().getIndex()) {\n                    return plan;\n                }\n            } else {\n                List<AbstractExpression> indexedExprs = null;\n                try {\n                    indexedExprs = AbstractExpression.fromJSONArrayString(exprsjson, null);\n                } catch (JSONException e) {\n                    e.printStackTrace();\n                    assert(false);\n                    return plan;\n                }\n                if (left.equals(indexedExprs.get(searchKeyCount - 1))) {\n                    return plan;\n                }\n            }\n            if (!expr.getRight().equals(isp.getSearchKeyExpressions().get(searchKeyCount - 1))) {\n                return plan;\n            }\n            expr = predicates.get(1);\n            if (expr.getExpressionType() != ExpressionType.OPERATOR_NOT) {\n                return plan;\n            }\n            if (expr.getLeft().getExpressionType() != ExpressionType.OPERATOR_IS_NULL) {\n                return plan;\n            }\n            if (!expr.getLeft().getLeft().equals(predicates.get(0).getLeft())) {\n                return plan;\n            }\n        }\n\n        // With no start or end keys, there's not much a counting index can do.\n        if (isp.getEndExpression() == null && isp.getSearchKeyExpressions().size() == 0) {\n            // An indexed query without a where clause can fall back to a plain old table count.\n            // This can only happen when a confused query like\n            // \"select count(*) from table order by index_key;\"\n            // meets a naive planner that doesn't just cull the no-op ORDER BY. Who, us?\n            return new TableCountPlanNode(isp, aggplan);\n        }\n\n        // check for the index's support for counting\n        Index idx = isp.getCatalogIndex();\n        if ( ! idx.getCountable()) {\n            return plan;\n        }\n\n        // The core idea is that counting index needs to know the start key and end key to\n        // jump to to get counts instead of actually doing any scanning.\n        // Options to be determined are:\n        // - whether each of the start/end keys is missing, partial (a prefix of a compund key), or complete,\n        // - whether the count should include or exclude entries exactly matching each of the start/end keys.\n        // Not all combinations of these options are supported;\n        // unsupportable cases cause the factory method to return null.\n        IndexCountPlanNode countingPlan = IndexCountPlanNode.createOrNull(isp, aggplan);\n        if (countingPlan == null) {\n            return plan;\n        }\n        return countingPlan;\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testCover3ColumnsInOrderWithLessThanAndOrderBy()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b < ? order by b;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.GTE, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n    }","id":90511,"modified_method":"public void testCover3ColumnsInOrderWithLessThanAndOrderBy()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b < ? order by b;\");\n        pn = pn.getChild(0).getChild(0).getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testCover3ColumnsWithLessThanAndOrderBy()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b < ? order by b;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.GTE, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n    }","id":90512,"modified_method":"public void testCover3ColumnsWithLessThanAndOrderBy()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b < ? order by b;\");\n        pn = pn.getChild(0).getChild(0).getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testCover3ColumnsInOrderWithLessThan()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and c = ? and b < ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.GTE, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n    }","id":90513,"modified_method":"public void testCover3ColumnsInOrderWithLessThan()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and c = ? and b < ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testCover3ColumnsOutOfOrderWithLessThan()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and b = ? and c < ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER2_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.EQ, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n    }","id":90514,"modified_method":"public void testCover3ColumnsOutOfOrderWithLessThan()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and b = ? and c < ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"IDX_1\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testEng1023()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and b < ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER2_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.GTE, ispn.getLookupType());\n        assertEquals(1, ispn.getSearchKeyExpressions().size());\n    }","id":90515,"modified_method":"public void testEng1023()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and b < ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER2_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testOrderedMultiMultiIntGTEFailure()\n    throws IOException, ProcCallException\n    {\n        final Client client = getClient();\n        final VoltTable results[] = client.callProcedure(\"CheckMultiMultiIntGTEFailure\").getResults();\n        if (results == null) {\n            fail();\n        }\n        //\n        // Must pass 10 tests\n        //\n        assertEquals(10, results.length);\n\n        // Start off easy, with COUNT(*)s\n        // Actually, these exercise a different (counted index) code path which has experienced its own regressions.\n        // Test 1 -- count EQ first component of compound key\n        int tableI = 0;\n        final VoltTableRow countEQ = results[tableI].fetchRow(0);\n        assertEquals( 2, countEQ.getLong(0));\n\n        // Test 2 -- count GTE first component of compound key\n        tableI++;\n        final VoltTableRow countGT = results[tableI].fetchRow(0);\n        assertEquals( 3, countGT.getLong(0));\n\n        // Test 3 -- count GT first component of compound key\n        tableI++;\n        final VoltTableRow countGTE = results[tableI].fetchRow(0);\n        assertEquals( 1, countGTE.getLong(0));\n\n        // Test 4 -- count LTE first component of compound key\n        tableI++;\n        final VoltTableRow countLTE = results[tableI].fetchRow(0);\n        assertEquals( 3, countLTE.getLong(0));\n\n        // Test 5 -- count LT first component of compound key\n        tableI++;\n        final VoltTableRow countLT = results[tableI].fetchRow(0);\n        assertEquals( 1, countLT.getLong(0));\n\n        // Test 6 -- EQ first component of compound key\n        tableI++;\n        int rowI = 0;\n        assertEquals( 2, results[tableI].getRowCount());\n        final VoltTableRow rowEQ0 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowEQ0.getLong(0));\n        assertEquals( 0, rowEQ0.getLong(1));\n\n        final VoltTableRow rowEQ1 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowEQ1.getLong(0));\n        assertEquals( 1, rowEQ1.getLong(1));\n\n        // Test 7 -- GTE first component of compound key\n        tableI++;\n        rowI = 0;\n        assertEquals( 3, results[tableI].getRowCount());\n        final VoltTableRow rowGTE0 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowGTE0.getLong(0));\n        assertEquals( 0, rowGTE0.getLong(1));\n\n        final VoltTableRow rowGTE1 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowGTE1.getLong(0));\n        assertEquals( 1, rowGTE1.getLong(1));\n\n        final VoltTableRow rowGTE2 = results[tableI].fetchRow(rowI++);\n        assertEquals( 1, rowGTE2.getLong(0));\n        assertEquals( 1, rowGTE2.getLong(1));\n\n        // Test 8 -- GT first component of compound key\n        tableI++;\n        rowI = 0;\n        assertEquals( 1, results[tableI].getRowCount());\n        final VoltTableRow rowGT0 = results[tableI].fetchRow(rowI++);\n        assertEquals( 1, rowGT0.getLong(0));\n        assertEquals( 1, rowGT0.getLong(1));\n\n        // Test 9 -- LTE first component of compound key\n        tableI++;\n        rowI = 0;\n        assertEquals( 3, results[tableI].getRowCount());\n        final VoltTableRow rowLTE0 = results[tableI].fetchRow(rowI++);\n        assertEquals( -1, rowLTE0.getLong(0));\n        assertEquals( 0, rowLTE0.getLong(1));\n\n        final VoltTableRow rowLTE1 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowLTE1.getLong(0));\n        assertEquals( 0, rowLTE1.getLong(1));\n\n        final VoltTableRow rowLTE2 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowLTE2.getLong(0));\n        assertEquals( 1, rowLTE2.getLong(1));\n\n        // Test 10 -- LT first component of compound key\n        tableI++;\n        rowI = 0;\n        assertEquals( 1, results[tableI].getRowCount());\n        final VoltTableRow rowLT0 = results[tableI].fetchRow(rowI++);\n        assertEquals( -1, rowLT0.getLong(0));\n        assertEquals( 0, rowLT0.getLong(1));\n}","id":90516,"modified_method":"public void testOrderedMultiMultiIntGTEFailure()\n    throws IOException, ProcCallException\n    {\n        final Client client = getClient();\n        final VoltTable results[] = client.callProcedure(\"CheckMultiMultiIntGTEFailure\").getResults();\n        if (results == null) {\n            fail();\n        }\n        //\n        // Must pass 10 tests\n        //\n        assertEquals(10, results.length);\n\n        // Start off easy, with COUNT(*)s\n        // Actually, these exercise a different (counted index) code path which has experienced its own regressions.\n        // Test 1 -- count EQ first component of compound key\n        int tableI = 0;\n        final VoltTableRow countEQ = results[tableI].fetchRow(0);\n        assertEquals( 2, countEQ.getLong(0));\n\n        // Test 2 -- count GTE first component of compound key\n        tableI++;\n        final VoltTableRow countGT = results[tableI].fetchRow(0);\n        assertEquals( 3, countGT.getLong(0));\n\n        // Test 3 -- count GT first component of compound key\n        tableI++;\n        final VoltTableRow countGTE = results[tableI].fetchRow(0);\n        assertEquals( 1, countGTE.getLong(0));\n\n        // Test 4 -- count LTE first component of compound key\n        tableI++;\n        final VoltTableRow countLTE = results[tableI].fetchRow(0);\n        assertEquals( 3, countLTE.getLong(0));\n\n        // Test 5 -- count LT first component of compound key\n        tableI++;\n        final VoltTableRow countLT = results[tableI].fetchRow(0);\n        assertEquals( 1, countLT.getLong(0));\n\n        // Test 6 -- EQ first component of compound key\n        tableI++;\n        int rowI = 0;\n        assertEquals( 2, results[tableI].getRowCount());\n        final VoltTableRow rowEQ0 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowEQ0.getLong(0));\n        assertEquals( 0, rowEQ0.getLong(1));\n\n        final VoltTableRow rowEQ1 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowEQ1.getLong(0));\n        assertEquals( 1, rowEQ1.getLong(1));\n\n        // Test 7 -- GTE first component of compound key\n        tableI++;\n        rowI = 0;\n        assertEquals( 3, results[tableI].getRowCount());\n        final VoltTableRow rowGTE0 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowGTE0.getLong(0));\n        assertEquals( 0, rowGTE0.getLong(1));\n\n        final VoltTableRow rowGTE1 = results[tableI].fetchRow(rowI++);\n        assertEquals( 0, rowGTE1.getLong(0));\n        assertEquals( 1, rowGTE1.getLong(1));\n\n        final VoltTableRow rowGTE2 = results[tableI].fetchRow(rowI++);\n        assertEquals( 1, rowGTE2.getLong(0));\n        assertEquals( 1, rowGTE2.getLong(1));\n\n        // Test 8 -- GT first component of compound key\n        tableI++;\n        rowI = 0;\n        assertEquals( 1, results[tableI].getRowCount());\n        final VoltTableRow rowGT0 = results[tableI].fetchRow(rowI++);\n        assertEquals( 1, rowGT0.getLong(0));\n        assertEquals( 1, rowGT0.getLong(1));\n\n        // Test 9 -- LTE first component of compound key\n        tableI++;\n        rowI = 0;\n        assertEquals( 3, results[tableI].getRowCount());\n        // following won't work anymore after adding reserve scan\n        // because jni and hsql produce difference order result\n        // so, add them to a set and ignore the order instead\n        final VoltTableRow rowLTE0 = results[tableI].fetchRow(rowI++);\n//        assertEquals( -1, rowLTE0.getLong(0));\n//        assertEquals( 0, rowLTE0.getLong(1));\n//\n        final VoltTableRow rowLTE1 = results[tableI].fetchRow(rowI++);\n//        assertEquals( 0, rowLTE1.getLong(0));\n//        assertEquals( 0, rowLTE1.getLong(1));\n//\n        final VoltTableRow rowLTE2 = results[tableI].fetchRow(rowI++);\n//        assertEquals( 0, rowLTE2.getLong(0));\n//        assertEquals( 1, rowLTE2.getLong(1));\n\n        HashSet<Long> TID = new HashSet<Long>();\n        HashSet<Long> BID = new HashSet<Long>();\n        HashSet<Long> expectedTID = new HashSet<Long>();\n        HashSet<Long> expectedBID = new HashSet<Long>();\n\n        expectedTID.add(-1L);\n        expectedTID.add(0L);\n        expectedTID.add(0L);\n\n        expectedBID.add(0L);\n        expectedBID.add(0L);\n        expectedBID.add(1L);\n\n        TID.add(rowLTE0.getLong(0));\n        TID.add(rowLTE1.getLong(0));\n        TID.add(rowLTE2.getLong(0));\n        BID.add(rowLTE0.getLong(1));\n        BID.add(rowLTE1.getLong(1));\n        BID.add(rowLTE2.getLong(1));\n\n        assertTrue(TID.equals(expectedTID));\n        assertTrue(BID.equals(expectedBID));\n\n        // Test 10 -- LT first component of compound key\n        tableI++;\n        rowI = 0;\n        assertEquals( 1, results[tableI].getRowCount());\n        final VoltTableRow rowLT0 = results[tableI].fetchRow(rowI++);\n        assertEquals( -1, rowLT0.getLong(0));\n        assertEquals( 0, rowLT0.getLong(1));\n}","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testDistributedIndexJoinConditions() {\n        // Distributed outer table, replicated inner -NLIJ/inlined IndexScan\n        AbstractPlanNode pn = compile(\"select * FROM P1 LEFT JOIN R3 ON P1.C = R3.A\");\n        AbstractPlanNode n = pn.getChild(0).getChild(0);\n        assertTrue(n instanceof NestLoopIndexPlanNode);\n        NestLoopIndexPlanNode nl = (NestLoopIndexPlanNode) n;\n        assertTrue(nl.getChildCount() == 1);\n        assertTrue(nl.getChild(0) instanceof ReceivePlanNode);\n\n        // Distributed inner  and replicated outer tables -NLJ/IndexScan\n        List<AbstractPlanNode> lpn = compileToFragments(\"select *  FROM R3 LEFT JOIN P2 ON R3.A = P2.A AND P2.A < 0 AND P2.E > 3 WHERE P2.A IS NULL\");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(0).getChild(0).getChild(0);\n        assertTrue(n instanceof NestLoopPlanNode);\n        assertTrue(JoinType.LEFT == ((NestLoopPlanNode) n).getJoinType());\n        assertTrue(((NestLoopPlanNode) n).getJoinPredicate() != null);\n        assertTrue(((NestLoopPlanNode) n).getWherePredicate() != null);\n        AbstractPlanNode c = n.getChild(0);\n        assertTrue(c instanceof SeqScanPlanNode);\n        c = n.getChild(1);\n        assertTrue(c instanceof ReceivePlanNode);\n        n = lpn.get(1).getChild(0);\n        assertTrue(n instanceof IndexScanPlanNode);\n        IndexScanPlanNode in = (IndexScanPlanNode) n;\n        assertTrue(in.getPredicate() != null);\n        assertTrue(ExpressionType.COMPARE_GREATERTHAN == in.getPredicate().getExpressionType());\n        assertTrue(IndexLookupType.GTE == in.getLookupType());\n\n        // Distributed inner  and outer tables -NLIJ/inlined IndexScan\n        lpn = compileToFragments(\"select *  FROM P2 RIGHT JOIN P3 ON P3.A = P2.A AND P2.A < 0 WHERE P2.A IS NULL\");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(1).getChild(0);\n        assertTrue(n instanceof NestLoopIndexPlanNode);\n        assertTrue(JoinType.LEFT == ((NestLoopIndexPlanNode) n).getJoinType());\n        assertTrue(((NestLoopIndexPlanNode) n).getJoinPredicate() == null);\n        assertTrue(((NestLoopIndexPlanNode) n).getWherePredicate() != null);\n        AbstractExpression w = ((NestLoopIndexPlanNode) n).getWherePredicate();\n        assertTrue(ExpressionType.OPERATOR_IS_NULL == w.getExpressionType());\n        IndexScanPlanNode indexScan = (IndexScanPlanNode)n.getInlinePlanNode(PlanNodeType.INDEXSCAN);\n        assertTrue(indexScan.getLookupType().equals(IndexLookupType.EQ));\n        assertTrue(ExpressionType.COMPARE_EQUAL == indexScan.getEndExpression().getExpressionType());\n        w = indexScan.getPredicate();\n        assertTrue(w != null);\n        assertTrue(w.getExpressionType() == ExpressionType.COMPARE_LESSTHAN);\n    }","id":90517,"modified_method":"public void testDistributedIndexJoinConditions() {\n        // Distributed outer table, replicated inner -NLIJ/inlined IndexScan\n        AbstractPlanNode pn = compile(\"select * FROM P1 LEFT JOIN R3 ON P1.C = R3.A\");\n        AbstractPlanNode n = pn.getChild(0).getChild(0);\n        assertTrue(n instanceof NestLoopIndexPlanNode);\n        NestLoopIndexPlanNode nl = (NestLoopIndexPlanNode) n;\n        assertTrue(nl.getChildCount() == 1);\n        assertTrue(nl.getChild(0) instanceof ReceivePlanNode);\n\n        // Distributed inner  and replicated outer tables -NLJ/IndexScan\n        List<AbstractPlanNode> lpn = compileToFragments(\"select *  FROM R3 LEFT JOIN P2 ON R3.A = P2.A AND P2.A < 0 AND P2.E > 3 WHERE P2.A IS NULL\");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(0).getChild(0).getChild(0);\n        assertTrue(n instanceof NestLoopPlanNode);\n        assertTrue(JoinType.LEFT == ((NestLoopPlanNode) n).getJoinType());\n        assertTrue(((NestLoopPlanNode) n).getJoinPredicate() != null);\n        assertTrue(((NestLoopPlanNode) n).getWherePredicate() != null);\n        AbstractPlanNode c = n.getChild(0);\n        assertTrue(c instanceof SeqScanPlanNode);\n        c = n.getChild(1);\n        assertTrue(c instanceof ReceivePlanNode);\n        n = lpn.get(1).getChild(0);\n        assertTrue(n instanceof IndexScanPlanNode);\n        IndexScanPlanNode in = (IndexScanPlanNode) n;\n        assertTrue(in.getPredicate() != null);\n        assertTrue(ExpressionType.CONJUNCTION_AND == in.getPredicate().getExpressionType());\n        assertTrue(IndexLookupType.LT == in.getLookupType());\n\n        // Distributed inner  and outer tables -NLIJ/inlined IndexScan\n        lpn = compileToFragments(\"select *  FROM P2 RIGHT JOIN P3 ON P3.A = P2.A AND P2.A < 0 WHERE P2.A IS NULL\");\n        assertTrue(lpn.size() == 2);\n        n = lpn.get(1).getChild(0);\n        assertTrue(n instanceof NestLoopIndexPlanNode);\n        assertTrue(JoinType.LEFT == ((NestLoopIndexPlanNode) n).getJoinType());\n        assertTrue(((NestLoopIndexPlanNode) n).getJoinPredicate() == null);\n        assertTrue(((NestLoopIndexPlanNode) n).getWherePredicate() != null);\n        AbstractExpression w = ((NestLoopIndexPlanNode) n).getWherePredicate();\n        assertTrue(ExpressionType.OPERATOR_IS_NULL == w.getExpressionType());\n        IndexScanPlanNode indexScan = (IndexScanPlanNode)n.getInlinePlanNode(PlanNodeType.INDEXSCAN);\n        assertTrue(indexScan.getLookupType().equals(IndexLookupType.EQ));\n        assertTrue(ExpressionType.COMPARE_EQUAL == indexScan.getEndExpression().getExpressionType());\n        w = indexScan.getPredicate();\n        assertTrue(w != null);\n        assertTrue(w.getExpressionType() == ExpressionType.COMPARE_LESSTHAN);\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testOrderDescWithEquality() {\n        validatePlan(\"SELECT * FROM T WHERE T_D0 = 2 ORDER BY T_D1 DESC\", true, false, true, false);\n    }","id":90518,"modified_method":"public void testOrderDescWithEquality() {\n        validatePlan(\"SELECT * FROM T WHERE T_D0 = 2 ORDER BY T_D1 DESC\", true, false, false, false);\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void validatePlan(String sql, boolean expectIndexScan, boolean expectSeqScan, boolean expectOrderBy, boolean expectHashAggregate)\n    {\n        AbstractPlanNode pn = compile(sql);\n        assertEquals(expectIndexScan, pn.hasAnyNodeOfType(PlanNodeType.INDEXSCAN));\n        assertEquals(expectSeqScan, pn.hasAnyNodeOfType(PlanNodeType.SEQSCAN));\n        assertEquals(expectOrderBy, pn.hasAnyNodeOfType(PlanNodeType.ORDERBY));\n        assertEquals(expectHashAggregate, pn.hasAnyNodeOfType(PlanNodeType.HASHAGGREGATE));\n    }","id":90519,"modified_method":"private void validatePlan(String sql, boolean expectIndexScan, boolean expectSeqScan, boolean expectOrderBy, boolean expectHashAggregate)\n    {\n        AbstractPlanNode pn = compile(sql);\n        System.out.println(pn.getChild(0).toJSONString());\n        assertEquals(expectIndexScan, pn.hasAnyNodeOfType(PlanNodeType.INDEXSCAN));\n        assertEquals(expectSeqScan, pn.hasAnyNodeOfType(PlanNodeType.SEQSCAN));\n        assertEquals(expectOrderBy, pn.hasAnyNodeOfType(PlanNodeType.ORDERBY));\n        assertEquals(expectHashAggregate, pn.hasAnyNodeOfType(PlanNodeType.HASHAGGREGATE));\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test002()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and c = ? and b < ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","id":90520,"modified_method":"public void test002()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and c = ? and b < ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test005()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and c = ? and b <= ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LTE, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(3, ExpressionUtil.uncombine(ispn.getInitialExpression()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","id":90521,"modified_method":"public void test005()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and c = ? and b <= ?;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LTE, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(3, ExpressionUtil.uncombine(ispn.getInitialExpression()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test0031()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b < ? order by b;\");\n        pn = pn.getChild(0).getChild(0).getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","id":90522,"modified_method":"public void test0031()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b < ? order by b;\");\n        pn = pn.getChild(0).getChild(0).getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test0062()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b <= ? order by b desc;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LTE, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(3, ExpressionUtil.uncombine(ispn.getInitialExpression()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","id":90523,"modified_method":"public void test0062()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b <= ? order by b desc;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LTE, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(3, ExpressionUtil.uncombine(ispn.getInitialExpression()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test001()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and b < ?\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER2_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","id":90524,"modified_method":"public void test001()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and b < ?\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER2_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test0032()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b < ? order by b desc;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","id":90525,"modified_method":"public void test0032()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b < ? order by b desc;\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LT, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test0061()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b <= ? order by b;\");\n        pn = pn.getChild(0).getChild(0).getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LTE, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(3, ExpressionUtil.uncombine(ispn.getInitialExpression()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","id":90526,"modified_method":"public void test0061()\n    {\n        AbstractPlanNode pn = compile(\"select a, b from t where a = ? and c = ? and b <= ? order by b;\");\n        pn = pn.getChild(0).getChild(0).getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER3_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LTE, ispn.getLookupType());\n        assertEquals(3, ispn.getSearchKeyExpressions().size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(3, ExpressionUtil.uncombine(ispn.getInitialExpression()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void test004()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and b <= ?\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER2_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LTE, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getInitialExpression()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","id":90527,"modified_method":"public void test004()\n    {\n        AbstractPlanNode pn = compile(\"select a from t where a = ? and b <= ?\");\n        pn = pn.getChild(0);\n        if (pn != null) {\n            System.out.println(pn.toJSONString());\n        }\n        assertTrue(pn instanceof IndexScanPlanNode);\n        IndexScanPlanNode ispn = (IndexScanPlanNode)pn;\n        assertEquals(\"COVER2_TREE\", ispn.getTargetIndexName());\n        assertEquals(IndexLookupType.LTE, ispn.getLookupType());\n        assertEquals(2, ispn.getSearchKeyExpressions().size());\n        assertEquals(1, ExpressionUtil.uncombine(ispn.getEndExpression()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getPredicate()).size());\n        assertEquals(2, ExpressionUtil.uncombine(ispn.getInitialExpression()).size());\n        assertEquals(SortDirectionType.DESC, ispn.getSortDirection());\n    }","commit_id":"f837a0eb734a543d9683b84e52060e38416fa87f","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testStuff() throws Exception {\n\t\tIndexAwareResourceSet set = get(IndexAwareResourceSet.class);\n\t\tset.setClasspathURIContext(IndexAwareResourcesetTest.class);\n\t\tURI uri = URI.createURI(\"classpath:/\" + getClass().getName().replace('.', '/')\n\t\t\t\t+ \".importuritestlanguage\");\n\t\tset.getResource(uri, true);\n\t\tIterator<EObjectDescriptor> result = set.getStore().eObjectDAO().createQuery().executeListResult()\n\t\t\t\t.iterator();\n\t\tList<String> names = new ArrayList<String>();\n\t\tnames.add(result.next().getName());\n\t\tnames.add(result.next().getName());\n\t\tassertFalse(result.hasNext());\n\t\t\n\t\tassertTrue(names.contains(\"A\"));\n\t\tassertTrue(names.contains(\"B\"));\n\t\t\n\t\tIterator<ECrossReferenceDescriptor> iter = set.getStore().eCrossReferenceDAO().createQuery().executeListResult().iterator();\n\t\tECrossReferenceDescriptor next = iter.next();\n\t\tassertEquals(\"B\",next.getSource().getName());\n\t\tassertEquals(\"A\",next.getTarget().getName());\n\t}","id":90528,"modified_method":"public void testStuff() throws Exception {\n\t\tIndexAwareResourceSet set = get(IndexAwareResourceSet.class);\n\t\tset.setClasspathURIContext(IndexAwareResourcesetTest.class);\n\t\tURI uri = URI.createURI(\"classpath:/\" + getClass().getName().replace('.', '/') + \".importuritestlanguage\");\n\t\tset.getResource(uri, true);\n\t\tIterable<EObjectDescriptor> query = set.getStore().eObjectDAO().createQuery().executeListResult();\n\t\tIterator<EObjectDescriptor> result = query.iterator();\n\t\tList<String> names = new ArrayList<String>();\n\t\tnames.add(result.next().getName());\n\t\tnames.add(result.next().getName());\n\t\tassertFalse(result.hasNext());\n\n\t\tassertTrue(names.contains(\"A\"));\n\t\tassertTrue(names.contains(\"B\"));\n\n\t\tresult = query.iterator();\n\t\tList<URI> uris = new ArrayList<URI>();\n\t\turis.add(result.next().getFragmentURI());\n\t\turis.add(result.next().getFragmentURI());\n\t\t\n\t\tIterator<ECrossReferenceDescriptor> iter = set.getStore().eCrossReferenceDAO().createQuery()\n\t\t\t\t.executeListResult().iterator();\n\t\tECrossReferenceDescriptor next = iter.next();\n\t\tassertTrue(uris.contains(next.getSourceURI()));\n\t\tassertTrue(uris.contains(next.getTargetURI()));\n\t}","commit_id":"2fadefd829b7f8708b2eaa1baca0cb59cf01ac4f","url":"https://github.com/eclipse/xtext"},{"original_method":"/** Test when input path is a directory */\n  @Test\n  public void testDirectory() throws IOException {\n    fs.mkdirs(DIR1);\n\n    // test empty directory\n    RemoteIterator<LocatedFileStatus> itor = fs.listFiles(\n        DIR1, true);\n    assertFalse(itor.hasNext());\n    itor = fs.listFiles(DIR1, false);\n    assertFalse(itor.hasNext());\n    \n    // testing directory with 1 file\n    writeFile(fs, FILE2, FILE_LEN);    \n    itor = fs.listFiles(DIR1, true);\n    LocatedFileStatus stat = itor.next();\n    assertFalse(itor.hasNext());\n    assertTrue(stat.isFile());\n    assertEquals(FILE_LEN, stat.getLen());\n    assertEquals(fs.makeQualified(FILE2), stat.getPath());\n    assertEquals(1, stat.getBlockLocations().length);\n    \n    itor = fs.listFiles(DIR1, false);\n    stat = itor.next();\n    assertFalse(itor.hasNext());\n    assertTrue(stat.isFile());\n    assertEquals(FILE_LEN, stat.getLen());\n    assertEquals(fs.makeQualified(FILE2), stat.getPath());\n    assertEquals(1, stat.getBlockLocations().length);\n\n    // test more complicated directory\n    writeFile(fs, FILE1, FILE_LEN);\n    writeFile(fs, FILE3, FILE_LEN);\n\n    itor = fs.listFiles(TEST_DIR, true);\n    stat = itor.next();\n    assertTrue(stat.isFile());\n    assertEquals(fs.makeQualified(FILE2), stat.getPath());\n    stat = itor.next();\n    assertTrue(stat.isFile());\n    assertEquals(fs.makeQualified(FILE3), stat.getPath());\n    stat = itor.next();\n    assertTrue(stat.isFile());\n    assertEquals(fs.makeQualified(FILE1), stat.getPath());\n    assertFalse(itor.hasNext());\n    \n    itor = fs.listFiles(TEST_DIR, false);\n    stat = itor.next();\n    assertTrue(stat.isFile());\n    assertEquals(fs.makeQualified(FILE1), stat.getPath());\n    assertFalse(itor.hasNext());\n    \n    fs.delete(TEST_DIR, true);\n  }","id":90529,"modified_method":"/** Test when input path is a directory */\n  @Test\n  public void testDirectory() throws IOException {\n    fs.mkdirs(DIR1);\n\n    // test empty directory\n    RemoteIterator<LocatedFileStatus> itor = fs.listFiles(\n        DIR1, true);\n    assertFalse(itor.hasNext());\n    itor = fs.listFiles(DIR1, false);\n    assertFalse(itor.hasNext());\n    \n    // testing directory with 1 file\n    writeFile(fs, FILE2, FILE_LEN);    \n    itor = fs.listFiles(DIR1, true);\n    LocatedFileStatus stat = itor.next();\n    assertFalse(itor.hasNext());\n    assertTrue(stat.isFile());\n    assertEquals(FILE_LEN, stat.getLen());\n    assertEquals(fs.makeQualified(FILE2), stat.getPath());\n    assertEquals(1, stat.getBlockLocations().length);\n    \n    itor = fs.listFiles(DIR1, false);\n    stat = itor.next();\n    assertFalse(itor.hasNext());\n    assertTrue(stat.isFile());\n    assertEquals(FILE_LEN, stat.getLen());\n    assertEquals(fs.makeQualified(FILE2), stat.getPath());\n    assertEquals(1, stat.getBlockLocations().length);\n\n    // test more complicated directory\n    writeFile(fs, FILE1, FILE_LEN);\n    writeFile(fs, FILE3, FILE_LEN);\n\n    Set<Path> filesToFind = new HashSet<Path>();\n    filesToFind.add(fs.makeQualified(FILE1));\n    filesToFind.add(fs.makeQualified(FILE2));\n    filesToFind.add(fs.makeQualified(FILE3));\n\n    itor = fs.listFiles(TEST_DIR, true);\n    stat = itor.next();\n    assertTrue(stat.isFile());\n    assertTrue(\"Path \" + stat.getPath() + \" unexpected\",\n      filesToFind.remove(stat.getPath()));\n\n    stat = itor.next();\n    assertTrue(stat.isFile());\n    assertTrue(\"Path \" + stat.getPath() + \" unexpected\",\n      filesToFind.remove(stat.getPath()));\n\n    stat = itor.next();\n    assertTrue(stat.isFile());\n    assertTrue(\"Path \" + stat.getPath() + \" unexpected\",\n      filesToFind.remove(stat.getPath()));\n    assertFalse(itor.hasNext());\n    assertTrue(filesToFind.isEmpty());\n    \n    itor = fs.listFiles(TEST_DIR, false);\n    stat = itor.next();\n    assertTrue(stat.isFile());\n    assertEquals(fs.makeQualified(FILE1), stat.getPath());\n    assertFalse(itor.hasNext());\n    \n    fs.delete(TEST_DIR, true);\n  }","commit_id":"a503521a2c0ec6c4ea42436e707563cef381da32","url":"https://github.com/apache/hadoop"},{"original_method":"public void testStuff() throws Exception {\n\t\tIndexAwareResourceSet set = get(IndexAwareResourceSet.class);\n\t\tset.setClasspathURIContext(IndexAwareResourcesetTest.class);\n\t\tURI uri = URI.createURI(\"classpath:/\" + getClass().getName().replace('.', '/')\n\t\t\t\t+ \".importuritestlanguage\");\n\t\tset.getResource(uri, true);\n\t\tIterator<EObjectDescriptor> result = set.getStore().eObjectDAO().createQuery().executeListResult()\n\t\t\t\t.iterator();\n\t\tList<String> names = new ArrayList<String>();\n\t\tnames.add(result.next().getName());\n\t\tnames.add(result.next().getName());\n\t\tassertFalse(result.hasNext());\n\t\t\n\t\tassertTrue(names.contains(\"A\"));\n\t\tassertTrue(names.contains(\"B\"));\n\t\t\n\t\tIterator<ECrossReferenceDescriptor> iter = set.getStore().eCrossReferenceDAO().createQuery().executeListResult().iterator();\n\t\tECrossReferenceDescriptor next = iter.next();\n\t\tassertEquals(\"B\",next.getSource().getName());\n\t\tassertEquals(\"A\",next.getTarget().getName());\n\t}","id":90530,"modified_method":"public void testStuff() throws Exception {\n\t\tIndexAwareResourceSet set = get(IndexAwareResourceSet.class);\n\t\tset.setClasspathURIContext(IndexAwareResourcesetTest.class);\n\t\tURI uri = URI.createURI(\"classpath:/\" + getClass().getName().replace('.', '/') + \".importuritestlanguage\");\n\t\tset.getResource(uri, true);\n\t\tIterable<EObjectDescriptor> query = set.getStore().eObjectDAO().createQuery().executeListResult();\n\t\tIterator<EObjectDescriptor> result = query.iterator();\n\t\tList<String> names = new ArrayList<String>();\n\t\tnames.add(result.next().getName());\n\t\tnames.add(result.next().getName());\n\t\tassertFalse(result.hasNext());\n\n\t\tassertTrue(names.contains(\"A\"));\n\t\tassertTrue(names.contains(\"B\"));\n\n\t\tresult = query.iterator();\n\t\tList<URI> uris = new ArrayList<URI>();\n\t\turis.add(result.next().getFragmentURI());\n\t\turis.add(result.next().getFragmentURI());\n\t\t\n\t\tIterator<ECrossReferenceDescriptor> iter = set.getStore().eCrossReferenceDAO().createQuery()\n\t\t\t\t.executeListResult().iterator();\n\t\tECrossReferenceDescriptor next = iter.next();\n\t\tassertTrue(uris.contains(next.getSourceURI()));\n\t\tassertTrue(uris.contains(next.getTargetURI()));\n\t}","commit_id":"3fa105f303088979491f547d00612c38836436e7","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic String render(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows PortletException {\n\n\t\tRequestDispatcher requestDispatcher =\n\t\t\t_servletContext.getRequestDispatcher(_JSP_PATH);\n\n\t\ttry {\n\t\t\tHttpServletRequest httpServletRequest =\n\t\t\t\tPortalUtil.getHttpServletRequest(renderRequest);\n\n\t\t\tHttpServletResponse httpServletResponse =\n\t\t\t\tPortalUtil.getHttpServletResponse(renderResponse);\n\n\t\t\trequestDispatcher.include(httpServletRequest, httpServletResponse);\n\t\t}\n\t\tcatch (Exception se) {\n\t\t\t_log.error(\"Unable to include JSP \" + _JSP_PATH, se);\n\n\t\t\tthrow new PortletException(\n\t\t\t\t\"Unable to include JSP \" + _JSP_PATH, se);\n\t\t}\n\n\t\treturn MVC_PATH_SKIP_DISPATCH;\n\t}","id":90531,"modified_method":"@Override\n\tpublic String render(\n\t\t\tRenderRequest renderRequest, RenderResponse renderResponse)\n\t\tthrows PortletException {\n\n\t\ttry {\n\t\t\tRequestDispatcher requestDispatcher =\n\t\t\t\t_servletContext.getRequestDispatcher(_JSP_PATH);\n\n\t\t\tHttpServletRequest httpServletRequest =\n\t\t\t\tPortalUtil.getHttpServletRequest(renderRequest);\n\t\t\tHttpServletResponse httpServletResponse =\n\t\t\t\tPortalUtil.getHttpServletResponse(renderResponse);\n\n\t\t\trequestDispatcher.include(httpServletRequest, httpServletResponse);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Unable to include JSP \" + _JSP_PATH, e);\n\t\t\t}\n\n\t\t\tthrow new PortletException(\n\t\t\t\t\"Unable to include JSP \" + _JSP_PATH, e);\n\t\t}\n\n\t\treturn MVC_PATH_SKIP_DISPATCH;\n\t}","commit_id":"038d80a0b2128f9291dd0b4192e35406047e3ebe","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\r\n     * Starts the address book service.\r\n     */\r\n    static void startService()\r\n    {\r\n        /* Register the ContactSourceService implementation (if any). */\r\n        String cssClassName;\r\n\r\n        if (OSUtils.IS_WINDOWS\r\n            && getConfigService().getBoolean(\r\n                PNAME_ENABLE_MICROSOFT_OUTLOOK_SEARCH, true))\r\n\r\n        {\r\n            cssClassName\r\n                = \"net.java.sip.communicator.plugin.addrbook\"\r\n                    + \".msoutlook.MsOutlookAddrBookContactSourceService\";\r\n        }\r\n        else if (OSUtils.IS_MAC\r\n                    && getConfigService().getBoolean(\r\n                        PNAME_ENABLE_MACOSX_ADDRESS_BOOK_SEARCH, true))\r\n        {\r\n            cssClassName\r\n                = \"net.java.sip.communicator.plugin.addrbook\"\r\n                    + \".macosx.MacOSXAddrBookContactSourceService\";\r\n        }\r\n        else\r\n            return;\r\n\r\n        try\r\n        {\r\n            css\r\n                = (ContactSourceService)\r\n                    Class.forName(cssClassName).newInstance();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            logger.error(\"Failed to instantiate \" + cssClassName, ex);\r\n            return;\r\n        }\r\n        try\r\n        {\r\n            cssServiceRegistration\r\n                = bundleContext.registerService(\r\n                        ContactSourceService.class.getName(),\r\n                        css,\r\n                        null);\r\n        }\r\n        finally\r\n        {\r\n            if (cssServiceRegistration == null)\r\n            {\r\n                if (css instanceof AsyncContactSourceService)\r\n                    ((AsyncContactSourceService) css).stop();\r\n                css = null;\r\n            }\r\n        }\r\n    }","id":90532,"modified_method":"/**\r\n     * Starts the address book service.\r\n     */\r\n    static void startService()\r\n    {\r\n        /* Register the ContactSourceService implementation (if any). */\r\n        String cssClassName;\r\n\r\n        if (OSUtils.IS_WINDOWS\r\n            && getConfigService().getBoolean(\r\n                PNAME_ENABLE_MICROSOFT_OUTLOOK_SEARCH, true))\r\n\r\n        {\r\n            cssClassName\r\n                = \"net.java.sip.communicator.plugin.addrbook\"\r\n                    + \".msoutlook.MsOutlookAddrBookContactSourceService\";\r\n        }\r\n        else if (OSUtils.IS_MAC\r\n                    && getConfigService().getBoolean(\r\n                        PNAME_ENABLE_MACOSX_ADDRESS_BOOK_SEARCH, true))\r\n        {\r\n            cssClassName\r\n                = \"net.java.sip.communicator.plugin.addrbook\"\r\n                    + \".macosx.MacOSXAddrBookContactSourceService\";\r\n        }\r\n        else\r\n            return;\r\n\r\n        try\r\n        {\r\n            css\r\n                = (ContactSourceService)\r\n                    Class.forName(cssClassName).newInstance();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            logger.error(\"Failed to instantiate \" + cssClassName + \" reason:\"\r\n                + ex.getMessage());\r\n\r\n            if(logger.isDebugEnabled())\r\n                logger.debug(\"Failed to instantiate \" + cssClassName, ex);\r\n            return;\r\n        }\r\n        try\r\n        {\r\n            cssServiceRegistration\r\n                = bundleContext.registerService(\r\n                        ContactSourceService.class.getName(),\r\n                        css,\r\n                        null);\r\n        }\r\n        finally\r\n        {\r\n            if (cssServiceRegistration == null)\r\n            {\r\n                if (css instanceof AsyncContactSourceService)\r\n                    ((AsyncContactSourceService) css).stop();\r\n                css = null;\r\n            }\r\n        }\r\n    }","commit_id":"19edeb6f0c60c88d4eb1e6eb81b2fbb3b316c8a5","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n\tpublic void clearQuerySuggestionDictionaryIndexes(\n\t\t\tSearchContext searchContext)\n\t\tthrows SearchException {\n\n\t\tStringBundler sb = getDeleteQuery(searchContext, QUERY_SUGGESTION_TYPE);\n\n\t\ttry {\n\t\t\t_solrServer.deleteByQuery(sb.toString());\n\n\t\t\tif (_commit) {\n\t\t\t\t_solrServer.commit();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new SearchException(e.getMessage());\n\t\t}\n\t}","id":90533,"modified_method":"@Override\n\tpublic void clearQuerySuggestionDictionaryIndexes(\n\t\t\tSearchContext searchContext)\n\t\tthrows SearchException {\n\n\t\tString deleteQuery = createDeleteQuery(\n\t\t\tsearchContext, QUERY_SUGGESTION_TYPE);\n\n\t\ttry {\n\t\t\t_solrServer.deleteByQuery(deleteQuery);\n\n\t\t\tif (_commit) {\n\t\t\t\t_solrServer.commit();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(e, e);\n\t\t\t}\n\n\t\t\tthrow new SearchException(e.getMessage(), e);\n\t\t}\n\t}","commit_id":"85cb36453d5da71ad2ed81c9aa69a7493b52ccf9","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic void clearSpellCheckerDictionaryIndexes(SearchContext searchContext)\n\t\tthrows SearchException {\n\n\t\tStringBundler sb = getDeleteQuery(searchContext, SPELL_CHECKER_TYPE);\n\n\t\ttry {\n\t\t\t_solrServer.deleteByQuery(sb.toString());\n\n\t\t\tif (_commit) {\n\t\t\t\t_solrServer.commit();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e, e);\n\n\t\t\tthrow new SearchException(e.getMessage());\n\t\t}\n\n\t}","id":90534,"modified_method":"@Override\n\tpublic void clearSpellCheckerDictionaryIndexes(SearchContext searchContext)\n\t\tthrows SearchException {\n\n\t\tString deleteQuery = createDeleteQuery(\n\t\t\tsearchContext, SPELL_CHECKER_TYPE);\n\n\t\ttry {\n\t\t\t_solrServer.deleteByQuery(deleteQuery);\n\n\t\t\tif (_commit) {\n\t\t\t\t_solrServer.commit();\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(e, e);\n\t\t\t}\n\n\t\t\tthrow new SearchException(e.getMessage(), e);\n\t\t}\n\n\t}","commit_id":"85cb36453d5da71ad2ed81c9aa69a7493b52ccf9","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected StringBundler getDeleteQuery(\n\t\tSearchContext searchContext, String type) {\n\n\t\tStringBundler sb = new StringBundler(14);\n\n\t\tsb.append(StringPool.PLUS);\n\t\tsb.append(Field.COMPANY_ID);\n\t\tsb.append(StringPool.COLON);\n\t\tsb.append(searchContext.getCompanyId());\n\t\taddQuerySeparator(sb);\n\t\tsb.append(Field.PORTLET_ID);\n\t\tsb.append(StringPool.COLON);\n\t\tsb.append(PortletKeys.SEARCH);\n\t\taddQuerySeparator(sb);\n\n\t\taddTypeQuery(sb, type);\n\n\t\treturn sb;\n\t}","id":90535,"modified_method":"protected String createDeleteQuery(\n\t\tSearchContext searchContext, String type) {\n\n\t\tStringBundler sb = new StringBundler(14);\n\n\t\tsb.append(StringPool.PLUS);\n\t\tsb.append(Field.COMPANY_ID);\n\t\tsb.append(StringPool.COLON);\n\t\tsb.append(searchContext.getCompanyId());\n\n\t\taddQuerySeparator(sb);\n\n\t\tsb.append(Field.PORTLET_ID);\n\t\tsb.append(StringPool.COLON);\n\t\tsb.append(PortletKeys.SEARCH);\n\n\t\taddQuerySeparator(sb);\n\n\t\taddTypeQuery(sb, type);\n\n\t\treturn sb.toString();\n\t}","commit_id":"85cb36453d5da71ad2ed81c9aa69a7493b52ccf9","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n  protected void publish(MetricsScope scope, Iterator<MetricsRecord> metrics) throws Exception {\n    while (metrics.hasNext()) {\n      MetricsRecord record = metrics.next();\n      String context = record.getContext();\n\n      // Context is expected to look like appId.b.programId.[m|r].[taskId]\n      String counterGroup;\n      String contextParts[] = splitPattern.split(context);\n      if (contextParts.length < 4) {\n        // using context name as counter group for \"unknown\"\n        counterGroup = \"continuuity.\" + context;\n      } else if (\"m\".equals(contextParts[3])) {\n        counterGroup = \"continuuity.mapper\";\n      } else if (\"r\".equals(contextParts[3])) {\n        counterGroup = \"continuuity.reducer\";\n      } else {\n        LOG.error(\"could not determine if the metric is a map or reduce metric from context {}, skipping...\", context);\n        continue;\n      }\n\n      counterGroup += \".\" + scope.name();\n\n      String counterName = getCounterName(record.getName());\n      taskContext.getCounter(counterGroup, counterName).increment(record.getValue());\n      for (TagMetric tag : record.getTags()) {\n        counterName = getCounterName(record.getName(), tag.getTag());\n        taskContext.getCounter(counterGroup, counterName).increment(tag.getValue());\n      }\n    }\n  }","id":90536,"modified_method":"@Override\n  protected void publish(MetricsScope scope, Iterator<MetricsRecord> metrics) throws Exception {\n    while (metrics.hasNext()) {\n      MetricsRecord record = metrics.next();\n      String context = record.getContext();\n\n      // Context is expected to look like appId.b.programId.[m|r].[taskId]\n      String counterGroup;\n      String contextParts[] = splitPattern.split(context);\n      if (contextParts.length < 4) {\n        // using context name as counter group for \"unknown\"\n        counterGroup = \"continuuity.\" + context;\n      } else if (\"m\".equals(contextParts[3])) {\n        counterGroup = \"continuuity.mapper\";\n      } else if (\"r\".equals(contextParts[3])) {\n        counterGroup = \"continuuity.reducer\";\n      } else {\n        LOG.error(\"could not determine if the metric is a map or reduce metric from context {}, skipping...\", context);\n        continue;\n      }\n\n      counterGroup += \".\" + scope.name();\n\n      String counterName = getCounterName(record.getName());\n      taskContext.getCounter(counterGroup, counterName).increment(record.getValue());\n      for (TagMetric tag : record.getTags()) {\n        counterName = getCounterName(record.getName(), tag.getTag());\n        if (counterName != null) {\n          taskContext.getCounter(counterGroup, counterName).increment(tag.getValue());\n        }\n      }\n    }\n  }","commit_id":"3befa6f2c4ca3a7ca8e653b138bbd27a88fecdd9","url":"https://github.com/caskdata/cdap"},{"original_method":"private String getCounterName(String metric, String tag) {\n    JsonObject name = new JsonObject();\n    name.addProperty(\"metric\", metric);\n    if (tag != null) {\n      name.addProperty(\"tag\", tag);\n    }\n    return name.toString();\n  }","id":90537,"modified_method":"private String getCounterName(String metric, String tag) {\n    if (tag == null) {\n      return metric;\n    } else {\n      return metric + \",\" + tag;\n    }\n  }","commit_id":"3befa6f2c4ca3a7ca8e653b138bbd27a88fecdd9","url":"https://github.com/caskdata/cdap"},{"original_method":"private void reportContinuuityStats(Iterable<Counter> counters, MetricsCollector collector, MetricsScope scope,\n                                         Table<MetricsScope, String, Integer> previousStats) {\n\n    // we don't want to overcount the untagged version of the metric.  For example.  If \"metric\":\"store.bytes\"\n    // comes in with \"tag\":\"dataset1\" and value 10, we will also have another counter for just the metric without the\n    // tag, also with value 10.  If we gauge both of them with their values, the final count sent off to the metrics\n    // system for the untagged metric will be 20 instead of 10.  So we need to keep track of the sum of the tagged\n    // values so that we can adjust accordingly.\n    Map<String, Integer> metricTagValues = Maps.newHashMap();\n    Map<String, Integer> metricUntaggedValues = Maps.newHashMap();\n\n    for (Counter counter : counters) {\n\n      // mapred counters are running counters whereas our metrics timeseries and aggregates make more\n      // sense as incremental numbers.  So we want to subtract the current counter value from the previous before\n      // emitting to the metrics system.\n      int emitValue = calcDiffAndSetTableValue(previousStats, scope, counter.getName(), counter.getValue());\n\n      // json object with \"metric\":[metricname] and optionally \"tag\":[tagname]\n      JsonObject counterObj = (JsonObject) parser.parse(counter.getName());\n      String metric = counterObj.get(\"metric\").getAsString();\n      if (counterObj.has(\"tag\")) {\n        String tag = counterObj.get(\"tag\").getAsString();\n        collector.gauge(metric, emitValue, tag);\n        int tagCountSoFar = (metricTagValues.containsKey(metric)) ? metricTagValues.get(metric) : 0;\n        metricTagValues.put(metric, tagCountSoFar + emitValue);\n      } else {\n        metricUntaggedValues.put(metric, emitValue);\n      }\n    }\n\n    // emit adjusted counts for the untagged metrics.\n    for (Map.Entry<String, Integer> untaggedEntry : metricUntaggedValues.entrySet()) {\n      String metric = untaggedEntry.getKey();\n      int tagValueSum = (metricTagValues.containsKey(metric)) ? metricTagValues.get(metric) : 0;\n      int adjustedValue = untaggedEntry.getValue() - tagValueSum;\n      collector.gauge(metric, adjustedValue);\n    }\n  }","id":90538,"modified_method":"private void reportContinuuityStats(Iterable<Counter> counters, MetricsCollector collector, MetricsScope scope,\n                                         Table<MetricsScope, String, Integer> previousStats) {\n\n    // we don't want to overcount the untagged version of the metric.  For example.  If \"metric\":\"store.bytes\"\n    // comes in with \"tag\":\"dataset1\" and value 10, we will also have another counter for just the metric without the\n    // tag, also with value 10.  If we gauge both of them with their values, the final count sent off to the metrics\n    // system for the untagged metric will be 20 instead of 10.  So we need to keep track of the sum of the tagged\n    // values so that we can adjust accordingly.\n    Map<String, Integer> metricTagValues = Maps.newHashMap();\n    Map<String, Integer> metricUntaggedValues = Maps.newHashMap();\n\n    for (Counter counter : counters) {\n\n      // mapred counters are running counters whereas our metrics timeseries and aggregates make more\n      // sense as incremental numbers.  So we want to subtract the current counter value from the previous before\n      // emitting to the metrics system.\n      int emitValue = calcDiffAndSetTableValue(previousStats, scope, counter.getName(), counter.getValue());\n\n      // \"<metric>\" or \"<metric>,<tag>\" if tag is present\n      String[] parts = counter.getName().split(\",\", 2);\n      String metric = parts[0];\n      if (parts.length == 2) {\n        // has tag\n        String tag = parts[1];\n        collector.gauge(metric, emitValue, tag);\n        int tagCountSoFar = (metricTagValues.containsKey(metric)) ? metricTagValues.get(metric) : 0;\n        metricTagValues.put(metric, tagCountSoFar + emitValue);\n      } else {\n        metricUntaggedValues.put(metric, emitValue);\n      }\n    }\n\n    // emit adjusted counts for the untagged metrics.\n    for (Map.Entry<String, Integer> untaggedEntry : metricUntaggedValues.entrySet()) {\n      String metric = untaggedEntry.getKey();\n      int tagValueSum = (metricTagValues.containsKey(metric)) ? metricTagValues.get(metric) : 0;\n      int adjustedValue = untaggedEntry.getValue() - tagValueSum;\n      collector.gauge(metric, adjustedValue);\n    }\n  }","commit_id":"3befa6f2c4ca3a7ca8e653b138bbd27a88fecdd9","url":"https://github.com/caskdata/cdap"},{"original_method":"public MapReduceMetricsWriter(Job jobConf, BasicMapReduceContext context) {\n    this.jobConf = jobConf;\n    this.context = context;\n    this.previousMapStats = HashBasedTable.create();\n    this.previousReduceStats = HashBasedTable.create();\n    this.parser = new JsonParser();\n  }","id":90539,"modified_method":"public MapReduceMetricsWriter(Job jobConf, BasicMapReduceContext context) {\n    this.jobConf = jobConf;\n    this.context = context;\n    this.previousMapStats = HashBasedTable.create();\n    this.previousReduceStats = HashBasedTable.create();\n  }","commit_id":"3befa6f2c4ca3a7ca8e653b138bbd27a88fecdd9","url":"https://github.com/caskdata/cdap"},{"original_method":"protected long copyEntry(long groupId, long entryId) throws Exception {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select * from TagsEntry where entryId = ?\");\n\n\t\t\tps.setLong(1, entryId);\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong companyId = rs.getLong(\"companyId\");\n\t\t\t\tlong userId = rs.getLong(\"userId\");\n\t\t\t\tString userName = rs.getString(\"userName\");\n\t\t\t\tTimestamp createDate = rs.getTimestamp(\"createDate\");\n\t\t\t\tTimestamp modifiedDate = rs.getTimestamp(\"modifiedDate\");\n\t\t\t\tString name = rs.getString(\"name\");\n\n\t\t\t\tlong newEntryId = CounterLocalServiceUtil.increment();\n\n\t\t\t\tps = con.prepareStatement(\n\t\t\t\t\t\"insert into TagsEntry (entryId, groupId, companyId, \" +\n\t\t\t\t\t\t\"userId, userName, createDate, modifiedDate, name) \" +\n\t\t\t\t\t\t\t\"values (?, ?, ?, ?, ?, ?, ?, ?)\");\n\n\t\t\t\tps.setLong(1, newEntryId);\n\t\t\t\tps.setLong(2, groupId);\n\t\t\t\tps.setLong(3, companyId);\n\t\t\t\tps.setLong(4, userId);\n\t\t\t\tps.setString(5, userName);\n\t\t\t\tps.setTimestamp(6, createDate);\n\t\t\t\tps.setTimestamp(7, modifiedDate);\n\t\t\t\tps.setString(8, name);\n\n\t\t\t\tps.executeUpdate();\n\n\t\t\t\tps.close();\n\n\t\t\t\tcopyProperties(entryId, newEntryId);\n\n\t\t\t\treturn newEntryId;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\n\t\tthrow new NoSuchEntryException(\n\t\t\t\"No TagsEntry exists with the primary key \" + entryId);\n\t}","id":90540,"modified_method":"protected long copyEntry(long groupId, long entryId) throws Exception {\n\t\tString key = groupId + StringPool.UNDERLINE + entryId;\n\n\t\tLong newEntryId = _entryIdsMap.get(key);\n\n\t\tif (newEntryId != null) {\n\t\t\treturn newEntryId.longValue();\n\t\t}\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select * from TagsEntry where entryId = ?\");\n\n\t\t\tps.setLong(1, entryId);\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tlong companyId = rs.getLong(\"companyId\");\n\t\t\t\tlong userId = rs.getLong(\"userId\");\n\t\t\t\tString userName = rs.getString(\"userName\");\n\t\t\t\tTimestamp createDate = rs.getTimestamp(\"createDate\");\n\t\t\t\tTimestamp modifiedDate = rs.getTimestamp(\"modifiedDate\");\n\t\t\t\tString name = rs.getString(\"name\");\n\n\t\t\t\tnewEntryId = CounterLocalServiceUtil.increment();\n\n\t\t\t\tps = con.prepareStatement(\n\t\t\t\t\t\"insert into TagsEntry (entryId, groupId, companyId, \" +\n\t\t\t\t\t\t\"userId, userName, createDate, modifiedDate, name) \" +\n\t\t\t\t\t\t\t\"values (?, ?, ?, ?, ?, ?, ?, ?)\");\n\n\t\t\t\tps.setLong(1, newEntryId);\n\t\t\t\tps.setLong(2, groupId);\n\t\t\t\tps.setLong(3, companyId);\n\t\t\t\tps.setLong(4, userId);\n\t\t\t\tps.setString(5, userName);\n\t\t\t\tps.setTimestamp(6, createDate);\n\t\t\t\tps.setTimestamp(7, modifiedDate);\n\t\t\t\tps.setString(8, name);\n\n\t\t\t\tps.executeUpdate();\n\n\t\t\t\tps.close();\n\n\t\t\t\tcopyProperties(entryId, newEntryId);\n\n\t\t\t\t_entryIdsMap.put(key, newEntryId);\n\n\t\t\t\treturn newEntryId;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\n\t\tthrow new NoSuchEntryException(\n\t\t\t\"No TagsEntry exists with the primary key \" + entryId);\n\t}","commit_id":"10b70f3a45c5fd7f6c8d8ef85a1cdfbf14eec8b6","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBThread addThread(long categoryId, MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Thread\n\n\t\tlong threadId = counterLocalService.increment();\n\n\t\tMBThread thread = mbThreadPersistence.create(threadId);\n\n\t\tthread.setGroupId(message.getGroupId());\n\t\tthread.setCompanyId(message.getCompanyId());\n\t\tthread.setCategoryId(categoryId);\n\t\tthread.setRootMessageId(message.getMessageId());\n\t\tthread.setRootMessageUserId(message.getUserId());\n\n\t\tif (message.isAnonymous()) {\n\t\t\tthread.setLastPostByUserId(0);\n\t\t}\n\t\telse {\n\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t}\n\n\t\tthread.setLastPostDate(message.getCreateDate());\n\n\t\tif (message.getPriority() != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tthread.setPriority(message.getPriority());\n\t\t}\n\n\t\tthread.setStatus(message.getStatus());\n\t\tthread.setStatusByUserId(message.getStatusByUserId());\n\t\tthread.setStatusByUserName(message.getStatusByUserName());\n\t\tthread.setStatusDate(message.getStatusDate());\n\n\t\tmbThreadPersistence.update(thread, false);\n\n\t\t// Asset\n\n\t\tif (categoryId >= 0) {\n\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\tmessage.getUserId(), message.getGroupId(),\n\t\t\t\tMBThread.class.getName(), thread.getThreadId(), null,\n\t\t\t\tnew long[0], new String[0], false, null, null, null, null, null,\n\t\t\t\tString.valueOf(thread.getRootMessageId()), null, null, null,\n\t\t\t\tnull, 0, 0, null, false);\n\t\t}\n\n\t\treturn thread;\n\t}","id":90541,"modified_method":"public MBThread addThread(long categoryId, MBMessage message)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Thread\n\n\t\tlong threadId = message.getThreadId();\n\n\t\tif (threadId <= 0) {\n\t\t\tthreadId = counterLocalService.increment();\n\t\t}\n\n\t\tMBThread thread = mbThreadPersistence.create(threadId);\n\n\t\tthread.setGroupId(message.getGroupId());\n\t\tthread.setCompanyId(message.getCompanyId());\n\t\tthread.setCategoryId(categoryId);\n\t\tthread.setRootMessageId(message.getMessageId());\n\t\tthread.setRootMessageUserId(message.getUserId());\n\n\t\tif (message.isAnonymous()) {\n\t\t\tthread.setLastPostByUserId(0);\n\t\t}\n\t\telse {\n\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t}\n\n\t\tthread.setLastPostDate(message.getCreateDate());\n\n\t\tif (message.getPriority() != MBThreadConstants.PRIORITY_NOT_GIVEN) {\n\t\t\tthread.setPriority(message.getPriority());\n\t\t}\n\n\t\tthread.setStatus(message.getStatus());\n\t\tthread.setStatusByUserId(message.getStatusByUserId());\n\t\tthread.setStatusByUserName(message.getStatusByUserName());\n\t\tthread.setStatusDate(message.getStatusDate());\n\n\t\tmbThreadPersistence.update(thread, false);\n\n\t\t// Asset\n\n\t\tif (categoryId >= 0) {\n\t\t\tassetEntryLocalService.updateEntry(\n\t\t\t\tmessage.getUserId(), message.getGroupId(),\n\t\t\t\tMBThread.class.getName(), thread.getThreadId(), null,\n\t\t\t\tnew long[0], new String[0], false, null, null, null, null, null,\n\t\t\t\tString.valueOf(thread.getRootMessageId()), null, null, null,\n\t\t\t\tnull, 0, 0, null, false);\n\t\t}\n\n\t\treturn thread;\n\t}","commit_id":"185b2fef6616bfceefdc0a20a8f82cb9272332f3","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Processes an incoming probe request.\n\t * If the probe has a positive HTL, routes with MH correction and probabilistically decrements HTL.\n\t * If the probe comes to have an HTL of zero: (an incoming HTL of zero is taken to be one.)\n\t * Returns (as node settings allow) exactly one of:\n\t * <ul>\n\t *         <li>unique identifier and integer 7-day uptime percentage<\/li>\n\t *         <li>uptime: 48-hour percentage or 7-day percentage<\/li>\n\t *         <li>output bandwidth<\/li>\n\t *         <li>store size<\/li>\n\t *         <li>link lengths<\/li>\n\t *         <li>location<\/li>\n\t *         <li>build number<\/li>\n\t * <\/ul>\n\t *\n\t * @param message probe request, containing HTL\n\t * @param source node from which the probe request was received. Used to relay back results. If null, it is\n\t *               considered to have been sent from the local node.\n\t * @param callback callback for probe response\n\t */\n\tpublic void request(final Message message, final PeerNode source, final AsyncMessageFilterCallback callback) {\n\t\tfinal Long uid = message.getLong(DMT.UID);\n\t\tif (overloadedFrom(uid, source, callback)) return;\n\t\tProbeType temp;\n\t\ttry {\n\t\t\ttemp = ProbeType.valueOf(message.getByte(DMT.TYPE));\n\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Probe type is \" + temp.name() + \".\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Invalid probe type \\\"\" + message.getString(DMT.TYPE) + \"\\\".\", e);\n\t\t\ttry {\n\t\t\t\tMessage unrecognized = DMT.createMHProbeError(uid, ProbeError.UNRECOGNIZED_TYPE);\n\t\t\t\t//Locally sent message.\n\t\t\t\tif (source == null) {\n\t\t\t\t\tcallback.onMatched(unrecognized);\n\t\t\t\t} else {\n\t\t\t\t\tsource.sendAsync(unrecognized, null, this);\n\t\t\t\t}\n\t\t\t} catch (NotConnectedException f) {\n\t\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Source of unrecognized result type is no longer connected.\", f);\n\t\t\t} catch (NullPointerException f) {\n\t\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Source of unrecognized result type is no longer connected.\", f);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfinal ProbeType type = temp;\n\t\tbyte htl = message.getByte(DMT.HTL);\n\t\tif (htl < 1) {\n\t\t\tif (logWARNING) Logger.warning(MHProbe.class, \"Received out-of-bounds HTL of \" + htl + \"; interpreting as 1.\");\n\t\t\thtl = 1;\n\t\t} else if (htl > MAX_HTL) {\n\t\t\tif (logWARNING) Logger.warning(MHProbe.class, \"Received out-of-bounds HTL of \" + htl + \"; interpreting as \" + MAX_HTL + \".\");\n\t\t\thtl = MAX_HTL;\n\t\t}\n\t\t//If no counter exists for the current source, add one.\n\t\tsynchronized (accepted) {\n\t\t\tif (!accepted.containsKey(source)) {\n\t\t\t\taccepted.put(source, new SynchronizedCounter());\n\t\t\t}\n\t\t}\n\t\tfinal SynchronizedCounter counter = accepted.get(source);\n\t\tsynchronized (counter) {\n\t\t\tif (overloadedFrom(uid, source, callback)) {\n\t\t\t\t/* The counter is at zero, but it will not be incremented and thus not decremented and\n\t\t\t\t * checked for removal.\n\t\t\t\t */\n\t\t\t\tif (counter.value() == 0) {\n\t\t\t\t\taccepted.remove(source);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcounter.increment();\n\t\t}\n\t\t//One-minute window on acceptance; free up this probe's slot in 60 seconds.\n\t\ttimer.schedule(new TimerTask() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tcounter.decrement();\n\t\t\t\t/* Once the counter hits zero, there's no reason to keep it around as it can just be\n\t\t\t\t * recreated when this peer sends another probe request without changing behavior.\n\t\t\t\t * To do otherwise would accumulate counters at zero over time.\n\t\t\t\t */\n\t\t\t\tif (counter.value() == 0) {\n\t\t\t\t\tMHProbe.this.accepted.remove(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}, MINUTE);\n\n\t\t/*\n\t\t * Route to a peer, using Metropolis-Hastings correction and ignoring backoff to get a more uniform\n\t\t * endpoint distribution. HTL is decremented before routing so that it's possible to respond locally.\n\t\t */\n\t\thtl = probabilisticDecrement(htl);\n\t\tif (htl == 0) {\n\t\t\trespond(type, uid, source, callback);\n\t\t} else {\n\t\t\troute(message, type, uid, htl, source, callback);\n\t\t}\n\t}","id":90542,"modified_method":"/**\n\t * Processes an incoming probe request.\n\t * If the probe has a positive HTL, routes with MH correction and probabilistically decrements HTL.\n\t * If the probe comes to have an HTL of zero: (an incoming HTL of zero is taken to be one.)\n\t * Returns (as node settings allow) exactly one of:\n\t * <ul>\n\t *         <li>unique identifier and integer 7-day uptime percentage<\/li>\n\t *         <li>uptime: 48-hour percentage or 7-day percentage<\/li>\n\t *         <li>output bandwidth<\/li>\n\t *         <li>store size<\/li>\n\t *         <li>link lengths<\/li>\n\t *         <li>location<\/li>\n\t *         <li>build number<\/li>\n\t * <\/ul>\n\t *\n\t * @param message probe request, containing HTL\n\t * @param source node from which the probe request was received. Used to relay back results. If null, it is\n\t *               considered to have been sent from the local node.\n\t * @param callback callback for probe response\n\t */\n\tpublic void request(final Message message, final PeerNode source, final AsyncMessageFilterCallback callback) {\n\t\tfinal Long uid = message.getLong(DMT.UID);\n\t\tProbeType temp;\n\t\ttry {\n\t\t\ttemp = ProbeType.valueOf(message.getByte(DMT.TYPE));\n\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Probe type is \" + temp.name() + \".\");\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Invalid probe type \\\"\" + message.getString(DMT.TYPE) + \"\\\".\", e);\n\t\t\ttry {\n\t\t\t\tMessage unrecognized = DMT.createMHProbeError(uid, ProbeError.UNRECOGNIZED_TYPE);\n\t\t\t\t//Locally sent message.\n\t\t\t\tif (source == null) {\n\t\t\t\t\tcallback.onMatched(unrecognized);\n\t\t\t\t} else {\n\t\t\t\t\tsource.sendAsync(unrecognized, null, this);\n\t\t\t\t}\n\t\t\t} catch (NotConnectedException f) {\n\t\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Source of unrecognized result type is no longer connected.\", f);\n\t\t\t} catch (NullPointerException f) {\n\t\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Source of unrecognized result type is no longer connected.\", f);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfinal ProbeType type = temp;\n\t\tbyte htl = message.getByte(DMT.HTL);\n\t\tif (htl < 1) {\n\t\t\tif (logWARNING) Logger.warning(MHProbe.class, \"Received out-of-bounds HTL of \" + htl + \"; interpreting as 1.\");\n\t\t\thtl = 1;\n\t\t} else if (htl > MAX_HTL) {\n\t\t\tif (logWARNING) Logger.warning(MHProbe.class, \"Received out-of-bounds HTL of \" + htl + \"; interpreting as \" + MAX_HTL + \".\");\n\t\t\thtl = MAX_HTL;\n\t\t}\n\t\t//If no counter exists for the current source, add one.\n\t\tsynchronized (accepted) {\n\t\t\tif (!accepted.containsKey(source)) {\n\t\t\t\taccepted.put(source, new SynchronizedCounter());\n\t\t\t}\n\t\tfinal SynchronizedCounter counter = accepted.get(source);\n\t\t\tif (accepted.containsKey(source) && accepted.get(source).value() >= MAX_ACCEPTED) {\n\t\t\t\t/* The counter is at zero, but it will not be incremented and thus not decremented and\n\t\t\t\t * checked for removal.\n\t\t\t\t */\n\t\t\t\tif (counter.value() == 0) {\n\t\t\t\t\taccepted.remove(source);\n\t\t\t\t}\n\t\t\t\t//Send an overload error back to the source.\n\t\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Already accepted maximum number of probes; rejecting incoming.\");\n\t\t\t\ttry {\n\t\t\t\t\tMessage overload = DMT.createMHProbeError(uid, ProbeError.OVERLOAD);\n\t\t\t\t\t//Locally sent message.\n\t\t\t\t\tif (source == null) {\n\t\t\t\t\t\tcallback.onMatched(overload);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsource.sendAsync(overload, null, this);\n\t\t\t\t\t}\n\t\t\t\t} catch (NotConnectedException e) {\n\t\t\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Source of excess probe no longer connected.\", e);\n\t\t\t\t} catch (NullPointerException e) {\n\t\t\t\t\tif (logDEBUG) Logger.debug(MHProbe.class, \"Source of excess probe no longer connected.\", e);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcounter.increment();\n\t\t//One-minute window on acceptance; free up this probe's slot in 60 seconds.\n\t\ttimer.schedule(new TimerTask() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tcounter.decrement();\n\t\t\t\t/* Once the counter hits zero, there's no reason to keep it around as it can just be\n\t\t\t\t * recreated when this peer sends another probe request without changing behavior.\n\t\t\t\t * To do otherwise would accumulate counters at zero over time.\n\t\t\t\t */\n\t\t\t\tsynchronized (accepted) {\n\t\t\t\tif (counter.value() == 0) {\n\t\t\t\t\tMHProbe.this.accepted.remove(source);\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}, MINUTE);\n\t\t}\n\n\t\t/*\n\t\t * Route to a peer, using Metropolis-Hastings correction and ignoring backoff to get a more uniform\n\t\t * endpoint distribution. HTL is decremented before routing so that it's possible to respond locally.\n\t\t */\n\t\thtl = probabilisticDecrement(htl);\n\t\tif (htl == 0) {\n\t\t\trespond(type, uid, source, callback);\n\t\t} else {\n\t\t\troute(message, type, uid, htl, source, callback);\n\t\t}\n\t}","commit_id":"cd0abdcdaf5ae0b8c61799a34bec1f4f41e8a251","url":"https://github.com/freenet/fred"},{"original_method":"private void assertIsNotGzipCompressed(String filename, int filesize) throws Exception\n    {\n        GzipTester tester = new GzipTester(testingdir);\n\n        tester.prepareServerFile(filename,filesize);\n\n        FilterHolder holder = tester.setContentServlet(testServlet);\n        holder.setInitParameter(\"mimeTypes\",\"text/plain\");\n\n        try\n        {\n            tester.start();\n            tester.assertIsResponseNotGzipCompressed(filename,filesize);\n        }\n        finally\n        {\n            tester.stop();\n        }\n    }","id":90543,"modified_method":"private void assertIsNotGzipCompressed(String filename, int filesize) throws Exception\n    {\n        GzipTester tester = new GzipTester(testingdir);\n\n        tester.prepareServerFile(filename,filesize);\n\n        FilterHolder holder = tester.setContentServlet(testServlet);\n        holder.setInitParameter(\"mimeTypes\",\"text/plain\");\n\n        try\n        {\n            tester.start();\n            tester.assertIsResponseNotGzipCompressed(filename,filesize,HttpStatus.OK_200);\n        }\n        finally\n        {\n            tester.stop();\n        }\n    }","commit_id":"0e541c4c243ccb923f20f6de62ab646d87c9617d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testIsNotGzipCompressed() throws Exception\n    {\n        GzipTester tester = new GzipTester(testingdir);\n\n        // Test content that is smaller than the buffer.\n        int filesize = GzipResponseWrapper.DEFAULT_BUFFER_SIZE * 4;\n        tester.prepareServerFile(\"file.mp3\",filesize);\n        \n        FilterHolder holder = tester.setContentServlet(org.eclipse.jetty.servlet.DefaultServlet.class);\n        holder.setInitParameter(\"mimeTypes\",\"text/plain\");\n\n        try\n        {\n            tester.start();\n            tester.assertIsResponseNotGzipCompressed(\"file.mp3\", filesize);\n        }\n        finally\n        {\n            tester.stop();\n        }\n    }","id":90544,"modified_method":"@Test\n    public void testIsNotGzipCompressed() throws Exception\n    {\n        GzipTester tester = new GzipTester(testingdir);\n\n        // Test content that is smaller than the buffer.\n        int filesize = GzipResponseWrapper.DEFAULT_BUFFER_SIZE * 4;\n        tester.prepareServerFile(\"file.mp3\",filesize);\n        \n        FilterHolder holder = tester.setContentServlet(org.eclipse.jetty.servlet.DefaultServlet.class);\n        holder.setInitParameter(\"mimeTypes\",\"text/plain\");\n\n        try\n        {\n            tester.start();\n            tester.assertIsResponseNotGzipCompressed(\"file.mp3\", filesize, HttpStatus.OK_200);\n        }\n        finally\n        {\n            tester.stop();\n        }\n    }","commit_id":"0e541c4c243ccb923f20f6de62ab646d87c9617d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @see javax.servlet.http.HttpServletResponseWrapper#setStatus(int, java.lang.String)\n     */\n    public void setStatus(int sc, String sm)\n    {\n        super.setStatus(sc,sm);\n        if (sc<200||sc>=300)\n            noGzip();\n    }","id":90545,"modified_method":"/**\n     * @see javax.servlet.http.HttpServletResponseWrapper#setStatus(int, java.lang.String)\n     */\n    public void setStatus(int sc, String sm)\n    {\n        super.setStatus(sc,sm);\n        if (sc<200 || sc==204 || sc==205 || sc>=300)\n            noGzip();\n    }","commit_id":"0e541c4c243ccb923f20f6de62ab646d87c9617d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * @see javax.servlet.http.HttpServletResponseWrapper#setStatus(int)\n     */\n    public void setStatus(int sc)\n    {\n        super.setStatus(sc);\n        if (sc<200||sc>=300)\n            noGzip();\n    }","id":90546,"modified_method":"/**\n     * @see javax.servlet.http.HttpServletResponseWrapper#setStatus(int)\n     */\n    public void setStatus(int sc)\n    {\n        super.setStatus(sc);\n        if (sc<200 || sc==204 || sc==205 ||sc>=300)\n            noGzip();\n    }","commit_id":"0e541c4c243ccb923f20f6de62ab646d87c9617d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Asserts that the requested filename results in a properly structured GzipFilter response, where the content is\n     * not compressed, and the content-length is returned appropriately.\n     * \n     * @param filename\n     *            the filename used for the request, and also used to compare the response to the server file, assumes\n     *            that the file is suitable for {@link Assert#assertEquals(Object, Object)} use. (in other words, the\n     *            contents of the file are text)\n     * @param expectedFilesize\n     *            the expected filesize to be specified on the Content-Length portion of the response headers. (note:\n     *            passing -1 will disable the Content-Length assertion)\n     * @throws Exception\n     */\n    public void assertIsResponseNotGzipCompressed(String filename, int expectedFilesize) throws Exception\n    {\n        System.err.printf(\"[GzipTester] requesting /context/%s%n\",filename);\n        HttpTester request = new HttpTester();\n        HttpTester response = new HttpTester();\n\n        request.setMethod(\"GET\");\n        request.setVersion(\"HTTP/1.0\");\n        request.setHeader(\"Host\",\"tester\");\n        request.setHeader(\"Accept-Encoding\",\"gzip\");\n        request.setURI(\"/context/\" + filename);\n\n        // Issue the request\n        ByteArrayBuffer reqsBuff = new ByteArrayBuffer(request.generate().getBytes());\n        // Collect the response(s)\n        ByteArrayBuffer respBuff = servletTester.getResponses(reqsBuff);\n        response.parse(respBuff.asArray());\n\n        // Assert the response headers\n        Assert.assertThat(\"Response.method\",response.getMethod(),nullValue());\n        Assert.assertThat(\"Response.status\",response.getStatus(),is(HttpServletResponse.SC_OK));\n        if (expectedFilesize != (-1))\n        {\n            Assert.assertThat(\"Response.header[Content-Length]\",response.getHeader(\"Content-Length\"),notNullValue());\n            int serverLength = Integer.parseInt(response.getHeader(\"Content-Length\"));\n            Assert.assertThat(\"Response.header[Content-Length]\",serverLength,is(expectedFilesize));\n        }\n        Assert.assertThat(\"Response.header[Content-Encoding]\",response.getHeader(\"Content-Encoding\"),not(containsString(\"gzip\")));\n\n        // Assert that the contents are what we expect.\n        File serverFile = testdir.getFile(filename);\n        String expected = IO.readToString(serverFile);\n        String actual = null;\n\n        InputStream in = null;\n        ByteArrayOutputStream out = null;\n        try\n        {\n            in = new ByteArrayInputStream(response.getContentBytes());\n            out = new ByteArrayOutputStream();\n            IO.copy(in,out);\n\n            actual = out.toString(encoding);\n            Assert.assertEquals(\"Server contents\",expected,actual);\n        }\n        finally\n        {\n            IO.close(out);\n            IO.close(in);\n        }\n    }","id":90547,"modified_method":"/**\n     * Asserts that the requested filename results in a properly structured GzipFilter response, where the content is\n     * not compressed, and the content-length is returned appropriately.\n     * \n     * @param filename\n     *            the filename used for the request, and also used to compare the response to the server file, assumes\n     *            that the file is suitable for {@link Assert#assertEquals(Object, Object)} use. (in other words, the\n     *            contents of the file are text)\n     * @param expectedFilesize\n     *            the expected filesize to be specified on the Content-Length portion of the response headers. (note:\n     *            passing -1 will disable the Content-Length assertion)\n     * @throws Exception\n     */\n    public void assertIsResponseNotGzipCompressed(String filename, int expectedFilesize, int status) throws Exception\n    {\n        System.err.printf(\"[GzipTester] requesting /context/%s%n\",filename);\n        HttpTester request = new HttpTester();\n        HttpTester response = new HttpTester();\n\n        request.setMethod(\"GET\");\n        request.setVersion(\"HTTP/1.0\");\n        request.setHeader(\"Host\",\"tester\");\n        request.setHeader(\"Accept-Encoding\",\"gzip\");\n        if (filename == null)\n            request.setURI(\"/context/\");\n        else\n            request.setURI(\"/context/\"+filename);\n\n        // Issue the request\n        ByteArrayBuffer reqsBuff = new ByteArrayBuffer(request.generate().getBytes());\n        // Collect the response(s)\n        ByteArrayBuffer respBuff = servletTester.getResponses(reqsBuff);\n        response.parse(respBuff.asArray());\n\n        // Assert the response headers\n        Assert.assertThat(\"Response.method\",response.getMethod(),nullValue());\n        Assert.assertThat(\"Response.status\",response.getStatus(),is(status));\n        if (expectedFilesize != (-1))\n        {\n            Assert.assertThat(\"Response.header[Content-Length]\",response.getHeader(\"Content-Length\"),notNullValue());\n            int serverLength = Integer.parseInt(response.getHeader(\"Content-Length\"));\n            Assert.assertThat(\"Response.header[Content-Length]\",serverLength,is(expectedFilesize));\n        }\n        Assert.assertThat(\"Response.header[Content-Encoding]\",response.getHeader(\"Content-Encoding\"),not(containsString(\"gzip\")));\n        \n        // Assert that the contents are what we expect.\n        if (filename != null)\n        {\n            File serverFile = testdir.getFile(filename);\n            String expected = IO.readToString(serverFile);\n            String actual = null;\n\n            InputStream in = null;\n            ByteArrayOutputStream out = null;\n            try\n            {\n                in = new ByteArrayInputStream(response.getContentBytes());\n                out = new ByteArrayOutputStream();\n                IO.copy(in,out);\n\n                actual = out.toString(encoding);\n                Assert.assertEquals(\"Server contents\",expected,actual);\n            }\n            finally\n            {\n                IO.close(out);\n                IO.close(in);\n            }\n        }\n    }","commit_id":"0e541c4c243ccb923f20f6de62ab646d87c9617d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void completeHeader(HttpFields fields, boolean allContentAdded) throws IOException\n    {\n        if (_state != STATE_HEADER)\n            return;\n\n        // handle a reset\n        if (isResponse() && _status==0)\n            throw new EofException();\n\n        if (_last && !allContentAdded)\n            throw new IllegalStateException(\"last?\");\n        _last = _last | allContentAdded;\n\n        // get a header buffer\n        if (_header == null)\n            _header = _buffers.getHeader();\n\n        boolean has_server = false;\n\n        try\n        {\n            if (isRequest())\n            {\n                _persistent=true;\n\n                if (_version == HttpVersions.HTTP_0_9_ORDINAL)\n                {\n                    _contentLength = HttpTokens.NO_CONTENT;\n                    _header.put(_method);\n                    _header.put((byte)' ');\n                    _header.put(_uri.getBytes(\"UTF-8\")); // TODO check\n                    _header.put(HttpTokens.CRLF);\n                    _state = STATE_FLUSHING;\n                    _noContent=true;\n                    return;\n                }\n                else\n                {\n                    _header.put(_method);\n                    _header.put((byte)' ');\n                    _header.put(_uri.getBytes(\"UTF-8\")); // TODO check\n                    _header.put((byte)' ');\n                    _header.put(_version==HttpVersions.HTTP_1_0_ORDINAL?HttpVersions.HTTP_1_0_BUFFER:HttpVersions.HTTP_1_1_BUFFER);\n                    _header.put(HttpTokens.CRLF);\n                }\n            }\n            else\n            {\n                // Responses\n                if (_version == HttpVersions.HTTP_0_9_ORDINAL)\n                {\n                    _persistent = false;\n                    _contentLength = HttpTokens.EOF_CONTENT;\n                    _state = STATE_CONTENT;\n                    return;\n                }\n                else\n                {\n                    if (_persistent==null)\n                        _persistent= (_version > HttpVersions.HTTP_1_0_ORDINAL);\n\n                    // add response line\n                    Status status = _status<__status.length?__status[_status]:null;\n\n                    if (status==null)\n                    {\n                        _header.put(HttpVersions.HTTP_1_1_BUFFER);\n                        _header.put((byte) ' ');\n                        _header.put((byte) ('0' + _status / 100));\n                        _header.put((byte) ('0' + (_status % 100) / 10));\n                        _header.put((byte) ('0' + (_status % 10)));\n                        _header.put((byte) ' ');\n                        if (_reason==null)\n                        {\n                            _header.put((byte) ('0' + _status / 100));\n                            _header.put((byte) ('0' + (_status % 100) / 10));\n                            _header.put((byte) ('0' + (_status % 10)));\n                        }\n                        else\n                            _header.put(_reason);\n                        _header.put(HttpTokens.CRLF);\n                    }\n                    else\n                    {\n                        if (_reason==null)\n                            _header.put(status._responseLine);\n                        else\n                        {\n                            _header.put(status._schemeCode);\n                            _header.put(_reason);\n                            _header.put(HttpTokens.CRLF);\n                        }\n                    }\n\n                    if (_status<200 && _status>=100 )\n                    {\n                        _noContent=true;\n                        _content=null;\n                        if (_buffer!=null)\n                            _buffer.clear();\n                        // end the header.\n\n                        if (_status!=101 )\n                        {\n                            _header.put(HttpTokens.CRLF);\n                            _state = STATE_CONTENT;\n                            return;\n                        }\n                    }\n                    else if (_status==204 || _status==304)\n                    {\n                        _noContent=true;\n                        _content=null;\n                        if (_buffer!=null)\n                            _buffer.clear();\n                    }\n                }\n            }\n\n            // Add headers\n            if (_status>=200 && _date!=null)\n            {\n                _header.put(HttpHeaders.DATE_BUFFER);\n                _header.put((byte)':');\n                _header.put((byte)' ');\n                _header.put(_date);\n                _header.put(CRLF);\n            }\n\n            // key field values\n            HttpFields.Field content_length = null;\n            HttpFields.Field transfer_encoding = null;\n            boolean keep_alive = false;\n            boolean close=false;\n            boolean content_type=false;\n            StringBuilder connection = null;\n\n            if (fields != null)\n            {\n                int s=fields.size();\n                for (int f=0;f<s;f++)\n                {\n                    HttpFields.Field field = fields.getField(f);\n                    if (field==null)\n                        continue;\n\n                    switch (field.getNameOrdinal())\n                    {\n                        case HttpHeaders.CONTENT_LENGTH_ORDINAL:\n                            content_length = field;\n                            _contentLength = field.getLongValue();\n\n                            if (_contentLength < _contentWritten || _last && _contentLength != _contentWritten)\n                                content_length = null;\n\n                            // write the field to the header buffer\n                            field.putTo(_header);\n                            break;\n\n                        case HttpHeaders.CONTENT_TYPE_ORDINAL:\n                            if (BufferUtil.isPrefix(MimeTypes.MULTIPART_BYTERANGES_BUFFER, field.getValueBuffer())) _contentLength = HttpTokens.SELF_DEFINING_CONTENT;\n\n                            // write the field to the header buffer\n                            content_type=true;\n                            field.putTo(_header);\n                            break;\n\n                        case HttpHeaders.TRANSFER_ENCODING_ORDINAL:\n                            if (_version == HttpVersions.HTTP_1_1_ORDINAL)\n                                transfer_encoding = field;\n                            // Do NOT add yet!\n                            break;\n\n                        case HttpHeaders.CONNECTION_ORDINAL:\n                            if (isRequest())\n                                field.putTo(_header);\n\n                            int connection_value = field.getValueOrdinal();\n                            switch (connection_value)\n                            {\n                                case -1:\n                                {\n                                    String[] values = field.getValue().split(\",\");\n                                    for  (int i=0;values!=null && i<values.length;i++)\n                                    {\n                                        CachedBuffer cb = HttpHeaderValues.CACHE.get(values[i].trim());\n\n                                        if (cb!=null)\n                                        {\n                                            switch(cb.getOrdinal())\n                                            {\n                                                case HttpHeaderValues.CLOSE_ORDINAL:\n                                                    close=true;\n                                                    if (isResponse())\n                                                        _persistent=false;\n                                                    keep_alive=false;\n                                                    if (!_persistent && isResponse() && _contentLength == HttpTokens.UNKNOWN_CONTENT)\n                                                        _contentLength = HttpTokens.EOF_CONTENT;\n                                                    break;\n\n                                                case HttpHeaderValues.KEEP_ALIVE_ORDINAL:\n                                                    if (_version == HttpVersions.HTTP_1_0_ORDINAL)\n                                                    {\n                                                        keep_alive = true;\n                                                        if (isResponse())\n                                                            _persistent = true;\n                                                    }\n                                                    break;\n\n                                                default:\n                                                    if (connection==null)\n                                                        connection=new StringBuilder();\n                                                    else\n                                                        connection.append(',');\n                                                    connection.append(values[i]);\n                                            }\n                                        }\n                                        else\n                                        {\n                                            if (connection==null)\n                                                connection=new StringBuilder();\n                                            else\n                                                connection.append(',');\n                                            connection.append(values[i]);\n                                        }\n                                    }\n\n                                    break;\n                                }\n                                case HttpHeaderValues.UPGRADE_ORDINAL:\n                                {\n                                    // special case for websocket connection ordering\n                                    if (isResponse())\n                                    {\n                                        field.putTo(_header);\n                                        continue;\n                                    }\n                                }\n                                case HttpHeaderValues.CLOSE_ORDINAL:\n                                {\n                                    close=true;\n                                    if (isResponse())\n                                        _persistent=false;\n                                    if (!_persistent && isResponse() && _contentLength == HttpTokens.UNKNOWN_CONTENT)\n                                        _contentLength = HttpTokens.EOF_CONTENT;\n                                    break;\n                                }\n                                case HttpHeaderValues.KEEP_ALIVE_ORDINAL:\n                                {\n                                    if (_version == HttpVersions.HTTP_1_0_ORDINAL)\n                                    {\n                                        keep_alive = true;\n                                        if (isResponse())\n                                            _persistent=true;\n                                    }\n                                    break;\n                                }\n                                default:\n                                {\n                                    if (connection==null)\n                                        connection=new StringBuilder();\n                                    else\n                                        connection.append(',');\n                                    connection.append(field.getValue());\n                                }\n                            }\n\n                            // Do NOT add yet!\n                            break;\n\n                        case HttpHeaders.SERVER_ORDINAL:\n                            if (getSendServerVersion())\n                            {\n                                has_server=true;\n                                field.putTo(_header);\n                            }\n                            break;\n\n                        default:\n                            // write the field to the header buffer\n                            field.putTo(_header);\n                    }\n                }\n            }\n\n            // Calculate how to end _content and connection, _content length and transfer encoding\n            // settings.\n            // From RFC 2616 4.4:\n            // 1. No body for 1xx, 204, 304 & HEAD response\n            // 2. Force _content-length?\n            // 3. If Transfer-Encoding!=identity && HTTP/1.1 && !HttpConnection==close then chunk\n            // 4. Content-Length\n            // 5. multipart/byteranges\n            // 6. close\n            switch ((int) _contentLength)\n            {\n                case HttpTokens.UNKNOWN_CONTENT:\n                    // It may be that we have no _content, or perhaps _content just has not been\n                    // written yet?\n\n                    // Response known not to have a body\n                    if (_contentWritten == 0 && isResponse() && (_status < 200 || _status == 204 || _status == 304))\n                        _contentLength = HttpTokens.NO_CONTENT;\n                    else if (_last)\n                    {\n                        // we have seen all the _content there is\n                        _contentLength = _contentWritten;\n                        if (content_length == null && (isResponse() || _contentLength>0 || content_type ))\n                        {\n                            // known length but not actually set.\n                            _header.put(HttpHeaders.CONTENT_LENGTH_BUFFER);\n                            _header.put(HttpTokens.COLON);\n                            _header.put((byte) ' ');\n                            BufferUtil.putDecLong(_header, _contentLength);\n                            _header.put(HttpTokens.CRLF);\n                        }\n                    }\n                    else\n                    {\n                        // No idea, so we must assume that a body is coming\n                        _contentLength = (!_persistent || _version < HttpVersions.HTTP_1_1_ORDINAL ) ? HttpTokens.EOF_CONTENT : HttpTokens.CHUNKED_CONTENT;\n                        if (isRequest() && _contentLength==HttpTokens.EOF_CONTENT)\n                        {\n                            _contentLength=HttpTokens.NO_CONTENT;\n                            _noContent=true;\n                        }\n                    }\n                    break;\n\n                case HttpTokens.NO_CONTENT:\n                    if (content_length == null && isResponse() && _status >= 200 && _status != 204 && _status != 304)\n                        _header.put(CONTENT_LENGTH_0);\n                    break;\n\n                case HttpTokens.EOF_CONTENT:\n                    _persistent = isRequest();\n                    break;\n\n                case HttpTokens.CHUNKED_CONTENT:\n                    break;\n\n                default:\n                    // TODO - maybe allow forced chunking by setting te ???\n                    break;\n            }\n\n            // Add transfer_encoding if needed\n            if (_contentLength == HttpTokens.CHUNKED_CONTENT)\n            {\n                // try to use user supplied encoding as it may have other values.\n                if (transfer_encoding != null && HttpHeaderValues.CHUNKED_ORDINAL != transfer_encoding.getValueOrdinal())\n                {\n                    String c = transfer_encoding.getValue();\n                    if (c.endsWith(HttpHeaderValues.CHUNKED))\n                        transfer_encoding.putTo(_header);\n                    else\n                        throw new IllegalArgumentException(\"BAD TE\");\n                }\n                else\n                    _header.put(TRANSFER_ENCODING_CHUNKED);\n            }\n\n            // Handle connection if need be\n            if (_contentLength==HttpTokens.EOF_CONTENT)\n            {\n                keep_alive=false;\n                _persistent=false;\n            }\n\n            if (isResponse())\n            {\n                if (!_persistent && (close || _version > HttpVersions.HTTP_1_0_ORDINAL))\n                {\n                    _header.put(CONNECTION_CLOSE);\n                    if (connection!=null)\n                    {\n                        _header.setPutIndex(_header.putIndex()-2);\n                        _header.put((byte)',');\n                        _header.put(connection.toString().getBytes());\n                        _header.put(CRLF);\n                    }\n                }\n                else if (keep_alive)\n                {\n                    _header.put(CONNECTION_KEEP_ALIVE);\n                    if (connection!=null)\n                    {\n                        _header.setPutIndex(_header.putIndex()-2);\n                        _header.put((byte)',');\n                        _header.put(connection.toString().getBytes());\n                        _header.put(CRLF);\n                    }\n                }\n                else if (connection!=null)\n                {\n                    _header.put(CONNECTION_);\n                    _header.put(connection.toString().getBytes());\n                    _header.put(CRLF);\n                }\n            }\n\n            if (!has_server && _status>199 && getSendServerVersion())\n                _header.put(SERVER);\n\n            // end the header.\n            _header.put(HttpTokens.CRLF);\n            _state = STATE_CONTENT;\n\n        }\n        catch(ArrayIndexOutOfBoundsException e)\n        {\n            throw new RuntimeException(\"Header>\"+_header.capacity(),e);\n        }\n    }","id":90548,"modified_method":"@Override\n    public void completeHeader(HttpFields fields, boolean allContentAdded) throws IOException\n    {\n        if (_state != STATE_HEADER)\n            return;\n\n        // handle a reset\n        if (isResponse() && _status==0)\n            throw new EofException();\n\n        if (_last && !allContentAdded)\n            throw new IllegalStateException(\"last?\");\n        _last = _last | allContentAdded;\n\n        // get a header buffer\n        if (_header == null)\n            _header = _buffers.getHeader();\n\n        boolean has_server = false;\n\n        try\n        {\n            if (isRequest())\n            {\n                _persistent=true;\n\n                if (_version == HttpVersions.HTTP_0_9_ORDINAL)\n                {\n                    _contentLength = HttpTokens.NO_CONTENT;\n                    _header.put(_method);\n                    _header.put((byte)' ');\n                    _header.put(_uri.getBytes(\"UTF-8\")); // TODO check\n                    _header.put(HttpTokens.CRLF);\n                    _state = STATE_FLUSHING;\n                    _noContent=true;\n                    return;\n                }\n                else\n                {\n                    _header.put(_method);\n                    _header.put((byte)' ');\n                    _header.put(_uri.getBytes(\"UTF-8\")); // TODO check\n                    _header.put((byte)' ');\n                    _header.put(_version==HttpVersions.HTTP_1_0_ORDINAL?HttpVersions.HTTP_1_0_BUFFER:HttpVersions.HTTP_1_1_BUFFER);\n                    _header.put(HttpTokens.CRLF);\n                }\n            }\n            else\n            {\n                // Responses\n                if (_version == HttpVersions.HTTP_0_9_ORDINAL)\n                {\n                    _persistent = false;\n                    _contentLength = HttpTokens.EOF_CONTENT;\n                    _state = STATE_CONTENT;\n                    return;\n                }\n                else\n                {\n                    if (_persistent==null)\n                        _persistent= (_version > HttpVersions.HTTP_1_0_ORDINAL);\n\n                    // add response line\n                    Status status = _status<__status.length?__status[_status]:null;\n\n                    if (status==null)\n                    {\n                        _header.put(HttpVersions.HTTP_1_1_BUFFER);\n                        _header.put((byte) ' ');\n                        _header.put((byte) ('0' + _status / 100));\n                        _header.put((byte) ('0' + (_status % 100) / 10));\n                        _header.put((byte) ('0' + (_status % 10)));\n                        _header.put((byte) ' ');\n                        if (_reason==null)\n                        {\n                            _header.put((byte) ('0' + _status / 100));\n                            _header.put((byte) ('0' + (_status % 100) / 10));\n                            _header.put((byte) ('0' + (_status % 10)));\n                        }\n                        else\n                            _header.put(_reason);\n                        _header.put(HttpTokens.CRLF);\n                    }\n                    else\n                    {\n                        if (_reason==null)\n                            _header.put(status._responseLine);\n                        else\n                        {\n                            _header.put(status._schemeCode);\n                            _header.put(_reason);\n                            _header.put(HttpTokens.CRLF);\n                        }\n                    }\n\n                    if (_status<200 && _status>=100 )\n                    {\n                        _noContent=true;\n                        _content=null;\n                        if (_buffer!=null)\n                            _buffer.clear();\n                        // end the header.\n\n                        if (_status!=101 )\n                        {\n                            _header.put(HttpTokens.CRLF);\n                            _state = STATE_CONTENT;\n                            return;\n                        }\n                    }\n                    else if (_status==204 || _status==304)\n                    {\n                        _noContent=true;\n                        _content=null;\n                        if (_buffer!=null)\n                            _buffer.clear();\n                    }\n                }\n            }\n\n            // Add headers\n            if (_status>=200 && _date!=null)\n            {\n                _header.put(HttpHeaders.DATE_BUFFER);\n                _header.put((byte)':');\n                _header.put((byte)' ');\n                _header.put(_date);\n                _header.put(CRLF);\n            }\n\n            // key field values\n            HttpFields.Field content_length = null;\n            HttpFields.Field transfer_encoding = null;\n            boolean keep_alive = false;\n            boolean close=false;\n            boolean content_type=false;\n            StringBuilder connection = null;\n\n            if (fields != null)\n            {\n                int s=fields.size();\n                for (int f=0;f<s;f++)\n                {\n                    HttpFields.Field field = fields.getField(f);\n                    if (field==null)\n                        continue;\n\n                    switch (field.getNameOrdinal())\n                    {\n                        case HttpHeaders.CONTENT_LENGTH_ORDINAL:\n                            content_length = field;\n                            _contentLength = field.getLongValue();\n\n                            if (_contentLength < _contentWritten || _last && _contentLength != _contentWritten)\n                                content_length = null;\n\n                            // write the field to the header buffer\n                            field.putTo(_header);\n                            break;\n\n                        case HttpHeaders.CONTENT_TYPE_ORDINAL:\n                            if (BufferUtil.isPrefix(MimeTypes.MULTIPART_BYTERANGES_BUFFER, field.getValueBuffer())) _contentLength = HttpTokens.SELF_DEFINING_CONTENT;\n\n                            // write the field to the header buffer\n                            content_type=true;\n                            field.putTo(_header);\n                            break;\n\n                        case HttpHeaders.TRANSFER_ENCODING_ORDINAL:\n                            if (_version == HttpVersions.HTTP_1_1_ORDINAL)\n                                transfer_encoding = field;\n                            // Do NOT add yet!\n                            break;\n\n                        case HttpHeaders.CONNECTION_ORDINAL:\n                            if (isRequest())\n                                field.putTo(_header);\n\n                            int connection_value = field.getValueOrdinal();\n                            switch (connection_value)\n                            {\n                                case -1:\n                                {\n                                    String[] values = field.getValue().split(\",\");\n                                    for  (int i=0;values!=null && i<values.length;i++)\n                                    {\n                                        CachedBuffer cb = HttpHeaderValues.CACHE.get(values[i].trim());\n\n                                        if (cb!=null)\n                                        {\n                                            switch(cb.getOrdinal())\n                                            {\n                                                case HttpHeaderValues.CLOSE_ORDINAL:\n                                                    close=true;\n                                                    if (isResponse())\n                                                        _persistent=false;\n                                                    keep_alive=false;\n                                                    if (!_persistent && isResponse() && _contentLength == HttpTokens.UNKNOWN_CONTENT)\n                                                        _contentLength = HttpTokens.EOF_CONTENT;\n                                                    break;\n\n                                                case HttpHeaderValues.KEEP_ALIVE_ORDINAL:\n                                                    if (_version == HttpVersions.HTTP_1_0_ORDINAL)\n                                                    {\n                                                        keep_alive = true;\n                                                        if (isResponse())\n                                                            _persistent = true;\n                                                    }\n                                                    break;\n\n                                                default:\n                                                    if (connection==null)\n                                                        connection=new StringBuilder();\n                                                    else\n                                                        connection.append(',');\n                                                    connection.append(values[i]);\n                                            }\n                                        }\n                                        else\n                                        {\n                                            if (connection==null)\n                                                connection=new StringBuilder();\n                                            else\n                                                connection.append(',');\n                                            connection.append(values[i]);\n                                        }\n                                    }\n\n                                    break;\n                                }\n                                case HttpHeaderValues.UPGRADE_ORDINAL:\n                                {\n                                    // special case for websocket connection ordering\n                                    if (isResponse())\n                                    {\n                                        field.putTo(_header);\n                                        continue;\n                                    }\n                                }\n                                case HttpHeaderValues.CLOSE_ORDINAL:\n                                {\n                                    close=true;\n                                    if (isResponse())\n                                        _persistent=false;\n                                    if (!_persistent && isResponse() && _contentLength == HttpTokens.UNKNOWN_CONTENT)\n                                        _contentLength = HttpTokens.EOF_CONTENT;\n                                    break;\n                                }\n                                case HttpHeaderValues.KEEP_ALIVE_ORDINAL:\n                                {\n                                    if (_version == HttpVersions.HTTP_1_0_ORDINAL)\n                                    {\n                                        keep_alive = true;\n                                        if (isResponse())\n                                            _persistent=true;\n                                    }\n                                    break;\n                                }\n                                default:\n                                {\n                                    if (connection==null)\n                                        connection=new StringBuilder();\n                                    else\n                                        connection.append(',');\n                                    connection.append(field.getValue());\n                                }\n                            }\n\n                            // Do NOT add yet!\n                            break;\n\n                        case HttpHeaders.SERVER_ORDINAL:\n                            if (getSendServerVersion())\n                            {\n                                has_server=true;\n                                field.putTo(_header);\n                            }\n                            break;\n\n                        default:\n                            // write the field to the header buffer\n                            field.putTo(_header);\n                    }\n                }\n            }\n\n            // Calculate how to end _content and connection, _content length and transfer encoding\n            // settings.\n            // From RFC 2616 4.4:\n            // 1. No body for 1xx, 204, 304 & HEAD response\n            // 2. Force _content-length?\n            // 3. If Transfer-Encoding!=identity && HTTP/1.1 && !HttpConnection==close then chunk\n            // 4. Content-Length\n            // 5. multipart/byteranges\n            // 6. close\n            switch ((int) _contentLength)\n            {\n                case HttpTokens.UNKNOWN_CONTENT:\n                    // It may be that we have no _content, or perhaps _content just has not been\n                    // written yet?\n\n                    // Response known not to have a body\n                    if (_contentWritten == 0 && isResponse() && (_status < 200 || _status == 204 || _status == 304))\n                        _contentLength = HttpTokens.NO_CONTENT;\n                    else if (_last)\n                    {\n                        // we have seen all the _content there is\n                        _contentLength = _contentWritten;\n                        if (content_length == null && (isResponse() || _contentLength>0 || content_type ) && !_noContent)\n                        {\n                            // known length but not actually set.\n                            _header.put(HttpHeaders.CONTENT_LENGTH_BUFFER);\n                            _header.put(HttpTokens.COLON);\n                            _header.put((byte) ' ');\n                            BufferUtil.putDecLong(_header, _contentLength);\n                            _header.put(HttpTokens.CRLF);\n                        }\n                    }\n                    else\n                    {\n                        // No idea, so we must assume that a body is coming\n                        _contentLength = (!_persistent || _version < HttpVersions.HTTP_1_1_ORDINAL ) ? HttpTokens.EOF_CONTENT : HttpTokens.CHUNKED_CONTENT;\n                        if (isRequest() && _contentLength==HttpTokens.EOF_CONTENT)\n                        {\n                            _contentLength=HttpTokens.NO_CONTENT;\n                            _noContent=true;\n                        }\n                    }\n                    break;\n\n                case HttpTokens.NO_CONTENT:\n                    if (content_length == null && isResponse() && _status >= 200 && _status != 204 && _status != 304)\n                        _header.put(CONTENT_LENGTH_0);\n                    break;\n\n                case HttpTokens.EOF_CONTENT:\n                    _persistent = isRequest();\n                    break;\n\n                case HttpTokens.CHUNKED_CONTENT:\n                    break;\n\n                default:\n                    // TODO - maybe allow forced chunking by setting te ???\n                    break;\n            }\n\n            // Add transfer_encoding if needed\n            if (_contentLength == HttpTokens.CHUNKED_CONTENT)\n            {\n                // try to use user supplied encoding as it may have other values.\n                if (transfer_encoding != null && HttpHeaderValues.CHUNKED_ORDINAL != transfer_encoding.getValueOrdinal())\n                {\n                    String c = transfer_encoding.getValue();\n                    if (c.endsWith(HttpHeaderValues.CHUNKED))\n                        transfer_encoding.putTo(_header);\n                    else\n                        throw new IllegalArgumentException(\"BAD TE\");\n                }\n                else\n                    _header.put(TRANSFER_ENCODING_CHUNKED);\n            }\n\n            // Handle connection if need be\n            if (_contentLength==HttpTokens.EOF_CONTENT)\n            {\n                keep_alive=false;\n                _persistent=false;\n            }\n\n            if (isResponse())\n            {\n                if (!_persistent && (close || _version > HttpVersions.HTTP_1_0_ORDINAL))\n                {\n                    _header.put(CONNECTION_CLOSE);\n                    if (connection!=null)\n                    {\n                        _header.setPutIndex(_header.putIndex()-2);\n                        _header.put((byte)',');\n                        _header.put(connection.toString().getBytes());\n                        _header.put(CRLF);\n                    }\n                }\n                else if (keep_alive)\n                {\n                    _header.put(CONNECTION_KEEP_ALIVE);\n                    if (connection!=null)\n                    {\n                        _header.setPutIndex(_header.putIndex()-2);\n                        _header.put((byte)',');\n                        _header.put(connection.toString().getBytes());\n                        _header.put(CRLF);\n                    }\n                }\n                else if (connection!=null)\n                {\n                    _header.put(CONNECTION_);\n                    _header.put(connection.toString().getBytes());\n                    _header.put(CRLF);\n                }\n            }\n\n            if (!has_server && _status>199 && getSendServerVersion())\n                _header.put(SERVER);\n\n            // end the header.\n            _header.put(HttpTokens.CRLF);\n            _state = STATE_CONTENT;\n\n        }\n        catch(ArrayIndexOutOfBoundsException e)\n        {\n            throw new RuntimeException(\"Header>\"+_header.capacity(),e);\n        }\n    }","commit_id":"0e541c4c243ccb923f20f6de62ab646d87c9617d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public EndpointConfiguration createConfiguration(String uri) throws Exception {\n        return null;\n    }","id":90549,"modified_method":"public EndpointConfiguration createConfiguration(String uri) throws Exception {\n        MappedEndpointConfiguration config = new MappedEndpointConfiguration(this);\n        config.setURI(new URI(uri));\n        return config;\n    }","commit_id":"0ce697358582d4b74641fc8615d68985a2651085","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Sets the URI that created this endpoint.\n     */\n    protected void setEndpointUri(String endpointUri) {\n        if (endpointUri == null) {\n            config = null;\n            return;\n        }\n        MappedEndpointConfiguration cfg = new MappedEndpointConfiguration(component);\n        try {\n            cfg.setURI(new URI(endpointUri));\n        } catch (URISyntaxException e) {\n            throw new RuntimeCamelException(e);\n        }\n        config = cfg;\n    }","id":90550,"modified_method":"/**\n     * Sets the URI that created this endpoint.\n     */\n    protected void setEndpointUri(String endpointUri) {\n        if (endpointUri == null) {\n            config = null;\n            return;\n        }\n        try {\n            if (component != null) {\n                config = component.createConfiguration(endpointUri);\n            } else {\n                MappedEndpointConfiguration cfg = new MappedEndpointConfiguration(null);\n                cfg.setURI(new URI(endpointUri));\n                config = cfg;\n            }\n        } catch (Exception e) {\n            throw new RuntimeCamelException(e);\n        }\n    }","commit_id":"0ce697358582d4b74641fc8615d68985a2651085","url":"https://github.com/apache/camel"},{"original_method":"@Override\n        public ByteBuffer next()\n        {\n            synchronized (lock)\n            {\n                Chunk chunk = current = chunks.poll();\n                if (chunk == CLOSE)\n                    throw new NoSuchElementException();\n                return chunk == null ? null : chunk.buffer;\n            }\n        }","id":90551,"modified_method":"@Override\n        public ByteBuffer next()\n        {\n            synchronized (lock)\n            {\n                Chunk chunk = current = chunks.poll();\n                if (chunk == CLOSE)\n                {\n                    // Slow path: reinsert the CLOSE chunk\n                    // so that hasNext() works correctly.\n                    chunks.add(0, CLOSE);\n                    throw new NoSuchElementException();\n                }\n                return chunk == null ? null : chunk.buffer;\n            }\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Advances the cursor to the next block of content.\n     * <p />\n     * The next block of content may be valid (which yields a non-null buffer\n     * returned by {@link #getByteBuffer()}), but may also be deferred\n     * (which yields a null buffer returned by {@link #getByteBuffer()}).\n     * <p />\n     * If the block of content pointed by the new cursor position is valid, this method returns true.\n     *\n     * @return true if there is content at the new cursor's position, false otherwise.\n     */\n    public boolean advance()\n    {\n        if (isLast())\n        {\n            if (content != AFTER)\n            {\n                content = buffer = AFTER;\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Advanced content past last chunk\");\n            }\n            return false;\n        }\n        else\n        {\n            ByteBuffer buffer = this.buffer = iterator.next();\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Advanced content to {} chunk {}\", isLast() ? \"last\" : \"next\", buffer);\n            content = buffer == null ? null : buffer.slice();\n            return buffer != null;\n        }\n    }","id":90552,"modified_method":"/**\n     * Advances the cursor to the next block of content.\n     * <p />\n     * The next block of content may be valid (which yields a non-null buffer\n     * returned by {@link #getByteBuffer()}), but may also be deferred\n     * (which yields a null buffer returned by {@link #getByteBuffer()}).\n     * <p />\n     * If the block of content pointed by the new cursor position is valid, this method returns true.\n     *\n     * @return true if there is content at the new cursor's position, false otherwise.\n     */\n    public boolean advance()\n    {\n        boolean advanced;\n        boolean hasNext;\n        ByteBuffer bytes;\n        if (iterator instanceof Synchronizable)\n        {\n            synchronized (((Synchronizable)iterator).getLock())\n            {\n                advanced = iterator.hasNext();\n                bytes = advanced ? iterator.next() : null;\n                hasNext = advanced && iterator.hasNext();\n            }\n        }\n        else\n        {\n            advanced = iterator.hasNext();\n            bytes = advanced ? iterator.next() : null;\n            hasNext = advanced && iterator.hasNext();\n        }\n\n        if (advanced)\n        {\n            buffer = bytes;\n            content = bytes == null ? null : bytes.slice();\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Advanced content to {} chunk {}\", hasNext ? \"next\" : \"last\", bytes);\n            return bytes != null;\n        }\n        else\n        {\n            if (content != AFTER)\n            {\n                content = buffer = AFTER;\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Advanced content past last chunk\");\n            }\n            return false;\n        }\n    }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void succeeded()\n        {\n            try\n            {\n                content.succeeded();\n                process();\n            }\n            // Catch-all for runtime exceptions\n            catch (Exception x)\n            {\n                anyToFailure(x);\n            }\n        }","id":90553,"modified_method":"@Override\n        public void succeeded()\n        {\n            try\n            {\n                HttpContent content = HttpSender.this.content;\n                if (content == null)\n                    return;\n                content.succeeded();\n                process();\n            }\n            catch (Throwable x)\n            {\n                anyToFailure(x);\n            }\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onContent()\n    {\n        HttpExchange exchange = getHttpExchange();\n        if (exchange == null)\n            return;\n\n        while (true)\n        {\n            SenderState current = senderState.get();\n            switch (current)\n            {\n                case IDLE:\n                {\n                    SenderState newSenderState = SenderState.SENDING;\n                    if (updateSenderState(current, newSenderState))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Deferred content available, {} -> {}\", current, newSenderState);\n                        contentCallback.iterate();\n                        return;\n                    }\n                    break;\n                }\n                case SENDING:\n                {\n                    SenderState newSenderState = SenderState.SENDING_WITH_CONTENT;\n                    if (updateSenderState(current, newSenderState))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Deferred content available, {} -> {}\", current, newSenderState);\n                        return;\n                    }\n                    break;\n                }\n                case EXPECTING:\n                {\n                    SenderState newSenderState = SenderState.EXPECTING_WITH_CONTENT;\n                    if (updateSenderState(current, newSenderState))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Deferred content available, {} -> {}\", current, newSenderState);\n                        return;\n                    }\n                    break;\n                }\n                case PROCEEDING:\n                {\n                    SenderState newSenderState = SenderState.PROCEEDING_WITH_CONTENT;\n                    if (updateSenderState(current, newSenderState))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Deferred content available, {} -> {}\", current, newSenderState);\n                        return;\n                    }\n                    break;\n                }\n                case SENDING_WITH_CONTENT:\n                case EXPECTING_WITH_CONTENT:\n                case PROCEEDING_WITH_CONTENT:\n                case WAITING:\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Deferred content available, {}\", current);\n                    return;\n                }\n                default:\n                {\n                    throw illegalSenderState(current);\n                }\n            }\n        }\n    }","id":90554,"modified_method":"@Override\n    public void onContent()\n    {\n        HttpExchange exchange = getHttpExchange();\n        if (exchange == null)\n            return;\n\n        while (true)\n        {\n            SenderState current = senderState.get();\n            switch (current)\n            {\n                case IDLE:\n                {\n                    SenderState newSenderState = SenderState.SENDING;\n                    if (updateSenderState(current, newSenderState))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Deferred content available, {} -> {}\", current, newSenderState);\n                        contentCallback.iterate();\n                        return;\n                    }\n                    break;\n                }\n                case SENDING:\n                {\n                    SenderState newSenderState = SenderState.SENDING_WITH_CONTENT;\n                    if (updateSenderState(current, newSenderState))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Deferred content available, {} -> {}\", current, newSenderState);\n                        return;\n                    }\n                    break;\n                }\n                case EXPECTING:\n                {\n                    SenderState newSenderState = SenderState.EXPECTING_WITH_CONTENT;\n                    if (updateSenderState(current, newSenderState))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Deferred content available, {} -> {}\", current, newSenderState);\n                        return;\n                    }\n                    break;\n                }\n                case PROCEEDING:\n                {\n                    SenderState newSenderState = SenderState.PROCEEDING_WITH_CONTENT;\n                    if (updateSenderState(current, newSenderState))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Deferred content available, {} -> {}\", current, newSenderState);\n                        return;\n                    }\n                    break;\n                }\n                case SENDING_WITH_CONTENT:\n                case EXPECTING_WITH_CONTENT:\n                case PROCEEDING_WITH_CONTENT:\n                case WAITING:\n                case COMPLETED:\n                case FAILED:\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Deferred content available, {}\", current);\n                    return;\n                }\n                default:\n                {\n                    illegalSenderState(current);\n                    return;\n                }\n            }\n        }\n    }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void reset()\n    {\n        content.close();\n        content = null;\n        senderState.set(SenderState.IDLE);\n    }","id":90555,"modified_method":"protected void reset()\n    {\n        HttpContent content = this.content;\n        this.content = null;\n        content.close();\n        senderState.set(SenderState.COMPLETED);\n    }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected void dispose()\n    {\n        HttpContent content = this.content;\n        if (content != null)\n            content.close();\n    }","id":90556,"modified_method":"protected void dispose()\n    {\n        HttpContent content = this.content;\n        this.content = null;\n        if (content != null)\n            content.close();\n        senderState.set(SenderState.FAILED);\n    }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void proceed(HttpExchange exchange, Throwable failure)\n    {\n        if (!expects100Continue(exchange.getRequest()))\n            return;\n\n        if (failure != null)\n        {\n            anyToFailure(failure);\n            return;\n        }\n\n        while (true)\n        {\n            SenderState current = senderState.get();\n            switch (current)\n            {\n                case EXPECTING:\n                {\n                    // We are still sending the headers, but we already got the 100 Continue.\n                    if (updateSenderState(current, SenderState.PROCEEDING))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Proceeding while expecting\");\n                        return;\n                    }\n                    break;\n                }\n                case EXPECTING_WITH_CONTENT:\n                {\n                    // More deferred content was submitted to onContent(), we already\n                    // got the 100 Continue, but we may be still sending the headers\n                    // (for example, with SSL we may have sent the encrypted data,\n                    // received the 100 Continue but not yet updated the decrypted\n                    // WriteFlusher so sending more content now may result in a\n                    // WritePendingException).\n                    if (updateSenderState(current, SenderState.PROCEEDING_WITH_CONTENT))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Proceeding while scheduled\");\n                        return;\n                    }\n                    break;\n                }\n                case WAITING:\n                {\n                    // We received the 100 Continue, now send the content if any.\n                    if (!updateSenderState(current, SenderState.SENDING))\n                        throw illegalSenderState(current);\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"Proceeding while waiting\");\n                    contentCallback.iterate();\n                    return;\n                }\n                default:\n                {\n                    throw illegalSenderState(current);\n                }\n            }\n        }\n    }","id":90557,"modified_method":"public void proceed(HttpExchange exchange, Throwable failure)\n    {\n        if (!expects100Continue(exchange.getRequest()))\n            return;\n\n        if (failure != null)\n        {\n            anyToFailure(failure);\n            return;\n        }\n\n        while (true)\n        {\n            SenderState current = senderState.get();\n            switch (current)\n            {\n                case EXPECTING:\n                {\n                    // We are still sending the headers, but we already got the 100 Continue.\n                    if (updateSenderState(current, SenderState.PROCEEDING))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Proceeding while expecting\");\n                        return;\n                    }\n                    break;\n                }\n                case EXPECTING_WITH_CONTENT:\n                {\n                    // More deferred content was submitted to onContent(), we already\n                    // got the 100 Continue, but we may be still sending the headers\n                    // (for example, with SSL we may have sent the encrypted data,\n                    // received the 100 Continue but not yet updated the decrypted\n                    // WriteFlusher so sending more content now may result in a\n                    // WritePendingException).\n                    if (updateSenderState(current, SenderState.PROCEEDING_WITH_CONTENT))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Proceeding while scheduled\");\n                        return;\n                    }\n                    break;\n                }\n                case WAITING:\n                {\n                    // We received the 100 Continue, now send the content if any.\n                    if (updateSenderState(current, SenderState.SENDING))\n                    {\n                        if (LOG.isDebugEnabled())\n                            LOG.debug(\"Proceeding while waiting\");\n                        contentCallback.iterate();\n                        return;\n                    }\n                    break;\n                }\n                case FAILED:\n                {\n                    return;\n                }\n                default:\n                {\n                    illegalSenderState(current);\n                    return;\n                }\n            }\n        }\n    }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private RuntimeException illegalSenderState(SenderState current)\n    {\n        return new IllegalStateException(\"Expected \" + current + \" found \" + senderState.get() + \" instead\");\n    }","id":90558,"modified_method":"private void illegalSenderState(SenderState current)\n    {\n        anyToFailure(new IllegalStateException(\"Expected \" + current + \" found \" + senderState.get() + \" instead\"));\n    }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        protected Action process() throws Exception\n        {\n            HttpExchange exchange = getHttpExchange();\n            if (exchange == null)\n                return Action.IDLE;\n\n            HttpContent content = HttpSender.this.content;\n            while (true)\n            {\n                boolean advanced = content.advance();\n                boolean consumed = content.isConsumed();\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Content {} consumed {} for {}\", advanced, consumed, exchange.getRequest());\n\n                if (advanced)\n                {\n                    sendContent(exchange, content, this);\n                    return Action.SCHEDULED;\n                }\n\n                if (consumed)\n                {\n                    sendContent(exchange, content, lastCallback);\n                    return Action.IDLE;\n                }\n\n                SenderState current = HttpSender.this.senderState.get();\n                switch (current)\n                {\n                    case SENDING:\n                    {\n                        if (updateSenderState(current, SenderState.IDLE))\n                        {\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"Content is deferred for {}\", exchange.getRequest());\n                            return Action.IDLE;\n                        }\n                        break;\n                    }\n                    case SENDING_WITH_CONTENT:\n                    {\n                        updateSenderState(current, SenderState.SENDING);\n                        break;\n                    }\n                    default:\n                    {\n                        throw illegalSenderState(current);\n                    }\n                }\n            }\n        }","id":90559,"modified_method":"@Override\n        protected Action process() throws Exception\n        {\n            HttpExchange exchange = getHttpExchange();\n            if (exchange == null)\n                return Action.IDLE;\n\n            HttpContent content = HttpSender.this.content;\n            if (content == null)\n                return Action.IDLE;\n\n            while (true)\n            {\n                boolean advanced = content.advance();\n                boolean consumed = content.isConsumed();\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Content {} consumed {} for {}\", advanced, consumed, exchange.getRequest());\n\n                if (advanced)\n                {\n                    sendContent(exchange, content, this);\n                    return Action.SCHEDULED;\n                }\n\n                if (consumed)\n                {\n                    sendContent(exchange, content, lastCallback);\n                    return Action.IDLE;\n                }\n\n                SenderState current = senderState.get();\n                switch (current)\n                {\n                    case SENDING:\n                    {\n                        if (updateSenderState(current, SenderState.IDLE))\n                        {\n                            if (LOG.isDebugEnabled())\n                                LOG.debug(\"Content is deferred for {}\", exchange.getRequest());\n                            return Action.IDLE;\n                        }\n                        break;\n                    }\n                    case SENDING_WITH_CONTENT:\n                    {\n                        updateSenderState(current, SenderState.SENDING);\n                        break;\n                    }\n                    default:\n                    {\n                        illegalSenderState(current);\n                        return Action.IDLE;\n                    }\n                }\n            }\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void onCompleteFailure(Throwable failure)\n        {\n            content.failed(failure);\n            anyToFailure(failure);\n        }","id":90560,"modified_method":"@Override\n        public void onCompleteFailure(Throwable failure)\n        {\n            HttpContent content = HttpSender.this.content;\n            if (content == null)\n                return;\n            content.failed(failure);\n            anyToFailure(failure);\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void process() throws Exception\n        {\n            HttpExchange exchange = getHttpExchange();\n            if (exchange == null)\n                return;\n\n            Request request = exchange.getRequest();\n            if (!headersToCommit(request))\n                return;\n\n            HttpContent content = HttpSender.this.content;\n\n            if (!content.hasContent())\n            {\n                // No content to send, we are done.\n                someToSuccess(exchange);\n            }\n            else\n            {\n                // Was any content sent while committing ?\n                ByteBuffer contentBuffer = content.getContent();\n                if (contentBuffer != null)\n                {\n                    if (!someToContent(request, contentBuffer))\n                        return;\n                }\n\n                while (true)\n                {\n                    SenderState current = senderState.get();\n                    switch (current)\n                    {\n                        case SENDING:\n                        {\n                            contentCallback.iterate();\n                            return;\n                        }\n                        case SENDING_WITH_CONTENT:\n                        {\n                            // We have deferred content to send.\n                            updateSenderState(current, SenderState.SENDING);\n                            break;\n                        }\n                        case EXPECTING:\n                        {\n                            // We sent the headers, wait for the 100 Continue response.\n                            if (updateSenderState(current, SenderState.WAITING))\n                                return;\n                            break;\n                        }\n                        case EXPECTING_WITH_CONTENT:\n                        {\n                            // We sent the headers, we have deferred content to send,\n                            // wait for the 100 Continue response.\n                            if (updateSenderState(current, SenderState.WAITING))\n                                return;\n                            break;\n                        }\n                        case PROCEEDING:\n                        {\n                            // We sent the headers, we have the 100 Continue response,\n                            // we have no content to send.\n                            if (updateSenderState(current, SenderState.IDLE))\n                                return;\n                            break;\n                        }\n                        case PROCEEDING_WITH_CONTENT:\n                        {\n                            // We sent the headers, we have the 100 Continue response,\n                            // we have deferred content to send.\n                            updateSenderState(current, SenderState.SENDING);\n                            break;\n                        }\n                        default:\n                        {\n                            throw illegalSenderState(current);\n                        }\n                    }\n                }\n            }\n        }","id":90561,"modified_method":"private void process() throws Exception\n        {\n            HttpExchange exchange = getHttpExchange();\n            if (exchange == null)\n                return;\n\n            Request request = exchange.getRequest();\n            if (!headersToCommit(request))\n                return;\n\n             HttpContent content = HttpSender.this.content;\n            if (content == null)\n                return;\n\n            if (!content.hasContent())\n            {\n                // No content to send, we are done.\n                someToSuccess(exchange);\n            }\n            else\n            {\n                // Was any content sent while committing ?\n                ByteBuffer contentBuffer = content.getContent();\n                if (contentBuffer != null)\n                {\n                    if (!someToContent(request, contentBuffer))\n                        return;\n                }\n\n                while (true)\n                {\n                    SenderState current = senderState.get();\n                    switch (current)\n                    {\n                        case SENDING:\n                        {\n                            contentCallback.iterate();\n                            return;\n                        }\n                        case SENDING_WITH_CONTENT:\n                        {\n                            // We have deferred content to send.\n                            updateSenderState(current, SenderState.SENDING);\n                            break;\n                        }\n                        case EXPECTING:\n                        {\n                            // We sent the headers, wait for the 100 Continue response.\n                            if (updateSenderState(current, SenderState.WAITING))\n                                return;\n                            break;\n                        }\n                        case EXPECTING_WITH_CONTENT:\n                        {\n                            // We sent the headers, we have deferred content to send,\n                            // wait for the 100 Continue response.\n                            if (updateSenderState(current, SenderState.WAITING))\n                                return;\n                            break;\n                        }\n                        case PROCEEDING:\n                        {\n                            // We sent the headers, we have the 100 Continue response,\n                            // we have no content to send.\n                            if (updateSenderState(current, SenderState.IDLE))\n                                return;\n                            break;\n                        }\n                        case PROCEEDING_WITH_CONTENT:\n                        {\n                            // We sent the headers, we have the 100 Continue response,\n                            // we have deferred content to send.\n                            updateSenderState(current, SenderState.SENDING);\n                            break;\n                        }\n                        case FAILED:\n                        {\n                            return;\n                        }\n                        default:\n                        {\n                            illegalSenderState(current);\n                            return;\n                        }\n                    }\n                }\n            }\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void succeeded()\n        {\n            ByteBuffer buffer = content.getContent();\n            someToContent(getHttpExchange().getRequest(), buffer);\n            content.succeeded();\n            super.succeeded();\n        }","id":90562,"modified_method":"@Override\n        public void succeeded()\n        {\n            HttpExchange exchange = getHttpExchange();\n            if (exchange == null)\n                return;\n            HttpContent content = HttpSender.this.content;\n            if (content == null)\n                return;\n            content.succeeded();\n            ByteBuffer buffer = content.getContent();\n            someToContent(exchange.getRequest(), buffer);\n            super.succeeded();\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void succeeded()\n        {\n            content.succeeded();\n            HttpExchange exchange = getHttpExchange();\n            if (exchange == null)\n                return;\n            someToSuccess(exchange);\n        }","id":90563,"modified_method":"@Override\n        public void succeeded()\n        {\n            HttpExchange exchange = getHttpExchange();\n            if (exchange == null)\n                return;\n            HttpContent content = HttpSender.this.content;\n            if (content == null)\n                return;\n            content.succeeded();\n            someToSuccess(exchange);\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void send(HttpExchange exchange)\n    {\n        Request request = exchange.getRequest();\n        if (!queuedToBegin(request))\n            return;\n\n        ContentProvider contentProvider = request.getContent();\n        HttpContent content = this.content = new HttpContent(contentProvider);\n\n        SenderState newSenderState = SenderState.SENDING;\n        if (expects100Continue(request))\n            newSenderState = content.hasContent() ? SenderState.EXPECTING_WITH_CONTENT : SenderState.EXPECTING;\n        if (!updateSenderState(SenderState.IDLE, newSenderState))\n            throw illegalSenderState(SenderState.IDLE);\n\n        // Setting the listener may trigger calls to onContent() by other\n        // threads so we must set it only after the sender state has been updated\n        if (contentProvider instanceof AsyncContentProvider)\n            ((AsyncContentProvider)contentProvider).setListener(this);\n\n        if (!beginToHeaders(request))\n            return;\n\n        sendHeaders(exchange, content, commitCallback);\n    }","id":90564,"modified_method":"public void send(HttpExchange exchange)\n    {\n        Request request = exchange.getRequest();\n        if (!queuedToBegin(request))\n            return;\n\n        ContentProvider contentProvider = request.getContent();\n        HttpContent content = this.content = new HttpContent(contentProvider);\n\n        SenderState newSenderState = SenderState.SENDING;\n        if (expects100Continue(request))\n            newSenderState = content.hasContent() ? SenderState.EXPECTING_WITH_CONTENT : SenderState.EXPECTING;\n\n        out: while (true)\n        {\n            SenderState current = senderState.get();\n            switch (current)\n            {\n                case IDLE:\n                case COMPLETED:\n                {\n                    if (updateSenderState(current, newSenderState))\n                        break out;\n                    break;\n                }\n                default:\n                {\n                    illegalSenderState(current);\n                    return;\n                }\n            }\n        }\n\n        // Setting the listener may trigger calls to onContent() by other\n        // threads so we must set it only after the sender state has been updated\n        if (contentProvider instanceof AsyncContentProvider)\n            ((AsyncContentProvider)contentProvider).setListener(this);\n\n        if (!beginToHeaders(request))\n            return;\n\n        sendHeaders(exchange, content, commitCallback);\n    }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void failed(Throwable failure)\n        {\n            content.failed(failure);\n            anyToFailure(failure);\n        }","id":90565,"modified_method":"@Override\n        public void failed(Throwable failure)\n        {\n            HttpContent content = HttpSender.this.content;\n            if (content == null)\n                return;\n            content.failed(failure);\n            anyToFailure(failure);\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void failed(Throwable failure)\n        {\n            content.failed(failure);\n            anyToFailure(failure);\n        }","id":90566,"modified_method":"@Override\n        public void failed(Throwable failure)\n        {\n            HttpContent content = HttpSender.this.content;\n            if (content == null)\n                return;\n            content.failed(failure);\n            anyToFailure(failure);\n        }","commit_id":"7c915bcba27d958febe18be658dab39e8fd1f063","url":"https://github.com/eclipse/jetty.project"},{"original_method":"void prepend(StandardSession.FrameBytes frameBytes)\n    {\n        Throwable failure;\n        synchronized (lock)\n        {\n            failure = this.failure;\n            if (failure == null)\n            {\n                // Scan from the front of the queue looking to skip higher priority messages\n                int index = 0;\n                int size=queue.size();\n                while (index < size)\n                {\n                    StandardSession.FrameBytes element = queue.getUnsafe(index);\n                    if (element.compareTo(frameBytes) <= 0)\n                        break;\n                    ++index;\n                }\n                queue.add(index, frameBytes);\n            }\n        }\n\n        // If no failures make sure we are iterating\n        if (failure == null)\n            flush();\n        else\n            frameBytes.failed(new SPDYException(failure));\n    }","id":90567,"modified_method":"public Throwable prepend(StandardSession.FrameBytes frameBytes)\n    {\n        synchronized (lock)\n        {\n            Throwable failure = this.failure;\n            if (failure == null)\n            {\n                // Scan from the front of the queue looking to skip higher priority messages\n                int index = 0;\n                int size = queue.size();\n                while (index < size)\n                {\n                    StandardSession.FrameBytes element = queue.getUnsafe(index);\n                    if (element.compareTo(frameBytes) <= 0)\n                        break;\n                    ++index;\n                }\n                queue.add(index, frameBytes);\n            }\n            return failure;\n        }\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"void flush()\n    {\n        flusherCB.iterate();\n    }","id":90568,"modified_method":"public void flush()\n    {\n        callback.iterate();\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"void removeFrameBytesFromQueue(Stream stream)\n    {\n        synchronized (lock)\n        {\n            for (StandardSession.FrameBytes frameBytes : queue)\n                if (frameBytes.getStream() == stream)\n                    queue.remove(frameBytes);\n        }\n    }","id":90569,"modified_method":"public void removeFrameBytesFromQueue(Stream stream)\n    {\n        synchronized (lock)\n        {\n            for (StandardSession.FrameBytes frameBytes : queue)\n                if (frameBytes.getStream() == stream)\n                    queue.remove(frameBytes);\n        }\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"void append(StandardSession.FrameBytes frameBytes)\n    {\n        Throwable failure;\n        synchronized (lock)\n        {\n            failure = this.failure;\n            if (failure == null)\n            {\n                // Control frames are added in order\n                if (frameBytes instanceof StandardSession.ControlFrameBytes)\n                    queue.add(frameBytes);\n                else\n                {\n                    // Otherwise scan from the back of the queue to insert by priority\n                    int index = queue.size();\n                    while (index > 0)\n                    {\n                        StandardSession.FrameBytes element = queue.getUnsafe(index - 1);\n                        if (element.compareTo(frameBytes) >= 0)\n                            break;\n                        --index;\n                    }\n                    queue.add(index, frameBytes);\n                }\n            }\n        }\n        \n        // If no failures make sure we are iterating\n        if (failure == null)\n            flush();\n        else\n            frameBytes.failed(new SPDYException(failure));\n    }","id":90570,"modified_method":"public Throwable append(StandardSession.FrameBytes frameBytes)\n    {\n        synchronized (lock)\n        {\n            Throwable failure = this.failure;\n            if (failure == null)\n            {\n                // Non DataFrameBytes are inserted last\n                queue.add(frameBytes);\n            }\n            return failure;\n        }\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Flusher(Controller controller)\n    {\n        this.controller = controller;\n    }","id":90571,"modified_method":"public Flusher(Controller controller)\n    {\n        this(controller, 8);\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void generateAndEnqueueControlFrame(IStream stream, ControlFrame frame, long timeout, TimeUnit unit, Callback callback)\n    {\n        try\n        {\n            // Synchronization is necessary, since we may have concurrent replies\n            // and those needs to be generated and enqueued atomically in order\n            // to maintain a correct compression context\n            synchronized (this)\n            {\n                ByteBuffer buffer = generator.control(frame);\n                LOG.debug(\"Queuing {} on {}\", frame, stream);\n                ControlFrameBytes frameBytes = new ControlFrameBytes(stream, callback, frame, buffer);\n                if (timeout > 0)\n                    frameBytes.task = scheduler.schedule(frameBytes, timeout, unit);\n\n                // Special handling for PING frames, they must be sent as soon as possible\n                if (ControlFrameType.PING == frame.getType())\n                    flusher.prepend(frameBytes);\n                else\n                    flusher.append(frameBytes);\n            }\n        }\n        catch (Exception x)\n        {\n            notifyCallbackFailed(callback, x);\n        }\n    }","id":90572,"modified_method":"private void generateAndEnqueueControlFrame(IStream stream, ControlFrame frame, long timeout, TimeUnit unit, Callback callback)\n    {\n        try\n        {\n            // Synchronization is necessary, since we may have concurrent replies\n            // and those needs to be generated and enqueued atomically in order\n            // to maintain a correct compression context\n            ControlFrameBytes frameBytes;\n            Throwable throwable;\n            synchronized (this)\n            {\n                ByteBuffer buffer = generator.control(frame);\n                LOG.debug(\"Queuing {} on {}\", frame, stream);\n                frameBytes = new ControlFrameBytes(stream, callback, frame, buffer);\n                if (timeout > 0)\n                    frameBytes.task = scheduler.schedule(frameBytes, timeout, unit);\n\n                // Special handling for PING frames, they must be sent as soon as possible\n                if (ControlFrameType.PING == frame.getType())\n                    throwable = flusher.prepend(frameBytes);\n                else\n                    throwable = flusher.append(frameBytes);\n            }\n            // Flush MUST be done outside synchronized blocks\n            flush(frameBytes, throwable);\n        }\n        catch (Exception x)\n        {\n            notifyCallbackFailed(callback, x);\n        }\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onStreamException(StreamException x)\n    {\n        // TODO: rename to onFailure\n        notifyOnException(listener, x); //TODO: notify StreamFrameListener if exists?\n        rst(new RstInfo(x.getStreamId(), x.getStreamStatus()), new Callback.Adapter());\n    }","id":90573,"modified_method":"@Override\n    public void onStreamException(StreamException x)\n    {\n        notifyOnFailure(listener, x); // TODO: notify StreamFrameListener if exists?\n        rst(new RstInfo(x.getStreamId(), x.getStreamStatus()), new Callback.Adapter());\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n        public void succeeded()\n        {\n            bufferPool.release(buffer);\n            IStream stream = getStream();\n            dataInfo.consume(size);\n            flowControlStrategy.updateWindow(StandardSession.this, stream, -size);\n            if (dataInfo.available() > 0)\n            {\n                // We have written a frame out of this DataInfo, but there is more to write.\n                // We need to keep the correct ordering of frames, to avoid that another\n                // DataInfo for the same stream is written before this one is finished.\n                flusher.prepend(this);\n            }\n            else\n            {\n                super.succeeded();\n                stream.updateCloseState(dataInfo.isClose(), true);\n                if (stream.isClosed())\n                    removeStream(stream);\n            }\n        }","id":90574,"modified_method":"@Override\n        public void succeeded()\n        {\n            bufferPool.release(buffer);\n            IStream stream = getStream();\n            dataInfo.consume(size);\n            flowControlStrategy.updateWindow(StandardSession.this, stream, -size);\n            if (dataInfo.available() > 0)\n            {\n                // We have written a frame out of this DataInfo, but there is more to write.\n                // We need to keep the correct ordering of frames, to avoid that another\n                // DataInfo for the same stream is written before this one is finished.\n                flush(this, flusher.prepend(this));\n            }\n            else\n            {\n                super.succeeded();\n                stream.updateCloseState(dataInfo.isClose(), true);\n                if (stream.isClosed())\n                    removeStream(stream);\n            }\n        }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void shutdown()\n    {\n        FrameBytes frameBytes = new CloseFrameBytes();\n        flusher.append(frameBytes);\n    }","id":90575,"modified_method":"@Override\n    public void shutdown()\n    {\n        CloseFrameBytes frameBytes = new CloseFrameBytes();\n        flush(frameBytes, flusher.append(frameBytes));\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void notifyOnException(SessionFrameListener listener, Throwable x)\n    {\n        try\n        {\n            if (listener != null)\n            {\n                LOG.debug(\"Invoking callback with {} on listener {}\", x, listener);\n                listener.onFailure(this, x);\n            }\n        }\n        catch (Exception xx)\n        {\n            LOG.info(\"Exception while notifying listener \" + listener, xx);\n        }\n        catch (Error xx)\n        {\n            LOG.info(\"Exception while notifying listener \" + listener, xx);\n            throw xx;\n        }\n    }","id":90576,"modified_method":"private void notifyOnFailure(SessionFrameListener listener, Throwable x)\n    {\n        try\n        {\n            if (listener != null)\n            {\n                LOG.debug(\"Invoking callback with {} on listener {}\", x, listener);\n                listener.onFailure(this, x);\n            }\n        }\n        catch (Exception xx)\n        {\n            LOG.info(\"Exception while notifying listener \" + listener, xx);\n        }\n        catch (Error xx)\n        {\n            LOG.info(\"Exception while notifying listener \" + listener, xx);\n            throw xx;\n        }\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void data(IStream stream, DataInfo dataInfo, long timeout, TimeUnit unit, Callback callback)\n    {\n        LOG.debug(\"Queuing {} on {}\", dataInfo, stream);\n        DataFrameBytes frameBytes = new DataFrameBytes(stream, callback, dataInfo);\n        if (timeout > 0)\n            frameBytes.task = scheduler.schedule(frameBytes, timeout, unit);\n        flusher.append(frameBytes);\n    }","id":90577,"modified_method":"@Override\n    public void data(IStream stream, DataInfo dataInfo, long timeout, TimeUnit unit, Callback callback)\n    {\n        LOG.debug(\"Queuing {} on {}\", dataInfo, stream);\n        DataFrameBytes frameBytes = new DataFrameBytes(stream, callback, dataInfo);\n        if (timeout > 0)\n            frameBytes.task = scheduler.schedule(frameBytes, timeout, unit);\n        flush(frameBytes, flusher.append(frameBytes));\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void onSessionException(SessionException x)\n    {\n        Throwable cause = x.getCause();\n        notifyOnException(listener, cause == null ? x : cause);\n        goAway(x.getSessionStatus(), 0, TimeUnit.SECONDS, new Callback.Adapter());\n    }","id":90578,"modified_method":"@Override\n    public void onSessionException(SessionException x)\n    {\n        Throwable cause = x.getCause();\n        notifyOnFailure(listener, cause == null ? x : cause);\n        goAway(x.getSessionStatus(), 0, TimeUnit.SECONDS, new Callback.Adapter());\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void complete(final Callback callback)\n    {\n        callback.succeeded();\n    }","id":90579,"modified_method":"private void complete(final Callback callback)\n    {\n        try\n        {\n            if (callback != null)\n                callback.succeeded();\n        }\n        catch (Throwable x)\n        {\n            LOG.info(\"Exception while notifying callback \" + callback, x);\n        }\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"private void notifyCallbackFailed(Callback callback, Throwable x)\n    {\n        try\n        {\n            if (callback != null)\n                callback.failed(x);\n        }\n        catch (Exception xx)\n        {\n            LOG.info(\"Exception while notifying callback \" + callback, xx);\n        }\n        catch (Error xx)\n        {\n            LOG.info(\"Exception while notifying callback \" + callback, xx);\n            throw xx;\n        }\n    }","id":90580,"modified_method":"private void notifyCallbackFailed(Callback callback, Throwable failure)\n    {\n        try\n        {\n            if (callback != null)\n                callback.failed(failure);\n        }\n        catch (Throwable x)\n        {\n            LOG.info(\"Exception while notifying callback \" + callback, x);\n        }\n    }","commit_id":"7a51f602dda9d2420c1451ed3da0ac7aa09e33ea","url":"https://github.com/eclipse/jetty.project"},{"original_method":"protected String updateAmsEnvContent(String content) {\n    if (content == null) {\n      return null;\n    }\n    if (!content.contains(\"AMS_COLLECTOR_GC_OPTS\")) {\n      content += \"\\n\" +\n        \"# AMS Collector GC options\\n\" +\n        \"export AMS_COLLECTOR_GC_OPTS=\\\"-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 \" +\n        \"-XX:+UseCMSInitiatingOccupancyOnly -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps \" +\n        \"-XX:+UseGCLogFileRotation -XX:GCLogFileSize=10M \" +\n        \"-Xloggc:{{ams_collector_log_dir}}/collector-gc.log-`date +'%Y%m%d%H%M'`\\\"\\n\" +\n        \"export AMS_COLLECTOR_OPTS=\\\"$AMS_COLLECTOR_OPTS $AMS_COLLECTOR_GC_OPTS\\\"\\n\";\n    }\n    return content;\n  }","id":90581,"modified_method":"protected String updateAmsEnvContent(String content) {\n    if (content == null) {\n      return null;\n    }\n    if (!content.contains(\"AMS_COLLECTOR_GC_OPTS\")) {\n      content += \"\\n\" +\n        \"# AMS Collector GC options\\n\" +\n        \"export AMS_COLLECTOR_GC_OPTS=\\\"-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 \" +\n        \"-XX:+UseCMSInitiatingOccupancyOnly -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps \" +\n        \"-XX:+UseGCLogFileRotation -XX:GCLogFileSize=10M \" +\n        \"-Xloggc:{{ams_collector_log_dir}}/collector-gc.log-`date +'%Y%m%d%H%M'`\\\"\\n\" +\n        \"export AMS_COLLECTOR_OPTS=\\\"$AMS_COLLECTOR_OPTS $AMS_COLLECTOR_GC_OPTS\\\"\\n\";\n    }\n\n    if (!content.contains(\"HBASE_NORMALIZATION_ENABLED\")) {\n      content += \"\\n\" +\n        \"# HBase compaction policy enabled\\n\" +\n        \"export HBASE_NORMALIZATION_ENABLED={{ams_hbase_normalizer_enabled}}\\n\";\n    }\n\n    if (!content.contains(\"HBASE_FIFO_COMPACTION_POLICY_ENABLED\")) {\n      content += \"\\n\" +\n        \"# HBase compaction policy enabled\\n\" +\n        \"export HBASE_FIFO_COMPACTION_POLICY_ENABLED={{ams_hbase_fifo_compaction_policy_enabled}}\\n\";\n    }\n\n    return content;\n  }","commit_id":"a8649b0f0edc452fe73f32151bcd04f6323d288d","url":"https://github.com/apache/ambari"},{"original_method":"protected void updateAMSConfigs() throws AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    if (clusters != null) {\n      Map<String, Cluster> clusterMap = clusters.getClusters();\n\n      if (clusterMap != null && !clusterMap.isEmpty()) {\n        for (final Cluster cluster : clusterMap.values()) {\n\n          Config amsHbaseEnv = cluster.getDesiredConfigByType(AMS_HBASE_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsHbaseEnvProperties = amsHbaseEnv.getProperties();\n            String content = amsHbaseEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsHbaseEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_ENV, newProperties, true, true);\n          }\n\n          Config amsEnv = cluster.getDesiredConfigByType(AMS_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsHbaseEnvProperties = amsEnv.getProperties();\n            String content = amsHbaseEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_ENV, newProperties, true, true);\n          }\n\n          Config amsSite = cluster.getDesiredConfigByType(AMS_SITE);\n          if (amsSite != null) {\n            Map<String, String> newProperties = new HashMap<>();\n\n            //Changed AMS result set limit from 5760 to 15840.\n            newProperties.put(\"timeline.metrics.service.default.result.limit\", String.valueOf(15840));\n\n            //Interval\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.interval\", String.valueOf(120));\n            newProperties.put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(300));\n            newProperties.put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(300));\n\n            //ttl\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.ttl\", String.valueOf(2592000));\n            newProperties.put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(7776000));\n\n            //checkpoint\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.checkpointCutOffMultiplier\", String.valueOf(2));\n\n            //disabled\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.disabled\", String.valueOf(false));\n\n            updateConfigurationPropertiesForCluster(cluster, AMS_SITE, newProperties, true, true);\n          }\n\n          Config amsHbaseSite = cluster.getDesiredConfigByType(AMS_HBASE_SITE);\n          if (amsHbaseSite != null) {\n            Map<String, String> amsHbaseSiteProperties = amsHbaseSite.getProperties();\n            String zkTimeout = amsHbaseSiteProperties.get(AMS_HBASE_SITE_ZK_TIMEOUT_PROPERTY);\n            // if old default, set new default\n            if (\"20000\".equals(zkTimeout)) {\n              Map<String, String> newProperties = new HashMap<>();\n              newProperties.put(AMS_HBASE_SITE_ZK_TIMEOUT_PROPERTY, \"120000\");\n              updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_SITE, newProperties, true, true);\n            }\n          }\n        }\n      }\n    }\n\n  }","id":90582,"modified_method":"protected void updateAMSConfigs() throws AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    if (clusters != null) {\n      Map<String, Cluster> clusterMap = clusters.getClusters();\n\n      if (clusterMap != null && !clusterMap.isEmpty()) {\n        for (final Cluster cluster : clusterMap.values()) {\n\n          Config amsHbaseEnv = cluster.getDesiredConfigByType(AMS_HBASE_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsHbaseEnvProperties = amsHbaseEnv.getProperties();\n            String content = amsHbaseEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsHbaseEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_ENV, newProperties, true, true);\n          }\n\n          Config amsEnv = cluster.getDesiredConfigByType(AMS_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsEnvProperties = amsEnv.getProperties();\n            String content = amsEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_ENV, newProperties, true, true);\n          }\n\n          Config amsSite = cluster.getDesiredConfigByType(AMS_SITE);\n          if (amsSite != null) {\n            Map<String, String> currentAmsSiteProperties = amsSite.getProperties();\n            Map<String, String> newProperties = new HashMap<>();\n\n            //Changed AMS result set limit from 5760 to 15840.\n            if(currentAmsSiteProperties.containsKey(\"timeline.metrics.service.default.result.limit\") &&\n              currentAmsSiteProperties.get(\"timeline.metrics.service.default.result.limit\").equals(String.valueOf(5760))) {\n              LOG.info(\"Updating timeline.metrics.service.default.result.limit to 15840\");\n              newProperties.put(\"timeline.metrics.service.default.result.limit\", String.valueOf(15840));\n            }\n\n            //Interval\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.interval\", String.valueOf(120));\n            newProperties.put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(300));\n            newProperties.put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(300));\n\n            //ttl\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.ttl\", String.valueOf(2592000));\n            newProperties.put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(7776000));\n\n            //checkpoint\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.checkpointCutOffMultiplier\", String.valueOf(2));\n\n            //disabled\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.disabled\", String.valueOf(false));\n\n            //Add compaction policy property\n            newProperties.put(\"hbase.fifo.compaction.policy.enabled\", String.valueOf(true));\n\n            updateConfigurationPropertiesForCluster(cluster, AMS_SITE, newProperties, true, true);\n          }\n\n          Config amsHbaseSite = cluster.getDesiredConfigByType(AMS_HBASE_SITE);\n          if (amsHbaseSite != null) {\n            Map<String, String> amsHbaseSiteProperties = amsHbaseSite.getProperties();\n            Map<String, String> newProperties = new HashMap<>();\n\n            String zkTimeout = amsHbaseSiteProperties.get(AMS_HBASE_SITE_ZK_TIMEOUT_PROPERTY);\n            // if old default, set new default\n            if (\"20000\".equals(zkTimeout)) {\n              newProperties.put(AMS_HBASE_SITE_ZK_TIMEOUT_PROPERTY, \"120000\");\n            }\n\n            //Adding hbase.normalizer.period to upgrade\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY)) {\n              LOG.info(\"Enabling \" + AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY, String.valueOf(true));\n            }\n\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY)) {\n              LOG.info(\"Updating \" + AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY, String.valueOf(600000));\n            }\n\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY)) {\n              LOG.info(\"Updating \" + AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY,\n                \"org.apache.hadoop.hbase.master.normalizer.SimpleRegionNormalizer\");\n            }\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_SITE, newProperties, true, true);\n          }\n        }\n      }\n    }\n\n  }","commit_id":"a8649b0f0edc452fe73f32151bcd04f6323d288d","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testAmsHbaseSiteUpdateConfigs() throws Exception{\n\n    Map<String, String> oldPropertiesAmsHbaseSite = new HashMap<String, String>() {\n      {\n        //Including only those properties that might be present in an older version.\n        put(\"zookeeper.session.timeout.localHBaseCluster\", String.valueOf(20000));\n      }\n    };\n    Map<String, String> newPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        put(\"zookeeper.session.timeout.localHBaseCluster\", String.valueOf(120000));\n      }\n    };\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n\n    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);\n    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);\n    Config mockAmsHbaseSite = easyMockSupport.createNiceMock(Config.class);\n\n    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", cluster);\n    }}).once();\n    expect(cluster.getDesiredConfigByType(\"ams-hbase-site\")).andReturn(mockAmsHbaseSite).atLeastOnce();\n    expect(mockAmsHbaseSite.getProperties()).andReturn(oldPropertiesAmsHbaseSite).atLeastOnce();\n\n    Injector injector = easyMockSupport.createNiceMock(Injector.class);\n    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();\n\n    replay(injector, clusters, mockAmsHbaseSite, cluster);\n\n    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)\n      .addMockedMethod(\"createConfiguration\")\n      .addMockedMethod(\"getClusters\", new Class[] { })\n      .withConstructor(createNiceMock(ActionManager.class), clusters, injector)\n      .createNiceMock();\n\n    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);\n    Capture<ConfigurationRequest> configurationRequestCapture = EasyMock.newCapture();\n    ConfigurationResponse configurationResponseMock = easyMockSupport.createMock(ConfigurationResponse.class);\n\n    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();\n    expect(controller.getClusters()).andReturn(clusters).anyTimes();\n    expect(controller.createConfiguration(capture(configurationRequestCapture))).andReturn(configurationResponseMock).once();\n\n    replay(controller, injector2, configurationResponseMock);\n    new UpgradeCatalog213(injector2).updateAMSConfigs();\n    easyMockSupport.verifyAll();\n\n    ConfigurationRequest configurationRequest = configurationRequestCapture.getValue();\n    Map<String, String> updatedProperties = configurationRequest.getProperties();\n    assertTrue(Maps.difference(newPropertiesAmsSite, updatedProperties).areEqual());\n  }","id":90583,"modified_method":"@Test\n  public void testAmsHbaseSiteUpdateConfigs() throws Exception{\n\n    Map<String, String> oldPropertiesAmsHbaseSite = new HashMap<String, String>() {\n      {\n        //Including only those properties that might be present in an older version.\n        put(\"zookeeper.session.timeout.localHBaseCluster\", String.valueOf(20000));\n      }\n    };\n    Map<String, String> newPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        put(\"zookeeper.session.timeout.localHBaseCluster\", String.valueOf(120000));\n        put(\"hbase.normalizer.enabled\", String.valueOf(true));\n        put(\"hbase.normalizer.period\", String.valueOf(600000));\n        put(\"hbase.master.normalizer.class\", \"org.apache.hadoop.hbase.master.normalizer.SimpleRegionNormalizer\");\n\n      }\n    };\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n\n    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);\n    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);\n    Config mockAmsHbaseSite = easyMockSupport.createNiceMock(Config.class);\n\n    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", cluster);\n    }}).once();\n    expect(cluster.getDesiredConfigByType(\"ams-hbase-site\")).andReturn(mockAmsHbaseSite).atLeastOnce();\n    expect(mockAmsHbaseSite.getProperties()).andReturn(oldPropertiesAmsHbaseSite).atLeastOnce();\n\n    Injector injector = easyMockSupport.createNiceMock(Injector.class);\n    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();\n\n    replay(injector, clusters, mockAmsHbaseSite, cluster);\n\n    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)\n      .addMockedMethod(\"createConfiguration\")\n      .addMockedMethod(\"getClusters\", new Class[] { })\n      .withConstructor(createNiceMock(ActionManager.class), clusters, injector)\n      .createNiceMock();\n\n    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);\n    Capture<ConfigurationRequest> configurationRequestCapture = EasyMock.newCapture();\n    ConfigurationResponse configurationResponseMock = easyMockSupport.createMock(ConfigurationResponse.class);\n\n    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();\n    expect(controller.getClusters()).andReturn(clusters).anyTimes();\n    expect(controller.createConfiguration(capture(configurationRequestCapture))).andReturn(configurationResponseMock).once();\n\n    replay(controller, injector2, configurationResponseMock);\n    new UpgradeCatalog213(injector2).updateAMSConfigs();\n    easyMockSupport.verifyAll();\n\n    ConfigurationRequest configurationRequest = configurationRequestCapture.getValue();\n    Map<String, String> updatedProperties = configurationRequest.getProperties();\n    assertTrue(Maps.difference(newPropertiesAmsSite, updatedProperties).areEqual());\n  }","commit_id":"a8649b0f0edc452fe73f32151bcd04f6323d288d","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testAmsSiteUpdateConfigs() throws Exception{\n\n    Map<String, String> oldPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        //Including only those properties that might be present in an older version.\n        put(\"timeline.metrics.service.default.result.limit\", String.valueOf(5760));\n        put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(1000));\n        put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(1000));\n        put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(1000));\n      }\n    };\n    Map<String, String> newPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        put(\"timeline.metrics.service.default.result.limit\", String.valueOf(15840));\n        put(\"timeline.metrics.cluster.aggregator.second.interval\", String.valueOf(120));\n        put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(300));\n        put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(300));\n        put(\"timeline.metrics.cluster.aggregator.second.ttl\", String.valueOf(2592000));\n        put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(7776000));\n        put(\"timeline.metrics.cluster.aggregator.second.checkpointCutOffMultiplier\", String.valueOf(2));\n        put(\"timeline.metrics.cluster.aggregator.second.disabled\", String.valueOf(false));\n      }\n    };\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n\n    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);\n    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);\n    Config mockAmsSite = easyMockSupport.createNiceMock(Config.class);\n\n    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", cluster);\n    }}).once();\n    expect(cluster.getDesiredConfigByType(\"ams-site\")).andReturn(mockAmsSite).atLeastOnce();\n    expect(mockAmsSite.getProperties()).andReturn(oldPropertiesAmsSite).times(1);\n\n    Injector injector = easyMockSupport.createNiceMock(Injector.class);\n    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();\n\n    replay(injector, clusters, mockAmsSite, cluster);\n\n    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)\n      .addMockedMethod(\"createConfiguration\")\n      .addMockedMethod(\"getClusters\", new Class[] { })\n      .withConstructor(createNiceMock(ActionManager.class), clusters, injector)\n      .createNiceMock();\n\n    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);\n    Capture<ConfigurationRequest> configurationRequestCapture = EasyMock.newCapture();\n    ConfigurationResponse configurationResponseMock = easyMockSupport.createMock(ConfigurationResponse.class);\n\n    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();\n    expect(controller.getClusters()).andReturn(clusters).anyTimes();\n    expect(controller.createConfiguration(capture(configurationRequestCapture))).andReturn(configurationResponseMock).once();\n\n    replay(controller, injector2, configurationResponseMock);\n    new UpgradeCatalog213(injector2).updateAMSConfigs();\n    easyMockSupport.verifyAll();\n\n    ConfigurationRequest configurationRequest = configurationRequestCapture.getValue();\n    Map<String, String> updatedProperties = configurationRequest.getProperties();\n    assertTrue(Maps.difference(newPropertiesAmsSite, updatedProperties).areEqual());\n\n  }","id":90584,"modified_method":"@Test\n  public void testAmsSiteUpdateConfigs() throws Exception{\n\n    Map<String, String> oldPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        //Including only those properties that might be present in an older version.\n        put(\"timeline.metrics.service.default.result.limit\", String.valueOf(5760));\n        put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(1000));\n        put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(1000));\n        put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(1000));\n      }\n    };\n    Map<String, String> newPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        put(\"timeline.metrics.service.default.result.limit\", String.valueOf(15840));\n        put(\"timeline.metrics.cluster.aggregator.second.interval\", String.valueOf(120));\n        put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(300));\n        put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(300));\n        put(\"timeline.metrics.cluster.aggregator.second.ttl\", String.valueOf(2592000));\n        put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(7776000));\n        put(\"timeline.metrics.cluster.aggregator.second.checkpointCutOffMultiplier\", String.valueOf(2));\n        put(\"timeline.metrics.cluster.aggregator.second.disabled\", String.valueOf(false));\n        put(\"hbase.fifo.compaction.policy.enabled\", String.valueOf(true));\n      }\n    };\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n\n    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);\n    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);\n    Config mockAmsSite = easyMockSupport.createNiceMock(Config.class);\n\n    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", cluster);\n    }}).once();\n    expect(cluster.getDesiredConfigByType(\"ams-site\")).andReturn(mockAmsSite).atLeastOnce();\n    expect(mockAmsSite.getProperties()).andReturn(oldPropertiesAmsSite).times(2);\n\n    Injector injector = easyMockSupport.createNiceMock(Injector.class);\n    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();\n\n    replay(injector, clusters, mockAmsSite, cluster);\n\n    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)\n      .addMockedMethod(\"createConfiguration\")\n      .addMockedMethod(\"getClusters\", new Class[] { })\n      .withConstructor(createNiceMock(ActionManager.class), clusters, injector)\n      .createNiceMock();\n\n    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);\n    Capture<ConfigurationRequest> configurationRequestCapture = EasyMock.newCapture();\n    ConfigurationResponse configurationResponseMock = easyMockSupport.createMock(ConfigurationResponse.class);\n\n    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();\n    expect(controller.getClusters()).andReturn(clusters).anyTimes();\n    expect(controller.createConfiguration(capture(configurationRequestCapture))).andReturn(configurationResponseMock).once();\n\n    replay(controller, injector2, configurationResponseMock);\n    new UpgradeCatalog213(injector2).updateAMSConfigs();\n    easyMockSupport.verifyAll();\n\n    ConfigurationRequest configurationRequest = configurationRequestCapture.getValue();\n    Map<String, String> updatedProperties = configurationRequest.getProperties();\n    assertTrue(Maps.difference(newPropertiesAmsSite, updatedProperties).areEqual());\n\n  }","commit_id":"a8649b0f0edc452fe73f32151bcd04f6323d288d","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpdateAmsEnvContent() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n    Method updateAmsEnvContent = UpgradeCatalog213.class.getDeclaredMethod(\"updateAmsEnvContent\", String.class);\n    UpgradeCatalog213 upgradeCatalog213 = new UpgradeCatalog213(injector);\n    String oldContent = \"some_content\";\n\n    String expectedContent = \"some_content\" + \"\\n\" +\n      \"# AMS Collector GC options\\n\" +\n      \"export AMS_COLLECTOR_GC_OPTS=\\\"-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 \" +\n      \"-XX:+UseCMSInitiatingOccupancyOnly -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps \" +\n      \"-XX:+UseGCLogFileRotation -XX:GCLogFileSize=10M \" +\n      \"-Xloggc:{{ams_collector_log_dir}}/collector-gc.log-`date +'%Y%m%d%H%M'`\\\"\\n\" +\n      \"export AMS_COLLECTOR_OPTS=\\\"$AMS_COLLECTOR_OPTS $AMS_COLLECTOR_GC_OPTS\\\"\\n\";\n    String result = (String) updateAmsEnvContent.invoke(upgradeCatalog213, oldContent);\n    Assert.assertEquals(expectedContent, result);\n  }","id":90585,"modified_method":"@Test\n  public void testUpdateAmsEnvContent() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n    Method updateAmsEnvContent = UpgradeCatalog213.class.getDeclaredMethod(\"updateAmsEnvContent\", String.class);\n    UpgradeCatalog213 upgradeCatalog213 = new UpgradeCatalog213(injector);\n    String oldContent = \"some_content\";\n\n    String expectedContent = \"some_content\" + \"\\n\" +\n      \"# AMS Collector GC options\\n\" +\n      \"export AMS_COLLECTOR_GC_OPTS=\\\"-XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=70 \" +\n      \"-XX:+UseCMSInitiatingOccupancyOnly -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps \" +\n      \"-XX:+UseGCLogFileRotation -XX:GCLogFileSize=10M \" +\n      \"-Xloggc:{{ams_collector_log_dir}}/collector-gc.log-`date +'%Y%m%d%H%M'`\\\"\\n\" +\n      \"export AMS_COLLECTOR_OPTS=\\\"$AMS_COLLECTOR_OPTS $AMS_COLLECTOR_GC_OPTS\\\"\\n\"+\n      \"\\n\" +\n      \"# HBase compaction policy enabled\\n\" +\n      \"export HBASE_NORMALIZATION_ENABLED={{ams_hbase_normalizer_enabled}}\\n\" +\n      \"\\n\" +\n      \"# HBase compaction policy enabled\\n\" +\n      \"export HBASE_FIFO_COMPACTION_POLICY_ENABLED={{ams_hbase_fifo_compaction_policy_enabled}}\\n\";\n\n    String result = (String) updateAmsEnvContent.invoke(upgradeCatalog213, oldContent);\n    Assert.assertEquals(expectedContent, result);\n  }","commit_id":"a8649b0f0edc452fe73f32151bcd04f6323d288d","url":"https://github.com/apache/ambari"},{"original_method":"protected void updateStormConfigs() throws AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    for (final Cluster cluster : getCheckedClusterMap(ambariManagementController.getClusters()).values()) {\n      Config stormSiteProps = cluster.getDesiredConfigByType(STORM_SITE);\n      if (stormSiteProps != null) {\n        String nimbusMonitorFreqSecs = stormSiteProps.getProperties().get(NIMBS_MONITOR_FREQ_SECS_PROPERTY);\n        if (nimbusMonitorFreqSecs != null && nimbusMonitorFreqSecs.equals(\"10\")) {\n          Map<String, String> updates = Collections.singletonMap(NIMBS_MONITOR_FREQ_SECS_PROPERTY, \"120\");\n          updateConfigurationPropertiesForCluster(cluster, STORM_SITE, updates, true, false);\n        }\n      }\n    }\n  }","id":90586,"modified_method":"protected void updateStormConfigs() throws AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    for (final Cluster cluster : getCheckedClusterMap(ambariManagementController.getClusters()).values()) {\n      Config stormSiteProps = cluster.getDesiredConfigByType(STORM_SITE);\n      if (stormSiteProps != null) {\n        Map<String, String> updates = new HashMap<>();\n\n        String nimbusMonitorFreqSecs = stormSiteProps.getProperties().get(NIMBS_MONITOR_FREQ_SECS_PROPERTY);\n        if (nimbusMonitorFreqSecs != null && nimbusMonitorFreqSecs.equals(\"10\")) {\n          updates.put(NIMBS_MONITOR_FREQ_SECS_PROPERTY, \"120\");\n        }\n\n        Service amsService = null;\n        try {\n          amsService = cluster.getService(\"AMBARI_METRICS\");\n        } catch(AmbariException ambariException) {\n          LOG.info(\"AMBARI_METRICS service not found in cluster while updating storm-site properties\");\n        }\n        String metricsReporter = stormSiteProps.getProperties().get(STORM_METRICS_REPORTER);\n        if (amsService != null && StringUtils.isEmpty(metricsReporter)) {\n          updates.put(STORM_METRICS_REPORTER, \"org.apache.hadoop.metrics2.sink.storm.StormTimelineMetricsReporter\");\n        }\n\n        updateConfigurationPropertiesForCluster(cluster, STORM_SITE, updates, true, false);\n      }\n    }\n  }","commit_id":"13ba48bb6bf78e561285bbfe52bab0bedf36527e","url":"https://github.com/apache/ambari"},{"original_method":"protected void updateAMSConfigs() throws AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    if (clusters != null) {\n      Map<String, Cluster> clusterMap = clusters.getClusters();\n\n      if (clusterMap != null && !clusterMap.isEmpty()) {\n        for (final Cluster cluster : clusterMap.values()) {\n\n          Config amsHbaseEnv = cluster.getDesiredConfigByType(AMS_HBASE_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsHbaseEnvProperties = amsHbaseEnv.getProperties();\n            String content = amsHbaseEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsHbaseEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_ENV, newProperties, true, true);\n          }\n\n          Config amsEnv = cluster.getDesiredConfigByType(AMS_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsEnvProperties = amsEnv.getProperties();\n            String content = amsEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_ENV, newProperties, true, true);\n          }\n\n          Config amsSite = cluster.getDesiredConfigByType(AMS_SITE);\n          if (amsSite != null) {\n            Map<String, String> currentAmsSiteProperties = amsSite.getProperties();\n            Map<String, String> newProperties = new HashMap<>();\n\n            //Changed AMS result set limit from 5760 to 15840.\n            if(currentAmsSiteProperties.containsKey(\"timeline.metrics.service.default.result.limit\") &&\n              currentAmsSiteProperties.get(\"timeline.metrics.service.default.result.limit\").equals(String.valueOf(5760))) {\n              LOG.info(\"Updating timeline.metrics.service.default.result.limit to 15840\");\n              newProperties.put(\"timeline.metrics.service.default.result.limit\", String.valueOf(15840));\n            }\n\n            //Interval\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.interval\", String.valueOf(120));\n            newProperties.put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(300));\n            newProperties.put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(300));\n\n            //ttl\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.ttl\", String.valueOf(2592000));\n            newProperties.put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(7776000));\n\n            //checkpoint\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.checkpointCutOffMultiplier\", String.valueOf(2));\n\n            //disabled\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.disabled\", String.valueOf(false));\n\n            //Add compaction policy property\n            newProperties.put(\"hbase.fifo.compaction.policy.enabled\", String.valueOf(true));\n\n            updateConfigurationPropertiesForCluster(cluster, AMS_SITE, newProperties, true, true);\n          }\n\n          Config amsHbaseSite = cluster.getDesiredConfigByType(AMS_HBASE_SITE);\n          if (amsHbaseSite != null) {\n            Map<String, String> amsHbaseSiteProperties = amsHbaseSite.getProperties();\n            Map<String, String> newProperties = new HashMap<>();\n\n            String zkTimeout = amsHbaseSiteProperties.get(AMS_HBASE_SITE_ZK_TIMEOUT_PROPERTY);\n            // if old default, set new default\n            if (\"20000\".equals(zkTimeout)) {\n              newProperties.put(AMS_HBASE_SITE_ZK_TIMEOUT_PROPERTY, \"120000\");\n            }\n\n            //Adding hbase.normalizer.period to upgrade\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY)) {\n              LOG.info(\"Enabling \" + AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY, String.valueOf(true));\n            }\n\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY)) {\n              LOG.info(\"Updating \" + AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY, String.valueOf(600000));\n            }\n\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY)) {\n              LOG.info(\"Updating \" + AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY,\n                \"org.apache.hadoop.hbase.master.normalizer.SimpleRegionNormalizer\");\n            }\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_SITE, newProperties, true, true);\n          }\n        }\n      }\n    }\n\n  }","id":90587,"modified_method":"protected void updateAMSConfigs() throws AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    if (clusters != null) {\n      Map<String, Cluster> clusterMap = clusters.getClusters();\n\n      if (clusterMap != null && !clusterMap.isEmpty()) {\n        for (final Cluster cluster : clusterMap.values()) {\n\n          Config amsHbaseEnv = cluster.getDesiredConfigByType(AMS_HBASE_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsHbaseEnvProperties = amsHbaseEnv.getProperties();\n            String content = amsHbaseEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsHbaseEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_ENV, newProperties, true, true);\n          }\n\n          Config amsEnv = cluster.getDesiredConfigByType(AMS_ENV);\n          if (amsHbaseEnv != null) {\n            Map<String, String> amsEnvProperties = amsEnv.getProperties();\n            String content = amsEnvProperties.get(\"content\");\n            Map<String, String> newProperties = new HashMap<>();\n            newProperties.put(\"content\", updateAmsEnvContent(content));\n            updateConfigurationPropertiesForCluster(cluster, AMS_ENV, newProperties, true, true);\n          }\n\n          Config amsSite = cluster.getDesiredConfigByType(AMS_SITE);\n          if (amsSite != null) {\n            Map<String, String> currentAmsSiteProperties = amsSite.getProperties();\n            Map<String, String> newProperties = new HashMap<>();\n\n            //Changed AMS result set limit from 5760 to 15840.\n            if(currentAmsSiteProperties.containsKey(\"timeline.metrics.service.default.result.limit\") &&\n              currentAmsSiteProperties.get(\"timeline.metrics.service.default.result.limit\").equals(String.valueOf(5760))) {\n              LOG.info(\"Updating timeline.metrics.service.default.result.limit to 15840\");\n              newProperties.put(\"timeline.metrics.service.default.result.limit\", String.valueOf(15840));\n            }\n\n            //Interval\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.interval\", String.valueOf(120));\n            newProperties.put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(300));\n            newProperties.put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(300));\n\n            //ttl\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.ttl\", String.valueOf(2592000));\n            newProperties.put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(7776000));\n\n            //checkpoint\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.checkpointCutOffMultiplier\", String.valueOf(2));\n\n            //disabled\n            newProperties.put(\"timeline.metrics.cluster.aggregator.second.disabled\", String.valueOf(false));\n\n            //Add compaction policy property\n            newProperties.put(TIMELINE_METRICS_HBASE_FIFO_COMPACTION_ENABLED, String.valueOf(true));\n\n            updateConfigurationPropertiesForCluster(cluster, AMS_SITE, newProperties, true, true);\n          }\n\n          Config amsHbaseSite = cluster.getDesiredConfigByType(AMS_HBASE_SITE);\n          if (amsHbaseSite != null) {\n            Map<String, String> amsHbaseSiteProperties = amsHbaseSite.getProperties();\n            Map<String, String> newProperties = new HashMap<>();\n\n            String zkTimeout = amsHbaseSiteProperties.get(AMS_HBASE_SITE_ZK_TIMEOUT_PROPERTY);\n            // if old default, set new default\n            if (\"20000\".equals(zkTimeout)) {\n              newProperties.put(AMS_HBASE_SITE_ZK_TIMEOUT_PROPERTY, \"120000\");\n            }\n\n            //Adding hbase.normalizer.period to upgrade\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY)) {\n              LOG.info(\"Enabling \" + AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_ENABLED_PROPERTY, String.valueOf(true));\n            }\n\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY)) {\n              LOG.info(\"Updating \" + AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_PERIOD_PROPERTY, String.valueOf(600000));\n            }\n\n            if(!amsHbaseSiteProperties.containsKey(AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY)) {\n              LOG.info(\"Updating \" + AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY);\n              newProperties.put(AMS_HBASE_SITE_NORMALIZER_CLASS_PROPERTY,\n                \"org.apache.hadoop.hbase.master.normalizer.SimpleRegionNormalizer\");\n            }\n            updateConfigurationPropertiesForCluster(cluster, AMS_HBASE_SITE, newProperties, true, true);\n          }\n        }\n      }\n    }\n\n  }","commit_id":"13ba48bb6bf78e561285bbfe52bab0bedf36527e","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testUpdateStormSiteConfigs() throws Exception {\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n    final AmbariManagementController mockAmbariManagementController = easyMockSupport.createNiceMock(AmbariManagementController.class);\n    final ConfigHelper mockConfigHelper = easyMockSupport.createMock(ConfigHelper.class);\n\n    final Clusters mockClusters = easyMockSupport.createStrictMock(Clusters.class);\n    final Cluster mockClusterExpected = easyMockSupport.createNiceMock(Cluster.class);\n    final Map<String, String> propertiesStormSite = new HashMap<String, String>() {\n      {\n        put(\"nimbus.monitor.freq.secs\", \"10\");\n      }\n    };\n\n    final Config mockStormSite = easyMockSupport.createNiceMock(Config.class);\n    expect(mockStormSite.getProperties()).andReturn(propertiesStormSite).once();\n\n    final Injector mockInjector = Guice.createInjector(new AbstractModule() {\n      @Override\n      protected void configure() {\n        bind(AmbariManagementController.class).toInstance(mockAmbariManagementController);\n        bind(ConfigHelper.class).toInstance(mockConfigHelper);\n        bind(Clusters.class).toInstance(mockClusters);\n        bind(EntityManager.class).toInstance(entityManager);\n\n        bind(DBAccessor.class).toInstance(createNiceMock(DBAccessor.class));\n        bind(OsFamily.class).toInstance(createNiceMock(OsFamily.class));\n      }\n    });\n\n    expect(mockAmbariManagementController.getClusters()).andReturn(mockClusters).once();\n    expect(mockClusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", mockClusterExpected);\n    }}).once();\n\n    expect(mockClusterExpected.getDesiredConfigByType(\"storm-site\")).andReturn(mockStormSite).atLeastOnce();\n    expect(mockStormSite.getProperties()).andReturn(propertiesStormSite).atLeastOnce();\n\n    easyMockSupport.replayAll();\n    mockInjector.getInstance(UpgradeCatalog213.class).updateStormConfigs();\n    easyMockSupport.verifyAll();\n  }","id":90588,"modified_method":"@Test\n  public void testUpdateStormSiteConfigs() throws Exception {\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n    final AmbariManagementController mockAmbariManagementController = easyMockSupport.createNiceMock(AmbariManagementController.class);\n    final ConfigHelper mockConfigHelper = easyMockSupport.createMock(ConfigHelper.class);\n\n    final Clusters mockClusters = easyMockSupport.createStrictMock(Clusters.class);\n    final Cluster mockClusterExpected = easyMockSupport.createNiceMock(Cluster.class);\n    final Map<String, String> propertiesStormSite = new HashMap<String, String>() {\n      {\n        put(\"nimbus.monitor.freq.secs\", \"10\");\n        put(\"metrics.reporter.register\", \"org.apache.hadoop.metrics2.sink.storm.StormTimelineMetricsReporter\");\n      }\n    };\n\n    final Config mockStormSite = easyMockSupport.createNiceMock(Config.class);\n    expect(mockStormSite.getProperties()).andReturn(propertiesStormSite).once();\n\n    final Injector mockInjector = Guice.createInjector(new AbstractModule() {\n      @Override\n      protected void configure() {\n        bind(AmbariManagementController.class).toInstance(mockAmbariManagementController);\n        bind(ConfigHelper.class).toInstance(mockConfigHelper);\n        bind(Clusters.class).toInstance(mockClusters);\n        bind(EntityManager.class).toInstance(entityManager);\n\n        bind(DBAccessor.class).toInstance(createNiceMock(DBAccessor.class));\n        bind(OsFamily.class).toInstance(createNiceMock(OsFamily.class));\n      }\n    });\n\n    expect(mockAmbariManagementController.getClusters()).andReturn(mockClusters).once();\n    expect(mockClusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", mockClusterExpected);\n    }}).once();\n\n    expect(mockClusterExpected.getDesiredConfigByType(\"storm-site\")).andReturn(mockStormSite).atLeastOnce();\n    expect(mockStormSite.getProperties()).andReturn(propertiesStormSite).atLeastOnce();\n\n    easyMockSupport.replayAll();\n    mockInjector.getInstance(UpgradeCatalog213.class).updateStormConfigs();\n    easyMockSupport.verifyAll();\n  }","commit_id":"13ba48bb6bf78e561285bbfe52bab0bedf36527e","url":"https://github.com/apache/ambari"},{"original_method":"@Test\n  public void testAmsSiteUpdateConfigs() throws Exception{\n\n    Map<String, String> oldPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        //Including only those properties that might be present in an older version.\n        put(\"timeline.metrics.service.default.result.limit\", String.valueOf(5760));\n        put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(1000));\n        put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(1000));\n        put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(1000));\n      }\n    };\n    Map<String, String> newPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        put(\"timeline.metrics.service.default.result.limit\", String.valueOf(15840));\n        put(\"timeline.metrics.cluster.aggregator.second.interval\", String.valueOf(120));\n        put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(300));\n        put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(300));\n        put(\"timeline.metrics.cluster.aggregator.second.ttl\", String.valueOf(2592000));\n        put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(7776000));\n        put(\"timeline.metrics.cluster.aggregator.second.checkpointCutOffMultiplier\", String.valueOf(2));\n        put(\"timeline.metrics.cluster.aggregator.second.disabled\", String.valueOf(false));\n        put(\"hbase.fifo.compaction.policy.enabled\", String.valueOf(true));\n      }\n    };\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n\n    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);\n    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);\n    Config mockAmsSite = easyMockSupport.createNiceMock(Config.class);\n\n    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", cluster);\n    }}).once();\n    expect(cluster.getDesiredConfigByType(\"ams-site\")).andReturn(mockAmsSite).atLeastOnce();\n    expect(mockAmsSite.getProperties()).andReturn(oldPropertiesAmsSite).times(2);\n\n    Injector injector = easyMockSupport.createNiceMock(Injector.class);\n    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();\n\n    replay(injector, clusters, mockAmsSite, cluster);\n\n    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)\n      .addMockedMethod(\"createConfiguration\")\n      .addMockedMethod(\"getClusters\", new Class[] { })\n      .withConstructor(createNiceMock(ActionManager.class), clusters, injector)\n      .createNiceMock();\n\n    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);\n    Capture<ConfigurationRequest> configurationRequestCapture = EasyMock.newCapture();\n    ConfigurationResponse configurationResponseMock = easyMockSupport.createMock(ConfigurationResponse.class);\n\n    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();\n    expect(controller.getClusters()).andReturn(clusters).anyTimes();\n    expect(controller.createConfiguration(capture(configurationRequestCapture))).andReturn(configurationResponseMock).once();\n\n    replay(controller, injector2, configurationResponseMock);\n    new UpgradeCatalog213(injector2).updateAMSConfigs();\n    easyMockSupport.verifyAll();\n\n    ConfigurationRequest configurationRequest = configurationRequestCapture.getValue();\n    Map<String, String> updatedProperties = configurationRequest.getProperties();\n    assertTrue(Maps.difference(newPropertiesAmsSite, updatedProperties).areEqual());\n\n  }","id":90589,"modified_method":"@Test\n  public void testAmsSiteUpdateConfigs() throws Exception{\n\n    Map<String, String> oldPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        //Including only those properties that might be present in an older version.\n        put(\"timeline.metrics.service.default.result.limit\", String.valueOf(5760));\n        put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(1000));\n        put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(1000));\n        put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(1000));\n      }\n    };\n    Map<String, String> newPropertiesAmsSite = new HashMap<String, String>() {\n      {\n        put(\"timeline.metrics.service.default.result.limit\", String.valueOf(15840));\n        put(\"timeline.metrics.cluster.aggregator.second.interval\", String.valueOf(120));\n        put(\"timeline.metrics.cluster.aggregator.minute.interval\", String.valueOf(300));\n        put(\"timeline.metrics.host.aggregator.minute.interval\", String.valueOf(300));\n        put(\"timeline.metrics.cluster.aggregator.second.ttl\", String.valueOf(2592000));\n        put(\"timeline.metrics.cluster.aggregator.minute.ttl\", String.valueOf(7776000));\n        put(\"timeline.metrics.cluster.aggregator.second.checkpointCutOffMultiplier\", String.valueOf(2));\n        put(\"timeline.metrics.cluster.aggregator.second.disabled\", String.valueOf(false));\n        put(\"timeline.metrics.hbase.fifo.compaction.enabled\", String.valueOf(true));\n      }\n    };\n    EasyMockSupport easyMockSupport = new EasyMockSupport();\n\n    Clusters clusters = easyMockSupport.createNiceMock(Clusters.class);\n    final Cluster cluster = easyMockSupport.createNiceMock(Cluster.class);\n    Config mockAmsSite = easyMockSupport.createNiceMock(Config.class);\n\n    expect(clusters.getClusters()).andReturn(new HashMap<String, Cluster>() {{\n      put(\"normal\", cluster);\n    }}).once();\n    expect(cluster.getDesiredConfigByType(\"ams-site\")).andReturn(mockAmsSite).atLeastOnce();\n    expect(mockAmsSite.getProperties()).andReturn(oldPropertiesAmsSite).times(2);\n\n    Injector injector = easyMockSupport.createNiceMock(Injector.class);\n    expect(injector.getInstance(Gson.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(MaintenanceStateHelper.class)).andReturn(null).anyTimes();\n    expect(injector.getInstance(KerberosHelper.class)).andReturn(createNiceMock(KerberosHelper.class)).anyTimes();\n\n    replay(injector, clusters, mockAmsSite, cluster);\n\n    AmbariManagementControllerImpl controller = createMockBuilder(AmbariManagementControllerImpl.class)\n      .addMockedMethod(\"createConfiguration\")\n      .addMockedMethod(\"getClusters\", new Class[] { })\n      .withConstructor(createNiceMock(ActionManager.class), clusters, injector)\n      .createNiceMock();\n\n    Injector injector2 = easyMockSupport.createNiceMock(Injector.class);\n    Capture<ConfigurationRequest> configurationRequestCapture = EasyMock.newCapture();\n    ConfigurationResponse configurationResponseMock = easyMockSupport.createMock(ConfigurationResponse.class);\n\n    expect(injector2.getInstance(AmbariManagementController.class)).andReturn(controller).anyTimes();\n    expect(controller.getClusters()).andReturn(clusters).anyTimes();\n    expect(controller.createConfiguration(capture(configurationRequestCapture))).andReturn(configurationResponseMock).once();\n\n    replay(controller, injector2, configurationResponseMock);\n    new UpgradeCatalog213(injector2).updateAMSConfigs();\n    easyMockSupport.verifyAll();\n\n    ConfigurationRequest configurationRequest = configurationRequestCapture.getValue();\n    Map<String, String> updatedProperties = configurationRequest.getProperties();\n    assertTrue(Maps.difference(newPropertiesAmsSite, updatedProperties).areEqual());\n\n  }","commit_id":"13ba48bb6bf78e561285bbfe52bab0bedf36527e","url":"https://github.com/apache/ambari"},{"original_method":"protected  void updateStormConfigs() throws  AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(\n            AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    if (clusters != null) {\n      Map<String, Cluster> clusterMap = clusters.getClusters();\n\n      if (clusterMap != null && !clusterMap.isEmpty()) {\n        for (final Cluster cluster : clusterMap.values()) {\n          //if cluster is secured we should set additional properties\n          if(cluster.getDesiredConfigByType(\"cluster-env\") != null\n                  && cluster.getDesiredConfigByType(\"cluster-env\").getProperties().get(\"security_enabled\").equals(\"true\")\n                  && cluster.getDesiredConfigByType(\"storm-site\") != null ) {\n            Map<String, String> newStormProps = new HashMap<String, String>();\n            if (!cluster.getDesiredConfigByType(\"storm-site\").getProperties().containsKey(\"java.security.auth.login.config\")) {\n              newStormProps.put(\"java.security.auth.login.config\", \"{{conf_dir}}/storm_jaas.conf\");\n            }\n            updateConfigurationPropertiesForCluster(cluster, \"storm-site\", newStormProps, false, true);\n          }\n        }\n      }\n    }\n  }","id":90590,"modified_method":"protected  void updateStormConfigs() throws  AmbariException {\n    AmbariManagementController ambariManagementController = injector.getInstance(\n            AmbariManagementController.class);\n    Clusters clusters = ambariManagementController.getClusters();\n\n    if (clusters != null) {\n      Map<String, Cluster> clusterMap = clusters.getClusters();\n\n      if (clusterMap != null && !clusterMap.isEmpty()) {\n        for (final Cluster cluster : clusterMap.values()) {\n          //if cluster is secured we should set additional properties\n          if(cluster.getDesiredConfigByType(\"cluster-env\") != null\n                  && cluster.getDesiredConfigByType(\"cluster-env\").getProperties().get(\"security_enabled\").equals(\"true\")\n                  && cluster.getDesiredConfigByType(\"storm-site\") != null ) {\n            Map<String, String> newStormProps = new HashMap<String, String>();\n            if (!cluster.getDesiredConfigByType(\"storm-site\").getProperties().containsKey(\"java.security.auth.login.config\")) {\n              newStormProps.put(\"java.security.auth.login.config\", \"{{conf_dir}}/storm_jaas.conf\");\n            }\n            if (!cluster.getDesiredConfigByType(\"storm-site\").getProperties().containsKey(\"nimbus.admins\")) {\n              newStormProps.put(\"nimbus.admins\", \"['{{storm_user}}']\");\n            }\n            if (!cluster.getDesiredConfigByType(\"storm-site\").getProperties().containsKey(\"nimbus.supervisors.users\")) {\n              newStormProps.put(\"nimbus.supervisors.users\", \"['{{storm_user}}']\");\n            }\n            if (!cluster.getDesiredConfigByType(\"storm-site\").getProperties().containsKey(\"storm.zookeeper.superACL\")) {\n              newStormProps.put(\"storm.zookeeper.superACL\", \"sasl:{{storm_base_jaas_principal}}\");\n            }\n            if (!cluster.getDesiredConfigByType(\"storm-site\").getProperties().containsKey(\"ui.filter.params\")) {\n              newStormProps.put(\"ui.filter.params\", \"{'type': 'kerberos', 'kerberos.principal': '{{storm_ui_jaas_principal}}', 'kerberos.keytab': '{{storm_ui_keytab_path}}', 'kerberos.name.rules': 'DEFAULT'}\");\n            }\n            updateConfigurationPropertiesForCluster(cluster, \"storm-site\", newStormProps, false, true);\n          }\n        }\n      }\n    }\n  }","commit_id":"df1fc98b5ce73df2801a98ab6b1a6af0246776b0","url":"https://github.com/apache/ambari"},{"original_method":"private static void addRemoteHelpers(WebArchive archive)\n   {\n      archive.addPackages(true, \"org.zanata.rest.helper\");\n      archive.addPackages(true, \"org.zanata.arquillian\");\n      addAllAsResources(archive, new File(\"src/test/resources/org/zanata/test/model\"), \"org/zanata/test/model\");\n   }","id":90591,"modified_method":"private static void addRemoteHelpers(WebArchive archive)\n   {\n      archive.addPackages(true, \"org.zanata.rest.helper\");\n      archive.addPackages(true, \"org.zanata.arquillian\");\n      archive.addAsResource(\"org/zanata/test/model/\");\n   }","commit_id":"ed2f8e523f114d1c5209c710a23e1312c4bfb824","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Deployment(name = \"zanata.war\")\n   public static Archive<?> createDeployment()\n   {\n\n      WebArchive archive =  ShrinkWrap.create(WebArchive.class, DEPLOYMENT_NAME + \".war\");\n      archive.addAsLibraries(Maven.resolver()\n            .loadPomFromFile(\"pom.xml\")\n            .importRuntimeDependencies(\n                  // Reject some not needed dependencies\n                  new RejectDependenciesStrategy(\"net.bull.javamelody:javamelody-core\")\n            )\n            .asFile());\n\n      // Test dependencies\n      archive.addAsLibraries(Maven.resolver().loadPomFromFile(\"pom.xml\").resolve(\"org.hibernate:hibernate-testing\").withoutTransitivity().asFile());\n      archive.addAsLibraries(Maven.resolver().loadPomFromFile(\"pom.xml\").resolve(\"org.dbunit:dbunit\").withoutTransitivity().asFile());\n\n      // Local packages\n      archive.addPackages(true, new Filter<ArchivePath>()\n      {\n         @Override\n         public boolean include(ArchivePath object)\n         {\n            // Avoid the model package (for some reason it's being included as a class file)\n            return !object.get().startsWith(\"/org/zanata/model/\") &&\n                   // and the ui package (not needed)\n                   !object.get().startsWith(\"/org/zanata/ui\");\n         }\n      }, \"org.zanata\");\n\n      // Resources (descriptors, etc)\n      archive.addAsResource(EmptyAsset.INSTANCE, \"seam.properties\");\n      archive.addAsWebInfResource(new File(\"src/test/resources/arquillian/jboss-deployment-structure.xml\"));\n      archive.addAsResource(new File(\"src/main/resources/pluralforms.properties\"));\n      archive.addAsResource(new FileAsset(new File(\"src/main/resources/META-INF/orm.xml\")), \"META-INF/orm.xml\");\n      archive.addAsResource(new FileAsset(new File(\"src/test/jboss-embedded-bootstrap/META-INF/persistence.xml\")), \"META-INF/persistence.xml\");\n      archive.addAsResource(new FileAsset(new File(\"src/main/webapp-jboss/WEB-INF/classes/META-INF/components.xml\")), \"META-INF/components.xml\");\n      archive.addAsResource(new FileAsset(new File(\"src/test/resources/arquillian/components.properties\")), \"components.properties\");\n      archive.addAsResource(new FileAsset(new File(\"src/test/resources/import.sql\")), \"import.sql\");\n      archive.addAsResource(\"security.drl\");\n      archive.addAsWebInfResource(new File(\"src/test/resources/arquillian/zanata.properties\"),\n            \"classes/zanata.properties\");\n      archive.setWebXML(\"arquillian/test-web.xml\");\n      //archive.addAsWebInfResource(\"arquillian/test-web.xml\", \"web.xml\");\n\n      addRemoteHelpers(archive);\n\n      // Export (to actually see what is being deployed)\n      //archive.as(ZipExporter.class).exportTo(new File(\"/home/camunoz/temp/archive.war\"), true);\n\n      return archive;\n   }","id":90592,"modified_method":"@Deployment(name = \"zanata.war\")\n   public static Archive<?> createDeployment()\n   {\n\n      WebArchive archive =  ShrinkWrap.create(WebArchive.class, DEPLOYMENT_NAME + \".war\");\n      archive.addAsLibraries(Maven.resolver()\n            .loadPomFromFile(\"pom.xml\")\n            .importRuntimeDependencies(\n                  // Reject some not needed dependencies\n                  new RejectDependenciesStrategy(\"net.bull.javamelody:javamelody-core\")\n            )\n            .asFile());\n\n      // Test dependencies\n      archive.addAsLibraries(Maven.resolver().loadPomFromFile(\"pom.xml\").resolve(\"org.hibernate:hibernate-testing\").withoutTransitivity().asFile());\n      archive.addAsLibraries(Maven.resolver().loadPomFromFile(\"pom.xml\").resolve(\"org.dbunit:dbunit\").withoutTransitivity().asFile());\n\n      // Local packages\n      archive.addPackages(true, new Filter<ArchivePath>()\n      {\n         @Override\n         public boolean include(ArchivePath object)\n         {\n            // Avoid the model package (for some reason it's being included as a class file)\n            return !object.get().startsWith(\"/org/zanata/model/\") &&\n                   // and the ui package (not needed)\n                   !object.get().startsWith(\"/org/zanata/ui\");\n         }\n      }, \"org.zanata\");\n\n      // Resources (descriptors, etc)\n      archive.addAsResource(EmptyAsset.INSTANCE, \"seam.properties\");\n      archive.addAsResource(\"pluralforms.properties\");\n      archive.addAsResource(new ClassLoaderAsset(\"META-INF/orm.xml\"), \"META-INF/orm.xml\");\n      archive.addAsResource(new FileAsset(new File(\"src/main/webapp-jboss/WEB-INF/classes/META-INF/components.xml\")), \"META-INF/components.xml\");\n      archive.addAsResource(new ClassLoaderAsset(\"arquillian/persistence.xml\"), \"META-INF/persistence.xml\");\n      archive.addAsResource(new ClassLoaderAsset(\"arquillian/components.properties\"), \"components.properties\");\n      archive.addAsResource(\"import.sql\");\n      archive.addAsResource(\"security.drl\");\n      archive.addAsWebInfResource(\"arquillian/jboss-deployment-structure.xml\");\n      archive.addAsWebInfResource(new ClassLoaderAsset(\"arquillian/zanata.properties\"), \"classes/zanata.properties\");\n      archive.setWebXML(\"arquillian/test-web.xml\");\n\n      addRemoteHelpers(archive);\n\n      // Export (to actually see what is being deployed)\n      archive.as(ZipExporter.class).exportTo(new File(\"/home/camunoz/temp/archive.war\"), true);\n\n      return archive;\n   }","commit_id":"ed2f8e523f114d1c5209c710a23e1312c4bfb824","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void getFileEntries(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong fileEntryId = ParamUtil.getLong(request, \"fileEntryId\");\n\n\t\tlong groupId = themeDisplay.getScopeGroupId();\n\t\tlong folderId = ParamUtil.getLong(request, \"folderId\");\n\t\tString title = ParamUtil.getString(request, \"title\");\n\n\t\tFileEntry fileEntry = null;\n\t\tList<FileEntry> fileEntries = null;\n\n\t\tif (fileEntryId > 0) {\n\t\t\ttry {\n\t\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(fileEntryId);\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t}\n\t\t}\n\t\telse if (Validator.isNotNull(title)) {\n\t\t\ttry {\n\t\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tgroupId, folderId, title);\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlong[] fileEntryIds = StringUtil.split(\n\t\t\t\tParamUtil.getString(request, \"fileEntryIds\"), 0L);\n\n\t\t\tfileEntries = new ArrayList<FileEntry>();\n\n\t\t\tfor (int i = 0; i < fileEntryIds.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tfileEntry = DLAppServiceUtil.getFileEntry(fileEntryIds[i]);\n\n\t\t\t\t\tfileEntries.add(fileEntry);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((fileEntryId > 0) || Validator.isNotNull(title)) {\n\t\t\trequest.setAttribute(\n\t\t\t\tWebKeys.DOCUMENT_LIBRARY_FILE_ENTRY, fileEntry);\n\t\t}\n\t\telse {\n\t\t\trequest.setAttribute(\n\t\t\t\tWebKeys.DOCUMENT_LIBRARY_FILE_ENTRIES, fileEntries);\n\t\t}\n\t}","id":90593,"modified_method":"public static void getFileEntries(HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong fileEntryId = ParamUtil.getLong(request, \"fileEntryId\");\n\n\t\tlong groupId = themeDisplay.getScopeGroupId();\n\t\tlong folderId = ParamUtil.getLong(request, \"folderId\");\n\t\tString title = ParamUtil.getString(request, \"title\");\n\n\t\tif (fileEntryId > 0) {\n\t\t\ttry {\n\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tfileEntryId);\n\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.DOCUMENT_LIBRARY_FILE_ENTRY, fileEntry);\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t}\n\t\t}\n\t\telse if (Validator.isNotNull(title)) {\n\t\t\ttry {\n\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\tgroupId, folderId, title);\n\n\t\t\t\trequest.setAttribute(\n\t\t\t\t\tWebKeys.DOCUMENT_LIBRARY_FILE_ENTRY, fileEntry);\n\t\t\t}\n\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tList<FileEntry> fileEntries = new ArrayList<FileEntry>();\n\n\t\t\tlong[] fileEntryIds = StringUtil.split(\n\t\t\t\tParamUtil.getString(request, \"fileEntryIds\"), 0L);\n\n\t\t\tfor (int i = 0; i < fileEntryIds.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tFileEntry fileEntry = DLAppServiceUtil.getFileEntry(\n\t\t\t\t\t\tfileEntryIds[i]);\n\n\t\t\t\t\tfileEntries.add(fileEntry);\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchFileEntryException nsfee) {\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trequest.setAttribute(\n\t\t\t\tWebKeys.DOCUMENT_LIBRARY_FILE_ENTRIES, fileEntries);\n\t\t}\n\t}","commit_id":"634c14cbc554dda4a8a101e29bb89b72353f9998","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void startElement( String uri, String localName, String qName, Attributes attributes )\n        throws SAXException\n    {\n        try\n        {\n            if ( \"testsuite\".equals( qName ) )\n            {\n                numberOfErrors = Integer.parseInt( attributes.getValue( \"errors\" ) );\n\n                numberOfFailures = Integer.parseInt( attributes.getValue( \"failures\" ) );\n\n                numberOfTests = Integer.parseInt( attributes.getValue( \"tests\" ) );\n\n                Number time = numberFormat.parse( attributes.getValue( \"time\" ) );\n\n                timeElapsed = time.floatValue();\n\n                //check if group attribute is existing\n                if ( attributes.getValue( \"group\" ) != null && !\"\".equals( attributes.getValue( \"group\" ) ) )\n                {\n                    packageName = attributes.getValue( \"group\" );\n\n                    name = attributes.getValue( \"name\" );\n\n                    fullClassName = packageName + \".\" + name;\n                }\n                else\n                {\n                    fullClassName = attributes.getValue( \"name\" );\n\n                    name = fullClassName.substring( fullClassName.lastIndexOf( \".\" ) + 1, fullClassName.length() );\n\n                    int lastDotPosition = fullClassName.lastIndexOf( \".\" );\n                    if ( lastDotPosition < 0 )\n                    {\n                        /* no package name */\n                        packageName = \"\";\n                    }\n                    else\n                    {\n                        packageName = fullClassName.substring( 0, lastDotPosition );\n                    }\n                }\n\n                testCases = new ArrayList();\n            }\n            else if ( \"testcase\".equals( qName ) )\n            {\n                currentElement = new StringBuffer();\n\n                testCase = new ReportTestCase();\n\n                testCase.setFullClassName( fullClassName );\n\n                testCase.setName( attributes.getValue( \"name\" ) );\n\n                testCase.setClassName( name );\n\n                String timeAsString = attributes.getValue( \"time\" );\n\n                Number time = new Integer( 0 );\n\n                if ( timeAsString != null )\n                {\n                    time = numberFormat.parse( timeAsString );\n                }\n\n                testCase.setTime( time.floatValue() );\n\n                testCase.setFullName( packageName + \".\" + name + \".\" + testCase.getName() );\n            }\n            else if ( \"failure\".equals( qName ) )\n            {\n                testCase.addFailure( attributes.getValue( \"message\" ), attributes.getValue( \"type\" ) );\n            }\n            else if ( \"error\".equals( qName ) )\n            {\n                testCase.addFailure( attributes.getValue( \"message\" ), attributes.getValue( \"type\" ) );\n            }\n        }\n        catch ( ParseException e )\n        {\n            throw new SAXException( e.getMessage(), e );\n        }\n    }","id":90594,"modified_method":"public void startElement( String uri, String localName, String qName, Attributes attributes )\n        throws SAXException\n    {\n        try\n        {\n            if ( \"testsuite\".equals( qName ) )\n            {\n                numberOfErrors = getAttributeAsInt( attributes, \"errors\" );\n                numberOfFailures = getAttributeAsInt( attributes, \"failures\" );\n                numberOfSkipped = getAttributeAsInt( attributes, \"skipped\" );\n                numberOfTests = getAttributeAsInt( attributes, \"tests\" );\n\n                Number time = numberFormat.parse( attributes.getValue( \"time\" ) );\n\n                timeElapsed = time.floatValue();\n\n                //check if group attribute is existing\n                if ( attributes.getValue( \"group\" ) != null && !\"\".equals( attributes.getValue( \"group\" ) ) )\n                {\n                    packageName = attributes.getValue( \"group\" );\n\n                    name = attributes.getValue( \"name\" );\n\n                    fullClassName = packageName + \".\" + name;\n                }\n                else\n                {\n                    fullClassName = attributes.getValue( \"name\" );\n\n                    name = fullClassName.substring( fullClassName.lastIndexOf( \".\" ) + 1, fullClassName.length() );\n\n                    int lastDotPosition = fullClassName.lastIndexOf( \".\" );\n                    if ( lastDotPosition < 0 )\n                    {\n                        /* no package name */\n                        packageName = \"\";\n                    }\n                    else\n                    {\n                        packageName = fullClassName.substring( 0, lastDotPosition );\n                    }\n                }\n\n                testCases = new ArrayList();\n            }\n            else if ( \"testcase\".equals( qName ) )\n            {\n                currentElement = new StringBuffer();\n\n                testCase = new ReportTestCase();\n\n                testCase.setFullClassName( fullClassName );\n\n                testCase.setName( attributes.getValue( \"name\" ) );\n\n                testCase.setClassName( name );\n\n                String timeAsString = attributes.getValue( \"time\" );\n\n                Number time = new Integer( 0 );\n\n                if ( timeAsString != null )\n                {\n                    time = numberFormat.parse( timeAsString );\n                }\n\n                testCase.setTime( time.floatValue() );\n\n                testCase.setFullName( packageName + \".\" + name + \".\" + testCase.getName() );\n            }\n            else if ( \"failure\".equals( qName ) )\n            {\n                testCase.addFailure( attributes.getValue( \"message\" ), attributes.getValue( \"type\" ) );\n            }\n            else if ( \"error\".equals( qName ) )\n            {\n                testCase.addFailure( attributes.getValue( \"message\" ), attributes.getValue( \"type\" ) );\n            }\n        }\n        catch ( ParseException e )\n        {\n            throw new SAXException( e.getMessage(), e );\n        }\n    }","commit_id":"7154799ab84832bdb124f4dc49460c4e1d7c1190","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void constructSummarySection( ResourceBundle bundle, Sink sink )\n    {\n        Map summary = report.getSummary( testSuites );\n\n        sink.sectionTitle1();\n\n        sinkAnchor( sink, \"Summary\" );\n\n        sink.text( bundle.getString( \"report.surefire.label.summary\" ) );\n\n        sink.sectionTitle1_();\n\n        constructHotLinks( sink, bundle );\n\n        sinkLineBreak( sink );\n\n        sink.table();\n\n        sink.tableRow();\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.tests\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.errors\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.failures\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.successrate\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.time\" ) );\n\n        sink.tableRow_();\n\n        sink.tableRow();\n\n        sinkCell( sink, (String) summary.get( \"totalTests\" ) );\n\n        sinkCell( sink, (String) summary.get( \"totalErrors\" ) );\n\n        sinkCell( sink, (String) summary.get( \"totalFailures\" ) );\n\n        sinkCell( sink, summary.get( \"totalPercentage\" ) + \"%\" );\n\n        sinkCell( sink, (String) summary.get( \"totalElapsedTime\" ) );\n\n        sink.tableRow_();\n\n        sink.table_();\n\n        sink.lineBreak();\n\n        sink.rawText( bundle.getString( \"report.surefire.text.note1\" ) );\n\n        sinkLineBreak( sink );\n    }","id":90595,"modified_method":"private void constructSummarySection( ResourceBundle bundle, Sink sink )\n    {\n        Map summary = report.getSummary( testSuites );\n\n        sink.sectionTitle1();\n\n        sinkAnchor( sink, \"Summary\" );\n\n        sink.text( bundle.getString( \"report.surefire.label.summary\" ) );\n\n        sink.sectionTitle1_();\n\n        constructHotLinks( sink, bundle );\n\n        sinkLineBreak( sink );\n\n        sink.table();\n\n        sink.tableRow();\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.tests\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.errors\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.failures\" ) );\n        \n        sinkHeader( sink, bundle.getString( \"report.surefire.label.skipped\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.successrate\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.time\" ) );\n\n        sink.tableRow_();\n\n        sink.tableRow();\n\n        sinkCell( sink, (String) summary.get( \"totalTests\" ) );\n\n        sinkCell( sink, (String) summary.get( \"totalErrors\" ) );\n\n        sinkCell( sink, (String) summary.get( \"totalFailures\" ) );\n\n        sinkCell( sink, (String) summary.get( \"totalSkipped\" ) );\n\n        sinkCell( sink, summary.get( \"totalPercentage\" ) + \"%\" );\n\n        sinkCell( sink, (String) summary.get( \"totalElapsedTime\" ) );\n\n        sink.tableRow_();\n\n        sink.table_();\n\n        sink.lineBreak();\n\n        sink.rawText( bundle.getString( \"report.surefire.text.note1\" ) );\n\n        sinkLineBreak( sink );\n    }","commit_id":"7154799ab84832bdb124f4dc49460c4e1d7c1190","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void constructPackagesSection( ResourceBundle bundle, Sink sink, Map suitePackages )\n    {\n        NumberFormat numberFormat = report.getNumberFormat();\n\n        sink.sectionTitle1();\n\n        sinkAnchor( sink, \"Package_List\" );\n\n        sink.text( bundle.getString( \"report.surefire.label.packagelist\" ) );\n\n        sink.sectionTitle1_();\n\n        constructHotLinks( sink, bundle );\n\n        sinkLineBreak( sink );\n\n        sink.table();\n\n        sink.tableRow();\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.package\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.tests\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.errors\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.failures\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.successrate\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.time\" ) );\n\n        sink.tableRow_();\n\n        Iterator packIter = suitePackages.keySet().iterator();\n\n        while ( packIter.hasNext() )\n        {\n            sink.tableRow();\n\n            String packageName = (String) packIter.next();\n\n            List testSuiteList = (List) suitePackages.get( packageName );\n\n            Map packageSummary = report.getSummary( testSuiteList );\n\n            sinkCellLink( sink, packageName, \"#\" + packageName );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalTests\" ) );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalErrors\" ) );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalFailures\" ) );\n\n            sinkCell( sink, packageSummary.get( \"totalPercentage\" ) + \"%\" );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalElapsedTime\" ) );\n\n            sink.tableRow_();\n        }\n\n        sink.table_();\n\n        sink.lineBreak();\n\n        sink.rawText( bundle.getString( \"report.surefire.text.note2\" ) );\n\n        packIter = suitePackages.keySet().iterator();\n\n        while ( packIter.hasNext() )\n        {\n            String packageName = (String) packIter.next();\n\n            List testSuiteList = (List) suitePackages.get( packageName );\n\n            Iterator suiteIterator = testSuiteList.iterator();\n\n            sink.sectionTitle2();\n\n            sinkAnchor( sink, packageName );\n\n            sink.text( packageName );\n\n            sink.sectionTitle2_();\n\n            sink.table();\n\n            sink.tableRow();\n\n            sinkHeader( sink, \"\" );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.class\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.tests\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.errors\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.failures\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.successrate\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.time\" ) );\n\n            sink.tableRow_();\n\n            while ( suiteIterator.hasNext() )\n            {\n                ReportTestSuite suite = (ReportTestSuite) suiteIterator.next();\n\n                if ( showSuccess || suite.getNumberOfErrors() != 0 || suite.getNumberOfFailures() != 0 )\n                {\n\n                    sink.tableRow();\n\n                    sink.tableCell();\n\n                    sink.link( \"#\" + suite.getPackageName() + suite.getName() );\n\n                    if ( suite.getNumberOfErrors() > 0 )\n                    {\n                        sinkIcon( \"error\", sink );\n                    }\n                    else if ( suite.getNumberOfFailures() > 0 )\n                    {\n                        sinkIcon( \"junit.framework\", sink );\n                    }\n                    else\n                    {\n                        sinkIcon( \"success\", sink );\n                    }\n\n                    sink.link_();\n\n                    sink.tableCell_();\n\n                    sinkCellLink( sink, suite.getName(), \"#\" + suite.getPackageName() + suite.getName() );\n\n                    sinkCell( sink, Integer.toString( suite.getNumberOfTests() ) );\n\n                    sinkCell( sink, Integer.toString( suite.getNumberOfErrors() ) );\n\n                    sinkCell( sink, Integer.toString( suite.getNumberOfFailures() ) );\n\n                    String percentage = report.computePercentage( suite.getNumberOfTests(), suite.getNumberOfErrors(),\n                                                                  suite.getNumberOfFailures() );\n                    sinkCell( sink, percentage + \"%\" );\n\n                    sinkCell( sink, numberFormat.format( suite.getTimeElapsed() ) );\n\n                    sink.tableRow_();\n                }\n            }\n\n            sink.table_();\n        }\n\n        sinkLineBreak( sink );\n    }","id":90596,"modified_method":"private void constructPackagesSection( ResourceBundle bundle, Sink sink, Map suitePackages )\n    {\n        NumberFormat numberFormat = report.getNumberFormat();\n\n        sink.sectionTitle1();\n\n        sinkAnchor( sink, \"Package_List\" );\n\n        sink.text( bundle.getString( \"report.surefire.label.packagelist\" ) );\n\n        sink.sectionTitle1_();\n\n        constructHotLinks( sink, bundle );\n\n        sinkLineBreak( sink );\n\n        sink.table();\n\n        sink.tableRow();\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.package\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.tests\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.errors\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.failures\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.skipped\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.successrate\" ) );\n\n        sinkHeader( sink, bundle.getString( \"report.surefire.label.time\" ) );\n\n        sink.tableRow_();\n\n        Iterator packIter = suitePackages.keySet().iterator();\n\n        while ( packIter.hasNext() )\n        {\n            sink.tableRow();\n\n            String packageName = (String) packIter.next();\n\n            List testSuiteList = (List) suitePackages.get( packageName );\n\n            Map packageSummary = report.getSummary( testSuiteList );\n\n            sinkCellLink( sink, packageName, \"#\" + packageName );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalTests\" ) );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalErrors\" ) );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalFailures\" ) );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalSkipped\" ) );\n\n            sinkCell( sink, packageSummary.get( \"totalPercentage\" ) + \"%\" );\n\n            sinkCell( sink, (String) packageSummary.get( \"totalElapsedTime\" ) );\n\n            sink.tableRow_();\n        }\n\n        sink.table_();\n\n        sink.lineBreak();\n\n        sink.rawText( bundle.getString( \"report.surefire.text.note2\" ) );\n\n        packIter = suitePackages.keySet().iterator();\n\n        while ( packIter.hasNext() )\n        {\n            String packageName = (String) packIter.next();\n\n            List testSuiteList = (List) suitePackages.get( packageName );\n\n            Iterator suiteIterator = testSuiteList.iterator();\n\n            sink.sectionTitle2();\n\n            sinkAnchor( sink, packageName );\n\n            sink.text( packageName );\n\n            sink.sectionTitle2_();\n\n            sink.table();\n\n            sink.tableRow();\n\n            sinkHeader( sink, \"\" );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.class\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.tests\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.errors\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.failures\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.skipped\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.successrate\" ) );\n\n            sinkHeader( sink, bundle.getString( \"report.surefire.label.time\" ) );\n\n            sink.tableRow_();\n\n            while ( suiteIterator.hasNext() )\n            {\n                ReportTestSuite suite = (ReportTestSuite) suiteIterator.next();\n\n                if ( showSuccess || suite.getNumberOfErrors() != 0 || suite.getNumberOfFailures() != 0 )\n                {\n\n                    sink.tableRow();\n\n                    sink.tableCell();\n\n                    sink.link( \"#\" + suite.getPackageName() + suite.getName() );\n\n                    if ( suite.getNumberOfErrors() > 0 )\n                    {\n                        sinkIcon( \"error\", sink );\n                    }\n                    else if ( suite.getNumberOfFailures() > 0 )\n                    {\n                        sinkIcon( \"junit.framework\", sink );\n                    }\n                    else\n                    {\n                        sinkIcon( \"success\", sink );\n                    }\n\n                    sink.link_();\n\n                    sink.tableCell_();\n\n                    sinkCellLink( sink, suite.getName(), \"#\" + suite.getPackageName() + suite.getName() );\n\n                    sinkCell( sink, Integer.toString( suite.getNumberOfTests() ) );\n\n                    sinkCell( sink, Integer.toString( suite.getNumberOfErrors() ) );\n\n                    sinkCell( sink, Integer.toString( suite.getNumberOfFailures() ) );\n\n                    sinkCell( sink, Integer.toString( suite.getNumberOfSkipped() ) );\n\n                    String percentage = report.computePercentage( suite.getNumberOfTests(), suite.getNumberOfErrors(),\n                                                                  suite.getNumberOfFailures(), suite\n                                                                      .getNumberOfSkipped() );\n                    sinkCell( sink, percentage + \"%\" );\n\n                    sinkCell( sink, numberFormat.format( suite.getTimeElapsed() ) );\n\n                    sink.tableRow_();\n                }\n            }\n\n            sink.table_();\n        }\n\n        sinkLineBreak( sink );\n    }","commit_id":"7154799ab84832bdb124f4dc49460c4e1d7c1190","url":"https://github.com/apache/maven-plugins"},{"original_method":"public String computePercentage( int tests, int errors, int failures )\n    {\n        float percentage;\n        if ( tests == 0 )\n        {\n            percentage = 0;\n        }\n        else\n        {\n            percentage = ( (float) ( tests - errors - failures ) / (float) tests ) * PCENT;\n        }\n\n        return numberFormat.format( percentage );\n    }","id":90597,"modified_method":"public String computePercentage( int tests, int errors, int failures, int skipped )\n    {\n        float percentage;\n        if ( tests == 0 )\n        {\n            percentage = 0;\n        }\n        else\n        {\n            percentage = ( (float) ( tests - errors - failures - skipped ) / (float) tests ) * PCENT;\n        }\n\n        return numberFormat.format( percentage );\n    }","commit_id":"7154799ab84832bdb124f4dc49460c4e1d7c1190","url":"https://github.com/apache/maven-plugins"},{"original_method":"public Map getSummary( List suites )\n    {\n        Map totalSummary = new HashMap();\n\n        ListIterator iter = suites.listIterator();\n\n        int totalNumberOfTests = 0;\n\n        int totalNumberOfErrors = 0;\n\n        int totalNumberOfFailures = 0;\n\n        float totalElapsedTime = 0.0f;\n\n        while ( iter.hasNext() )\n        {\n            ReportTestSuite suite = (ReportTestSuite) iter.next();\n\n            totalNumberOfTests += suite.getNumberOfTests();\n\n            totalNumberOfErrors += suite.getNumberOfErrors();\n\n            totalNumberOfFailures += suite.getNumberOfFailures();\n\n            totalElapsedTime += suite.getTimeElapsed();\n        }\n\n        String totalPercentage = computePercentage( totalNumberOfTests, totalNumberOfErrors, totalNumberOfFailures );\n\n        totalSummary.put( \"totalTests\", Integer.toString( totalNumberOfTests ) );\n\n        totalSummary.put( \"totalErrors\", Integer.toString( totalNumberOfErrors ) );\n\n        totalSummary.put( \"totalFailures\", Integer.toString( totalNumberOfFailures ) );\n\n        totalSummary.put( \"totalElapsedTime\", numberFormat.format( totalElapsedTime ) );\n\n        totalSummary.put( \"totalPercentage\", totalPercentage );\n\n        return totalSummary;\n    }","id":90598,"modified_method":"public Map getSummary( List suites )\n    {\n        Map totalSummary = new HashMap();\n\n        ListIterator iter = suites.listIterator();\n\n        int totalNumberOfTests = 0;\n\n        int totalNumberOfErrors = 0;\n\n        int totalNumberOfFailures = 0;\n\n        int totalNumberOfSkipped = 0;\n\n        float totalElapsedTime = 0.0f;\n\n        while ( iter.hasNext() )\n        {\n            ReportTestSuite suite = (ReportTestSuite) iter.next();\n\n            totalNumberOfTests += suite.getNumberOfTests();\n\n            totalNumberOfErrors += suite.getNumberOfErrors();\n\n            totalNumberOfFailures += suite.getNumberOfFailures();\n\n            totalNumberOfSkipped += suite.getNumberOfSkipped();\n\n            totalElapsedTime += suite.getTimeElapsed();\n        }\n\n        String totalPercentage = computePercentage( totalNumberOfTests, totalNumberOfErrors, totalNumberOfFailures,\n                                                    totalNumberOfSkipped );\n\n        totalSummary.put( \"totalTests\", Integer.toString( totalNumberOfTests ) );\n\n        totalSummary.put( \"totalErrors\", Integer.toString( totalNumberOfErrors ) );\n\n        totalSummary.put( \"totalFailures\", Integer.toString( totalNumberOfFailures ) );\n\n        totalSummary.put( \"totalSkipped\", Integer.toString( totalNumberOfSkipped ) );\n\n        totalSummary.put( \"totalElapsedTime\", numberFormat.format( totalElapsedTime ) );\n\n        totalSummary.put( \"totalPercentage\", totalPercentage );\n\n        return totalSummary;\n    }","commit_id":"7154799ab84832bdb124f4dc49460c4e1d7c1190","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testGetSummary()\n        throws Exception\n    {\n        ReportTestSuite tSuite1 = new ReportTestSuite();\n\n        ReportTestSuite tSuite2 = new ReportTestSuite();\n\n        tSuite1.setNumberOfErrors( 10 );\n\n        tSuite1.setNumberOfFailures( 20 );\n\n        tSuite1.setTimeElapsed( 1.0f );\n\n        tSuite1.setNumberOfTests( 100 );\n\n        tSuite2.setNumberOfErrors( 10 );\n\n        tSuite2.setNumberOfFailures( 20 );\n\n        tSuite2.setTimeElapsed( 1.0f );\n\n        tSuite2.setNumberOfTests( 100 );\n\n        List suiteList = new ArrayList();\n\n        suiteList.add( tSuite1 );\n\n        suiteList.add( tSuite2 );\n\n        Map testMap = report.getSummary( suiteList );\n\n        assertEquals( 20, Integer.parseInt( testMap.get( \"totalErrors\" ).toString() ) );\n\n        assertEquals( 40, Integer.parseInt( testMap.get( \"totalFailures\" ).toString() ) );\n\n        assertEquals( 200, Integer.parseInt( testMap.get( \"totalTests\" ).toString() ) );\n\n        NumberFormat numberFormat = report.getNumberFormat();\n\n        assertEquals( 2.0f, numberFormat.parse( testMap.get( \"totalElapsedTime\" ).toString() )\n            .floatValue(), 0.0f );\n\n        assertEquals( 70.00f, numberFormat.parse( (String) testMap.get( \"totalPercentage\" ) )\n            .floatValue(), 0 );\n    }","id":90599,"modified_method":"public void testGetSummary()\n        throws Exception\n    {\n        ReportTestSuite tSuite1 = new ReportTestSuite();\n\n        ReportTestSuite tSuite2 = new ReportTestSuite();\n\n        tSuite1.setNumberOfErrors( 10 );\n\n        tSuite1.setNumberOfFailures( 20 );\n\n        tSuite1.setNumberOfSkipped( 2 );\n\n        tSuite1.setTimeElapsed( 1.0f );\n\n        tSuite1.setNumberOfTests( 100 );\n\n        tSuite2.setNumberOfErrors( 10 );\n\n        tSuite2.setNumberOfFailures( 20 );\n        \n        tSuite2.setNumberOfSkipped( 2 );\n\n        tSuite2.setTimeElapsed( 1.0f );\n\n        tSuite2.setNumberOfTests( 100 );\n\n        List suiteList = new ArrayList();\n\n        suiteList.add( tSuite1 );\n\n        suiteList.add( tSuite2 );\n\n        Map testMap = report.getSummary( suiteList );\n\n        assertEquals( 20, Integer.parseInt( testMap.get( \"totalErrors\" ).toString() ) );\n\n        assertEquals( 40, Integer.parseInt( testMap.get( \"totalFailures\" ).toString() ) );\n\n        assertEquals( 200, Integer.parseInt( testMap.get( \"totalTests\" ).toString() ) );\n\n        assertEquals( 4, Integer.parseInt( testMap.get( \"totalSkipped\" ).toString() ) );\n\n        NumberFormat numberFormat = report.getNumberFormat();\n\n        assertEquals( 2.0f, numberFormat.parse( testMap.get( \"totalElapsedTime\" ).toString() )\n            .floatValue(), 0.0f );\n\n        assertEquals( 68.00f, numberFormat.parse( (String) testMap.get( \"totalPercentage\" ) )\n            .floatValue(), 0 );\n    }","commit_id":"7154799ab84832bdb124f4dc49460c4e1d7c1190","url":"https://github.com/apache/maven-plugins"},{"original_method":"public void testComputePercentage()\n        throws Exception\n    {\n        NumberFormat numberFormat = report.getNumberFormat();\n\n        assertEquals( 70.00f, numberFormat.parse( report.computePercentage( 100, 20, 10 ) )\n            .floatValue(), 0 );\n    }","id":90600,"modified_method":"public void testComputePercentage()\n        throws Exception\n    {\n        NumberFormat numberFormat = report.getNumberFormat();\n\n        assertEquals( 70.00f, numberFormat.parse( report.computePercentage( 100, 20, 10, 0 ) )\n            .floatValue(), 0 );\n    }","commit_id":"7154799ab84832bdb124f4dc49460c4e1d7c1190","url":"https://github.com/apache/maven-plugins"},{"original_method":"/** Make the next token.\n   *  @param txt What the token should be\n   *  @param originalText The original String that got transformed into txt\n   */\n  private Object getNext(String txt, String originalText) {\n    txt = removeSoftHyphens(txt);\n    if (invertible) {\n      String str = prevWordAfter.toString();\n      prevWordAfter.setLength(0);\n      CoreLabel word = (CoreLabel) tokenFactory.makeToken(txt, yychar, yylength());\n      word.set(CoreAnnotations.OriginalTextAnnotation.class, originalText);\n      word.set(CoreAnnotations.BeforeAnnotation.class, str);\n      prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n      prevWord = word;\n      return word;\n    } else {\n      return tokenFactory.makeToken(txt, yychar, yylength());\n   }\n  }","id":90601,"modified_method":"/** Make the next token.\n   *  @param txt What the token should be\n   *  @param originalText The original String that got transformed into txt\n   */\n  private Object getNext(String txt, String originalText) {\n    return getNext(txt, originalText, null);\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 25: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 32: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 33: break;\n        case 12: \n          { final String origTxt = yytext();\n                          return getNext(asciiQuotes(origTxt), origTxt);\n          }\n        case 34: break;\n        case 15: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 35: break;\n        case 10: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n\t\t    String origTxt = yytext();\n                    return getNext(asciiDash(origTxt), origTxt);\n\t\t  }\n          }\n        case 36: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 37: break;\n        case 27: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 38: break;\n        case 24: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 39: break;\n        case 23: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 1;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 2;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 40: break;\n        case 18: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 41: break;\n        case 4: \n          { return getNext();\n          }\n        case 42: break;\n        case 28: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 43: break;\n        case 7: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 44: break;\n        case 9: \n          { return handleEllipsis(yytext());\n          }\n        case 45: break;\n        case 17: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 46: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 47: break;\n        case 30: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 48: break;\n        case 14: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 49: break;\n        case 11: \n          { return normalizeFractions(yytext());\n          }\n        case 50: break;\n        case 31: \n          { String txt = yytext();\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = txt.replaceAll(\"\\\\(\", openparen);\n\t\t\t    txt = txt.replaceAll(\"\\\\)\", closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n          }\n        case 51: break;\n        case 26: \n          { return getNormalizedAmpNext();\n          }\n        case 52: break;\n        case 22: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String txt = asciiQuotes(origTxt);\n                          return getNext(asciiDash(txt), origTxt);\n          }\n        case 53: break;\n        case 20: \n          { // this one should only match if we're basically at the end of file\n\t\t\t  // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 54: break;\n        case 8: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 55: break;\n        case 29: \n          { yypushback(3) ; return getNext();\n          }\n        case 56: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 57: break;\n        case 21: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt);\n          }\n        case 58: break;\n        case 13: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 59: break;\n        case 19: \n          { if (!noSGML) {\n                            return getNext();\n\t\t\t  }\n          }\n        case 60: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 61: break;\n        case 16: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 62: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) { \n            prevWordAfter.append(yytext()); \n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }","id":90602,"modified_method":"/**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 26: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 33: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 34: break;\n        case 12: \n          { final String origTxt = yytext();\n                          return getNext(asciiQuotes(origTxt), origTxt);\n          }\n        case 35: break;\n        case 15: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 36: break;\n        case 10: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n\t\t    String origTxt = yytext();\n                    return getNext(asciiDash(origTxt), origTxt);\n\t\t  }\n          }\n        case 37: break;\n        case 21: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION);\n          }\n        case 38: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 39: break;\n        case 28: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 40: break;\n        case 25: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 41: break;\n        case 24: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 1;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 2;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 42: break;\n        case 18: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 43: break;\n        case 4: \n          { return getNext();\n          }\n        case 44: break;\n        case 29: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 45: break;\n        case 7: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 46: break;\n        case 9: \n          { return handleEllipsis(yytext());\n          }\n        case 47: break;\n        case 17: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 48: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 49: break;\n        case 31: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 50: break;\n        case 14: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 51: break;\n        case 11: \n          { return normalizeFractions(yytext());\n          }\n        case 52: break;\n        case 32: \n          { String txt = yytext();\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = txt.replaceAll(\"\\\\(\", openparen);\n\t\t\t    txt = txt.replaceAll(\"\\\\)\", closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n          }\n        case 53: break;\n        case 27: \n          { return getNormalizedAmpNext();\n          }\n        case 54: break;\n        case 23: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String txt = asciiQuotes(origTxt);\n                          return getNext(asciiDash(txt), origTxt);\n          }\n        case 55: break;\n        case 20: \n          { // this one should only match if we're basically at the end of file\n\t\t\t  // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 56: break;\n        case 8: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 57: break;\n        case 30: \n          { yypushback(3) ; return getNext();\n          }\n        case 58: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 59: break;\n        case 22: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt);\n          }\n        case 60: break;\n        case 13: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 61: break;\n        case 19: \n          { if (!noSGML) {\n                            return getNext();\n\t\t\t  }\n          }\n        case 62: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 63: break;\n        case 16: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 64: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) { \n            prevWordAfter.append(yytext()); \n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * A fast, rule-based tokenizer for Modern Standard French.\n   * Performs punctuation splitting and light tokenization by default.\n   * <p>\n   * Currently, this tokenizer does not do line splitting. It assumes that the input\n   * file is delimited by the system line separator. The output will be equivalently\n   * delimited.\n   * <\/p>\n   *\n   * @param args\n   */\n  public static void main(String[] args) {\n    final Properties options = StringUtils.argsToProperties(args, argOptionDefs());\n    if (options.containsKey(\"help\")) {\n      System.err.println(usage());\n      System.exit(-1);\n    }\n\n    // Process normalization options\n    final TokenizerFactory<CoreLabel> tf = options.containsKey(\"ftb\") ?\n        FrenchTokenizer.ftbFactory() : FrenchTokenizer.factory();\n    for (String option : options.stringPropertyNames()) {\n      tf.setOptions(option);\n    }\n\n    // Normalize line separators so that we can count lines in the output\n    tf.setOptions(\"tokenizeNLs\");\n\n    // Read the file from stdin\n    int nLines = 0;\n    int nTokens = 0;\n    final String encoding = options.getProperty(\"encoding\", \"UTF-8\");\n    final boolean toLower = PropertiesUtils.getBool(options, \"lowerCase\", false);\n    try {\n      Tokenizer<CoreLabel> tokenizer = tf.getTokenizer(new InputStreamReader(System.in, encoding));\n      boolean printSpace = false;\n      while (tokenizer.hasNext()) {\n        ++nTokens;\n        String word = tokenizer.next().word();\n        if (word.equals(FrenchLexer.NEWLINE_TOKEN)) {\n          ++nLines;\n          printSpace = false;\n          System.out.println();\n        } else {\n          if (printSpace) System.out.print(\" \");\n          System.out.print(toLower ? word.toLowerCase(Locale.FRENCH) : word);\n          printSpace = true;\n        }\n      }\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    }\n    System.err.printf(\"Done! Tokenized %d lines (%d tokens)%n\", nLines, nTokens);\n  }","id":90603,"modified_method":"/**\n   * A fast, rule-based tokenizer for Modern Standard French.\n   * Performs punctuation splitting and light tokenization by default.\n   * <p>\n   * Currently, this tokenizer does not do line splitting. It assumes that the input\n   * file is delimited by the system line separator. The output will be equivalently\n   * delimited.\n   * <\/p>\n   *\n   * @param args\n   */\n  public static void main(String[] args) {\n    final Properties options = StringUtils.argsToProperties(args, argOptionDefs());\n    if (options.containsKey(\"help\")) {\n      System.err.println(usage());\n      System.exit(-1);\n    }\n\n    // Lexer options\n    final TokenizerFactory<CoreLabel> tf = options.containsKey(\"ftb\") ?\n        FrenchTokenizer.ftbFactory() : FrenchTokenizer.factory();\n    String orthoOptions = options.getProperty(\"orthoOpts\", \"\");\n    tf.setOptions(orthoOptions);\n    \n    // Currently we split on sentence-final whitespace. No options for\n    // more granular sentence splitting.\n    tf.setOptions(\"tokenizeNLs\");\n    \n    // Other options\n    final String encoding = options.getProperty(\"encoding\", \"UTF-8\");\n    final boolean toLower = PropertiesUtils.getBool(options, \"lowerCase\", false);\n\n    // Read the file from stdin\n    int nLines = 0;\n    int nTokens = 0;\n    final long startTime = System.nanoTime();\n    try {\n      Tokenizer<CoreLabel> tokenizer = tf.getTokenizer(new InputStreamReader(System.in, encoding));\n      boolean printSpace = false;\n      while (tokenizer.hasNext()) {\n        ++nTokens;\n        String word = tokenizer.next().word();\n        if (word.equals(FrenchLexer.NEWLINE_TOKEN)) {\n          ++nLines;\n          printSpace = false;\n          System.out.println();\n        } else {\n          if (printSpace) System.out.print(\" \");\n          String outputToken = toLower ? word.toLowerCase(Locale.FRENCH) : word;\n          System.out.print(outputToken);\n          printSpace = true;\n        }\n      }\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    }\n    long elapsedTime = System.nanoTime() - startTime;\n    double linesPerSec = (double) nLines / (elapsedTime / 1e9);\n    System.err.printf(\"Done! Tokenized %d lines (%d tokens) at %.2f lines/sec%n\", nLines, nTokens, linesPerSec);\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static TokenizerFactory<CoreLabel> factory() {\n    return FrenchTokenizerFactory.newTokenizerFactory();\n  }","id":90604,"modified_method":"/**\n   * Returns a factory for FrenchTokenizer.\n   * \n   * @return\n   */\n  public static TokenizerFactory<CoreLabel> factory() {\n    return FrenchTokenizerFactory.newTokenizerFactory();\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static Map<String,Integer> argOptionDefs() {\n    Map<String,Integer> argOptionDefs = Generics.newHashMap();\n    argOptionDefs.put(\"help\", 0);\n    argOptionDefs.put(\"ftb\", 0);\n    argOptionDefs.put(\"lowerCase\", 0);\n    argOptionDefs.put(\"encoding\", 1);\n    return argOptionDefs;\n  }","id":90605,"modified_method":"private static Map<String,Integer> argOptionDefs() {\n    Map<String,Integer> argOptionDefs = Generics.newHashMap();\n    argOptionDefs.put(\"help\", 0);\n    argOptionDefs.put(\"ftb\", 0);\n    argOptionDefs.put(\"lowerCase\", 0);\n    argOptionDefs.put(\"encoding\", 1);\n    argOptionDefs.put(\"orthoOpts\", 1);\n    return argOptionDefs;\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  @SuppressWarnings(\"unchecked\")\n  protected T getNext() {\n    try {\n      T nextToken = null;\n      // Depending on the orthographic normalization options,\n      // some tokens can be obliterated. In this case, keep iterating\n      // until we see a non-zero length token.\n      do {\n        nextToken = (T) lexer.next();\n      } while (nextToken != null && nextToken.word().length() == 0);\n\n      return nextToken;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n  }","id":90606,"modified_method":"@Override\n  @SuppressWarnings(\"unchecked\")\n  protected T getNext() {\n    try {\n      T nextToken = null;\n      // Depending on the orthographic normalization options,\n      // some tokens can be obliterated. In this case, keep iterating\n      // until we see a non-zero length token.\n      do {\n        nextToken = (splitCompounds && compoundBuffer.size() > 0) ?\n            (T) compoundBuffer.remove(0) : \n              (T) lexer.next();\n      } while (nextToken != null && nextToken.word().length() == 0);\n\n      // Check for compounds to split\n      if (splitCompounds && nextToken instanceof CoreLabel) {\n        CoreLabel cl = (CoreLabel) nextToken;\n        if (cl.containsKey(ParentAnnotation.class) && cl.get(ParentAnnotation.class).equals(FrenchLexer.COMPOUND_ANNOTATION)) {\n          nextToken = (T) processCompound(cl);\n        }\n      }\n      \n      return nextToken;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String usage() {\n    StringBuffer sb = new StringBuffer();\n    String nl = System.getProperty(\"line.separator\");\n    sb.append(String.format(\"Usage: java %s [OPTIONS] < file%n%n\", FrenchTokenizer.class.getName()));\n    sb.append(\"Options:\").append(nl);\n    sb.append(\"   -help          : Print this message.\").append(nl);\n    sb.append(\"   -ftb           : Tokenization for experiments in Green et al. (2011).\").append(nl);\n    sb.append(\"   -lowerCase     : Apply lowercasing.\").append(nl);\n    sb.append(\"   -encoding type : Encoding format.\").append(nl);\n    return sb.toString();\n  }","id":90607,"modified_method":"private static String usage() {\n    StringBuffer sb = new StringBuffer();\n    String nl = System.getProperty(\"line.separator\");\n    sb.append(String.format(\"Usage: java %s [OPTIONS] < file%n%n\", FrenchTokenizer.class.getName()));\n    sb.append(\"Options:\").append(nl);\n    sb.append(\"   -help          : Print this message.\").append(nl);\n    sb.append(\"   -ftb           : Tokenization for experiments in Green et al. (2011).\").append(nl);\n    sb.append(\"   -lowerCase     : Apply lowercasing.\").append(nl);\n    sb.append(\"   -encoding type : Encoding format.\").append(nl);\n    sb.append(\"   -orthoOpts str : Orthographic options (see FrenchLexer.java)\").append(nl);\n    return sb.toString();\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static TokenizerFactory<CoreLabel> ftbFactory() {\n    TokenizerFactory<CoreLabel> tf = FrenchTokenizerFactory.newTokenizerFactory();\n    for (String option : ftbOptions.stringPropertyNames()) {\n      tf.setOptions(option);\n    }\n    return tf;\n  }","id":90608,"modified_method":"/**\n   * Returns a factory for FrenchTokenizer that replicates the tokenization of\n   * Green, de Marneffe, and Manning (2011).\n   * \n   * @return\n   */\n  public static TokenizerFactory<CoreLabel> ftbFactory() {\n    TokenizerFactory<CoreLabel> tf = FrenchTokenizerFactory.newTokenizerFactory();\n    tf.setOptions(FTB_OPTIONS);\n    return tf;\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Tokenizer<T> getTokenizer(Reader r) {\n      return new FrenchTokenizer<T>(r, factory, lexerProperties);\n    }","id":90609,"modified_method":"public Tokenizer<T> getTokenizer(Reader r) {\n      return new FrenchTokenizer<T>(r, factory, lexerProperties, splitCompoundOption);\n    }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public FrenchTokenizer(Reader r, LexedTokenFactory<T> tf, Properties lexerProperties) {\n    lexer = new FrenchLexer(r, tf, lexerProperties);\n  }","id":90610,"modified_method":"/**\n   * Constructor.\n   * \n   * @param r\n   * @param tf\n   * @param lexerProperties\n   * @param splitCompounds\n   */\n  public FrenchTokenizer(Reader r, LexedTokenFactory<T> tf, Properties lexerProperties, boolean splitCompounds) {\n    lexer = new FrenchLexer(r, tf, lexerProperties);\n    this.splitCompounds = splitCompounds;\n    if (splitCompounds) compoundBuffer = Generics.newLinkedList();\n  }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * options: A comma-separated list of options\n     */\n    public void setOptions(String options) {\n      String[] optionList = options.split(\",\");\n      for (String option : optionList) {\n        String[] fields = option.split(\"=\");\n        if (fields.length == 1) {\n          lexerProperties.put(option, \"true\");\n          \n        } else if (fields.length == 2) {\n          lexerProperties.put(fields[0], fields[1]);\n        } else {\n          System.err.printf(\"%s: Bad option %s%n\", this.getClass().getName(), option);\n        }\n      }\n    }","id":90611,"modified_method":"/**\n     * Set underlying tokenizer options.\n     * \n     * @param options A comma-separated list of options\n     */\n    public void setOptions(String options) {\n      String[] optionList = options.split(\",\");\n      for (String option : optionList) {\n        String[] fields = option.split(\"=\");\n        if (fields.length == 1) {\n          if (fields[0].equals(\"splitCompounds\")) {\n            splitCompoundOption = true;\n          } else {\n            lexerProperties.put(option, \"true\");\n          }\n        \n        } else if (fields.length == 2) {\n          if (fields[0].equals(\"splitCompounds\")) {\n            splitCompoundOption = Boolean.valueOf(fields[1]);\n          } else {\n            lexerProperties.put(fields[0], fields[1]);\n          }\n        \n        } else {\n          System.err.printf(\"%s: Bad option %s%n\", this.getClass().getName(), option);\n        }\n      }\n    }","commit_id":"7721589f90cf05af72cd122e50d30db9c5520a76","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 25: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 32: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 33: break;\n        case 12: \n          { final String origTxt = yytext();\n                          return getNext(asciiQuotes(origTxt), origTxt);\n          }\n        case 34: break;\n        case 15: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 35: break;\n        case 10: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n\t\t    String origTxt = yytext();\n                    return getNext(asciiDash(origTxt), origTxt);\n\t\t  }\n          }\n        case 36: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 37: break;\n        case 27: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 38: break;\n        case 24: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 39: break;\n        case 23: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 1;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 2;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 40: break;\n        case 18: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 41: break;\n        case 4: \n          { return getNext();\n          }\n        case 42: break;\n        case 28: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 43: break;\n        case 7: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 44: break;\n        case 9: \n          { return handleEllipsis(yytext());\n          }\n        case 45: break;\n        case 17: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 46: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 47: break;\n        case 30: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 48: break;\n        case 14: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 49: break;\n        case 11: \n          { return normalizeFractions(yytext());\n          }\n        case 50: break;\n        case 31: \n          { String txt = yytext();\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = txt.replaceAll(\"\\\\(\", openparen);\n\t\t\t    txt = txt.replaceAll(\"\\\\)\", closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n          }\n        case 51: break;\n        case 26: \n          { return getNormalizedAmpNext();\n          }\n        case 52: break;\n        case 22: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String txt = asciiQuotes(origTxt);\n                          return getNext(asciiDash(txt), origTxt);\n          }\n        case 53: break;\n        case 20: \n          { // this one should only match if we're basically at the end of file\n\t\t\t  // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 54: break;\n        case 8: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 55: break;\n        case 29: \n          { yypushback(3) ; return getNext();\n          }\n        case 56: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 57: break;\n        case 21: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt);\n          }\n        case 58: break;\n        case 13: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 59: break;\n        case 19: \n          { if (!noSGML) {\n                            return getNext();\n\t\t\t  }\n          }\n        case 60: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 61: break;\n        case 16: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 62: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) { \n            prevWordAfter.append(yytext()); \n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }","id":90612,"modified_method":"/**\n   * Resumes scanning until the next regular expression is matched,\n   * the end of input is encountered or an I/O-Error occurs.\n   *\n   * @return      the next token\n   * @exception   java.io.IOException  if any I/O-Error occurs\n   */\n  public Object next() throws java.io.IOException {\n    int zzInput;\n    int zzAction;\n\n    // cached fields:\n    int zzCurrentPosL;\n    int zzMarkedPosL;\n    int zzEndReadL = zzEndRead;\n    char [] zzBufferL = zzBuffer;\n    char [] zzCMapL = ZZ_CMAP;\n\n    int [] zzTransL = ZZ_TRANS;\n    int [] zzRowMapL = ZZ_ROWMAP;\n    int [] zzAttrL = ZZ_ATTRIBUTE;\n\n    while (true) {\n      zzMarkedPosL = zzMarkedPos;\n\n      yychar+= zzMarkedPosL-zzStartRead;\n\n      zzAction = -1;\n\n      zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;\n  \n      zzState = ZZ_LEXSTATE[zzLexicalState];\n\n\n      zzForAction: {\n        while (true) {\n    \n          if (zzCurrentPosL < zzEndReadL)\n            zzInput = zzBufferL[zzCurrentPosL++];\n          else if (zzAtEOF) {\n            zzInput = YYEOF;\n            break zzForAction;\n          }\n          else {\n            // store back cached positions\n            zzCurrentPos  = zzCurrentPosL;\n            zzMarkedPos   = zzMarkedPosL;\n            boolean eof = zzRefill();\n            // get translated positions and possibly new buffer\n            zzCurrentPosL  = zzCurrentPos;\n            zzMarkedPosL   = zzMarkedPos;\n            zzBufferL      = zzBuffer;\n            zzEndReadL     = zzEndRead;\n            if (eof) {\n              zzInput = YYEOF;\n              break zzForAction;\n            }\n            else {\n              zzInput = zzBufferL[zzCurrentPosL++];\n            }\n          }\n          int zzNext = zzTransL[ zzRowMapL[zzState] + zzCMapL[zzInput] ];\n          if (zzNext == -1) break zzForAction;\n          zzState = zzNext;\n\n          int zzAttributes = zzAttrL[zzState];\n          if ( (zzAttributes & 1) == 1 ) {\n            zzAction = zzState;\n            zzMarkedPosL = zzCurrentPosL;\n            if ( (zzAttributes & 8) == 8 ) break zzForAction;\n          }\n\n        }\n      }\n\n      // store back cached position\n      zzMarkedPos = zzMarkedPosL;\n\n      switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {\n        case 26: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                            txt = delimit(txt, '*');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 33: break;\n        case 5: \n          { if (tokenizeNLs) {\n                      return getNext(NEWLINE_TOKEN, yytext()); // js: for tokenizing carriage returns\n                  } else if (invertible) {\n                      prevWordAfter.append(yytext());\n                  }\n          }\n        case 34: break;\n        case 12: \n          { final String origTxt = yytext();\n                          return getNext(asciiQuotes(origTxt), origTxt);\n          }\n        case 35: break;\n        case 15: \n          { if (normalizeParentheses) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 36: break;\n        case 10: \n          { if (yylength() >= 3 && yylength() <= 4 && ptb3Dashes) {\n\t            return getNext(ptbmdash, yytext());\n                  } else {\n\t\t    String origTxt = yytext();\n                    return getNext(asciiDash(origTxt), origTxt);\n\t\t  }\n          }\n        case 37: break;\n        case 21: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt, COMPOUND_ANNOTATION);\n          }\n        case 38: break;\n        case 1: \n          { String str = yytext();\n          int first = str.charAt(0);\n          String msg = String.format(\"Untokenizable: %s (U+%s, decimal: %s)\", yytext(), Integer.toHexString(first).toUpperCase(), Integer.toString(first));\n          switch (untokenizable) {\n            case NONE_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              break;\n            case FIRST_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              break;\n            case ALL_DELETE:\n              if (invertible) {\n                prevWordAfter.append(str);\n              }\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              break;\n            case NONE_KEEP:\n              return getNext();\n            case FIRST_KEEP:\n              if ( ! this.seenUntokenizableCharacter) {\n                LOGGER.warning(msg);\n                this.seenUntokenizableCharacter = true;\n              }\n              return getNext();\n            case ALL_KEEP:\n              LOGGER.warning(msg);\n              this.seenUntokenizableCharacter = true;\n              return getNext();\n          }\n          }\n        case 39: break;\n        case 28: \n          // lookahead expression with fixed lookahead length\n          yypushback(2);\n          { return getNext();\n          }\n        case 40: break;\n        case 25: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 7;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 8;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 41: break;\n        case 24: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 1;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 2;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { return getNext();\n          }\n        case 42: break;\n        case 18: \n          // lookahead expression with fixed lookahead length\n          yypushback(1);\n          { return getNext();\n          }\n        case 43: break;\n        case 4: \n          { return getNext();\n          }\n        case 44: break;\n        case 29: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 5;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 6;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 45: break;\n        case 7: \n          { if (ptb3Dashes) {\n                            return getNext(ptbmdash, yytext()); }\n                          else {\n                            return getNext();\n                          }\n          }\n        case 46: break;\n        case 9: \n          { return handleEllipsis(yytext());\n          }\n        case 47: break;\n        case 17: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openbrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 48: break;\n        case 2: \n          { if (normalizeOtherBrackets) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 49: break;\n        case 31: \n          { String txt = yytext();\n                          if (escapeForwardSlashAsterisk) {\n                            txt = delimit(txt, '/');\n                          }\n                          return getNext(txt, yytext());\n          }\n        case 50: break;\n        case 14: \n          { if (normalizeParentheses) {\n                    return getNext(openparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 51: break;\n        case 11: \n          { return normalizeFractions(yytext());\n          }\n        case 52: break;\n        case 32: \n          { String txt = yytext();\n\t\t\t  if (normalizeParentheses) {\n\t\t\t    txt = txt.replaceAll(\"\\\\(\", openparen);\n\t\t\t    txt = txt.replaceAll(\"\\\\)\", closeparen);\n\t\t\t  }\n\t\t\t  return getNext(txt, yytext());\n          }\n        case 53: break;\n        case 27: \n          { return getNormalizedAmpNext();\n          }\n        case 54: break;\n        case 23: \n          // general lookahead, find correct zzMarkedPos\n          { int zzFState = 3;\n            int zzFPos = zzStartRead;\n            if (zzFin.length <= zzBufferL.length) { zzFin = new boolean[zzBufferL.length+1]; }\n            boolean zzFinL[] = zzFin;\n            while (zzFState != -1 && zzFPos < zzMarkedPos) {\n              if ((zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n              zzInput = zzBufferL[zzFPos++];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            }\n            if (zzFState != -1 && (zzAttrL[zzFState] & 1) == 1) { zzFinL[zzFPos] = true; } \n\n            zzFState = 4;\n            zzFPos = zzMarkedPos;\n            while (!zzFinL[zzFPos] || (zzAttrL[zzFState] & 1) != 1) {\n              zzInput = zzBufferL[--zzFPos];\n              zzFState = zzTransL[ zzRowMapL[zzFState] + zzCMapL[zzInput] ];\n            };\n            zzMarkedPos = zzFPos;\n          }\n          { final String origTxt = yytext();\n                          String txt = asciiQuotes(origTxt);\n                          return getNext(asciiDash(txt), origTxt);\n          }\n        case 55: break;\n        case 20: \n          { // this one should only match if we're basically at the end of file\n\t\t\t  // since the last one matches two things, even newlines\n                          String s;\n                          if (strictTreebank3 && ! \"U.S.\".equals(yytext())) {\n                            yypushback(1); // return a period for next time\n                            s = yytext();\n                          } else {\n                            s = yytext();\n                            yypushback(1); // return a period for next time\n                          }\n\t                  return getNext(s, yytext());\n          }\n        case 56: break;\n        case 8: \n          { if (invertible) {\n                     prevWordAfter.append(yytext());\n                  }\n          }\n        case 57: break;\n        case 30: \n          { yypushback(3) ; return getNext();\n          }\n        case 58: break;\n        case 3: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '/'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 59: break;\n        case 22: \n          { final String origTxt = yytext();\n                          return getNext(asciiDash(origTxt), origTxt);\n          }\n        case 60: break;\n        case 13: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closebrace, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 61: break;\n        case 19: \n          { if (!noSGML) {\n                            return getNext();\n\t\t\t  }\n          }\n        case 62: break;\n        case 6: \n          { if (normalizeOtherBrackets) {\n                    return getNext(closeparen, yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 63: break;\n        case 16: \n          { if (escapeForwardSlashAsterisk) {\n                    return getNext(delimit(yytext(), '*'), yytext()); }\n                  else {\n                    return getNext();\n                  }\n          }\n        case 64: break;\n        default: \n          if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {\n            zzAtEOF = true;\n              {\n                if (invertible) { \n            prevWordAfter.append(yytext()); \n            String str = prevWordAfter.toString();\n            prevWordAfter.setLength(0);\n            prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n          }\n          return null;\n              }\n          } \n          else {\n            zzScanError(ZZ_NO_MATCH);\n          }\n      }\n    }\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/** Make the next token.\n   *  @param txt What the token should be\n   *  @param originalText The original String that got transformed into txt\n   */\n  private Object getNext(String txt, String originalText) {\n    txt = removeSoftHyphens(txt);\n    if (invertible) {\n      String str = prevWordAfter.toString();\n      prevWordAfter.setLength(0);\n      CoreLabel word = (CoreLabel) tokenFactory.makeToken(txt, yychar, yylength());\n      word.set(CoreAnnotations.OriginalTextAnnotation.class, originalText);\n      word.set(CoreAnnotations.BeforeAnnotation.class, str);\n      prevWord.set(CoreAnnotations.AfterAnnotation.class, str);\n      prevWord = word;\n      return word;\n    } else {\n      return tokenFactory.makeToken(txt, yychar, yylength());\n   }\n  }","id":90613,"modified_method":"/** Make the next token.\n   *  @param txt What the token should be\n   *  @param originalText The original String that got transformed into txt\n   */\n  private Object getNext(String txt, String originalText) {\n    return getNext(txt, originalText, null);\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n     * options: A comma-separated list of options\n     */\n    public void setOptions(String options) {\n      String[] optionList = options.split(\",\");\n      for (String option : optionList) {\n        String[] fields = option.split(\"=\");\n        if (fields.length == 1) {\n          lexerProperties.put(option, \"true\");\n          \n        } else if (fields.length == 2) {\n          lexerProperties.put(fields[0], fields[1]);\n        } else {\n          System.err.printf(\"%s: Bad option %s%n\", this.getClass().getName(), option);\n        }\n      }\n    }","id":90614,"modified_method":"/**\n     * Set underlying tokenizer options.\n     * \n     * @param options A comma-separated list of options\n     */\n    public void setOptions(String options) {\n      String[] optionList = options.split(\",\");\n      for (String option : optionList) {\n        String[] fields = option.split(\"=\");\n        if (fields.length == 1) {\n          if (fields[0].equals(\"splitCompounds\")) {\n            splitCompoundOption = true;\n          } else {\n            lexerProperties.put(option, \"true\");\n          }\n        \n        } else if (fields.length == 2) {\n          if (fields[0].equals(\"splitCompounds\")) {\n            splitCompoundOption = Boolean.valueOf(fields[1]);\n          } else {\n            lexerProperties.put(fields[0], fields[1]);\n          }\n        \n        } else {\n          System.err.printf(\"%s: Bad option %s%n\", this.getClass().getName(), option);\n        }\n      }\n    }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static TokenizerFactory<CoreLabel> ftbFactory() {\n    TokenizerFactory<CoreLabel> tf = FrenchTokenizerFactory.newTokenizerFactory();\n    for (String option : ftbOptions.stringPropertyNames()) {\n      tf.setOptions(option);\n    }\n    return tf;\n  }","id":90615,"modified_method":"/**\n   * Returns a factory for FrenchTokenizer that replicates the tokenization of\n   * Green, de Marneffe, and Manning (2011).\n   * \n   * @return\n   */\n  public static TokenizerFactory<CoreLabel> ftbFactory() {\n    TokenizerFactory<CoreLabel> tf = FrenchTokenizerFactory.newTokenizerFactory();\n    tf.setOptions(FTB_OPTIONS);\n    return tf;\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public static TokenizerFactory<CoreLabel> factory() {\n    return FrenchTokenizerFactory.newTokenizerFactory();\n  }","id":90616,"modified_method":"/**\n   * Returns a factory for FrenchTokenizer.\n   * \n   * @return\n   */\n  public static TokenizerFactory<CoreLabel> factory() {\n    return FrenchTokenizerFactory.newTokenizerFactory();\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"@Override\n  @SuppressWarnings(\"unchecked\")\n  protected T getNext() {\n    try {\n      T nextToken = null;\n      // Depending on the orthographic normalization options,\n      // some tokens can be obliterated. In this case, keep iterating\n      // until we see a non-zero length token.\n      do {\n        nextToken = (T) lexer.next();\n      } while (nextToken != null && nextToken.word().length() == 0);\n\n      return nextToken;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n  }","id":90617,"modified_method":"@Override\n  @SuppressWarnings(\"unchecked\")\n  protected T getNext() {\n    try {\n      T nextToken = null;\n      // Depending on the orthographic normalization options,\n      // some tokens can be obliterated. In this case, keep iterating\n      // until we see a non-zero length token.\n      do {\n        nextToken = (splitCompounds && compoundBuffer.size() > 0) ?\n            (T) compoundBuffer.remove(0) : \n              (T) lexer.next();\n      } while (nextToken != null && nextToken.word().length() == 0);\n\n      // Check for compounds to split\n      if (splitCompounds && nextToken instanceof CoreLabel) {\n        CoreLabel cl = (CoreLabel) nextToken;\n        if (cl.containsKey(ParentAnnotation.class) && cl.get(ParentAnnotation.class).equals(FrenchLexer.COMPOUND_ANNOTATION)) {\n          nextToken = (T) processCompound(cl);\n        }\n      }\n      \n      return nextToken;\n\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * A fast, rule-based tokenizer for Modern Standard French.\n   * Performs punctuation splitting and light tokenization by default.\n   * <p>\n   * Currently, this tokenizer does not do line splitting. It assumes that the input\n   * file is delimited by the system line separator. The output will be equivalently\n   * delimited.\n   * <\/p>\n   *\n   * @param args\n   */\n  public static void main(String[] args) {\n    final Properties options = StringUtils.argsToProperties(args, argOptionDefs());\n    if (options.containsKey(\"help\")) {\n      System.err.println(usage());\n      System.exit(-1);\n    }\n\n    // Process normalization options\n    final TokenizerFactory<CoreLabel> tf = options.containsKey(\"ftb\") ?\n        FrenchTokenizer.ftbFactory() : FrenchTokenizer.factory();\n    for (String option : options.stringPropertyNames()) {\n      tf.setOptions(option);\n    }\n\n    // Normalize line separators so that we can count lines in the output\n    tf.setOptions(\"tokenizeNLs\");\n\n    // Read the file from stdin\n    int nLines = 0;\n    int nTokens = 0;\n    final String encoding = options.getProperty(\"encoding\", \"UTF-8\");\n    final boolean toLower = PropertiesUtils.getBool(options, \"lowerCase\", false);\n    try {\n      Tokenizer<CoreLabel> tokenizer = tf.getTokenizer(new InputStreamReader(System.in, encoding));\n      boolean printSpace = false;\n      while (tokenizer.hasNext()) {\n        ++nTokens;\n        String word = tokenizer.next().word();\n        if (word.equals(FrenchLexer.NEWLINE_TOKEN)) {\n          ++nLines;\n          printSpace = false;\n          System.out.println();\n        } else {\n          if (printSpace) System.out.print(\" \");\n          System.out.print(toLower ? word.toLowerCase(Locale.FRENCH) : word);\n          printSpace = true;\n        }\n      }\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    }\n    System.err.printf(\"Done! Tokenized %d lines (%d tokens)%n\", nLines, nTokens);\n  }","id":90618,"modified_method":"/**\n   * A fast, rule-based tokenizer for Modern Standard French.\n   * Performs punctuation splitting and light tokenization by default.\n   * <p>\n   * Currently, this tokenizer does not do line splitting. It assumes that the input\n   * file is delimited by the system line separator. The output will be equivalently\n   * delimited.\n   * <\/p>\n   *\n   * @param args\n   */\n  public static void main(String[] args) {\n    final Properties options = StringUtils.argsToProperties(args, argOptionDefs());\n    if (options.containsKey(\"help\")) {\n      System.err.println(usage());\n      System.exit(-1);\n    }\n\n    // Lexer options\n    final TokenizerFactory<CoreLabel> tf = options.containsKey(\"ftb\") ?\n        FrenchTokenizer.ftbFactory() : FrenchTokenizer.factory();\n    String orthoOptions = options.getProperty(\"orthoOpts\", \"\");\n    tf.setOptions(orthoOptions);\n    \n    // Currently we split on sentence-final whitespace. No options for\n    // more granular sentence splitting.\n    tf.setOptions(\"tokenizeNLs\");\n    \n    // Other options\n    final String encoding = options.getProperty(\"encoding\", \"UTF-8\");\n    final boolean toLower = PropertiesUtils.getBool(options, \"lowerCase\", false);\n\n    // Read the file from stdin\n    int nLines = 0;\n    int nTokens = 0;\n    final long startTime = System.nanoTime();\n    try {\n      Tokenizer<CoreLabel> tokenizer = tf.getTokenizer(new InputStreamReader(System.in, encoding));\n      boolean printSpace = false;\n      while (tokenizer.hasNext()) {\n        ++nTokens;\n        String word = tokenizer.next().word();\n        if (word.equals(FrenchLexer.NEWLINE_TOKEN)) {\n          ++nLines;\n          printSpace = false;\n          System.out.println();\n        } else {\n          if (printSpace) System.out.print(\" \");\n          String outputToken = toLower ? word.toLowerCase(Locale.FRENCH) : word;\n          System.out.print(outputToken);\n          printSpace = true;\n        }\n      }\n    } catch (UnsupportedEncodingException e) {\n      e.printStackTrace();\n    }\n    long elapsedTime = System.nanoTime() - startTime;\n    double linesPerSec = (double) nLines / (elapsedTime / 1e9);\n    System.err.printf(\"Done! Tokenized %d lines (%d tokens) at %.2f lines/sec%n\", nLines, nTokens, linesPerSec);\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static Map<String,Integer> argOptionDefs() {\n    Map<String,Integer> argOptionDefs = Generics.newHashMap();\n    argOptionDefs.put(\"help\", 0);\n    argOptionDefs.put(\"ftb\", 0);\n    argOptionDefs.put(\"lowerCase\", 0);\n    argOptionDefs.put(\"encoding\", 1);\n    return argOptionDefs;\n  }","id":90619,"modified_method":"private static Map<String,Integer> argOptionDefs() {\n    Map<String,Integer> argOptionDefs = Generics.newHashMap();\n    argOptionDefs.put(\"help\", 0);\n    argOptionDefs.put(\"ftb\", 0);\n    argOptionDefs.put(\"lowerCase\", 0);\n    argOptionDefs.put(\"encoding\", 1);\n    argOptionDefs.put(\"orthoOpts\", 1);\n    return argOptionDefs;\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public FrenchTokenizer(Reader r, LexedTokenFactory<T> tf, Properties lexerProperties) {\n    lexer = new FrenchLexer(r, tf, lexerProperties);\n  }","id":90620,"modified_method":"/**\n   * Constructor.\n   * \n   * @param r\n   * @param tf\n   * @param lexerProperties\n   * @param splitCompounds\n   */\n  public FrenchTokenizer(Reader r, LexedTokenFactory<T> tf, Properties lexerProperties, boolean splitCompounds) {\n    lexer = new FrenchLexer(r, tf, lexerProperties);\n    this.splitCompounds = splitCompounds;\n    if (splitCompounds) compoundBuffer = Generics.newLinkedList();\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"private static String usage() {\n    StringBuffer sb = new StringBuffer();\n    String nl = System.getProperty(\"line.separator\");\n    sb.append(String.format(\"Usage: java %s [OPTIONS] < file%n%n\", FrenchTokenizer.class.getName()));\n    sb.append(\"Options:\").append(nl);\n    sb.append(\"   -help          : Print this message.\").append(nl);\n    sb.append(\"   -ftb           : Tokenization for experiments in Green et al. (2011).\").append(nl);\n    sb.append(\"   -lowerCase     : Apply lowercasing.\").append(nl);\n    sb.append(\"   -encoding type : Encoding format.\").append(nl);\n    return sb.toString();\n  }","id":90621,"modified_method":"private static String usage() {\n    StringBuffer sb = new StringBuffer();\n    String nl = System.getProperty(\"line.separator\");\n    sb.append(String.format(\"Usage: java %s [OPTIONS] < file%n%n\", FrenchTokenizer.class.getName()));\n    sb.append(\"Options:\").append(nl);\n    sb.append(\"   -help          : Print this message.\").append(nl);\n    sb.append(\"   -ftb           : Tokenization for experiments in Green et al. (2011).\").append(nl);\n    sb.append(\"   -lowerCase     : Apply lowercasing.\").append(nl);\n    sb.append(\"   -encoding type : Encoding format.\").append(nl);\n    sb.append(\"   -orthoOpts str : Orthographic options (see FrenchLexer.java)\").append(nl);\n    return sb.toString();\n  }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"public Tokenizer<T> getTokenizer(Reader r) {\n      return new FrenchTokenizer<T>(r, factory, lexerProperties);\n    }","id":90622,"modified_method":"public Tokenizer<T> getTokenizer(Reader r) {\n      return new FrenchTokenizer<T>(r, factory, lexerProperties, splitCompoundOption);\n    }","commit_id":"9c2c8903697296b001da0f07afc02b043cd45ba8","url":"https://github.com/stanfordnlp/CoreNLP"},{"original_method":"/**\n   * Tests that close() will close but not cancel the underlying out streams. Also checks that\n   * close() persists and completes the file.\n   */\n  @Test\n  public void closeTest() throws Exception {\n    mTestStream.write(BufferUtils.getIncreasingByteArray((int) (BLOCK_LENGTH * 1.5)));\n    mTestStream.close();\n    for (long streamIndex = 0; streamIndex < 2; streamIndex ++) {\n      Assert.assertFalse(mTachyonOutStreamMap.get(streamIndex).isCanceled());\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isClosed());\n    }\n    Mockito.verify(mWorkerClient, Mockito.times(1)).persistFile(Mockito.eq(FILE_ID),\n        Mockito.anyLong(), Mockito.anyString());\n    Mockito.verify(mFileSystemMasterClient, Mockito.times(1)).completeFile(FILE_ID);\n    Mockito.verify(mBlockStoreContext, Mockito.timeout(1)).acquireWorkerClient();\n    Mockito.verify(mBlockStoreContext, Mockito.timeout(1)).releaseWorkerClient(mWorkerClient);\n  }","id":90623,"modified_method":"/**\n   * Tests that close() will close but not cancel the underlying out streams. Also checks that\n   * close() persists and completes the file.\n   */\n  @Test\n  public void closeTest() throws Exception {\n    Mockito.when(mUnderFileSystem.rename(Mockito.anyString(), Mockito.anyString()))\n        .thenReturn(true);\n    mTestStream.write(BufferUtils.getIncreasingByteArray((int) (BLOCK_LENGTH * 1.5)));\n    mTestStream.close();\n    for (long streamIndex = 0; streamIndex < 2; streamIndex ++) {\n      Assert.assertFalse(mTachyonOutStreamMap.get(streamIndex).isCanceled());\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isClosed());\n    }\n    Mockito.verify(mFileSystemMasterClient, Mockito.times(1)).completeFile(Mockito.eq(FILE_ID),\n        Mockito.any(CompleteFileOptions.class));\n  }","commit_id":"d80ee71621b0308cd16d2f43bc098c2446d4dda3","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests that cancel() will cancel and close the underlying out streams, and delete from the under\n   * file system. Also makes sure that cancel() doesn't persist or complete the file.\n   */\n  @Test\n  public void cancelTest() throws Exception {\n    mTestStream.write(BufferUtils.getIncreasingByteArray((int) (BLOCK_LENGTH * 1.5)));\n    mTestStream.cancel();\n    for (long streamIndex = 0; streamIndex < 2; streamIndex ++) {\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isClosed());\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isCanceled());\n    }\n    // Don't persist or complete the file if the stream was canceled\n    Mockito.verify(mWorkerClient, Mockito.times(0)).persistFile(Mockito.anyLong(),\n        Mockito.anyLong(), Mockito.anyString());\n    Mockito.verify(mFileSystemMasterClient, Mockito.times(0)).completeFile(FILE_ID);\n\n    Mockito.verify(mUnderFileSystem, Mockito.times(1)).delete(Mockito.anyString(),\n        Mockito.eq(false));\n  }","id":90624,"modified_method":"/**\n   * Tests that cancel() will cancel and close the underlying out streams, and delete from the under\n   * file system. Also makes sure that cancel() doesn't persist or complete the file.\n   */\n  @Test\n  public void cancelTest() throws Exception {\n    mTestStream.write(BufferUtils.getIncreasingByteArray((int) (BLOCK_LENGTH * 1.5)));\n    mTestStream.cancel();\n    for (long streamIndex = 0; streamIndex < 2; streamIndex ++) {\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isClosed());\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isCanceled());\n    }\n    // Don't persist or complete the file if the stream was canceled\n    Mockito.verify(mFileSystemMasterClient, Mockito.times(0)).completeFile(FILE_ID,\n        CompleteFileOptions.defaults());\n\n    Mockito.verify(mUnderFileSystem, Mockito.times(1)).delete(Mockito.anyString(),\n        Mockito.eq(false));\n  }","commit_id":"d80ee71621b0308cd16d2f43bc098c2446d4dda3","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests that close() will close but not cancel the underlying out streams. Also checks that\n   * close() persists and completes the file.\n   */\n  @Test\n  public void closeTest() throws Exception {\n    mTestStream.write(BufferUtils.getIncreasingByteArray((int) (BLOCK_LENGTH * 1.5)));\n    mTestStream.close();\n    for (long streamIndex = 0; streamIndex < 2; streamIndex ++) {\n      Assert.assertFalse(mTachyonOutStreamMap.get(streamIndex).isCanceled());\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isClosed());\n    }\n    Mockito.verify(mWorkerClient, Mockito.times(1)).persistFile(Mockito.eq(FILE_ID),\n        Mockito.anyLong(), Mockito.anyString());\n    Mockito.verify(mFileSystemMasterClient, Mockito.times(1)).completeFile(FILE_ID);\n    Mockito.verify(mBlockStoreContext, Mockito.timeout(1)).acquireWorkerClient();\n    Mockito.verify(mBlockStoreContext, Mockito.timeout(1)).releaseWorkerClient(mWorkerClient);\n  }","id":90625,"modified_method":"/**\n   * Tests that close() will close but not cancel the underlying out streams. Also checks that\n   * close() persists and completes the file.\n   */\n  @Test\n  public void closeTest() throws Exception {\n    Mockito.when(mUnderFileSystem.rename(Mockito.anyString(), Mockito.anyString()))\n        .thenReturn(true);\n    mTestStream.write(BufferUtils.getIncreasingByteArray((int) (BLOCK_LENGTH * 1.5)));\n    mTestStream.close();\n    for (long streamIndex = 0; streamIndex < 2; streamIndex ++) {\n      Assert.assertFalse(mTachyonOutStreamMap.get(streamIndex).isCanceled());\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isClosed());\n    }\n    Mockito.verify(mFileSystemMasterClient, Mockito.times(1)).completeFile(Mockito.eq(FILE_ID),\n        Mockito.any(CompleteFileOptions.class));\n  }","commit_id":"6a30313f3dc7c66aa2fdcee3c560e755b5bf2467","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Tests that cancel() will cancel and close the underlying out streams, and delete from the under\n   * file system. Also makes sure that cancel() doesn't persist or complete the file.\n   */\n  @Test\n  public void cancelTest() throws Exception {\n    mTestStream.write(BufferUtils.getIncreasingByteArray((int) (BLOCK_LENGTH * 1.5)));\n    mTestStream.cancel();\n    for (long streamIndex = 0; streamIndex < 2; streamIndex ++) {\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isClosed());\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isCanceled());\n    }\n    // Don't persist or complete the file if the stream was canceled\n    Mockito.verify(mWorkerClient, Mockito.times(0)).persistFile(Mockito.anyLong(),\n        Mockito.anyLong(), Mockito.anyString());\n    Mockito.verify(mFileSystemMasterClient, Mockito.times(0)).completeFile(FILE_ID);\n\n    Mockito.verify(mUnderFileSystem, Mockito.times(1)).delete(Mockito.anyString(),\n        Mockito.eq(false));\n  }","id":90626,"modified_method":"/**\n   * Tests that cancel() will cancel and close the underlying out streams, and delete from the under\n   * file system. Also makes sure that cancel() doesn't persist or complete the file.\n   */\n  @Test\n  public void cancelTest() throws Exception {\n    mTestStream.write(BufferUtils.getIncreasingByteArray((int) (BLOCK_LENGTH * 1.5)));\n    mTestStream.cancel();\n    for (long streamIndex = 0; streamIndex < 2; streamIndex ++) {\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isClosed());\n      Assert.assertTrue(mTachyonOutStreamMap.get(streamIndex).isCanceled());\n    }\n    // Don't persist or complete the file if the stream was canceled\n    Mockito.verify(mFileSystemMasterClient, Mockito.times(0)).completeFile(FILE_ID,\n        CompleteFileOptions.defaults());\n\n    Mockito.verify(mUnderFileSystem, Mockito.times(1)).delete(Mockito.anyString(),\n        Mockito.eq(false));\n  }","commit_id":"6a30313f3dc7c66aa2fdcee3c560e755b5bf2467","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n   * Completes a file. After a file is completed, it cannot be written to. Called via RPC.\n   *\n   * @param fileId the file id to complete\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws BlockInfoException if a block information exception is encountered\n   */\n  public void completeFile(long fileId, CompleteFileOptions options) throws BlockInfoException,\n      FileDoesNotExistException, InvalidPathException, SuspectedFileSizeException {\n    synchronized (mInodeTree) {\n      long opTimeMs = System.currentTimeMillis();\n      Inode inode = mInodeTree.getInodeById(fileId);\n      if (!inode.isFile()) {\n        throw new FileDoesNotExistException(\n            ExceptionMessage.FILEID_MUST_BE_FILE.getMessage(fileId));\n      }\n\n      InodeFile fileInode = (InodeFile) inode;\n      List<Long> blockIdList = fileInode.getBlockIds();\n      List<BlockInfo> blockInfoList = mBlockMaster.getBlockInfoList(blockIdList);\n      if (blockInfoList.size() != blockIdList.size()) {\n        throw new BlockInfoException(\"Cannot complete file without all the blocks committed\");\n      }\n\n      // Iterate from all in-memory file blocks, computing the length and verify that all the blocks\n      // (except the last one) is the same size as the file block size.\n      long inMemoryLength = 0;\n      long fileBlockSize = fileInode.getBlockSizeBytes();\n      for (int i = 0; i < blockInfoList.size(); i ++) {\n        BlockInfo blockInfo = blockInfoList.get(i);\n        inMemoryLength += blockInfo.getLength();\n        if (i < blockInfoList.size() - 1 && blockInfo.getLength() != fileBlockSize) {\n          throw new BlockInfoException(\n              \"Block index \" + i + \" has a block size smaller than the file block size (\"\n                  + fileInode.getBlockSizeBytes() + \")\");\n        }\n      }\n\n      // If the file is both persisted and stored in memory, the memory footprint and the UFS file\n      // length should match.\n      if (fileInode.isPersisted() && inMemoryLength != 0\n          && options.getUfsLength() != inMemoryLength) {\n        throw new SuspectedFileSizeException(\"Inconsistent file length: Tachyon \" + inMemoryLength\n            + \" UFS \" + options.getUfsLength());\n      }\n\n      // If the file is persisted, its length is determined by UFS. Otherwise, its length is\n      // determined by its memory footprint.\n      long length = fileInode.isPersisted() ? options.getUfsLength() : inMemoryLength;\n\n      completeFileInternal(fileInode.getBlockIds(), fileId, length, opTimeMs);\n      writeJournalEntry(\n          new CompleteFileEntry(fileInode.getBlockIds(), fileId, length, opTimeMs));\n      flushJournal();\n    }\n  }","id":90627,"modified_method":"/**\n   * Completes a file. After a file is completed, it cannot be written to. Called via RPC.\n   *\n   * @param fileId the file id to complete\n   * @throws FileDoesNotExistException if the file does not exist\n   * @throws BlockInfoException if a block information exception is encountered\n   */\n  public void completeFile(long fileId, CompleteFileOptions options) throws BlockInfoException,\n      FileDoesNotExistException, InvalidPathException, SuspectedFileSizeException {\n    synchronized (mInodeTree) {\n      long opTimeMs = System.currentTimeMillis();\n      Inode inode = mInodeTree.getInodeById(fileId);\n      if (!inode.isFile()) {\n        throw new FileDoesNotExistException(\n            ExceptionMessage.FILEID_MUST_BE_FILE.getMessage(fileId));\n      }\n\n      InodeFile fileInode = (InodeFile) inode;\n      List<Long> blockIdList = fileInode.getBlockIds();\n      List<BlockInfo> blockInfoList = mBlockMaster.getBlockInfoList(blockIdList);\n\n      // Iterate from all in-memory file blocks, computing the length and verify that all the blocks\n      // (except the last one) is the same size as the file block size.\n      long inMemoryLength = 0;\n      long fileBlockSize = fileInode.getBlockSizeBytes();\n      for (int i = 0; i < blockInfoList.size(); i ++) {\n        BlockInfo blockInfo = blockInfoList.get(i);\n        inMemoryLength += blockInfo.getLength();\n        if (i < blockInfoList.size() - 1 && blockInfo.getLength() != fileBlockSize) {\n          throw new BlockInfoException(\n              \"Block index \" + i + \" has a block size smaller than the file block size (\"\n                  + fileInode.getBlockSizeBytes() + \")\");\n        }\n      }\n\n      // If the file is both persisted and stored in memory, the memory footprint and the UFS file\n      // length should match.\n      if (fileInode.isPersisted() && inMemoryLength != 0\n          && options.getUfsLength() != inMemoryLength) {\n        throw new SuspectedFileSizeException(\"Inconsistent file length: Tachyon \" + inMemoryLength\n            + \" UFS \" + options.getUfsLength());\n      }\n\n      // If the file is persisted, its length is determined by UFS. Otherwise, its length is\n      // determined by its memory footprint.\n      long length = fileInode.isPersisted() ? options.getUfsLength() : inMemoryLength;\n\n      completeFileInternal(fileInode.getBlockIds(), fileId, length, opTimeMs);\n      writeJournalEntry(\n          new CompleteFileEntry(fileInode.getBlockIds(), fileId, length, opTimeMs));\n      flushJournal();\n    }\n  }","commit_id":"6a30313f3dc7c66aa2fdcee3c560e755b5bf2467","url":"https://github.com/amplab/tachyon"},{"original_method":"@Before\n\tpublic void setUp() {\n\t\t_flickrItemSelectorCriterion = new FlickrItemSelectorCriterion();\n\n\t\tList<ItemSelectorReturnType> desiredItemSelectorReturnTypes =\n\t\t\tnew ArrayList<>();\n\n\t\tdesiredItemSelectorReturnTypes.add(_testURLItemSelectorReturnType);\n\n\t\t_flickrItemSelectorCriterion.setDesiredItemSelectorReturnTypes(\n\t\t\tdesiredItemSelectorReturnTypes);\n\n\t\t_itemSelectorImpl = new ItemSelectorImpl();\n\n\t\t_itemSelectorCriterionSerializer.addItemSelectorReturnType(\n\t\t\t_testFileEntryItemSelectorReturnType);\n\t\t_itemSelectorCriterionSerializer.addItemSelectorReturnType(\n\t\t\t_testStringItemSelectorReturnType);\n\t\t_itemSelectorCriterionSerializer.addItemSelectorReturnType(\n\t\t\t_testURLItemSelectorReturnType);\n\n\t\t_itemSelectorImpl.setItemSelectorCriterionSerializer(\n\t\t\t_itemSelectorCriterionSerializer);\n\n\t\t_mediaItemSelectorCriterion = new MediaItemSelectorCriterion();\n\n\t\t_mediaItemSelectorCriterion.setFileExtension(\"jpg\");\n\t\t_mediaItemSelectorCriterion.setMaxSize(2048);\n\n\t\tdesiredItemSelectorReturnTypes = new ArrayList<>();\n\n\t\tdesiredItemSelectorReturnTypes.add(\n\t\t\tnew TestFileEntryItemSelectorReturnType());\n\t\tdesiredItemSelectorReturnTypes.add(_testURLItemSelectorReturnType);\n\n\t\t_mediaItemSelectorCriterion.setDesiredItemSelectorReturnTypes(\n\t\t\tdesiredItemSelectorReturnTypes);\n\n\t\tJSONFactoryUtil jsonFactoryUtil = new JSONFactoryUtil();\n\n\t\tjsonFactoryUtil.setJSONFactory(new JSONFactoryImpl());\n\n\t\tPortal portal = mock(Portal.class);\n\n\t\tLiferayPortletResponse liferayPortletResponse =\n\t\t\tgetMockPortletResponse();\n\n\t\twhen(\n\t\t\tportal.getLiferayPortletResponse(Mockito.any(PortletResponse.class))\n\t\t).thenReturn(\n\t\t\tliferayPortletResponse\n\t\t);\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(portal);\n\n\t\tPortletURLFactory portletURLFactory = mock(PortletURLFactory.class);\n\n\t\tLiferayPortletURL mockLiferayPortletURL = mock(LiferayPortletURL.class);\n\n\t\twhen(\n\t\t\tportletURLFactory.create(\n\t\t\t\tMockito.any(PortletRequest.class), Mockito.anyString(),\n\t\t\t\tMockito.anyLong(), Mockito.anyString())\n\t\t).thenReturn(\n\t\t\tmockLiferayPortletURL\n\t\t);\n\n\t\tPortletURLFactoryUtil portletURLFactoryUtil =\n\t\t\tnew PortletURLFactoryUtil();\n\n\t\tportletURLFactoryUtil.setPortletURLFactory(portletURLFactory);\n\t}","id":90628,"modified_method":"@Before\n\tpublic void setUp() {\n\t\t_flickrItemSelectorCriterion = new FlickrItemSelectorCriterion();\n\n\t\tList<ItemSelectorReturnType> desiredItemSelectorReturnTypes =\n\t\t\tnew ArrayList<>();\n\n\t\tdesiredItemSelectorReturnTypes.add(_testURLItemSelectorReturnType);\n\n\t\t_flickrItemSelectorCriterion.setDesiredItemSelectorReturnTypes(\n\t\t\tdesiredItemSelectorReturnTypes);\n\n\t\t_itemSelectorImpl = new ItemSelectorImpl();\n\n\t\t_itemSelectorCriterionSerializer.addItemSelectorReturnType(\n\t\t\t_testFileEntryItemSelectorReturnType);\n\t\t_itemSelectorCriterionSerializer.addItemSelectorReturnType(\n\t\t\t_testStringItemSelectorReturnType);\n\t\t_itemSelectorCriterionSerializer.addItemSelectorReturnType(\n\t\t\t_testURLItemSelectorReturnType);\n\n\t\t_itemSelectorImpl.setItemSelectorCriterionSerializer(\n\t\t\t_itemSelectorCriterionSerializer);\n\n\t\t_mediaItemSelectorCriterion = new MediaItemSelectorCriterion();\n\n\t\t_mediaItemSelectorCriterion.setFileExtension(\"jpg\");\n\t\t_mediaItemSelectorCriterion.setMaxSize(2048);\n\n\t\tdesiredItemSelectorReturnTypes = new ArrayList<>();\n\n\t\tdesiredItemSelectorReturnTypes.add(\n\t\t\tnew TestFileEntryItemSelectorReturnType());\n\t\tdesiredItemSelectorReturnTypes.add(_testURLItemSelectorReturnType);\n\n\t\t_mediaItemSelectorCriterion.setDesiredItemSelectorReturnTypes(\n\t\t\tdesiredItemSelectorReturnTypes);\n\n\t\tJSONFactoryUtil jsonFactoryUtil = new JSONFactoryUtil();\n\n\t\tjsonFactoryUtil.setJSONFactory(new JSONFactoryImpl());\n\n\t\tPortal portal = mock(Portal.class);\n\n\t\tLiferayPortletResponse liferayPortletResponse =\n\t\t\tmock(LiferayPortletResponse.class);\n\n\t\tLiferayPortletRequest liferayPortletRequest =\n\t\t\tgetMockPortletRequest(liferayPortletResponse);\n\n\t\twhen(\n\t\t\tportal.getLiferayPortletResponse(Mockito.any(PortletResponse.class))\n\t\t).thenReturn(\n\t\t\tliferayPortletResponse\n\t\t);\n\n\t\twhen(\n\t\t\tportal.getLiferayPortletRequest(Mockito.any(PortletRequest.class))\n\t\t).thenReturn(\n\t\t\tliferayPortletRequest\n\t\t);\n\n\t\tLayout layout = mock(Layout.class);\n\n\t\twhen(\n\t\t\tportal.getControlPanelLayout(\n\t\t\t\tMockito.anyLong(), Mockito.any(Group.class))\n\t\t).thenReturn(\n\t\t\tlayout\n\t\t);\n\n\t\tPortalUtil portalUtil = new PortalUtil();\n\n\t\tportalUtil.setPortal(portal);\n\n\t\tPortletURLFactory portletURLFactory = mock(PortletURLFactory.class);\n\n\t\tLiferayPortletURL mockLiferayPortletURL = mock(LiferayPortletURL.class);\n\n\t\twhen(\n\t\t\tportletURLFactory.create(\n\t\t\t\tMockito.any(HttpServletRequest.class), Mockito.anyString(),\n\t\t\t\tMockito.any(Layout.class), Mockito.anyString())\n\t\t).thenReturn(\n\t\t\tmockLiferayPortletURL\n\t\t);\n\n\t\tPortletURLFactoryUtil portletURLFactoryUtil =\n\t\t\tnew PortletURLFactoryUtil();\n\n\t\tportletURLFactoryUtil.setPortletURLFactory(portletURLFactory);\n\t}","commit_id":"ea0b3b7eed3f27184c7203e7d3ae1de44b30f9b5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected PortletRequest getMockPortletRequest(\n\t\tPortletResponse portletResponse) {\n\n\t\tPortletRequest portletRequest = mock(PortletRequest.class);\n\n\t\twhen(\n\t\t\tportletRequest.getAttribute(JavaConstants.JAVAX_PORTLET_RESPONSE)\n\t\t).thenReturn(\n\t\t\tportletResponse\n\t\t);\n\n\t\tThemeDisplay themeDisplay = mock(ThemeDisplay.class);\n\n\t\twhen(\n\t\t\tportletRequest.getAttribute(WebKeys.THEME_DISPLAY)\n\t\t).thenReturn(\n\t\t\tthemeDisplay\n\t\t);\n\n\t\tMap<String, String[]> parameters =\n\t\t\t_itemSelectorImpl.getItemSelectorParameters(\n\t\t\t\t\"itemSelectedEventName\", _mediaItemSelectorCriterion,\n\t\t\t\t_flickrItemSelectorCriterion);\n\n\t\twhen(\n\t\t\tportletRequest.getParameterMap()\n\t\t).thenReturn(\n\t\t\tparameters\n\t\t);\n\n\t\treturn portletRequest;\n\t}","id":90629,"modified_method":"protected LiferayPortletRequest getMockPortletRequest(\n\t\tPortletResponse portletResponse) {\n\n\t\tLiferayPortletRequest liferayPortletRequest = mock(\n\t\t\tLiferayPortletRequest.class);\n\n\t\twhen(\n\t\t\tliferayPortletRequest.getAttribute(\n\t\t\t\tJavaConstants.JAVAX_PORTLET_RESPONSE)\n\t\t).thenReturn(\n\t\t\tportletResponse\n\t\t);\n\n\t\tThemeDisplay themeDisplay = mock(ThemeDisplay.class);\n\n\t\twhen(\n\t\t\tliferayPortletRequest.getAttribute(WebKeys.THEME_DISPLAY)\n\t\t).thenReturn(\n\t\t\tthemeDisplay\n\t\t);\n\n\t\tMap<String, String[]> parameters =\n\t\t\t_itemSelectorImpl.getItemSelectorParameters(\n\t\t\t\t\"itemSelectedEventName\", _mediaItemSelectorCriterion,\n\t\t\t\t_flickrItemSelectorCriterion);\n\n\t\twhen(\n\t\t\tliferayPortletRequest.getParameterMap()\n\t\t).thenReturn(\n\t\t\tparameters\n\t\t);\n\n\t\tHttpServletRequest request = mock(HttpServletRequest.class);\n\n\t\twhen(\n\t\t\tliferayPortletRequest.getHttpServletRequest()\n\t\t).thenReturn(\n\t\t\trequest\n\t\t);\n\n\t\twhen(\n\t\t\trequest.getAttribute(WebKeys.THEME_DISPLAY)\n\t\t).thenReturn(\n\t\t\tthemeDisplay\n\t\t);\n\n\t\tGroup group = mock(Group.class);\n\n\t\twhen(\n\t\t\tthemeDisplay.getScopeGroup()\n\t\t).thenReturn(\n\t\t\tgroup\n\t\t);\n\n\t\twhen(\n\t\t\tgroup.getGroupId()\n\t\t).thenReturn(\n\t\t\t12345L\n\t\t);\n\n\t\twhen(\n\t\t\tthemeDisplay.getScopeGroupId()\n\t\t).thenReturn(\n\t\t\t12345L\n\t\t);\n\n\t\twhen(\n\t\t\tthemeDisplay.getCompanyId()\n\t\t).thenReturn(\n\t\t\t12345L\n\t\t);\n\n\t\treturn liferayPortletRequest;\n\t}","commit_id":"ea0b3b7eed3f27184c7203e7d3ae1de44b30f9b5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testGetItemSelectorRendering() {\n\t\tsetUpItemSelectionCriterionHandlers();\n\n\t\tPortletResponse portletResponse = getMockPortletResponse();\n\n\t\tPortletRequest portletRequest = getMockPortletRequest(portletResponse);\n\n\t\tItemSelectorRendering itemSelectorRendering =\n\t\t\t_itemSelectorImpl.getItemSelectorRendering(\n\t\t\t\tportletRequest, portletResponse);\n\n\t\tAssert.assertEquals(\n\t\t\t\"itemSelectedEventName\",\n\t\t\titemSelectorRendering.getItemSelectedEventName());\n\n\t\tList<ItemSelectorViewRenderer> itemSelectorViewRenderers =\n\t\t\titemSelectorRendering.getItemSelectorViewRenderers();\n\n\t\tItemSelectorViewRenderer mediaItemSelectorViewRenderer =\n\t\t\titemSelectorViewRenderers.get(0);\n\n\t\tMediaItemSelectorCriterion mediaItemSelectorCriterion =\n\t\t\t(MediaItemSelectorCriterion)\n\t\t\t\tmediaItemSelectorViewRenderer.getItemSelectorCriterion();\n\n\t\tAssert.assertEquals(\n\t\t\t_mediaItemSelectorCriterion.getFileExtension(),\n\t\t\tmediaItemSelectorCriterion.getFileExtension());\n\t\tAssert.assertEquals(\n\t\t\t_mediaItemSelectorCriterion.getMaxSize(),\n\t\t\tmediaItemSelectorCriterion.getMaxSize());\n\t\tAssert.assertTrue(\n\t\t\t(ItemSelectorView<?>)\n\t\t\t\tmediaItemSelectorViewRenderer.getItemSelectorView()\n\t\t\t\t\tinstanceof MediaItemSelectorView);\n\n\t\tItemSelectorViewRenderer flickrItemSelectorViewRenderer =\n\t\t\titemSelectorViewRenderers.get(1);\n\n\t\tFlickrItemSelectorCriterion flickrItemSelectorCriterion =\n\t\t\t(FlickrItemSelectorCriterion)\n\t\t\t\tflickrItemSelectorViewRenderer.getItemSelectorCriterion();\n\n\t\tAssert.assertEquals(\n\t\t\t_flickrItemSelectorCriterion.getUser(),\n\t\t\tflickrItemSelectorCriterion.getUser());\n\t\tAssert.assertTrue(\n\t\t\t(ItemSelectorView<?>)\n\t\t\t\tflickrItemSelectorViewRenderer.getItemSelectorView()\n\t\t\t\t\tinstanceof FlickrItemSelectorView);\n\t\tAssert.assertEquals(2, itemSelectorViewRenderers.size());\n\t}","id":90630,"modified_method":"@Test\n\tpublic void testGetItemSelectorRendering() {\n\t\tsetUpItemSelectionCriterionHandlers();\n\n\t\tPortletResponse portletResponse = mock(PortletResponse.class);\n\n\t\tPortletRequest portletRequest = getMockPortletRequest(portletResponse);\n\n\t\tItemSelectorRendering itemSelectorRendering =\n\t\t\t_itemSelectorImpl.getItemSelectorRendering(\n\t\t\t\tportletRequest, portletResponse);\n\n\t\tAssert.assertEquals(\n\t\t\t\"itemSelectedEventName\",\n\t\t\titemSelectorRendering.getItemSelectedEventName());\n\n\t\tList<ItemSelectorViewRenderer> itemSelectorViewRenderers =\n\t\t\titemSelectorRendering.getItemSelectorViewRenderers();\n\n\t\tItemSelectorViewRenderer mediaItemSelectorViewRenderer =\n\t\t\titemSelectorViewRenderers.get(0);\n\n\t\tMediaItemSelectorCriterion mediaItemSelectorCriterion =\n\t\t\t(MediaItemSelectorCriterion)\n\t\t\t\tmediaItemSelectorViewRenderer.getItemSelectorCriterion();\n\n\t\tAssert.assertEquals(\n\t\t\t_mediaItemSelectorCriterion.getFileExtension(),\n\t\t\tmediaItemSelectorCriterion.getFileExtension());\n\t\tAssert.assertEquals(\n\t\t\t_mediaItemSelectorCriterion.getMaxSize(),\n\t\t\tmediaItemSelectorCriterion.getMaxSize());\n\t\tAssert.assertTrue(\n\t\t\t(ItemSelectorView<?>)\n\t\t\t\tmediaItemSelectorViewRenderer.getItemSelectorView()\n\t\t\t\t\tinstanceof MediaItemSelectorView);\n\n\t\tItemSelectorViewRenderer flickrItemSelectorViewRenderer =\n\t\t\titemSelectorViewRenderers.get(1);\n\n\t\tFlickrItemSelectorCriterion flickrItemSelectorCriterion =\n\t\t\t(FlickrItemSelectorCriterion)\n\t\t\t\tflickrItemSelectorViewRenderer.getItemSelectorCriterion();\n\n\t\tAssert.assertEquals(\n\t\t\t_flickrItemSelectorCriterion.getUser(),\n\t\t\tflickrItemSelectorCriterion.getUser());\n\t\tAssert.assertTrue(\n\t\t\t(ItemSelectorView<?>)\n\t\t\t\tflickrItemSelectorViewRenderer.getItemSelectorView()\n\t\t\t\t\tinstanceof FlickrItemSelectorView);\n\t\tAssert.assertEquals(2, itemSelectorViewRenderers.size());\n\t}","commit_id":"ea0b3b7eed3f27184c7203e7d3ae1de44b30f9b5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(15);\n\n\t\tsb.append(\"<div class=\\\"activity-body\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"date\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"date\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tFormat dateFormatDate = getFormatDateTime(\n\t\t\tserviceContext.getLocale(), serviceContext.getTimeZone());\n\n\t\tCalendarBooking calendarBooking =\n\t\t\tCalendarBookingLocalServiceUtil.fetchCalendarBooking(classPK);\n\n\t\tsb.append(dateFormatDate.format(calendarBooking.getStartTime()));\n\n\t\tsb.append(\"<\/div><div class=\\\"location\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"location\"));\n\t\tsb.append(\": <\/strong>\");\n\t\tsb.append(calendarBooking.getLocation());\n\t\tsb.append(\"<\/div><div class=\\\"description\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"description\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(className, classPK);\n\n\t\tsb.append(\n\t\t\tStringUtil.shorten(\n\t\t\t\tassetRenderer.getSummary(serviceContext.getLocale()), 200));\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":90631,"modified_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(15);\n\n\t\tsb.append(\"<div class=\\\"activity-body\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"date\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"date\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tFormat dateFormatDate = getFormatDateTime(\n\t\t\tserviceContext.getLocale(), serviceContext.getTimeZone());\n\n\t\tCalendarBooking calendarBooking =\n\t\t\tCalendarBookingLocalServiceUtil.fetchCalendarBooking(classPK);\n\n\t\tsb.append(dateFormatDate.format(calendarBooking.getStartTime()));\n\n\t\tsb.append(\"<\/div><div class=\\\"location\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"location\"));\n\t\tsb.append(\": <\/strong>\");\n\t\tsb.append(calendarBooking.getLocation());\n\t\tsb.append(\"<\/div><div class=\\\"description\\\"><strong>\");\n\t\tsb.append(serviceContext.translate(\"description\"));\n\t\tsb.append(\": <\/strong>\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(className, classPK);\n\n\t\tsb.append(\n\t\t\tStringUtil.shorten(\n\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\tassetRenderer.getSummary(\n\t\t\t\t\t\tserviceContext.getLocale()), 200)));\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"f02f1566604e367b9f46d7306f99b97c44bf6f60","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(11);\n\n\t\tsb.append(\"<div class=\\\"activity-body document\\\">\");\n\t\tsb.append(\"<span class=\\\"document-thumbnail\\\"><img src=\\\"\");\n\n\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(classPK);\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\tString thumbnailSrc = DLUtil.getThumbnailSrc(\n\t\t\tfileEntry, fileVersion, null, serviceContext.getThemeDisplay());\n\n\t\tsb.append(thumbnailSrc);\n\t\tsb.append(\"\\\"><\/span>\");\n\t\tsb.append(\"<div class=\\\"document-container\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"version\\\">\");\n\t\tsb.append(\n\t\t\tserviceContext.translate(\"version-x\", fileVersion.getVersion()));\n\t\tsb.append(\"<\/div><div class=\\\"document-content\\\">\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(className, classPK);\n\n\t\tsb.append(\n\t\t\tStringUtil.shorten(\n\t\t\t\tassetRenderer.getSummary(serviceContext.getLocale()), 200));\n\n\t\tsb.append(\"<\/div><\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":90632,"modified_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(11);\n\n\t\tsb.append(\"<div class=\\\"activity-body document\\\">\");\n\t\tsb.append(\"<span class=\\\"document-thumbnail\\\"><img src=\\\"\");\n\n\t\tFileEntry fileEntry = DLAppLocalServiceUtil.getFileEntry(classPK);\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\tString thumbnailSrc = DLUtil.getThumbnailSrc(\n\t\t\tfileEntry, fileVersion, null, serviceContext.getThemeDisplay());\n\n\t\tsb.append(thumbnailSrc);\n\t\tsb.append(\"\\\"><\/span>\");\n\t\tsb.append(\"<div class=\\\"document-container\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"version\\\">\");\n\t\tsb.append(\n\t\t\tserviceContext.translate(\"version-x\", fileVersion.getVersion()));\n\t\tsb.append(\"<\/div><div class=\\\"document-content\\\">\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(className, classPK);\n\n\t\tsb.append(\n\t\t\tStringUtil.shorten(\n\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\tassetRenderer.getSummary(\n\t\t\t\t\t\tserviceContext.getLocale()), 200)));\n\n\t\tsb.append(\"<\/div><\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"f02f1566604e367b9f46d7306f99b97c44bf6f60","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<div class=\\\"activity-body\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"wiki-page-content\\\">\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(className, classPK);\n\n\t\tsb.append(\n\t\t\tStringUtil.shorten(\n\t\t\t\tassetRenderer.getSummary(serviceContext.getLocale()), 200));\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","id":90633,"modified_method":"protected String getBody(\n\t\t\tString className, long classPK, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tStringBundler sb = new StringBundler(5);\n\n\t\tsb.append(\"<div class=\\\"activity-body\\\"><div class=\\\"title\\\">\");\n\t\tsb.append(getPageTitle(className, classPK, serviceContext));\n\t\tsb.append(\"<\/div><div class=\\\"wiki-page-content\\\">\");\n\n\t\tAssetRenderer assetRenderer = getAssetRenderer(className, classPK);\n\n\t\tsb.append(\n\t\t\tStringUtil.shorten(\n\t\t\t\tHtmlUtil.escape(\n\t\t\t\t\tassetRenderer.getSummary(\n\t\t\t\t\t\tserviceContext.getLocale()), 200)));\n\n\t\tsb.append(\"<\/div><\/div>\");\n\n\t\treturn sb.toString();\n\t}","commit_id":"f02f1566604e367b9f46d7306f99b97c44bf6f60","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public void drop(DropTargetDropEvent dtde) {\n    Point point = dtde.getLocation();\n    Object target = myTree.getPathForLocation(point.x, point.y).getLastPathComponent();\n    if (!(target instanceof SNodeTreeNode)) {\n      dtde.rejectDrop();\n      return;\n    }\n\n    SNode targetNode = ((SNodeTreeNode) target).getSNode();\n\n    Object source = null;\n    try {\n      source = dtde.getTransferable().getTransferData(myDataFlavor);\n    } catch (Throwable t) {\n      t.printStackTrace();\n    }\n    if (!(source instanceof SNode)) {\n      dtde.rejectDrop();\n      return;\n    }\n    SNode sourceNode = (SNode) source;\n\n    List<SNode> nodeToMove = getNodesToMove(targetNode, Collections.singletonList(sourceNode));\n    if (nodeToMove.isEmpty()) {\n      dtde.rejectDrop();\n      return;\n    }\n    Project project = (Project) DataManager.getInstance().getDataContext().getData(MPSDataKeys.PROJECT.getName());\n    JOptionPane.showConfirmDialog(WindowManager.getInstance().getFrame(project),\n      \"<html>Do you want to move node from virtual package '<b>\"\n        + getVirtualPackage(sourceNode)\n        + \"<\/b>' to '<b>\"\n        + getVirtualPackage(targetNode)\n        + \"<\/b>'?<\/html>\");\n    dtde.acceptDrop(dtde.getDropAction());\n  }","id":90634,"modified_method":"public void drop(DropTargetDropEvent dtde) {\n    Point point = dtde.getLocation();\n    TreePath treePath = myTree.getPathForLocation(point.x, point.y);\n    Object target = treePath.getLastPathComponent();\n    if (!(target instanceof MPSTreeNode)) {\n      dtde.rejectDrop();\n      return;\n    }\n    Object source = null;\n    try {\n      source = dtde.getTransferable().getTransferData(myDataFlavor);\n    } catch (Throwable t) {\n      t.printStackTrace();\n    }\n    if (!(source instanceof SNode)) {\n      dtde.rejectDrop();\n      return;\n    }\n    final SNode sourceNode = (SNode) source;\n\n    SModelDescriptor targetModel = getTargetModel(treePath);\n    final String targetPackage = getTargetVirtualPackage(treePath);\n    List<SNode> nodeToMove = getNodesToMove(targetModel, targetPackage, Collections.singletonList(sourceNode));\n    if (nodeToMove.isEmpty()) {\n      dtde.rejectDrop();\n      return;\n    }\n    Project project = (Project) DataManager.getInstance().getDataContext().getData(MPSDataKeys.PROJECT.getName());\n    int result = JOptionPane.showConfirmDialog(WindowManager.getInstance().getFrame(project),\n      \"<html>Do you want to move node from virtual package '<b>\"\n        + getVirtualPackage(sourceNode)\n        + \"<\/b>' to '<b>\"\n        + targetPackage\n        + \"<\/b>'?<\/html>\");\n    if (result == JOptionPane.YES_OPTION) {\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          sourceNode.setProperty(SModelTreeNode.PACK, targetPackage);\n          if (SNodeOperations.isInstanceOf(sourceNode, AbstractConceptDeclaration.concept)) {\n            for (SNode aspect : AbstractConceptDeclaration_Behavior.call_findAllAspects_7754459869734028917(sourceNode, GlobalScope.getInstance())) {\n              aspect.setProperty(SModelTreeNode.PACK, targetPackage);\n            }\n          }\n        }\n      });\n    }\n    dtde.acceptDrop(dtde.getDropAction());\n  }","commit_id":"afdc406b6dc1a2c3b72073861693f266bcf85f71","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<SNode> getNodesToMove(SNode targetNode, List<SNode> sourceNodes) {\n    if (targetNode == null) return Collections.emptyList();\n    String virtualPackege = getVirtualPackage(targetNode);\n    SModelDescriptor contextModel = getModelDescriptor(targetNode);\n    if (contextModel == null) return Collections.emptyList();\n    List<SNode> result = new ArrayList<SNode>();\n    for (final SNode node : sourceNodes) {\n      if (virtualPackege.equals(getVirtualPackage(node))) continue;\n      SModelDescriptor md = getModelDescriptor(node);\n      if (EqualUtil.equals(md, contextModel)) {\n        result.add(node);\n      }\n    }\n    return result;\n  }","id":90635,"modified_method":"private List<SNode> getNodesToMove(SModelDescriptor targetModel, String virtualPackage, List<SNode> sourceNodes) {\n    if (targetModel == null) return Collections.emptyList();\n    List<SNode> result = new ArrayList<SNode>();\n    for (final SNode node : sourceNodes) {\n      if (virtualPackage.equals(getVirtualPackage(node))) continue;\n      SModelDescriptor sourceModel = getModelDescriptor(node);\n      if (EqualUtil.equals(sourceModel, targetModel)) {\n        result.add(node);\n      }\n    }\n    return result;\n  }","commit_id":"afdc406b6dc1a2c3b72073861693f266bcf85f71","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * Displays an confirmation dialog with some option buttons given by <code>optionType<\/code>.\n     * It is always on top even if there are other open windows like detached dialogs,\n     * relation editors, history browsers and the like.\n     *\n     * Set <code>optionType<\/code> to {@see JOptionPane#YES_NO_OPTION} for a dialog with a YES and\n     * a NO button.\n\n     * Set <code>optionType<\/code> to {@see JOptionPane#YES_NO_CANCEL_OPTION} for a dialog with a YES,\n     * a NO and a CANCEL button\n     *\n     * Replies true, if the selected option is equal to <code>trueOption<\/code>, otherwise false.\n     * Replies true, if the dialog is not displayed because the respective preference option\n     * <code>preferenceKey<\/code> is set to false.\n     *\n     * @param preferenceKey the preference key\n     * @param parent  the parent component\n     * @param message  the message\n     * @param title the title\n     * @param optionType  the option type\n     * @param messageType the message type\n     * @param options a list of options\n     * @param defaultOption the default option\n     *\n     *\n     * @return the index of the selected option. {@see JOptionPane#CLOSED_OPTION} if the dialog was closed.\n     * {@see ConditionalOptionPaneUtil#DIALOG_DISABLED_OPTION} if the dialog is disabled.\n     *\n     */\n    static public int showOptionDialog(String preferenceKey, Component parent, Object message, String title, int optionType, int messageType, Object [] options, Object defaultOption) throws HeadlessException {\n        if (!getDialogShowingEnabled(preferenceKey))\n            return DIALOG_DISABLED_OPTION;\n        MessagePanel pnl = new MessagePanel(false, message);\n        int ret = JOptionPane.showOptionDialog(parent, pnl, title, optionType, messageType, null,options,defaultOption);\n\n        if(!pnl.getDialogShowingEnabled())\n            setDialogShowingEnabled(preferenceKey, false);\n        return ret;\n    }","id":90636,"modified_method":"/**\n     * Displays an confirmation dialog with some option buttons given by <code>optionType<\/code>.\n     * It is always on top even if there are other open windows like detached dialogs,\n     * relation editors, history browsers and the like.\n     *\n     * Set <code>optionType<\/code> to {@see JOptionPane#YES_NO_OPTION} for a dialog with a YES and\n     * a NO button.\n\n     * Set <code>optionType<\/code> to {@see JOptionPane#YES_NO_CANCEL_OPTION} for a dialog with a YES,\n     * a NO and a CANCEL button\n     *\n     * Returns one of the constants JOptionPane.YES_OPTION, JOptionPane.NO_OPTION,\n     * JOptionPane.CANCEL_OPTION or JOptionPane.CLOSED_OPTION depending on the action chosen by\n     * the user.\n     *\n     * @param preferenceKey the preference key\n     * @param parent  the parent component\n     * @param message  the message\n     * @param title the title\n     * @param optionType  the option type\n     * @param messageType the message type\n     * @param options a list of options\n     * @param defaultOption the default option\n     *\n     * @return the option selected by user. {@see JOptionPane#CLOSED_OPTION} if the dialog was closed.\n     */\n    static public int showOptionDialog(String preferenceKey, Component parent, Object message, String title, int optionType, int messageType, Object [] options, Object defaultOption) throws HeadlessException {\n        int ret = getDialogReturnValue(preferenceKey);\n        if (!getDialogShowingEnabled(preferenceKey) && ((ret == JOptionPane.YES_OPTION) || (ret == JOptionPane.NO_OPTION)))\n            return ret;\n        MessagePanel pnl = new MessagePanel(false, message);\n        ret = JOptionPane.showOptionDialog(parent, pnl, title, optionType, messageType, null, options, defaultOption);\n\n        if (((ret == JOptionPane.YES_OPTION) || (ret == JOptionPane.NO_OPTION)) && !pnl.getDialogShowingEnabled()) {\n            setDialogShowingEnabled(preferenceKey, false);\n            setDialogReturnValue(preferenceKey, ret);\n        }\n        return ret;\n    }","commit_id":"6a0600a22db0ae3976b6c8cc20b3d6751a95eb1b","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Displays an confirmation dialog with some option buttons given by <code>optionType<\/code>.\n     * It is always on top even if there are other open windows like detached dialogs,\n     * relation editors, history browsers and the like.\n     *\n     * Set <code>optionType<\/code> to {@see JOptionPane#YES_NO_OPTION} for a dialog with a YES and\n     * a NO button.\n\n     * Set <code>optionType<\/code> to {@see JOptionPane#YES_NO_CANCEL_OPTION} for a dialog with a YES,\n     * a NO and a CANCEL button\n     *\n     * Replies true, if the selected option is equal to <code>trueOption<\/code>, otherwise false.\n     * Replies true, if the dialog is not displayed because the respective preference option\n     * <code>preferenceKey<\/code> is set to false.\n     *\n     * @param preferenceKey the preference key\n     * @param parent  the parent component\n     * @param message  the message\n     * @param title the title\n     * @param optionType  the option type\n     * @param messageType the message type\n     * @param trueOption  if this option is selected the method replies true\n     *\n     *\n     * @return true, if the selected option is equal to <code>trueOption<\/code>, otherwise false.\n     *\n     * @see JOptionPane#INFORMATION_MESSAGE\n     * @see JOptionPane#WARNING_MESSAGE\n     * @see JOptionPane#ERROR_MESSAGE\n     */\n    static public boolean showConfirmationDialog(String preferenceKey, Component parent, Object message, String title, int optionType, int messageType, int trueOption) throws HeadlessException {\n        if (!getDialogShowingEnabled(preferenceKey) && (getDialogReturnValue(preferenceKey) >= 0))\n            return getDialogReturnValue(preferenceKey) == trueOption;\n        MessagePanel pnl = new MessagePanel(false, message);\n        int ret = JOptionPane.showConfirmDialog(parent, pnl, title, optionType, messageType);\n        if ((ret >= 0) && !pnl.getDialogShowingEnabled()) {\n            setDialogShowingEnabled(preferenceKey, false);\n            setDialogReturnValue(preferenceKey, ret);\n        }\n        return ret == trueOption;\n    }","id":90637,"modified_method":"/**\n     * Displays a confirmation dialog with some option buttons given by <code>optionType<\/code>.\n     * It is always on top even if there are other open windows like detached dialogs,\n     * relation editors, history browsers and the like.\n     *\n     * Set <code>optionType<\/code> to {@see JOptionPane#YES_NO_OPTION} for a dialog with a YES and\n     * a NO button.\n\n     * Set <code>optionType<\/code> to {@see JOptionPane#YES_NO_CANCEL_OPTION} for a dialog with a YES,\n     * a NO and a CANCEL button\n     *\n     * Replies true, if the selected option is equal to <code>trueOption<\/code>, otherwise false.\n     * Replies true, if the dialog is not displayed because the respective preference option\n     * <code>preferenceKey<\/code> is set to false and the user has previously chosen\n     * <code>trueOption<\/code>.\n     *\n     * @param preferenceKey the preference key\n     * @param parent  the parent component\n     * @param message  the message\n     * @param title the title\n     * @param optionType  the option type\n     * @param messageType the message type\n     * @param trueOption  if this option is selected the method replies true\n     *\n     *\n     * @return true, if the selected option is equal to <code>trueOption<\/code>, otherwise false.\n     *\n     * @see JOptionPane#INFORMATION_MESSAGE\n     * @see JOptionPane#WARNING_MESSAGE\n     * @see JOptionPane#ERROR_MESSAGE\n     */\n    static public boolean showConfirmationDialog(String preferenceKey, Component parent, Object message, String title, int optionType, int messageType, int trueOption) throws HeadlessException {\n        int ret = getDialogReturnValue(preferenceKey);\n        if (!getDialogShowingEnabled(preferenceKey) && ((ret == JOptionPane.YES_OPTION) || (ret == JOptionPane.NO_OPTION)))\n            return ret == trueOption;\n        MessagePanel pnl = new MessagePanel(false, message);\n        ret = JOptionPane.showConfirmDialog(parent, pnl, title, optionType, messageType);\n        if (((ret == JOptionPane.YES_OPTION) || (ret == JOptionPane.NO_OPTION)) && !pnl.getDialogShowingEnabled()) {\n            setDialogShowingEnabled(preferenceKey, false);\n            setDialogReturnValue(preferenceKey, ret);\n        }\n        return ret == trueOption;\n    }","commit_id":"6a0600a22db0ae3976b6c8cc20b3d6751a95eb1b","url":"https://github.com/openstreetmap/josm"},{"original_method":"public static void main(String args[]) throws Exception {\n\t\tProject project = new Project();\n\t\tBugCollection origCollection = new SortedBugCollection();\n\t\tint argCount = 0;\n\t\tif (argCount == args.length)\n\t\t\torigCollection.readXML(System.in, project);\n\t\telse\n\t\t\torigCollection.readXML(args[argCount], project);\n\t\tProjectStats stats = origCollection.getProjectStats();\n\t\tprintRow(\"kind\", \"name\", \"density/KNCSS\", \"bugs\", \"NCSS\");\n\t\tprintRow(\"project\", origCollection.getCurrentAppVersion().getReleaseName(), \n\t\t\t\t(10000 * stats.getTotalBugs() / stats.getCodeSize())/10.0d, stats.getTotalBugs(),\n\t\t\t\tstats.getCodeSize());\n\t\tfor (PackageStats p : stats.getPackageStats()) if (p.getTotalBugs() > 4) {\n\t\t\t\n\t\t\t\tprintRow(\"package\", p.getPackageName(), (10000 * p.getTotalBugs()\n\t\t\t\t\t/ p.size())/10.0d, p.getTotalBugs(), p.size());\n\t\t\tfor (ClassStats c : p.getClassStats()) if (c.getTotalBugs() > 4) {\n\t\t\t\tprintRow(\"class\", c.getName(), 1000 * c.getTotalBugs()\n\t\t\t\t\t\t/ c.size(), c.getTotalBugs(), c.size());\n\t\t\t}\n\t\t}\n\n\t}","id":90638,"modified_method":"public static void main(String args[]) throws Exception {\n\t\tProject project = new Project();\n\t\tBugCollection origCollection = new SortedBugCollection();\n\t\tint argCount = 0;\n\t\tif (argCount == args.length)\n\t\t\torigCollection.readXML(System.in, project);\n\t\telse\n\t\t\torigCollection.readXML(args[argCount], project);\n\t\tProjectStats stats = origCollection.getProjectStats();\n\t\tprintRow(\"kind\", \"name\", \"density/KNCSS\", \"bugs\", \"NCSS\");\n\t\tdouble projectDensity = density(stats.getTotalBugs(),  stats.getCodeSize());\n\t\tprintRow(\"project\", origCollection.getCurrentAppVersion().getReleaseName(), \n\t\t\t\tprojectDensity, stats.getTotalBugs(),\n\t\t\t\tstats.getCodeSize());\n\t\tfor (PackageStats p : stats.getPackageStats()) if (p.getTotalBugs() > 4) {\n\t\t\t\n\t\t\t\n\t\t\t\tdouble packageDensity = density( p.getTotalBugs(),p.size());\n\t\t\t\tif (Double.isNaN(packageDensity) || packageDensity < projectDensity) continue;\n\t\t\t\tprintRow(\"package\", p.getPackageName(), \n\t\t\t\t\t\tpackageDensity, p.getTotalBugs(), p.size());\n\t\t\tfor (ClassStats c : p.getClassStats()) if (c.getTotalBugs() > 4) {\n\t\t\t\tdouble density = density( c.getTotalBugs(), c.size());\n\t\t\t\tif (Double.isNaN(density) || density < packageDensity) continue;\n\t\t\t\tprintRow(\"class\", c.getName(), \n\t\t\t\t\t\tdensity, c.getTotalBugs(), c.size());\n\t\t\t}\n\t\t}\n\n\t}","commit_id":"4083f61855c443988da94c51344a88acf2fed612","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"public void testChoiceWithoutEnd() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\", \\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\", \\\"seda:aggregate\\\")\";\n        String expectedDSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".end()\";\n\n        assertEquals(expectedDSL, render(DSL));\n    }","id":90639,"modified_method":"public void testChoiceWithoutEnd() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\", \\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\", \\\"seda:aggregate\\\")\";\n        \n        //TODO check this result\n        String expectedDSL = \"from(\\\"direct:start\\\").split(body()).choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".end()\";\n\n        assertEquals(expectedDSL, render(DSL));\n    }","commit_id":"035e2c79a6105986f65a5f6709c9e86640cca387","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        ExpressionNode expNode = (ExpressionNode)processor;\n        ExpressionDefinition expression = expNode.getExpression();\n\n        buffer.append(\".\").append(expNode.getShortName());\n        if (expNode instanceof DelayDefinition) {\n            String delay = expression.getExpressionValue().toString();\n            if (!delay.contains(\"(\")) {\n                String delayTime = expression.getExpressionValue().toString();\n                buffer.append(\"(\").append(delayTime).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof FilterDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            } else if (expression.getLanguage() != null) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof IdempotentConsumerDefinition) {\n        } else if (expNode instanceof LoopDefinition) {\n            if (expression instanceof ConstantExpression) {\n                buffer.append(\"(\").append(expression.getExpression()).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof RecipientListDefinition) {\n            buffer.append(\"(\");\n            ExpressionRenderer.render(buffer, expression);\n            buffer.append(\")\");\n        } else if (expNode instanceof SetBodyDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.renderConstant(buffer, expression);\n            }\n        } else if (expNode instanceof SetHeaderDefinition) {\n            SetHeaderDefinition set = (SetHeaderDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getHeaderName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SetOutHeaderDefinition) {\n            buffer.append(\"(\\\"unspported expressions in SetOutHeaderDefinition\\\")\");\n        } else if (expNode instanceof SetPropertyDefinition) {\n            SetPropertyDefinition set = (SetPropertyDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getPropertyName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SplitDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (!expValue.contains(\"(\")) {\n                buffer.append(\"().\").append(expValue).append(\"()\");\n            } else {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof TransformDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\") || expValue.startsWith(\"prepend\") || expValue.startsWith(\"to\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expValue.startsWith(\"xpath\")) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"(constant(\\\"\").append(expression.getExpressionValue().toString()).append(\"\\\"))\");\n            }\n        } else if (expNode instanceof WhenDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            }\n            if (expression instanceof ExpressionClause) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, (ExpressionClause)expression);\n            }\n        }\n    }","id":90640,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        ExpressionNode expNode = (ExpressionNode)processor;\n        ExpressionDefinition expression = expNode.getExpression();\n\n        buffer.append(\".\").append(expNode.getShortName());\n        if (expNode instanceof DelayDefinition) {\n            String delay = expression.getExpressionValue().toString();\n            if (!delay.contains(\"(\")) {\n                String delayTime = expression.getExpressionValue().toString();\n                buffer.append(\"(\").append(delayTime).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof FilterDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            } else if (expression.getLanguage() != null) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof IdempotentConsumerDefinition) {\n        } else if (expNode instanceof LoopDefinition) {\n            if (expression instanceof ConstantExpression) {\n                buffer.append(\"(\").append(expression.getExpression()).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof RecipientListDefinition) {\n            buffer.append(\"(\");\n            ExpressionRenderer.render(buffer, expression);\n            buffer.append(\")\");\n        } else if (expNode instanceof SetBodyDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.renderConstant(buffer, expression);\n            }\n        } else if (expNode instanceof SetHeaderDefinition) {\n            SetHeaderDefinition set = (SetHeaderDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getHeaderName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SetOutHeaderDefinition) {\n            buffer.append(\"(\\\"unspported expressions in SetOutHeaderDefinition\\\")\");\n        } else if (expNode instanceof SetPropertyDefinition) {\n            SetPropertyDefinition set = (SetPropertyDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getPropertyName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SplitDefinition) {\n            if (expression.getExpressionValue() != null) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expression.getExpressionType() != null) {\n                buffer.append(\"().\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n\n            SplitDefinition split = (SplitDefinition)expNode;\n            if (split.isStreaming()) {\n                buffer.append(\".streaming()\");\n            }\n        } else if (expNode instanceof TransformDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\") || expValue.startsWith(\"prepend\") || expValue.startsWith(\"to\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expValue.startsWith(\"xpath\")) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"(constant(\\\"\").append(expression.getExpressionValue().toString()).append(\"\\\"))\");\n            }\n        } else if (expNode instanceof WhenDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            }\n            if (expression instanceof ExpressionClause) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, (ExpressionClause)expression);\n            }\n        }\n    }","commit_id":"035e2c79a6105986f65a5f6709c9e86640cca387","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Render a simple expression: header(foo) -> header(\"foo\")\n     * tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n     * \n     * @param buffer\n     * @param expression\n     */\n    public static void renderExpression(StringBuilder buffer, String expression) {\n        if (!expression.contains(\",\")) {\n            // header(foo) -> header(\"foo\")\n            expression = expression.replaceAll(\"\\\\(\", \"(\\\"\").replaceAll(\"\\\\)\", \"\\\")\");\n            buffer.append(expression);\n        } else if (expression.startsWith(\"tokenize\")) {\n            String words[] = expression.split(\"\\\\(\");\n            if (words.length == 2) {\n                // tokenize(body, ,) -> body().tokenize(\",\")\n                String tokenize = words[1].substring(words[1].indexOf(\" \") + 1, words[1].lastIndexOf(\")\"));\n                words[1] = words[1].substring(0, words[1].indexOf(\",\"));\n\n                buffer.append(words[1]).append(\"().\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            } else if (words.length == 3) {\n                // tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n                String symbolName = words[2].substring(0, words[2].indexOf(\")\"));\n                String tokenize = words[2].substring(words[2].indexOf(\" \") + 1, words[2].lastIndexOf(\")\"));\n\n                buffer.append(words[1]).append(\"(\\\"\").append(symbolName).append(\"\\\").\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            }\n        } else if (expression.startsWith(\"append\")) {\n            // append(body, World!) -> body().append(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"append(\\\"\").append(words[2]).append(\"\\\")\");\n        } else if (expression.startsWith(\"prepend\")) {\n            // prepend(body, World!) -> body().prepend(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"prepend(\\\"\").append(words[2]).append(\"\\\")\");\n        }\n    }","id":90641,"modified_method":"/**\n     * Render a simple expression: header(foo) -> header(\"foo\")\n     * tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n     * \n     * @param buffer\n     * @param expression\n     */\n    public static void renderExpression(StringBuilder buffer, String expression) {\n        if (!expression.contains(\",\")) {\n            if (expression.contains(\"(\")) {\n                // header(foo) -> header(\"foo\")\n                expression = expression.replaceAll(\"\\\\(\", \"(\\\"\").replaceAll(\"\\\\)\", \"\\\")\");\n                buffer.append(expression);\n            } else {\n                // body -> body()\n                buffer.append(expression).append(\"()\");\n            }\n        } else if (expression.startsWith(\"tokenize\")) {\n            String words[] = expression.split(\"\\\\(\");\n            if (words.length == 2) {\n                // tokenize(body, ,) -> body().tokenize(\",\")\n                String tokenize = words[1].substring(words[1].indexOf(\" \") + 1, words[1].lastIndexOf(\")\"));\n                words[1] = words[1].substring(0, words[1].indexOf(\",\"));\n\n                if (!words[1].contains(\"[\")) {\n                    // body\n                    buffer.append(words[1]).append(\"()\");\n                } else {\n                    // bodyAs[clazz]\n                    String word = words[1].substring(0, words[1].indexOf(\"As\"));\n                    String clazz = words[1].substring(words[1].lastIndexOf(\".\") + 1, words[1].length() - 1);\n                    buffer.append(word).append(\"(\").append(clazz).append(\".class)\");\n                }\n\n                buffer.append(\".\").append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            } else if (words.length == 3) {\n                // tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n                String symbolName = words[2].substring(0, words[2].indexOf(\")\"));\n                String tokenize = words[2].substring(words[2].indexOf(\" \") + 1, words[2].lastIndexOf(\")\"));\n\n                buffer.append(words[1]).append(\"(\\\"\").append(symbolName).append(\"\\\").\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            }\n        } else if (expression.startsWith(\"append\")) {\n            // append(body, World!) -> body().append(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"append(\\\"\").append(words[2]).append(\"\\\")\");\n        } else if (expression.startsWith(\"prepend\")) {\n            // prepend(body, World!) -> body().prepend(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"prepend(\\\"\").append(words[2]).append(\"\\\")\");\n        }\n    }","commit_id":"035e2c79a6105986f65a5f6709c9e86640cca387","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * render a RouteDefinition\n     * \n     * @throws IOException\n     */\n    public static void renderRoute(StringBuilder buffer, RouteDefinition route) {\n        List<FromDefinition> inputs = route.getInputs();\n        List<ProcessorDefinition> outputs = route.getOutputs();\n\n        // render the error handler\n        if (!(route.getErrorHandlerBuilder() instanceof ErrorHandlerBuilderRef)) {\n            if (route.getErrorHandlerBuilder() instanceof DeadLetterChannelBuilder) {\n                DeadLetterChannelBuilder deadLetter = (DeadLetterChannelBuilder)route.getErrorHandlerBuilder();\n                buffer.append(\"errorHandler(deadLetterChannel(\\\"\").append(deadLetter.getDeadLetterUri()).append(\"\\\")\");\n                buffer.append(\".maximumRedeliveries(\").append(deadLetter.getRedeliveryPolicy().getMaximumRedeliveries()).append(\")\");\n                buffer.append(\".redeliverDelay(\").append(deadLetter.getRedeliveryPolicy().getRedeliverDelay()).append(\")\");\n                buffer.append(\".handled(\").append(deadLetter.getHandledPolicy().toString()).append(\")\");\n                buffer.append(\");\");\n            }\n        }\n\n        // render the global dsl not started with from, like global\n        // onCompletion, onException, intercept\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == null) {\n                renderProcessor(buffer, processor);\n                buffer.append(\";\");\n            }\n        }\n\n        // render the inputs of the router\n        buffer.append(\"from(\");\n        for (FromDefinition input : inputs) {\n            buffer.append(\"\\\"\").append(input.getUri()).append(\"\\\"\");\n            if (input != inputs.get(inputs.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render the outputs of the router\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == route) {\n                renderProcessor(buffer, processor);\n            }\n        }\n    }","id":90642,"modified_method":"/**\n     * render a RouteDefinition\n     * \n     * @throws IOException\n     */\n    public static void renderRoute(StringBuilder buffer, RouteDefinition route) {\n        List<FromDefinition> inputs = route.getInputs();\n        List<ProcessorDefinition> outputs = route.getOutputs();\n\n        // render the error handler\n        if (!(route.getErrorHandlerBuilder() instanceof ErrorHandlerBuilderRef)) {\n            if (route.getErrorHandlerBuilder() instanceof DeadLetterChannelBuilder) {\n                DeadLetterChannelBuilder deadLetter = (DeadLetterChannelBuilder)route.getErrorHandlerBuilder();\n                buffer.append(\"errorHandler(deadLetterChannel(\\\"\").append(deadLetter.getDeadLetterUri()).append(\"\\\")\");\n                buffer.append(\".maximumRedeliveries(\").append(deadLetter.getRedeliveryPolicy().getMaximumRedeliveries()).append(\")\");\n                buffer.append(\".redeliverDelay(\").append(deadLetter.getRedeliveryPolicy().getRedeliverDelay()).append(\")\");\n                buffer.append(\".handled(\").append(deadLetter.getHandledPolicy().toString()).append(\")\");\n                buffer.append(\");\");\n            }\n        }\n\n        // render the global dsl not started with from, like global\n        // onCompletion, onException, intercept\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == null && !(processor instanceof SendDefinition)) {\n                renderProcessor(buffer, processor);\n                buffer.append(\";\");\n            }\n        }\n\n        // render the inputs of the router\n        buffer.append(\"from(\");\n        for (FromDefinition input : inputs) {\n            buffer.append(\"\\\"\").append(input.getUri()).append(\"\\\"\");\n            if (input != inputs.get(inputs.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render some route configurations\n        if (route.isStreamCache() != null && route.isStreamCache()) {\n            buffer.append(\".streamCaching()\");\n        }\n\n        // render the outputs of the router\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == route || processor instanceof SendDefinition) {\n                renderProcessor(buffer, processor);\n            }\n        }\n    }","commit_id":"035e2c79a6105986f65a5f6709c9e86640cca387","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * render a ProcessorDefiniton\n     */\n    private static void renderProcessor(StringBuilder buffer, ProcessorDefinition processor) {\n        if (processor instanceof AggregateDefinition) {\n            AggregateDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ChoiceDefinition) {\n            ChoiceDefinition choice = (ChoiceDefinition)processor;\n            buffer.append(\".\").append(choice.getShortName()).append(\"()\");\n            for (WhenDefinition when : choice.getWhenClauses()) {\n                renderProcessor(buffer, when);\n            }\n            OtherwiseDefinition other = choice.getOtherwise();\n            if (other != null) {\n                renderProcessor(buffer, other);\n            }\n            buffer.append(\".end()\");\n            return;\n        } else if (processor instanceof ConvertBodyDefinition) {\n            ConvertBodyDefinition convertBody = (ConvertBodyDefinition)processor;\n            buffer.append(\".\").append(convertBody.getShortName()).append(\"(\");\n            if (convertBody.getType().equals(\"[B\")) {\n                buffer.append(\"byte[].class\");\n            } else {\n                buffer.append(convertBody.getType()).append(\".class\");\n            }\n            if (convertBody.getCharset() != null) {\n                buffer.append(\", \\\"\").append(convertBody.getCharset()).append(\"\\\"\");\n            }\n            buffer.append(\")\");\n        } else if (processor instanceof ExpressionNode) {\n            ExpressionNodeRenderer.render(buffer, processor);\n        } else if (processor instanceof LoadBalanceDefinition) {\n            LoadBalanceDefinition loadB = (LoadBalanceDefinition)processor;\n            // buffer.append(\".\").append(output.getShortName()).append(\"()\");\n            buffer.append(\".\").append(\"loadBalance\").append(\"()\");\n\n            LoadBalancer lb = loadB.getLoadBalancerType().getLoadBalancer(null);\n            if (lb instanceof FailOverLoadBalancer) {\n                buffer.append(\".failover(\");\n                List<Class> exceptions = ((FailOverLoadBalancer)lb).getExceptions();\n                for (Class excep : exceptions) {\n                    buffer.append(excep.getSimpleName()).append(\".class\");\n                    if (excep != exceptions.get(exceptions.size() - 1)) {\n                        buffer.append(\", \");\n                    }\n                }\n                buffer.append(\")\");\n            } else if (lb instanceof RandomLoadBalancer) {\n                buffer.append(\".random()\");\n            } else if (lb instanceof RoundRobinLoadBalancer) {\n                buffer.append(\".roundRobin()\");\n            } else if (lb instanceof StickyLoadBalancer) {\n                buffer.append(\".sticky()\");\n            } else if (lb instanceof TopicLoadBalancer) {\n                buffer.append(\".topic()\");\n            }\n\n            List<ProcessorDefinition> branches = loadB.getOutputs();\n            for (ProcessorDefinition branch : branches) {\n                renderProcessor(buffer, branch);\n            }\n            return;\n        } else if (processor instanceof OnCompletionDefinition) {\n            OnCompletionDefinitionRenderer.render(buffer, processor);\n            return;\n        } else if (processor instanceof OnExceptionDefinition) {\n            OnExceptionDefinitionRenderer.render(buffer, processor);\n            return;\n        } else if (processor instanceof OutputDefinition) {\n            OutputDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ResequenceDefinition) {\n            ResequenceDefinition resequence = (ResequenceDefinition)processor;\n            buffer.append(\".\").append(processor.getShortName()).append(\"(\");\n\n            List<Expression> exps = resequence.getExpressionList();\n            for (Expression exp : exps) {\n                buffer.append(exp.toString()).append(\"()\");\n                if (exp != exps.get(exps.size() - 1)) {\n                    buffer.append(\", \");\n                }\n            }\n            buffer.append(\")\");\n        } else if (processor instanceof RoutingSlipDefinition) {\n            RoutingSlipDefinition routingSlip = (RoutingSlipDefinition)processor;\n            buffer.append(\".\").append(routingSlip.getShortName()).append(\"(\\\"\").append(routingSlip.getHeaderName()).append(\"\\\", \\\"\").append(routingSlip.getUriDelimiter())\n                .append(\"\\\")\");\n        } else if (processor instanceof SendDefinition) {\n            SendDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ThrottleDefinition) {\n            ThrottleDefinition throttle = (ThrottleDefinition)processor;\n            buffer.append(\".\").append(throttle.getShortName()).append(\"(\").append(throttle.getMaximumRequestsPerPeriod()).append(\")\");\n            if (throttle.getTimePeriodMillis() != 1000) {\n                buffer.append(\".timePeriodMillis(\").append(throttle.getTimePeriodMillis()).append(\")\");\n            }\n        } else {\n            buffer.append(\".\").append(processor.getShortName()).append(\"()\");\n        }\n\n        List<ProcessorDefinition> outputs = processor.getOutputs();\n\n        for (ProcessorDefinition nextProcessor : outputs) {\n            renderProcessor(buffer, nextProcessor);\n        }\n    }","id":90643,"modified_method":"/**\n     * render a ProcessorDefiniton\n     */\n    private static void renderProcessor(StringBuilder buffer, ProcessorDefinition processor) {\n        if (processor instanceof AggregateDefinition) {\n            AggregateDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ChoiceDefinition) {\n            ChoiceDefinition choice = (ChoiceDefinition)processor;\n            buffer.append(\".\").append(choice.getShortName()).append(\"()\");\n            for (WhenDefinition when : choice.getWhenClauses()) {\n                renderProcessor(buffer, when);\n            }\n            OtherwiseDefinition other = choice.getOtherwise();\n            if (other != null) {\n                renderProcessor(buffer, other);\n            }\n            buffer.append(\".end()\");\n            return;\n        } else if (processor instanceof ConvertBodyDefinition) {\n            ConvertBodyDefinition convertBody = (ConvertBodyDefinition)processor;\n            buffer.append(\".\").append(convertBody.getShortName()).append(\"(\");\n            if (convertBody.getType().equals(\"[B\")) {\n                buffer.append(\"byte[].class\");\n            } else {\n                buffer.append(convertBody.getType()).append(\".class\");\n            }\n            if (convertBody.getCharset() != null) {\n                buffer.append(\", \\\"\").append(convertBody.getCharset()).append(\"\\\"\");\n            }\n            buffer.append(\")\");\n        } else if (processor instanceof ExpressionNode) {\n            ExpressionNodeRenderer.render(buffer, processor);\n        } else if (processor instanceof LoadBalanceDefinition) {\n            LoadBalanceDefinition loadB = (LoadBalanceDefinition)processor;\n            // buffer.append(\".\").append(output.getShortName()).append(\"()\");\n            buffer.append(\".\").append(\"loadBalance\").append(\"()\");\n\n            LoadBalancer lb = loadB.getLoadBalancerType().getLoadBalancer(null);\n            if (lb instanceof FailOverLoadBalancer) {\n                buffer.append(\".failover(\");\n                List<Class> exceptions = ((FailOverLoadBalancer)lb).getExceptions();\n                for (Class excep : exceptions) {\n                    buffer.append(excep.getSimpleName()).append(\".class\");\n                    if (excep != exceptions.get(exceptions.size() - 1)) {\n                        buffer.append(\", \");\n                    }\n                }\n                buffer.append(\")\");\n            } else if (lb instanceof RandomLoadBalancer) {\n                buffer.append(\".random()\");\n            } else if (lb instanceof RoundRobinLoadBalancer) {\n                buffer.append(\".roundRobin()\");\n            } else if (lb instanceof StickyLoadBalancer) {\n                buffer.append(\".sticky(\");\n                ExpressionRenderer.renderExpression(buffer, ((StickyLoadBalancer)lb).getCorrelationExpression().toString());\n                buffer.append(\")\");\n            } else if (lb instanceof TopicLoadBalancer) {\n                buffer.append(\".topic()\");\n            }\n\n            List<ProcessorDefinition> branches = loadB.getOutputs();\n            for (ProcessorDefinition branch : branches) {\n                renderProcessor(buffer, branch);\n            }\n            return;\n        } else if (processor instanceof OnCompletionDefinition) {\n            OnCompletionDefinitionRenderer.render(buffer, processor);\n            return;\n        } else if (processor instanceof OnExceptionDefinition) {\n            OnExceptionDefinitionRenderer.render(buffer, processor);\n            return;\n        } else if (processor instanceof OutputDefinition) {\n            OutputDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ResequenceDefinition) {\n            ResequenceDefinition resequence = (ResequenceDefinition)processor;\n            buffer.append(\".\").append(processor.getShortName()).append(\"(\");\n\n            List<Expression> exps = resequence.getExpressionList();\n            for (Expression exp : exps) {\n                ExpressionRenderer.renderExpression(buffer, exp.toString());\n                if (exp != exps.get(exps.size() - 1)) {\n                    buffer.append(\", \");\n                }\n            }\n            buffer.append(\")\");\n\n            if (resequence.getStreamConfig() != null) {\n                // TODO improve stream() support\n                buffer.append(\".stream()\");\n            }\n\n        } else if (processor instanceof RoutingSlipDefinition) {\n            RoutingSlipDefinition routingSlip = (RoutingSlipDefinition)processor;\n            buffer.append(\".\").append(routingSlip.getShortName()).append(\"(\\\"\").append(routingSlip.getHeaderName()).append(\"\\\", \\\"\").append(routingSlip.getUriDelimiter())\n                .append(\"\\\")\");\n        } else if (processor instanceof SendDefinition) {\n            SendDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ThrottleDefinition) {\n            ThrottleDefinition throttle = (ThrottleDefinition)processor;\n            buffer.append(\".\").append(throttle.getShortName()).append(\"(\").append(throttle.getMaximumRequestsPerPeriod()).append(\")\");\n            if (throttle.getTimePeriodMillis() != 1000) {\n                buffer.append(\".timePeriodMillis(\").append(throttle.getTimePeriodMillis()).append(\")\");\n            }\n        } else {\n            buffer.append(\".\").append(processor.getShortName()).append(\"()\");\n        }\n\n        List<ProcessorDefinition> outputs = processor.getOutputs();\n\n        for (ProcessorDefinition nextProcessor : outputs) {\n            renderProcessor(buffer, nextProcessor);\n        }\n    }","commit_id":"035e2c79a6105986f65a5f6709c9e86640cca387","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String getShortName() {\n        return \"interceptEndpoint\";\n    }","id":90644,"modified_method":"@Override\n    public String getShortName() {\n        return \"interceptSendToEndpoint\";\n    }","commit_id":"035e2c79a6105986f65a5f6709c9e86640cca387","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        // if not a global onCompletion, add a period\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n\n        OnExceptionDefinition onException = (OnExceptionDefinition)processor;\n        buffer.append(processor.getShortName()).append(\"(\");\n        List<Class> exceptions = onException.getExceptionClasses();\n        for (Class excep : exceptions) {\n            buffer.append(excep.getSimpleName()).append(\".class\");\n            if (excep != exceptions.get(exceptions.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        List<ProcessorDefinition> branches = onException.getOutputs();\n        for (ProcessorDefinition branch : branches) {\n            SendDefinitionRenderer.render(buffer, branch);\n        }\n    }","id":90645,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        // if not a global onCompletion, add a period\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n\n        OnExceptionDefinition onException = (OnExceptionDefinition)processor;\n        buffer.append(processor.getShortName()).append(\"(\");\n        List<Class> exceptions = onException.getExceptionClasses();\n        for (Class excep : exceptions) {\n            buffer.append(excep.getSimpleName()).append(\".class\");\n            if (excep != exceptions.get(exceptions.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render handled() dsl\n        if (onException.getHandledPolicy() != null) {\n            String handled = onException.getHandledPolicy().toString();\n            buffer.append(\".handled(\").append(handled).append(\")\");\n        }\n\n        List<ProcessorDefinition> branches = onException.getOutputs();\n        for (ProcessorDefinition branch : branches) {\n            SendDefinitionRenderer.render(buffer, branch);\n        }\n    }","commit_id":"035e2c79a6105986f65a5f6709c9e86640cca387","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        OutputDefinition out = (OutputDefinition)processor;\n\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n        buffer.append(out.getShortName());\n\n        if (out instanceof AOPDefinition) {\n            buffer.append(\"()\");\n            AOPDefinition aop = (AOPDefinition)out;\n\n            if (aop.getBeforeUri() != null && aop.getAfterUri() != null) {\n                buffer.append(\".around(\\\"\").append(aop.getBeforeUri());\n                buffer.append(\"\\\", \\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getBeforeUri() != null) {\n                buffer.append(\".before(\\\"\").append(aop.getBeforeUri()).append(\"\\\")\");\n            } else if (aop.getAfterUri() != null) {\n                buffer.append(\".after(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getAfterFinallyUri() != null) {\n                buffer.append(\".afterFinally(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            }\n\n        } else if (out instanceof BeanDefinition) {\n\n        } else if (out instanceof EnrichDefinition) {\n            String enrich = out.toString();\n            String resourceUri = enrich.substring(enrich.indexOf('[') + 1, enrich.indexOf(' '));\n            buffer.append(\"(\\\"\").append(resourceUri).append(\"\\\")\");\n        } else if (out instanceof FinallyDefinition) {\n            \n        } else if (out instanceof InterceptDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof InterceptSendToEndpointDefinition) {\n\n        } else if (out instanceof MarshalDefinition) {\n            DataFormatDefinition dataFormat = ((MarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        } else if (out instanceof MulticastDefinition) {\n\n        } else if (out instanceof OtherwiseDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof PipelineDefinition) {\n\n        } else if (out instanceof PolicyDefinition) {\n\n        } else if (out instanceof PollEnrichDefinition) {\n\n        } else if (out instanceof ProcessDefinition) {\n\n        } else if (out instanceof RemoveHeaderDefinition) {\n            RemoveHeaderDefinition remove = (RemoveHeaderDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getHeaderName()).append(\"\\\")\");\n        } else if (out instanceof RemovePropertyDefinition) {\n            RemovePropertyDefinition remove = (RemovePropertyDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getPropertyName()).append(\"\\\")\");\n        } else if (out instanceof SetExchangePatternDefinition) {\n\n        } else if (out instanceof SortDefinition) {\n            SortDefinition sort = (SortDefinition)out;\n            buffer.append(\"(\");\n            ExpressionRenderer.renderExpression(buffer, sort.getExpression().toString());\n            buffer.append(\")\");\n        } else if (out instanceof StopDefinition) {\n\n        } else if (out instanceof ThreadsDefinition) {\n\n        } else if (out instanceof TransactedDefinition) {\n\n        } else if (out instanceof TryDefinition) {\n\n        } else if (out instanceof UnmarshalDefinition) {\n            DataFormatDefinition dataFormat = ((UnmarshalDefinition)out).getDataFormatType();\n            Class clazz = dataFormat.getClass();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        }\n    }","id":90646,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        OutputDefinition out = (OutputDefinition)processor;\n\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n        buffer.append(out.getShortName());\n\n        if (out instanceof AOPDefinition) {\n            buffer.append(\"()\");\n            AOPDefinition aop = (AOPDefinition)out;\n\n            if (aop.getBeforeUri() != null && aop.getAfterUri() != null) {\n                buffer.append(\".around(\\\"\").append(aop.getBeforeUri());\n                buffer.append(\"\\\", \\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getBeforeUri() != null) {\n                buffer.append(\".before(\\\"\").append(aop.getBeforeUri()).append(\"\\\")\");\n            } else if (aop.getAfterUri() != null) {\n                buffer.append(\".after(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getAfterFinallyUri() != null) {\n                buffer.append(\".afterFinally(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            }\n\n        } else if (out instanceof BeanDefinition) {\n\n        } else if (out instanceof EnrichDefinition) {\n            String enrich = out.toString();\n            String resourceUri = enrich.substring(enrich.indexOf('[') + 1, enrich.indexOf(' '));\n            buffer.append(\"(\\\"\").append(resourceUri).append(\"\\\")\");\n        } else if (out instanceof FinallyDefinition) {\n\n        } else if (out instanceof InterceptDefinition) {\n            buffer.append(\"()\");\n            if (out instanceof InterceptFromDefinition) {\n\n            } else {\n\n            }\n        } else if (out instanceof InterceptSendToEndpointDefinition) {\n            InterceptSendToEndpointDefinition interceptSend = (InterceptSendToEndpointDefinition)out;\n            buffer.append(\"(\\\"\").append(interceptSend.getUri()).append(\"\\\")\");\n            if (interceptSend.getSkipSendToOriginalEndpoint()) {\n                buffer.append(\".skipSendToOriginalEndpoint()\");\n            }\n        } else if (out instanceof MarshalDefinition) {\n            DataFormatDefinition dataFormat = ((MarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        } else if (out instanceof MulticastDefinition) {\n\n        } else if (out instanceof OtherwiseDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof PipelineDefinition) {\n\n        } else if (out instanceof PolicyDefinition) {\n\n        } else if (out instanceof PollEnrichDefinition) {\n\n        } else if (out instanceof ProcessDefinition) {\n\n        } else if (out instanceof RemoveHeaderDefinition) {\n            RemoveHeaderDefinition remove = (RemoveHeaderDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getHeaderName()).append(\"\\\")\");\n        } else if (out instanceof RemovePropertyDefinition) {\n            RemovePropertyDefinition remove = (RemovePropertyDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getPropertyName()).append(\"\\\")\");\n        } else if (out instanceof SetExchangePatternDefinition) {\n\n        } else if (out instanceof SortDefinition) {\n            SortDefinition sort = (SortDefinition)out;\n            buffer.append(\"(\");\n            ExpressionRenderer.renderExpression(buffer, sort.getExpression().toString());\n            buffer.append(\")\");\n        } else if (out instanceof StopDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof ThreadsDefinition) {\n\n        } else if (out instanceof TransactedDefinition) {\n\n        } else if (out instanceof TryDefinition) {\n\n        } else if (out instanceof UnmarshalDefinition) {\n            DataFormatDefinition dataFormat = ((UnmarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        }\n    }","commit_id":"035e2c79a6105986f65a5f6709c9e86640cca387","url":"https://github.com/apache/camel"},{"original_method":"public void testChoiceWithoutEnd() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\", \\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\", \\\"seda:aggregate\\\")\";\n        \n        //TODO check this result\n        String expectedDSL = \"from(\\\"direct:start\\\").split(body()).choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".end()\";\n\n        assertEquals(expectedDSL, render(DSL));\n    }","id":90647,"modified_method":"public void testChoiceWithoutEnd() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\", \\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\", \\\"seda:aggregate\\\")\";\n        String expectedDSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".end()\";\n\n        assertEquals(expectedDSL, render(DSL));\n    }","commit_id":"ed83cf57aa6744dfd4f034e10ee6e6ce5601be03","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        ExpressionNode expNode = (ExpressionNode)processor;\n        ExpressionDefinition expression = expNode.getExpression();\n\n        buffer.append(\".\").append(expNode.getShortName());\n        if (expNode instanceof DelayDefinition) {\n            String delay = expression.getExpressionValue().toString();\n            if (!delay.contains(\"(\")) {\n                String delayTime = expression.getExpressionValue().toString();\n                buffer.append(\"(\").append(delayTime).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof FilterDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            } else if (expression.getLanguage() != null) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof IdempotentConsumerDefinition) {\n        } else if (expNode instanceof LoopDefinition) {\n            if (expression instanceof ConstantExpression) {\n                buffer.append(\"(\").append(expression.getExpression()).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof RecipientListDefinition) {\n            buffer.append(\"(\");\n            ExpressionRenderer.render(buffer, expression);\n            buffer.append(\")\");\n        } else if (expNode instanceof SetBodyDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.renderConstant(buffer, expression);\n            }\n        } else if (expNode instanceof SetHeaderDefinition) {\n            SetHeaderDefinition set = (SetHeaderDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getHeaderName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SetOutHeaderDefinition) {\n            buffer.append(\"(\\\"unspported expressions in SetOutHeaderDefinition\\\")\");\n        } else if (expNode instanceof SetPropertyDefinition) {\n            SetPropertyDefinition set = (SetPropertyDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getPropertyName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SplitDefinition) {\n            if (expression.getExpressionValue() != null) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expression.getExpressionType() != null) {\n                buffer.append(\"().\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n\n            SplitDefinition split = (SplitDefinition)expNode;\n            if (split.isStreaming()) {\n                buffer.append(\".streaming()\");\n            }\n        } else if (expNode instanceof TransformDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\") || expValue.startsWith(\"prepend\") || expValue.startsWith(\"to\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expValue.startsWith(\"xpath\")) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"(constant(\\\"\").append(expression.getExpressionValue().toString()).append(\"\\\"))\");\n            }\n        } else if (expNode instanceof WhenDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            }\n            if (expression instanceof ExpressionClause) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, (ExpressionClause)expression);\n            }\n        }\n    }","id":90648,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        ExpressionNode expNode = (ExpressionNode)processor;\n        ExpressionDefinition expression = expNode.getExpression();\n\n        buffer.append(\".\").append(expNode.getShortName());\n        if (expNode instanceof DelayDefinition) {\n            String delay = expression.getExpressionValue().toString();\n            if (!delay.contains(\"(\")) {\n                String delayTime = expression.getExpressionValue().toString();\n                buffer.append(\"(\").append(delayTime).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof FilterDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            } else if (expression.getLanguage() != null) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof IdempotentConsumerDefinition) {\n        } else if (expNode instanceof LoopDefinition) {\n            if (expression instanceof ConstantExpression) {\n                buffer.append(\"(\").append(expression.getExpression()).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof RecipientListDefinition) {\n            buffer.append(\"(\");\n            ExpressionRenderer.render(buffer, expression);\n            buffer.append(\")\");\n        } else if (expNode instanceof SetBodyDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.renderConstant(buffer, expression);\n            }\n        } else if (expNode instanceof SetHeaderDefinition) {\n            SetHeaderDefinition set = (SetHeaderDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getHeaderName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SetOutHeaderDefinition) {\n            buffer.append(\"(\\\"unspported expressions in SetOutHeaderDefinition\\\")\");\n        } else if (expNode instanceof SetPropertyDefinition) {\n            SetPropertyDefinition set = (SetPropertyDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getPropertyName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SplitDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (!expValue.contains(\"(\")) {\n                buffer.append(\"().\").append(expValue).append(\"()\");\n            } else {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof TransformDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\") || expValue.startsWith(\"prepend\") || expValue.startsWith(\"to\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expValue.startsWith(\"xpath\")) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"(constant(\\\"\").append(expression.getExpressionValue().toString()).append(\"\\\"))\");\n            }\n        } else if (expNode instanceof WhenDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            }\n            if (expression instanceof ExpressionClause) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, (ExpressionClause)expression);\n            }\n        }\n    }","commit_id":"ed83cf57aa6744dfd4f034e10ee6e6ce5601be03","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Render a simple expression: header(foo) -> header(\"foo\")\n     * tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n     * \n     * @param buffer\n     * @param expression\n     */\n    public static void renderExpression(StringBuilder buffer, String expression) {\n        if (!expression.contains(\",\")) {\n            if (expression.contains(\"(\")) {\n                // header(foo) -> header(\"foo\")\n                expression = expression.replaceAll(\"\\\\(\", \"(\\\"\").replaceAll(\"\\\\)\", \"\\\")\");\n                buffer.append(expression);\n            } else {\n                // body -> body()\n                buffer.append(expression).append(\"()\");\n            }\n        } else if (expression.startsWith(\"tokenize\")) {\n            String words[] = expression.split(\"\\\\(\");\n            if (words.length == 2) {\n                // tokenize(body, ,) -> body().tokenize(\",\")\n                String tokenize = words[1].substring(words[1].indexOf(\" \") + 1, words[1].lastIndexOf(\")\"));\n                words[1] = words[1].substring(0, words[1].indexOf(\",\"));\n\n                if (!words[1].contains(\"[\")) {\n                    // body\n                    buffer.append(words[1]).append(\"()\");\n                } else {\n                    // bodyAs[clazz]\n                    String word = words[1].substring(0, words[1].indexOf(\"As\"));\n                    String clazz = words[1].substring(words[1].lastIndexOf(\".\") + 1, words[1].length() - 1);\n                    buffer.append(word).append(\"(\").append(clazz).append(\".class)\");\n                }\n\n                buffer.append(\".\").append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            } else if (words.length == 3) {\n                // tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n                String symbolName = words[2].substring(0, words[2].indexOf(\")\"));\n                String tokenize = words[2].substring(words[2].indexOf(\" \") + 1, words[2].lastIndexOf(\")\"));\n\n                buffer.append(words[1]).append(\"(\\\"\").append(symbolName).append(\"\\\").\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            }\n        } else if (expression.startsWith(\"append\")) {\n            // append(body, World!) -> body().append(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"append(\\\"\").append(words[2]).append(\"\\\")\");\n        } else if (expression.startsWith(\"prepend\")) {\n            // prepend(body, World!) -> body().prepend(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"prepend(\\\"\").append(words[2]).append(\"\\\")\");\n        }\n    }","id":90649,"modified_method":"/**\n     * Render a simple expression: header(foo) -> header(\"foo\")\n     * tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n     * \n     * @param buffer\n     * @param expression\n     */\n    public static void renderExpression(StringBuilder buffer, String expression) {\n        if (!expression.contains(\",\")) {\n            // header(foo) -> header(\"foo\")\n            expression = expression.replaceAll(\"\\\\(\", \"(\\\"\").replaceAll(\"\\\\)\", \"\\\")\");\n            buffer.append(expression);\n        } else if (expression.startsWith(\"tokenize\")) {\n            String words[] = expression.split(\"\\\\(\");\n            if (words.length == 2) {\n                // tokenize(body, ,) -> body().tokenize(\",\")\n                String tokenize = words[1].substring(words[1].indexOf(\" \") + 1, words[1].lastIndexOf(\")\"));\n                words[1] = words[1].substring(0, words[1].indexOf(\",\"));\n\n                buffer.append(words[1]).append(\"().\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            } else if (words.length == 3) {\n                // tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n                String symbolName = words[2].substring(0, words[2].indexOf(\")\"));\n                String tokenize = words[2].substring(words[2].indexOf(\" \") + 1, words[2].lastIndexOf(\")\"));\n\n                buffer.append(words[1]).append(\"(\\\"\").append(symbolName).append(\"\\\").\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            }\n        } else if (expression.startsWith(\"append\")) {\n            // append(body, World!) -> body().append(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"append(\\\"\").append(words[2]).append(\"\\\")\");\n        } else if (expression.startsWith(\"prepend\")) {\n            // prepend(body, World!) -> body().prepend(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"prepend(\\\"\").append(words[2]).append(\"\\\")\");\n        }\n    }","commit_id":"ed83cf57aa6744dfd4f034e10ee6e6ce5601be03","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * render a RouteDefinition\n     * \n     * @throws IOException\n     */\n    public static void renderRoute(StringBuilder buffer, RouteDefinition route) {\n        List<FromDefinition> inputs = route.getInputs();\n        List<ProcessorDefinition> outputs = route.getOutputs();\n\n        // render the error handler\n        if (!(route.getErrorHandlerBuilder() instanceof ErrorHandlerBuilderRef)) {\n            if (route.getErrorHandlerBuilder() instanceof DeadLetterChannelBuilder) {\n                DeadLetterChannelBuilder deadLetter = (DeadLetterChannelBuilder)route.getErrorHandlerBuilder();\n                buffer.append(\"errorHandler(deadLetterChannel(\\\"\").append(deadLetter.getDeadLetterUri()).append(\"\\\")\");\n                buffer.append(\".maximumRedeliveries(\").append(deadLetter.getRedeliveryPolicy().getMaximumRedeliveries()).append(\")\");\n                buffer.append(\".redeliverDelay(\").append(deadLetter.getRedeliveryPolicy().getRedeliverDelay()).append(\")\");\n                buffer.append(\".handled(\").append(deadLetter.getHandledPolicy().toString()).append(\")\");\n                buffer.append(\");\");\n            }\n        }\n\n        // render the global dsl not started with from, like global\n        // onCompletion, onException, intercept\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == null && !(processor instanceof SendDefinition)) {\n                renderProcessor(buffer, processor);\n                buffer.append(\";\");\n            }\n        }\n\n        // render the inputs of the router\n        buffer.append(\"from(\");\n        for (FromDefinition input : inputs) {\n            buffer.append(\"\\\"\").append(input.getUri()).append(\"\\\"\");\n            if (input != inputs.get(inputs.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render some route configurations\n        if (route.isStreamCache() != null && route.isStreamCache()) {\n            buffer.append(\".streamCaching()\");\n        }\n\n        // render the outputs of the router\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == route || processor instanceof SendDefinition) {\n                renderProcessor(buffer, processor);\n            }\n        }\n    }","id":90650,"modified_method":"/**\n     * render a RouteDefinition\n     * \n     * @throws IOException\n     */\n    public static void renderRoute(StringBuilder buffer, RouteDefinition route) {\n        List<FromDefinition> inputs = route.getInputs();\n        List<ProcessorDefinition> outputs = route.getOutputs();\n\n        // render the error handler\n        if (!(route.getErrorHandlerBuilder() instanceof ErrorHandlerBuilderRef)) {\n            if (route.getErrorHandlerBuilder() instanceof DeadLetterChannelBuilder) {\n                DeadLetterChannelBuilder deadLetter = (DeadLetterChannelBuilder)route.getErrorHandlerBuilder();\n                buffer.append(\"errorHandler(deadLetterChannel(\\\"\").append(deadLetter.getDeadLetterUri()).append(\"\\\")\");\n                buffer.append(\".maximumRedeliveries(\").append(deadLetter.getRedeliveryPolicy().getMaximumRedeliveries()).append(\")\");\n                buffer.append(\".redeliverDelay(\").append(deadLetter.getRedeliveryPolicy().getRedeliverDelay()).append(\")\");\n                buffer.append(\".handled(\").append(deadLetter.getHandledPolicy().toString()).append(\")\");\n                buffer.append(\");\");\n            }\n        }\n\n        // render the global dsl not started with from, like global\n        // onCompletion, onException, intercept\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == null) {\n                renderProcessor(buffer, processor);\n                buffer.append(\";\");\n            }\n        }\n\n        // render the inputs of the router\n        buffer.append(\"from(\");\n        for (FromDefinition input : inputs) {\n            buffer.append(\"\\\"\").append(input.getUri()).append(\"\\\"\");\n            if (input != inputs.get(inputs.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render the outputs of the router\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == route) {\n                renderProcessor(buffer, processor);\n            }\n        }\n    }","commit_id":"ed83cf57aa6744dfd4f034e10ee6e6ce5601be03","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * render a ProcessorDefiniton\n     */\n    private static void renderProcessor(StringBuilder buffer, ProcessorDefinition processor) {\n        if (processor instanceof AggregateDefinition) {\n            AggregateDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ChoiceDefinition) {\n            ChoiceDefinition choice = (ChoiceDefinition)processor;\n            buffer.append(\".\").append(choice.getShortName()).append(\"()\");\n            for (WhenDefinition when : choice.getWhenClauses()) {\n                renderProcessor(buffer, when);\n            }\n            OtherwiseDefinition other = choice.getOtherwise();\n            if (other != null) {\n                renderProcessor(buffer, other);\n            }\n            buffer.append(\".end()\");\n            return;\n        } else if (processor instanceof ConvertBodyDefinition) {\n            ConvertBodyDefinition convertBody = (ConvertBodyDefinition)processor;\n            buffer.append(\".\").append(convertBody.getShortName()).append(\"(\");\n            if (convertBody.getType().equals(\"[B\")) {\n                buffer.append(\"byte[].class\");\n            } else {\n                buffer.append(convertBody.getType()).append(\".class\");\n            }\n            if (convertBody.getCharset() != null) {\n                buffer.append(\", \\\"\").append(convertBody.getCharset()).append(\"\\\"\");\n            }\n            buffer.append(\")\");\n        } else if (processor instanceof ExpressionNode) {\n            ExpressionNodeRenderer.render(buffer, processor);\n        } else if (processor instanceof LoadBalanceDefinition) {\n            LoadBalanceDefinition loadB = (LoadBalanceDefinition)processor;\n            // buffer.append(\".\").append(output.getShortName()).append(\"()\");\n            buffer.append(\".\").append(\"loadBalance\").append(\"()\");\n\n            LoadBalancer lb = loadB.getLoadBalancerType().getLoadBalancer(null);\n            if (lb instanceof FailOverLoadBalancer) {\n                buffer.append(\".failover(\");\n                List<Class> exceptions = ((FailOverLoadBalancer)lb).getExceptions();\n                for (Class excep : exceptions) {\n                    buffer.append(excep.getSimpleName()).append(\".class\");\n                    if (excep != exceptions.get(exceptions.size() - 1)) {\n                        buffer.append(\", \");\n                    }\n                }\n                buffer.append(\")\");\n            } else if (lb instanceof RandomLoadBalancer) {\n                buffer.append(\".random()\");\n            } else if (lb instanceof RoundRobinLoadBalancer) {\n                buffer.append(\".roundRobin()\");\n            } else if (lb instanceof StickyLoadBalancer) {\n                buffer.append(\".sticky(\");\n                ExpressionRenderer.renderExpression(buffer, ((StickyLoadBalancer)lb).getCorrelationExpression().toString());\n                buffer.append(\")\");\n            } else if (lb instanceof TopicLoadBalancer) {\n                buffer.append(\".topic()\");\n            }\n\n            List<ProcessorDefinition> branches = loadB.getOutputs();\n            for (ProcessorDefinition branch : branches) {\n                renderProcessor(buffer, branch);\n            }\n            return;\n        } else if (processor instanceof OnCompletionDefinition) {\n            OnCompletionDefinitionRenderer.render(buffer, processor);\n            return;\n        } else if (processor instanceof OnExceptionDefinition) {\n            OnExceptionDefinitionRenderer.render(buffer, processor);\n            return;\n        } else if (processor instanceof OutputDefinition) {\n            OutputDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ResequenceDefinition) {\n            ResequenceDefinition resequence = (ResequenceDefinition)processor;\n            buffer.append(\".\").append(processor.getShortName()).append(\"(\");\n\n            List<Expression> exps = resequence.getExpressionList();\n            for (Expression exp : exps) {\n                ExpressionRenderer.renderExpression(buffer, exp.toString());\n                if (exp != exps.get(exps.size() - 1)) {\n                    buffer.append(\", \");\n                }\n            }\n            buffer.append(\")\");\n\n            if (resequence.getStreamConfig() != null) {\n                // TODO improve stream() support\n                buffer.append(\".stream()\");\n            }\n\n        } else if (processor instanceof RoutingSlipDefinition) {\n            RoutingSlipDefinition routingSlip = (RoutingSlipDefinition)processor;\n            buffer.append(\".\").append(routingSlip.getShortName()).append(\"(\\\"\").append(routingSlip.getHeaderName()).append(\"\\\", \\\"\").append(routingSlip.getUriDelimiter())\n                .append(\"\\\")\");\n        } else if (processor instanceof SendDefinition) {\n            SendDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ThrottleDefinition) {\n            ThrottleDefinition throttle = (ThrottleDefinition)processor;\n            buffer.append(\".\").append(throttle.getShortName()).append(\"(\").append(throttle.getMaximumRequestsPerPeriod()).append(\")\");\n            if (throttle.getTimePeriodMillis() != 1000) {\n                buffer.append(\".timePeriodMillis(\").append(throttle.getTimePeriodMillis()).append(\")\");\n            }\n        } else {\n            buffer.append(\".\").append(processor.getShortName()).append(\"()\");\n        }\n\n        List<ProcessorDefinition> outputs = processor.getOutputs();\n\n        for (ProcessorDefinition nextProcessor : outputs) {\n            renderProcessor(buffer, nextProcessor);\n        }\n    }","id":90651,"modified_method":"/**\n     * render a ProcessorDefiniton\n     */\n    private static void renderProcessor(StringBuilder buffer, ProcessorDefinition processor) {\n        if (processor instanceof AggregateDefinition) {\n            AggregateDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ChoiceDefinition) {\n            ChoiceDefinition choice = (ChoiceDefinition)processor;\n            buffer.append(\".\").append(choice.getShortName()).append(\"()\");\n            for (WhenDefinition when : choice.getWhenClauses()) {\n                renderProcessor(buffer, when);\n            }\n            OtherwiseDefinition other = choice.getOtherwise();\n            if (other != null) {\n                renderProcessor(buffer, other);\n            }\n            buffer.append(\".end()\");\n            return;\n        } else if (processor instanceof ConvertBodyDefinition) {\n            ConvertBodyDefinition convertBody = (ConvertBodyDefinition)processor;\n            buffer.append(\".\").append(convertBody.getShortName()).append(\"(\");\n            if (convertBody.getType().equals(\"[B\")) {\n                buffer.append(\"byte[].class\");\n            } else {\n                buffer.append(convertBody.getType()).append(\".class\");\n            }\n            if (convertBody.getCharset() != null) {\n                buffer.append(\", \\\"\").append(convertBody.getCharset()).append(\"\\\"\");\n            }\n            buffer.append(\")\");\n        } else if (processor instanceof ExpressionNode) {\n            ExpressionNodeRenderer.render(buffer, processor);\n        } else if (processor instanceof LoadBalanceDefinition) {\n            LoadBalanceDefinition loadB = (LoadBalanceDefinition)processor;\n            // buffer.append(\".\").append(output.getShortName()).append(\"()\");\n            buffer.append(\".\").append(\"loadBalance\").append(\"()\");\n\n            LoadBalancer lb = loadB.getLoadBalancerType().getLoadBalancer(null);\n            if (lb instanceof FailOverLoadBalancer) {\n                buffer.append(\".failover(\");\n                List<Class> exceptions = ((FailOverLoadBalancer)lb).getExceptions();\n                for (Class excep : exceptions) {\n                    buffer.append(excep.getSimpleName()).append(\".class\");\n                    if (excep != exceptions.get(exceptions.size() - 1)) {\n                        buffer.append(\", \");\n                    }\n                }\n                buffer.append(\")\");\n            } else if (lb instanceof RandomLoadBalancer) {\n                buffer.append(\".random()\");\n            } else if (lb instanceof RoundRobinLoadBalancer) {\n                buffer.append(\".roundRobin()\");\n            } else if (lb instanceof StickyLoadBalancer) {\n                buffer.append(\".sticky()\");\n            } else if (lb instanceof TopicLoadBalancer) {\n                buffer.append(\".topic()\");\n            }\n\n            List<ProcessorDefinition> branches = loadB.getOutputs();\n            for (ProcessorDefinition branch : branches) {\n                renderProcessor(buffer, branch);\n            }\n            return;\n        } else if (processor instanceof OnCompletionDefinition) {\n            OnCompletionDefinitionRenderer.render(buffer, processor);\n            return;\n        } else if (processor instanceof OnExceptionDefinition) {\n            OnExceptionDefinitionRenderer.render(buffer, processor);\n            return;\n        } else if (processor instanceof OutputDefinition) {\n            OutputDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ResequenceDefinition) {\n            ResequenceDefinition resequence = (ResequenceDefinition)processor;\n            buffer.append(\".\").append(processor.getShortName()).append(\"(\");\n\n            List<Expression> exps = resequence.getExpressionList();\n            for (Expression exp : exps) {\n                buffer.append(exp.toString()).append(\"()\");\n                if (exp != exps.get(exps.size() - 1)) {\n                    buffer.append(\", \");\n                }\n            }\n            buffer.append(\")\");\n        } else if (processor instanceof RoutingSlipDefinition) {\n            RoutingSlipDefinition routingSlip = (RoutingSlipDefinition)processor;\n            buffer.append(\".\").append(routingSlip.getShortName()).append(\"(\\\"\").append(routingSlip.getHeaderName()).append(\"\\\", \\\"\").append(routingSlip.getUriDelimiter())\n                .append(\"\\\")\");\n        } else if (processor instanceof SendDefinition) {\n            SendDefinitionRenderer.render(buffer, processor);\n        } else if (processor instanceof ThrottleDefinition) {\n            ThrottleDefinition throttle = (ThrottleDefinition)processor;\n            buffer.append(\".\").append(throttle.getShortName()).append(\"(\").append(throttle.getMaximumRequestsPerPeriod()).append(\")\");\n            if (throttle.getTimePeriodMillis() != 1000) {\n                buffer.append(\".timePeriodMillis(\").append(throttle.getTimePeriodMillis()).append(\")\");\n            }\n        } else {\n            buffer.append(\".\").append(processor.getShortName()).append(\"()\");\n        }\n\n        List<ProcessorDefinition> outputs = processor.getOutputs();\n\n        for (ProcessorDefinition nextProcessor : outputs) {\n            renderProcessor(buffer, nextProcessor);\n        }\n    }","commit_id":"ed83cf57aa6744dfd4f034e10ee6e6ce5601be03","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String getShortName() {\n        return \"interceptSendToEndpoint\";\n    }","id":90652,"modified_method":"@Override\n    public String getShortName() {\n        return \"interceptEndpoint\";\n    }","commit_id":"ed83cf57aa6744dfd4f034e10ee6e6ce5601be03","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        // if not a global onCompletion, add a period\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n\n        OnExceptionDefinition onException = (OnExceptionDefinition)processor;\n        buffer.append(processor.getShortName()).append(\"(\");\n        List<Class> exceptions = onException.getExceptionClasses();\n        for (Class excep : exceptions) {\n            buffer.append(excep.getSimpleName()).append(\".class\");\n            if (excep != exceptions.get(exceptions.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render handled() dsl\n        if (onException.getHandledPolicy() != null) {\n            String handled = onException.getHandledPolicy().toString();\n            buffer.append(\".handled(\").append(handled).append(\")\");\n        }\n\n        List<ProcessorDefinition> branches = onException.getOutputs();\n        for (ProcessorDefinition branch : branches) {\n            SendDefinitionRenderer.render(buffer, branch);\n        }\n    }","id":90653,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        // if not a global onCompletion, add a period\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n\n        OnExceptionDefinition onException = (OnExceptionDefinition)processor;\n        buffer.append(processor.getShortName()).append(\"(\");\n        List<Class> exceptions = onException.getExceptionClasses();\n        for (Class excep : exceptions) {\n            buffer.append(excep.getSimpleName()).append(\".class\");\n            if (excep != exceptions.get(exceptions.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        List<ProcessorDefinition> branches = onException.getOutputs();\n        for (ProcessorDefinition branch : branches) {\n            SendDefinitionRenderer.render(buffer, branch);\n        }\n    }","commit_id":"ed83cf57aa6744dfd4f034e10ee6e6ce5601be03","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        OutputDefinition out = (OutputDefinition)processor;\n\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n        buffer.append(out.getShortName());\n\n        if (out instanceof AOPDefinition) {\n            buffer.append(\"()\");\n            AOPDefinition aop = (AOPDefinition)out;\n\n            if (aop.getBeforeUri() != null && aop.getAfterUri() != null) {\n                buffer.append(\".around(\\\"\").append(aop.getBeforeUri());\n                buffer.append(\"\\\", \\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getBeforeUri() != null) {\n                buffer.append(\".before(\\\"\").append(aop.getBeforeUri()).append(\"\\\")\");\n            } else if (aop.getAfterUri() != null) {\n                buffer.append(\".after(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getAfterFinallyUri() != null) {\n                buffer.append(\".afterFinally(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            }\n\n        } else if (out instanceof BeanDefinition) {\n\n        } else if (out instanceof EnrichDefinition) {\n            String enrich = out.toString();\n            String resourceUri = enrich.substring(enrich.indexOf('[') + 1, enrich.indexOf(' '));\n            buffer.append(\"(\\\"\").append(resourceUri).append(\"\\\")\");\n        } else if (out instanceof FinallyDefinition) {\n\n        } else if (out instanceof InterceptDefinition) {\n            buffer.append(\"()\");\n            if (out instanceof InterceptFromDefinition) {\n\n            } else {\n\n            }\n        } else if (out instanceof InterceptSendToEndpointDefinition) {\n            InterceptSendToEndpointDefinition interceptSend = (InterceptSendToEndpointDefinition)out;\n            buffer.append(\"(\\\"\").append(interceptSend.getUri()).append(\"\\\")\");\n            if (interceptSend.getSkipSendToOriginalEndpoint()) {\n                buffer.append(\".skipSendToOriginalEndpoint()\");\n            }\n        } else if (out instanceof MarshalDefinition) {\n            DataFormatDefinition dataFormat = ((MarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        } else if (out instanceof MulticastDefinition) {\n\n        } else if (out instanceof OtherwiseDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof PipelineDefinition) {\n\n        } else if (out instanceof PolicyDefinition) {\n\n        } else if (out instanceof PollEnrichDefinition) {\n\n        } else if (out instanceof ProcessDefinition) {\n\n        } else if (out instanceof RemoveHeaderDefinition) {\n            RemoveHeaderDefinition remove = (RemoveHeaderDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getHeaderName()).append(\"\\\")\");\n        } else if (out instanceof RemovePropertyDefinition) {\n            RemovePropertyDefinition remove = (RemovePropertyDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getPropertyName()).append(\"\\\")\");\n        } else if (out instanceof SetExchangePatternDefinition) {\n\n        } else if (out instanceof SortDefinition) {\n            SortDefinition sort = (SortDefinition)out;\n            buffer.append(\"(\");\n            ExpressionRenderer.renderExpression(buffer, sort.getExpression().toString());\n            buffer.append(\")\");\n        } else if (out instanceof StopDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof ThreadsDefinition) {\n\n        } else if (out instanceof TransactedDefinition) {\n\n        } else if (out instanceof TryDefinition) {\n\n        } else if (out instanceof UnmarshalDefinition) {\n            DataFormatDefinition dataFormat = ((UnmarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        }\n    }","id":90654,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        OutputDefinition out = (OutputDefinition)processor;\n\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n        buffer.append(out.getShortName());\n\n        if (out instanceof AOPDefinition) {\n            buffer.append(\"()\");\n            AOPDefinition aop = (AOPDefinition)out;\n\n            if (aop.getBeforeUri() != null && aop.getAfterUri() != null) {\n                buffer.append(\".around(\\\"\").append(aop.getBeforeUri());\n                buffer.append(\"\\\", \\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getBeforeUri() != null) {\n                buffer.append(\".before(\\\"\").append(aop.getBeforeUri()).append(\"\\\")\");\n            } else if (aop.getAfterUri() != null) {\n                buffer.append(\".after(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getAfterFinallyUri() != null) {\n                buffer.append(\".afterFinally(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            }\n\n        } else if (out instanceof BeanDefinition) {\n\n        } else if (out instanceof EnrichDefinition) {\n            String enrich = out.toString();\n            String resourceUri = enrich.substring(enrich.indexOf('[') + 1, enrich.indexOf(' '));\n            buffer.append(\"(\\\"\").append(resourceUri).append(\"\\\")\");\n        } else if (out instanceof FinallyDefinition) {\n            \n        } else if (out instanceof InterceptDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof InterceptSendToEndpointDefinition) {\n\n        } else if (out instanceof MarshalDefinition) {\n            DataFormatDefinition dataFormat = ((MarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        } else if (out instanceof MulticastDefinition) {\n\n        } else if (out instanceof OtherwiseDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof PipelineDefinition) {\n\n        } else if (out instanceof PolicyDefinition) {\n\n        } else if (out instanceof PollEnrichDefinition) {\n\n        } else if (out instanceof ProcessDefinition) {\n\n        } else if (out instanceof RemoveHeaderDefinition) {\n            RemoveHeaderDefinition remove = (RemoveHeaderDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getHeaderName()).append(\"\\\")\");\n        } else if (out instanceof RemovePropertyDefinition) {\n            RemovePropertyDefinition remove = (RemovePropertyDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getPropertyName()).append(\"\\\")\");\n        } else if (out instanceof SetExchangePatternDefinition) {\n\n        } else if (out instanceof SortDefinition) {\n            SortDefinition sort = (SortDefinition)out;\n            buffer.append(\"(\");\n            ExpressionRenderer.renderExpression(buffer, sort.getExpression().toString());\n            buffer.append(\")\");\n        } else if (out instanceof StopDefinition) {\n\n        } else if (out instanceof ThreadsDefinition) {\n\n        } else if (out instanceof TransactedDefinition) {\n\n        } else if (out instanceof TryDefinition) {\n\n        } else if (out instanceof UnmarshalDefinition) {\n            DataFormatDefinition dataFormat = ((UnmarshalDefinition)out).getDataFormatType();\n            Class clazz = dataFormat.getClass();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        }\n    }","commit_id":"ed83cf57aa6744dfd4f034e10ee6e6ce5601be03","url":"https://github.com/apache/camel"},{"original_method":"public void testChoiceWithoutEnd() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\", \\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\", \\\"seda:aggregate\\\")\";\n        String expectedDSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".end()\";\n\n        assertEquals(expectedDSL, render(DSL));\n    }","id":90655,"modified_method":"public void testChoiceWithoutEnd() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").split().body().choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\", \\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\", \\\"seda:aggregate\\\")\";\n        \n        //TODO check this result\n        String expectedDSL = \"from(\\\"direct:start\\\").split(body()).choice()\" +\n        \t\t\".when().method(\\\"orderItemHelper\\\", \\\"isWidget\\\").to(\\\"bean:widgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".otherwise().to(\\\"bean:gadgetInventory\\\").to(\\\"seda:aggregate\\\")\" +\n        \t\t\".end()\";\n\n        assertEquals(expectedDSL, render(DSL));\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public void testChoiceWithPredication() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").choice()\" +\n        \t\t\".when(header(\\\"username\\\").isNotNull()).to(\\\"mock:god\\\")\" +\n        \t\t\".when(header(\\\"admin\\\").isEqualTo(\\\"true\\\")).to(\\\"mock:admin\\\")\" +\n        \t\t\".otherwise().to(\\\"mock:guest\\\")\" +\n        \t\t\".end()\";\n        String expectedDSL = DSL;\n\n        assertEquals(expectedDSL, render(DSL));\n    }","id":90656,"modified_method":"public void testChoiceWithPredication() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").choice()\" +\n        \t\t\".when(header(\\\"username\\\").isNull()).to(\\\"mock:god\\\")\" +\n        \t\t\".when(header(\\\"admin\\\").isEqualTo(\\\"true\\\")).to(\\\"mock:admin\\\")\" +\n        \t\t\".otherwise().to(\\\"mock:guest\\\")\" +\n        \t\t\".end()\";\n        String expectedDSL = DSL;\n\n        assertEquals(expectedDSL, render(DSL));\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n\n    }","id":90657,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        ChoiceDefinition choice = (ChoiceDefinition)processor;\n        buffer.append(\".\").append(choice.getShortName()).append(\"()\");\n        for (WhenDefinition when : choice.getWhenClauses()) {\n            ProcessorDefinitionRenderer.render(buffer, when);\n        }\n        OtherwiseDefinition other = choice.getOtherwise();\n        if (other != null) {\n            ProcessorDefinitionRenderer.render(buffer, other);\n        }\n        buffer.append(\".end()\");\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        ExpressionNode expNode = (ExpressionNode)processor;\n        ExpressionDefinition expression = expNode.getExpression();\n\n        buffer.append(\".\").append(expNode.getShortName());\n        if (expNode instanceof DelayDefinition) {\n            String delay = expression.getExpressionValue().toString();\n            if (!delay.contains(\"(\")) {\n                String delayTime = expression.getExpressionValue().toString();\n                buffer.append(\"(\").append(delayTime).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof FilterDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            } else if (expression.getLanguage() != null) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof IdempotentConsumerDefinition) {\n        } else if (expNode instanceof LoopDefinition) {\n            if (expression instanceof ConstantExpression) {\n                buffer.append(\"(\").append(expression.getExpression()).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof RecipientListDefinition) {\n            buffer.append(\"(\");\n            ExpressionRenderer.render(buffer, expression);\n            buffer.append(\")\");\n        } else if (expNode instanceof SetBodyDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.renderConstant(buffer, expression);\n            }\n        } else if (expNode instanceof SetHeaderDefinition) {\n            SetHeaderDefinition set = (SetHeaderDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getHeaderName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SetOutHeaderDefinition) {\n            buffer.append(\"(\\\"unspported expressions in SetOutHeaderDefinition\\\")\");\n        } else if (expNode instanceof SetPropertyDefinition) {\n            SetPropertyDefinition set = (SetPropertyDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getPropertyName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SplitDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (!expValue.contains(\"(\")) {\n                buffer.append(\"().\").append(expValue).append(\"()\");\n            } else {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof TransformDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\") || expValue.startsWith(\"prepend\") || expValue.startsWith(\"to\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expValue.startsWith(\"xpath\")) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"(constant(\\\"\").append(expression.getExpressionValue().toString()).append(\"\\\"))\");\n            }\n        } else if (expNode instanceof WhenDefinition) {\n            if (expression.getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, expression.getPredicate());\n            }\n            if (expression instanceof ExpressionClause) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, (ExpressionClause)expression);\n            }\n        }\n    }","id":90658,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        ExpressionNode expNode = (ExpressionNode)processor;\n        ExpressionDefinition expression = expNode.getExpression();\n\n        buffer.append(\".\").append(expNode.getShortName());\n        if (expNode instanceof DelayDefinition) {\n            String delay = expression.getExpressionValue().toString();\n            if (!delay.contains(\"(\")) {\n                String delayTime = expression.getExpressionValue().toString();\n                buffer.append(\"(\").append(delayTime).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof FilterDefinition) {\n            if (expression.getPredicate() != null) {\n                buffer.append(\"(\");\n                PredicateRenderer.render(buffer, expression.getPredicate());\n                buffer.append(\")\");\n            } else if (expression.getLanguage() != null) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof IdempotentConsumerDefinition) {\n            // TODO improve it\n        } else if (expNode instanceof LoopDefinition) {\n            if (expression instanceof ConstantExpression) {\n                buffer.append(\"(\").append(expression.getExpression()).append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof RecipientListDefinition) {\n            buffer.append(\"(\");\n            ExpressionRenderer.render(buffer, expression);\n            buffer.append(\")\");\n        } else if (expNode instanceof SetBodyDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else {\n                buffer.append(\"()\");\n                ExpressionRenderer.renderConstant(buffer, expression);\n            }\n        } else if (expNode instanceof SetHeaderDefinition) {\n            SetHeaderDefinition set = (SetHeaderDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getHeaderName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SetOutHeaderDefinition) {\n            buffer.append(\"(\\\"unspported expressions in SetOutHeaderDefinition\\\")\");\n        } else if (expNode instanceof SetPropertyDefinition) {\n            SetPropertyDefinition set = (SetPropertyDefinition)expNode;\n            buffer.append(\"(\\\"\").append(set.getPropertyName()).append(\"\\\")\");\n            if (expression.getExpressionValue() != null) {\n                ExpressionRenderer.renderConstant(buffer, expression);\n            } else if (expression.getExpressionType() != null) {\n                ExpressionRenderer.render(buffer, expression);\n            }\n        } else if (expNode instanceof SplitDefinition) {\n            if (expression.getExpressionValue() != null) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expression.getExpressionType() != null) {\n                buffer.append(\"().\");\n                ExpressionRenderer.render(buffer, expression);\n            }\n\n            SplitDefinition split = (SplitDefinition)expNode;\n            if (split.isStreaming()) {\n                buffer.append(\".streaming()\");\n            }\n        } else if (expNode instanceof TransformDefinition) {\n            String expValue = expression.getExpressionValue().toString();\n            if (expValue.startsWith(\"append\") || expValue.startsWith(\"prepend\") || expValue.startsWith(\"to\")) {\n                buffer.append(\"(\");\n                ExpressionRenderer.render(buffer, expression);\n                buffer.append(\")\");\n            } else if (expValue.startsWith(\"xpath\")) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, expression);\n            } else {\n                buffer.append(\"(constant(\\\"\").append(expression.getExpressionValue().toString()).append(\"\\\"))\");\n            }\n        } else if (expNode instanceof WhenDefinition) {\n            if (expression.getPredicate() != null) {\n                buffer.append(\"(\");\n                PredicateRenderer.render(buffer, expression.getPredicate());\n                buffer.append(\")\");\n            }\n            if (expression instanceof ExpressionClause) {\n                buffer.append(\"()\");\n                ExpressionRenderer.render(buffer, (ExpressionClause)expression);\n            }\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Render a simple expression: header(foo) -> header(\"foo\")\n     * tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n     * \n     * @param buffer\n     * @param expression\n     */\n    public static void renderExpression(StringBuilder buffer, String expression) {\n        if (!expression.contains(\",\")) {\n            // header(foo) -> header(\"foo\")\n            expression = expression.replaceAll(\"\\\\(\", \"(\\\"\").replaceAll(\"\\\\)\", \"\\\")\");\n            buffer.append(expression);\n        } else if (expression.startsWith(\"tokenize\")) {\n            String words[] = expression.split(\"\\\\(\");\n            if (words.length == 2) {\n                // tokenize(body, ,) -> body().tokenize(\",\")\n                String tokenize = words[1].substring(words[1].indexOf(\" \") + 1, words[1].lastIndexOf(\")\"));\n                words[1] = words[1].substring(0, words[1].indexOf(\",\"));\n\n                buffer.append(words[1]).append(\"().\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            } else if (words.length == 3) {\n                // tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n                String symbolName = words[2].substring(0, words[2].indexOf(\")\"));\n                String tokenize = words[2].substring(words[2].indexOf(\" \") + 1, words[2].lastIndexOf(\")\"));\n\n                buffer.append(words[1]).append(\"(\\\"\").append(symbolName).append(\"\\\").\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            }\n        } else if (expression.startsWith(\"append\")) {\n            // append(body, World!) -> body().append(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"append(\\\"\").append(words[2]).append(\"\\\")\");\n        } else if (expression.startsWith(\"prepend\")) {\n            // prepend(body, World!) -> body().prepend(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"prepend(\\\"\").append(words[2]).append(\"\\\")\");\n        }\n    }","id":90659,"modified_method":"/**\n     * Render a simple expression: header(foo) -> header(\"foo\")\n     * tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n     * \n     * @param buffer\n     * @param expression\n     */\n    public static void renderExpression(StringBuilder buffer, String expression) {\n        if (!expression.contains(\",\")) {\n            if (expression.contains(\"(\")) {\n                // header(foo) -> header(\"foo\")\n                expression = expression.replaceAll(\"\\\\(\", \"(\\\"\").replaceAll(\"\\\\)\", \"\\\")\");\n                buffer.append(expression);\n            } else {\n                // body -> body()\n                buffer.append(expression).append(\"()\");\n            }\n        } else if (expression.startsWith(\"tokenize\")) {\n            String words[] = expression.split(\"\\\\(\");\n            if (words.length == 2) {\n                // tokenize(body, ,) -> body().tokenize(\",\")\n                String tokenize = words[1].substring(words[1].indexOf(\" \") + 1, words[1].lastIndexOf(\")\"));\n                words[1] = words[1].substring(0, words[1].indexOf(\",\"));\n\n                if (!words[1].contains(\"[\")) {\n                    // body\n                    buffer.append(words[1]).append(\"()\");\n                } else {\n                    // bodyAs[clazz]\n                    String word = words[1].substring(0, words[1].indexOf(\"As\"));\n                    String clazz = words[1].substring(words[1].lastIndexOf(\".\") + 1, words[1].length() - 1);\n                    buffer.append(word).append(\"(\").append(clazz).append(\".class)\");\n                }\n\n                buffer.append(\".\").append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            } else if (words.length == 3) {\n                // tokenize(header(foo), ,) -> header(\"foo\").tokenize(\",\")\n                String symbolName = words[2].substring(0, words[2].indexOf(\")\"));\n                String tokenize = words[2].substring(words[2].indexOf(\" \") + 1, words[2].lastIndexOf(\")\"));\n\n                buffer.append(words[1]).append(\"(\\\"\").append(symbolName).append(\"\\\").\");\n                buffer.append(words[0]).append(\"(\\\"\").append(tokenize).append(\"\\\")\");\n            }\n        } else if (expression.startsWith(\"append\")) {\n            // append(body, World!) -> body().append(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"append(\\\"\").append(words[2]).append(\"\\\")\");\n        } else if (expression.startsWith(\"prepend\")) {\n            // prepend(body, World!) -> body().prepend(\" World!\")\n            String words[] = expression.split(\"\\\\(|, |\\\\)\");\n\n            buffer.append(words[1]).append(\"().\").append(\"prepend(\\\"\").append(words[2]).append(\"\\\")\");\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * render a RouteDefinition\n     * \n     * @throws IOException\n     */\n    public static void renderRoute(StringBuilder buffer, RouteDefinition route) {\n        List<FromDefinition> inputs = route.getInputs();\n        List<ProcessorDefinition> outputs = route.getOutputs();\n\n        // render the error handler\n        if (!(route.getErrorHandlerBuilder() instanceof ErrorHandlerBuilderRef)) {\n            if (route.getErrorHandlerBuilder() instanceof DeadLetterChannelBuilder) {\n                DeadLetterChannelBuilder deadLetter = (DeadLetterChannelBuilder)route.getErrorHandlerBuilder();\n                buffer.append(\"errorHandler(deadLetterChannel(\\\"\").append(deadLetter.getDeadLetterUri()).append(\"\\\")\");\n                buffer.append(\".maximumRedeliveries(\").append(deadLetter.getRedeliveryPolicy().getMaximumRedeliveries()).append(\")\");\n                buffer.append(\".redeliverDelay(\").append(deadLetter.getRedeliveryPolicy().getRedeliverDelay()).append(\")\");\n                buffer.append(\".handled(\").append(deadLetter.getHandledPolicy().toString()).append(\")\");\n                buffer.append(\");\");\n            }\n        }\n\n        // render the global dsl not started with from, like global\n        // onCompletion, onException, intercept\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == null) {\n                renderProcessor(buffer, processor);\n                buffer.append(\";\");\n            }\n        }\n\n        // render the inputs of the router\n        buffer.append(\"from(\");\n        for (FromDefinition input : inputs) {\n            buffer.append(\"\\\"\").append(input.getUri()).append(\"\\\"\");\n            if (input != inputs.get(inputs.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render the outputs of the router\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == route) {\n                renderProcessor(buffer, processor);\n            }\n        }\n    }","id":90660,"modified_method":"/**\n     * render a RouteDefinition\n     */\n    public static void renderRoute(StringBuilder buffer, RouteDefinition route) {\n        List<FromDefinition> inputs = route.getInputs();\n        List<ProcessorDefinition> outputs = route.getOutputs();\n\n        // render the error handler\n        if (!(route.getErrorHandlerBuilder() instanceof ErrorHandlerBuilderRef)) {\n            if (route.getErrorHandlerBuilder() instanceof DeadLetterChannelBuilder) {\n                DeadLetterChannelBuilder deadLetter = (DeadLetterChannelBuilder)route.getErrorHandlerBuilder();\n                buffer.append(\"errorHandler(deadLetterChannel(\\\"\").append(deadLetter.getDeadLetterUri()).append(\"\\\")\");\n                buffer.append(\".maximumRedeliveries(\").append(deadLetter.getRedeliveryPolicy().getMaximumRedeliveries()).append(\")\");\n                buffer.append(\".redeliverDelay(\").append(deadLetter.getRedeliveryPolicy().getRedeliverDelay()).append(\")\");\n                buffer.append(\".handled(\").append(deadLetter.getHandledPolicy().toString()).append(\")\");\n                buffer.append(\");\");\n            }\n        }\n\n        // render the global dsl not started with from, like global\n        // intercept, interceptFrom,interceptSendToEndpoint, onCompletion,\n        // onException\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == null && !(processor instanceof SendDefinition)) {\n                ProcessorDefinitionRenderer.render(buffer, processor);\n                buffer.append(\";\");\n            }\n        }\n\n        // render the inputs of the router\n        buffer.append(\"from(\");\n        for (FromDefinition input : inputs) {\n            buffer.append(\"\\\"\").append(input.getUri()).append(\"\\\"\");\n            if (input != inputs.get(inputs.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render some route configurations\n        if (route.isTrace() != null) {\n            if (route.isTrace()) {\n                buffer.append(\".tracing()\");\n            } else {\n                buffer.append(\".noTracing()\");\n            }\n        }\n        if (route.isStreamCache() != null && route.isStreamCache()) {\n            buffer.append(\".streamCaching()\");\n        }\n\n        // render the outputs of the router\n        for (ProcessorDefinition processor : outputs) {\n            if (processor.getParent() == route || processor instanceof SendDefinition) {\n                ProcessorDefinitionRenderer.render(buffer, processor);\n            }\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * render a RoutesDefinition\n     */\n    public static void renderRoutes(StringBuilder buffer, RoutesDefinition routes) {\n        // TODO Auto-generated method stub\n\n    }","id":90661,"modified_method":"/**\n     * render a set of RouteDefinition\n     */\n    public static void renderRoutes(StringBuilder buffer, List<RouteDefinition> routes) {\n        for (RouteDefinition route : routes) {\n            renderRoute(buffer, route);\n            if (route != routes.get(routes.size() - 1)) {\n                buffer.append(\";\");\n            }\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public void _testRoutes() throws Exception {\n        FileReader reader = new FileReader(\"src/test/resources/testedRoutes.txt\");\n        BufferedReader br = new BufferedReader(reader);\n        String dsl = null;\n        while ((dsl = br.readLine()) != null) {\n            if (dsl.startsWith(\"#\")) {\n                continue;\n            }\n            System.out.println(\"dsl: \" + dsl);\n            System.out.println(\"after rendered: \\n\" + render(dsl));\n            System.out.println();\n        }\n    }","id":90662,"modified_method":"public void testRoutes() throws Exception {\n        FileReader reader = new FileReader(\"src/test/resources/routes.txt\");\n        BufferedReader br = new BufferedReader(reader);\n        String dsl = null;\n        while ((dsl = br.readLine()) != null) {\n            System.out.println(\"dsl: \" + dsl);\n            System.out.println(\"after rendered: \\n\" + renderRoutes(dsl));\n            System.out.println();\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public String render(String dsl) throws Exception {\n        RouteDefinition route = createRoute(dsl);\n        assertNotNull(route);\n\n        StringBuilder sb = new StringBuilder();\n        GroovyRenderer.renderRoute(sb, route);\n        return sb.toString();\n    }","id":90663,"modified_method":"public String render(String dsl) throws Exception {\n        RouteDefinition route = getRoute(dsl);\n        assertNotNull(route);\n\n        StringBuilder sb = new StringBuilder();\n        GroovyRenderer.renderRoute(sb, route);\n        return sb.toString();\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public RouteDefinition createRoute(String dsl) throws Exception {\n        if (context != null) {\n            context.stop();\n        }\n        context = new DefaultCamelContext();\n\n        String routeStr = header + dsl + footer;\n        GroovyClassLoader classLoader = new GroovyClassLoader();\n        Class clazz = classLoader.parseClass(routeStr);\n        RouteBuilder builder = (RouteBuilder)clazz.newInstance();\n\n        context.addRoutes(builder);\n        List<RouteDefinition> list = context.getRouteDefinitions();\n        if (!list.isEmpty()) {\n            return list.get(0);\n        }\n        return null;\n    }","id":90664,"modified_method":"/**\n     * create routes using the dsl and add them into camelContext\n     */\n    private void createAndAddRoute(String dsl) throws Exception, InstantiationException, IllegalAccessException {\n        if (context != null) {\n            context.stop();\n        }\n        context = new DefaultCamelContext();\n\n        String routeStr = header + dsl + footer;\n        GroovyClassLoader classLoader = new GroovyClassLoader();\n        Class clazz = classLoader.parseClass(routeStr);\n        RouteBuilder builder = (RouteBuilder)clazz.newInstance();\n\n        context.addRoutes(builder);\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public String getShortName() {\n        return \"interceptEndpoint\";\n    }","id":90665,"modified_method":"@Override\n    public String getShortName() {\n        return \"interceptSendToEndpoint\";\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        // if not a global onCompletion, add a period\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n\n        OnCompletionDefinition onComplete = (OnCompletionDefinition)processor;\n        buffer.append(processor.getShortName()).append(\"()\");\n        if (onComplete.getOnWhen() != null) {\n            WhenDefinition when = onComplete.getOnWhen();\n            buffer.append(\".onWhen\");\n            if (when.getExpression().getPredicate() != null) {\n                PredicateRenderer.renderPredicate(buffer, when.getExpression().getPredicate());\n            } else {\n                buffer.append(\"Unsupported Expression!\");\n            }\n        }\n        if (onComplete.getOnCompleteOnly()) {\n            buffer.append(\".onCompleteOnly()\");\n        }\n        if (onComplete.getOnFailureOnly()) {\n            buffer.append(\".onFailureOnly()\");\n        }\n        List<ProcessorDefinition> branches = onComplete.getOutputs();\n        for (ProcessorDefinition branch : branches) {\n            SendDefinitionRenderer.render(buffer, branch);\n        }\n\n\n        // if not a global onCompletion, using end() at the end\n        if (notGlobal) {\n            buffer.append(\".end()\");\n        }\n    }","id":90666,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        // if not a global onCompletion, add a period\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n\n        OnCompletionDefinition onComplete = (OnCompletionDefinition)processor;\n        buffer.append(processor.getShortName()).append(\"()\");\n        if (onComplete.getOnWhen() != null) {\n            WhenDefinition when = onComplete.getOnWhen();\n            buffer.append(\".onWhen\");\n            if (when.getExpression().getPredicate() != null) {\n                buffer.append(\"(\");\n                PredicateRenderer.render(buffer, when.getExpression().getPredicate());\n                buffer.append(\")\");\n            } else {\n                buffer.append(\"Unsupported Expression!\");\n            }\n        }\n        if (onComplete.getOnCompleteOnly()) {\n            buffer.append(\".onCompleteOnly()\");\n        }\n        if (onComplete.getOnFailureOnly()) {\n            buffer.append(\".onFailureOnly()\");\n        }\n        List<ProcessorDefinition> branches = onComplete.getOutputs();\n        for (ProcessorDefinition branch : branches) {\n            SendDefinitionRenderer.render(buffer, branch);\n        }\n\n        // if not a global onCompletion, using end() at the end\n        if (notGlobal) {\n            buffer.append(\".end()\");\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        // if not a global onCompletion, add a period\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n\n        OnExceptionDefinition onException = (OnExceptionDefinition)processor;\n        buffer.append(processor.getShortName()).append(\"(\");\n        List<Class> exceptions = onException.getExceptionClasses();\n        for (Class excep : exceptions) {\n            buffer.append(excep.getSimpleName()).append(\".class\");\n            if (excep != exceptions.get(exceptions.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        List<ProcessorDefinition> branches = onException.getOutputs();\n        for (ProcessorDefinition branch : branches) {\n            SendDefinitionRenderer.render(buffer, branch);\n        }\n    }","id":90667,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        // if not a global onCompletion, add a period\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n\n        OnExceptionDefinition onException = (OnExceptionDefinition)processor;\n        buffer.append(processor.getShortName()).append(\"(\");\n        List<Class> exceptions = onException.getExceptionClasses();\n        for (Class excep : exceptions) {\n            buffer.append(excep.getSimpleName()).append(\".class\");\n            if (excep != exceptions.get(exceptions.size() - 1)) {\n                buffer.append(\", \");\n            }\n        }\n        buffer.append(\")\");\n\n        // render handled() dsl\n        if (onException.getHandledPolicy() != null) {\n            String handled = onException.getHandledPolicy().toString();\n            buffer.append(\".handled(\").append(handled).append(\")\");\n        }\n\n        List<ProcessorDefinition> branches = onException.getOutputs();\n        for (ProcessorDefinition branch : branches) {\n            SendDefinitionRenderer.render(buffer, branch);\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        OutputDefinition out = (OutputDefinition)processor;\n\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n        buffer.append(out.getShortName());\n\n        if (out instanceof AOPDefinition) {\n            buffer.append(\"()\");\n            AOPDefinition aop = (AOPDefinition)out;\n\n            if (aop.getBeforeUri() != null && aop.getAfterUri() != null) {\n                buffer.append(\".around(\\\"\").append(aop.getBeforeUri());\n                buffer.append(\"\\\", \\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getBeforeUri() != null) {\n                buffer.append(\".before(\\\"\").append(aop.getBeforeUri()).append(\"\\\")\");\n            } else if (aop.getAfterUri() != null) {\n                buffer.append(\".after(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getAfterFinallyUri() != null) {\n                buffer.append(\".afterFinally(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            }\n\n        } else if (out instanceof BeanDefinition) {\n\n        } else if (out instanceof EnrichDefinition) {\n            String enrich = out.toString();\n            String resourceUri = enrich.substring(enrich.indexOf('[') + 1, enrich.indexOf(' '));\n            buffer.append(\"(\\\"\").append(resourceUri).append(\"\\\")\");\n        } else if (out instanceof FinallyDefinition) {\n            \n        } else if (out instanceof InterceptDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof InterceptSendToEndpointDefinition) {\n\n        } else if (out instanceof MarshalDefinition) {\n            DataFormatDefinition dataFormat = ((MarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        } else if (out instanceof MulticastDefinition) {\n\n        } else if (out instanceof OtherwiseDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof PipelineDefinition) {\n\n        } else if (out instanceof PolicyDefinition) {\n\n        } else if (out instanceof PollEnrichDefinition) {\n\n        } else if (out instanceof ProcessDefinition) {\n\n        } else if (out instanceof RemoveHeaderDefinition) {\n            RemoveHeaderDefinition remove = (RemoveHeaderDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getHeaderName()).append(\"\\\")\");\n        } else if (out instanceof RemovePropertyDefinition) {\n            RemovePropertyDefinition remove = (RemovePropertyDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getPropertyName()).append(\"\\\")\");\n        } else if (out instanceof SetExchangePatternDefinition) {\n\n        } else if (out instanceof SortDefinition) {\n            SortDefinition sort = (SortDefinition)out;\n            buffer.append(\"(\");\n            ExpressionRenderer.renderExpression(buffer, sort.getExpression().toString());\n            buffer.append(\")\");\n        } else if (out instanceof StopDefinition) {\n\n        } else if (out instanceof ThreadsDefinition) {\n\n        } else if (out instanceof TransactedDefinition) {\n\n        } else if (out instanceof TryDefinition) {\n\n        } else if (out instanceof UnmarshalDefinition) {\n            DataFormatDefinition dataFormat = ((UnmarshalDefinition)out).getDataFormatType();\n            Class clazz = dataFormat.getClass();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        }\n    }","id":90668,"modified_method":"public static void render(StringBuilder buffer, ProcessorDefinition processor) {\n        OutputDefinition out = (OutputDefinition)processor;\n        boolean notGlobal = buffer.toString().endsWith(\")\");\n        if (notGlobal) {\n            buffer.append(\".\");\n        }\n        buffer.append(out.getShortName());\n\n        if (out instanceof AOPDefinition) {\n            buffer.append(\"()\");\n            AOPDefinition aop = (AOPDefinition)out;\n            if (aop.getBeforeUri() != null && aop.getAfterUri() != null) {\n                buffer.append(\".around(\\\"\").append(aop.getBeforeUri());\n                buffer.append(\"\\\", \\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getBeforeUri() != null) {\n                buffer.append(\".before(\\\"\").append(aop.getBeforeUri()).append(\"\\\")\");\n            } else if (aop.getAfterUri() != null) {\n                buffer.append(\".after(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            } else if (aop.getAfterFinallyUri() != null) {\n                buffer.append(\".afterFinally(\\\"\").append(aop.getAfterUri()).append(\"\\\")\");\n            }\n\n        } else if (out instanceof BeanDefinition) {\n            // TODO improve it\n        } else if (out instanceof EnrichDefinition) {\n            String enrich = out.toString();\n            String resourceUri = enrich.substring(enrich.indexOf('[') + 1, enrich.indexOf(' '));\n            buffer.append(\"(\\\"\").append(resourceUri).append(\"\\\")\");\n        } else if (out instanceof FinallyDefinition) {\n\n        } else if (out instanceof InterceptDefinition) {\n            if (out instanceof InterceptFromDefinition) {\n                InterceptFromDefinition interceptFrom = (InterceptFromDefinition)out;\n                if (interceptFrom.getUri() != null) {\n                    buffer.append(\"(\\\"\").append(interceptFrom.getUri()).append(\"\\\")\");\n                    return;\n                }\n            }\n            buffer.append(\"()\");\n        } else if (out instanceof InterceptSendToEndpointDefinition) {\n            InterceptSendToEndpointDefinition interceptSend = (InterceptSendToEndpointDefinition)out;\n            buffer.append(\"(\\\"\").append(interceptSend.getUri()).append(\"\\\")\");\n            if (interceptSend.getSkipSendToOriginalEndpoint()) {\n                buffer.append(\".skipSendToOriginalEndpoint()\");\n            }\n        } else if (out instanceof MarshalDefinition) {\n            DataFormatDefinition dataFormat = ((MarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        } else if (out instanceof MulticastDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof OtherwiseDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof PipelineDefinition) {\n            // transformed into simple ToDefinition\n        } else if (out instanceof PolicyDefinition) {\n            // TODO improve it\n        } else if (out instanceof PollEnrichDefinition) {\n            // TODO improve it\n        } else if (out instanceof ProcessDefinition) {\n            // TODO improve it\n        } else if (out instanceof RemoveHeaderDefinition) {\n            RemoveHeaderDefinition remove = (RemoveHeaderDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getHeaderName()).append(\"\\\")\");\n        } else if (out instanceof RemovePropertyDefinition) {\n            RemovePropertyDefinition remove = (RemovePropertyDefinition)out;\n            buffer.append(\"(\\\"\").append(remove.getPropertyName()).append(\"\\\")\");\n        } else if (out instanceof SetExchangePatternDefinition) {\n            // TODO improve it\n        } else if (out instanceof SortDefinition) {\n            SortDefinition sort = (SortDefinition)out;\n            buffer.append(\"(\");\n            ExpressionRenderer.renderExpression(buffer, sort.getExpression().toString());\n            buffer.append(\")\");\n        } else if (out instanceof StopDefinition) {\n            buffer.append(\"()\");\n        } else if (out instanceof ThreadsDefinition) {\n            // TODO improve it\n        } else if (out instanceof TransactedDefinition) {\n            // TODO improve it\n        } else if (out instanceof TryDefinition) {\n            // TODO improve it\n        } else if (out instanceof UnmarshalDefinition) {\n            DataFormatDefinition dataFormat = ((UnmarshalDefinition)out).getDataFormatType();\n            buffer.append(\"().\").append(dataFormat.getClass().getAnnotation(XmlRootElement.class).name()).append(\"()\");\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public void testPipeline1() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").pipeline(\\\"direct:x\\\", \\\"direct:y\\\", \\\"direct:z\\\", \\\"mock:result\\\")\";\n        String expectedDSL = \"from(\\\"direct:start\\\").to(\\\"direct:x\\\").to(\\\"direct:y\\\").to(\\\"direct:z\\\").to(\\\"mock:result\\\")\";\n\n        assertEquals(expectedDSL, render(DSL));\n    }","id":90669,"modified_method":"public void testPipeline1() throws Exception {\n        String DSL = \"from(\\\"direct:start\\\").pipeline(\\\"mock:x\\\", \\\"mock:y\\\", \\\"mock:z\\\", \\\"mock:result\\\")\";\n        String expectedDSL = \"from(\\\"direct:start\\\").to(\\\"mock:x\\\").to(\\\"mock:y\\\").to(\\\"mock:z\\\").to(\\\"mock:result\\\")\";\n\n        assertEquals(expectedDSL, render(DSL));\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"public static void renderPredicate(StringBuilder buffer, Predicate predicate) {\n        String pre = predicate.toString();\n        if (pre.contains(\"(\")) {\n            pre = pre.replaceAll(\"\\\\(\", \"(\\\"\").replaceAll(\"\\\\)\", \"\\\")\");\n\n            String rightExp = pre.substring(pre.indexOf(\" \") + 1);\n            if (rightExp.startsWith(\"==\")) {\n                // replace == with isEqualTo\n                pre = pre.replaceFirst(\"\\\\ == \", \".isEqualTo(\\\"\");\n                pre += \"\\\")\";\n            } else if (rightExp.startsWith(\"is not null\")) {\n                pre = pre.replaceFirst(\"\\\\ is not null\", \".isNotNull()\");\n            }\n            buffer.append(\"(\").append(pre).append(\")\");\n        } else {\n            String tmp[] = pre.split(\"\\\\s+\");\n            buffer.append(\"(\").append(tmp[0]).append(\"().\").append(tmp[1]).append(\"(\\\"\").append(tmp[2]).append(\"\\\"))\");\n        }\n    }","id":90670,"modified_method":"public static void render(StringBuilder buffer, Predicate predicate) {\n        String pre = predicate.toString();\n        if (pre.startsWith(\"not (\")) {\n            renderNot(buffer, pre);\n        } else if (pre.contains(\") and (\")) {\n            renderAnd(buffer, pre);\n        } else if (pre.contains(\") or (\")) {\n            renderOr(buffer, pre);\n        } else if (pre.startsWith(\"in (\")) {\n            renderIn(buffer, pre);\n        } else if (pre.contains(\".matches(\")) {\n            renderMatches(buffer, pre);\n        } else {\n            render(buffer, pre);\n        }\n    }","commit_id":"83bd77880ff9ba56612280eaf992a1af6894a637","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n        for (final JaxrsAnnotations annotation : JaxrsAnnotations.values()) {\n            if (!index.getAnnotations(annotation.getDotName()).isEmpty()) {\n                JaxrsDeploymentMarker.mark(deploymentUnit);\n                phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, Services.JBOSS_MODULE_INDEX_SERVICE);\n                return;\n            }\n        }\n\n        //register resource, provider and application as CDI annotation defining types\n        deploymentUnit.addToAttachmentList(WeldAttachments.INJECTION_TARGET_DEFINING_ANNOTATIONS, new AnnotationType(JaxrsAnnotations.PROVIDER.getDotName(), false));\n        deploymentUnit.addToAttachmentList(WeldAttachments.INJECTION_TARGET_DEFINING_ANNOTATIONS, new AnnotationType(JaxrsAnnotations.PATH.getDotName(), false));\n    }","id":90671,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (deploymentUnit.getParent() == null) {\n            //register resource, provider and application as CDI annotation defining types\n            deploymentUnit.addToAttachmentList(WeldAttachments.INJECTION_TARGET_DEFINING_ANNOTATIONS, new AnnotationType(JaxrsAnnotations.PROVIDER.getDotName(), false));\n            deploymentUnit.addToAttachmentList(WeldAttachments.INJECTION_TARGET_DEFINING_ANNOTATIONS, new AnnotationType(JaxrsAnnotations.PATH.getDotName(), false));\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n        for (final JaxrsAnnotations annotation : JaxrsAnnotations.values()) {\n            if (!index.getAnnotations(annotation.getDotName()).isEmpty()) {\n                JaxrsDeploymentMarker.mark(deploymentUnit);\n                phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS, Services.JBOSS_MODULE_INDEX_SERVICE);\n                return;\n            }\n        }\n\n    }","commit_id":"8480a118c4592ea91f1ead213c662bb4c4f853cf","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        // for war modules we require a beans.xml to load portable extensions\n        if (PrivateSubDeploymentMarker.isPrivate(deploymentUnit)) {\n            if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n                return;\n            }\n        } else if (deploymentUnit.getParent() == null) {\n            // if any sub deployments have beans.xml then the top level deployment is\n            // marked as a weld deplyment\n            if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n                return;\n            }\n        } else {\n            // if any deployments have a beans.xml we need to load portable extensions\n            // even if this one does not.\n            if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit.getParent())) {\n                return;\n            }\n        }\n\n        // we attach extensions directly to the top level deployment\n        final DeploymentUnit topLevelDeployment = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit\n                .getParent();\n\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        ClassLoader oldCl = SecurityActions.getContextClassLoader();\n        try {\n            SecurityActions.setContextClassLoader(module.getClassLoader());\n            loadAttachments(module, topLevelDeployment);\n        } finally {\n            SecurityActions.setContextClassLoader(oldCl);\n        }\n    }","id":90672,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        // for war modules we require a beans.xml to load portable extensions\n        if (PrivateSubDeploymentMarker.isPrivate(deploymentUnit)) {\n            if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n                return;\n            }\n        } else if (deploymentUnit.getParent() == null) {\n            // if any sub deployments have beans.xml then the top level deployment is\n            // marked as a weld deplyment\n            if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n                return;\n            }\n        } else {\n            // if any deployments have a beans.xml we need to load portable extensions\n            // even if this one does not.\n            if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit.getParent())) {\n                return;\n            }\n        }\n\n        // we attach extensions directly to the top level deployment\n        final DeploymentUnit topLevelDeployment = deploymentUnit.getParent() == null ? deploymentUnit : deploymentUnit\n                .getParent();\n\n        final ServicesAttachment services = deploymentUnit.getAttachment(Attachments.SERVICES);\n\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        ClassLoader oldCl = SecurityActions.getContextClassLoader();\n        try {\n            SecurityActions.setContextClassLoader(module.getClassLoader());\n            loadAttachments(services, module, topLevelDeployment);\n        } finally {\n            SecurityActions.setContextClassLoader(oldCl);\n        }\n    }","commit_id":"ca6d6c49c6792ef501f6762a25a141802560135e","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void loadAttachments(Module module, DeploymentUnit deploymentUnit) {\n        // now load extensions\n        final ServiceLoader<Extension> loader = ServiceLoader.load(Extension.class, module.getClassLoader());\n        final Iterator<Metadata<Extension>> iterator = loader.iterator();\n        while (iterator.hasNext()) {\n            Metadata<Extension> extension = iterator.next();\n            log.debug(\"Loaded portable extension \" + extension.getLocation());\n            deploymentUnit.addToAttachmentList(WeldAttachments.PORTABLE_EXTENSIONS, extension);\n        }\n    }","id":90673,"modified_method":"private void loadAttachments(final ServicesAttachment servicesAttachment, Module module, DeploymentUnit deploymentUnit) {\n        // now load extensions\n        final DeploymentReflectionIndex index = deploymentUnit.getAttachment(Attachments.REFLECTION_INDEX);\n        final List<String> services = servicesAttachment.getServiceImplementations(Extension.class.getName());\n        if (services == null) {\n            return;\n        }\n        for (String service : services) {\n            final Extension extension = loadExtension(service, index,  module.getClassLoader());\n            if(extension == null) {\n                continue;\n            }\n            Metadata<Extension> metadata = new MetadataImpl<Extension>(extension, deploymentUnit.getName());\n            log.debug(\"Loaded portable extension \" + extension);\n            deploymentUnit.addToAttachmentList(WeldAttachments.PORTABLE_EXTENSIONS, metadata);\n        }\n    }","commit_id":"ca6d6c49c6792ef501f6762a25a141802560135e","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void error(String message) {\n      myOriginalPositionMarker.drop();\n      super.error(message);\n    }","id":90674,"modified_method":"@Override\n    public void error(String message) {\n      if (myOriginalPositionMarker != null) {\n        myOriginalPositionMarker.drop();\n      }\n      super.error(message);\n    }","commit_id":"468391cb0a96463839f9e7453cdf42498735c5fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void done(@NotNull IElementType type) {\n      myOriginalPositionMarker.drop();\n      super.done(type);\n    }","id":90675,"modified_method":"@Override\n    public void done(@NotNull IElementType type) {\n      if (myOriginalPositionMarker != null) {\n        myOriginalPositionMarker.drop();\n      }\n      super.done(type);\n    }","commit_id":"468391cb0a96463839f9e7453cdf42498735c5fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void doneBefore(@NotNull IElementType type, @NotNull Marker before) {\n      myOriginalPositionMarker.drop();\n      super.doneBefore(type, getDelegateOrThis(before));\n    }","id":90676,"modified_method":"@Override\n    public void doneBefore(@NotNull IElementType type, @NotNull Marker before) {\n      if (myOriginalPositionMarker != null) {\n        myOriginalPositionMarker.drop();\n      }\n      super.doneBefore(type, getDelegateOrThis(before));\n    }","commit_id":"468391cb0a96463839f9e7453cdf42498735c5fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void collapse(@NotNull IElementType type) {\n      myOriginalPositionMarker.drop();\n      super.collapse(type);\n    }","id":90677,"modified_method":"@Override\n    public void collapse(@NotNull IElementType type) {\n      if (myOriginalPositionMarker != null) {\n        myOriginalPositionMarker.drop();\n      }\n      super.collapse(type);\n    }","commit_id":"468391cb0a96463839f9e7453cdf42498735c5fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void rollbackTo() {\n      myOriginalPositionMarker.rollbackTo();\n      myLexPosition = myBuilderPosition;\n    }","id":90678,"modified_method":"@Override\n    public void rollbackTo() {\n      if (myOriginalPositionMarker != null) {\n        myOriginalPositionMarker.rollbackTo();\n      } else {\n        super.rollbackTo();\n      }\n      myLexPosition = myBuilderPosition;\n    }","commit_id":"468391cb0a96463839f9e7453cdf42498735c5fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void drop() {\n      myOriginalPositionMarker.drop();\n      super.drop();\n    }","id":90679,"modified_method":"@Override\n    public void drop() {\n      if (myOriginalPositionMarker != null) {\n        myOriginalPositionMarker.drop();\n      }\n      super.drop();\n    }","commit_id":"468391cb0a96463839f9e7453cdf42498735c5fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public Marker mark() {\n    Marker originalPositionMarker = super.mark();\n    // In the case of the topmost node all should be inserted\n    if (myLexPosition != 0) {\n      synchronizePositions(true);\n    }\n\n    final Marker mark = super.mark();\n    return new MyMarker(mark, originalPositionMarker, myLexPosition);\n  }","id":90680,"modified_method":"@NotNull\n  @Override\n  public Marker mark() {\n    Marker originalPositionMarker = null;\n    // In the case of the topmost node all should be inserted\n    if (myLexPosition != 0) {\n      originalPositionMarker = super.mark();\n      synchronizePositions(true);\n    }\n\n    final Marker mark = super.mark();\n    if (myLexPosition == 0) {\n      if (myDelegate.getTokenType() == TemplateMasqueradingLexer.MINUS_TYPE) {\n        myDelegate.advanceLexer();\n      }\n    }\n    return new MyMarker(mark, originalPositionMarker, myLexPosition);\n  }","commit_id":"468391cb0a96463839f9e7453cdf42498735c5fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void doneBefore(@NotNull IElementType type, @NotNull Marker before, String errorMessage) {\n      myOriginalPositionMarker.drop();\n      super.doneBefore(type, getDelegateOrThis(before), errorMessage);\n    }","id":90681,"modified_method":"@Override\n    public void doneBefore(@NotNull IElementType type, @NotNull Marker before, String errorMessage) {\n      if (myOriginalPositionMarker != null) {\n        myOriginalPositionMarker.drop();\n      }\n      super.doneBefore(type, getDelegateOrThis(before), errorMessage);\n    }","commit_id":"468391cb0a96463839f9e7453cdf42498735c5fd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Builds and creates a new database instance.\n   * @param p parser instance\n   * @param db name of database; if set to null,\n   * a main memory database instance is created\n   * @return success of operation\n   */\n  protected final boolean build(final Parser p, final String db) {\n    new Close().execute(context);\n\n    final boolean mem = db == null || prop.is(Prop.MAINMEM);\n    if(!mem && context.pinned(db)) return error(DBINUSE);\n\n    final Builder builder = mem ? new MemBuilder(p) : prop.is(Prop.NATIVEDATA) ?\n        new NativeBuilder(p) : new DiskBuilder(p);\n    progress(builder);\n\n    String err = null;\n    try {\n      final Data data = builder.build(db == null ? \"\" : db + \".tmp\");\n      if(mem) {\n        context.openDB(data);\n      } else {\n        index(data);\n        data.close();\n        move(db, p.prop);\n        new Open(db).execute(context);\n      }\n      return info(DBCREATED, db, perf.getTimer());\n    } catch(final FileNotFoundException ex) {\n      BaseX.debug(ex);\n      err = BaseX.info(FILEWHICH, p.io);\n    } catch(final ProgressException ex) {\n      err = PROGERR;\n    } catch(final IOException ex) {\n      BaseX.debug(ex);\n      final String msg = ex.getMessage();\n      err = BaseX.info(msg != null ? msg : args[0]);\n    } catch(final Exception ex) {\n      BaseX.debug(ex);\n      err = BaseX.info(CREATEERR, args[0]);\n    }\n    try {\n      builder.close();\n    } catch(final IOException ex) {\n      BaseX.debug(ex);\n    }\n    DropDB.drop(db, prop);\n    return error(err);\n  }","id":90682,"modified_method":"/**\n   * Builds and creates a new database instance.\n   * @param p parser instance\n   * @param db name of database; if set to null,\n   * a main memory database instance is created\n   * @return success of operation\n   */\n  protected final boolean build(final Parser p, final String db) {\n    new Close().execute(context);\n\n    final boolean mem = db == null || prop.is(Prop.MAINMEM);\n    if(!mem && context.pinned(db)) return error(DBINUSE);\n\n    final Builder builder = mem ? new MemBuilder(p) : prop.is(Prop.NATIVEDATA) ?\n        new NativeBuilder(p) : new DiskBuilder(p);\n    progress(builder);\n\n    String err = null;\n    try {\n      final Data data = builder.build(db == null ? \"\" : db + \".tmp\");\n      if(mem) {\n        context.openDB(data);\n      } else {\n        index(data);\n        data.close();\n        move(db, p.prop);\n        new Open(db).execute(context);\n      }\n      return info(DBCREATED, db, perf.getTimer());\n    } catch(final FileNotFoundException ex) {\n      BaseX.debug(ex);\n      err = BaseX.info(FILEWHICH, p.io);\n    } catch(final ProgressException ex) {\n      err = PROGERR;\n    } catch(final IOException ex) {\n      BaseX.debug(ex);\n      final String msg = ex.getMessage();\n      err = BaseX.info(msg != null ? msg : args[0]);\n    } catch(final Exception ex) {\n      BaseX.debug(ex);\n      err = BaseX.info(CREATEERR, args[0]);\n    }\n    try {\n      builder.close();\n    } catch(final IOException ex) {\n      BaseX.debug(ex);\n    }\n    if(db != null) DropDB.drop(db + \".tmp\", prop);\n    return error(err);\n  }","commit_id":"6848762d6d2dcd930963fdf0e21b044c28e8a1dd","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Extracts metadata of a single email.\r\n   * @param build reference to the database builder\r\n   * @return false if no more mails are found\r\n   * @throws IOException I/O exception\r\n   */\r\n  private boolean getSingleMailData(final Builder build) throws IOException {\r\n    build.startElem(EMAIL, atts.reset());\r\n\r\n    // catch exceptions and insert them into tree to find the part of\r\n    // the mail which caused problem\r\n    mBoundary = \"\";\r\n    getHeaderData(build);\r\n\r\n    if(mBoundary.length() != 0) {\r\n      // currently, mContextType can still be empty..\r\n      mMultiPart = mContentType != null && mContentType.contains(\"multipart\");\r\n\r\n      // find beginning of first part\r\n      if(mMultiPart) while(!mCurrLine.contains(mBoundary))\r\n        readLine();\r\n    }\r\n\r\n    // parse all mail parts (can be just one)\r\n    while(getBodyData(build));\r\n\r\n    // need to reset if email is mbox format\r\n    mMultiPart = false;\r\n\r\n    build.endElem(EMAIL);\r\n\r\n    while(readLine() && mCurrLine.length() == 0);\r\n    return mCurrLine != null;\r\n  }","id":90683,"modified_method":"/**\r\n   * Extracts metadata of a single email.\r\n   * @param build reference to the database builder\r\n   * @return false if no more mails are found\r\n   * @throws IOException I/O exception\r\n   */\r\n  private boolean getSingleMailData(final Builder build) throws IOException {\r\n    build.startElem(EMAIL, atts.reset());\r\n\r\n    // catch exceptions and insert them into tree to find the part of\r\n    // the mail which caused problem\r\n    mBoundary = \"\";\r\n    getHeaderData(build);\r\n\r\n    if(mBoundary.length() != 0) {\r\n      // currently, mContextType can still be empty..\r\n      mMultiPart = mContentType != null && mContentType.contains(\"multipart\");\r\n\r\n      // find beginning of first part\r\n      if(mMultiPart) while(!mCurrLine.contains(mBoundary) && readLine());\r\n    }\r\n\r\n    // parse all mail parts (can be just one)\r\n    if(mCurrLine != null) {\r\n      while(getBodyData(build));\r\n      // need to reset if email is mbox format\r\n      mMultiPart = false;\r\n    }\r\n\r\n    build.endElem(EMAIL);\r\n\r\n    while(readLine() && mCurrLine.length() == 0);\r\n    return mCurrLine != null;\r\n  }","commit_id":"6848762d6d2dcd930963fdf0e21b044c28e8a1dd","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public String toString() {\n    final StringBuilder s = new StringBuilder();\n    if(is(ST) || sd != null)\n      s.append(\" \" + QueryTokens.WITH + \" \" + QueryTokens.STEMMING);\n    if(is(WC))\n      s.append(\" \" + QueryTokens.WITH + \" \" + QueryTokens.WILDCARDS);\n    if(is(FZ))\n      s.append(\" \" + QueryTokens.WITH + \" \" + QueryTokens.FUZZY);\n    if(is(DC))\n      s.append(\" \" + QueryTokens.DIACRITICS + \" \" + QueryTokens.SENSITIVE);\n    if(th != null)\n      s.append(\" \" + QueryTokens.WITH + \" \" + QueryTokens.THESAURUS);\n    if(is(UC))\n      s.append(\" \" + QueryTokens.UPPERCASE);\n    if(is(LC))\n      s.append(\" \" + QueryTokens.LOWERCASE);\n    return s.toString();\n  }","id":90684,"modified_method":"@Override\n  public String toString() {\n    final StringBuilder s = new StringBuilder();\n    if(is(ST) || sd != null)\n      s.append(\" \" + QueryTokens.USING + \" \" + QueryTokens.STEMMING);\n    if(is(WC))\n      s.append(\" \" + QueryTokens.USING + \" \" + QueryTokens.WILDCARDS);\n    if(is(FZ))\n      s.append(\" \" + QueryTokens.USING + \" \" + QueryTokens.FUZZY);\n    if(is(DC))\n      s.append(\" \" + QueryTokens.USING + \" \" + QueryTokens.DIACRITICS + \" \" +\n          QueryTokens.SENSITIVE);\n    if(th != null)\n      s.append(\" \" + QueryTokens.USING + \" \" + QueryTokens.THESAURUS);\n    if(is(UC))\n      s.append(\" \" + QueryTokens.USING + \" \" + QueryTokens.UPPERCASE);\n    if(is(LC))\n      s.append(\" \" + QueryTokens.USING + \" \" + QueryTokens.LOWERCASE);\n    return s.toString();\n  }","commit_id":"6848762d6d2dcd930963fdf0e21b044c28e8a1dd","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @param s store flag\r\n   * @throws Exception exception\r\n   */\r\n  private void query(final int db, final int qu, final boolean s)\r\n      throws Exception {\r\n    if (budget > -1) {\r\n      final double timer = budget - rqt[qu];\r\n      if (timer <= 0) {\r\n        if (s) {  \r\n          res.println(0 + \";\" + 0);\r\n          BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), 0);\r\n        }\r\n        return;\r\n      }\r\n      launcher.execute(new Set(Prop.IBT, timer));   \r\n    }\r\n    \r\n    final CachedOutput r = new CachedOutput();\r\n    if(launcher.execute(new XQuery(queries.get(qu)))) {\r\n      launcher.output(r);\r\n      if(!s) return;\r\n\r\n      final CachedOutput out = new CachedOutput();\r\n      launcher.info(out);\r\n      final String time = Pattern.compile(\".*\" + \"Total Time: (.*?) ms.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n\r\n      // output result\r\n      BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n      if(info) {\r\n        BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n            Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n      }\r\n      String in = out.toString();\r\n      in = in.substring(in.indexOf(\"Results\") + \r\n          \"Results\".length(), in.indexOf(\"Item\")).trim();\r\n      rqt[qu] += Double.parseDouble(time);\r\n      res.println(time + \";\" + \r\n          Integer.parseInt(in.substring(in.indexOf(':') + 2)));\r\n    } else {\r\n      final CachedOutput out = new CachedOutput();\r\n      launcher.info(out);\r\n      BaseX.outln(out.toString());\r\n      res.println(-1 + \";\" + -1);\r\n    }\r\n  }","id":90685,"modified_method":"/**\r\n   * Performs a single query.\r\n   * @param db database offset\r\n   * @param qu query offset\r\n   * @param s store flag\r\n   * @throws Exception exception\r\n   */\r\n  private void query(final int db, final int qu, final boolean s)\r\n      throws Exception {\r\n    if (budget > -1) {\r\n      final double timer = budget - rqt[qu];\r\n      if (timer <= 0) {\r\n        if (s) {  \r\n          res.println(0 + \";\" + 0);\r\n          BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), 0);\r\n        }\r\n        return;\r\n      }\r\n      launcher.execute(new Set(Prop.IBT, timer));   \r\n    }\r\n    \r\n    final CachedOutput r = new CachedOutput();\r\n    if(launcher.execute(new XQuery(queries.get(qu)))) {\r\n      launcher.output(r);\r\n      if(!s) return;\r\n\r\n      final CachedOutput out = new CachedOutput();\r\n      launcher.info(out);\r\n      final String time = Pattern.compile(\".*Total Time: (.*?) ms.*\",\r\n          Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\");\r\n\r\n      // output result\r\n      BaseX.outln(\"Query % on %: %\", qu + 1, databases.get(db), time);\r\n      if(info) {\r\n        BaseX.outln(\"- \" + Pattern.compile(\".*Result: (.*?)\\\\n.*\",\r\n            Pattern.DOTALL).matcher(out.toString()).replaceAll(\"$1\"));\r\n      }\r\n      String in = out.toString();\r\n      in = in.substring(in.indexOf(\"Results\") + \r\n          \"Results\".length(), in.indexOf(\"Item\")).trim();\r\n      rqt[qu] += Double.parseDouble(time);\r\n      res.println(time + \";\" + \r\n          Integer.parseInt(in.substring(in.indexOf(':') + 2)));\r\n    } else {\r\n      final CachedOutput out = new CachedOutput();\r\n      launcher.info(out);\r\n      BaseX.outln(out.toString());\r\n      res.println(-1 + \";\" + -1);\r\n    }\r\n  }","commit_id":"6848762d6d2dcd930963fdf0e21b044c28e8a1dd","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\r\n   * Creates and prints the submission file.\r\n   * @throws Exception Exception\r\n   */\r\n  private static void openSubFile() throws Exception {\r\n    sub = new PrintOutput(\"submission.xml\");\r\n    sub.println(\"<!DOCTYPE efficiency-submission SYSTEM \" +\r\n    \"'efficiency-submission.dtd'>\");\r\n    xml = new XMLSerializer(sub, false, true);\r\n\r\n    // print header in output file\r\n    xml.openElement(token(\"efficiency-submission\"),\r\n        token(\"participant-id\"), token(\"304\"),\r\n        token(\"run-id\"), token(\"1111111\"),\r\n        token(\"task\"), token(TASK[0]),\r\n        token(\"type\"), token(TYPE[0]),\r\n        token(\"query\"), token(query[0]),\r\n        token(\"sequential\"), token(\"yes\"),\r\n        token(\"no_cpu\"), token(\"2\"),\r\n        token(\"ram\"), token(\"32 GB\"),\r\n        token(\"index_size_bytes\"), token(\"7.5 GB\")\r\n    );\r\n    xml.emptyElement(token(\"topic-fields\"),\r\n        token(\"co_title\"), token(\"no\"),\r\n        token(\"cas_title\"), token(\"no\"),\r\n        token(\"xpath_title\"), token(\"yes\"),\r\n        token(\"text_predicates\"), token(\"no\"),\r\n        token(\"description\"), token(\"no\"),\r\n        token(\"narrative\"), token(\"no\")\r\n    );\r\n\r\n    xml.openElement(token(\"general_description\"));\r\n    xml.text(token(\"The client/server architecture of BaseX 5.72 was used \" +\r\n        \"to perform the tests. The test machine has an Intel Xeon E5345 \" +\r\n        \"with 2 Quad-Core CPUs and 32 GB RAM.\"));\r\n    xml.closeElement();\r\n    xml.openElement(token(\"ranking_description\"));\r\n    xml.text(token(\"We are using both content-based as well as \" +\r\n        \"structural-based ranking. At first, a content-based weight \" +\r\n        \"is estimated and later refined for each location step. \" +\r\n        \"The weights are derived from database meta information.\"));\r\n    xml.closeElement();\r\n    xml.openElement(token(\"indexing_description\"));\r\n    xml.text(token(\"The full-text indexes of BaseX support both an \" +\r\n        \"sped up evaluation of simple ftcontains operators as well \" +\r\n        \"as advanced features of the upcoming XQFT Recommendation. \" +\r\n        \"The indexes contain token positions and pointers on the text nodes. \" +\r\n        \"Structural information, such as location paths to the text nodes, \" +\r\n        \"are evaluated at runtime. As a consequence, our performance \" +\r\n        \"measurements include the total time both for accessing the indexes \" +\r\n        \"as well as traversing the inverted specified location paths.\"));\r\n    xml.closeElement();\r\n    xml.openElement(token(\"caching_description\"));\r\n    xml.text(token(\"Both database instances as well as the full-text \" +\r\n        \"indexes are completely disk-based and rely on the caching \" +\r\n        \"mechanisms of the operating system.\"));\r\n    xml.closeElement();\r\n  }","id":90686,"modified_method":"/**\r\n   * Creates and prints the submission file.\r\n   * @throws Exception Exception\r\n   */\r\n  private static void openSubFile() throws Exception {\r\n    sub = new PrintOutput(\"submission.xml\");\r\n    sub.println(\"<!DOCTYPE efficiency-submission SYSTEM \" +\r\n    \"'efficiency-submission.dtd'>\");\r\n    xml = new XMLSerializer(sub, false, true);\r\n\r\n    // print header in output file\r\n    xml.openElement(token(\"efficiency-submission\"),\r\n        token(\"participant-id\"), token(\"304\"),\r\n        token(\"run-id\"), token(\"1111111\"),\r\n        token(\"task\"), token(TASK[0]),\r\n        token(\"type\"), token(TYPE[0]),\r\n        token(\"query\"), token(query[0]),\r\n        token(\"sequential\"), token(\"yes\"),\r\n        token(\"no_cpu\"), token(\"2\"),\r\n        token(\"ram\"), token(\"32 GB\"),\r\n        token(\"index_size_bytes\"), token(\"7869335184\"),\r\n        token(\"indexing_time_sec\"), token(\"3028\")\r\n    );\r\n    xml.emptyElement(token(\"topic-fields\"),\r\n        token(\"co_title\"), token(\"no\"),\r\n        token(\"cas_title\"), token(\"no\"),\r\n        token(\"xpath_title\"), token(\"yes\"),\r\n        token(\"text_predicates\"), token(\"no\"),\r\n        token(\"description\"), token(\"no\"),\r\n        token(\"narrative\"), token(\"no\")\r\n    );\r\n\r\n    xml.openElement(token(\"general_description\"));\r\n    xml.text(token(\"The client/server architecture of BaseX 5.72 was used \" +\r\n        \"to perform the tests. The test machine has an Intel Xeon E5345 \" +\r\n        \"with 2 Quad-Core CPUs and 32 GB RAM.\"));\r\n    xml.closeElement();\r\n    xml.openElement(token(\"ranking_description\"));\r\n    xml.text(token(\"We are using both content-based as well as \" +\r\n        \"structural-based ranking. At first, a content-based weight \" +\r\n        \"is estimated and later refined for each location step. \" +\r\n        \"The weights are derived from database meta information.\"));\r\n    xml.closeElement();\r\n    xml.openElement(token(\"indexing_description\"));\r\n    xml.text(token(\"The full-text indexes of BaseX support both an \" +\r\n        \"sped up evaluation of simple ftcontains operators as well \" +\r\n        \"as advanced features of the upcoming XQFT Recommendation. \" +\r\n        \"The indexes contain token positions and pointers on the text nodes. \" +\r\n        \"Structural information, such as location paths to the text nodes, \" +\r\n        \"are evaluated at runtime. As a consequence, our performance \" +\r\n        \"measurements include the total time both for accessing the indexes \" +\r\n        \"as well as traversing the inverted specified location paths.\"));\r\n    xml.closeElement();\r\n    xml.openElement(token(\"caching_description\"));\r\n    xml.text(token(\"Both database instances as well as the full-text \" +\r\n        \"indexes are completely disk-based and rely on the caching \" +\r\n        \"mechanisms of the operating system.\"));\r\n    xml.closeElement();\r\n  }","commit_id":"6848762d6d2dcd930963fdf0e21b044c28e8a1dd","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param txt text\n   * @param fto full-text options\n   * @param f fast evaluation\n   * @param pr database properties\n   */\n  public Tokenizer(final byte[] txt, final FTOpt fto, final boolean f,\n      final Prop pr) {\n    this(txt, pr);\n    lc = fto.is(FTOpt.LC);\n    uc = fto.is(FTOpt.UC);\n    cs = fto.is(FTOpt.CS);\n    wc = fto.is(FTOpt.WC);\n    fz = fto.is(FTOpt.FZ);\n    sd = fto.sd;\n    fast = f;\n  }","id":90687,"modified_method":"/**\n   * Constructor.\n   * @param txt text\n   * @param fto full-text options\n   * @param f fast evaluation\n   * @param pr database properties\n   */\n  public Tokenizer(final byte[] txt, final FTOpt fto, final boolean f,\n      final Prop pr) {\n    this(txt, pr);\n    lc = fto.is(FTOpt.LC);\n    uc = fto.is(FTOpt.UC);\n    cs = fto.is(FTOpt.CS);\n    wc = fto.is(FTOpt.WC);\n    fz = fto.is(FTOpt.FZ);\n    st = fto.is(FTOpt.ST);\n    st = fto.is(FTOpt.ST);\n    dc = fto.is(FTOpt.DC);\n    sd = fto.sd;\n    fast = f;\n  }","commit_id":"6848762d6d2dcd930963fdf0e21b044c28e8a1dd","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\r\n  public void extract(final Builder build, final File f) throws IOException {\r\n    build.startElem(XML, atts.reset());\r\n    final IO io = IO.get(f.getPath());\r\n    final Parser parser = Parser.xmlParser(io, build.parser.prop);\r\n    parser.doc = false;\r\n    parser.parse(build);\r\n    build.endElem(XML);\r\n  }","id":90688,"modified_method":"@Override\r\n  public void extract(final Builder build, final File f) throws IOException {\r\n    // skip too large files\r\n    if(f.length() > build.parser.prop.num(Prop.FSTEXTMAX)) return;\r\n\r\n    final IO io = IO.get(f.getPath());\r\n    try {\r\n      // parse file in main memory first\r\n      final Parser p = Parser.xmlParser(io, build.parser.prop);\r\n      new MemBuilder(p).build();\r\n    } catch(final IOException ex) {\r\n      // XML parsing exception...\r\n      return;\r\n    }\r\n    build.startElem(XML, atts.reset());\r\n    final Parser parser = Parser.xmlParser(io, build.parser.prop);\r\n    parser.doc = false;\r\n    parser.parse(build);\r\n    build.endElem(XML);\r\n  }","commit_id":"6848762d6d2dcd930963fdf0e21b044c28e8a1dd","url":"https://github.com/BaseXdb/basex"},{"original_method":"@NotNull\n  private static PsiBuilder.Marker parseParameterList(final PsiBuilder builder) {\n    assert builder.getTokenType() == JavaTokenType.LPARENTH : builder.getTokenType();\n    final PsiBuilder.Marker paramList = builder.mark();\n    builder.advanceLexer();\n\n    PsiBuilder.Marker invalidElements = null;\n    String errorMessage = null;\n    boolean commaExpected = false;\n    int paramCount = 0;\n    while (true) {\n      final IElementType tokenType = builder.getTokenType();\n      if (tokenType == null || tokenType == JavaTokenType.RPARENTH) {\n        boolean noLastParam = !commaExpected && paramCount > 0;\n        if (noLastParam) {\n          error(builder, JavaErrorMessages.message(\"expected.identifier.or.type\"));\n        }\n        if (tokenType == JavaTokenType.RPARENTH) {\n          if (invalidElements != null) {\n            invalidElements.error(errorMessage);\n          }\n          invalidElements = null;\n          builder.advanceLexer();\n        }\n        else {\n          if (!noLastParam) {\n            if (invalidElements != null) {\n              invalidElements.error(errorMessage);\n            }\n            invalidElements = null;\n            error(builder, JavaErrorMessages.message(\"expected.rparen\"));\n          }\n        }\n        break;\n      }\n\n      if (commaExpected) {\n        if (builder.getTokenType() == JavaTokenType.COMMA) {\n          commaExpected = false;\n          if (invalidElements != null) {\n            invalidElements.error(errorMessage);\n            invalidElements = null;\n          }\n          builder.advanceLexer();\n          continue;\n        }\n      }\n      else {\n        final PsiBuilder.Marker param = parseParameter(builder, true);\n        if (param != null) {\n          commaExpected = true;\n          if (invalidElements != null) {\n            invalidElements.errorBefore(errorMessage, param);\n            invalidElements = null;\n          }\n          paramCount++;\n          continue;\n        }\n      }\n\n      if (invalidElements == null) {\n        if (builder.getTokenType() == JavaTokenType.COMMA) {\n          error(builder, JavaErrorMessages.message(\"expected.parameter\"));\n          builder.advanceLexer();\n          continue;\n        }\n        else {\n          invalidElements = builder.mark();\n          errorMessage = commaExpected ? JavaErrorMessages.message(\"expected.comma\") : JavaErrorMessages.message(\"expected.parameter\");\n        }\n      }\n\n      // adding a reference, not simple tokens allows \"Browse ..\" to work well\n      final PsiBuilder.Marker ref = ReferenceParser.parseJavaCodeReference(builder, true, true, false);\n      if (ref == null && builder.getTokenType() != null) {\n        builder.advanceLexer();\n      }\n    }\n\n    if (invalidElements != null) {\n      invalidElements.error(errorMessage);\n    }\n\n    paramList.done(JavaElementType.PARAMETER_LIST);\n    return paramList;\n  }","id":90689,"modified_method":"@NotNull\n  public static PsiBuilder.Marker parseParameterList(final PsiBuilder builder) {\n    assert builder.getTokenType() == JavaTokenType.LPARENTH : builder.getTokenType();\n    final PsiBuilder.Marker paramList = builder.mark();\n    builder.advanceLexer();\n\n    PsiBuilder.Marker invalidElements = null;\n    String errorMessage = null;\n    boolean commaExpected = false;\n    int paramCount = 0;\n    while (true) {\n      final IElementType tokenType = builder.getTokenType();\n      if (tokenType == null || tokenType == JavaTokenType.RPARENTH) {\n        boolean noLastParam = !commaExpected && paramCount > 0;\n        if (noLastParam) {\n          error(builder, JavaErrorMessages.message(\"expected.identifier.or.type\"));\n        }\n        if (tokenType == JavaTokenType.RPARENTH) {\n          if (invalidElements != null) {\n            invalidElements.error(errorMessage);\n          }\n          invalidElements = null;\n          builder.advanceLexer();\n        }\n        else {\n          if (!noLastParam) {\n            if (invalidElements != null) {\n              invalidElements.error(errorMessage);\n            }\n            invalidElements = null;\n            error(builder, JavaErrorMessages.message(\"expected.rparen\"));\n          }\n        }\n        break;\n      }\n\n      if (commaExpected) {\n        if (builder.getTokenType() == JavaTokenType.COMMA) {\n          commaExpected = false;\n          if (invalidElements != null) {\n            invalidElements.error(errorMessage);\n            invalidElements = null;\n          }\n          builder.advanceLexer();\n          continue;\n        }\n      }\n      else {\n        final PsiBuilder.Marker param = parseParameter(builder, true);\n        if (param != null) {\n          commaExpected = true;\n          if (invalidElements != null) {\n            invalidElements.errorBefore(errorMessage, param);\n            invalidElements = null;\n          }\n          paramCount++;\n          continue;\n        }\n      }\n\n      if (invalidElements == null) {\n        if (builder.getTokenType() == JavaTokenType.COMMA) {\n          error(builder, JavaErrorMessages.message(\"expected.parameter\"));\n          builder.advanceLexer();\n          continue;\n        }\n        else {\n          invalidElements = builder.mark();\n          errorMessage = commaExpected ? JavaErrorMessages.message(\"expected.comma\") : JavaErrorMessages.message(\"expected.parameter\");\n        }\n      }\n\n      // adding a reference, not simple tokens allows \"Browse ..\" to work well\n      final PsiBuilder.Marker ref = ReferenceParser.parseJavaCodeReference(builder, true, true, false);\n      if (ref == null && builder.getTokenType() != null) {\n        builder.advanceLexer();\n      }\n    }\n\n    if (invalidElements != null) {\n      invalidElements.error(errorMessage);\n    }\n\n    paramList.done(JavaElementType.PARAMETER_LIST);\n    return paramList;\n  }","commit_id":"9d20d0115ed3ef6a83835580e41c676bc516f869","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static PsiBuilder.Marker parseAnnotation(final PsiBuilder builder) {\n    assert builder.getTokenType() == JavaTokenType.AT : builder.getTokenType();\n    final PsiBuilder.Marker anno = builder.mark();\n    builder.advanceLexer();\n\n    final PsiBuilder.Marker classRef = ReferenceParser.parseJavaCodeReference(builder, true, false, false);\n    if (classRef == null) {\n      error(builder, JavaErrorMessages.message(\"expected.class.reference\"));\n    }\n\n    parseAnnotationParameterList(builder);\n\n    anno.done(JavaElementType.ANNOTATION);\n    return anno;\n  }","id":90690,"modified_method":"@NotNull\n  public static PsiBuilder.Marker parseAnnotation(final PsiBuilder builder) {\n    assert builder.getTokenType() == JavaTokenType.AT : builder.getTokenType();\n    final PsiBuilder.Marker anno = builder.mark();\n    builder.advanceLexer();\n\n    final PsiBuilder.Marker classRef = ReferenceParser.parseJavaCodeReference(builder, true, false, false);\n    if (classRef == null) {\n      error(builder, JavaErrorMessages.message(\"expected.class.reference\"));\n    }\n\n    parseAnnotationParameterList(builder);\n\n    anno.done(JavaElementType.ANNOTATION);\n    return anno;\n  }","commit_id":"9d20d0115ed3ef6a83835580e41c676bc516f869","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiBuilder.Marker parseClassFromKeyword(final PsiBuilder builder, final PsiBuilder.Marker declaration,\n                                                         final boolean isAnnotation, final Context context) {\n    final IElementType keywordTokenType = builder.getTokenType();\n    assert ElementType.CLASS_KEYWORD_BIT_SET.contains(keywordTokenType) : keywordTokenType;\n    builder.advanceLexer();\n    final boolean isEnum = (keywordTokenType == JavaTokenType.ENUM_KEYWORD);\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      error(builder, JavaErrorMessages.message(\"expected.identifier\"));\n      declaration.drop();\n      return null;\n    }\n\n    ReferenceParser.parseTypeParameters(builder);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.EXTENDS_KEYWORD, JavaElementType.EXTENDS_LIST, JavaTokenType.COMMA);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.IMPLEMENTS_KEYWORD, JavaElementType.IMPLEMENTS_LIST, JavaTokenType.COMMA);\n\n    if (builder.getTokenType() != JavaTokenType.LBRACE) {\n      final PsiBuilder.Marker error = builder.mark();\n      while (BEFORE_LBRACE_ELEMENTS_SET.contains(builder.getTokenType())) {\n        builder.advanceLexer();\n      }\n      error.error(JavaErrorMessages.message(\"expected.lbrace\"));\n    }\n\n    if (builder.getTokenType() == JavaTokenType.LBRACE) {\n      parseClassBodyWithBraces(builder, isAnnotation, isEnum);\n    }\n\n    if (context == Context.FILE) {\n      boolean declarationsAfterEnd = false;\n\n      while (builder.getTokenType() != null && builder.getTokenType() != JavaTokenType.RBRACE) {\n        final PsiBuilder.Marker position = builder.mark();\n        final PsiBuilder.Marker extra = parse(builder, Context.CLASS);\n        if (extra != null && AFTER_END_DECLARATION_SET.contains(exprType(extra))) {\n          if (!declarationsAfterEnd) {\n            error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), extra);\n          }\n          declarationsAfterEnd = true;\n          position.drop();\n        }\n        else {\n          position.rollbackTo();\n          break;\n        }\n      }\n\n      if (declarationsAfterEnd) {\n        expectOrError(builder, JavaTokenType.RBRACE, JavaErrorMessages.message(\"expected.rbrace\"));\n      }\n    }\n\n    declaration.done(JavaElementType.CLASS);\n    return declaration;\n  }","id":90691,"modified_method":"@Nullable\n  public static PsiBuilder.Marker parseClassFromKeyword(final PsiBuilder builder, final PsiBuilder.Marker declaration,\n                                                        final boolean isAnnotation, final Context context) {\n    final IElementType keywordTokenType = builder.getTokenType();\n    assert ElementType.CLASS_KEYWORD_BIT_SET.contains(keywordTokenType) : keywordTokenType;\n    builder.advanceLexer();\n    final boolean isEnum = (keywordTokenType == JavaTokenType.ENUM_KEYWORD);\n\n    if (!expect(builder, JavaTokenType.IDENTIFIER)) {\n      error(builder, JavaErrorMessages.message(\"expected.identifier\"));\n      declaration.drop();\n      return null;\n    }\n\n    ReferenceParser.parseTypeParameters(builder);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.EXTENDS_KEYWORD, JavaElementType.EXTENDS_LIST, JavaTokenType.COMMA);\n    ReferenceParser.parseReferenceList(builder, JavaTokenType.IMPLEMENTS_KEYWORD, JavaElementType.IMPLEMENTS_LIST, JavaTokenType.COMMA);\n\n    if (builder.getTokenType() != JavaTokenType.LBRACE) {\n      final PsiBuilder.Marker error = builder.mark();\n      while (BEFORE_LBRACE_ELEMENTS_SET.contains(builder.getTokenType())) {\n        builder.advanceLexer();\n      }\n      error.error(JavaErrorMessages.message(\"expected.lbrace\"));\n    }\n\n    if (builder.getTokenType() == JavaTokenType.LBRACE) {\n      parseClassBodyWithBraces(builder, isAnnotation, isEnum);\n    }\n\n    if (context == Context.FILE) {\n      boolean declarationsAfterEnd = false;\n\n      while (builder.getTokenType() != null && builder.getTokenType() != JavaTokenType.RBRACE) {\n        final PsiBuilder.Marker position = builder.mark();\n        final PsiBuilder.Marker extra = parse(builder, Context.CLASS);\n        if (extra != null && AFTER_END_DECLARATION_SET.contains(exprType(extra))) {\n          if (!declarationsAfterEnd) {\n            error(builder, JavaErrorMessages.message(\"expected.class.or.interface\"), extra);\n          }\n          declarationsAfterEnd = true;\n          position.drop();\n        }\n        else {\n          position.rollbackTo();\n          break;\n        }\n      }\n\n      if (declarationsAfterEnd) {\n        expectOrError(builder, JavaTokenType.RBRACE, JavaErrorMessages.message(\"expected.rbrace\"));\n      }\n    }\n\n    declaration.done(JavaElementType.CLASS);\n    return declaration;\n  }","commit_id":"9d20d0115ed3ef6a83835580e41c676bc516f869","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static Pair<PsiBuilder.Marker, Boolean> parseModifierList(final PsiBuilder builder) {\n    final PsiBuilder.Marker modList = builder.mark();\n    boolean isEmpty = true;\n\n    while (true) {\n      final IElementType tokenType = builder.getTokenType();\n      if (tokenType == null) break;\n      if (ElementType.MODIFIER_BIT_SET.contains(tokenType)) {\n        builder.advanceLexer();\n        isEmpty = false;\n      }\n      else if (tokenType == JavaTokenType.AT) {\n        if (ElementType.KEYWORD_BIT_SET.contains(nextTokenType(builder))) {\n          break;\n        }\n        parseAnnotation(builder);\n        isEmpty = false;\n      }\n      else {\n        break;\n      }\n    }\n\n    modList.done(JavaElementType.MODIFIER_LIST);\n    return Pair.create(modList, isEmpty);\n  }","id":90692,"modified_method":"@NotNull\n  private static Pair<PsiBuilder.Marker, Boolean> parseModifierList(final PsiBuilder builder) {\n    return parseModifierList(builder, ElementType.MODIFIER_BIT_SET);\n  }","commit_id":"9d20d0115ed3ef6a83835580e41c676bc516f869","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static PsiBuilder.Marker parseImportList(final PsiBuilder builder) {\n    final PsiBuilder.Marker list = builder.mark();\n\n    if (builder.getTokenType() == JavaTokenType.IMPORT_KEYWORD) {\n      PsiBuilder.Marker invalidElements = null;\n      while (!builder.eof()) {\n        if (IMPORT_LIST_STOPPER_SET.contains(builder.getTokenType())) break;\n\n        final PsiBuilder.Marker statement = parseImportStatement(builder);\n        if (statement != null) {\n          if (invalidElements != null) {\n            invalidElements.errorBefore(JavaErrorMessages.message(\"unexpected.token\"), statement);\n            invalidElements = null;\n          }\n          continue;\n        }\n\n        if (invalidElements == null) {\n          invalidElements = builder.mark();\n        }\n        builder.advanceLexer();\n      }\n\n      if (invalidElements != null) {\n        invalidElements.error(JavaErrorMessages.message(\"unexpected.token\"));\n      }\n    }\n\n    list.done(JavaElementType.IMPORT_LIST);\n    return list;\n  }","id":90693,"modified_method":"@NotNull\n  private static Pair<PsiBuilder.Marker, Boolean> parseImportList(final PsiBuilder builder) {\n    return parseImportList(builder, IMPORT_LIST_STOPPER_SET);\n  }","commit_id":"9d20d0115ed3ef6a83835580e41c676bc516f869","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PsiBuilder.Marker parsePackageStatement(final PsiBuilder builder) {\n    final PsiBuilder.Marker statement = builder.mark();\n\n    if (!expect(builder, JavaTokenType.PACKAGE_KEYWORD)) {\n      final PsiBuilder.Marker modList = builder.mark();\n      DeclarationParser.parseAnnotations(builder);\n      modList.done(JavaElementType.MODIFIER_LIST);\n      if (!expect(builder, JavaTokenType.PACKAGE_KEYWORD)) {\n        statement.rollbackTo();\n        return null;\n      }\n    }\n\n    final PsiBuilder.Marker ref = ReferenceParser.parseJavaCodeReference(builder, true, false, false);\n    if (ref == null) {\n      statement.rollbackTo();\n      return null;\n    }\n\n    semicolon(builder);\n\n    statement.done(JavaElementType.PACKAGE_STATEMENT);\n    return statement;\n  }","id":90694,"modified_method":"@Nullable\n  public static PsiBuilder.Marker parsePackageStatement(final PsiBuilder builder) {\n    final PsiBuilder.Marker statement = builder.mark();\n\n    if (!expect(builder, JavaTokenType.PACKAGE_KEYWORD)) {\n      final PsiBuilder.Marker modList = builder.mark();\n      DeclarationParser.parseAnnotations(builder);\n      modList.done(JavaElementType.MODIFIER_LIST);\n      if (!expect(builder, JavaTokenType.PACKAGE_KEYWORD)) {\n        statement.rollbackTo();\n        return null;\n      }\n    }\n\n    final PsiBuilder.Marker ref = ReferenceParser.parseJavaCodeReference(builder, true, false, false);\n    if (ref == null) {\n      statement.rollbackTo();\n      return null;\n    }\n\n    semicolon(builder);\n\n    statement.done(JavaElementType.PACKAGE_STATEMENT);\n    return statement;\n  }","commit_id":"9d20d0115ed3ef6a83835580e41c676bc516f869","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PsiBuilder braceMatchingBuilder(final PsiBuilder builder) {\n    return new PsiBuilderAdapter(builder) {\n      private int braceCount = 1;\n      private int lastOffset = -1;\n\n      @Override\n      public IElementType getTokenType() {\n        final IElementType tokenType = super.getTokenType();\n        if (getCurrentOffset() != lastOffset) {\n          if (tokenType == JavaTokenType.LBRACE) {\n            braceCount++;\n          }\n          else if (tokenType == JavaTokenType.RBRACE) {\n            braceCount--;\n          }\n          lastOffset = getCurrentOffset();\n        }\n        return (braceCount == 0 ? null : tokenType);\n      }\n\n      @Override\n      public boolean eof() {\n        return braceCount == 0 || super.eof();\n      }\n    };\n  }","id":90695,"modified_method":"public static PsiBuilder braceMatchingBuilder(final PsiBuilder builder) {\n    final PsiBuilder.Marker pos = builder.mark();\n\n    int braceCount = 1;\n    while (!builder.eof()) {\n      final IElementType tokenType = builder.getTokenType();\n      if (tokenType == JavaTokenType.LBRACE) braceCount++;\n      else if (tokenType == JavaTokenType.RBRACE) braceCount--;\n      if (braceCount == 0) break;\n      builder.advanceLexer();\n    }\n    final int stopAt = builder.getCurrentOffset();\n\n    pos.rollbackTo();\n\n    return stoppingBuilder(builder, stopAt);\n  }","commit_id":"9d20d0115ed3ef6a83835580e41c676bc516f869","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Release group of allocated markers.\n   *\n   * @param markers markers to drop.\n   */\n  public static void drop(final PsiBuilder.Marker... markers) {\n    for (PsiBuilder.Marker marker : markers) {\n      marker.drop();\n    }\n  }","id":90696,"modified_method":"/**\n   * Release group of allocated markers.\n   *\n   * @param markers markers to drop.\n   */\n  public static void drop(final PsiBuilder.Marker... markers) {\n    for (PsiBuilder.Marker marker : markers) {\n      if (marker != null) marker.drop();\n    }\n  }","commit_id":"9d20d0115ed3ef6a83835580e41c676bc516f869","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void abort() {\n    try {\n      close();\n    } catch(final IOException ex) {\n      Util.debug(ex);\n    }\n    DropDB.drop(meta.name, mprop);\n  }","id":90697,"modified_method":"@Override\n  public void abort() {\n    try {\n      close();\n    } catch(final IOException ex) {\n      Util.debug(ex);\n    }\n    if(meta != null) DropDB.drop(meta.name, mprop);\n  }","commit_id":"11a99a067be7e7b31ad2f18df4f8ba9477e1fffe","url":"https://github.com/BaseXdb/basex"},{"original_method":"protected void updateLayoutPriorities(PortletDataContext portletDataContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMap<Long, Layout> layouts =\n\t\t\t(Map<Long, Layout>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tLayout.class + \".layout\");\n\n\t\tMap<Long, NavigableSet<Layout>> layoutMap =\n\t\t\tnew HashMap<Long, NavigableSet<Layout>>();\n\n\t\tList<Layout> importedLayouts = new LinkedList<Layout>();\n\n\t\t// Gathering imported layouts and create a NavigableSet for each\n\t\t// parentLayoutId to handle each priority queue separately\n\n\t\tfor (Element layoutElement : _layoutElements) {\n\t\t\tString action = layoutElement.attributeValue(Constants.ACTION);\n\n\t\t\tif (action.equals(Constants.ADD)) {\n\t\t\t\tlong layoutId = GetterUtil.getLong(\n\t\t\t\t\tlayoutElement.attributeValue(\"layout-id\"));\n\n\t\t\t\tLayout layout = layouts.get(layoutId);\n\n\t\t\t\tNavigableSet<Layout> childLayouts = layoutMap.get(\n\t\t\t\t\tlayout.getParentLayoutId());\n\n\t\t\t\tif (childLayouts == null) {\n\t\t\t\t\tlayoutMap.put(\n\t\t\t\t\t\tlayout.getParentLayoutId(),\n\t\t\t\t\t\tnew TreeSet<Layout>(new LayoutPriorityComparator()));\n\t\t\t\t}\n\n\t\t\t\timportedLayouts.add(\n\t\t\t\t\tLayoutLocalServiceUtil.getLayout(layout.getPlid()));\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> groupLayouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tportletDataContext.getGroupId(),\n\t\t\tportletDataContext.isPrivateLayout());\n\n\t\tList<Layout> unmodifiedLayouts = new LinkedList<Layout>(groupLayouts);\n\n\t\tunmodifiedLayouts.removeAll(importedLayouts);\n\n\t\t// Priorities are up-to date if there are no unmodified layouts\n\n\t\tif (unmodifiedLayouts.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fill the sets with the layouts which weren't updated by the import.\n\t\t// If there isn't any updated/new layout under a parent, there is\n\t\t// nothing to do\n\n\t\tfor (Layout unmodifiedLayout : unmodifiedLayouts) {\n\t\t\tNavigableSet<Layout> childLayouts = layoutMap.get(\n\t\t\t\tunmodifiedLayout.getParentLayoutId());\n\n\t\t\tif (childLayouts != null) {\n\t\t\t\tchildLayouts.add(unmodifiedLayout);\n\t\t\t}\n\t\t}\n\n\t\tfor (Layout importedLayout : importedLayouts) {\n\t\t\tNavigableSet<Layout> childLayouts = layoutMap.get(\n\t\t\t\timportedLayout.getParentLayoutId());\n\n\t\t\tif (childLayouts.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tSortedSet<Layout> tailSet = childLayouts.tailSet(\n\t\t\t\timportedLayout, true);\n\n\t\t\tint priority = importedLayout.getPriority();\n\n\t\t\t// If a layout's priority collides with an existing one, then we\n\t\t\t// \"push it back\" by 1, and do it until there is no collision.\n\t\t\t// Break, if there was a \"hole\" in the priority queue and we don't\n\t\t\t// have to push back more layouts\n\n\t\t\tfor (Layout tailLayout : tailSet) {\n\t\t\t\tif (tailLayout.getPriority() == priority) {\n\t\t\t\t\ttailLayout.setPriority(++priority);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchildLayouts.add(importedLayout);\n\t\t}\n\n\t\tfor (NavigableSet<Layout> childLayouts : layoutMap.values()) {\n\t\t\tfor (Layout childLayout : childLayouts) {\n\t\t\t\tLayoutUtil.update(childLayout);\n\t\t\t}\n\t\t}\n\t}","id":90698,"modified_method":"protected void updateLayoutPriorities(PortletDataContext portletDataContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMap<Long, Layout> layouts =\n\t\t\t(Map<Long, Layout>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tLayout.class + \".layout\");\n\n\t\tMap<Long, NavigableSet<Layout>> navigableSets =\n\t\t\tnew HashMap<Long, NavigableSet<Layout>>();\n\n\t\tList<Layout> importedLayouts = new LinkedList<Layout>();\n\n\t\t// Gathering imported layouts and create a navigable set for each parent\n\t\t// layout ID to handle each priority queue separately\n\n\t\tfor (Element layoutElement : _layoutElements) {\n\t\t\tString action = layoutElement.attributeValue(Constants.ACTION);\n\n\t\t\tif (action.equals(Constants.ADD)) {\n\t\t\t\tlong layoutId = GetterUtil.getLong(\n\t\t\t\t\tlayoutElement.attributeValue(\"layout-id\"));\n\n\t\t\t\tLayout layout = layouts.get(layoutId);\n\n\t\t\t\tNavigableSet<Layout> navigableSet = navigableSets.get(\n\t\t\t\t\tlayout.getParentLayoutId());\n\n\t\t\t\tif (navigableSet == null) {\n\t\t\t\t\tnavigableSets.put(\n\t\t\t\t\t\tlayout.getParentLayoutId(),\n\t\t\t\t\t\tnew TreeSet<Layout>(new LayoutPriorityComparator()));\n\t\t\t\t}\n\n\t\t\t\timportedLayouts.add(\n\t\t\t\t\tLayoutLocalServiceUtil.getLayout(layout.getPlid()));\n\t\t\t}\n\t\t}\n\n\t\tList<Layout> unmodifiedLayouts = new LinkedList<Layout>(\n\t\t\tLayoutLocalServiceUtil.getLayouts(\n\t\t\t\tportletDataContext.getGroupId(),\n\t\t\t\tportletDataContext.isPrivateLayout()));\n\n\t\tunmodifiedLayouts.removeAll(importedLayouts);\n\n\t\t// Priorities are up to date if there are no unmodified layouts\n\n\t\tif (unmodifiedLayouts.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fill the navigable sets with layouts that were not updated by the\n\t\t// import\n\n\t\tfor (Layout unmodifiedLayout : unmodifiedLayouts) {\n\t\t\tNavigableSet<Layout> navigableSet = navigableSets.get(\n\t\t\t\tunmodifiedLayout.getParentLayoutId());\n\n\t\t\tif (navigableSet != null) {\n\t\t\t\tnavigableSet.add(unmodifiedLayout);\n\t\t\t}\n\t\t}\n\n\t\tfor (Layout importedLayout : importedLayouts) {\n\t\t\tNavigableSet<Layout> navigableSet = navigableSets.get(\n\t\t\t\timportedLayout.getParentLayoutId());\n\n\t\t\tif (navigableSet.isEmpty()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Ensure that priorities are unique\n\n\t\t\tSet<Layout> tailLayouts = navigableSet.tailSet(\n\t\t\t\timportedLayout, true);\n\n\t\t\tint priority = importedLayout.getPriority();\n\n\t\t\tfor (Layout tailLayout : tailLayouts) {\n\t\t\t\tif (tailLayout.getPriority() == priority) {\n\t\t\t\t\ttailLayout.setPriority(++priority);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnavigableSet.add(importedLayout);\n\t\t}\n\n\t\tfor (NavigableSet<Layout> navigableSet : navigableSets.values()) {\n\t\t\tfor (Layout layout : navigableSet) {\n\t\t\t\tLayoutUtil.update(layout);\n\t\t\t}\n\t\t}\n\t}","commit_id":"708e7104c77d1b87be6b5c3f00fb3dabb657d910","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int compare(Object obj1, Object obj2) {\n\t\tLayout layout1 = (Layout)obj1;\n\t\tLayout layout2 = (Layout)obj2;\n\n\t\tint value = 0;\n\n\t\tint priority1 = layout1 == null ? -1 : layout1.getPriority();\n\t\tint priority2 = layout2 == null ? -1 : layout2.getPriority();\n\n\t\tif (priority1 > priority2) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (priority1 < priority2) {\n\t\t\tvalue = -1;\n\t\t}\n\t\telse {\n\t\t\tif (_layout != null) {\n\t\t\t\tif (_layout.equals(layout1)) {\n\t\t\t\t\tif (_lessThan) {\n\t\t\t\t\t\tvalue = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_layout.equals(layout2)) {\n\t\t\t\t\tif (_lessThan) {\n\t\t\t\t\t\tvalue = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_ascending) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","id":90699,"modified_method":"@Override\n\tpublic int compare(Object obj1, Object obj2) {\n\t\tLayout layout1 = (Layout)obj1;\n\t\tLayout layout2 = (Layout)obj2;\n\n\t\tint value = 0;\n\n\t\tint priority1 = -1;\n\n\t\tif (layout1 != null) {\n\t\t\tpriority1 = layout1.getPriority();\n\t\t}\n\n\t\tint priority2 = -1;\n\n\t\tif (layout1 != null) {\n\t\t\tpriority2 = layout1.getPriority();\n\t\t}\n\n\t\tif (priority1 > priority2) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (priority1 < priority2) {\n\t\t\tvalue = -1;\n\t\t}\n\t\telse {\n\t\t\tif (_layout != null) {\n\t\t\t\tif (_layout.equals(layout1)) {\n\t\t\t\t\tif (_lessThan) {\n\t\t\t\t\t\tvalue = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_layout.equals(layout2)) {\n\t\t\t\t\tif (_lessThan) {\n\t\t\t\t\t\tvalue = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_ascending) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","commit_id":"708e7104c77d1b87be6b5c3f00fb3dabb657d910","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic int compare(Object obj1, Object obj2) {\n\t\tLayout layout1 = (Layout)obj1;\n\t\tLayout layout2 = (Layout)obj2;\n\n\t\tint value = 0;\n\n\t\tint priority1 = layout1.getPriority();\n\t\tint priority2 = layout2.getPriority();\n\n\t\tif (priority1 > priority2) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (priority1 < priority2) {\n\t\t\tvalue = -1;\n\t\t}\n\t\telse {\n\t\t\tif (_layout != null) {\n\t\t\t\tif (_layout.equals(layout1)) {\n\t\t\t\t\tif (_lessThan) {\n\t\t\t\t\t\tvalue = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_layout.equals(layout2)) {\n\t\t\t\t\tif (_lessThan) {\n\t\t\t\t\t\tvalue = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_ascending) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","id":90700,"modified_method":"@Override\n\tpublic int compare(Object obj1, Object obj2) {\n\t\tLayout layout1 = (Layout)obj1;\n\t\tLayout layout2 = (Layout)obj2;\n\n\t\tint value = 0;\n\n\t\tint priority1 = layout1 == null ? -1 : layout1.getPriority();\n\t\tint priority2 = layout2 == null ? -1 : layout2.getPriority();\n\n\t\tif (priority1 > priority2) {\n\t\t\tvalue = 1;\n\t\t}\n\t\telse if (priority1 < priority2) {\n\t\t\tvalue = -1;\n\t\t}\n\t\telse {\n\t\t\tif (_layout != null) {\n\t\t\t\tif (_layout.equals(layout1)) {\n\t\t\t\t\tif (_lessThan) {\n\t\t\t\t\t\tvalue = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_layout.equals(layout2)) {\n\t\t\t\t\tif (_lessThan) {\n\t\t\t\t\t\tvalue = -1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvalue = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_ascending) {\n\t\t\treturn value;\n\t\t}\n\t\telse {\n\t\t\treturn -value;\n\t\t}\n\t}","commit_id":"6aab095b89390c32d89e2b6942abcde57f9f8d00","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n    protected void populateModel(final OperationContext context, final ModelNode operation, final Resource resource) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String path = address.getLastElement().getValue();\n        final String name = address.getElement(address.size() - 2).getValue();\n        ModelNode content = operation.get(CONTENT);\n        final byte[] hash;\n        if (content.hasDefined(HASH)) {\n            managedContentValidator.validate(content);\n            hash = content.require(HASH).asBytes();\n            addFromHash(hash, name, path, context);\n        } else {\n            hash = addFromContentAdditionParameter(context, content);\n        }\n        final ModelNode slave = operation.clone();\n        slave.get(CONTENT).clear();\n        slave.get(CONTENT).get(HASH).set(hash);\n\n        context.attach(OperationAttachments.SLAVE_SERVER_OPERATION, slave);\n\n\n        ModelNode modified = operation.clone();\n        modified.get(CONTENT).clone();\n        modified.get(CONTENT).set(hash);\n        for (AttributeDefinition attr : ContentDefinition.attributes()) {\n            attr.validateAndSet(modified, resource.getModel());\n        }\n        if (!contentRepository.syncContent(hash)) {\n            throw ServerMessages.MESSAGES.noSuchDeploymentContent(Arrays.toString(hash));\n        }\n    }","id":90701,"modified_method":"@Override\n    protected void populateModel(final OperationContext context, final ModelNode operation, final Resource resource) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String path = address.getLastElement().getValue();\n        final String name = address.getElement(address.size() - 2).getValue();\n        final ModelNode content = operation.get(CONTENT);\n        final byte[] hash;\n        if (content.hasDefined(HASH)) {\n            managedContentValidator.validate(content);\n            hash = content.require(HASH).asBytes();\n            addFromHash(hash, name, path, context);\n        } else {\n            hash = addFromContentAdditionParameter(context, content);\n\n            final ModelNode slave = operation.clone();\n            slave.get(CONTENT).clear();\n            slave.get(CONTENT).get(HASH).set(hash);\n\n            List<DomainOperationTransformer> transformers = context.getAttachment(OperationAttachments.SLAVE_SERVER_OPERATION_TRANSFORMERS);\n            if(transformers == null) {\n                context.attach(OperationAttachments.SLAVE_SERVER_OPERATION_TRANSFORMERS, transformers = new ArrayList<DomainOperationTransformer>());\n            }\n            transformers.add(new CompositeOperationAwareTransformer(slave));\n        }\n\n\n\n        ModelNode modified = operation.clone();\n        modified.get(CONTENT).clone();\n        modified.get(CONTENT).set(hash);\n        for (AttributeDefinition attr : ContentDefinition.attributes()) {\n            attr.validateAndSet(modified, resource.getModel());\n        }\n        if (!contentRepository.syncContent(hash)) {\n            throw ServerMessages.MESSAGES.noSuchDeploymentContent(Arrays.toString(hash));\n        }\n    }","commit_id":"0b77f89a79d4ae54f54379bd86d8c000c6fb6ef7","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void installServices(final OperationContext context, final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers, final String name, final String deploymentOverlay, final boolean regularExpression, final DeploymentOverlayPriority priority) {\n        final DeploymentOverlayLinkService service = new DeploymentOverlayLinkService(name, regularExpression, priority);\n\n        final ServiceName serviceName = DeploymentOverlayLinkService.SERVICE_NAME.append(name);\n        ServiceBuilder<DeploymentOverlayLinkService> builder = context.getServiceTarget().addService(serviceName, service)\n                .addDependency(DeploymentOverlayIndexService.SERVICE_NAME, DeploymentOverlayIndexService.class, service.getDeploymentOverlayIndexServiceInjectedValue())\n                .addDependency(DeploymentOverlayService.SERVICE_NAME.append(deploymentOverlay), DeploymentOverlayService.class, service.getDeploymentOverlayServiceInjectedValue());\n        if(verificationHandler != null) {\n            builder.addListener(verificationHandler);\n        }\n        final ServiceController<DeploymentOverlayLinkService> controller = builder.install();\n        if(newControllers != null) {\n            newControllers.add(controller);\n        }\n    }","id":90702,"modified_method":"static void installServices(final OperationContext context, final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers, final String name, final String deploymentOverlay, final boolean regularExpression, final DeploymentOverlayPriority priority) {\n        final DeploymentOverlayLinkService service = new DeploymentOverlayLinkService(name, regularExpression, priority);\n\n        final ServiceName serviceName = DeploymentOverlayLinkService.SERVICE_NAME.append(deploymentOverlay).append(name);\n        ServiceBuilder<DeploymentOverlayLinkService> builder = context.getServiceTarget().addService(serviceName, service)\n                .addDependency(DeploymentOverlayIndexService.SERVICE_NAME, DeploymentOverlayIndexService.class, service.getDeploymentOverlayIndexServiceInjectedValue())\n                .addDependency(DeploymentOverlayService.SERVICE_NAME.append(deploymentOverlay), DeploymentOverlayService.class, service.getDeploymentOverlayServiceInjectedValue());\n        if(verificationHandler != null) {\n            builder.addListener(verificationHandler);\n        }\n        final ServiceController<DeploymentOverlayLinkService> controller = builder.install();\n        if(newControllers != null) {\n            newControllers.add(controller);\n        }\n    }","commit_id":"0b77f89a79d4ae54f54379bd86d8c000c6fb6ef7","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final ServiceName serviceName = DeploymentOverlayLinkService.SERVICE_NAME.append(name);\n        context.removeService(serviceName);\n    }","id":90703,"modified_method":"@Override\n    protected void performRuntime(final OperationContext context, final ModelNode operation, final ModelNode model) throws OperationFailedException {\n        final PathAddress address = PathAddress.pathAddress(operation.get(OP_ADDR));\n        final String name = address.getLastElement().getValue();\n        final String deploymentOverlay =address.getElement(address.size() - 2).getValue();\n        final ServiceName serviceName = DeploymentOverlayLinkService.SERVICE_NAME.append(deploymentOverlay).append(name);\n        context.removeService(serviceName);\n    }","commit_id":"0b77f89a79d4ae54f54379bd86d8c000c6fb6ef7","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void setupDeploymentOverride() throws Exception {\n\n        ModelNode op = new ModelNode();\n        op.get(ModelDescriptionConstants.OP_ADDR).set(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_OVERLAY);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        executeOnMaster(op);\n\n\n        //add an override that will not be linked via a wildcard\n        //add the content\n        op = new ModelNode();\n        OperationBuilder builder = new OperationBuilder(op, true);\n        ModelNode addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_OVERLAY);\n        addr.add(ModelDescriptionConstants.CONTENT, \"WEB-INF/web.xml\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        op.get(ModelDescriptionConstants.CONTENT).get(INPUT_STREAM_INDEX).set(0);\n        builder.addInputStream(getClass().getClassLoader().getResourceAsStream(\"deploymentoverlay/override.xml\"));\n        executeOnMaster(builder.build());\n\n        //add the non-wildcard link to the server group\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.SERVER_GROUP, \"main-server-group\");\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_OVERLAY);\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        executeOnMaster(op);\n\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.SERVER_GROUP, \"main-server-group\");\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_OVERLAY);\n        addr.add(ModelDescriptionConstants.DEPLOYMENT, \"test.war\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        executeOnMaster(op);\n\n        //add the deployment overlay that will be linked to a single server\n        op = new ModelNode();\n        op.get(ModelDescriptionConstants.OP_ADDR).set(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_SERVER);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        executeOnMaster(op);\n\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_SERVER);\n        addr.add(ModelDescriptionConstants.CONTENT, \"WEB-INF/web.xml\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        op.get(ModelDescriptionConstants.CONTENT).get(ModelDescriptionConstants.BYTES).set(FileUtils.readFile(getClass().getClassLoader().getResource( \"deploymentoverlay/wildcard-override.xml\")).getBytes());\n        executeOnMaster(op);\n\n        op = new ModelNode();\n        op.get(ModelDescriptionConstants.OP_ADDR).set(new ModelNode());\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.UPLOAD_DEPLOYMENT_BYTES);\n        op.get(ModelDescriptionConstants.BYTES).set(\"new file\".getBytes());\n        final ModelNode result = executeOnMaster(op);\n\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_SERVER);\n        addr.add(ModelDescriptionConstants.CONTENT, \"WEB-INF/classes/wildcard-new-file\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        op.get(ModelDescriptionConstants.CONTENT).get(HASH).set(result);\n        executeOnMaster(op);\n/*\n        //add the per server link\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.HOST, \"master\");\n        addr.add(ModelDescriptionConstants.SERVER, \"main-one\" );\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY_LINK, TEST_SERVER);\n        op = new ModelNode();\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        op.get(ModelDescriptionConstants.DEPLOYMENT).set(\"*.war\");\n        op.get(ModelDescriptionConstants.DEPLOYMENT_OVERLAY).set(TEST_SERVER);\n        executeOnMaster(op);*/\n    }","id":90704,"modified_method":"public void setupDeploymentOverride() throws Exception {\n\n        ModelNode op = new ModelNode();\n        op.get(ModelDescriptionConstants.OP_ADDR).set(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_OVERLAY);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        executeOnMaster(op);\n\n\n        //add an override that will not be linked via a wildcard\n        //add the content\n        op = new ModelNode();\n        OperationBuilder builder = new OperationBuilder(op, true);\n        ModelNode addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_OVERLAY);\n        addr.add(ModelDescriptionConstants.CONTENT, \"WEB-INF/web.xml\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        op.get(ModelDescriptionConstants.CONTENT).get(INPUT_STREAM_INDEX).set(0);\n        builder.addInputStream(getClass().getClassLoader().getResourceAsStream(\"deploymentoverlay/override.xml\"));\n        executeOnMaster(builder.build());\n\n        //add the non-wildcard link to the server group\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.SERVER_GROUP, \"main-server-group\");\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_OVERLAY);\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        executeOnMaster(op);\n\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.SERVER_GROUP, \"main-server-group\");\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_OVERLAY);\n        addr.add(ModelDescriptionConstants.DEPLOYMENT, \"test.war\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        executeOnMaster(op);\n\n\n        //add the wildard link\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n\n        op = new ModelNode();\n        op.get(ModelDescriptionConstants.OP_ADDR).set(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_WILDCARD);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        steps.add(op);\n\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_WILDCARD);\n        addr.add(ModelDescriptionConstants.CONTENT, \"WEB-INF/web.xml\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        op.get(ModelDescriptionConstants.CONTENT).get(ModelDescriptionConstants.BYTES).set(FileUtils.readFile(getClass().getClassLoader().getResource( \"deploymentoverlay/wildcard-override.xml\")).getBytes());\n\n        steps.add(op);\n\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_WILDCARD);\n        addr.add(ModelDescriptionConstants.CONTENT, \"WEB-INF/classes/wildcard-new-file\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        op.get(ModelDescriptionConstants.CONTENT).get(ModelDescriptionConstants.INPUT_STREAM_INDEX).set(0);\n        opBuilder.addInputStream(new ByteArrayInputStream(\"new file\".getBytes()));\n        steps.add(op);\n\n        //add the non-wildcard link to the server group\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.SERVER_GROUP, \"main-server-group\");\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_WILDCARD);\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        steps.add(op);\n\n        op = new ModelNode();\n        addr = new ModelNode();\n        addr.add(ModelDescriptionConstants.SERVER_GROUP, \"main-server-group\");\n        addr.add(ModelDescriptionConstants.DEPLOYMENT_OVERLAY, TEST_WILDCARD);\n        addr.add(ModelDescriptionConstants.DEPLOYMENT, \".*\\\\.war\");\n        op.get(ModelDescriptionConstants.OP_ADDR).set(addr);\n        op.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.ADD);\n        op.get(ModelDescriptionConstants.REGULAR_EXPRESSION).set(true);\n        steps.add(op);\n\n        executeOnMaster(opBuilder.build());\n    }","commit_id":"0b77f89a79d4ae54f54379bd86d8c000c6fb6ef7","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n\n        if (context.hasFailureDescription()) {\n            // abort\n            context.setRollbackOnly();\n            context.completeStep();\n            return;\n        }\n\n        final Set<String> outstanding = new HashSet<String>(hostProxies.keySet());\n        final List<TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation>> results = new ArrayList<TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation>>();\n        final Map<String, HostControllerUpdateTask.ExecutedHostRequest> finalResults = new HashMap<String, HostControllerUpdateTask.ExecutedHostRequest>();\n        final HostControllerUpdateTask.ProxyOperationListener listener = new HostControllerUpdateTask.ProxyOperationListener();\n        for (Map.Entry<String, ProxyController> entry : hostProxies.entrySet()) {\n            // Create the proxy task\n            final String host = entry.getKey();\n            final TransformingProxyController proxyController = (TransformingProxyController) entry.getValue();\n            ModelNode op = context.getAttachment(OperationAttachments.SLAVE_SERVER_OPERATION);\n            if(op == null) {\n                op = operation;\n            }\n            final HostControllerUpdateTask task = new HostControllerUpdateTask(host, op.clone(), context, proxyController);\n            // Execute the operation on the remote host\n            final HostControllerUpdateTask.ExecutedHostRequest finalResult = task.execute(listener);\n            finalResults.put(host, finalResult);\n        }\n\n        // Wait for all hosts to reach the prepared state\n        boolean interrupted = false;\n        try {\n            try {\n                while(outstanding.size() > 0) {\n                    final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared = listener.retrievePreparedOperation();\n                    final String hostName = prepared.getOperation().getName();\n                    if(! outstanding.remove(hostName)) {\n                        continue;\n                    }\n                    final ModelNode preparedResult = prepared.getPreparedResult();\n                    if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {\n                        HOST_CONTROLLER_LOGGER.tracef(\"Preliminary result for remote host %s is %s\", hostName, preparedResult);\n                    }\n                    domainOperationContext.addHostControllerResult(hostName, preparedResult);\n                    results.add(prepared);\n                }\n            } catch (InterruptedException ie) {\n                interrupted = true;\n                // Set rollback only\n                domainOperationContext.setFailureReported(true);\n                // Rollback all HCs\n                for(final HostControllerUpdateTask.ExecutedHostRequest finalResult : finalResults.values()) {\n                    finalResult.asyncCancel();\n                }\n                // Wait that all hosts are rolled back!?\n                for(final Map.Entry<String, HostControllerUpdateTask.ExecutedHostRequest> entry : finalResults.entrySet()) {\n                    final String hostName = entry.getKey();\n                    try {\n                        final HostControllerUpdateTask.ExecutedHostRequest request = entry.getValue();\n                        final ModelNode result = request.getFinalResult().get();\n                        final ModelNode transformedResult = request.transformResult(result);\n                        domainOperationContext.addHostControllerResult(hostName, transformedResult);\n                    } catch (Exception e) {\n                        final ModelNode result = new ModelNode();\n                        result.get(OUTCOME).set(FAILED);\n                        if (e instanceof InterruptedException) {\n                            result.get(FAILURE_DESCRIPTION).set(MESSAGES.interruptedAwaitingResultFromHost(entry.getKey()));\n                            interrupted = true;\n                        } else {\n                            result.get(FAILURE_DESCRIPTION).set(MESSAGES.exceptionAwaitingResultFromHost(entry.getKey(), e.getMessage()));\n                        }\n                        domainOperationContext.addHostControllerResult(hostName, result);\n                    }\n                }\n            }\n\n            context.completeStep();\n\n        } finally {\n            try {\n                // Inform the remote hosts whether to commit or roll back their updates\n                // Do this in parallel\n                boolean rollback = domainOperationContext.isCompleteRollback();\n                for(final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared : results) {\n                    if(prepared.isDone()) {\n                        continue;\n                    }\n                    if(! rollback) {\n                        prepared.commit();\n                    } else {\n                        prepared.rollback();\n                    }\n                }\n                // Now get the final results from the hosts\n                for(final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared : results) {\n                    final String hostName = prepared.getOperation().getName();\n                    try {\n                        final ModelNode finalResult = prepared.getFinalResult().get();\n                        domainOperationContext.addHostControllerResult(hostName, finalResult);\n\n                        if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {\n                            HOST_CONTROLLER_LOGGER.tracef(\"Final result for remote host %s is %s\", hostName, finalResult);\n                        }\n                    } catch (InterruptedException e) {\n                        interrupted = true;\n                        CONTROLLER_LOGGER.interruptedAwaitingFinalResponse(hostName);\n                    } catch (ExecutionException e) {\n                        CONTROLLER_LOGGER.caughtExceptionAwaitingFinalResponse(e.getCause(), hostName);\n                    }\n                }\n            } finally {\n                if (interrupted) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }","id":90705,"modified_method":"@Override\n    public void execute(final OperationContext context, final ModelNode operation) throws OperationFailedException {\n\n        if (context.hasFailureDescription()) {\n            // abort\n            context.setRollbackOnly();\n            context.completeStep();\n            return;\n        }\n\n        final Set<String> outstanding = new HashSet<String>(hostProxies.keySet());\n        final List<TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation>> results = new ArrayList<TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation>>();\n        final Map<String, HostControllerUpdateTask.ExecutedHostRequest> finalResults = new HashMap<String, HostControllerUpdateTask.ExecutedHostRequest>();\n        final HostControllerUpdateTask.ProxyOperationListener listener = new HostControllerUpdateTask.ProxyOperationListener();\n        for (Map.Entry<String, ProxyController> entry : hostProxies.entrySet()) {\n            // Create the proxy task\n            final String host = entry.getKey();\n            final TransformingProxyController proxyController = (TransformingProxyController) entry.getValue();\n            List<DomainOperationTransformer> transformers = context.getAttachment(OperationAttachments.SLAVE_SERVER_OPERATION_TRANSFORMERS);\n            ModelNode op = operation;\n            if(transformers != null) {\n                for(final DomainOperationTransformer transformer : transformers) {\n                    op = transformer.transform(context, op);\n                }\n            }\n            final HostControllerUpdateTask task = new HostControllerUpdateTask(host, op.clone(), context, proxyController);\n            // Execute the operation on the remote host\n            final HostControllerUpdateTask.ExecutedHostRequest finalResult = task.execute(listener);\n            finalResults.put(host, finalResult);\n        }\n\n        // Wait for all hosts to reach the prepared state\n        boolean interrupted = false;\n        try {\n            try {\n                while(outstanding.size() > 0) {\n                    final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared = listener.retrievePreparedOperation();\n                    final String hostName = prepared.getOperation().getName();\n                    if(! outstanding.remove(hostName)) {\n                        continue;\n                    }\n                    final ModelNode preparedResult = prepared.getPreparedResult();\n                    if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {\n                        HOST_CONTROLLER_LOGGER.tracef(\"Preliminary result for remote host %s is %s\", hostName, preparedResult);\n                    }\n                    domainOperationContext.addHostControllerResult(hostName, preparedResult);\n                    results.add(prepared);\n                }\n            } catch (InterruptedException ie) {\n                interrupted = true;\n                // Set rollback only\n                domainOperationContext.setFailureReported(true);\n                // Rollback all HCs\n                for(final HostControllerUpdateTask.ExecutedHostRequest finalResult : finalResults.values()) {\n                    finalResult.asyncCancel();\n                }\n                // Wait that all hosts are rolled back!?\n                for(final Map.Entry<String, HostControllerUpdateTask.ExecutedHostRequest> entry : finalResults.entrySet()) {\n                    final String hostName = entry.getKey();\n                    try {\n                        final HostControllerUpdateTask.ExecutedHostRequest request = entry.getValue();\n                        final ModelNode result = request.getFinalResult().get();\n                        final ModelNode transformedResult = request.transformResult(result);\n                        domainOperationContext.addHostControllerResult(hostName, transformedResult);\n                    } catch (Exception e) {\n                        final ModelNode result = new ModelNode();\n                        result.get(OUTCOME).set(FAILED);\n                        if (e instanceof InterruptedException) {\n                            result.get(FAILURE_DESCRIPTION).set(MESSAGES.interruptedAwaitingResultFromHost(entry.getKey()));\n                            interrupted = true;\n                        } else {\n                            result.get(FAILURE_DESCRIPTION).set(MESSAGES.exceptionAwaitingResultFromHost(entry.getKey(), e.getMessage()));\n                        }\n                        domainOperationContext.addHostControllerResult(hostName, result);\n                    }\n                }\n            }\n\n            context.completeStep();\n\n        } finally {\n            try {\n                // Inform the remote hosts whether to commit or roll back their updates\n                // Do this in parallel\n                boolean rollback = domainOperationContext.isCompleteRollback();\n                for(final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared : results) {\n                    if(prepared.isDone()) {\n                        continue;\n                    }\n                    if(! rollback) {\n                        prepared.commit();\n                    } else {\n                        prepared.rollback();\n                    }\n                }\n                // Now get the final results from the hosts\n                for(final TransactionalProtocolClient.PreparedOperation<HostControllerUpdateTask.ProxyOperation> prepared : results) {\n                    final String hostName = prepared.getOperation().getName();\n                    try {\n                        final ModelNode finalResult = prepared.getFinalResult().get();\n                        domainOperationContext.addHostControllerResult(hostName, finalResult);\n\n                        if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {\n                            HOST_CONTROLLER_LOGGER.tracef(\"Final result for remote host %s is %s\", hostName, finalResult);\n                        }\n                    } catch (InterruptedException e) {\n                        interrupted = true;\n                        CONTROLLER_LOGGER.interruptedAwaitingFinalResponse(hostName);\n                    } catch (ExecutionException e) {\n                        CONTROLLER_LOGGER.caughtExceptionAwaitingFinalResponse(e.getCause(), hostName);\n                    }\n                }\n            } finally {\n                if (interrupted) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n        }\n    }","commit_id":"0b77f89a79d4ae54f54379bd86d8c000c6fb6ef7","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Map<Set<ServerIdentity>, ModelNode> getServerOperations(OperationContext context, ModelNode originalOperation, PathAddress address) {\n        if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {\n            HOST_CONTROLLER_LOGGER.tracef(\"Resolving %s\", originalOperation);\n        }\n\n        ModelNode operation = context.getAttachment(OperationAttachments.SLAVE_SERVER_OPERATION);\n        if(operation == null) {\n            operation = originalOperation;\n        }\n\n        Set<ModelNode> dontPropagate = context.getAttachment(DONT_PROPAGATE_TO_SERVERS_ATTACHMENT);\n        if (dontPropagate != null && dontPropagate.contains(operation)) {\n            return Collections.emptyMap();\n        }\n\n        final ModelNode domain = Resource.Tools.readModel(context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS, true));\n        final ModelNode host = domain.get(HOST, localHostName);\n        if (address.size() == 0) {\n            return resolveDomainRootOperation(operation, domain, host);\n        } else {\n            DomainKey domainKey = DomainKey.forName(address.getElement(0).getKey());\n            switch (domainKey) {\n                case EXTENSION: {\n                    Set<ServerIdentity> allServers = getAllRunningServers(host, localHostName, serverProxies);\n                    return Collections.singletonMap(allServers, operation);\n                }\n                case DEPLOYMENT: {\n                    return Collections.emptyMap();\n                }\n                case PATH: {\n                    return getServerPathOperations(operation, address, host, true);\n                }\n                case SYSTEM_PROPERTY: {\n                    return getServerSystemPropertyOperations(operation, address, Level.DOMAIN, domain, null, host);\n                }\n                case PROFILE: {\n                    return getServerProfileOperations(operation, address, domain, host);\n                }\n                case INTERFACE: {\n                    return getServerInterfaceOperations(operation, address, host, true);\n                }\n                case SOCKET_BINDING_GROUP: {\n                    return getServerSocketBindingGroupOperations(operation, address, domain, host);\n                }\n                case SERVER_GROUP: {\n                    return getServerGroupOperations(operation, address, domain, host);\n                }\n                case MANAGMENT_CLIENT_CONTENT: {\n                    return Collections.emptyMap();\n                }\n                case HOST: {\n                    return getServerHostOperations(operation, address, domain, host);\n                }\n                case DEPLOYMENT_OVERLAY: {\n                    return getDeploymentOverlayOperations(operation, host);\n                }\n                default:\n                    throw MESSAGES.unexpectedInitialPathKey(address.getElement(0).getKey());\n            }\n        }\n    }","id":90706,"modified_method":"public Map<Set<ServerIdentity>, ModelNode> getServerOperations(OperationContext context, ModelNode originalOperation, PathAddress address) {\n        if (HOST_CONTROLLER_LOGGER.isTraceEnabled()) {\n            HOST_CONTROLLER_LOGGER.tracef(\"Resolving %s\", originalOperation);\n        }\n\n        List<DomainOperationTransformer> transformers = context.getAttachment(OperationAttachments.SLAVE_SERVER_OPERATION_TRANSFORMERS);\n        ModelNode operation = originalOperation;\n        if(transformers != null) {\n            for(DomainOperationTransformer transformer : transformers) {\n                operation = transformer.transform(context, operation);\n            }\n        }\n\n        Set<ModelNode> dontPropagate = context.getAttachment(DONT_PROPAGATE_TO_SERVERS_ATTACHMENT);\n        if (dontPropagate != null && dontPropagate.contains(operation)) {\n            return Collections.emptyMap();\n        }\n\n        final ModelNode domain = Resource.Tools.readModel(context.readResourceFromRoot(PathAddress.EMPTY_ADDRESS, true));\n        final ModelNode host = domain.get(HOST, localHostName);\n        if (address.size() == 0) {\n            return resolveDomainRootOperation(operation, domain, host);\n        } else {\n            DomainKey domainKey = DomainKey.forName(address.getElement(0).getKey());\n            switch (domainKey) {\n                case EXTENSION: {\n                    Set<ServerIdentity> allServers = getAllRunningServers(host, localHostName, serverProxies);\n                    return Collections.singletonMap(allServers, operation);\n                }\n                case DEPLOYMENT: {\n                    return Collections.emptyMap();\n                }\n                case PATH: {\n                    return getServerPathOperations(operation, address, host, true);\n                }\n                case SYSTEM_PROPERTY: {\n                    return getServerSystemPropertyOperations(operation, address, Level.DOMAIN, domain, null, host);\n                }\n                case PROFILE: {\n                    return getServerProfileOperations(operation, address, domain, host);\n                }\n                case INTERFACE: {\n                    return getServerInterfaceOperations(operation, address, host, true);\n                }\n                case SOCKET_BINDING_GROUP: {\n                    return getServerSocketBindingGroupOperations(operation, address, domain, host);\n                }\n                case SERVER_GROUP: {\n                    return getServerGroupOperations(operation, address, domain, host);\n                }\n                case MANAGMENT_CLIENT_CONTENT: {\n                    return Collections.emptyMap();\n                }\n                case HOST: {\n                    return getServerHostOperations(operation, address, domain, host);\n                }\n                case DEPLOYMENT_OVERLAY: {\n                    return getDeploymentOverlayOperations(operation, host);\n                }\n                default:\n                    throw MESSAGES.unexpectedInitialPathKey(address.getElement(0).getKey());\n            }\n        }\n    }","commit_id":"0b77f89a79d4ae54f54379bd86d8c000c6fb6ef7","url":"https://github.com/wildfly/wildfly"},{"original_method":"public DefaultMessageAdapter(Object message, UMOMessageAdapter previous)\n    {\n        if (previous != null)\n        {\n            id = previous.getUniqueId();\n\n            if (message == null)\n            {\n                this.message = NullPayload.getInstance();\n            }\n            else\n            {\n                this.message = message;\n            }\n            for (Iterator iterator = previous.getAttachmentNames().iterator(); iterator.hasNext();)\n            {\n                String name = (String) iterator.next();\n                try\n                {\n                    addAttachment(name, previous.getAttachment(name));\n                }\n                catch (Exception e)\n                {\n                    throw new MuleRuntimeException(CoreMessages.failedToReadPayload(), e);\n                }\n            }\n            for (Iterator iterator = previous.getPropertyNames().iterator(); iterator.hasNext();)\n            {\n                String name = (String) iterator.next();\n                try\n                {\n                    setProperty(name, previous.getProperty(name));\n                }\n                catch (Exception e)\n                {\n                    throw new MuleRuntimeException(CoreMessages.failedToReadPayload(), e);\n                }\n            }\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"previousAdapter may not be null\");\n        }\n    }","id":90707,"modified_method":"public DefaultMessageAdapter(Object message, UMOMessageAdapter previous)\n    {\n        if (previous != null)\n        {\n            id = previous.getUniqueId();\n\n            if (message == null)\n            {\n                this.message = NullPayload.getInstance();\n            }\n            else\n            {\n                this.message = message;\n            }\n            // MULE-1564\n            // this is an iterator over a concurrent map and so is weakly consistent (not fail-safe)\n            // that means we don't get errors here, but may see changed values.\n            // so we can make this safe to null values (although not predictable) by simply checking values\n            for (Iterator iterator = previous.getAttachmentNames().iterator(); iterator.hasNext();)\n            {\n                String name = (String) iterator.next();\n                try\n                {\n                    DataHandler dh = previous.getAttachment(name);\n                    if (null == dh)\n                    {\n                        logger.warn(\"Detected concurrent access to attachment \" + name + \" for \" + previous);\n                    }\n                    else\n                    {\n                        addAttachment(name, dh);\n                    }\n                }\n                catch (Exception e)\n                {\n                    throw new MuleRuntimeException(CoreMessages.failedToReadPayload(), e);\n                }\n            }\n            for (Iterator iterator = previous.getPropertyNames().iterator(); iterator.hasNext();)\n            {\n                String name = (String) iterator.next();\n                try\n                {\n                    Object value = previous.getProperty(name);\n                    if (null == value)\n                    {\n                        logger.warn(\"Detected concurrent access to property \" + name + \" for \" + previous);\n                    }\n                    else\n                    {\n                        setProperty(name, value);\n                    }\n                }\n                catch (Exception e)\n                {\n                    throw new MuleRuntimeException(CoreMessages.failedToReadPayload(), e);\n                }\n            }\n        }\n        else\n        {\n            throw new IllegalArgumentException(\"previousAdapter may not be null\");\n        }\n    }","commit_id":"1f133b9e072bfa7080eb4797e709ffc878de1c8c","url":"https://github.com/mulesoft/mule"},{"original_method":"private ResourceType createResourceType(List<String> resources) {\n        List<AttributeType> attributes = new ArrayList<AttributeType>();\n        for (String resource : resources) {\n            if (resource != null) {\n                attributes.add(createAttribute(XACMLConstants.RESOURCE_ID, XACMLConstants.XS_STRING, null,\n                                               resource));\n            }\n        }\n        return RequestComponentBuilder.createResourceType(attributes, null);\n    }","id":90708,"modified_method":"private ResourceType createResourceType(List<String> resources) {\n        List<AttributeType> attributes = new ArrayList<AttributeType>();\n        \n        List<AttributeValueType> resourceAttributes = new ArrayList<AttributeValueType>();\n        for (String resource : resources) {\n            if (resource != null) {\n                AttributeValueType resourceAttributeValue = \n                    RequestComponentBuilder.createAttributeValueType(resource);\n                resourceAttributes.add(resourceAttributeValue);\n            }\n        }\n\n        if (!resourceAttributes.isEmpty()) {\n            AttributeType resourceAttribute = \n                createAttribute(\n                    XACMLConstants.RESOURCE_ID,\n                    XACMLConstants.XS_STRING,\n                    null,\n                    resourceAttributes\n                );\n            attributes.add(resourceAttribute);\n        }\n        \n        return RequestComponentBuilder.createResourceType(attributes, null);\n    }","commit_id":"cf388678325e27f7f485339b92d01e0c484d4d07","url":"https://github.com/apache/cxf"},{"original_method":"private ResourceType createResourceType(List<String> resources) {\n        List<AttributeType> attributes = new ArrayList<AttributeType>();\n        \n        List<AttributeValueType> resourceAttributes = new ArrayList<AttributeValueType>();\n        for (String resource : resources) {\n            if (resource != null) {\n                AttributeValueType resourceAttributeValue = \n                    RequestComponentBuilder.createAttributeValueType(resource);\n                resourceAttributes.add(resourceAttributeValue);\n            }\n        }\n\n        if (!resourceAttributes.isEmpty()) {\n            AttributeType resourceAttribute = \n                createAttribute(\n                    XACMLConstants.RESOURCE_ID,\n                    XACMLConstants.XS_STRING,\n                    null,\n                    resourceAttributes\n                );\n            attributes.add(resourceAttribute);\n        }\n        \n        return RequestComponentBuilder.createResourceType(attributes, null);\n    }","id":90709,"modified_method":"private ResourceType createResourceType(List<String> resources) {\n        List<AttributeType> attributes = new ArrayList<AttributeType>();\n        for (String resource : resources) {\n            if (resource != null) {\n                attributes.add(createAttribute(XACMLConstants.RESOURCE_ID, XACMLConstants.XS_STRING, null,\n                                               resource));\n            }\n        }\n        return RequestComponentBuilder.createResourceType(attributes, null);\n    }","commit_id":"e4b9f2583f1128d225cfd2095810a7630367e6a3","url":"https://github.com/apache/cxf"},{"original_method":"private SubjectType createSubjectType(Principal principal, List<String> roles, String issuer) {\n        List<AttributeType> attributes = new ArrayList<AttributeType>();\n        attributes.add(createAttribute(XACMLConstants.SUBJECT_ID, XACMLConstants.XS_STRING, issuer,\n                                       principal.getName()));\n\n        for (String role : roles) {\n            if (role != null) {\n                attributes.add(createAttribute(XACMLConstants.SUBJECT_ROLE, XACMLConstants.XS_ANY_URI,\n                                               issuer, role));\n            }\n        }\n\n        return RequestComponentBuilder.createSubjectType(attributes, null);\n    }","id":90710,"modified_method":"private SubjectType createSubjectType(Principal principal, List<String> roles, String issuer) {\n        List<AttributeType> attributes = new ArrayList<AttributeType>();\n        attributes.add(createAttribute(XACMLConstants.SUBJECT_ID, XACMLConstants.XS_STRING, issuer,\n                                       principal.getName()));\n\n        if (roles != null) {\n            List<AttributeValueType> roleAttributes = new ArrayList<AttributeValueType>();\n            for (String role : roles) {\n                if (role != null) {\n                    AttributeValueType subjectRoleAttributeValue = \n                        RequestComponentBuilder.createAttributeValueType(role);\n                    roleAttributes.add(subjectRoleAttributeValue);\n                }\n            }\n\n            if (!roleAttributes.isEmpty()) {\n                AttributeType subjectRoleAttribute = \n                    createAttribute(\n                        XACMLConstants.SUBJECT_ROLE,\n                        XACMLConstants.XS_ANY_URI,\n                        issuer,\n                        roleAttributes\n                    );\n                attributes.add(subjectRoleAttribute);\n            }\n        }\n\n        return RequestComponentBuilder.createSubjectType(attributes, null);\n    }","commit_id":"c364e6c5134002951b22e3740d04ec2cd20b1cf3","url":"https://github.com/apache/cxf"},{"original_method":"private AttributeType createAttribute(String id, String type, String issuer, String value) {\n        return RequestComponentBuilder.createAttributeType(id, type, issuer, \n                                                           Collections.singletonList(\n                                                           RequestComponentBuilder.createAttributeValueType(value)));\n    }","id":90711,"modified_method":"private AttributeType createAttribute(String id, String type, String issuer, String value) {\n        return createAttribute(id, type, issuer, \n                               Collections.singletonList(RequestComponentBuilder.createAttributeValueType(value)));\n    }","commit_id":"c364e6c5134002951b22e3740d04ec2cd20b1cf3","url":"https://github.com/apache/cxf"},{"original_method":"protected Lock lockMemorySchedulerCluster(String owner) throws Exception {\n\t\tLock lock = null;\n\n\t\tif (owner == null) {\n\t\t\tlock = LockLocalServiceUtil.lock(\n\t\t\t\t_LOCK_CLASS_NAME, _LOCK_CLASS_NAME, _localClusterNodeAddress,\n\t\t\t\tPropsValues.MEMORY_CLUSTER_SCHEDULER_LOCK_CACHE_ENABLED);\n\t\t}\n\t\telse {\n\t\t\tlock = LockLocalServiceUtil.lock(\n\t\t\t\t_LOCK_CLASS_NAME, _LOCK_CLASS_NAME, owner,\n\t\t\t\t_localClusterNodeAddress,\n\t\t\t\tPropsValues.MEMORY_CLUSTER_SCHEDULER_LOCK_CACHE_ENABLED);\n\t\t}\n\n\t\tif (!lock.isNew()) {\n\t\t\treturn lock;\n\t\t}\n\n\t\tboolean forceSync = ProxyModeThreadLocal.isForceSync();\n\n\t\tProxyModeThreadLocal.setForceSync(true);\n\n\t\t_writeLock.lock();\n\n\t\ttry {\n\t\t\tfor (ObjectValuePair<SchedulerResponse, TriggerState>\n\t\t\t\t\tmemoryClusteredJob : _memoryClusteredJobs.values()) {\n\n\t\t\t\tSchedulerResponse schedulerResponse =\n\t\t\t\t\tmemoryClusteredJob.getKey();\n\n\t\t\t\t_schedulerEngine.schedule(\n\t\t\t\t\tschedulerResponse.getTrigger(),\n\t\t\t\t\tschedulerResponse.getDescription(),\n\t\t\t\t\tschedulerResponse.getDestinationName(),\n\t\t\t\t\tschedulerResponse.getMessage());\n\n\t\t\t\tTriggerState triggerState = memoryClusteredJob.getValue();\n\n\t\t\t\tif (triggerState.equals(TriggerState.PAUSED)) {\n\t\t\t\t\t_schedulerEngine.pause(\n\t\t\t\t\t\tschedulerResponse.getJobName(),\n\t\t\t\t\t\tschedulerResponse.getGroupName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tProxyModeThreadLocal.setForceSync(forceSync);\n\n\t\t\t_writeLock.unlock();\n\t\t}\n\n\t\treturn lock;\n\t}","id":90712,"modified_method":"protected Lock lockMemorySchedulerCluster(String owner) throws Exception {\n\t\tLock lock = null;\n\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tif (owner == null) {\n\t\t\t\t\tlock = LockLocalServiceUtil.lock(\n\t\t\t\t\t\t_LOCK_CLASS_NAME, _LOCK_CLASS_NAME,\n\t\t\t\t\t\t_localClusterNodeAddress,\n\t\t\t\t\t\tPropsValues.MEMORY_CLUSTER_SCHEDULER_LOCK_CACHE_ENABLED);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlock = LockLocalServiceUtil.lock(\n\t\t\t\t\t\t_LOCK_CLASS_NAME, _LOCK_CLASS_NAME, owner,\n\t\t\t\t\t\t_localClusterNodeAddress,\n\t\t\t\t\t\tPropsValues.MEMORY_CLUSTER_SCHEDULER_LOCK_CACHE_ENABLED);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcatch(SystemException se) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"Failed scheduler cluster master competition, \" +\n\t\t\t\t\t\"start to retry\");\n\t\t\t}\n\t\t}\n\n\t\tif (!lock.isNew()) {\n\t\t\treturn lock;\n\t\t}\n\n\t\tboolean forceSync = ProxyModeThreadLocal.isForceSync();\n\n\t\tProxyModeThreadLocal.setForceSync(true);\n\n\t\t_writeLock.lock();\n\n\t\ttry {\n\t\t\tfor (ObjectValuePair<SchedulerResponse, TriggerState>\n\t\t\t\t\tmemoryClusteredJob : _memoryClusteredJobs.values()) {\n\n\t\t\t\tSchedulerResponse schedulerResponse =\n\t\t\t\t\tmemoryClusteredJob.getKey();\n\n\t\t\t\t_schedulerEngine.schedule(\n\t\t\t\t\tschedulerResponse.getTrigger(),\n\t\t\t\t\tschedulerResponse.getDescription(),\n\t\t\t\t\tschedulerResponse.getDestinationName(),\n\t\t\t\t\tschedulerResponse.getMessage());\n\n\t\t\t\tTriggerState triggerState = memoryClusteredJob.getValue();\n\n\t\t\t\tif (triggerState.equals(TriggerState.PAUSED)) {\n\t\t\t\t\t_schedulerEngine.pause(\n\t\t\t\t\t\tschedulerResponse.getJobName(),\n\t\t\t\t\t\tschedulerResponse.getGroupName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tProxyModeThreadLocal.setForceSync(forceSync);\n\n\t\t\t_writeLock.unlock();\n\t\t}\n\n\t\treturn lock;\n\t}","commit_id":"6804cb44427cd038e6d878accff5ce5cb97da756","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Transactional(isolation = Isolation.SERIALIZABLE)\n\tpublic Lock lock(\n\t\t\tString className, String key, String expectedOwner,\n\t\t\tString updatedOwner, boolean retrieveFromCache)\n\t\tthrows SystemException {\n\n\t\tLock lock = lockPersistence.fetchByC_K(\n\t\t\tclassName, key, retrieveFromCache);\n\n\t\tif (lock != null) {\n\t\t\tString owner = lock.getOwner();\n\n\t\t\tif (!owner.equals(expectedOwner)) {\n\t\t\t\treturn lock;\n\t\t\t}\n\n\t\t\tlockPersistence.remove(lock);\n\n\t\t\tlock = null;\n\t\t}\n\n\t\tif (lock == null) {\n\t\t\tlong lockId = counterLocalService.increment();\n\n\t\t\tlock = lockPersistence.create(lockId);\n\n\t\t\tlock.setCreateDate(new Date());\n\t\t\tlock.setClassName(className);\n\t\t\tlock.setKey(key);\n\t\t\tlock.setOwner(updatedOwner);\n\n\t\t\tlockPersistence.update(lock, false);\n\n\t\t\tlock.setNew(true);\n\t\t}\n\n\t\treturn lock;\n\t}","id":90713,"modified_method":"@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic Lock lock(\n\t\t\tString className, String key, String expectedOwner,\n\t\t\tString updatedOwner, boolean retrieveFromCache)\n\t\tthrows SystemException {\n\n\t\tLock lock = lockFinder.fetchByC_K(className, key, LockMode.UPGRADE);\n\n\t\tif (lock == null) {\n\t\t\tlong lockId = counterLocalService.increment();\n\n\t\t\tlock = lockPersistence.create(lockId);\n\n\t\t\tlock.setCreateDate(new Date());\n\t\t\tlock.setClassName(className);\n\t\t\tlock.setKey(key);\n\t\t\tlock.setOwner(updatedOwner);\n\n\t\t\tlockPersistence.update(lock, false);\n\n\t\t\tlock.setNew(true);\n\t\t}\n\t\telse if (lock.getOwner().equals(expectedOwner)) {\n\n\t\t\tlock.setCreateDate(new Date());\n\t\t\tlock.setClassName(className);\n\t\t\tlock.setKey(key);\n\t\t\tlock.setOwner(updatedOwner);\n\n\t\t\tlockPersistence.update(lock, false);\n\n\t\t\tlock.setNew(true);\n\t\t}\n\n\t\treturn lock;\n\t}","commit_id":"6804cb44427cd038e6d878accff5ce5cb97da756","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Transactional(isolation = Isolation.SERIALIZABLE)\n\tpublic void unlock(\n\t\t\tString className, String key, String owner,\n\t\t\tboolean retrieveFromCache)\n\t\tthrows SystemException {\n\n\t\tLock lock = lockPersistence.fetchByC_K(\n\t\t\tclassName, key, retrieveFromCache);\n\n\t\tif (lock == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (lock.getOwner().equals(owner)) {\n\t\t\tdeleteLock(lock);\n\t\t}\n\t}","id":90714,"modified_method":"@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic void unlock(\n\t\t\tString className, String key, String owner,\n\t\t\tboolean retrieveFromCache)\n\t\tthrows SystemException {\n\n\t\tLock lock = lockFinder.fetchByC_K(className, key, LockMode.UPGRADE);\n\n\t\tif (lock == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (lock.getOwner().equals(owner)) {\n\t\t\tdeleteLock(lock);\n\t\t}\n\t}","commit_id":"6804cb44427cd038e6d878accff5ce5cb97da756","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Transactional(isolation = Isolation.SERIALIZABLE)\n\tpublic Lock lock(\n\t\t\tString className, String key, String owner,\n\t\t\tboolean retrieveFromCache)\n\t\tthrows SystemException {\n\n\t\tLock lock = lockPersistence.fetchByC_K(\n\t\t\tclassName, key, retrieveFromCache);\n\n\t\tif (lock == null) {\n\t\t\tlong lockId = counterLocalService.increment();\n\n\t\t\tlock = lockPersistence.create(lockId);\n\n\t\t\tlock.setCreateDate(new Date());\n\t\t\tlock.setClassName(className);\n\t\t\tlock.setKey(key);\n\t\t\tlock.setOwner(owner);\n\n\t\t\tlockPersistence.update(lock, false);\n\n\t\t\tlock.setNew(true);\n\t\t}\n\n\t\treturn lock;\n\t}","id":90715,"modified_method":"@Transactional(propagation = Propagation.REQUIRES_NEW)\n\tpublic Lock lock(\n\t\t\tString className, String key, String owner,\n\t\t\tboolean retrieveFromCache)\n\t\tthrows SystemException {\n\n\t\treturn lock(className, key, null, owner, retrieveFromCache);\n\t}","commit_id":"6804cb44427cd038e6d878accff5ce5cb97da756","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void shutdown() {\r\n    acquireExclusiveLock();\r\n    try {\r\n      if (!active)\r\n        return;\r\n\r\n      active = false;\r\n\r\n      shutdownHook.cancel();\r\n      profiler.shutdown();\r\n\r\n      OLogManager.instance().debug(this, \"Orient Engine is shutting down...\");\r\n\r\n      // CALL THE SHUTDOWN ON ALL THE LISTENERS\r\n      for (OOrientListener l : listeners) {\r\n        l.onShutdown();\r\n      }\r\n\r\n      // CLOSE ALL DATABASES\r\n      databaseFactory.shutdown();\r\n\r\n      // CLOSE ALL THE STORAGES\r\n      final List<OStorage> storagesCopy = new ArrayList<OStorage>(storages.values());\r\n      for (OStorage stg : storagesCopy) {\r\n        OLogManager.instance().debug(this, \"Shutting down storage: \" + stg.getName() + \"...\");\r\n        stg.close(true);\r\n      }\r\n\r\n      OMMapManagerLocator.getInstance().shutdown();\r\n\r\n      // STOP ALL THE PENDING THREADS\r\n      threadGroup.interrupt();\r\n      listeners.clear();\r\n\r\n      OLogManager.instance().debug(this, \"Orient Engine shutdown complete\");\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","id":90716,"modified_method":"public void shutdown() {\r\n    acquireExclusiveLock();\r\n    try {\r\n      if (!active)\r\n        return;\r\n\r\n      active = false;\r\n\r\n      if (shutdownHook != null)\r\n        shutdownHook.cancel();\r\n      if (profiler != null)\r\n        profiler.shutdown();\r\n\r\n      OLogManager.instance().debug(this, \"Orient Engine is shutting down...\");\r\n\r\n      if (listeners != null)\r\n        // CALL THE SHUTDOWN ON ALL THE LISTENERS\r\n        for (OOrientListener l : listeners) {\r\n          if (l != null)\r\n            l.onShutdown();\r\n        }\r\n\r\n      if (databaseFactory != null)\r\n        // CLOSE ALL DATABASES\r\n        databaseFactory.shutdown();\r\n\r\n      if (storages != null) {\r\n        // CLOSE ALL THE STORAGES\r\n        final List<OStorage> storagesCopy = new ArrayList<OStorage>(storages.values());\r\n        for (OStorage stg : storagesCopy) {\r\n          OLogManager.instance().debug(this, \"Shutting down storage: \" + stg.getName() + \"...\");\r\n          stg.close(true);\r\n        }\r\n      }\r\n\r\n      if (OMMapManagerLocator.getInstance() != null)\r\n        OMMapManagerLocator.getInstance().shutdown();\r\n\r\n      if (threadGroup != null)\r\n        // STOP ALL THE PENDING THREADS\r\n        threadGroup.interrupt();\r\n\r\n      if (listeners != null)\r\n        listeners.clear();\r\n\r\n      OLogManager.instance().debug(this, \"Orient Engine shutdown complete\");\r\n\r\n    } finally {\r\n      releaseExclusiveLock();\r\n    }\r\n  }","commit_id":"8f78647822c9230b3b7a118d5084e9f758d06696","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void cancel() {\n    super.cancel();\n    if (cvModelBuildersKey == null)\n      return;\n    for (int i=0; i<cvModelBuildersKey.length; ++i) {\n      ModelBuilder<M,P,O> mb = DKV.getGet(cvModelBuildersKey[i]);\n      if (mb != null) {\n        Log.info(\"Cancelling CV model \" + mb);\n        mb.cancel();\n        assert(mb.isCancelledOrCrashed());\n      }\n    }\n  }","id":90717,"modified_method":"@Override\n  public void cancel() {\n    super.cancel();\n    // parent job cancels all running CV child jobs\n    if (cvModelBuilderKeys != null) {\n      for (int i = 0; i < cvModelBuilderKeys.length; ++i) {\n        ModelBuilder<M, P, O> mb = DKV.getGet(cvModelBuilderKeys[i]);\n        if (mb != null) {\n          assert (mb.cvModelBuilderKeys == null); //prevent infinite recursion\n          mb.cancel();\n        }\n      }\n    }\n  }","commit_id":"848c015b1ac6dee7517bd9d82eeae2919d01c9c6","url":"https://github.com/h2oai/h2o-3"},{"original_method":"/**\n   * Default naive (serial) implementation of N-fold cross-validation\n   * @return Cross-validation Job\n   * (builds N+1 models, all have train+validation metrics, the main model has N-fold cross-validated validation metrics)\n   */\n  public Job<M> computeCrossValidation() {\n    assert(_state == JobState.RUNNING); //main Job is still running\n    final Frame origTrainFrame = train();\n\n    // Step 1: Assign each row to a fold\n    // TODO: Implement better splitting algo (with Strata if response is categorical), e.g. http://www.lexjansen.com/scsug/2009/Liang_Xie2.pdf\n    final Vec foldAssignment;\n\n    final Integer N;\n    if (_parms._fold_column != null) {\n      foldAssignment = origTrainFrame.vec(_parms._fold_column);\n      N = (int)foldAssignment.max() - (int)foldAssignment.min() + 1;\n      assert(N>1); //should have been already checked in init();\n    } else {\n      N = _parms._nfolds;\n      long seed = new Random().nextLong();\n      for (Field f : _parms.getClass().getFields()) {\n        if (f.getName().equals(\"_seed\")) {\n          try {\n            seed = (long)(f.get(_parms));\n          } catch (IllegalAccessException e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      final long actualSeed = seed;\n      Log.info(\"Creating \" + N + \" cross-validation splits with random number seed: \" + actualSeed);\n      foldAssignment = origTrainFrame.anyVec().makeZero();\n      final Model.Parameters.FoldAssignmentScheme foldAssignmentScheme = _parms._fold_assignment;\n      new MRTask() {\n        @Override\n        public void map(Chunk foldAssignment) {\n          for (int i = 0; i < foldAssignment._len; ++i) {\n            int fold;\n            switch (foldAssignmentScheme) {\n              case AUTO:\n              case Random:\n                fold = Math.abs(getRNG(foldAssignment.start() + actualSeed + i).nextInt()) % N;\n                break;\n              case Modulo:\n                fold = ((int) (foldAssignment.start() + i)) % N;\n                break;\n              default:\n                throw H2O.unimpl();\n            }\n            foldAssignment.set(i, fold);\n          }\n        }\n      }.doAll(foldAssignment);\n    }\n\n    final Key[] modelKeys = new Key[N];\n    final Key[] predictionKeys = new Key[N];\n\n    // Step 2: Make 2*N binary weight vectors and store the CV train/validation frames\n    final String origWeightsName = _parms._weights_column;\n    final Vec[] weights = new Vec[2*N];\n    final Vec origWeight  = origWeightsName != null ? origTrainFrame.vec(origWeightsName) : origTrainFrame.anyVec().makeCon(1.0);\n    final Frame[] cvTrain = new Frame[N];\n    final Frame[] cvValid = new Frame[N];\n    final String[] identifier = new String[N];\n    final String weightName = \"weights\";\n\n    final Key<M> origDest = dest();\n    for (int i=0; i<N; ++i) {\n      // Make weights\n      weights[2*i]   = origTrainFrame.anyVec().makeZero();\n      weights[2*i+1] = origTrainFrame.anyVec().makeZero();\n\n      // Now update the weights in place\n      final int whichFold = i;\n      new MRTask() {\n        @Override\n        public void map(Chunk chks[]) {\n          Chunk fold = chks[0];\n          Chunk orig = chks[1];\n          Chunk train = chks[2];\n          Chunk valid = chks[3];\n          for (int i=0; i< orig._len; ++i) {\n            int foldAssignment = (int)fold.at8(i) % N;\n            assert(foldAssignment >= 0 && foldAssignment <N);\n            boolean holdout = foldAssignment == whichFold;\n            double w = orig.atd(i);\n            train.set(i, holdout ? 0 : w);\n            valid.set(i, holdout ? w : 0);\n          }\n        }\n      }.doAll(new Vec[]{foldAssignment, origWeight, weights[2*i], weights[2*i+1]});\n      if (weights[2*i].isConst() || weights[2*i+1].isConst()) {\n        String msg = \"Not enough data to create \" + N + \" random cross-validation splits. Either reduce nfolds, specify a larger dataset (or specify another random number seed, if applicable).\";\n        throw new H2OIllegalArgumentException(msg);\n      }\n\n      identifier[i] = origDest.toString() + \"_cv_\" + (i+1);\n      modelKeys[i] = Key.make(identifier[i]);\n\n      // Training/Validation share the same data, but will have exclusive weights\n      cvTrain[i] = new Frame(Key.make(identifier[i]+\"_\"+_parms._train.toString()+\"_train\"), origTrainFrame.names(), origTrainFrame.vecs());\n      cvTrain[i].add(weightName, weights[2*i]);\n      DKV.put(cvTrain[i]);\n      cvValid[i] = new Frame(Key.make(identifier[i]+\"_\"+_parms._train.toString()+\"_valid\"), origTrainFrame.names(), origTrainFrame.vecs());\n      cvValid[i].add(weightName, weights[2*i+1]);\n      DKV.put(cvValid[i]);\n    }\n\n    // clean up memory (mostly small helper vectors and Frame headers)\n    if (_parms._fold_column == null) foldAssignment.remove();\n    if (origWeightsName == null) origWeight.remove();\n\n    // adapt main Job's progress bar to build N+1 models\n    ModelMetrics.MetricBuilder[] mb = new ModelMetrics.MetricBuilder[N];\n    _deleteProgressKey = false; // keep the same progress bar for all N+1 jobs\n\n    long cs = _parms.checksum();\n    final boolean async = false;\n    cvModelBuildersKey = new Key[N];\n    ModelBuilder<M, P, O>[] cvModelBuilders = new ModelBuilder[N];\n    for (int i=0; i<N; ++i) {\n      if (isCancelledOrCrashed()) break;\n      Log.info(\"Building cross-validation model \" + (i+1) + \" / \" + N + \".\");\n      // Shallow clone - not everything is a private copy!!!\n      cvModelBuilders[i] = (ModelBuilder<M, P, O>) this.clone();\n      cvModelBuilders[i]._key = Key.make(_key.toString() + \"_cv\" + i);\n      cvModelBuildersKey[i] =  cvModelBuilders[i]._key;\n      cvModelBuilders[i].cvModelBuildersKey = null;\n\n      // Fix up some parameters of the clone - UGLY - hopefully nothing is missing\n      cvModelBuilders[i]._dest = modelKeys[i]; // the model_id gets updated as well in modifyParmsForCrossValidationSplits (must be consistent)\n      cvModelBuilders[i]._state = JobState.CREATED;\n      cvModelBuilders[i]._parms =  (P)_parms.clone();\n      cvModelBuilders[i]._parms._weights_column = weightName;\n      cvModelBuilders[i]._parms._train = cvTrain[i]._key;\n      cvModelBuilders[i]._parms._valid = cvValid[i]._key;\n      cvModelBuilders[i]._parms._fold_assignment = Model.Parameters.FoldAssignmentScheme.AUTO;\n      cvModelBuilders[i].modifyParmsForCrossValidationSplits(i, N, _parms._model_id);\n      cvModelBuilders[i]._start_time = System.currentTimeMillis();\n      cvModelBuilders[i].trainModelImpl(-1, true); //non-blocking\n      if (!async)\n        cvModelBuilders[i].block();\n    }\n    // check that this Job's original _params haven't changed\n    assert(cs == _parms.checksum());\n\n    if (!isCancelledOrCrashed()) {\n      Log.info(\"Building main model.\");\n\n      //HACK:\n      // Can't use changeJobState (it assumes that state transitions are monotonic)\n      assert (DKV.get(_key).get() == this);\n      assert(_state == JobState.RUNNING);\n      assert (((Job)DKV.getGet(_key))._state == JobState.RUNNING);\n      _state = JobState.CREATED;\n      assert (((Job)DKV.getGet(_key))._state == JobState.CREATED);\n      assert(!_deleteProgressKey);\n      _deleteProgressKey = true; //delete progress after the main model is done\n\n      modifyParmsForCrossValidationMainModel(N); //tell the main model that it shouldn't stop early either\n\n      trainModelImpl(-1, false); //non-blocking\n      if (!async)\n        block();\n\n      // in async case, the CV models can score while the main model is still building\n      Model[] m = new Model[N];\n      for (int i=0; i<N; ++i) {\n        Frame adaptFr = new Frame(cvValid[i]);\n        try {\n          if (isCancelledOrCrashed()) {\n            Log.warn(\"Cancelling all N-fold cross-validation jobs.\");\n            break;\n          } else {\n            // Since canBeDone() is false for the CV model, we need to explicitly set the job state to DONE here:\n            cvModelBuilders[i].block();\n\n            // mark the job as done\n            cvModelBuilders[i].done(true);               // mark the model as completed via force flag (otherwise it wouldn't mark it since canBeDone is false)\n            cvModelBuilders[i].updateModelOutput();      // mirror the Job state in the model\n            m[i] = DKV.getGet(cvModelBuilders[i].dest());   // now the model is ready for consumption\n            m[i].adaptTestForTrain(adaptFr, true, !isSupervised());\n            mb[i] = m[i].scoreMetrics(adaptFr);\n\n            if (_parms._keep_cross_validation_predictions) {\n              String predName = \"prediction_\" + modelKeys[i].toString();\n              predictionKeys[i] = Key.make(predName);\n              m[i].predictScoreImpl(cvValid[i], adaptFr, predName);\n            }\n\n            // free resources\n            DKV.remove(cvTrain[i]._key);\n            DKV.remove(cvValid[i]._key);\n            weights[2 * i].remove();\n            weights[2 * i + 1].remove();\n            cvModelBuilders[i].remove();\n          }\n        } finally {\n          if (adaptFr != null) {\n            Model.cleanup_adapt(adaptFr, cvValid[i]);\n            DKV.remove(adaptFr._key);\n          }\n        }\n      }\n\n      // wait for completion of the main model\n      block();\n      Model mainModel = DKV.getGet(dest()); // get the fully trained model, but it's not yet done (still needs cv metrics)\n\n      // Check that both the job and the model are not yet marked as done (canBeDone() looks at whether N-fold CV is done)\n      assert(_state == JobState.RUNNING);\n\n      // Compute and put the cross-validation metrics into the main model\n      Log.info(\"Computing \" + N + \"-fold cross-validation metrics.\");\n      mainModel._output._cross_validation_models = new Key[N];\n      mainModel._output._cross_validation_predictions = _parms._keep_cross_validation_predictions ? new Key[N] : null;\n      for (int i = 0; i < N; ++i) {\n        if (i > 0) mb[0].reduce(mb[i]);\n        mainModel._output._cross_validation_models[i] = modelKeys[i];\n        if (_parms._keep_cross_validation_predictions)\n          mainModel._output._cross_validation_predictions[i] = predictionKeys[i];\n      }\n      mainModel._output._cross_validation_metrics = mb[0].makeModelMetrics(mainModel, _parms.train());\n      mainModel._output._cross_validation_metrics._description = N + \"-fold cross-validation on training data\";\n      Log.info(mainModel._output._cross_validation_metrics.toString());\n\n      // Now, the main model is complete (has cv metrics)\n      DKV.put(mainModel);\n\n      assert(!isDone());\n      done(true); //now, we can mark the job as done\n      updateModelOutput(); //update the state of the model (tiny race condition here: someone might fetch the model without the updated state/time)\n    }\n    return this;\n  }","id":90718,"modified_method":"/**\n   * Default naive (serial) implementation of N-fold cross-validation\n   * @return Cross-validation Job\n   * (builds N+1 models, all have train+validation metrics, the main model has N-fold cross-validated validation metrics)\n   */\n  public Job<M> computeCrossValidation() {\n    assert(_state == JobState.RUNNING); //main Job is still running\n    final Frame origTrainFrame = train();\n\n    // Step 1: Assign each row to a fold\n    // TODO: Implement better splitting algo (with Strata if response is categorical), e.g. http://www.lexjansen.com/scsug/2009/Liang_Xie2.pdf\n    final Vec foldAssignment;\n\n    final Integer N;\n    if (_parms._fold_column != null) {\n      foldAssignment = origTrainFrame.vec(_parms._fold_column);\n      N = (int)foldAssignment.max() - (int)foldAssignment.min() + 1;\n      assert(N>1); //should have been already checked in init();\n    } else {\n      N = _parms._nfolds;\n      long seed = new Random().nextLong();\n      for (Field f : _parms.getClass().getFields()) {\n        if (f.getName().equals(\"_seed\")) {\n          try {\n            seed = (long)(f.get(_parms));\n          } catch (IllegalAccessException e) {\n            e.printStackTrace();\n          }\n        }\n      }\n      final long actualSeed = seed;\n      Log.info(\"Creating \" + N + \" cross-validation splits with random number seed: \" + actualSeed);\n      foldAssignment = origTrainFrame.anyVec().makeZero();\n      final Model.Parameters.FoldAssignmentScheme foldAssignmentScheme = _parms._fold_assignment;\n      new MRTask() {\n        @Override\n        public void map(Chunk foldAssignment) {\n          for (int i = 0; i < foldAssignment._len; ++i) {\n            int fold;\n            switch (foldAssignmentScheme) {\n              case AUTO:\n              case Random:\n                fold = Math.abs(getRNG(foldAssignment.start() + actualSeed + i).nextInt()) % N;\n                break;\n              case Modulo:\n                fold = ((int) (foldAssignment.start() + i)) % N;\n                break;\n              default:\n                throw H2O.unimpl();\n            }\n            foldAssignment.set(i, fold);\n          }\n        }\n      }.doAll(foldAssignment);\n    }\n\n    final Key[] modelKeys = new Key[N];\n    final Key[] predictionKeys = new Key[N];\n\n    // Step 2: Make 2*N binary weight vectors and store the CV train/validation frames\n    final String origWeightsName = _parms._weights_column;\n    final Vec[] weights = new Vec[2*N];\n    final Vec origWeight  = origWeightsName != null ? origTrainFrame.vec(origWeightsName) : origTrainFrame.anyVec().makeCon(1.0);\n    final Frame[] cvTrain = new Frame[N];\n    final Frame[] cvValid = new Frame[N];\n    final String[] identifier = new String[N];\n    final String weightName = \"weights\";\n\n    final Key<M> origDest = dest();\n    for (int i=0; i<N; ++i) {\n      // Make weights\n      weights[2*i]   = origTrainFrame.anyVec().makeZero();\n      weights[2*i+1] = origTrainFrame.anyVec().makeZero();\n\n      // Now update the weights in place\n      final int whichFold = i;\n      new MRTask() {\n        @Override\n        public void map(Chunk chks[]) {\n          Chunk fold = chks[0];\n          Chunk orig = chks[1];\n          Chunk train = chks[2];\n          Chunk valid = chks[3];\n          for (int i=0; i< orig._len; ++i) {\n            int foldAssignment = (int)fold.at8(i) % N;\n            assert(foldAssignment >= 0 && foldAssignment <N);\n            boolean holdout = foldAssignment == whichFold;\n            double w = orig.atd(i);\n            train.set(i, holdout ? 0 : w);\n            valid.set(i, holdout ? w : 0);\n          }\n        }\n      }.doAll(new Vec[]{foldAssignment, origWeight, weights[2*i], weights[2*i+1]});\n      if (weights[2*i].isConst() || weights[2*i+1].isConst()) {\n        String msg = \"Not enough data to create \" + N + \" random cross-validation splits. Either reduce nfolds, specify a larger dataset (or specify another random number seed, if applicable).\";\n        throw new H2OIllegalArgumentException(msg);\n      }\n\n      identifier[i] = origDest.toString() + \"_cv_\" + (i+1);\n      modelKeys[i] = Key.make(identifier[i]);\n\n      // Training/Validation share the same data, but will have exclusive weights\n      cvTrain[i] = new Frame(Key.make(identifier[i]+\"_\"+_parms._train.toString()+\"_train\"), origTrainFrame.names(), origTrainFrame.vecs());\n      cvTrain[i].add(weightName, weights[2*i]);\n      DKV.put(cvTrain[i]);\n      cvValid[i] = new Frame(Key.make(identifier[i]+\"_\"+_parms._train.toString()+\"_valid\"), origTrainFrame.names(), origTrainFrame.vecs());\n      cvValid[i].add(weightName, weights[2*i+1]);\n      DKV.put(cvValid[i]);\n    }\n\n    // clean up memory (mostly small helper vectors and Frame headers)\n    if (_parms._fold_column == null) foldAssignment.remove();\n    if (origWeightsName == null) origWeight.remove();\n\n    // adapt main Job's progress bar to build N+1 models\n    ModelMetrics.MetricBuilder[] mb = new ModelMetrics.MetricBuilder[N];\n    _deleteProgressKey = false; // keep the same progress bar for all N+1 jobs\n\n    long cs = _parms.checksum();\n    final boolean async = false;\n    cvModelBuilderKeys = new Key[N];\n    ModelBuilder<M, P, O>[] cvModelBuilders = new ModelBuilder[N];\n    for (int i=0; i<N; ++i) {\n      if (isCancelledOrCrashed()) break;\n      Log.info(\"Building cross-validation model \" + (i+1) + \" / \" + N + \".\");\n\n      // Shallow clone - not everything is a private copy!!!\n      cvModelBuilders[i] = (ModelBuilder<M, P, O>) this.clone();\n\n      // Fix up some parameters of the clone - UGLY - hopefully nothing is missing\n      cvModelBuilderKeys[i] = Key.make(_key.toString() + \"_cv\" + i);\n      cvModelBuilders[i]._key = cvModelBuilderKeys[i];\n      cvModelBuilders[i].cvModelBuilderKeys = null; //children cannot have children\n      cvModelBuilders[i]._dest = modelKeys[i]; // the model_id gets updated as well in modifyParmsForCrossValidationSplits (must be consistent)\n      cvModelBuilders[i]._state = JobState.CREATED;\n      cvModelBuilders[i]._parms =  (P)_parms.clone();\n      cvModelBuilders[i]._parms._weights_column = weightName;\n      cvModelBuilders[i]._parms._train = cvTrain[i]._key;\n      cvModelBuilders[i]._parms._valid = cvValid[i]._key;\n      cvModelBuilders[i]._parms._fold_assignment = Model.Parameters.FoldAssignmentScheme.AUTO;\n      cvModelBuilders[i].modifyParmsForCrossValidationSplits(i, N, _parms._model_id);\n      cvModelBuilders[i]._start_time = System.currentTimeMillis();\n      cvModelBuilders[i].trainModelImpl(-1, true); //non-blocking\n      if (!async)\n        cvModelBuilders[i].block();\n    }\n    // check that this Job's original _params haven't changed\n    assert(cs == _parms.checksum());\n\n    if (!isCancelledOrCrashed()) {\n      Log.info(\"Building main model.\");\n\n      //HACK:\n      // Can't use changeJobState (it assumes that state transitions are monotonic)\n      assert (DKV.get(_key).get() == this);\n      assert(_state == JobState.RUNNING);\n      assert (((Job)DKV.getGet(_key))._state == JobState.RUNNING);\n      _state = JobState.CREATED;\n      assert (((Job)DKV.getGet(_key))._state == JobState.CREATED);\n      assert(!_deleteProgressKey);\n      _deleteProgressKey = true; //delete progress after the main model is done\n\n      modifyParmsForCrossValidationMainModel(N); //tell the main model that it shouldn't stop early either\n\n      trainModelImpl(-1, false); //non-blocking\n      if (!async)\n        block();\n\n      // in async case, the CV models can score while the main model is still building\n      Model[] m = new Model[N];\n      for (int i=0; i<N; ++i) {\n        Frame adaptFr = new Frame(cvValid[i]);\n        try {\n          if (isCancelledOrCrashed()) {\n            Log.warn(\"Cancelling all N-fold cross-validation jobs.\");\n            break;\n          } else {\n            // Since canBeDone() is false for the CV model, we need to explicitly set the job state to DONE here:\n            cvModelBuilders[i].block();\n\n            // mark the job as done\n            cvModelBuilders[i].done(true);               // mark the model as completed via force flag (otherwise it wouldn't mark it since canBeDone is false)\n            cvModelBuilders[i].updateModelOutput();      // mirror the Job state in the model\n            m[i] = DKV.getGet(cvModelBuilders[i].dest());   // now the model is ready for consumption\n            m[i].adaptTestForTrain(adaptFr, true, !isSupervised());\n            mb[i] = m[i].scoreMetrics(adaptFr);\n\n            if (_parms._keep_cross_validation_predictions) {\n              String predName = \"prediction_\" + modelKeys[i].toString();\n              predictionKeys[i] = Key.make(predName);\n              m[i].predictScoreImpl(cvValid[i], adaptFr, predName);\n            }\n\n            // free resources\n            DKV.remove(cvTrain[i]._key);\n            DKV.remove(cvValid[i]._key);\n            weights[2 * i].remove();\n            weights[2 * i + 1].remove();\n            cvModelBuilders[i].remove();\n          }\n        } finally {\n          if (adaptFr != null) {\n            Model.cleanup_adapt(adaptFr, cvValid[i]);\n            DKV.remove(adaptFr._key);\n          }\n        }\n      }\n\n      // wait for completion of the main model\n      block();\n      Model mainModel = DKV.getGet(dest()); // get the fully trained model, but it's not yet done (still needs cv metrics)\n\n      // Check that both the job and the model are not yet marked as done (canBeDone() looks at whether N-fold CV is done)\n      assert(_state == JobState.RUNNING);\n\n      // Compute and put the cross-validation metrics into the main model\n      Log.info(\"Computing \" + N + \"-fold cross-validation metrics.\");\n      mainModel._output._cross_validation_models = new Key[N];\n      mainModel._output._cross_validation_predictions = _parms._keep_cross_validation_predictions ? new Key[N] : null;\n      for (int i = 0; i < N; ++i) {\n        if (i > 0) mb[0].reduce(mb[i]);\n        mainModel._output._cross_validation_models[i] = modelKeys[i];\n        if (_parms._keep_cross_validation_predictions)\n          mainModel._output._cross_validation_predictions[i] = predictionKeys[i];\n      }\n      mainModel._output._cross_validation_metrics = mb[0].makeModelMetrics(mainModel, _parms.train());\n      mainModel._output._cross_validation_metrics._description = N + \"-fold cross-validation on training data\";\n      Log.info(mainModel._output._cross_validation_metrics.toString());\n\n      // Now, the main model is complete (has cv metrics)\n      DKV.put(mainModel);\n\n      assert(!isDone());\n      done(true); //now, we can mark the job as done\n      updateModelOutput(); //update the state of the model (tiny race condition here: someone might fetch the model without the updated state/time)\n    }\n    return this;\n  }","commit_id":"848c015b1ac6dee7517bd9d82eeae2919d01c9c6","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void fail(FetchException e) {\n        synchronized(this) {\n            if(succeeded || failed) return;\n            failed = true;\n        }\n        if(storage != null)\n            context.getChkFetchScheduler(realTimeFlag).removePendingKeys(storage.keyListener, true);\n        getter.cancel(context);\n        if(storage != null)\n            storage.cancel();\n        cb.onFailure(e, this, context);\n    }","id":90719,"modified_method":"public void fail(FetchException e) {\n        synchronized(this) {\n            if(succeeded || failed) return;\n            failed = true;\n        }\n        if(storage != null)\n            context.getChkFetchScheduler(realTimeFlag).removePendingKeys(storage.keyListener, true);\n        if(getter != null)\n            getter.cancel(context);\n        if(storage != null)\n            storage.cancel();\n        cb.onFailure(e, this, context);\n    }","commit_id":"609345c78ab95f36b6cf27e9240ee4822fe4f525","url":"https://github.com/freenet/fred"},{"original_method":"public boolean cancel() {\n\t\t\treturn future().cancel(true);\n\t\t}","id":90720,"modified_method":"public boolean cancel() {\n\t\t\tlong start = System.currentTimeMillis();\n\t\t\tif(_currentThread != null) {\n\t\t\t\taddThreadInterrupt(_currentThread, \"ERXDelayedRequestHandler: stop requested\");\n\n\t\t\t\t//while(System.currentTimeMillis() - start < 5000 && !isDone()) {\n\t\t\t\t\tif(future().cancel(true)) {\n\t\t\t\t\t\tlog.info(\"Cancelled: \" + _currentThread + \": \" + isDone());\n\t\t\t\t\t}\n\t\t\t\t//}\n\t\t\t\tlog.info(\"Thread done after cancel: \" + isDone());\n\t\t\t}\n\t\t\treturn isDone();\n\t\t}","commit_id":"112afd690be1f53496814027ffb62f762f524c25","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOResponse call() throws Exception {\n\t\t\tfinal ERXApplication app = ERXApplication.erxApplication();\n\t\t\tWOResponse response = app.dispatchRequestImmediately(request());\n\t\t\t// testing\n\t\t\t// Thread.sleep(6000);\n\t\t\t// log.info(\"done: \" + this);\n\t\t\t\n\t\t\treturn response;\n\t\t}","id":90721,"modified_method":"public WOResponse call() throws Exception {\n\t\t\t_currentThread = Thread.currentThread();\n\t\t\ttry {\n\t\t\t\tfinal ERXApplication app = ERXApplication.erxApplication();\n\t\t\t\tWOResponse response = app.dispatchRequestImmediately(request());\n\t\t\t\t// testing\n\t\t\t\t// Thread.sleep(6000);\n\t\t\t\t// log.info(\"Done: \" + this);\n\t\t\t\treturn response;\n\t\t\t} finally {\n\t\t\t\tclearThreadInterrupt(_currentThread);\n\t\t\t\t_currentThread = null;\n\t\t\t}\n\t\t}","commit_id":"112afd690be1f53496814027ffb62f762f524c25","url":"https://github.com/wocommunity/wonder"},{"original_method":"public DelayedRequest(WORequest request) {\n\t\t\tsuper();\n\t\t\t_request = request;\n\t\t\t_future = _executor.submit(this);\n\t\t\t_id = ERXRandomGUID.newGid();\n\t\t\t_start = new NSTimestamp();\n\t\t}","id":90722,"modified_method":"public DelayedRequest(WORequest request) {\n\t\t\tsuper();\n\t\t\t_request = (WORequest) request.clone();\n\t\t\t_future = _executor.submit(this);\n\t\t\t_id = ERXRandomGUID.newGid();\n\t\t\t_start = new NSTimestamp();\n\t\t}","commit_id":"112afd690be1f53496814027ffb62f762f524c25","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Create a \"stopped\" page. Note that the session has not been awakened yet\n\t * and you probably shouldn't do it either.\n\t * \n\t * @param request\n\t * @param url\n\t * @return\n\t */\n\tprotected WOResponse createStoppedResponse(WORequest request) {\n\t\tfinal ERXApplication app = ERXApplication.erxApplication();\n\t\tString args = (request.sessionID() != null ? \"wosid=\" + request.sessionID() : \"\");\n\n\t\tWORequest home = app.createRequest(\"GET\", request.applicationURLPrefix() + \"?\" + args, \"HTTP/1.0\", (Map) request.headers(), null, null);\n\t\tWOResponse result = app.dispatchRequestImmediately(home);\n\t\treturn result;\n\t}","id":90723,"modified_method":"/**\n\t * Create a \"stopped\" page. Note that the session has not been awakened yet\n\t * and you probably shouldn't do it either. The default implementation redirect to \n\t * the entry.\n\t * \n\t * @param request\n\t * @param url\n\t * @return\n\t */\n\tprotected WOResponse createStoppedResponse(WORequest request) {\n\t\tfinal ERXApplication app = ERXApplication.erxApplication();\n\t\tString args = (request.sessionID() != null ? \"wosid=\" + request.sessionID() : \"\");\n\n\t\tString url = request.applicationURLPrefix() + \"?\" + args;\n\t\tWOResponse result = new WOResponse();\n\t\tresult.setHeader(url, \"location\");\n\t\tresult.setStatus(302);\n\t\treturn result;\n\t}","commit_id":"112afd690be1f53496814027ffb62f762f524c25","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Creates a request handler instance.\n\t * \n\t * @param refresh\n\t *            time for the refresh of the page\n\t * @param maxRequestTime\n\t *            time that a request can take at most before the delayed page\n\t *            is returned.\n\t * @param cssUrl\n\t *            url for a style sheet for the message page\n\t */\n\tpublic ERXDelayedRequestHandler(int refresh, int maxRequestTime, String cssUrl) {\n\t\t_cssUrl = cssUrl;\n\t\t_refresh = refresh;\n\t\t_maxRequestTime = maxRequestTime;\n\t\t_executor = Executors.newCachedThreadPool();\n\t\t_futures = new ERXExpiringCache<String, DelayedRequest>(refresh() * 5) {\n\t\t\t@Override\n\t\t\tprotected synchronized void removeEntryForKey(Entry<DelayedRequest> entry, String key) {\n\t\t\t\tFuture future = entry.object().future();\n\t\t\t\tif (!future.isDone()) {\n\t\t\t\t\tif (!future.cancel(true)) {\n\t\t\t\t\t\tlog.error(\"Delayed was running, but couldn't be cancelled: \" + entry.object());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.info(\"Stopped delayed request that was still running: \" + entry.object());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.removeEntryForKey(entry, key);\n\t\t\t}\n\t\t};\n\t\t_urls = new ERXExpiringCache(refresh() * 50);\n\t}","id":90724,"modified_method":"/**\n\t * Creates a request handler instance.\n\t * \n\t * @param refresh\n\t *            time for the refresh of the page\n\t * @param maxRequestTime\n\t *            time that a request can take at most before the delayed page\n\t *            is returned.\n\t * @param cssUrl\n\t *            url for a style sheet for the message page\n\t */\n\tpublic ERXDelayedRequestHandler(int refresh, int maxRequestTime, String cssUrl) {\n\t\t_cssUrl = cssUrl;\n\t\t_refresh = refresh;\n\t\t_maxRequestTime = maxRequestTime;\n\t\t_executor = Executors.newCachedThreadPool();\n\t\t_futures = new ERXExpiringCache<String, DelayedRequest>(refresh() * 5) {\n\t\t\t@Override\n\t\t\tprotected synchronized void removeEntryForKey(Entry<DelayedRequest> entry, String key) {\n\t\t\t\tFuture future = entry.object().future();\n\t\t\t\tif (!entry.object().isDone()) {\n\t\t\t\t\tif (!entry.object().cancel()) {\n\t\t\t\t\t\tlog.error(\"Delayed was running, but couldn't be cancelled: \" + entry.object());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlog.info(\"Stopped delayed request that was still running: \" + entry.object());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsuper.removeEntryForKey(entry, key);\n\t\t\t}\n\t\t};\n\t\t_urls = new ERXExpiringCache(refresh() * 50);\n\t}","commit_id":"112afd690be1f53496814027ffb62f762f524c25","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isDone() {\n\t\t\treturn future().isDone();\n\t\t}","id":90725,"modified_method":"public boolean isDone() {\n\t\t\treturn _currentThread == null;\n\t\t}","commit_id":"112afd690be1f53496814027ffb62f762f524c25","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * Override to handle specific actions for the current future.\n\t * \n\t * @param request\n\t * @param delayedRequest\n\t * @param id\n\t * @return\n\t */\n\tprotected WOResponse handle(WORequest request, DelayedRequest delayedRequest, String id) {\n\t\tfinal ERXApplication app = ERXApplication.erxApplication();\n\t\tWOResponse response = null;\n\t\ttry {\n\t\t\tString action = request.stringFormValueForKey(\"action\");\n\t\t\tif (!delayedRequest.isDone()) {\n\t\t\t\tif (\"stop\".equals(action)) {\n\t\t\t\t\tif (delayedRequest.cancel()) {\n\t\t\t\t\t\t_futures.removeObjectForKey(id);\n\t\t\t\t\t\t_urls.setObjectForKey(delayedRequest.request().uri(), id);\n\t\t\t\t\t\tresponse = createStoppedResponse(request);\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString url = request.uri();\n\t\t\t\t\tif (!KEY.equals(request.requestHandlerKey())) {\n\t\t\t\t\t\tString args = \"id=\" + id;\n\t\t\t\t\t\tString sessionID = request.sessionID();\n\t\t\t\t\t\tif (sessionID != null) {\n\t\t\t\t\t\t\targs += \"&wosid=\" + sessionID;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs += \"&__start=\" + delayedRequest.start().getTime();\n\t\t\t\t\t\targs += \"&__time=\" + System.currentTimeMillis();\n\t\t\t\t\t\turl = app.createContextForRequest((WORequest) request.clone()).urlWithRequestHandlerKey(KEY, \"wait\", args);\n\t\t\t\t\t}\n\t\t\t\t\tlog.debug(\"Delaying: \" + request.uri());\n\t\t\t\t\tresponse = createRefreshResponse(request, url);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// AK: this double assignment is not an error. The future will try\n\t\t\t// to get the value. When we time out, the old value from above will\n\t\t\t// be returned. If we don't, then the real response is used.\n\t\t\tresponse = delayedRequest.response(maxRequestTime());\n\t\t\t_futures.removeObjectForKey(id);\n\t\t\t_urls.setObjectForKey(delayedRequest.request().uri(), id);\n\t\t}\n\t\tcatch (InterruptedException e1) {\n\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(e1.getCause());\n\t\t}\n\t\tcatch (ExecutionException e1) {\n\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(e1.getCause());\n\t\t}\n\t\tcatch (TimeoutException e) {\n\t\t\tlog.debug(\"Timed out, redirecting: \" + request.uri());\n\t\t}\n\t\treturn response;\n\t}","id":90726,"modified_method":"/**\n\t * Override to handle specific actions for the current future.\n\t * \n\t * @param request\n\t * @param delayedRequest\n\t * @param id\n\t * @return\n\t */\n\tprotected WOResponse handle(WORequest request, DelayedRequest delayedRequest, String id) {\n\t\tfinal ERXApplication app = ERXApplication.erxApplication();\n\t\tWOResponse response = null;\n\t\ttry {\n\t\t\tString action = request.stringFormValueForKey(\"action\");\n\t\t\tif (!delayedRequest.isDone()) {\n\t\t\t\tif (\"stop\".equals(action)) {\n\t\t\t\t\tif (delayedRequest.cancel()) {\n\t\t\t\t\t\t_futures.removeObjectForKey(id);\n\t\t\t\t\t\t_urls.setObjectForKey(delayedRequest.request().uri(), id);\n\t\t\t\t\t\tresponse = createStoppedResponse(request);\n\t\t\t\t\t\treturn response;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString url = request.uri();\n\t\t\t\t\tif (!KEY.equals(request.requestHandlerKey())) {\n\t\t\t\t\t\tString args = \"id=\" + id;\n\t\t\t\t\t\tString sessionID = request.sessionID();\n\t\t\t\t\t\tif (sessionID != null) {\n\t\t\t\t\t\t\targs += \"&wosid=\" + sessionID;\n\t\t\t\t\t\t}\n\t\t\t\t\t\targs += \"&__start=\" + delayedRequest.start().getTime();\n\t\t\t\t\t\targs += \"&__time=\" + System.currentTimeMillis();\n\t\t\t\t\t\turl = app.createContextForRequest((WORequest) request.clone()).urlWithRequestHandlerKey(KEY, \"wait\", args);\n\t\t\t\t\t}\n\t\t\t\t\tlog.debug(\"Delaying: \" + request.uri());\n\t\t\t\t\tresponse = createRefreshResponse(request, url);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// AK: this double assignment is not an error. The future will try\n\t\t\t// to get the value. When we time out, the old value from above will\n\t\t\t// be returned. If we don't, then the real response is used.\n\t\t\tresponse = delayedRequest.response(maxRequestTime());\n\t\t\t_futures.removeObjectForKey(id);\n\t\t\t_urls.setObjectForKey(delayedRequest.request().uri(), id);\n\t\t}\n\t\tcatch (InterruptedException e1) {\n\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(e1.getCause());\n\t\t}\n\t\tcatch (ExecutionException e1) {\n\t\t\tthrow NSForwardException._runtimeExceptionForThrowable(e1.getCause());\n\t\t}\n\t\tcatch (CancellationException e) {\n\t\t\tlog.info(\"Cancelled, redirecting: \" + request.uri());\n\t\t\tresponse = createStoppedResponse(request);\n\t\t}\n\t\tcatch (TimeoutException e) {\n\t\t\tlog.debug(\"Timed out, redirecting: \" + request.uri());\n\t\t}\n\t\treturn response;\n\t}","commit_id":"112afd690be1f53496814027ffb62f762f524c25","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n         * This query could not be canceled.\n         */\n        public void cancel()\n        {\n            callHistoryQuery.cancel();\n        }","id":90727,"modified_method":"/**\n         * This query could not be canceled.\n         */\n        public void cancel()\n        {\n            if (callHistoryQuery != null)\n                callHistoryQuery.cancel();\n        }","commit_id":"b668f527c286f42ca62b1372770b3170e35157d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"public boolean isCanceled()\n    {\n        return isCanceled;\n    }","id":90728,"modified_method":"/**\n     * Indicates if this query is canceled.\n     * @return <tt>true<\/tt> if this query is canceled, <tt>false<\/tt> otherwise\n     */\n    public boolean isCanceled()\n    {\n        return isCanceled;\n    }","commit_id":"b668f527c286f42ca62b1372770b3170e35157d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void cancel()\n    {\n        isCanceled = true;\n    }","id":90729,"modified_method":"/**\n     * Cancels this filter query.\n     */\n    public void cancel()\n    {\n        isCanceled = true;\n        filterQueries.clear();\n        fireFilterQueryEvent();\n    }","commit_id":"b668f527c286f42ca62b1372770b3170e35157d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"public Collection<ExternalContactSource> getContactSources()\n    {\n        if (contactSources == null)\n            contactSources = TreeContactList.getContactSources();\n\n        return contactSources;\n    }","id":90730,"modified_method":"/**\n     * Returns the list of <tt>ExternalContactSource<\/tt> this filter searches\n     * in.\n     * @return the list of <tt>ExternalContactSource<\/tt> this filter searches\n     * in\n     */\n    public Collection<ExternalContactSource> getContactSources()\n    {\n        if (contactSources == null)\n            contactSources = TreeContactList.getContactSources();\n\n        return contactSources;\n    }","commit_id":"b668f527c286f42ca62b1372770b3170e35157d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Applies this filter to the given <tt>contactSource<\/tt> and stores the\n     * result in the given <tt>treeModel<\/tt>.\n     *\n     * @param contactSource the <tt>ExternalContactSource<\/tt> to apply the\n     * filter to\n     * @param treeModel the <tt>ContactListTreeModel<\/tt> in which the results\n     * are stored\n     */\n    public void applyFilter(ExternalContactSource contactSource,\n                            ContactListTreeModel treeModel)\n    {\n        logger.debug(\"Search filter applied on source: \"\n                + contactSource.getContactSourceService());\n\n        ContactSourceService sourceService\n            = contactSource.getContactSourceService();\n\n        if (sourceService instanceof ExtendedContactSourceService)\n            currentQuery\n                = ((ExtendedContactSourceService) sourceService)\n                    .queryContactSource(filterPattern);\n        else\n            currentQuery = sourceService.queryContactSource(filterString);\n\n        // Add first available results.\n        this.addMatching(currentQuery.getQueryResults(), treeModel);\n\n        currentQuery.addContactQueryListener(GuiActivator.getContactList());\n    }","id":90731,"modified_method":"/**\n     * Applies this filter to the given <tt>contactSource<\/tt> and stores the\n     * result in the given <tt>treeModel<\/tt>.\n     *\n     * @param contactSource the <tt>ExternalContactSource<\/tt> to apply the\n     * filter to\n     * @param treeModel the <tt>ContactListTreeModel<\/tt> in which the results\n     * are stored\n     * @return the <tt>ContactQuery<\/tt> that tracks this filter\n     */\n    public ContactQuery applyFilter(ExternalContactSource contactSource,\n                                    ContactListTreeModel treeModel)\n    {\n        logger.debug(\"Search filter applied on source: \"\n                + contactSource.getContactSourceService());\n\n        ContactSourceService sourceService\n            = contactSource.getContactSourceService();\n\n        if (sourceService instanceof ExtendedContactSourceService)\n            currentQuery\n                = ((ExtendedContactSourceService) sourceService)\n                    .queryContactSource(filterPattern);\n        else\n            currentQuery = sourceService.queryContactSource(filterString);\n\n        // Add first available results.\n        this.addMatching(currentQuery.getQueryResults(), treeModel);\n\n        currentQuery.addContactQueryListener(GuiActivator.getContactList());\n\n        return currentQuery;\n    }","commit_id":"b668f527c286f42ca62b1372770b3170e35157d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Indicates that the status of a query has changed.\n     * @param event the <tt>ContactQueryStatusEvent<\/tt> that notified us\n     */\n    public void queryStatusChanged(ContactQueryStatusEvent event)\n    {\n        int eventType = event.getEventType();\nSystem.out.println(\"EHOOOOOOOOOO=========\" + event.getEventType());\n        if (eventType == ContactQueryStatusEvent.QUERY_ERROR)\n        {\n            //TODO: Show the error to the user??\n        }\n\n        event.getQuerySource().removeContactQueryListener(this);\n    }","id":90732,"modified_method":"/**\n     * Indicates that the status of a query has changed.\n     * @param event the <tt>ContactQueryStatusEvent<\/tt> that notified us\n     */\n    public void queryStatusChanged(ContactQueryStatusEvent event)\n    {\n        int eventType = event.getEventType();\n\n        if (eventType == ContactQueryStatusEvent.QUERY_ERROR)\n        {\n            //TODO: Show the error to the user??\n        }\n        event.getQuerySource().removeContactQueryListener(this);\n    }","commit_id":"b668f527c286f42ca62b1372770b3170e35157d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Applies the given <tt>ContactListSourceFilter<\/tt>.\n     * @param filter the <tt>ContactListSourceFilter<\/tt> to apply\n     * @return the <tt>FilterQuery<\/tt> through which the filter could be\n     * tracked\n     */\n    public FilterQuery applyFilter(final ContactListSourceFilter filter)\n    {\n        final ContactListTreeModel tempTreeModel = new ContactListTreeModel();\n\n        filterQuery = new FilterQuery();\n\n        // If the filter has a default contact source, we apply it first.\n        if (filter.hasDefaultSource())\n            filterQuery.setSucceeded(applyFilter(filter, tempTreeModel, null));\n\n        Iterator<ExternalContactSource> filterSources\n             = filter.getContactSources().iterator();\n\n        // Then we apply the filter on all its contact sources.\n        while (filterSources.hasNext())\n        {\n            final ExternalContactSource filterSource = filterSources.next();\n\n            if (filterQuery.isCanceled())\n                return filterQuery;\n\n            filterQuery.addWaitResult();\n            new Thread()\n            {\n                public void run()\n                {\n                    boolean isSucceeded\n                        = applyFilter(  filter,\n                                        tempTreeModel,\n                                        filterSource);\n\n                    if (!filterQuery.isSucceeded() && isSucceeded)\n                        filterQuery.setSucceeded(true);\n\n                    filterQuery.removeWaitResult();\n                }\n            }.start();\n        }\n        return filterQuery;\n    }","id":90733,"modified_method":"/**\n     * Applies the given <tt>ContactListSourceFilter<\/tt>.\n     * @param filter the <tt>ContactListSourceFilter<\/tt> to apply\n     * @return the <tt>FilterQuery<\/tt> through which the filter could be\n     * tracked\n     */\n    public FilterQuery applyFilter(final ContactListSourceFilter filter)\n    {\n        final ContactListTreeModel tempTreeModel = new ContactListTreeModel();\n\n        filterQuery = new FilterQuery();\n\n        // If the filter has a default contact source, we apply it first.\n        if (filter.hasDefaultSource())\n            filterQuery.setSucceeded(applyFilter(filter, tempTreeModel, null));\n\n        Iterator<ExternalContactSource> filterSources\n             = filter.getContactSources().iterator();\n\n        // Then we apply the filter on all its contact sources.\n        while (filterSources.hasNext())\n        {\n            final ExternalContactSource filterSource = filterSources.next();\n\n            if (filterQuery.isCanceled())\n                return filterQuery;\n\n            new Thread()\n            {\n                public void run()\n                {\n                    boolean isSucceeded\n                        = applyFilter(  filter,\n                                        tempTreeModel,\n                                        filterSource);\n\n                    filterQuery.setSucceeded(\n                        !filterQuery.isSucceeded() && isSucceeded);\n                }\n            }.start();\n        }\n        return filterQuery;\n    }","commit_id":"b668f527c286f42ca62b1372770b3170e35157d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Applies the given <tt>filter<\/tt> and changes the content of the\n     * contact list according to it.\n     * @param filter the new filter to set\n     * @param tempTreeModel the treeModel, where the filter results are stored\n     * @param contactSource the <tt>ExternalContactSource<\/tt> to apply the\n     * filter to\n     * @return <tt>true<\/tt> to indicate that the filter has found a match, \n     * <tt>false<\/tt> if no matches were found and the contact list is then\n     * empty.\n     */\n    private boolean applyFilter(ContactListFilter filter,\n                                ContactListTreeModel tempTreeModel,\n                                ExternalContactSource contactSource)\n    {\n        // We set the isFiltering to true to indicate that we're currently\n        // filtering.\n        isFiltering = true;\n\n        if (currentFilter == null || !currentFilter.equals(filter))\n            this.currentFilter = filter;\n\n        // We synchronize the matching and all MetaContactListener events on\n        // the searchTreeModel in order to prevent modification to be done on\n        // the actual treeModel while we're working with the temporary model.\n        synchronized (filterLock)\n        {\n            treeModel.clearDependencies();\n\n            // If we have a specific contact source and we're dealing with\n            // a ContactListSourceFilter then we would apply the filter only\n            // to this source.\n            if (contactSource != null\n                    && filter instanceof ContactListSourceFilter)\n                ((ContactListSourceFilter) currentFilter)\n                    .applyFilter(contactSource, tempTreeModel);\n            else\n                currentFilter.applyFilter(tempTreeModel);\n\n            treeModel = tempTreeModel;\n        }\n\n        // If in the mean time someone has stopped filtering we return here.\n        if (!isFiltering)\n        {\n            return (treeModel.getChildCount(treeModel.getRoot()) > 0);\n        }\n\n        SwingUtilities.invokeLater(new Runnable()\n        {\n            public void run()\n            {\n                // Set the updated treeModel to the tree component.\n                setTreeModel(treeModel);\n\n                // Refresh the view.\n                treeModel.reload();\n\n                // Expand all rows. Should be done only after the new model\n                // is visible to have effect.\n                expandAllRows();\n\n                // We should explicitly re-validate the whole tree as we\n                // changed its model.\n                revalidate();\n                repaint();\n            }\n        });\n\n        // We set the isFiltering to false to indicate that we finished\n        // filtering.\n        isFiltering = false;\n\n        boolean hasResults = false;\n\n        // As we update the tree in the swing thread, we should check the\n        // temporary model here in order to given correct results.\n        if (tempTreeModel.getChildCount(tempTreeModel.getRoot()) > 0)\n            hasResults = true;\n\n        return hasResults;\n    }","id":90734,"modified_method":"/**\n     * Applies the given <tt>filter<\/tt> and changes the content of the\n     * contact list according to it.\n     * @param filter the new filter to set\n     * @param tempTreeModel the treeModel, where the filter results are stored\n     * @param contactSource the <tt>ExternalContactSource<\/tt> to apply the\n     * filter to\n     * @return <tt>true<\/tt> to indicate that the filter has found a match, \n     * <tt>false<\/tt> if no matches were found and the contact list is then\n     * empty.\n     */\n    private boolean applyFilter(ContactListFilter filter,\n                                ContactListTreeModel tempTreeModel,\n                                ExternalContactSource contactSource)\n    {\n        // We set the isFiltering to true to indicate that we're currently\n        // filtering.\n        isFiltering = true;\n\n        if (currentFilter == null || !currentFilter.equals(filter))\n            this.currentFilter = filter;\n\n        // We synchronize the matching and all MetaContactListener events on\n        // the searchTreeModel in order to prevent modification to be done on\n        // the actual treeModel while we're working with the temporary model.\n        synchronized (filterLock)\n        {\n            treeModel.clearDependencies();\n\n            // If we have a specific contact source and we're dealing with\n            // a ContactListSourceFilter then we would apply the filter only\n            // to this source.\n            if (contactSource != null\n                    && filter instanceof ContactListSourceFilter)\n            {\n                ContactQuery contactQuery\n                    = ((ContactListSourceFilter) currentFilter)\n                        .applyFilter(contactSource, tempTreeModel);\n\n                filterQuery.addContactQuery(contactQuery);\n            }\n            else\n                currentFilter.applyFilter(tempTreeModel);\n\n            treeModel = tempTreeModel;\n        }\n\n        // If in the mean time someone has stopped filtering we return here.\n        if (!isFiltering)\n        {\n            return (treeModel.getChildCount(treeModel.getRoot()) > 0);\n        }\n\n        SwingUtilities.invokeLater(new Runnable()\n        {\n            public void run()\n            {\n                // Set the updated treeModel to the tree component.\n                setTreeModel(treeModel);\n\n                // Refresh the view.\n                treeModel.reload();\n\n                // Expand all rows. Should be done only after the new model\n                // is visible to have effect.\n                expandAllRows();\n\n                // We should explicitly re-validate the whole tree as we\n                // changed its model.\n                revalidate();\n                repaint();\n            }\n        });\n\n        // We set the isFiltering to false to indicate that we finished\n        // filtering.\n        isFiltering = false;\n\n        boolean hasResults = false;\n\n        // As we update the tree in the swing thread, we should check the\n        // temporary model here in order to given correct results.\n        if (tempTreeModel.getChildCount(tempTreeModel.getRoot()) > 0)\n            hasResults = true;\n\n        return hasResults;\n    }","commit_id":"b668f527c286f42ca62b1372770b3170e35157d9","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void removeTable(UUID tableId) {\n\t\tif (tables.containsKey(tableId)) {\n\t\t\tTable table = tables.get(tableId);\n\t\t\ttable.getMatch().getGame().end();\n\t\t}\n\t\tcontrollers.remove(tableId);\n\t\ttables.remove(tableId);\n\t\tGamesRoomManager.getInstance().removeTable(tableId);\n\t}","id":90735,"modified_method":"public void removeTable(UUID tableId) {\n\t\tif (tables.containsKey(tableId)) {\n\t\t\tTable table = tables.get(tableId);\n\t\t\tcontrollers.remove(tableId);\n\t\t\ttables.remove(tableId);\n\t\t\tGamesRoomManager.getInstance().removeTable(tableId);\n\t\t\ttable.getMatch().getGame().end();\n\t\t}\n\t}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"public void showDialog(UUID roomId, UUID tableId, boolean isTournament) {\n\t\tthis.roomId = roomId;\n\t\tthis.tableId = tableId;\n\t\tthis.isTournament = isTournament;\n\t\tsession = MageFrame.getSession();\n\t\tupdateTask = new UpdateSeatsTask(session, roomId, tableId, this);\n\t\tif (session.isTableOwner(roomId, tableId)) {\n\t\t\tthis.btnStart.setVisible(true);\n\t\t\tthis.btnMoveDown.setVisible(true);\n\t\t\tthis.btnMoveUp.setVisible(true);\n\t\t} else {\n\t\t\tthis.btnStart.setVisible(false);\n\t\t\tthis.btnMoveDown.setVisible(false);\n\t\t\tthis.btnMoveUp.setVisible(false);\n\t\t}\n\t\tUUID chatId = session.getTableChatId(tableId);\n\t\tif (chatId != null) {\n\t\t\tthis.chatPanel.connect(chatId);\n\t\t\tupdateTask.execute();\n\t\t\tthis.setModal(true);\n\t\t\tthis.setLocation(100, 100);\n\t\t\tthis.setVisible(true);\n\t\t}\n\t\telse {\n\t\t\tcloseDialog();\n\t\t}\n\t}","id":90736,"modified_method":"public void showDialog(UUID roomId, UUID tableId, boolean isTournament) {\n\t\tthis.roomId = roomId;\n\t\tthis.tableId = tableId;\n\t\tthis.isTournament = isTournament;\n\t\tsession = MageFrame.getSession();\n\t\tupdateTask = new UpdateSeatsTask(session, roomId, tableId, this);\n\t\tif (session.isTableOwner(roomId, tableId)) {\n\t\t\tthis.btnStart.setVisible(true);\n\t\t\tthis.btnMoveDown.setVisible(true);\n\t\t\tthis.btnMoveUp.setVisible(true);\n\t\t} else {\n\t\t\tthis.btnStart.setVisible(false);\n\t\t\tthis.btnMoveDown.setVisible(false);\n\t\t\tthis.btnMoveUp.setVisible(false);\n\t\t}\n\t\tUUID chatId = session.getTableChatId(tableId);\n\t\tif (chatId != null) {\n\t\t\tthis.chatPanel.connect(chatId);\n\t\t\tupdateTask.execute();\n\t\t\tthis.setModal(false);\n\t\t\tthis.setLocation(100, 100);\n\t\t\tthis.setVisible(true);\n\t\t}\n\t\telse {\n\t\t\tcloseDialog();\n\t\t}\n\t}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"public void closeDialog() {\n\t\tupdateTask.cancel(true);\n\t\tthis.chatPanel.disconnect();\n\t\tsetVisible(false);\n\t}","id":90737,"modified_method":"public void closeDialog() {\n\t\tif (updateTask != null)\tupdateTask.cancel(true);\n\t\tthis.chatPanel.disconnect();\n\t\tsetVisible(false);\n\t}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"private void btnCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelActionPerformed\n\t\tif (session.isTableOwner(roomId, tableId)) {\n\t\t\tsession.removeTable(roomId, tableId);\n\t\t} else {\n\t\t\tsession.leaveTable(roomId, tableId);\n\t\t}\n\t\tcloseDialog();\n\t}","id":90738,"modified_method":"private void btnCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnCancelActionPerformed\n\t\ttry {\n\t\t\tif (session.isTableOwner(roomId, tableId)) {\n\t\t\t\tsession.removeTable(roomId, tableId);\n\t\t\t} else {\n\t\t\t\tsession.leaveTable(roomId, tableId);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t//swallow exception\n\t\t\tlogger.error(e);\n\t\t}\n\t\tcloseDialog();\n\t}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"/** Creates new form TablesPanel */\n    public TablesPanel() {\n\t\t\n\t\ttableModel = new TableTableModel();\n\n        initComponents();\n\n\t\ttableTables.createDefaultColumnsFromModel();\n\n\t\tAction join = new AbstractAction()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e)\n\t\t\t{\n\t\t\t\tint modelRow = Integer.valueOf( e.getActionCommand() );\n\t\t\t\tUUID tableId = (UUID)tableModel.getValueAt(modelRow, 8);\n\t\t\t\tUUID gameId = (UUID)tableModel.getValueAt(modelRow, 7);\n\t\t\t\tString state = (String)tableModel.getValueAt(modelRow, 5);\n\t\t\t\tboolean isTournament = (Boolean)tableModel.getValueAt(modelRow, 6);\n\n\t\t\t\tif (state.equals(\"Join\")) {\n\t\t\t\t\tif (isTournament) {\n\t\t\t\t\t\tlogger.info(\"Joining tournament \" + tableId);\n\t\t\t\t\t\tif (session.joinTournamentTable(roomId, tableId, session.getUserName(), \"Human\", 1))\n\t\t\t\t\t\t\ttableWaitingDialog.showDialog(roomId, tableId, true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlogger.info(\"Joining table \" + tableId);\n\t\t\t\t\t\tjoinTableDialog.showDialog(roomId, tableId);\n\t\t\t\t\t\tif (joinTableDialog.isJoined())\n\t\t\t\t\t\t\ttableWaitingDialog.showDialog(roomId, tableId, false);\n\t\t\t\t\t}\n\t\t\t\t} else if (state.equals(\"Watch\")) {\n\t\t\t\t\tlogger.info(\"Watching table \" + tableId);\n\t\t\t\t\tsession.watchTable(roomId, tableId);\n\t\t\t\t} else if (state.equals(\"Replay\")) {\n\t\t\t\t\tlogger.info(\"Replaying game \" + gameId);\n\t\t\t\t\tsession.replayGame(gameId);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tButtonColumn buttonColumn = new ButtonColumn(tableTables, join, 5);\n\t\t\n\t\tjSplitPane1.setOpaque(false);\n\t\tjScrollPane1.setOpaque(false);\n\t\tjPanel1.setOpaque(false);\n\t\tjScrollPane1.getViewport().setBackground(new Color(20,20,20,150));\n    }","id":90739,"modified_method":"/** Creates new form TablesPanel */\n    public TablesPanel() {\n\t\t\n\t\ttableModel = new TableTableModel();\n\n        initComponents();\n\n\t\ttableTables.createDefaultColumnsFromModel();\n\n\t\tAction join = new AbstractAction()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e)\n\t\t\t{\n\t\t\t\tint modelRow = Integer.valueOf( e.getActionCommand() );\n\t\t\t\tUUID tableId = (UUID)tableModel.getValueAt(modelRow, 8);\n\t\t\t\tUUID gameId = (UUID)tableModel.getValueAt(modelRow, 7);\n\t\t\t\tString state = (String)tableModel.getValueAt(modelRow, 5);\n\t\t\t\tboolean isTournament = (Boolean)tableModel.getValueAt(modelRow, 6);\n\t\t\t\tString owner = (String)tableModel.getValueAt(modelRow, 1);\n\n\t\t\t\tif (state.equals(\"Join\")) {\n\t\t\t\t\tif (owner.equals(session.getUserName())) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tJDesktopPane desktopPane = (JDesktopPane)session.getUI().getComponent(MageComponents.DESKTOP_PANE);\n\t\t\t\t\t\t\tJInternalFrame[] windows = desktopPane.getAllFramesInLayer(javax.swing.JLayeredPane.DEFAULT_LAYER);\n\t\t\t\t\t\t\tfor (JInternalFrame frame : windows) {\n\t\t\t\t\t\t\t\tif (frame.getTitle().equals(\"Waiting for players\")) {\n\t\t\t\t\t\t\t\t\tframe.toFront();\n\t\t\t\t\t\t\t\t\tframe.setVisible(true);\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tframe.setSelected(true);\n\t\t\t\t\t\t\t\t\t} catch (PropertyVetoException ve) {\n\t\t\t\t\t\t\t\t\t\tve.printStackTrace();\n\t\t\t\t\t\t\t\t\t\tlogger.error(ve);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\tlogger.error(ex);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (isTournament) {\n\t\t\t\t\t\tlogger.info(\"Joining tournament \" + tableId);\n\t\t\t\t\t\tif (session.joinTournamentTable(roomId, tableId, session.getUserName(), \"Human\", 1))\n\t\t\t\t\t\t\ttableWaitingDialog.showDialog(roomId, tableId, true);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlogger.info(\"Joining table \" + tableId);\n\t\t\t\t\t\tjoinTableDialog.showDialog(roomId, tableId);\n\t\t\t\t\t\tif (joinTableDialog.isJoined())\n\t\t\t\t\t\t\ttableWaitingDialog.showDialog(roomId, tableId, false);\n\t\t\t\t\t}\n\t\t\t\t} else if (state.equals(\"Watch\")) {\n\t\t\t\t\tlogger.info(\"Watching table \" + tableId);\n\t\t\t\t\tsession.watchTable(roomId, tableId);\n\t\t\t\t} else if (state.equals(\"Replay\")) {\n\t\t\t\t\tlogger.info(\"Replaying game \" + gameId);\n\t\t\t\t\tsession.replayGame(gameId);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tButtonColumn buttonColumn = new ButtonColumn(tableTables, join, 5);\n\t\t\n\t\tjSplitPane1.setOpaque(false);\n\t\tjScrollPane1.setOpaque(false);\n\t\tjPanel1.setOpaque(false);\n\t\tjScrollPane1.getViewport().setBackground(new Color(20,20,20,150));\n    }","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"private void btnNewTournamentActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNewTournamentActionPerformed\n\t\tnewTournamentDialog.showDialog(roomId);\n\t\tif (newTournamentDialog.getTable() != null) {\n\t\t\ttableWaitingDialog.showDialog(roomId, newTournamentDialog.getTable().getTableId(), true);\n\t\t}\n\t}","id":90740,"modified_method":"private void btnNewTournamentActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNewTournamentActionPerformed\n\t\tnewTournamentDialog = new NewTournamentDialog();\n\t\tMageFrame.getDesktop().add(newTournamentDialog);\n\t\tnewTournamentDialog.showDialog(roomId);\n\t\tif (newTournamentDialog.getTable() != null) {\n\t\t\ttableWaitingDialog.showDialog(roomId, newTournamentDialog.getTable().getTableId(), true);\n\t\t}\n\t}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"public void showTables(UUID roomId) {\n\n\t\tthis.roomId = roomId;\n\t\tsession = MageFrame.getSession();\n\t\tupdateTask = new UpdateTablesTask(session, roomId, this);\n\t\tupdatePlayersTask = new UpdatePlayersTask(session, roomId, this.chatPanel);\n\t\tif (session != null) {\n\t\t\tbtnQuickStart.setVisible(session.isTestMode());\n\t\t}\n\t\tif (newTableDialog == null) {\n\t\t\tnewTableDialog = new NewTableDialog();\n\t\t\tMageFrame.getDesktop().add(newTableDialog);\n\t\t}\n\t\tif (newTournamentDialog == null) {\n\t\t\tnewTournamentDialog = new NewTournamentDialog();\n\t\t\tMageFrame.getDesktop().add(newTournamentDialog);\n\t\t}\n\t\tif (joinTableDialog == null) {\n\t\t\tjoinTableDialog = new JoinTableDialog();\n\t\t\tMageFrame.getDesktop().add(joinTableDialog);\n\t\t}\n\t\tif (tableWaitingDialog == null) {\n\t\t\ttableWaitingDialog = new TableWaitingDialog();\n\t\t\tMageFrame.getDesktop().add(tableWaitingDialog);\n\t\t}\n\t\tUUID chatRoomId = session.getRoomChatId(roomId);\n\t\tif (chatRoomId != null) {\n\t\t\tthis.chatPanel.connect(chatRoomId);\n\t\t\tupdateTask.execute();\n\t\t\tupdatePlayersTask.execute();\n\t\t\tthis.setVisible(true);\n\t\t\tthis.repaint();\n\t\t}\n\t\telse {\n\t\t\thideTables();\n\t\t}\n\t\t\n\t\tsession.getUI().addButton(MageComponents.NEW_GAME_BUTTON, btnNewTable);\n\t}","id":90741,"modified_method":"public void showTables(UUID roomId) {\n\n\t\tthis.roomId = roomId;\n\t\tsession = MageFrame.getSession();\n\t\tupdateTask = new UpdateTablesTask(session, roomId, this);\n\t\tupdatePlayersTask = new UpdatePlayersTask(session, roomId, this.chatPanel);\n\t\tif (session != null) {\n\t\t\tbtnQuickStart.setVisible(session.isTestMode());\n\t\t}\n\t\tif (newTableDialog == null) {\n\t\t\tnewTableDialog = new NewTableDialog();\n\t\t\tMageFrame.getDesktop().add(newTableDialog);\n\t\t}\n\t\tif (newTournamentDialog == null) {\n\t\t\tnewTournamentDialog = new NewTournamentDialog();\n\t\t\tMageFrame.getDesktop().add(newTournamentDialog);\n\t\t}\n\t\tif (joinTableDialog == null) {\n\t\t\tjoinTableDialog = new JoinTableDialog();\n\t\t\tMageFrame.getDesktop().add(joinTableDialog);\n\t\t}\n\t\t/*if (tableWaitingDialog == null) {\n\t\t\ttableWaitingDialog = new TableWaitingDialog();\n\t\t\tMageFrame.getDesktop().add(tableWaitingDialog);\n\t\t}*/\n\t\tUUID chatRoomId = session.getRoomChatId(roomId);\n\t\tif (chatRoomId != null) {\n\t\t\tthis.chatPanel.connect(chatRoomId);\n\t\t\tupdateTask.execute();\n\t\t\tupdatePlayersTask.execute();\n\t\t\tthis.setVisible(true);\n\t\t\tthis.repaint();\n\t\t}\n\t\telse {\n\t\t\thideTables();\n\t\t}\n\t\t\n\t\tsession.getUI().addButton(MageComponents.NEW_GAME_BUTTON, btnNewTable);\n\t}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"private void handleError(Exception ex) {\n\t\tlogger.log(Level.SEVERE, \"Error loading deck\", ex);\n\t\tJOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Error loading deck.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n\t}","id":90742,"modified_method":"private void handleError(Exception ex) {\n\t\tlogger.fatal(\"Error loading deck: \", ex);\n\t\tJOptionPane.showMessageDialog(MageFrame.getDesktop(), \"Error loading deck.\", \"Error\", JOptionPane.ERROR_MESSAGE);\n\t}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"private void btnNewTableActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNewTableActionPerformed\n\t\tnewTableDialog.showDialog(roomId);\n\t\tif (newTableDialog.getTable() != null) {\n\t\t\ttableWaitingDialog.showDialog(roomId, newTableDialog.getTable().getTableId(), false);\n\t\t}\n}","id":90743,"modified_method":"private void btnNewTableActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNewTableActionPerformed\n\t\tnewTableDialog.showDialog(roomId);\n\t\tif (newTableDialog.getTable() != null) {\n\t\t\ttableWaitingDialog = new TableWaitingDialog();\n\t\t\tMageFrame.getDesktop().add(tableWaitingDialog);\n\t\t\ttableWaitingDialog.showDialog(roomId, newTableDialog.getTable().getTableId(), false);\n\t\t}\n}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"public void hideTables() {\n\t\tif (tableWaitingDialog != null && tableWaitingDialog.isVisible()) {\n\t\t\ttableWaitingDialog.closeDialog();\n\t\t}\n\t\tif (updateTask != null)\n\t\t\tupdateTask.cancel(true);\n\t\tif (updatePlayersTask != null)\n\t\t\tupdatePlayersTask.cancel(true);\n\t\tthis.chatPanel.disconnect();\n\n\t\tComponent c = this.getParent();\n\t\twhile (c != null && !(c instanceof TablesPane)) {\n\t\t\tc = c.getParent();\n\t\t}\n\t\tif (c != null)\n\t\t\tc.setVisible(false);\n\t}","id":90744,"modified_method":"public void hideTables() {\n\t\t/*if (tableWaitingDialog != null && tableWaitingDialog.isVisible()) {\n\t\t\ttableWaitingDialog.closeDialog();\n\t\t}*/\n\t\tfor (Component component : MageFrame.getDesktop().getComponents()) {\n\t\t\tif (component instanceof TableWaitingDialog) {\n\t\t\t\t((TableWaitingDialog)component).closeDialog();\n\t\t\t}\n\t\t}\n\t\tif (updateTask != null)\n\t\t\tupdateTask.cancel(true);\n\t\tif (updatePlayersTask != null)\n\t\t\tupdatePlayersTask.cancel(true);\n\t\tthis.chatPanel.disconnect();\n\n\t\tComponent c = this.getParent();\n\t\twhile (c != null && !(c instanceof TablesPane)) {\n\t\t\tc = c.getParent();\n\t\t}\n\t\tif (c != null)\n\t\t\tc.setVisible(false);\n\t}","commit_id":"4133a1312051e7905daa78f1809b7d088b55d87e","url":"https://github.com/magefree/mage"},{"original_method":"public void stop()\n    {\n        scheduledGossipTask.cancel(false);\n        logger.info(\"Announcing shutdown\");\n        Uninterruptibles.sleepUninterruptibly(intervalInMillis * 2, TimeUnit.MILLISECONDS);\n        MessageOut message = new MessageOut(MessagingService.Verb.GOSSIP_SHUTDOWN);\n        for (InetAddress ep : liveEndpoints)\n            MessagingService.instance().sendOneWay(message, ep);\n    }","id":90745,"modified_method":"public void stop()\n    {\n    \tif (scheduledGossipTask != null)\n    \t\tscheduledGossipTask.cancel(false);\n        logger.info(\"Announcing shutdown\");\n        Uninterruptibles.sleepUninterruptibly(intervalInMillis * 2, TimeUnit.MILLISECONDS);\n        MessageOut message = new MessageOut(MessagingService.Verb.GOSSIP_SHUTDOWN);\n        for (InetAddress ep : liveEndpoints)\n            MessagingService.instance().sendOneWay(message, ep);\n    }","commit_id":"ea5b6246d24c6092cda17c28610f76b17b0be25c","url":"https://github.com/apache/cassandra"},{"original_method":"protected void addTaskToWorker(final Runnable runnable, boolean first, final Runnable postRunnable) {\n    Runnable runnable1 = new Runnable() {\n      public void run() {\n        try {\n          ProgressManager.getInstance().runProcess(\n            new Runnable() {\n              public void run() {\n                ApplicationManager.getApplication().runReadAction(runnable);\n                if (postRunnable != null) {\n                  ApplicationManager.getApplication().invokeLater(postRunnable);\n                }\n              }\n            },\n            myProgress\n          );\n        }\n        catch (ProcessCanceledException e) {\n          //ignore\n        }\n      }\n    };\n\n    if (myWorker == null || myWorker.isDisposed()) {\n      myWorker = new WorkerThread(\"AbstractTreeBuilder.Worker\");\n      myWorker.start();\n      if (first) {\n        myWorker.addTaskFirst(runnable1);\n      }\n      else {\n        myWorker.addTask(runnable1);\n      }\n      myWorker.dispose(false);\n    }\n    else {\n      if (first) {\n        myWorker.addTaskFirst(runnable1);\n      }\n      else {\n        myWorker.addTask(runnable1);\n      }\n    }\n  }","id":90746,"modified_method":"protected void addTaskToWorker(final Runnable runnable, boolean first, final Runnable postRunnable) {\n    Runnable runnable1 = new Runnable() {\n      public void run() {\n        try {\n          Runnable runnable2 = new Runnable() {\n              public void run() {\n                ApplicationManager.getApplication().runReadAction(runnable);\n                if (postRunnable != null) {\n                  ApplicationManager.getApplication().invokeLater(postRunnable);\n                }\n              }\n            };\n          if (myProgress != null) {\n            ProgressManager.getInstance().runProcess(runnable2, myProgress);\n          } else {\n            runnable2.run();\n          }\n        }\n        catch (ProcessCanceledException e) {\n          //ignore\n        }\n      }\n    };\n\n    if (myWorker == null || myWorker.isDisposed()) {\n      myWorker = new WorkerThread(\"AbstractTreeBuilder.Worker\");\n      myWorker.start();\n      if (first) {\n        myWorker.addTaskFirst(runnable1);\n      }\n      else {\n        myWorker.addTask(runnable1);\n      }\n      myWorker.dispose(false);\n    }\n    else {\n      if (first) {\n        myWorker.addTaskFirst(runnable1);\n      }\n      else {\n        myWorker.addTask(runnable1);\n      }\n    }\n  }","commit_id":"b7f07db63477802a18690ff04eb9e6449a2dc63a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n    LOG.assertTrue(!myDisposed);\n    myDisposed = true;\n    myTree.removeTreeExpansionListener(myExpansionListener);\n    disposeNode(myRootNode);\n    myElementToNodeMap.clear();\n    myUpdater.cancelAllRequests();\n    myUpdater.dispose();\n    if (myWorker != null) {\n      myWorker.dispose(true);\n    }\n    myElementToNodeMap.clear();\n    TREE_NODE_WRAPPER.setValue(null);\n    myProgress.cancel();\n  }","id":90747,"modified_method":"public void dispose() {\n    LOG.assertTrue(!myDisposed);\n    myDisposed = true;\n    myTree.removeTreeExpansionListener(myExpansionListener);\n    disposeNode(myRootNode);\n    myElementToNodeMap.clear();\n    myUpdater.cancelAllRequests();\n    myUpdater.dispose();\n    if (myWorker != null) {\n      myWorker.dispose(true);\n    }\n    myElementToNodeMap.clear();\n    TREE_NODE_WRAPPER.setValue(null);\n    if (myProgress != null) {\n      myProgress.cancel();\n    }\n  }","commit_id":"b7f07db63477802a18690ff04eb9e6449a2dc63a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  protected abstract ProgressIndicator createProgressIndicator();","id":90748,"modified_method":"@Nullable\n  protected ProgressIndicator createProgressIndicator() {\n    return null;\n  }","commit_id":"b7f07db63477802a18690ff04eb9e6449a2dc63a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    final Component component = getRenderer(row, column).getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n    if (row % 2 == 0 && !isSelected) {\n      component.setBackground(darken(table.getBackground()));\n    } else {\n      component.setBackground(isSelected ? table.getSelectionBackground() : table.getBackground());\n    }\n    return component;\n  }","id":90749,"modified_method":"public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {\n    final JComponent component = (JComponent)getRenderer(row, column).getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n    if (row % 2 == 0 && !isSelected) {\n      component.setBackground(darken(table.getBackground()));\n    } else {\n      component.setBackground(isSelected ? table.getSelectionBackground() : table.getBackground());\n    }\n    component.setOpaque(true);\n    return component;\n  }","commit_id":"b7f07db63477802a18690ff04eb9e6449a2dc63a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TableCellRenderer getCellRenderer(int row, int column) {\n    ColumnInfo columnInfo = getTreeViewModel().getColumnInfos()[convertColumnIndexToModel(column)];\n    TableCellRenderer renderer = columnInfo.getRenderer(getTree().getPathForRow(row).getLastPathComponent());\n    final TableCellRenderer baseRenderer = renderer == null ? super.getCellRenderer(row, column) : renderer;\n    return new TableCellRenderer() {\n      public Component getTableCellRendererComponent(JTable table,\n                                                     Object value,\n                                                     boolean isSelected,\n                                                     boolean hasFocus,\n                                                     int row,\n                                                     int column) {\n        final JComponent rendererComponent = (JComponent)baseRenderer.getTableCellRendererComponent(\n          table, value, isSelected, hasFocus, row, column);\n        if (isSelected) {\n          rendererComponent.setBackground(table.getSelectionBackground());\n          rendererComponent.setForeground(table.getSelectionForeground());\n        }\n        else {\n          rendererComponent.setBackground(table.getBackground());\n          rendererComponent.setForeground(table.getForeground());\n        }\n        rendererComponent.setOpaque(isSelected);\n        return rendererComponent;\n      }\n    };\n  }","id":90750,"modified_method":"public TableCellRenderer getCellRenderer(int row, int column) {\n    ColumnInfo columnInfo = getTreeViewModel().getColumnInfos()[convertColumnIndexToModel(column)];\n    TableCellRenderer renderer = getRenderer(columnInfo, getTree().getPathForRow(row).getLastPathComponent());\n    final TableCellRenderer baseRenderer = renderer == null ? super.getCellRenderer(row, column) : renderer;\n    return new TableCellRenderer() {\n      public Component getTableCellRendererComponent(JTable table,\n                                                     Object value,\n                                                     boolean isSelected,\n                                                     boolean hasFocus,\n                                                     int row,\n                                                     int column) {\n        final JComponent rendererComponent = (JComponent)baseRenderer.getTableCellRendererComponent(\n          table, value, isSelected, hasFocus, row, column);\n        if (isSelected) {\n          rendererComponent.setBackground(table.getSelectionBackground());\n          rendererComponent.setForeground(table.getSelectionForeground());\n        }\n        else {\n          rendererComponent.setBackground(table.getBackground());\n          rendererComponent.setForeground(table.getForeground());\n        }\n        rendererComponent.setOpaque(isSelected);\n        return rendererComponent;\n      }\n    };\n  }","commit_id":"b7f07db63477802a18690ff04eb9e6449a2dc63a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public TableCellEditor getCellEditor(int row, int column) {\n    ColumnInfo columnInfo = getTreeViewModel().getColumnInfos()[column];\n    TableCellEditor editor = columnInfo.getEditor(getTree().getPathForRow(row).getLastPathComponent());\n    if (editor == null) {\n      return super.getCellEditor(row, column);\n    }\n    else {\n      return editor;\n    }\n  }","id":90751,"modified_method":"public TableCellEditor getCellEditor(int row, int column) {\n    ColumnInfo columnInfo = getTreeViewModel().getColumnInfos()[column];\n    TableCellEditor editor = getEditor(columnInfo, getTree().getPathForRow(row).getLastPathComponent());\n    if (editor == null) {\n      return super.getCellEditor(row, column);\n    }\n    else {\n      return editor;\n    }\n  }","commit_id":"b7f07db63477802a18690ff04eb9e6449a2dc63a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public synchronized void stop() {\n    renewalTimer.cancel();\n    delegationTokens.clear();\n\n    dtCancelThread.interrupt();\n    try {\n      dtCancelThread.join(1000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    if (tokenKeepAliveEnabled && delayedRemovalThread != null) {\n      delayedRemovalThread.interrupt();\n      try {\n        delayedRemovalThread.join(1000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Interrupted while joining on delayed removal thread.\", e);\n      }\n    }\n    \n    super.stop();\n  }","id":90752,"modified_method":"@Override\n  public synchronized void stop() {\n    if (renewalTimer != null) {\n      renewalTimer.cancel();\n    }\n    delegationTokens.clear();\n\n    dtCancelThread.interrupt();\n    try {\n      dtCancelThread.join(1000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n    if (tokenKeepAliveEnabled && delayedRemovalThread != null) {\n      delayedRemovalThread.interrupt();\n      try {\n        delayedRemovalThread.join(1000);\n      } catch (InterruptedException e) {\n        LOG.info(\"Interrupted while joining on delayed removal thread.\", e);\n      }\n    }\n    \n    super.stop();\n  }","commit_id":"8c7f5f2c7f4227b38c9acf3e45fb62022a1103ff","url":"https://github.com/apache/hadoop"},{"original_method":"@Override public boolean release() throws ElasticSearchException {\n        try {\n            searcher.close();\n        } catch (IOException e) {\n            // ignore this exception\n        } catch (AlreadyClosedException e) {\n            // ignore this as well\n        }\n        engineSearcher.release();\n        keepAliveTimeout.cancel();\n        return true;\n    }","id":90753,"modified_method":"@Override public boolean release() throws ElasticSearchException {\n        // we should close this searcher, since its a new one we create each time, and we use the IndexReader\n        try {\n            searcher.close();\n        } catch (Exception e) {\n            // ignore any exception here\n        }\n        engineSearcher.release();\n        if (keepAliveTimeout != null) {\n            keepAliveTimeout.cancel();\n        }\n        return true;\n    }","commit_id":"8ec7ee66a9ca266bf0d961c28f67d121e37dc389","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private SearchContext createContext(InternalSearchRequest request) throws ElasticSearchException {\n        IndexService indexService = indicesService.indexServiceSafe(request.index());\n        IndexShard indexShard = indexService.shardSafe(request.shardId());\n        Engine.Searcher engineSearcher = indexShard.searcher();\n\n        SearchShardTarget shardTarget = new SearchShardTarget(clusterService.state().nodes().localNodeId(), request.index(), request.shardId());\n\n        SearchContext context = new SearchContext(idGenerator.incrementAndGet(), shardTarget, request.numberOfShards(), request.timeout(), request.types(), engineSearcher, indexService, scriptService);\n\n        context.scroll(request.scroll());\n\n        parseSource(context, request.source(), request.sourceOffset(), request.sourceLength());\n        parseSource(context, request.extraSource(), request.extraSourceOffset(), request.extraSourceLength());\n\n        // if the from and size are still not set, default them\n        if (context.from() == -1) {\n            context.from(0);\n        }\n        if (context.size() == -1) {\n            context.size(10);\n        }\n\n        // pre process\n        dfsPhase.preProcess(context);\n        queryPhase.preProcess(context);\n        fetchPhase.preProcess(context);\n\n        // compute the context keep alive\n        TimeValue keepAlive = defaultKeepAlive;\n        if (request.scroll() != null && request.scroll().keepAlive() != null) {\n            keepAlive = request.scroll().keepAlive();\n        }\n        context.keepAlive(keepAlive);\n        context.accessed(timerService.estimatedTimeInMillis());\n        context.keepAliveTimeout(timerService.newTimeout(new KeepAliveTimerTask(context), keepAlive, TimerService.ExecutionType.DEFAULT));\n\n        return context;\n    }","id":90754,"modified_method":"private SearchContext createContext(InternalSearchRequest request) throws ElasticSearchException {\n        IndexService indexService = indicesService.indexServiceSafe(request.index());\n        IndexShard indexShard = indexService.shardSafe(request.shardId());\n\n        SearchShardTarget shardTarget = new SearchShardTarget(clusterService.state().nodes().localNodeId(), request.index(), request.shardId());\n\n        Engine.Searcher engineSearcher = indexShard.searcher();\n        SearchContext context = new SearchContext(idGenerator.incrementAndGet(), shardTarget, request.numberOfShards(), request.timeout(), request.types(), engineSearcher, indexService, scriptService);\n\n        try {\n            context.scroll(request.scroll());\n\n            parseSource(context, request.source(), request.sourceOffset(), request.sourceLength());\n            parseSource(context, request.extraSource(), request.extraSourceOffset(), request.extraSourceLength());\n\n            // if the from and size are still not set, default them\n            if (context.from() == -1) {\n                context.from(0);\n            }\n            if (context.size() == -1) {\n                context.size(10);\n            }\n\n            // pre process\n            dfsPhase.preProcess(context);\n            queryPhase.preProcess(context);\n            fetchPhase.preProcess(context);\n\n            // compute the context keep alive\n            TimeValue keepAlive = defaultKeepAlive;\n            if (request.scroll() != null && request.scroll().keepAlive() != null) {\n                keepAlive = request.scroll().keepAlive();\n            }\n            context.keepAlive(keepAlive);\n            context.accessed(timerService.estimatedTimeInMillis());\n            context.keepAliveTimeout(timerService.newTimeout(new KeepAliveTimerTask(context), keepAlive, TimerService.ExecutionType.DEFAULT));\n        } catch (RuntimeException e) {\n            context.release();\n            throw e;\n        }\n\n        return context;\n    }","commit_id":"8ec7ee66a9ca266bf0d961c28f67d121e37dc389","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\r\n    protected void onStop() {\r\n    \tmNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\r\n\t\tmNotificationManager.notify(APP_NOTIFICATION_ID, getNotification());\r\n\t\tif(progressDlg != null){\r\n\t\t\tprogressDlg.dismiss();\r\n\t\t\tprogressDlg = null;\r\n\t\t}\r\n    \tsuper.onStop();\r\n    }","id":90755,"modified_method":"@Override\r\n    protected void onStop() {\r\n    \t// TODO keep this check?\r\n    \tif(routingHelper.isFollowingMode()){\r\n    \t\tmNotificationManager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\r\n    \t\tmNotificationManager.notify(APP_NOTIFICATION_ID, getNotification());\r\n    \t}\r\n\t\tif(progressDlg != null){\r\n\t\t\tprogressDlg.dismiss();\r\n\t\t\tprogressDlg = null;\r\n\t\t}\r\n    \tsuper.onStop();\r\n    }","commit_id":"aa078129de35bac64bade2ca2bc0bed3912f317f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n    protected void onDestroy() {\r\n    \tsuper.onDestroy();\r\n    \tsavingTrackHelper.close();\r\n    \tmNotificationManager.cancel(APP_NOTIFICATION_ID);\r\n    \tMapTileDownloader.getInstance().removeDownloaderCallback(mapView);\r\n    }","id":90756,"modified_method":"@Override\r\n    protected void onDestroy() {\r\n    \tsuper.onDestroy();\r\n    \tsavingTrackHelper.close();\r\n    \tif(mNotificationManager != null){\r\n    \t\tmNotificationManager.cancel(APP_NOTIFICATION_ID);\r\n    \t}\r\n    \tMapTileDownloader.getInstance().removeDownloaderCallback(mapView);\r\n    }","commit_id":"aa078129de35bac64bade2ca2bc0bed3912f317f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected void updateUI(){\r\n\t\tfindViewById(R.id.ResetCountry).setEnabled(region != null);\r\n\t\tif(region == null){\r\n\t\t\tcountryButton.setText(R.string.ChooseCountry);\r\n\t\t} else {\r\n\t\t\tcountryButton.setText(region.getName());\r\n\t\t}\r\n\t\tfindViewById(R.id.ResetCity).setEnabled(postcode != null || city != null);\r\n\t\tif(city == null && postcode == null){\r\n\t\t\tcityButton.setText(R.string.choose_city);\r\n\t\t} else {\r\n\t\t\tif(postcode != null){\r\n\t\t\t\tcityButton.setText(postcode.getName());\r\n\t\t\t} else {\r\n\t\t\t\tcityButton.setText(city.getName(region.useEnglishNames()));\r\n\t\t\t}\r\n\t\t}\r\n\t\tcityButton.setEnabled(region != null);\r\n\t\t\r\n\t\tfindViewById(R.id.ResetStreet).setEnabled(street != null);\r\n\t\tif(street == null){\r\n\t\t\tstreetButton.setText(R.string.choose_street);\r\n\t\t} else {\r\n\t\t\tstreetButton.setText(street.getName(region.useEnglishNames()));\r\n\t\t}\r\n\t\tstreetButton.setEnabled(city != null || postcode != null);\r\n\t\t\r\n\t\tif(radioBuilding){\r\n\t\t\t((RadioButton)findViewById(R.id.RadioBuilding)).setChecked(true);\r\n\t\t} else {\r\n\t\t\t((RadioButton)findViewById(R.id.RadioIntersStreet)).setChecked(true);\r\n\t\t}\r\n\t\tupdateBuildingSection();\r\n\t\t\r\n\t\tbuildingButton.setEnabled(street != null);\r\n\t\t\r\n\t\tshowOnMap.setEnabled(city != null || street != null);\r\n\t\tnavigateTo.setEnabled(city != null || street != null);\r\n\t}","id":90757,"modified_method":"protected void updateUI(){\r\n\t\tfindViewById(R.id.ResetCountry).setEnabled(region != null);\r\n\t\tif(region == null){\r\n\t\t\tcountryButton.setText(R.string.ChooseCountry);\r\n\t\t} else {\r\n\t\t\tcountryButton.setText(region.getName());\r\n\t\t}\r\n\t\tfindViewById(R.id.ResetCity).setEnabled(postcode != null || city != null);\r\n\t\tif(city == null && postcode == null){\r\n\t\t\tcityButton.setText(R.string.choose_city);\r\n\t\t} else {\r\n\t\t\tif(postcode != null){\r\n\t\t\t\tcityButton.setText(postcode.getName());\r\n\t\t\t} else {\r\n\t\t\t\tcityButton.setText(city.getName(region.useEnglishNames()));\r\n\t\t\t}\r\n\t\t}\r\n\t\tcityButton.setEnabled(region != null);\r\n\t\t\r\n\t\tfindViewById(R.id.ResetStreet).setEnabled(street != null);\r\n\t\tif(street == null){\r\n\t\t\tstreetButton.setText(R.string.choose_street);\r\n\t\t} else {\r\n\t\t\tstreetButton.setText(street.getName(region.useEnglishNames()));\r\n\t\t}\r\n\t\tstreetButton.setEnabled(city != null || postcode != null);\r\n\t\t\r\n\t\tbuildingButton.setEnabled(street != null);\r\n\t\t((RadioGroup)findViewById(R.id.RadioGroup)).setVisibility(street == null ? View.GONE : View.VISIBLE);\r\n\t\t\r\n\t\tif(radioBuilding){\r\n\t\t\t((RadioButton)findViewById(R.id.RadioBuilding)).setChecked(true);\r\n\t\t} else {\r\n\t\t\t((RadioButton)findViewById(R.id.RadioIntersStreet)).setChecked(true);\r\n\t\t}\r\n\t\tupdateBuildingSection();\r\n\t\t\r\n\t\tshowOnMap.setEnabled(city != null || street != null);\r\n\t\tnavigateTo.setEnabled(city != null || street != null);\r\n\t}","commit_id":"aa078129de35bac64bade2ca2bc0bed3912f317f","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void shutdown() {\n\t\tsuper.shutdown();\n\t\ttimer.cancel();\n\t\tif (backgroundExecutorService != null) {\n\t\t\tbackgroundExecutorService.shutdownNow();\n\t\t}\n\t}","id":90758,"modified_method":"@Override\n\tpublic void shutdown() {\n\t\tsuper.shutdown();\n        if (timer != null)\n            timer.cancel();\n        \n        if (backgroundExecutorService != null) {\n\t\t\tbackgroundExecutorService.shutdownNow();\n\t\t}\n\t}","commit_id":"23fb9f7c62294af35a363f1519c8a09372a7311b","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"@Override\n  public void start() {\n    metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n\n    Futures.getUnchecked(Services.chainStart(zkClientService,\n                                             kafkaClientService,\n                                             metricsCollectionService));\n\n    injector.getInstance(WeaveRunnerService.class).startAndWait();\n\n    leaderElection = new LeaderElection(zkClientService,\n                                        Constants.Service.APP_FABRIC_LEADER_ELECTION_PREFIX, new ElectionHandler() {\n      @Override\n      public void leader() {\n        appFabricServer = injector.getInstance(AppFabricServer.class);\n        LOG.info(\"Leader: Starting app fabric server.\");\n        Futures.getUnchecked(Services.chainStart(appFabricServer));\n      }\n\n      @Override\n      public void follower() {\n        if (appFabricServer != null) {\n          LOG.info(\"Follower: Stopping app fabric server.\");\n          Futures.getUnchecked(Services.chainStop(appFabricServer));\n        }\n      }\n    });\n    startHealthCheckService();\n  }","id":90759,"modified_method":"@Override\n  public void start() {\n    metricsCollectionService = injector.getInstance(MetricsCollectionService.class);\n\n    startHealthCheckService();\n\n    Futures.getUnchecked(Services.chainStart(zkClientService,\n                                             kafkaClientService,\n                                             metricsCollectionService));\n\n    injector.getInstance(WeaveRunnerService.class).startAndWait();\n\n    leaderElection = new LeaderElection(zkClientService,\n                                        Constants.Service.APP_FABRIC_LEADER_ELECTION_PREFIX, new ElectionHandler() {\n      @Override\n      public void leader() {\n        appFabricServer = injector.getInstance(AppFabricServer.class);\n        LOG.info(\"Leader: Starting app fabric server.\");\n        Futures.getUnchecked(Services.chainStart(appFabricServer));\n      }\n\n      @Override\n      public void follower() {\n        if (appFabricServer != null) {\n          LOG.info(\"Follower: Stopping app fabric server.\");\n          Futures.getUnchecked(Services.chainStop(appFabricServer));\n        }\n      }\n    });\n  }","commit_id":"a3c975948ea5324eb3b5565024c504e1d6f32534","url":"https://github.com/caskdata/cdap"},{"original_method":"private void startHealthCheckService() {\n    CConfiguration conf = injector.getInstance(CConfiguration.class);\n    int port = conf.getInt(Constants.AppFabric.SERVER_COMMAND_PORT, 0);\n    cmdService = CommandPortService.builder(\"app-fabric-status\")\n      .setPort(port)\n      .addCommandHandler(RUOKHandler.COMMAND, RUOKHandler.DESCRIPTION, new RUOKHandler())\n      .build();\n    cmdService.start();\n  }","id":90760,"modified_method":"private void startHealthCheckService() {\n    CConfiguration conf = injector.getInstance(CConfiguration.class);\n    int port = conf.getInt(Constants.AppFabric.SERVER_COMMAND_PORT, 0);\n    cmdService = CommandPortService.builder(\"app-fabric-status\")\n      .setPort(port)\n      .addCommandHandler(RUOKHandler.COMMAND, RUOKHandler.DESCRIPTION, new RUOKHandler())\n      .build();\n    cmdService.startAndWait();\n  }","commit_id":"a3c975948ea5324eb3b5565024c504e1d6f32534","url":"https://github.com/caskdata/cdap"},{"original_method":"/**\n   * Invoked by jsvc to stop the program.\n   */\n  @Override\n  public void stop() {\n    LOG.info(\"Stopping App Fabric ...\");\n    cmdService.stop();\n    leaderElection.cancel();\n\n    if (appFabricServer != null) {\n      Futures.getUnchecked(Services.chainStop(appFabricServer));\n    }\n\n    Futures.getUnchecked(Services.chainStop(metricsCollectionService,\n                                            kafkaClientService, zkClientService));\n  }","id":90761,"modified_method":"/**\n   * Invoked by jsvc to stop the program.\n   */\n  @Override\n  public void stop() {\n    LOG.info(\"Stopping App Fabric ...\");\n    if (cmdService != null) {\n      cmdService.stop();\n    }\n\n    if (leaderElection != null){\n      leaderElection.cancel();\n    }\n\n    if (appFabricServer != null) {\n      Futures.getUnchecked(Services.chainStop(appFabricServer));\n    }\n\n    Futures.getUnchecked(Services.chainStop(metricsCollectionService,\n                                            kafkaClientService, zkClientService));\n  }","commit_id":"a3c975948ea5324eb3b5565024c504e1d6f32534","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void stop() throws IOException {\n    super.stop();\n    mTTLCheckerService.cancel(true);\n  }","id":90762,"modified_method":"@Override\n  public void stop() throws IOException {\n    super.stop();\n    if (mTTLCheckerService != null) {\n      mTTLCheckerService.cancel(true);\n    }\n  }","commit_id":"4d0a6b2983e549209633fcb7c04447d5b2ec8367","url":"https://github.com/amplab/tachyon"},{"original_method":"/**\n     * builds the GUI\n     */\n    protected void build() {\n        setLayout(new GridBagLayout());\n        GridBagConstraints gc = new GridBagConstraints();\n        setBorder(BorderFactory.createEmptyBorder(3,3,3,3));\n\n        bgUseNewOrExisting = new ButtonGroup();\n\n        gc.gridwidth = 4;\n        gc.gridx = 0;\n        gc.gridy = 0;\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        gc.weightx = 1.0;\n        gc.weighty = 0.0;\n        gc.insets = new Insets(0, 0, 5, 0);\n        add(new JMultilineLabel(\"Please decide what changeset data is uploaded to an whether to close the changeset after the next upload.\"), gc);\n\n        gc.gridwidth = 4;\n        gc.gridy = 1;\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        gc.weightx = 1.0;\n        gc.weighty = 0.0;\n        gc.insets = new Insets(0,0,0,0);\n        gc.anchor = GridBagConstraints.FIRST_LINE_START;\n        rbUseNew = new JRadioButton(tr(\"Upload to a new changeset\"));\n        rbUseNew.setToolTipText(tr(\"Open a new changeset and use it in the next upload\"));\n        bgUseNewOrExisting.add(rbUseNew);\n        add(rbUseNew, gc);\n\n        gc.gridx = 0;\n        gc.gridy = 2;\n        gc.gridwidth = 1;\n        gc.weightx = 0.0;\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        rbExisting = new JRadioButton(tr(\"Upload to an existing changeset\"));\n        rbExisting.setToolTipText(tr(\"Upload data to an already existing and open changeset\"));\n        bgUseNewOrExisting.add(rbExisting);\n        add(rbExisting, gc);\n\n        gc.gridx = 1;\n        gc.gridy = 2;\n        gc.gridwidth = 1;\n        gc.weightx = 1.0;\n        model = new OpenChangesetComboBoxModel();\n        ChangesetCache.getInstance().addChangesetCacheListener(model);\n        cbOpenChangesets = new JComboBox(model);\n        cbOpenChangesets.setToolTipText(\"Select an open changeset\");\n        cbOpenChangesets.setRenderer(new ChangesetCellRenderer());\n        cbOpenChangesets.addItemListener(new ChangesetListItemStateListener());\n        Dimension d = cbOpenChangesets.getPreferredSize();\n        d.width = 200;\n        cbOpenChangesets.setPreferredSize(d);\n        d.width = 100;\n        cbOpenChangesets.setMinimumSize(d);\n        model.addListDataListener(this);\n        add(cbOpenChangesets, gc);\n\n        gc.gridx = 2;\n        gc.gridy = 2;\n        gc.weightx = 0.0;\n        gc.gridwidth = 1;\n        gc.weightx = 0.0;\n        btnRefresh = new JButton(new RefreshAction());\n        btnRefresh.setMargin(new Insets(0,0,0,0));\n        add(btnRefresh, gc);\n\n        gc.gridx = 3;\n        gc.gridy = 2;\n        gc.gridwidth = 1;\n        CloseChangesetAction closeChangesetAction = new CloseChangesetAction();\n        btnClose = new JButton(closeChangesetAction);\n        btnClose.setMargin(new Insets(0,0,0,0));\n        cbOpenChangesets.addItemListener(closeChangesetAction);\n        add(btnClose, gc);\n\n        gc.gridx = 0;\n        gc.gridy = 3;\n        gc.gridwidth = 4;\n        gc.weightx = 1.0;\n        cbCloseAfterUpload = new JCheckBox(tr(\"Close changeset after upload\"));\n        cbCloseAfterUpload.setToolTipText(tr(\"Select to close the changeset after the next upload\"));\n        add(cbCloseAfterUpload, gc);\n        cbCloseAfterUpload.setSelected(Main.pref.getBoolean(\"upload.changeset.close\", true));\n        cbCloseAfterUpload.addItemListener(new CloseAfterUploadItemStateListener());\n\n        gc.gridx = 0;\n        gc.gridy = 5;\n        gc.gridwidth = 4;\n        gc.weightx = 1.0;\n        gc.weighty = 1.0;\n        gc.fill = GridBagConstraints.BOTH;\n        add(new JPanel(), gc);\n\n        rbUseNew.getModel().addItemListener(new RadioButtonHandler());\n        rbExisting.getModel().addItemListener(new RadioButtonHandler());\n    }","id":90763,"modified_method":"/**\n     * builds the GUI\n     */\n    protected void build() {\n        setLayout(new GridBagLayout());\n        GridBagConstraints gc = new GridBagConstraints();\n        setBorder(BorderFactory.createEmptyBorder(3,3,3,3));\n\n        bgUseNewOrExisting = new ButtonGroup();\n\n        gc.gridwidth = 4;\n        gc.gridx = 0;\n        gc.gridy = 0;\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        gc.weightx = 1.0;\n        gc.weighty = 0.0;\n        gc.insets = new Insets(0, 0, 5, 0);\n        add(new JMultilineLabel(tr(\"Please decide what changeset data is uploaded to an whether to close the changeset after the next upload.\")), gc);\n\n        gc.gridwidth = 4;\n        gc.gridy = 1;\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        gc.weightx = 1.0;\n        gc.weighty = 0.0;\n        gc.insets = new Insets(0,0,0,0);\n        gc.anchor = GridBagConstraints.FIRST_LINE_START;\n        rbUseNew = new JRadioButton(tr(\"Upload to a new changeset\"));\n        rbUseNew.setToolTipText(tr(\"Open a new changeset and use it in the next upload\"));\n        bgUseNewOrExisting.add(rbUseNew);\n        add(rbUseNew, gc);\n\n        gc.gridx = 0;\n        gc.gridy = 2;\n        gc.gridwidth = 1;\n        gc.weightx = 0.0;\n        gc.fill = GridBagConstraints.HORIZONTAL;\n        rbExisting = new JRadioButton(tr(\"Upload to an existing changeset\"));\n        rbExisting.setToolTipText(tr(\"Upload data to an already existing and open changeset\"));\n        bgUseNewOrExisting.add(rbExisting);\n        add(rbExisting, gc);\n\n        gc.gridx = 1;\n        gc.gridy = 2;\n        gc.gridwidth = 1;\n        gc.weightx = 1.0;\n        model = new OpenChangesetComboBoxModel();\n        ChangesetCache.getInstance().addChangesetCacheListener(model);\n        cbOpenChangesets = new JComboBox(model);\n        cbOpenChangesets.setToolTipText(\"Select an open changeset\");\n        cbOpenChangesets.setRenderer(new ChangesetCellRenderer());\n        cbOpenChangesets.addItemListener(new ChangesetListItemStateListener());\n        Dimension d = cbOpenChangesets.getPreferredSize();\n        d.width = 200;\n        cbOpenChangesets.setPreferredSize(d);\n        d.width = 100;\n        cbOpenChangesets.setMinimumSize(d);\n        model.addListDataListener(this);\n        add(cbOpenChangesets, gc);\n\n        gc.gridx = 2;\n        gc.gridy = 2;\n        gc.weightx = 0.0;\n        gc.gridwidth = 1;\n        gc.weightx = 0.0;\n        btnRefresh = new JButton(new RefreshAction());\n        btnRefresh.setMargin(new Insets(0,0,0,0));\n        add(btnRefresh, gc);\n\n        gc.gridx = 3;\n        gc.gridy = 2;\n        gc.gridwidth = 1;\n        CloseChangesetAction closeChangesetAction = new CloseChangesetAction();\n        btnClose = new JButton(closeChangesetAction);\n        btnClose.setMargin(new Insets(0,0,0,0));\n        cbOpenChangesets.addItemListener(closeChangesetAction);\n        rbExisting.addItemListener(closeChangesetAction);\n        add(btnClose, gc);\n\n        gc.gridx = 0;\n        gc.gridy = 3;\n        gc.gridwidth = 4;\n        gc.weightx = 1.0;\n        cbCloseAfterUpload = new JCheckBox(tr(\"Close changeset after upload\"));\n        cbCloseAfterUpload.setToolTipText(tr(\"Select to close the changeset after the next upload\"));\n        add(cbCloseAfterUpload, gc);\n        cbCloseAfterUpload.setSelected(Main.pref.getBoolean(\"upload.changeset.close\", true));\n        cbCloseAfterUpload.addItemListener(new CloseAfterUploadItemStateListener());\n\n        gc.gridx = 0;\n        gc.gridy = 5;\n        gc.gridwidth = 4;\n        gc.weightx = 1.0;\n        gc.weighty = 1.0;\n        gc.fill = GridBagConstraints.BOTH;\n        add(new JPanel(), gc);\n\n        rbUseNew.getModel().addItemListener(new RadioButtonHandler());\n        rbExisting.getModel().addItemListener(new RadioButtonHandler());\n    }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void refreshEnabledState() {\n            setEnabled(cbOpenChangesets.getModel().getSize() > 0 && cbOpenChangesets.getSelectedItem() != null);\n        }","id":90764,"modified_method":"protected void refreshEnabledState() {\n            setEnabled(\n                    cbOpenChangesets.getModel().getSize() > 0\n                    && cbOpenChangesets.getSelectedItem() != null\n                    && rbExisting.isSelected()\n            );\n        }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void actionPerformed(ActionEvent e) {\n            DownloadOpenChangesetsTask task = new DownloadOpenChangesetsTask(model);\n            Main.worker.submit(task);\n        }","id":90765,"modified_method":"public void actionPerformed(ActionEvent e) {\n            DownloadOpenChangesetsTask task = new DownloadOpenChangesetsTask(ChangesetManagementPanel.this);\n            Main.worker.submit(task);\n        }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    protected void cancel() {\n        this.cancelled = true;\n        reader.cancel();\n    }","id":90766,"modified_method":"@Override\n    protected void cancel() {\n        this.cancelled = true;\n        synchronized(this) {\n            if (reader != null) {\n                reader.cancel();\n            }\n        }\n    }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    protected void realRun() throws SAXException, IOException, OsmTransferException {\n        try {\n            if (model.getUserId()== 0) {\n                userInfo = fetchUserInfo();\n                model.setUserId(userInfo.getId());\n            }\n            if (cancelled)\n                return;\n            reader = new OsmServerChangesetReader();\n            ChangesetQuery query = new ChangesetQuery().forUser((int)model.getUserId()).beingOpen(true);\n            changesets = reader.queryChangesets(\n                    query,\n                    getProgressMonitor().createSubTaskMonitor(1, false /* not internal */)\n            );\n        } catch(Exception e) {\n            if (cancelled)\n                return;\n            lastException = e;\n        }\n    }","id":90767,"modified_method":"@Override\n    protected void realRun() throws SAXException, IOException, OsmTransferException {\n        try {\n            JosmUserIdentityManager im = JosmUserIdentityManager.getInstance();\n            if (im.isAnonymous()) {\n                refreshUserIdentity();\n            } else if (im.isFullyIdentified()){\n                // do nothing\n            } else if (im.isPartiallyIdentified()) {\n                refreshUserIdentity();\n            }\n            if (cancelled)return;\n            synchronized(this) {\n                reader = new OsmServerChangesetReader();\n            }\n            ChangesetQuery query = new ChangesetQuery().beingOpen(true);\n            if (im.isAnonymous())\n                // we still don't know anything about the current user. Can't retrieve\n                // its changesets\n                return;\n            else if (im.isFullyIdentified()) {\n                query = query.forUser(im.getUserId());\n            } else {\n                // we only know the users name, not its id. Nevermind, try to read\n                // its open changesets anyway.\n                //\n                query = query.forUser(im.getUserName());\n            }\n            changesets = reader.queryChangesets(\n                    query,\n                    getProgressMonitor().createSubTaskMonitor(1, false /* not internal */)\n            );\n        } catch(Exception e) {\n            if (cancelled)\n                return;\n            lastException = e;\n        }\n    }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    protected void finish() {\n        if (cancelled)\n            return;\n        if (lastException != null) {\n            ExceptionDialogUtil.explainException(lastException);\n            return;\n        }\n        if (changesets.isEmpty()) {\n            JOptionPane.showMessageDialog(\n                    Main.parent,\n                    tr(\"There are no open changesets\"),\n                    tr(\"No open changesets\"),\n                    JOptionPane.INFORMATION_MESSAGE\n            );\n        }\n        SwingUtilities.invokeLater(\n                new Runnable() {\n                    public void run() {\n                        ChangesetCache.getInstance().update(changesets);\n                    }\n                }\n        );\n    }","id":90768,"modified_method":"@Override\n    protected void finish() {\n        if (JosmUserIdentityManager.getInstance().isAnonymous()) {\n            JOptionPane.showMessageDialog(\n                    JOptionPane.getFrameForComponent(parent),\n                    tr(\"<html>Could not retrieve the list of your open changesets because<br>\"\n                            + \"JOSM doesn't know your identity.<br>\"\n                            + \"You've either chosen to work anonymously or you are not entitled<br>\"\n                            + \"to know the identity of the user on whose behalf you are working.\"\n                            + \"<\/html>\"\n                    ),\n                    tr(\"Missing user identity\"),\n                    JOptionPane.ERROR_MESSAGE\n            );\n            return;\n        }\n        if (cancelled)return;\n        if (lastException != null) {\n            ExceptionDialogUtil.explainException(lastException);\n            return;\n        }\n        if (changesets.isEmpty()) {\n            JOptionPane.showMessageDialog(\n                    Main.parent,\n                    tr(\"There are no open changesets\"),\n                    tr(\"No open changesets\"),\n                    JOptionPane.INFORMATION_MESSAGE\n            );\n            return;\n        }\n        SwingUtilities.invokeLater(\n                new Runnable() {\n                    public void run() {\n                        ChangesetCache.getInstance().update(changesets);\n                    }\n                }\n        );\n    }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     *\n     * @param model provides the user id of the current user and accepts the changesets\n     * after download\n     */\n    public DownloadOpenChangesetsTask(OpenChangesetComboBoxModel model) {\n        super(tr(\"Downloading open changesets ...\", false /* don't ignore exceptions */));\n        this.model = model;\n    }","id":90769,"modified_method":"/**\n     *\n     * @param model provides the user id of the current user and accepts the changesets\n     * after download\n     */\n    public DownloadOpenChangesetsTask(Component parent) {\n        super(parent, tr(\"Downloading open changesets ...\"), false /* don't ignore exceptions */);\n        this.parent = parent;\n    }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void selectFirstChangeset() {\n        if (changesets == null || changesets.isEmpty()) {\n            setSelectedItem(null);\n        } else {\n            setSelectedItem(changesets.get(0));\n        }\n    }","id":90770,"modified_method":"/**\n     * Selects the first changeset in the current list of open changesets\n     */\n    public void selectFirstChangeset() {\n        if (changesets == null || changesets.isEmpty()) {\n            setSelectedItem(null);\n        } else {\n            setSelectedItem(changesets.get(0));\n        }\n    }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void refresh() {\n        changesets.clear();\n        changesets.addAll(ChangesetCache.getInstance().getOpenChangesets());\n        fireContentsChanged(this, 0, getSize());\n        int idx = changesets.indexOf(selectedChangeset);\n        if (idx < 0) {\n            setSelectedItem(null);\n        } else {\n            setSelectedItem(changesets.get(idx));\n        }\n    }","id":90771,"modified_method":"/**\n     * Refreshes the content of the combobox model with the current list of open\n     * changesets from the {@see ChangesetCache}.\n     */\n    public void refresh() {\n        changesets.clear();\n        changesets.addAll(ChangesetCache.getInstance().getOpenChangesets());\n        fireContentsChanged(this, 0, getSize());\n        int idx = changesets.indexOf(selectedChangeset);\n        if (idx < 0) {\n            selectFirstChangeset();\n        } else {\n            setSelectedItem(changesets.get(idx));\n        }\n    }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"public UserInfo fetchUserInfo(ProgressMonitor monitor) throws OsmTransferException {\n        try {\n            monitor.beginTask(tr(\"Reading user info ...\"));\n            InputStream in = getInputStream(\"user/details\", monitor.createSubTaskMonitor(1, true));\n            return buildFromXML(\n                    DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(in)\n            );\n        } catch(OsmTransferException e) {\n            throw e;\n        } catch(Exception e) {\n            throw new OsmTransferException(e);\n        } finally {\n            monitor.finishTask();\n        }\n    }","id":90772,"modified_method":"public UserInfo fetchUserInfo(ProgressMonitor monitor) throws OsmTransferException {\n        try {\n            monitor.beginTask(tr(\"\"));\n            monitor.indeterminateSubTask(tr(\"Reading user info ...\"));\n            InputStream in = getInputStream(\"user/details\", monitor.createSubTaskMonitor(1, true));\n            return buildFromXML(\n                    DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(in)\n            );\n        } catch(OsmTransferException e) {\n            throw e;\n        } catch(Exception e) {\n            throw new OsmTransferException(e);\n        } finally {\n            monitor.finishTask();\n        }\n    }","commit_id":"f01ceb44f6e5caf8494a77bcafc3142b109ea63e","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void contextInitialized(ServletContextEvent event) {\n        try {\n            cloudStackContext = new CloudStackSpringContext();\n            event.getServletContext().setAttribute(CloudStackSpringContext.CLOUDSTACK_CONTEXT_SERVLET_KEY, cloudStackContext);\n        } catch (IOException e) {\n            log.error(\"Failed to start CloudStack\", e);\n            throw new RuntimeException(\"Failed to initialize CloudStack Spring modules\", e);\n        }\n\n        configuredParentName = event.getServletContext().getInitParameter(WEB_PARENT_MODULE);\n        if (configuredParentName == null) {\n            configuredParentName = WEB_PARENT_MODULE_DEFAULT;\n        }\n\n        super.contextInitialized(event);\n    }","id":90773,"modified_method":"@Override\n    public void contextInitialized(ServletContextEvent event) {\n        try {\n            cloudStackContext = new CloudStackSpringContext();\n            cloudStackContext.registerShutdownHook();\n            event.getServletContext().setAttribute(CloudStackSpringContext.CLOUDSTACK_CONTEXT_SERVLET_KEY, cloudStackContext);\n        } catch (IOException e) {\n            log.error(\"Failed to start CloudStack\", e);\n            throw new RuntimeException(\"Failed to initialize CloudStack Spring modules\", e);\n        }\n\n        configuredParentName = event.getServletContext().getInitParameter(WEB_PARENT_MODULE);\n        if (configuredParentName == null) {\n            configuredParentName = WEB_PARENT_MODULE_DEFAULT;\n        }\n\n        super.contextInitialized(event);\n    }","commit_id":"4849368c94f4c5d7e48beb92dba653bc97aa5ba5","url":"https://github.com/apache/cloudstack"},{"original_method":"public void stopBeans() {\n        with(new WithComponentLifeCycle() {\n            @Override\n            public void with(ComponentLifecycle lifecycle) {\n                lifecycle.stop();\n            }\n        });\n    }","id":90774,"modified_method":"public void stopBeans() {\n        with(new WithComponentLifeCycle() {\n            @Override\n            public void with(ComponentLifecycle lifecycle) {\n                log.info(\"stopping bean \" + lifecycle.getName());\n                lifecycle.stop();\n            }\n        });\n    }","commit_id":"4849368c94f4c5d7e48beb92dba653bc97aa5ba5","url":"https://github.com/apache/cloudstack"},{"original_method":"public void registerShutdownHook() {\n        ApplicationContext base = moduleDefinitionSet.getApplicationContext(baseName);\n\n        if (base instanceof ConfigurableApplicationContext) {\n            ((ConfigurableApplicationContext)base).registerShutdownHook();\n        }\n    }","id":90775,"modified_method":"public void registerShutdownHook() {\n        Map<String, ApplicationContext> contextMap= moduleDefinitionSet.getContextMap();\n\n        for (String appName : contextMap.keySet()) {\n            ApplicationContext contex = contextMap.get(appName);\n            if (contex instanceof ConfigurableApplicationContext) {\n                log.trace(\"registering shutdown hook for bean \"+ appName);\n                ((ConfigurableApplicationContext)contex).registerShutdownHook();\n            }\n        }\n    }","commit_id":"4849368c94f4c5d7e48beb92dba653bc97aa5ba5","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public boolean stop() {\n        _dbSyncTimer.cancel();\n        return true;\n    }","id":90776,"modified_method":"@Override\n    public boolean stop() {\n        if (_dbSyncTimer != null) {\n            _dbSyncTimer.cancel();\n        }\n        return true;\n    }","commit_id":"4849368c94f4c5d7e48beb92dba653bc97aa5ba5","url":"https://github.com/apache/cloudstack"},{"original_method":"public void fail(FetchException e) {\n        synchronized(this) {\n            if(succeeded || failed) return;\n            failed = true;\n        }\n        context.getChkFetchScheduler(realTimeFlag).removePendingKeys(storage.keyListener, true);\n        getter.cancel(context);\n        storage.cancel();\n        cb.onFailure(e, this, null, context);\n    }","id":90777,"modified_method":"public void fail(FetchException e) {\n        synchronized(this) {\n            if(succeeded || failed) return;\n            failed = true;\n        }\n        context.getChkFetchScheduler(realTimeFlag).removePendingKeys(storage.keyListener, true);\n        getter.cancel(context);\n        if(storage != null)\n            storage.cancel();\n        cb.onFailure(e, this, null, context);\n    }","commit_id":"fadf6635ac42784ad46fad327d3863f1ceca9ab4","url":"https://github.com/freenet/fred"},{"original_method":"SplitFileFetcherNew(Metadata metadata, GetCompletionCallback rcb, ClientRequester parent,\n            FetchContext fetchContext, boolean realTimeFlag, List<COMPRESSOR_TYPE> decompressors, \n            ClientMetadata clientMetadata, long token, boolean topDontCompress, \n            short topCompatibilityMode, boolean persistent, FreenetURI thisKey, boolean isFinalFetch,\n            ObjectContainer container, ClientContext context) \n            throws FetchException, MetadataParseException {\n        if(persistent) throw new UnsupportedOperationException();\n        this.persistent = false;\n        this.cb = rcb;\n        this.parent = parent;\n        this.realTimeFlag = realTimeFlag;\n        this.token = token;\n        this.context = context;\n        if(parent instanceof ClientGetter) {\n            wantBinaryBlob = ((ClientGetter)parent).collectingBinaryBlob();\n        } else {\n            wantBinaryBlob = false;\n        }\n        blockFetchContext = new FetchContext(fetchContext, FetchContext.SPLITFILE_DEFAULT_BLOCK_MASK, true, null);\n        if(parent.isCancelled())\n            throw new FetchException(FetchException.CANCELLED);\n        \n        KeySalter salter = context.getChkFetchScheduler(realTimeFlag).schedTransient;\n\n        try {\n            storage = new SplitFileFetcherStorage(metadata, this, decompressors, clientMetadata, \n                    topDontCompress, topCompatibilityMode, fetchContext, realTimeFlag, salter,\n                    thisKey, parent.getURI(), isFinalFetch, parent.getClientDetail(container), \n                    context.random, context.tempBucketFactory, context.tempRAFFactory, \n                    context.mainExecutor, context.ticker, context.memoryLimitedJobRunner, new CRCChecksumChecker(), persistent);\n        } catch (InsufficientDiskSpaceException e) {\n            throw new FetchException(FetchException.NOT_ENOUGH_DISK_SPACE);\n        } catch (IOException e) {\n            Logger.error(this, \"Failed to start splitfile fetcher because of disk I/O error?: \"+e, e);\n            throw new FetchException(FetchException.BUCKET_ERROR, e);\n        }\n        long eventualLength = Math.max(storage.finalLength, metadata.uncompressedDataLength());\n        boolean wasActive = true;\n        if(persistent) {\n            wasActive = container.ext().isActive(cb);\n            if(!wasActive)\n                container.activate(cb, 1);\n        }\n        cb.onExpectedSize(eventualLength, container, context);\n        if(metadata.uncompressedDataLength() > 0)\n            cb.onFinalizedMetadata(container);\n        if(!wasActive)\n            container.deactivate(cb, 1);\n        if(eventualLength > 0 && fetchContext.maxOutputLength > 0 && eventualLength > fetchContext.maxOutputLength)\n            throw new FetchException(FetchException.TOO_BIG, eventualLength, true, clientMetadata.getMIMEType());\n        getter = new SplitFileFetcherGet(this, storage);\n    }","id":90778,"modified_method":"SplitFileFetcherNew(Metadata metadata, GetCompletionCallback rcb, ClientRequester parent,\n            FetchContext fetchContext, boolean realTimeFlag, List<COMPRESSOR_TYPE> decompressors, \n            ClientMetadata clientMetadata, long token, boolean topDontCompress, \n            short topCompatibilityMode, boolean persistent, FreenetURI thisKey, boolean isFinalFetch,\n            ObjectContainer container, ClientContext context) \n            throws FetchException, MetadataParseException {\n        if(persistent) throw new UnsupportedOperationException();\n        this.persistent = false;\n        this.cb = rcb;\n        this.parent = parent;\n        this.realTimeFlag = realTimeFlag;\n        this.token = token;\n        this.context = context;\n        if(parent instanceof ClientGetter) {\n            wantBinaryBlob = ((ClientGetter)parent).collectingBinaryBlob();\n        } else {\n            wantBinaryBlob = false;\n        }\n        blockFetchContext = new FetchContext(fetchContext, FetchContext.SPLITFILE_DEFAULT_BLOCK_MASK, true, null);\n        if(parent.isCancelled())\n            throw new FetchException(FetchException.CANCELLED);\n        \n        KeySalter salter = context.getChkFetchScheduler(realTimeFlag).schedTransient;\n\n        try {\n            storage = new SplitFileFetcherStorage(metadata, this, decompressors, clientMetadata, \n                    topDontCompress, topCompatibilityMode, fetchContext, realTimeFlag, salter,\n                    thisKey, parent.getURI(), isFinalFetch, parent.getClientDetail(container), \n                    context.random, context.tempBucketFactory, context.tempRAFFactory, \n                    context.mainExecutor, context.ticker, context.memoryLimitedJobRunner, new CRCChecksumChecker(), persistent);\n        } catch (InsufficientDiskSpaceException e) {\n            throw new FetchException(FetchException.NOT_ENOUGH_DISK_SPACE);\n        } catch (IOException e) {\n            Logger.error(this, \"Failed to start splitfile fetcher because of disk I/O error?: \"+e, e);\n            throw new FetchException(FetchException.BUCKET_ERROR, e);\n        }\n        long eventualLength = Math.max(storage.finalLength, metadata.uncompressedDataLength());\n        boolean wasActive = true;\n        if(persistent) {\n            wasActive = container.ext().isActive(cb);\n            if(!wasActive)\n                container.activate(cb, 1);\n        }\n        cb.onExpectedSize(eventualLength, container, context);\n        if(metadata.uncompressedDataLength() > 0)\n            cb.onFinalizedMetadata(container);\n        if(!wasActive)\n            container.deactivate(cb, 1);\n        if(eventualLength > 0 && fetchContext.maxOutputLength > 0 && eventualLength > fetchContext.maxOutputLength)\n            throw new FetchException(FetchException.TOO_BIG, eventualLength, true, clientMetadata.getMIMEType());\n        getter = new SplitFileFetcherGet(this, storage);\n        raf = storage.getRAF();\n    }","commit_id":"fadf6635ac42784ad46fad327d3863f1ceca9ab4","url":"https://github.com/freenet/fred"},{"original_method":"@Test\n  public void testTable() throws Exception {\n    KeyValueTableDefinition.KeyValueTable table = datasetManager.getDataset(\"my_table\", null);\n    Assert.assertNotNull(table);\n    Transaction tx = transactionManager.startShort(100);\n    table.startTx(tx);\n    Assert.assertEquals(\"first\", table.get(\"1\"));\n  }","id":90779,"modified_method":"@Test\n  public void testTable() throws Exception {\n    KeyValueTableDefinition.KeyValueTable table = datasetManager.getDataset(\"my_table\", null);\n    Assert.assertNotNull(table);\n    Transaction tx = transactionManager.startShort(100);\n    table.startTx(tx);\n    Assert.assertEquals(\"first\", table.get(\"1\"));\n    transactionManager.abort(tx);\n  }","commit_id":"aa7c6c4eaffd3b2875c6e90cdb07f612338fd244","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void shutDown() throws Exception {\n    if (hiveServer2 != null) {\n      hiveServer2.stop();\n      discoveryCancel.cancel();\n    }\n  }","id":90780,"modified_method":"@Override\n  protected void shutDown() throws Exception {\n    if (hiveServer2 != null) {\n      hiveServer2.stop();\n    }\n    if (discoveryCancel != null) {\n      discoveryCancel.cancel();\n    }\n  }","commit_id":"aa7c6c4eaffd3b2875c6e90cdb07f612338fd244","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void run(HookContext hookContext) throws Exception {\n    // We cannot rely on hookContext.getOperationName(), it remains the same\n    // through the life of a beeline command\n    if (TransactionPreHook.SELECT_QUERY.matcher(hookContext.getQueryPlan().getQueryString()).matches()) {\n      LOG.debug(\"Entering post hive hook for hive query\");\n      HiveConf hiveConf = hookContext.getConf();\n      Transaction tx = TxnSerDe.deserialize(hiveConf);\n      LOG.debug(\"Transaction retrieved in post hook: {}\", tx);\n\n      TransactionSystemClient txClient = ContextManager.getTxClient(hiveConf);\n      // Transaction doesn't involve any changes\n      if (txClient.canCommit(tx, ImmutableList.<byte[]>of())) {\n        if (!txClient.commit(tx)) {\n          txClient.abort(tx);\n          LOG.info(\"Could not pass second commit checking for tx used for Hive query: {}\", tx);\n        }\n      } else {\n        // Very unlikely with empty changes\n        txClient.abort(tx);\n        LOG.info(\"Could not pass first commit checking for tx used for Hive query: {}\", tx);\n      }\n    }\n  }","id":90781,"modified_method":"@Override\n  public void run(HookContext hookContext) throws Exception {\n    // We cannot rely on hookContext.getOperationName(), it remains the same\n    // through the life of a beeline command\n    if (TransactionPreHook.SELECT_QUERY.matcher(hookContext.getQueryPlan().getQueryString()).matches()) {\n      LOG.debug(\"Entering post hive hook for hive query\");\n      HiveConf hiveConf = hookContext.getConf();\n      Transaction tx = TxnSerDe.deserialize(hiveConf);\n      LOG.debug(\"Transaction retrieved in post hook: {}\", tx);\n\n      TransactionSystemClient txClient = ContextManager.getTxClient(hiveConf);\n      // Transaction doesn't involve any changes\n      if (txClient.canCommit(tx, ImmutableList.<byte[]>of())) {\n        if (!txClient.commit(tx)) {\n          txClient.abort(tx);\n          LOG.info(\"Could not pass second commit checking for tx used for Hive query: {}\", tx);\n        }\n      } else {\n        // Very unlikely with empty changes\n        txClient.invalidate(tx.getWritePointer());\n        LOG.info(\"Could not pass first commit checking for tx used for Hive query: {}\", tx);\n      }\n    }\n  }","commit_id":"aa7c6c4eaffd3b2875c6e90cdb07f612338fd244","url":"https://github.com/caskdata/cdap"},{"original_method":"protected Predicate<IEObjectDescription> getSearchPredicate(final String searchPattern) {\n\t\treturn new Predicate<IEObjectDescription>() {\n\t\t\tpublic boolean apply(IEObjectDescription input) {\n\t\t\t\treturn getPrefixMatcher().isCandidateMatchingPrefix(input.getName(), searchPattern)\n\t\t\t\t\t\t|| getPrefixMatcher().isCandidateMatchingPrefix(input.getQualifiedName(), searchPattern);\n\t\t\t}\n\t\t};\n\t}","id":90782,"modified_method":"protected Predicate<IEObjectDescription> getSearchPredicate(final String stringPattern) {\n\t\tfinal SearchPattern searchPattern = new SearchPattern();\n\t\tsearchPattern.setPattern(stringPattern);\n\t\treturn new Predicate<IEObjectDescription>() {\n\t\t\tpublic boolean apply(IEObjectDescription input) {\n\t\t\t\treturn searchPattern.matches(input.getName()) \n\t\t\t\t\t\t|| searchPattern.matches(input.getQualifiedName());\n\t\t\t}\n\t\t};\n\t}","commit_id":"e9ca5bb3416930a9dcabb89261ac7d784acee2f3","url":"https://github.com/eclipse/xtext"},{"original_method":"public void dispose() {\n\t\tviewer = null;\n\t\tmatches = null;\n\t\tstatusLabel = null;\n\t\tsizeCalculationJob.cancel();\n\t\tsizeCalculationJob = null;\n\t}","id":90783,"modified_method":"public void dispose() {\n\t\tviewer = null;\n\t\tmatches = null;\n\t\tstatusLabel = null;\n\t\tif (sizeCalculationJob != null) {\n\t\t\tsizeCalculationJob.cancel();\n\t\t\tsizeCalculationJob = null;\n\t\t}\n\t}","commit_id":"e9ca5bb3416930a9dcabb89261ac7d784acee2f3","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public <A> void read(ByteBuffer[] dsts, int offset, int length,\n            long timeout, TimeUnit unit, A attachment,\n            CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        sc.read(netInBuffer, timeout, unit, attachment, new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        //the data read\n                        long read = 0;\n                        //the SSL engine result\n                        SSLEngineResult unwrap;\n                        do {\n                            //prepare the buffer\n                            netInBuffer.flip();\n                            //unwrap the data\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n                            //compact the buffer\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                //we did receive some data, add it to our total\n                                read += unwrap.bytesProduced();\n                                //perform any tasks if needed\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                //if we need more network data, then bail out for now.\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    break;\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                //buffer overflow can happen, if we have read data, then\n                                //empty out the dst buffer before we do another read\n                                break;\n                            } else {\n                                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                                //for now, throw an exception, as we initialized the buffers\n                                //in the constructor\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0)); //continue to unwrapping as long as the input buffer has stuff\n                        // If everything is OK, so complete\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        });\n\n    }","id":90784,"modified_method":"@Override\n    public <A> void read(ByteBuffer[] dsts, int offset, int length,\n            long timeout, TimeUnit unit, A attachment,\n            CompletionHandler<Long, ? super A> handler) {\n        if (offset < 0 || dsts == null || (offset + length) > dsts.length) {\n            throw new IllegalArgumentException();\n        }\n        if (closing || closed) {\n            handler.completed(Long.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        //the data read\n                        long read = 0;\n                        //the SSL engine result\n                        SSLEngineResult unwrap;\n                        do {\n                            //prepare the buffer\n                            netInBuffer.flip();\n                            //unwrap the data\n                            unwrap = sslEngine.unwrap(netInBuffer, dsts, offset, length);\n                            //compact the buffer\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                //we did receive some data, add it to our total\n                                read += unwrap.bytesProduced();\n                                //perform any tasks if needed\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                //if we need more network data, then bail out for now.\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                //buffer overflow can happen, if we have read data, then\n                                //empty out the dst buffer before we do another read\n                                break;\n                            } else {\n                                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                                //for now, throw an exception, as we initialized the buffers\n                                //in the constructor\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0)); //continue to unwrapping as long as the input buffer has stuff\n                        // If everything is OK, so complete\n                        handler.completed(Long.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }","commit_id":"1edc8e0486841211b5d7f98f59f7ba9f7529fdbc","url":"https://github.com/apache/tomcat"},{"original_method":"private FutureRead(ByteBuffer dst) {\n            this.dst = dst;\n            this.integer = sc.read(netInBuffer);\n        }","id":90785,"modified_method":"private FutureRead(ByteBuffer dst) {\n            this.dst = dst;\n            if (netInBuffer.position() > 0) {\n                this.integer = null;\n            } else {\n                this.integer = sc.read(netInBuffer);\n            }\n        }","commit_id":"1edc8e0486841211b5d7f98f59f7ba9f7529fdbc","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    public <A> void read(final ByteBuffer dst,\n            long timeout, TimeUnit unit, final A attachment,\n            CompletionHandler<Integer, ? super A> handler) {\n        // Check state\n        if (closing || closed) {\n            handler.completed(Integer.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        sc.read(netInBuffer, timeout, unit, attachment, new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        //the data read\n                        int read = 0;\n                        //the SSL engine result\n                        SSLEngineResult unwrap;\n                        do {\n                            //prepare the buffer\n                            netInBuffer.flip();\n                            //unwrap the data\n                            unwrap = sslEngine.unwrap(netInBuffer, dst);\n                            //compact the buffer\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                //we did receive some data, add it to our total\n                                read += unwrap.bytesProduced();\n                                //perform any tasks if needed\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                //if we need more network data, then bail out for now.\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    break;\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                //buffer overflow can happen, if we have read data, then\n                                //empty out the dst buffer before we do another read\n                                break;\n                            } else {\n                                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                                //for now, throw an exception, as we initialized the buffers\n                                //in the constructor\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0)); //continue to unwrapping as long as the input buffer has stuff\n                        // If everything is OK, so complete\n                        handler.completed(Integer.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        });\n    }","id":90786,"modified_method":"@Override\n    public <A> void read(final ByteBuffer dst,\n            long timeout, TimeUnit unit, final A attachment,\n            CompletionHandler<Integer, ? super A> handler) {\n        // Check state\n        if (closing || closed) {\n            handler.completed(Integer.valueOf(-1), attachment);\n            return;\n        }\n        if (!handshakeComplete) {\n            throw new IllegalStateException(sm.getString(\"channel.nio.ssl.incompleteHandshake\"));\n        }\n        CompletionHandler<Integer, A> readCompletionHandler = new CompletionHandler<Integer, A>() {\n            @Override\n            public void completed(Integer nBytes, A attach) {\n                if (nBytes.intValue() < 0) {\n                    failed(new EOFException(), attach);\n                } else {\n                    try {\n                        //the data read\n                        int read = 0;\n                        //the SSL engine result\n                        SSLEngineResult unwrap;\n                        do {\n                            //prepare the buffer\n                            netInBuffer.flip();\n                            //unwrap the data\n                            unwrap = sslEngine.unwrap(netInBuffer, dst);\n                            //compact the buffer\n                            netInBuffer.compact();\n                            if (unwrap.getStatus() == Status.OK || unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                //we did receive some data, add it to our total\n                                read += unwrap.bytesProduced();\n                                //perform any tasks if needed\n                                if (unwrap.getHandshakeStatus() == HandshakeStatus.NEED_TASK)\n                                    tasks();\n                                //if we need more network data, then bail out for now.\n                                if (unwrap.getStatus() == Status.BUFFER_UNDERFLOW) {\n                                    if (read == 0) {\n                                        sc.read(netInBuffer, timeout, unit, attachment, this);\n                                        return;\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            } else if (unwrap.getStatus() == Status.BUFFER_OVERFLOW && read > 0) {\n                                //buffer overflow can happen, if we have read data, then\n                                //empty out the dst buffer before we do another read\n                                break;\n                            } else {\n                                //here we should trap BUFFER_OVERFLOW and call expand on the buffer\n                                //for now, throw an exception, as we initialized the buffers\n                                //in the constructor\n                                throw new IOException(sm.getString(\"channel.nio.ssl.unwrapFail\", unwrap.getStatus()));\n                            }\n                        } while ((netInBuffer.position() != 0)); //continue to unwrapping as long as the input buffer has stuff\n                        // If everything is OK, so complete\n                        handler.completed(Integer.valueOf(read), attach);\n                    } catch (Exception e) {\n                        failed(e, attach);\n                    }\n                }\n            }\n            @Override\n            public void failed(Throwable exc, A attach) {\n                handler.failed(exc, attach);\n            }\n        };\n        if (netInBuffer.position() > 0) {\n            readCompletionHandler.completed(Integer.valueOf(netInBuffer.position()), attachment);\n        } else {\n            sc.read(netInBuffer, timeout, unit, attachment, readCompletionHandler);\n        }\n    }","commit_id":"1edc8e0486841211b5d7f98f59f7ba9f7529fdbc","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public boolean cancel(boolean mayInterruptIfRunning) {\n            return integer.cancel(mayInterruptIfRunning);\n        }","id":90787,"modified_method":"@Override\n        public boolean cancel(boolean mayInterruptIfRunning) {\n            return (integer == null) ? false : integer.cancel(mayInterruptIfRunning);\n        }","commit_id":"1edc8e0486841211b5d7f98f59f7ba9f7529fdbc","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public Integer get(long timeout, TimeUnit unit)\n                throws InterruptedException, ExecutionException,\n                TimeoutException {\n            return unwrap(integer.get(timeout, unit).intValue());\n        }","id":90788,"modified_method":"@Override\n        public Integer get(long timeout, TimeUnit unit)\n                throws InterruptedException, ExecutionException,\n                TimeoutException {\n            return (integer == null) ? unwrap(netInBuffer.position(), timeout, unit) : unwrap(integer.get(timeout, unit).intValue(), timeout, unit);\n        }","commit_id":"1edc8e0486841211b5d7f98f59f7ba9f7529fdbc","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public boolean isCancelled() {\n            return integer.isCancelled();\n        }","id":90789,"modified_method":"@Override\n        public boolean isCancelled() {\n            return (integer == null) ? false : integer.isCancelled();\n        }","commit_id":"1edc8e0486841211b5d7f98f59f7ba9f7529fdbc","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public Integer get() throws InterruptedException, ExecutionException {\n            return unwrap(integer.get().intValue());\n        }","id":90790,"modified_method":"@Override\n        public Integer get() throws InterruptedException, ExecutionException {\n            return (integer == null) ? unwrap(netInBuffer.position(), -1, TimeUnit.MILLISECONDS) : unwrap(integer.get().intValue(), -1, TimeUnit.MILLISECONDS);\n        }","commit_id":"1edc8e0486841211b5d7f98f59f7ba9f7529fdbc","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public boolean isDone() {\n            return integer.isDone();\n        }","id":90791,"modified_method":"@Override\n        public boolean isDone() {\n            return (integer == null) ? true : integer.isDone();\n        }","commit_id":"1edc8e0486841211b5d7f98f59f7ba9f7529fdbc","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n    protected void doStop() throws Exception {\n        task.cancel();\n        task = null;\n    }","id":90792,"modified_method":"@Override\n    protected void doStop() throws Exception {\n        if (task != null) {\n            task.cancel();\n        }\n        task = null;\n    }","commit_id":"f555bad9218f361ccdb11880afb5d9bc5dc4d097","url":"https://github.com/apache/camel"},{"original_method":"private void startup() {\r\n\t\t\tif (_ncProto == NetworkProtocol.UDP) {\r\n\t\t\t\t_ncHeartBeatTimer = new Timer(true);\r\n\t\t\t\t_ncHeartBeatTimer.schedule(new HeartBeatTimer(), PERIOD);\r\n\t\t\t}\r\n\t\t}","id":90793,"modified_method":"private void startup() {\r\n\t\t\tif (_ncProto == NetworkProtocol.UDP) {\r\n\t\t\t\t_ncHeartBeatTimer = new Timer(true);\r\n\t\t\t\t_ncHeartBeatTimer.schedule(new HeartBeatTimer(), 0L);\r\n\t\t\t}\r\n\t\t}","commit_id":"f1a00e2671f305deee2ba89fbb064b04b4fc6acb","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void close() throws IOException {\r\n\t\t\tif (_ncProto == NetworkProtocol.UDP) {\r\n\t\t\t\t_ncDGrmChannel.close();\r\n\t\t\t\t_ncHeartBeatTimer.cancel();\r\n\t\t\t} else if (_ncProto == NetworkProtocol.TCP) {\r\n\t\t\t\t_ncSockChannel.close();\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IOException(\"NetworkChannel: invalid protocol specified\");\r\n\t\t\t}\r\n\t\t}","id":90794,"modified_method":"private void close() throws IOException {\r\n\t\t\tif (_ncProto == NetworkProtocol.UDP) {\r\n\t\t\t\t_ncDGrmChannel.close();\r\n\t\t\t\tif (null != _ncHeartBeatTimer)\r\n\t\t\t\t\t_ncHeartBeatTimer.cancel();\r\n\t\t\t} else if (_ncProto == NetworkProtocol.TCP) {\r\n\t\t\t\t_ncSockChannel.close();\r\n\t\t\t} else {\r\n\t\t\t\tthrow new IOException(\"NetworkChannel: invalid protocol specified\");\r\n\t\t\t}\r\n\t\t}","commit_id":"f1a00e2671f305deee2ba89fbb064b04b4fc6acb","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"protected Predicate<IEObjectDescription> getSearchPredicate(final String searchPattern) {\n\t\treturn new Predicate<IEObjectDescription>() {\n\t\t\tpublic boolean apply(IEObjectDescription input) {\n\t\t\t\treturn getPrefixMatcher().isCandidateMatchingPrefix(input.getName(), searchPattern)\n\t\t\t\t\t\t|| getPrefixMatcher().isCandidateMatchingPrefix(input.getQualifiedName(), searchPattern);\n\t\t\t}\n\t\t};\n\t}","id":90795,"modified_method":"protected Predicate<IEObjectDescription> getSearchPredicate(final String stringPattern) {\n\t\tfinal SearchPattern searchPattern = new SearchPattern();\n\t\tsearchPattern.setPattern(stringPattern);\n\t\treturn new Predicate<IEObjectDescription>() {\n\t\t\tpublic boolean apply(IEObjectDescription input) {\n\t\t\t\treturn searchPattern.matches(input.getName()) \n\t\t\t\t\t\t|| searchPattern.matches(input.getQualifiedName());\n\t\t\t}\n\t\t};\n\t}","commit_id":"27eaf93d57edf77ccf2b2857eb959b2e014f7d64","url":"https://github.com/eclipse/xtext"},{"original_method":"public void dispose() {\n\t\tviewer = null;\n\t\tmatches = null;\n\t\tstatusLabel = null;\n\t\tsizeCalculationJob.cancel();\n\t\tsizeCalculationJob = null;\n\t}","id":90796,"modified_method":"public void dispose() {\n\t\tviewer = null;\n\t\tmatches = null;\n\t\tstatusLabel = null;\n\t\tif (sizeCalculationJob != null) {\n\t\t\tsizeCalculationJob.cancel();\n\t\t\tsizeCalculationJob = null;\n\t\t}\n\t}","commit_id":"27eaf93d57edf77ccf2b2857eb959b2e014f7d64","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected void doShutdown() throws Exception {\n    leaderListenerCancellable.cancel();\n\n    heartbeatPublisher.stopAndWait();\n\n    if (leaderElection != null) {\n      Uninterruptibles.getUninterruptibly(leaderElection.stop(), 5, TimeUnit.SECONDS);\n    }\n\n    if (coordinationSubscription != null) {\n      coordinationSubscription.cancel();\n    }\n\n    if (resourceCoordinatorClient != null) {\n      resourceCoordinatorClient.stopAndWait();\n    }\n  }","id":90797,"modified_method":"@Override\n  protected void doShutdown() throws Exception {\n    for (Aggregator aggregator : aggregators.values()) {\n      aggregator.stopAndWait();\n    }\n\n    if (leaderListenerCancellable != null) {\n      leaderListenerCancellable.cancel();\n    }\n\n    if (heartbeatsSubscription != null) {\n      heartbeatsSubscription.cancel();\n    }\n\n    heartbeatPublisher.stopAndWait();\n\n    if (leaderElection != null) {\n      Uninterruptibles.getUninterruptibly(leaderElection.stop(), 5, TimeUnit.SECONDS);\n    }\n\n    if (coordinationSubscription != null) {\n      coordinationSubscription.cancel();\n    }\n\n    if (resourceCoordinatorClient != null) {\n      resourceCoordinatorClient.stopAndWait();\n    }\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void initialize() throws Exception {\n    heartbeatPublisher.startAndWait();\n    resourceCoordinatorClient.startAndWait();\n    coordinationSubscription = resourceCoordinatorClient.subscribe(discoverableSupplier.get().getName(),\n                                                                   new StreamsLeaderHandler());\n    performLeaderElection();\n  }","id":90798,"modified_method":"@Override\n  protected void initialize() throws Exception {\n    heartbeatPublisher.startAndWait();\n    resourceCoordinatorClient.startAndWait();\n    coordinationSubscription = resourceCoordinatorClient.subscribe(discoverableSupplier.get().getName(),\n                                                                   new StreamsLeaderHandler());\n\n    heartbeatsSubscription = subscribeToHeartbeatsFeed();\n    leaderListenerCancellable = addLeaderListener(new StreamLeaderListener() {\n      @Override\n      public void leaderOf(Set<String> streamNames) {\n        aggregate(streamNames);\n      }\n    });\n\n    performLeaderElection();\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public DistributedStreamService(CConfiguration cConf,\n                                  StreamCoordinatorClient streamCoordinatorClient,\n                                  StreamFileJanitorService janitorService,\n                                  ZKClient zkClient,\n                                  DiscoveryServiceClient discoveryServiceClient,\n                                  StreamMetaStore streamMetaStore,\n                                  Supplier<Discoverable> discoverableSupplier,\n                                  StreamWriterSizeCollector streamWriterSizeCollector,\n                                  HeartbeatPublisher heartbeatPublisher,\n                                  NotificationFeedManager notificationFeedManager,\n                                  StreamsHeartbeatsAggregator streamsHeartbeatsAggregator) {\n    super(streamCoordinatorClient, janitorService, notificationFeedManager);\n    this.zkClient = zkClient;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.streamMetaStore = streamMetaStore;\n    this.discoverableSupplier = discoverableSupplier;\n    this.streamWriterSizeCollector = streamWriterSizeCollector;\n    this.heartbeatPublisher = heartbeatPublisher;\n    this.streamsHeartbeatsAggregator = streamsHeartbeatsAggregator;\n    this.resourceCoordinatorClient = new ResourceCoordinatorClient(zkClient);\n    this.leaderListeners = Sets.newHashSet();\n    this.instanceId = cConf.getInt(Constants.Stream.CONTAINER_INSTANCE_ID);\n\n    this.leaderListenerCancellable = addLeaderListener(new StreamLeaderListener() {\n      @Override\n      public void leaderOf(Set<String> streamNames) {\n        DistributedStreamService.this.streamsHeartbeatsAggregator.aggregate(streamNames);\n      }\n    });\n  }","id":90799,"modified_method":"@Inject\n  public DistributedStreamService(CConfiguration cConf,\n                                  StreamAdmin streamAdmin,\n                                  StreamCoordinatorClient streamCoordinatorClient,\n                                  StreamFileJanitorService janitorService,\n                                  ZKClient zkClient,\n                                  DiscoveryServiceClient discoveryServiceClient,\n                                  StreamMetaStore streamMetaStore,\n                                  Supplier<Discoverable> discoverableSupplier,\n                                  StreamWriterSizeCollector streamWriterSizeCollector,\n                                  HeartbeatPublisher heartbeatPublisher,\n                                  NotificationFeedManager notificationFeedManager,\n                                  NotificationService notificationService) {\n    super(streamCoordinatorClient, janitorService, notificationFeedManager);\n    this.zkClient = zkClient;\n    this.streamAdmin = streamAdmin;\n    this.notificationService = notificationService;\n    this.discoveryServiceClient = discoveryServiceClient;\n    this.streamMetaStore = streamMetaStore;\n    this.discoverableSupplier = discoverableSupplier;\n    this.streamWriterSizeCollector = streamWriterSizeCollector;\n    this.heartbeatPublisher = heartbeatPublisher;\n    this.resourceCoordinatorClient = new ResourceCoordinatorClient(zkClient);\n    this.leaderListeners = Sets.newHashSet();\n    this.instanceId = cConf.getInt(Constants.Stream.CONTAINER_INSTANCE_ID);\n    this.aggregators = Maps.newConcurrentMap();\n    this.isInit = true;\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      Long initSize = streamsInitCounts.get(streamSpec.getName());\n      if (initSize == null) {\n        // First time that we see this Stream here\n        initSize = (long) 0;\n        streamsInitCounts.put(streamSpec.getName(), initSize);\n        streamsBaseCounts.put(streamSpec.getName(), initSize);\n      }\n      long absoluteSize = initSize + streamWriterSizeCollector.getTotalCollected(streamSpec.getName());\n\n      if (isInit || absoluteSize - streamsBaseCounts.get(streamSpec.getName()) >\n        Constants.Notification.Stream.DEFAULT_DATA_THRESHOLD) {\n        try {\n          publishNotification(streamSpec.getName(), absoluteSize);\n        } finally {\n          streamsBaseCounts.put(streamSpec.getName(), absoluteSize);\n        }\n      }\n    }\n    isInit = false;\n  }","id":90800,"modified_method":"@Override\n  protected void runOneIteration() throws Exception {\n    // Get stream size - which will be the entire size - and send a notification if the size is big enough\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      Aggregator aggregator = aggregators.get(streamSpec.getName());\n      if (aggregator == null) {\n        // First time that we see this Stream here\n        aggregator = new Aggregator(streamSpec.getName(), 0);\n        aggregators.put(streamSpec.getName(), aggregator);\n      }\n      aggregator.checkAggregatedSize();\n    }\n    isInit = false;\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      long filesSize = 0;\n      try {\n        StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n        filesSize = StreamUtils.fetchStreamFilesSize(config);\n      } catch (IOException e) {\n        LOG.error(\"Could not compute sizes of files for stream {}\", streamSpec.getName());\n      }\n      streamsInitCounts.put(streamSpec.getName(), filesSize);\n      streamsBaseCounts.put(streamSpec.getName(), filesSize);\n    }\n  }","id":90801,"modified_method":"@Override\n  protected void initialize() throws Exception {\n    for (StreamSpecification streamSpec : streamMetaStore.listStreams()) {\n      StreamConfig config = streamAdmin.getConfig(streamSpec.getName());\n      long filesSize = StreamUtils.fetchStreamFilesSize(config);\n      aggregators.put(streamSpec.getName(), new Aggregator(streamSpec.getName(), filesSize));\n    }\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Inject\n  public LocalStreamService(StreamCoordinatorClient streamCoordinatorClient,\n                            StreamFileJanitorService janitorService,\n                            StreamMetaStore streamMetaStore,\n                            StreamAdmin streamAdmin,\n                            StreamWriterSizeCollector streamWriterSizeCollector,\n                            NotificationFeedManager notificationFeedManager,\n                            NotificationService notificationService) {\n    super(streamCoordinatorClient, janitorService, notificationFeedManager);\n    this.streamAdmin = streamAdmin;\n    this.streamMetaStore = streamMetaStore;\n    this.streamWriterSizeCollector = streamWriterSizeCollector;\n    this.notificationService = notificationService;\n    this.streamsBaseCounts = Maps.newHashMap();\n    this.streamsInitCounts = Maps.newHashMap();\n    isInit = true;\n  }","id":90802,"modified_method":"@Inject\n  public LocalStreamService(StreamCoordinatorClient streamCoordinatorClient,\n                            StreamFileJanitorService janitorService,\n                            StreamMetaStore streamMetaStore,\n                            StreamAdmin streamAdmin,\n                            StreamWriterSizeCollector streamWriterSizeCollector,\n                            NotificationFeedManager notificationFeedManager,\n                            NotificationService notificationService) {\n    super(streamCoordinatorClient, janitorService, notificationFeedManager);\n    this.streamAdmin = streamAdmin;\n    this.streamMetaStore = streamMetaStore;\n    this.streamWriterSizeCollector = streamWriterSizeCollector;\n    this.notificationService = notificationService;\n    this.aggregators = Maps.newConcurrentMap();\n    this.isInit = true;\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(timestamp, absoluteSize);\n  }","id":90803,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(timestamp, size);\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"timestamp\", timestamp)\n      .add(\"absoluteSize\", absoluteSize)\n      .toString();\n  }","id":90804,"modified_method":"@Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n      .add(\"timestamp\", timestamp)\n      .add(\"size\", size)\n      .toString();\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"public StreamSizeNotification(long timestamp, long absoluteSize) {\n    this.timestamp = timestamp;\n    this.absoluteSize = absoluteSize;\n  }","id":90805,"modified_method":"public StreamSizeNotification(long timestamp, long size) {\n    this.timestamp = timestamp;\n    this.size = size;\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    StreamSizeNotification that = (StreamSizeNotification) o;\n\n    return Objects.equal(this.timestamp, that.timestamp) &&\n      Objects.equal(this.absoluteSize, that.absoluteSize);\n  }","id":90806,"modified_method":"@Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    StreamSizeNotification that = (StreamSizeNotification) o;\n\n    return Objects.equal(this.timestamp, that.timestamp) &&\n      Objects.equal(this.size, that.size);\n  }","commit_id":"b5f5c2c78253ad9174e78c052f040be74ad30ed2","url":"https://github.com/caskdata/cdap"},{"original_method":"public synchronized void close() throws IOException {\n    myWaitForThreadFuture.cancel(true);\n    myWaitSemaphore.up();\n\n    try {\n      if (myInputStream != null && !myContainsError) {\n          myInputStream.close();\n          try {\n              Thread.sleep(10);\n          } catch (InterruptedException e) {\n              //ignore\n          }\n      }\n    }\n    finally {\n      try {\n        if (myOutputStream != null && !myContainsError) {\n            myOutputStream.close();\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                //ignore\n            }\n\n        }\n        try {\n          myErrThread.setProcessTerminated(true);\n          myStdErrFuture.get();\n        }\n        catch (InterruptedException e) {\n          //\n        }\n        catch (ExecutionException e) {\n          LOG.error(e);\n        }\n      }\n      finally {\n        try {\n          if (myProcess != null) {\n              myProcess.destroy();\n          }\n        }\n        finally {\n          myInputStream = null;\n          myOutputStream = null;\n          myProcess = null;\n        }\n      }\n    }\n\n  }","id":90807,"modified_method":"public synchronized void close() throws IOException {\n    if (myWaitForThreadFuture != null) {\n      myWaitForThreadFuture.cancel(true);\n    }\n    if (myWaitSemaphore != null) {\n      myWaitSemaphore.up();\n    }\n\n    try {\n      if (myInputStream != null && !myContainsError) {\n          myInputStream.close();\n          try {\n              Thread.sleep(10);\n          } catch (InterruptedException e) {\n              //ignore\n          }\n      }\n    }\n    finally {\n      try {\n        if (myOutputStream != null && !myContainsError) {\n            myOutputStream.close();\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                //ignore\n            }\n\n        }\n        try {\n          if (myErrThread != null) {\n            myErrThread.setProcessTerminated(true);\n          }\n          if (myStdErrFuture != null) {\n            myStdErrFuture.get();\n          }\n        }\n        catch (InterruptedException e) {\n          //\n        }\n        catch (ExecutionException e) {\n          LOG.error(e);\n        }\n      }\n      finally {\n        try {\n          if (myProcess != null) {\n              myProcess.destroy();\n          }\n        }\n        finally {\n          myInputStream = null;\n          myOutputStream = null;\n          myProcess = null;\n        }\n      }\n    }\n\n  }","commit_id":"ebeb5fc74ced20acad2b1a0069c2a549bcb4c5ef","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean checkForPastSave(){\n    if(autosaveDir.exists()){\n      String prevSaves[] = Base.listFiles(autosaveDir, false);\n      if(prevSaves.length > 0){\n       pastSave = new File(prevSaves[0]);\n       return true;\n      }\n    }\n    return false;\n  }","id":90808,"modified_method":"public boolean checkForPastSave(){\n    if(autosaveDir.exists()){\n      String prevSaves[] = Base.listFiles(autosaveDir, false);\n      if(prevSaves.length > 0){\n       File t = new File(Base.listFiles(new File(prevSaves[0]), false)[0]);\n       pastSave = new File(t.getAbsolutePath() + File.separator + t.getName() + \".pde\"); \n       return true;\n      }\n    }\n    return false;\n  }","commit_id":"46e54ba52705839d6258ba02046d379f64b15b51","url":"https://github.com/processing/processing"},{"original_method":"public void stop(){\n    while(isSaving); // save operation mustn't be interrupted\n    timer.cancel();\n    Base.removeDir(autosaveDir);\n  }","id":90809,"modified_method":"public void stop(){\n    while(isSaving); // save operation mustn't be interrupted\n    if(timer != null) timer.cancel();\n    //Base.removeDir(autosaveDir);\n  }","commit_id":"46e54ba52705839d6258ba02046d379f64b15b51","url":"https://github.com/processing/processing"},{"original_method":"public void loadAutoSaver(){\n      autosaver = new AutoSaveUtil(this, 5);\n      if(!autosaver.checkForPastSave()) {\n        autosaver.init();\n        return;\n      }\n      \n      File pastSave = autosaver.getPastSave();\n      int response = Base.showYesNoQuestion(this, \"Unsaved backup found!\", \"An automatic backup of this \" +\n      \t\t\"sketch has been found. This may mean Processing quit unexpectedly last time.\", \n      \t\t\"Select YES to view it or NO to delete the backup.\");\n      if(response == JOptionPane.YES_OPTION){\n        handleOpenInternal(pastSave.getAbsolutePath());\n      }\n      else{\n        autosaver.init();\n      }\n    }","id":90810,"modified_method":"public void loadAutoSaver(){\n      autosaver = new AutoSaveUtil(this, 5);\n      if(!autosaver.checkForPastSave()) {\n        autosaver.init();\n        return;\n      }\n      \n      File pastSave = autosaver.getPastSave();\n      int response = Base.showYesNoQuestion(this, \"Unsaved backup found!\", \"An automatic backup of this \" +\n      \t\t\"sketch has been found. This may mean Processing quit unexpectedly last time.\", \n      \t\t\"Select YES to view it or NO to delete the backup.\");\n      if(response == JOptionPane.YES_OPTION){\n        handleOpenInternal(pastSave.getAbsolutePath());\n        //log(getSketch().getMainFilePath());\n        autosaver = new AutoSaveUtil(this, 5);\n      }\n      autosaver.init();        \n    }","commit_id":"46e54ba52705839d6258ba02046d379f64b15b51","url":"https://github.com/processing/processing"},{"original_method":"public void stop() {\n    myExecutingFuture.cancel(true);\n    try {\n      myServerSocket.close();\n    } catch (IOException e) {\n      throw new RuntimeException(e); //TODO implement catch clause\n    }\n  }","id":90811,"modified_method":"public void stop() {\n    if (myExecutingFuture != null) {\n      myExecutingFuture.cancel(true);\n    }\n    try {\n      if (myServerSocket != null) {\n        myServerSocket.close();\n      }\n    } catch (IOException e) {\n      throw new RuntimeException(e); //TODO implement catch clause\n    }\n  }","commit_id":"ea2bee8b0ee79763bc9291193ad202203840ec02","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n\tprotected void configureSourceViewer(ISourceViewer sourceViewer) {\n\t\tsourceViewer.setEditable(false);\n\t\tsourceViewer.configure(sourceViewerConfiguration);\n\t\tif (sourceViewer instanceof ITextViewerExtension6) {\n\t\t\tITextViewerExtension6 textViewerExtension6 = (ITextViewerExtension6) sourceViewer;\n\t\t\ttextViewerExtension6.setHyperlinkDetectors(null,\n\t\t\t\t\tsourceViewerConfiguration.getHyperlinkStateMask(sourceViewer));\n\t\t}\n\t}","id":90812,"modified_method":"@Override\n\tprotected void configureSourceViewer(ISourceViewer sourceViewer) {\n\t\tsourceViewer.setEditable(false);\n\t\tsourceViewer.configure(sourceViewerConfiguration);\n\t\tif (sourceViewer instanceof ITextViewerExtension6) {\n\t\t\tITextViewerExtension6 textViewerExtension6 = (ITextViewerExtension6) sourceViewer;\n\t\t\ttextViewerExtension6.setHyperlinkDetectors(null,\n\t\t\t\t\tsourceViewerConfiguration.getHyperlinkStateMask(sourceViewer));\n\t\t}\n\t\tif (sourceViewer instanceof ITextViewerExtension2) {\n\t\t\tITextViewerExtension2 textViewerExtension2 = (ITextViewerExtension2) sourceViewer;\n\t\t\tString[] configuredContentTypes = sourceViewerConfiguration.getConfiguredContentTypes(sourceViewer);\n\t\t\tfor (String contentType : configuredContentTypes) {\n\t\t\t\ttextViewerExtension2.removeTextHovers(contentType);\n\t\t\t}\n\t\t}\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void disconnectDocuments() {\n\t\tIMergeViewerContentProvider contentProvider = (IMergeViewerContentProvider) getContentProvider();\n\t\tdocumentProvider.disconnect(contentProvider.getLeftContent(getInput()));\n\t\tdocumentProvider.disconnect(contentProvider.getRightContent(getInput()));\n\t}","id":90813,"modified_method":"protected void disconnectDocuments() {\n\t\tIMergeViewerContentProvider contentProvider = (IMergeViewerContentProvider) getContentProvider();\n\t\tObject ancestorContent = contentProvider.getAncestorContent(getInput());\n\t\tObject leftContent = contentProvider.getLeftContent(getInput());\n\t\tObject rightContent = contentProvider.getRightContent(getInput());\n\t\tdocumentProvider.disconnect(inputObjectStreamContentAccessorMap.get(ancestorContent));\n\t\tdocumentProvider.disconnect(inputObjectStreamContentAccessorMap.get(leftContent));\n\t\tdocumentProvider.disconnect(inputObjectStreamContentAccessorMap.get(rightContent));\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void setEditable(ISourceViewer sourceViewer, boolean state) {\n\t\tsuper.setEditable(sourceViewer, state);\n\t\tDefaultMergeEditor mergeEditor = getEditor(sourceViewer);\n\t\tif (mergeEditor != null) {\n\t\t\tmergeEditor.setEditable(state);\n\t\t}\n\t}","id":90814,"modified_method":"@Override\n\tprotected void setEditable(ISourceViewer sourceViewer, boolean state) {\n\t\tsuper.setEditable(sourceViewer, state);\n\t\tDefaultMergeEditor mergeEditor = getEditor(sourceViewer);\n\t\tif (mergeEditor != null && mergeEditor.getEditorInput() != null) {\n\t\t\tmergeEditor.setEditable(state);\n\t\t}\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected Object updateAsDocument(Object object) {\n\t\tif (object instanceof IResourceProvider && supportsSharedDocuments(object)) {\n\t\t\treturn object;\n\t\t}\n\t\tif (object instanceof IStreamContentAccessor) {\n\t\t\ttry {\n\t\t\t\tdocumentProvider.connect(object);\n\t\t\t\treturn documentProvider.getDocument(object);\n\t\t\t} catch (CoreException coreException) {\n\t\t\t\tthrow new WrappedException(coreException);\n\t\t\t}\n\t\t}\n\t\treturn object;\n\t}","id":90815,"modified_method":"protected Object updateAsDocument(Object object) {\n\t\tif (object instanceof IResourceProvider && supportsSharedDocuments(object)) {\n\t\t\treturn object;\n\t\t}\n\t\tif (object instanceof IStreamContentAccessor) {\n\t\t\ttry {\n\t\t\t\tStreamContentAccessorDelegate streamContentAccessorDelegate = new StreamContentAccessorDelegate(\n\t\t\t\t\t\t(IStreamContentAccessor) object, createResourceProvider(object));\n\t\t\t\tdocumentProvider.connect(streamContentAccessorDelegate);\n\t\t\t\tinputObjectStreamContentAccessorMap.put(object, streamContentAccessorDelegate);\n\t\t\t\treturn documentProvider.getDocument(streamContentAccessorDelegate);\n\t\t\t} catch (CoreException coreException) {\n\t\t\t\tthrow new WrappedException(coreException);\n\t\t\t}\n\t\t}\n\t\treturn object;\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void configureSourceViewer(SourceViewer sourceViewer) {\n\t\tIEditorInput editorInput = getEditorInput(sourceViewer);\n\t\tSourceViewerConfiguration sourceViewerConfiguration = createSourceViewerConfiguration(sourceViewer, editorInput);\n\t\tsourceViewer.unconfigure();\n\t\tsourceViewer.configure(sourceViewerConfiguration);\n\t\tif (null == editorInput) {\n\t\t\tsourceViewer.setHyperlinkDetectors(null, sourceViewerConfiguration.getHyperlinkStateMask(sourceViewer));\n\t\t}\n\t}","id":90816,"modified_method":"protected void configureSourceViewer(SourceViewer sourceViewer) {\n\t\tIEditorInput editorInput = getEditorInput(sourceViewer);\n\t\tSourceViewerConfiguration sourceViewerConfiguration = createSourceViewerConfiguration(sourceViewer, editorInput);\n\t\tsourceViewer.unconfigure();\n\t\tsourceViewer.configure(sourceViewerConfiguration);\n\t\tif (sourceViewer.getDocument() instanceof IXtextDocument) {\n\t\t\tIXtextDocument xtextDocument = (IXtextDocument) sourceViewer.getDocument();\n\t\t\tif (!xtextDocument.readOnly(TEST_EXISTING_XTEXT_RESOURCE)) {\n\t\t\t\tString[] configuredContentTypes = sourceViewerConfiguration.getConfiguredContentTypes(sourceViewer);\n\t\t\t\tfor (String contentType : configuredContentTypes) {\n\t\t\t\t\tsourceViewer.removeTextHovers(contentType);\n\t\t\t\t}\n\t\t\t\tsourceViewer.setHyperlinkDetectors(null, sourceViewerConfiguration.getHyperlinkStateMask(sourceViewer));\n\t\t\t}\n\t\t}\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected IDocument createDocument(Object element) throws CoreException {\n\t\tIDocument document = null;\n\t\tif (element instanceof IStreamContentAccessor) {\n\t\t\tdocument = createEmptyDocument();\n\t\t\tsetupDocument(element, document);\n\t\t}\n\t\tif (document != null) {\n\t\t\tIDocumentPartitioner partitioner = documentPartitioner.get();\n\t\t\tpartitioner.connect(document);\n\t\t\tdocument.setDocumentPartitioner(partitioner);\n\t\t}\n\t\treturn document;\n\t}","id":90817,"modified_method":"@Override\n\tprotected IDocument createDocument(Object element) throws CoreException {\n\t\tIDocument document = null;\n\t\tif (element instanceof IStreamContentAccessor) {\n\t\t\tdocument = createEmptyDocument();\n\t\t\tsetupDocument(element, document);\n\t\t}\n\t\treturn document;\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String readString(IStreamContentAccessor streamContentAccessor) throws CoreException {\n\t\tInputStream is = streamContentAccessor.getContents();\n\t\tif (is != null) {\n\t\t\tString encoding = null;\n\t\t\tif (streamContentAccessor instanceof IEncodedStreamContentAccessor) {\n\t\t\t\ttry {\n\t\t\t\t\tencoding = ((IEncodedStreamContentAccessor) streamContentAccessor).getCharset();\n\t\t\t\t} catch (CoreException exception) {\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (encoding == null) {\n\t\t\t\tencoding = ResourcesPlugin.getEncoding();\n\t\t\t}\n\t\t\treturn readString(is, encoding);\n\t\t}\n\t\treturn null;\n\t}","id":90818,"modified_method":"protected String readString(IStreamContentAccessor streamContentAccessor) throws CoreException {\n\t\tInputStream inputStream = streamContentAccessor.getContents();\n\t\tif (inputStream != null) {\n\t\t\tString encoding = getEncoding(streamContentAccessor);\n\t\t\treturn readString(inputStream, encoding);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void setupDocument(Object element, IDocument document) {\n\t\tif (element instanceof IStreamContentAccessor) {\n\t\t\tdocument.set(getString(element));\n\t\t}\n\t}","id":90819,"modified_method":"protected void setupDocument(Object element, IDocument document) {\n\t\tString content = getString(element);\n\t\tdocument.set(content);\n\n\t\tIDocumentPartitioner partitioner = documentPartitioner.get();\n\t\tpartitioner.connect(document);\n\t\tdocument.setDocumentPartitioner(partitioner);\n\n\t\tXtextResource resource = createResource(element);\n\t\tloadResource(element, resource);\n\t\tif (resource!=null) {\n\t\t\t((XtextDocument) document).setInput(resource);\n\t\t}\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String readString(InputStream is, String encoding) {\n\t\tif (is == null) {\n\t\t\treturn null;\n\t\t}\n\t\tBufferedReader reader = null;\n\t\ttry {\n\t\t\tStringBuffer buffer = new StringBuffer();\n\t\t\tchar[] part = new char[2048];\n\t\t\tint read = 0;\n\t\t\treader = new BufferedReader(new InputStreamReader(is, encoding));\n\n\t\t\twhile ((read = reader.read(part)) != -1)\n\t\t\t\tbuffer.append(part, 0, read);\n\n\t\t\treturn buffer.toString();\n\n\t\t} catch (IOException ex) {\n\n\t\t} finally {\n\t\t\tif (reader != null) {\n\t\t\t\ttry {\n\t\t\t\t\treader.close();\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":90820,"modified_method":"protected String readString(InputStream inputStream, String encoding) {\n\t\tif (inputStream == null) {\n\t\t\treturn null;\n\t\t}\n\t\tBufferedReader reader = null;\n\t\ttry {\n\t\t\tStringBuffer buffer = new StringBuffer();\n\t\t\tchar[] part = new char[2048];\n\t\t\tint read = 0;\n\t\t\treader = new BufferedReader(new InputStreamReader(inputStream, encoding));\n\n\t\t\twhile ((read = reader.read(part)) != -1)\n\t\t\t\tbuffer.append(part, 0, read);\n\n\t\t\treturn buffer.toString();\n\n\t\t} catch (IOException ex) {\n\n\t\t} finally {\n\t\t\tif (reader != null) {\n\t\t\t\ttry {\n\t\t\t\t\treader.close();\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void checkAndUpdateAnnotations() {\n\t\tvalidationJob.cancel();\n\t\tvalidationJob.schedule();\n\t}","id":90821,"modified_method":"public void checkAndUpdateAnnotations() {\n\t\tif (validationJob!=null) {\n\t\t\tvalidationJob.cancel();\n\t\t\tvalidationJob.schedule();\n\t\t}\n\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic <T> T modify(IUnitOfWork<T, XtextResource> work) {\n\t\t\ttry {\n\t\t\t\tvalidationJob.cancel();\n\t\t\t\treturn super.modify(work);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\ttry {\n\t\t\t\t\tXtextResource state = getState();\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t\tstate.reparse(get());\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\tcheckAndUpdateAnnotations();\n\t\t\t}\n\t\t}","id":90822,"modified_method":"@Override\n\t\tpublic <T> T modify(IUnitOfWork<T, XtextResource> work) {\n\t\t\ttry {\n\t\t\t\tif (validationJob!=null) {\n\t\t\t\t\tvalidationJob.cancel();\n\t\t\t\t}\n\t\t\t\treturn super.modify(work);\n\t\t\t} catch (RuntimeException e) {\n\t\t\t\ttry {\n\t\t\t\t\tXtextResource state = getState();\n\t\t\t\t\tif (state != null)\n\t\t\t\t\t\tstate.reparse(get());\n\t\t\t\t} catch (IOException ioe) {\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t} finally {\n\t\t\t\tcheckAndUpdateAnnotations();\n\t\t\t}\n\t\t}","commit_id":"248c724584e2e94080725be084217d00df3d03d6","url":"https://github.com/eclipse/xtext"},{"original_method":"public ComponentDefinitionParser(Class clazz)\n    {\n        super(clazz, true);\n    }","id":90823,"modified_method":"public ComponentDefinitionParser()\n    {\n        addDelegate(parent);\n        addDelegate(pojoService);\n        registerPreProcessor(new CheckExclusiveClassAttributeObjectFactory());\n    }","commit_id":"41beee3b30c40b569d2fe77ff04a9c0f794321cd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)\n    {\n        Element parent = (Element) element.getParentNode();\n        String modelName = parent.getAttribute(ATTRIBUTE_NAME);\n        builder.addPropertyReference(\"model\", modelName);\n        super.doParse(element, parserContext, builder);\n    }","id":90824,"modified_method":"protected MuleDefinitionParser getDelegate(Element element, ParserContext parserContext)\n    {\n        if (StringUtils.isEmpty(element.getAttribute(AbstractMuleBeanDefinitionParser.ATTRIBUTE_CLASS)))\n        {\n            return parent;\n        }\n        else\n        {\n            return pojoService;\n        }\n    }","commit_id":"41beee3b30c40b569d2fe77ff04a9c0f794321cd","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"model\", new OrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"service\", new ComponentDefinitionParser(SedaComponent.class));\n    }","id":90825,"modified_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"model\", new OrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(SedaComponent.class));\n    }","commit_id":"41beee3b30c40b569d2fe77ff04a9c0f794321cd","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"admin-agent\", new MuleAdminAgentDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-component-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"component-threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerMuleDefinitionParser(\"transformer\", new ParentDefinitionParser()).addAlias(\"ref\", \"transformer\");\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"transformer-no-action\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-message-properties\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-object-to-string\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-string\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"transformer-string-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-append-string\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"transaction-manager-jndi\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-weblogic\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-jboss\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-jrun\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-resin\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-websphere\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"response-endpoint\", new GenericEndpointDefinitionParser(ResponseEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n        registerBeanDefinitionParser(\"custom-transaction-factory\", new TransactionFactoryDefinitionParser());\n        registerMuleDefinitionParser(\"transaction-factory\", new ParentDefinitionParser()).addAlias(\"ref\", \"factory\");\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        //TODO RM*\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolverSet\", null));\n        //registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        // Components\n        registerBeanDefinitionParser(\"seda-component\", new PassThroughComponentAdapter(new ComponentDefinitionParser(SedaComponent.class)));\n        registerBeanDefinitionParser(\"service\", new PassThroughComponentAdapter(new ComponentDefinitionParser(SedaComponent.class)));\n\n        // Common POJO Services\n        registerBeanDefinitionParser(\"bridge-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n        registerBeanDefinitionParser(\"no-args-call-component\", new SimplePojoServiceDefinitionParser(NoArgsCallWrapper.class));\n\n        //Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new PojoServiceDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new PojoServiceDefinitionParser(PrototypeObjectFactory.class));\n        BeanDefinitionParser bpdPooledObject = new PojoServiceDefinitionParser(PooledObjectFactory.class);\n        registerBeanDefinitionParser(\"pooled-object\", bpdPooledObject);\n        registerBeanDefinitionParser(\"component\", bpdPooledObject);\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound-router\", new ChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new ChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"nested-router\", new ChildDefinitionParser(\"nestedRouter\", NestedRouterCollection.class));\n        registerBeanDefinitionParser(\"response-router\", new ChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //NoArgsCallWrapper\n        registerBeanDefinitionParser(\"delegateClass\", new AttributeMapDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"delegateInstance\", new AttributeMapDefinitionParser(\"properties\"));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new ForwardingRouterDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\"));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Nested binding\n        registerBeanDefinitionParser(\"binding\", new RouterDefinitionParser(\"router\", NestedRouter.class));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(\"router\", null));\n        registerMuleDefinitionParser(\"reply-to\", new ParentDefinitionParser()).addAlias(\"address\", \"replyTo\");\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-response-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"single-response-router\", new RouterDefinitionParser(\"router\", SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"function-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", FunctionPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessageHeaderPropertyExtractor.class));\n        //registerBeanDefinitionParser(\"payload-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", PayloadPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerMuleDefinitionParser(\"filter\", new ParentDefinitionParser()).addAlias(\"ref\", \"filter\");\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\"));\n        registerMuleDefinitionParser(\"add-properties\", new ChildMapDefinitionParser(\"addProperties\"));\n        registerMuleDefinitionParser(\"delete-properties\", new ChildListDefinitionParser(\"deleteProperties\"));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\"));\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerMuleDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER)).addIgnored(\"type\").addIgnored(\"name\");\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerMuleDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\")).addAlias(\"strategy\", \"encryptionStrategy\");\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","id":90826,"modified_method":"public void init()\n    {\n        registerIgnoredElement(\"mule\");\n        registerIgnoredElement(\"description\");\n\n        //Common elements\n        registerBeanDefinitionParser(\"configuration\", new ConfigurationDefinitionParser());\n        registerBeanDefinitionParser(\"environment-property\", new EnvironmentPropertyDefinitionParser());\n        registerBeanDefinitionParser(\"admin-agent\", new MuleAdminAgentDefinitionParser());\n        registerBeanDefinitionParser(\"default-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-receiver-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-component-threading-profile\", new DefaultThreadingProfileDefinitionParser(MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"default-dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser());\n        registerBeanDefinitionParser(\"default-receiver-connection-strategy\", new ConnectionStrategyDefinitionParser());\n\n        //registerBeanDefinitionParser(\"mule-configuration\", new ManagementContextDefinitionParser());\n        registerBeanDefinitionParser(\"component-threading-profile\", new ThreadingProfileDefinitionParser(\"threadingProfile\", MuleConfiguration.DEFAULT_COMPONENT_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"custom-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", null));\n        registerBeanDefinitionParser(\"default-service-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultComponentExceptionStrategy.class));\n        registerBeanDefinitionParser(\"default-connector-exception-strategy\", new ChildDefinitionParser(\"exceptionListener\", DefaultExceptionStrategy.class));\n        registerBeanDefinitionParser(\"pooling-profile\", new PoolingProfileDefinitionParser());\n        registerBeanDefinitionParser(\"queue-profile\", new ChildDefinitionParser(\"queueProfile\", QueueProfile.class));\n\n        //Connector elements\n        registerBeanDefinitionParser(\"dispatcher-threading-profile\", new ThreadingProfileDefinitionParser(\"dispatcherThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_DISPATCHER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"receiver-threading-profile\", new ThreadingProfileDefinitionParser(\"receiverThreadingProfile\", MuleConfiguration.DEFAULT_MESSAGE_RECEIVER_THREADING_PROFILE));\n        registerBeanDefinitionParser(\"dispatcher-connection-strategy\", new ConnectionStrategyDefinitionParser(\"dispatcherConnectionStrategy\"));\n        registerBeanDefinitionParser(\"receiver-connection-straqtegy\", new ConnectionStrategyDefinitionParser(\"receiverConnectionStrategy\"));\n        registerBeanDefinitionParser(\"service-overrides\", new ServiceOverridesDefinitionParser());\n        registerBeanDefinitionParser(\"custom-connector\", new MuleOrphanDefinitionParser(true));\n\n        //Transformer elements\n        registerBeanDefinitionParser(\"transformer\", new ParentDefinitionParser().addAlias(\"ref\", \"transformer\"));\n\n        registerBeanDefinitionParser(\"custom-transformer\", new TransformerDefinitionParser());\n        registerBeanDefinitionParser(\"transformer-no-action\", new TransformerDefinitionParser(NoActionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-message-properties\", new TransformerDefinitionParser(MessagePropertiesTransformer.class));\n\n        registerBeanDefinitionParser(\"transformer-base64-encoder\", new TransformerDefinitionParser(Base64Encoder.class));\n        registerBeanDefinitionParser(\"transformer-base64-decoder\", new TransformerDefinitionParser(Base64Decoder.class));\n\n        registerBeanDefinitionParser(\"transformer-xml-entity-encoder\", new TransformerDefinitionParser(XmlEntityEncoder.class));\n        registerBeanDefinitionParser(\"transformer-xml-entity-decoder\", new TransformerDefinitionParser(XmlEntityDecoder.class));\n        registerBeanDefinitionParser(\"transformer-gzip-compress\", new TransformerDefinitionParser(GZipCompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-gzip-uncompress\", new TransformerDefinitionParser(GZipUncompressTransformer.class));\n        registerBeanDefinitionParser(\"transformer-encrypt\", new TransformerDefinitionParser(EncryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-decrypt\", new TransformerDefinitionParser(DecryptionTransformer.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-hex-string\", new TransformerDefinitionParser(ByteArrayToHexString.class));\n        registerBeanDefinitionParser(\"transformer-hex-sting-to-byte-array\", new TransformerDefinitionParser(HexStringToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-byte-array-to-object\", new TransformerDefinitionParser(ByteArrayToObject.class));\n        registerBeanDefinitionParser(\"transformer-object-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-object-to-string\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-serializable\", new TransformerDefinitionParser(ByteArrayToSerializable.class));\n        registerBeanDefinitionParser(\"transformer-serializable-to-byte-array\", new TransformerDefinitionParser(SerializableToByteArray.class));\n        registerBeanDefinitionParser(\"transformer-byte-array-to-string\", new TransformerDefinitionParser(ObjectToString.class));\n        registerBeanDefinitionParser(\"transformer-string-to-byte-array\", new TransformerDefinitionParser(ObjectToByteArray.class));\n\n        registerBeanDefinitionParser(\"transformer-append-string\", new TransformerDefinitionParser(StringAppendTransformer.class));\n\n        //Transaction Managers\n        registerBeanDefinitionParser(\"custom-transaction-manager\", new TransactionManagerDefinitionParser());\n        registerBeanDefinitionParser(\"transaction-manager-jndi\", new TransactionManagerDefinitionParser(GenericTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-weblogic\", new TransactionManagerDefinitionParser(WeblogicTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-jboss\", new TransactionManagerDefinitionParser(JBossTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-jrun\", new TransactionManagerDefinitionParser(JRunTransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-resin\", new TransactionManagerDefinitionParser(Resin3TransactionManagerLookupFactory.class));\n        registerBeanDefinitionParser(\"transaction-manager-websphere\", new TransactionManagerDefinitionParser(WebsphereTransactionManagerLookupFactory.class));\n\n        //Endpoint elements\n        registerBeanDefinitionParser(\"endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"inbound-endpoint\", new GenericEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"outbound-endpoint\", new GenericEndpointDefinitionParser(OutboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"response-endpoint\", new GenericEndpointDefinitionParser(ResponseEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"transaction\", new TransactionConfigDefinitionParser());\n        registerBeanDefinitionParser(\"custom-transaction-factory\", new TransactionFactoryDefinitionParser());\n        registerBeanDefinitionParser(\"transaction-factory\", new ParentDefinitionParser().addAlias(\"ref\", \"factory\"));\n\n        //Container contexts\n        registerBeanDefinitionParser(\"custom-container\", new MuleOrphanDefinitionParser(true));\n        registerBeanDefinitionParser(\"rmi-container\", new MuleOrphanDefinitionParser(RmiContainerContext.class, true));\n        registerBeanDefinitionParser(\"jndi-container\", new MuleOrphanDefinitionParser(JndiContainerContext.class, true));\n        registerBeanDefinitionParser(\"properties-container\", new MuleOrphanDefinitionParser(PropertiesContainerContext.class, true));\n\n        // Models\n        registerBeanDefinitionParser(\"model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n        registerBeanDefinitionParser(\"seda-model\", new InheritDefinitionParser(new OrphanDefinitionParser(SedaModel.class, true), new NamedDefinitionParser()));\n//        registerBeanDefinitionParser(\"model-seda-optimised\", new OrphanDefinitionParser(OptimisedSedaModel.class, true));\n//        registerBeanDefinitionParser(\"model-pipeline\", new OrphanDefinitionParser(PipelineModel.class, true));\n\n        //TODO RM*\n        registerBeanDefinitionParser(\"custom-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolverSet\", null));\n        //registerBeanDefinitionParser(\"callable-entrypoint-resolver\", new ChildDefinitionParser(\"entryPointResolver\", CallableEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"method-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"reflection-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", MethodEntryPointResolver.class));\n        //registerBeanDefinitionParser(\"non-void-entrypoint-resolver\", new ChildDefinitionParser(\"entrypointResolver\", NonVoidEntryPointResolver.class));\n\n        // Services\n        registerBeanDefinitionParser(\"seda-component\", new PassThroughComponentAdapter(new ServiceDefinitionParser(SedaComponent.class)));\n        registerBeanDefinitionParser(\"service\", new PassThroughComponentAdapter(new ServiceDefinitionParser(SedaComponent.class)));\n\n        // Pojo Components\n        registerBeanDefinitionParser(\"component\", new ComponentDefinitionParser());\n        registerBeanDefinitionParser(\"binding\", new BindingDefinitionParser(\"nestedRouter.routers\", NestedRouter.class).addCollection(\"nestedRouter.routers\"));\n\n        // Other Somponents\n        registerBeanDefinitionParser(\"bridge-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"pass-through-component\", new SimplePojoServiceDefinitionParser(PassThroughComponent.class));\n        registerBeanDefinitionParser(\"log-component\", new SimplePojoServiceDefinitionParser(LogComponent.class));\n        registerBeanDefinitionParser(\"echo-component\", new SimplePojoServiceDefinitionParser(EchoComponent.class));\n        registerBeanDefinitionParser(\"null-component\", new SimplePojoServiceDefinitionParser(NullComponent.class));\n        registerBeanDefinitionParser(\"no-args-call-component\", new SimplePojoServiceDefinitionParser(NoArgsCallWrapper.class));\n\n        // Object Factories\n        registerBeanDefinitionParser(\"singleton-object\", new PojoComponentDefinitionParser(SingletonObjectFactory.class));\n        registerBeanDefinitionParser(\"prototype-object\", new PojoComponentDefinitionParser(PrototypeObjectFactory.class));\n        registerBeanDefinitionParser(\"pooled-object\", new PojoComponentDefinitionParser(PooledObjectFactory.class));\n\n        //Routers\n        registerBeanDefinitionParser(\"inbound-router\", new ChildDefinitionParser(\"inboundRouter\", InboundRouterCollection.class));\n        registerBeanDefinitionParser(\"outbound-router\", new ChildDefinitionParser(\"outboundRouter\", OutboundRouterCollection.class));\n        registerBeanDefinitionParser(\"response-router\", new ChildDefinitionParser(\"responseRouter\", ResponseRouterCollection.class));\n\n        //NoArgsCallWrapper\n        registerBeanDefinitionParser(\"delegateClass\", new AttributeMapDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"delegateInstance\", new AttributeMapDefinitionParser(\"properties\"));\n\n        //Inbound Routers\n        registerBeanDefinitionParser(\"forwarding-router\", new ForwardingRouterDefinitionParser());\n        registerBeanDefinitionParser(\"inbound-pass-through-router\", new RouterDefinitionParser(\"router\", InboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"idempotent-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentReceiver.class));\n        registerBeanDefinitionParser(\"idempotent-secure-hash-receiver-router\", new RouterDefinitionParser(\"router\", IdempotentSecureHashReceiver.class));\n        registerBeanDefinitionParser(\"selective-consumer-router\", new RouterDefinitionParser(\"router\", SelectiveConsumer.class));\n        registerBeanDefinitionParser(\"wire-tap-router\", new RouterDefinitionParser(\"router\", WireTap.class));\n        registerBeanDefinitionParser(\"correlation-aggregator-router\", new RouterDefinitionParser(\"router\"));\n        registerBeanDefinitionParser(\"message-chunking-aggregator-router\", new RouterDefinitionParser(\"router\", MessageChunkingAggregator.class));\n        registerBeanDefinitionParser(\"correlation-resequencer-router\", new RouterDefinitionParser(\"router\", CorrelationEventResequencer.class));\n        registerBeanDefinitionParser(\"custom-inbound-router\", new RouterDefinitionParser(\"router\", null));\n\n        //Outbound Routers\n        registerBeanDefinitionParser(\"outbound-pass-through-router\", new RouterDefinitionParser(\"router\", OutboundPassThroughRouter.class));\n        registerBeanDefinitionParser(\"filtering-router\", new RouterDefinitionParser(\"router\", FilteringOutboundRouter.class));\n        registerBeanDefinitionParser(\"chaining-router\", new RouterDefinitionParser(\"router\", ChainingRouter.class));\n        registerBeanDefinitionParser(\"endpoint-selector-router\", new RouterDefinitionParser(\"router\", EndpointSelector.class));\n        registerBeanDefinitionParser(\"exception-based-router\", new RouterDefinitionParser(\"router\", ExceptionBasedRouter.class));\n        registerBeanDefinitionParser(\"list-message-splitter-router\", new RouterDefinitionParser(\"router\", FilteringListMessageSplitter.class));\n        registerBeanDefinitionParser(\"message-chunking-router\", new RouterDefinitionParser(\"router\", MessageChunkingRouter.class));\n        registerBeanDefinitionParser(\"multicasting-router\", new RouterDefinitionParser(\"router\", MulticastingRouter.class));\n        registerBeanDefinitionParser(\"static-recipient-list-router\", new RouterDefinitionParser(\"router\", StaticRecipientList.class));\n        registerBeanDefinitionParser(\"template-endpoint-router\", new RouterDefinitionParser(\"router\", TemplateEndpointRouter.class));\n        registerBeanDefinitionParser(\"custom-outbound-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"reply-to\", new ParentDefinitionParser().addAlias(\"address\", \"replyTo\"));\n\n        //Response Routers\n        registerBeanDefinitionParser(\"custom-response-router\", new RouterDefinitionParser(\"router\", null));\n        registerBeanDefinitionParser(\"single-response-router\", new RouterDefinitionParser(\"router\", SingleResponseRouter.class));\n\n        //Property Extractors\n        registerBeanDefinitionParser(\"function-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", FunctionPropertyExtractor.class));\n        registerBeanDefinitionParser(\"correlation-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", CorrelationPropertiesExtractor.class));\n        registerBeanDefinitionParser(\"custom-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\"));\n        registerBeanDefinitionParser(\"map-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MapPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"message-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", MessageHeaderPropertyExtractor.class));\n        //registerBeanDefinitionParser(\"payload-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", PayloadPropertyExtractor.class));\n\n        //Catch all Strategies\n        registerBeanDefinitionParser(\"logging-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", LoggingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n        registerBeanDefinitionParser(\"forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", ForwardingCatchAllStrategy.class));\n        registerBeanDefinitionParser(\"custom-forwarding-catch-all-strategy\", new ChildDefinitionParser(\"catchAllStrategy\", null));\n\n        //Common Filters\n        registerBeanDefinitionParser(\"filter\", new ParentDefinitionParser().addAlias(\"ref\", \"filter\"));\n        registerBeanDefinitionParser(\"and-filter\", new FilterDefinitionParser(AndFilter.class));\n        registerBeanDefinitionParser(\"or-filter\", new FilterDefinitionParser(OrFilter.class));\n        registerBeanDefinitionParser(\"not-filter\", new FilterDefinitionParser(NotFilter.class));\n        registerBeanDefinitionParser(\"regex-filter\", new FilterDefinitionParser(RegExFilter.class));\n        registerBeanDefinitionParser(\"exception-type-filter\", new FilterDefinitionParser(ExceptionTypeFilter.class));\n        registerBeanDefinitionParser(\"message-property-filter\", new FilterDefinitionParser(MessagePropertyFilter.class));\n        registerBeanDefinitionParser(\"payload-type-filter\", new FilterDefinitionParser(PayloadTypeFilter.class));\n        registerBeanDefinitionParser(\"wildcard-filter\", new FilterDefinitionParser(WildcardFilter.class));\n        registerBeanDefinitionParser(\"equals-filter\", new FilterDefinitionParser(EqualsFilter.class));\n        registerBeanDefinitionParser(\"custom-filter\", new FilterDefinitionParser());\n\n        //Retry strategies\n        registerBeanDefinitionParser(\"retry-connection-strategy\", new ChildDefinitionParser(\"connectionStrategy\", SimpleRetryConnectionStrategy.class));\n\n        //Utils / Standard Types\n        registerBeanDefinitionParser(\"properties\", new ChildMapDefinitionParser(\"properties\"));\n        registerBeanDefinitionParser(\"add-properties\", new ChildMapDefinitionParser(\"addProperties\"));\n        registerBeanDefinitionParser(\"delete-properties\", new ChildListDefinitionParser(\"deleteProperties\"));\n        registerBeanDefinitionParser(\"jndi-provider-properties\", new ChildMapDefinitionParser(\"jndiProviderProperties\"));\n        registerBeanDefinitionParser(\"environment\", new ChildMapDefinitionParser(\"environment\"));\n\n        //Security\n        registerBeanDefinitionParser(\"security-manager\", new NamedDefinitionParser(MuleProperties.OBJECT_SECURITY_MANAGER).addIgnored(\"type\").addIgnored(\"name\"));\n        registerBeanDefinitionParser(\"custom-security-provider\", new NameTransferDefinitionParser(\"providers\"));\n        registerBeanDefinitionParser(\"custom-encryption-strategy\", new NameTransferDefinitionParser(\"encryptionStrategies\").addAlias(\"strategy\", \"encryptionStrategy\"));\n        registerBeanDefinitionParser(\"password-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", PasswordBasedEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"secret-key-encryption-strategy\", new ChildDefinitionParser(\"encryptionStrategy\", SecretKeyEncryptionStrategy.class));\n        registerBeanDefinitionParser(\"encryption-security-filter\", new ChildDefinitionParser(\"securityFilter\", MuleEncryptionEndpointSecurityFilter.class));\n    }","commit_id":"41beee3b30c40b569d2fe77ff04a9c0f794321cd","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerMuleDefinitionParser(\"orphan\", new OrphanDefinitionParser(OrphanBean.class, true)).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\");\n        registerMuleDefinitionParser(\"child\", new ChildDefinitionParser(\"child\", ChildBean.class)).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\");\n        registerDelegateDefinitionParser(\"mapped-child\", new MapDefinitionParserMutator(\"map\", new ChildDefinitionParser(\"child\", ChildBean.class))).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\");\n        registerMuleDefinitionParser(\"kid\", new ChildDefinitionParser(\"kid\", ChildBean.class)).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\");\n        registerMuleDefinitionParser(\"parent\", new ParentDefinitionParser()).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\");\n        registerMuleDefinitionParser(\"orphan1\", new NamedDefinitionParser(\"orphan1\")).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\");\n        registerMuleDefinitionParser(\"orphan2\", new NamedDefinitionParser(\"orphan2\")).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\");\n        registerBeanDefinitionParser(\"map-entry\", new ChildMapEntryDefinitionParser(\"map\", \"key\", \"value\"));\n        registerBeanDefinitionParser(\"list-entry\", new ChildListEntryDefinitionParser(\"list\"));\n        registerMuleDefinitionParser(\"named\", new NamedDefinitionParser()).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\");\n        registerDelegateDefinitionParser(\"inherit\", new InheritDefinitionParser(\n                new OrphanDefinitionParser(OrphanBean.class, true),\n                new NamedDefinitionParser())).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\");\n\n        registerBeanDefinitionParser(\"string-endpoint\", new StringAddressEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"unaddressed-endpoint\", new UnaddressedEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerMuleDefinitionParser(\"address\", new ChildAddressDefinitionParser(\"test\")).addAlias(\"address\", \"host\");\n        registerBeanDefinitionParser(\"addressed-endpoint\", new AddressedEndpointDefinitionParser(\"test\", AddressedEndpointDefinitionParser.PROTOCOL, new UnaddressedEndpointDefinitionParser(EndpointURIEndpointBuilder.class), new String[]{}, new String[]{\"path\"}));\n        registerBeanDefinitionParser(\"orphan-endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"child-endpoint\", new ChildEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"unaddressed-orphan-endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"addressed-orphan-endpoint\", new AddressedEndpointDefinitionParser(\"test\", AddressedEndpointDefinitionParser.PROTOCOL, new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class), new String[]{}, new String[]{\"path\"}));\n        registerBeanDefinitionParser(\"addressed-child-endpoint\", new TransportEndpointDefinitionParser(\"test\", InboundEndpointFactoryBean.class, new String[]{}));\n\n        registerBeanDefinitionParser(\"list-element-test-1\", new AttributeListEntryDefinitionParser(\"kids\", \"listAttribute\"));\n        registerBeanDefinitionParser(\"list-element-test-2\",\n                new SingleParentFamilyDefinitionParser(\n                        new OrphanDefinitionParser(OrphanBean.class, true))\n                        .addChildDelegate(\"kid1\", new AttributeListEntryDefinitionParser(\"kids\", \"kid1\"))\n                        .addChildDelegate(\"kid2\", new AttributeListEntryDefinitionParser(\"kids\", \"kid2\")));\n        registerBeanDefinitionParser(\"list-element-test-3\", new AllAttributeChildDefinitionParser(new AttributeListEntryDefinitionParser(\"kids\")));\n\n        registerBeanDefinitionParser(\"factory\",\n                new ComplexComponentDefinitionParser(\n                        new SimplePojoServiceDefinitionParser(ChildBean.class, \"object\"),\n                        (ChildDefinitionParser) new ChildDefinitionParser(\"child\", ChildBean.class).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\")));\n\n        registerDelegateDefinitionParser(\"complex-endpoint\",\n                new TransportGlobalEndpointDefinitionParser(\n                        \"test\", TransportGlobalEndpointDefinitionParser.PROTOCOL,\n                        new String[]{\"string\", \"bar\"}, new String[]{\"path\"})).addAlias(\"bar\", \"foo\");\n    }","id":90827,"modified_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"orphan\", new OrphanDefinitionParser(OrphanBean.class, true).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\"));\n        registerBeanDefinitionParser(\"child\", new ChildDefinitionParser(\"child\", ChildBean.class).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\"));\n        registerBeanDefinitionParser(\"mapped-child\", new MapDefinitionParserMutator(\"map\", new ChildDefinitionParser(\"child\", ChildBean.class)).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\"));\n        registerBeanDefinitionParser(\"kid\", new ChildDefinitionParser(\"kid\", ChildBean.class).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\"));\n        registerBeanDefinitionParser(\"parent\", new ParentDefinitionParser().addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\"));\n        registerBeanDefinitionParser(\"orphan1\", new NamedDefinitionParser(\"orphan1\").addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\"));\n        registerBeanDefinitionParser(\"orphan2\", new NamedDefinitionParser(\"orphan2\").addAlias(\"bar\", \"foo\").addIgnored(\"ignored\"));\n        registerBeanDefinitionParser(\"map-entry\", new ChildMapEntryDefinitionParser(\"map\", \"key\", \"value\"));\n        registerBeanDefinitionParser(\"list-entry\", new ChildListEntryDefinitionParser(\"list\"));\n        registerBeanDefinitionParser(\"named\", new NamedDefinitionParser().addAlias(\"bar\", \"foo\").addIgnored(\"ignored\"));\n        registerBeanDefinitionParser(\"inherit\", new InheritDefinitionParser(\n                new OrphanDefinitionParser(OrphanBean.class, true),\n                new NamedDefinitionParser()).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\"));\n\n        registerBeanDefinitionParser(\"string-endpoint\", new StringAddressEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"unaddressed-endpoint\", new UnaddressedEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"address\", new ChildAddressDefinitionParser(\"test\").addAlias(\"address\", \"host\"));\n        registerBeanDefinitionParser(\"addressed-endpoint\", new AddressedEndpointDefinitionParser(\"test\", AddressedEndpointDefinitionParser.PROTOCOL, new UnaddressedEndpointDefinitionParser(EndpointURIEndpointBuilder.class), new String[]{}, new String[]{\"path\"}));\n        registerBeanDefinitionParser(\"orphan-endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"child-endpoint\", new ChildEndpointDefinitionParser(InboundEndpointFactoryBean.class));\n        registerBeanDefinitionParser(\"unaddressed-orphan-endpoint\", new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class));\n        registerBeanDefinitionParser(\"addressed-orphan-endpoint\", new AddressedEndpointDefinitionParser(\"test\", AddressedEndpointDefinitionParser.PROTOCOL, new OrphanEndpointDefinitionParser(EndpointURIEndpointBuilder.class), new String[]{}, new String[]{\"path\"}));\n        registerBeanDefinitionParser(\"addressed-child-endpoint\", new TransportEndpointDefinitionParser(\"test\", InboundEndpointFactoryBean.class, new String[]{}));\n\n        registerBeanDefinitionParser(\"list-element-test-1\", new AttributeListEntryDefinitionParser(\"kids\", \"listAttribute\"));\n        registerBeanDefinitionParser(\"list-element-test-2\",\n                new SingleParentFamilyDefinitionParser(\n                        new OrphanDefinitionParser(OrphanBean.class, true))\n                        .addChildDelegate(\"kid1\", new AttributeListEntryDefinitionParser(\"kids\", \"kid1\"))\n                        .addChildDelegate(\"kid2\", new AttributeListEntryDefinitionParser(\"kids\", \"kid2\")));\n        registerBeanDefinitionParser(\"list-element-test-3\", new AllAttributeChildDefinitionParser(new AttributeListEntryDefinitionParser(\"kids\")));\n\n        registerBeanDefinitionParser(\"factory\",\n                new ComplexComponentDefinitionParser(\n                        new SimplePojoServiceDefinitionParser(ChildBean.class, \"object\"),\n                        (ChildDefinitionParser) new ChildDefinitionParser(\"child\", ChildBean.class).addAlias(\"bar\", \"foo\").addIgnored(\"ignored\").addCollection(\"offspring\")));\n\n        registerBeanDefinitionParser(\"complex-endpoint\",\n                new TransportGlobalEndpointDefinitionParser(\n                        \"test\", TransportGlobalEndpointDefinitionParser.PROTOCOL,\n                        new String[]{\"string\", \"bar\"}, new String[]{\"path\"}).addAlias(\"bar\", \"foo\"));\n    }","commit_id":"41beee3b30c40b569d2fe77ff04a9c0f794321cd","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"model\", new OrphanDefinitionParser(DirectModel.class, true));\n        registerBeanDefinitionParser(\"service\", new ComponentDefinitionParser(DirectComponent.class));\n    }","id":90828,"modified_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"model\", new OrphanDefinitionParser(DirectModel.class, true));\n        registerBeanDefinitionParser(\"service\", new ServiceDefinitionParser(DirectComponent.class));\n    }","commit_id":"41beee3b30c40b569d2fe77ff04a9c0f794321cd","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerMuleDefinitionParser(\"security-filter\", new ChildDefinitionParser(\"securityFilter\", WsSecurityFilter.class)).addAlias(\"decryptionFile\", \"wsDecryptionFile\").addAlias(\"signatureFile\", \"wsSignatureFile\");\n        registerBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"addOutboundProperties\", \"key\", \"value\"));\n    }","id":90829,"modified_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"security-filter\", new ChildDefinitionParser(\"securityFilter\", WsSecurityFilter.class).addAlias(\"decryptionFile\", \"wsDecryptionFile\").addAlias(\"signatureFile\", \"wsSignatureFile\"));\n        registerBeanDefinitionParser(\"property\", new ChildMapEntryDefinitionParser(\"addOutboundProperties\", \"key\", \"value\"));\n    }","commit_id":"41beee3b30c40b569d2fe77ff04a9c0f794321cd","url":"https://github.com/mulesoft/mule"},{"original_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"jxpath-filter\", new ChildDefinitionParser(\"filter\", JXPathFilter.class));\n        registerBeanDefinitionParser(\"is-xml-filter\", new ChildDefinitionParser(\"filter\", IsXmlFilter.class));\n        registerBeanDefinitionParser(\"message-splitter\", new RouterDefinitionParser(\"router\", FilteringXmlMessageSplitter.class));\n        registerMuleDefinitionParser(\"round-robin-splitter\", new RouterDefinitionParser(\"router\", RoundRobinXmlSplitter.class)).addAlias(\"endpointFiltering\", \"enableEndpointFiltering\");\n        registerBeanDefinitionParser(\"dom-to-xml\", new MuleOrphanDefinitionParser(DomDocumentToXml.class, false));\n        registerBeanDefinitionParser(\"dom-to-output-handler\", new MuleOrphanDefinitionParser(DocumentToOutputHandler.class, false));\n        registerBeanDefinitionParser(\"jxpath-extractor\", new MuleOrphanDefinitionParser(JXPathExtractor.class, false));\n        registerBeanDefinitionParser(\"object-to-xml\", new MuleOrphanDefinitionParser(ObjectToXml.class, false));\n        registerBeanDefinitionParser(\"xml-to-dom\", new MuleOrphanDefinitionParser(XmlToDomDocument.class, false));\n        registerBeanDefinitionParser(\"xml-to-object\", new MuleOrphanDefinitionParser(XmlToObject.class, false));\n        registerBeanDefinitionParser(\"xslt-transformer\", new XsltTransformerDefinitionParser());\n        registerBeanDefinitionParser(\"jxpath-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", JXPathPropertyExtractor.class));\n        registerBeanDefinitionParser(\"xpath-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", XPathPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"bean-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", BeanPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"namespace\", new ChildMapEntryDefinitionParser(\"namespaces\", \"prefix\", \"uri\"));\n        registerBeanDefinitionParser(\"context-property\", new ChildMapEntryDefinitionParser(\"contextProperties\", \"key\", \"value\"));\n    }","id":90830,"modified_method":"public void init()\n    {\n        registerBeanDefinitionParser(\"jxpath-filter\", new ChildDefinitionParser(\"filter\", JXPathFilter.class));\n        registerBeanDefinitionParser(\"is-xml-filter\", new ChildDefinitionParser(\"filter\", IsXmlFilter.class));\n        registerBeanDefinitionParser(\"message-splitter\", new RouterDefinitionParser(\"router\", FilteringXmlMessageSplitter.class));\n        registerBeanDefinitionParser(\"round-robin-splitter\", new RouterDefinitionParser(\"router\", RoundRobinXmlSplitter.class).addAlias(\"endpointFiltering\", \"enableEndpointFiltering\"));\n        registerBeanDefinitionParser(\"dom-to-xml\", new MuleOrphanDefinitionParser(DomDocumentToXml.class, false));\n        registerBeanDefinitionParser(\"dom-to-output-handler\", new MuleOrphanDefinitionParser(DocumentToOutputHandler.class, false));\n        registerBeanDefinitionParser(\"jxpath-extractor\", new MuleOrphanDefinitionParser(JXPathExtractor.class, false));\n        registerBeanDefinitionParser(\"object-to-xml\", new MuleOrphanDefinitionParser(ObjectToXml.class, false));\n        registerBeanDefinitionParser(\"xml-to-dom\", new MuleOrphanDefinitionParser(XmlToDomDocument.class, false));\n        registerBeanDefinitionParser(\"xml-to-object\", new MuleOrphanDefinitionParser(XmlToObject.class, false));\n        registerBeanDefinitionParser(\"xslt-transformer\", new XsltTransformerDefinitionParser());\n        registerBeanDefinitionParser(\"jxpath-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", JXPathPropertyExtractor.class));\n        registerBeanDefinitionParser(\"xpath-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", XPathPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"bean-property-extractor\", new ChildDefinitionParser(\"propertyExtractor\", BeanPayloadPropertyExtractor.class));\n        registerBeanDefinitionParser(\"namespace\", new ChildMapEntryDefinitionParser(\"namespaces\", \"prefix\", \"uri\"));\n        registerBeanDefinitionParser(\"context-property\", new ChildMapEntryDefinitionParser(\"contextProperties\", \"key\", \"value\"));\n    }","commit_id":"41beee3b30c40b569d2fe77ff04a9c0f794321cd","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void goToNeighbour(boolean next) {\n    goTo(getNeighbourId(next));\n  }","id":90831,"modified_method":"protected abstract void goToNeighbour(boolean next);","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean hasNeighbour(boolean next) {\n    return getNeighbourId(next) != null;\n  }","id":90832,"modified_method":"protected abstract boolean hasNeighbour(boolean next);","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"void rootsDialogClosed() {\n    myRootsDialogInvoked = false;\n  }","id":90833,"modified_method":"void rootsDialogClosed() {\n    myMergeRootsDialog = null;\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void invokeMergeRoots(final SNodeId rootId) {\n    if (rootId == null) {\n      invokeMergeMetadata();\n      return;\n    }\n    if (myRootsDialogInvoked) {\n      return;\n    }\n    myRootsDialogInvoked = true;\n    final Wrappers._T<MergeRootsDialog> mergeRootsDialog = new Wrappers._T<MergeRootsDialog>();\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        mergeRootsDialog.value = new MergeRootsDialog(MergeModelsDialog.this, myMergeSession, rootId, myMergeTree.getNameForRoot(rootId));\n      }\n    });\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        mergeRootsDialog.value.toFront();\n      }\n    });\n    mergeRootsDialog.value.show();\n  }","id":90834,"modified_method":"public void invokeMergeRoots(@Nullable final SNodeId rootId) {\n    if (rootId == null) {\n      invokeMergeMetadata();\n      return;\n    }\n    if (myMergeRootsDialog != null) {\n      return;\n    }\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        myRootId = rootId;\n        myMergeRootsDialog = new MergeRootsDialog(myProject, myMergeSession, rootId, myMergeTree.getNameForRoot(rootId), getContentTitles(), getWindow(), new MergeModelsDialog.MyGoToNeighbourRootActions().getActions());\n      }\n    });\n    SwingUtilities.invokeLater(new Runnable() {\n      public void run() {\n        myMergeRootsDialog.toFront();\n      }\n    });\n    boolean isOk = myMergeRootsDialog.showAndGet();\n    if (!(isOk)) {\n      ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n        public void run() {\n          restoreState(myMergeRootsDialog.getStateToRestore());\n        }\n      });\n    }\n    if (myMetadataMergeSession != null && isOk) {\n\n    }\n    myMergeRootsDialog = null;\n    rebuildLater();\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static IModule check_3qqb0l_a0b0s(SModelDescriptor checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getModule();\n    }\n    return null;\n  }","id":90835,"modified_method":"private static IModule check_3qqb0l_a0b0v(SModelDescriptor checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getModule();\n    }\n    return null;\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void unregisterResultModel() {\n    final SModel resultModel = myMergeSession.getResultModel();\n    assert check_3qqb0l_a0b0s(check_3qqb0l_a0a1a81(resultModel)) instanceof DiffTemporaryModule;\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        DiffTemporaryModule.unregisterModel(resultModel, ProjectHelper.toMPSProject(myProject));\n      }\n    });\n  }","id":90836,"modified_method":"public void unregisterResultModel() {\n    final SModel resultModel = myMergeSession.getResultModel();\n    assert check_3qqb0l_a0b0v(check_3qqb0l_a0a1a12(resultModel)) instanceof DiffTemporaryModule;\n    ModelAccess.instance().runWriteAction(new Runnable() {\n      public void run() {\n        DiffTemporaryModule.unregisterModel(resultModel, ProjectHelper.toMPSProject(myProject));\n      }\n    });\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static SModelDescriptor check_3qqb0l_a0a1a81(SModel checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getModelDescriptor();\n    }\n    return null;\n  }","id":90837,"modified_method":"private static SModelDescriptor check_3qqb0l_a0a1a12(SModel checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getModelDescriptor();\n    }\n    return null;\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"private ChangeGroupLayout createChangeGroupLayout(boolean mine, boolean inspector) {\n    return new DiffChangeGroupLayout(myConflictChecker, (mine ?\n      myMergeSession.getMyChangeSet() :\n      myMergeSession.getRepositoryChangeSet()\n    ), (mine ?\n      myMineEditor :\n      myResultEditor\n    ), (mine ?\n      myResultEditor :\n      myRepositoryEditor\n    ), inspector);\n  }","id":90838,"modified_method":"private ChangeGroupLayout createChangeGroupLayout(boolean mine, boolean inspector) {\n    DiffChangeGroupLayout layout = new DiffChangeGroupLayout(myConflictChecker, (mine ?\n      myMergeSession.getMyChangeSet() :\n      myMergeSession.getRepositoryChangeSet()\n    ), (mine ?\n      myMineEditor :\n      myResultEditor\n    ), (mine ?\n      myResultEditor :\n      myRepositoryEditor\n    ), inspector);\n    MapSequence.fromMap(myDiffLayoutPart).put(layout, mine);\n    return layout;\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void resetState() {\n    Project project = ProjectHelper.toMPSProject(myModelsDialog.getProject());\n    Runnable r = new Runnable() {\n      public void run() {\n        myModelsDialog.restoreState(myStateToRestore);\n      }\n    };\n    if (project != null) {\n      ModelAccess.instance().runCommandInEDT(r, project);\n    } else {\n      ModelAccess.instance().runWriteActionInCommand(r);\n    }\n  }","id":90839,"modified_method":"public MergeSessionState getStateToRestore() {\n    return myStateToRestore;\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"private DiffEditor addEditor(int index, SModel model) {\n    SNodeId rootId = getRootNodeId(model);\n    SNode root = (rootId == null ?\n      null :\n      model.getNodeById(rootId)\n    );\n    final DiffEditor result = new DiffEditor(DiffTemporaryModule.getOperationContext(myModelsDialog.getProject(), model), root, myModelsDialog.getContentTitles()[index], index == 0);\n\n    GridBagConstraints gbc = new GridBagConstraints(index * 2, 0, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(5, (index == 0 ?\n      5 :\n      0\n    ), 5, (index == 2 ?\n      5 :\n      0\n    )), 0, 0);\n    myTopPanel.add(result.getTopComponent(), gbc);\n    myBottomPanel.add(result.getInspector().getExternalComponent(), gbc);\n\n    myDiffEditorsGroup.add(result);\n    return result;\n  }","id":90840,"modified_method":"private DiffEditor addEditor(int index, SModel model) {\n    SNodeId rootId = getRootNodeId(model);\n    SNode root = (rootId == null ?\n      null :\n      model.getNodeById(rootId)\n    );\n    final DiffEditor result = new DiffEditor(DiffTemporaryModule.getOperationContext(myProject, model), root, myTitles[index], index == 0);\n\n    GridBagConstraints gbc = new GridBagConstraints(index * 2, 0, 1, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, new Insets(5, (index == 0 ?\n      5 :\n      0\n    ), 5, (index == 2 ?\n      5 :\n      0\n    )), 0, 0);\n    myTopPanel.add(result.getTopComponent(), gbc);\n    myBottomPanel.add(result.getInspector().getExternalComponent(), gbc);\n\n    myDiffEditorsGroup.add(result);\n    return result;\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void rehighlight() {\n    if (myDisposed) {\n      return;\n    }\n    myMineEditor.unhighlightAllChanges();\n    myResultEditor.unhighlightAllChanges();\n    myRepositoryEditor.unhighlightAllChanges();\n\n    if (myResultEditor.getEditedNode() == null) {\n      SModel resultModel = myMergeSession.getResultModel();\n      SNodeId nodeId = getRootNodeId(resultModel);\n      if (nodeId != null) {\n        myResultEditor.editRoot(myModelsDialog.getProject(), nodeId, resultModel);\n      }\n    }\n\n    myResultEditor.getMainEditor().rebuildEditorContent();\n\n    highlightAllChanges();\n  }","id":90841,"modified_method":"public void rehighlight() {\n    if (myDisposed) {\n      return;\n    }\n    myMineEditor.unhighlightAllChanges();\n    myResultEditor.unhighlightAllChanges();\n    myRepositoryEditor.unhighlightAllChanges();\n\n    if (myResultEditor.getEditedNode() == null) {\n      SModel resultModel = myMergeSession.getResultModel();\n      SNodeId nodeId = getRootNodeId(resultModel);\n      if (nodeId != null) {\n        myResultEditor.editRoot(myProject, nodeId, resultModel);\n      }\n    }\n\n    myResultEditor.getMainEditor().rebuildEditorContent();\n\n    highlightAllChanges();\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void dispose() {\n    synchronized (this) {\n      if (myDisposed) {\n        return;\n      }\n      if (myStateToRestore == null) {\n        myModelsDialog.rebuildLater();\n      } else {\n        resetState();\n      }\n      myActionGroup.removeAll();\n      myModelsDialog.rootsDialogClosed();\n      if (myMineEditor != null) {\n        myMineEditor.dispose();\n      }\n      myMineEditor = null;\n      if (myResultEditor != null) {\n        myResultEditor.dispose();\n      }\n      myResultEditor = null;\n      if (myRepositoryEditor != null) {\n        myRepositoryEditor.dispose();\n      }\n      myRepositoryEditor = null;\n      ListSequence.fromList(myEdtiorSeparators).visitAll(new IVisitor<DiffEditorSeparator>() {\n        public void visit(DiffEditorSeparator s) {\n          s.dispose();\n        }\n      });\n      ListSequence.fromList(myEdtiorSeparators).clear();\n      myDisposed = true;\n    }\n    super.dispose();\n  }","id":90842,"modified_method":"@Override\n  public void dispose() {\n    synchronized (this) {\n      if (myDisposed) {\n        return;\n      }\n      if (myActionGroup != null) {\n        myActionGroup.removeAll();\n      }\n      myActionGroup = null;\n      if (myMineEditor != null) {\n        myMineEditor.dispose();\n      }\n      myMineEditor = null;\n      if (myResultEditor != null) {\n        myResultEditor.dispose();\n      }\n      myResultEditor = null;\n      if (myRepositoryEditor != null) {\n        myRepositoryEditor.dispose();\n      }\n      myRepositoryEditor = null;\n      ListSequence.fromList(myEdtiorSeparators).visitAll(new IVisitor<DiffEditorSeparator>() {\n        public void visit(DiffEditorSeparator s) {\n          s.dispose();\n        }\n      });\n      ListSequence.fromList(myEdtiorSeparators).clear();\n      myDisposed = true;\n    }\n    super.dispose();\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MergeRootsDialog(MergeModelsDialog mergeModelsDialog, MergeSession mergeSession, SNodeId rootId, String rootName) {\n    super(mergeModelsDialog.getWindow(), true);\n    setTitle(\"Merging \" + rootName);\n    myConflictChecker = new ChangeEditorMessage.ConflictChecker() {\n      public boolean isChangeConflicted(ModelChange ch) {\n        return Sequence.fromIterable(myMergeSession.getConflictedWith(ch)).isNotEmpty();\n      }\n    };\n    myModelsDialog = mergeModelsDialog;\n    myMergeSession = mergeSession;\n    myRootId = rootId;\n    myStateToRestore = myMergeSession.getCurrentState();\n\n    myMineEditor = addEditor(0, myMergeSession.getMyModel());\n    myResultEditor = addEditor(1, myMergeSession.getResultModel());\n    myRepositoryEditor = addEditor(2, myMergeSession.getRepositoryModel());\n\n    linkEditors(true, false);\n    linkEditors(false, false);\n    linkEditors(true, true);\n    linkEditors(false, true);\n\n    myMergeSession.setChangesInvalidateHandler(new MergeSession.ChangesInvalidateHandler() {\n      public void someChangesInvalidated() {\n        ModelAccess.instance().runWriteInEDT(new Runnable() {\n          public void run() {\n            rehighlight();\n          }\n        });\n      }\n    });\n\n    JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, myTopPanel, myBottomPanel);\n    splitPane.setResizeWeight(0.7);\n    MergeRootsDialog.MyGoToNeighbourRootActions neighbourActions = new MergeRootsDialog.MyGoToNeighbourRootActions();\n    NextPreviousTraverser neighbourTraverser = new NextPreviousTraverser(myChangeGroupLayouts, myResultEditor.getMainEditor());\n    myActionGroup = ActionUtils.groupFromActions(new ApplyNonConflictsForRoot(this), Separator.getInstance(), neighbourActions.previous(), neighbourActions.next(), Separator.getInstance(), neighbourTraverser.previousAction(), neighbourTraverser.nextAction());\n    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, myActionGroup, true);\n    neighbourTraverser.setActionToolbar(toolbar);\n\n    myContainer.add(toolbar.getComponent(), BorderLayout.NORTH);\n    myContainer.add(splitPane, BorderLayout.CENTER);\n    myContainer.add(this.myStatusBar, BorderLayout.SOUTH);\n    highlightAllChanges();\n\n    neighbourTraverser.goToFirstChangeLater();\n    DisplayMode displayMode = check_3816sg_a0hb0r(check_3816sg_a0a33a71(GraphicsEnvironment.getLocalGraphicsEnvironment()));\n    int width = (displayMode == null ?\n      800 :\n      displayMode.getWidth() - 100\n    );\n    int height = (displayMode == null ?\n      600 :\n      displayMode.getHeight() - 100\n    );\n    final Dimension size = DimensionService.getInstance().getSize(getDimensionServiceKey());\n    if (size == null) {\n      myContainer.setPreferredSize(new Dimension(width, height));\n    }\n\n    final Point location = DimensionService.getInstance().getLocation(getDimensionServiceKey());\n    if (location == null) {\n      setLocation(50, 50);\n    }\n    init();\n\n  }","id":90843,"modified_method":"public MergeRootsDialog(Project project, MergeSession mergeSession, SNodeId rootId, String rootName, String[] titles, Component parent, @Nullable BaseAction[] actions) {\n    super(parent, true);\n    setTitle(\"Merging \" + rootName);\n    myConflictChecker = new ChangeEditorMessage.ConflictChecker() {\n      public boolean isChangeConflicted(ModelChange ch) {\n        return Sequence.fromIterable(myMergeSession.getConflictedWith(ch)).isNotEmpty();\n      }\n    };\n    myProject = project;\n    myTitles = titles;\n    myMergeSession = mergeSession;\n    myRootId = rootId;\n    myStateToRestore = myMergeSession.getCurrentState();\n\n    myMineEditor = addEditor(0, myMergeSession.getMyModel());\n    myResultEditor = addEditor(1, myMergeSession.getResultModel());\n    myRepositoryEditor = addEditor(2, myMergeSession.getRepositoryModel());\n\n    linkEditors(true, false);\n    linkEditors(false, false);\n    linkEditors(true, true);\n    linkEditors(false, true);\n\n    myMergeSession.setChangesInvalidateHandler(new MergeSession.ChangesInvalidateHandler() {\n      public void someChangesInvalidated() {\n        ModelAccess.instance().runWriteInEDT(new Runnable() {\n          public void run() {\n            rehighlight();\n          }\n        });\n      }\n    });\n\n    JSplitPane splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, myTopPanel, myBottomPanel);\n    splitPane.setResizeWeight(0.7);\n    myTraverser = new NextPreviousTraverser(myChangeGroupLayouts, myResultEditor.getMainEditor());\n    myActionGroup = new DefaultActionGroup();\n    myActionGroup.add(new ApplyNonConflictsForRoot(this));\n    myActionGroup.addSeparator();\n    myActionGroup.addAll(myTraverser.previousAction(), myTraverser.nextAction());\n    if (actions != null) {\n      myActionGroup.addSeparator();\n      myActionGroup.addAll(actions);\n    }\n\n    ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, myActionGroup, true);\n    myTraverser.setActionToolbar(toolbar);\n\n    myContainer.add(toolbar.getComponent(), BorderLayout.NORTH);\n    myContainer.add(splitPane, BorderLayout.CENTER);\n    myContainer.add(this.myStatusBar, BorderLayout.SOUTH);\n    highlightAllChanges();\n\n    myTraverser.goToFirstChangeLater();\n    DisplayMode displayMode = check_3816sg_a0mb0u(check_3816sg_a0a83a02(GraphicsEnvironment.getLocalGraphicsEnvironment()));\n    int width = (displayMode == null ?\n      800 :\n      displayMode.getWidth() - 100\n    );\n    int height = (displayMode == null ?\n      600 :\n      displayMode.getHeight() - 100\n    );\n    final Dimension size = DimensionService.getInstance().getSize(getDimensionServiceKey());\n    if (size == null) {\n      myContainer.setPreferredSize(new Dimension(width, height));\n    }\n\n    final Point location = DimensionService.getInstance().getLocation(getDimensionServiceKey());\n    if (location == null) {\n      setLocation(50, 50);\n    }\n    init();\n\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static DisplayMode check_3816sg_a0hb0r(GraphicsDevice checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getDisplayMode();\n    }\n    return null;\n  }","id":90844,"modified_method":"private static DisplayMode check_3816sg_a0mb0u(GraphicsDevice checkedDotOperand) {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getDisplayMode();\n    }\n    return null;\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void saveAndClose() {\n    myStateToRestore = null;\n    close(DialogWrapper.OK_EXIT_CODE);\n  }","id":90845,"modified_method":"public void saveAndClose() {\n    close(DialogWrapper.OK_EXIT_CODE);\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static GraphicsDevice check_3816sg_a0a33a71(GraphicsEnvironment checkedDotOperand) throws HeadlessException {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getDefaultScreenDevice();\n    }\n    return null;\n  }","id":90846,"modified_method":"private static GraphicsDevice check_3816sg_a0a83a02(GraphicsEnvironment checkedDotOperand) throws HeadlessException {\n    if (null != checkedDotOperand) {\n      return checkedDotOperand.getDefaultScreenDevice();\n    }\n    return null;\n  }","commit_id":"d966f9fe06ab2a6deb3de23c067c833a55115930","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void setInfo( DatabaseMeta meta ) {\n\n    if ( meta == null ) {\n      return;\n    }\n\n    getControls();\n\n    // Name:\n    connectionNameBox.setValue( meta.getDisplayName() );\n\n    PluginRegistry registry = PluginRegistry.getInstance();\n    PluginInterface dInterface = registry.getPlugin( DatabasePluginType.class, meta.getPluginId() );\n\n    // Connection type:\n    int index = new ArrayList<String>( connectionMap.keySet() ).indexOf( dInterface.getName() );\n    if ( index >= 0 ) {\n      connectionBox.setSelectedIndex( index );\n    } else {\n      LogChannel.GENERAL.logError( \"Unable to find database type \"\n        + dInterface.getName() + \" in our connection map\" );\n    }\n\n    // Access type:\n    accessBox.setSelectedItem( DatabaseMeta.getAccessTypeDescLong( meta.getAccessType() ) );\n\n    // this is broken out so we can set the cache information only when caching\n    // connection values\n    setConnectionSpecificInfo( meta );\n    loadAccessData();\n\n    // Port number:\n    if ( portNumberBox != null ) {\n      portNumberBox.setValue( meta.getDatabasePortNumberString() );\n    }\n\n    // Options Parameters:\n\n    setOptionsData( meta.getExtraOptions() );\n\n    // Advanced panel settings:\n\n    if ( supportBooleanDataType != null ) {\n      supportBooleanDataType.setChecked( meta.supportsBooleanDataType() );\n    }\n\n    if ( supportTimestampDataType != null ) {\n      supportTimestampDataType.setChecked( meta.supportsTimestampDataType() );\n    }\n\n    if ( quoteIdentifiersCheck != null ) {\n      quoteIdentifiersCheck.setChecked( meta.isQuoteAllFields() );\n    }\n\n    if ( lowerCaseIdentifiersCheck != null ) {\n      lowerCaseIdentifiersCheck.setChecked( meta.isForcingIdentifiersToLowerCase() );\n    }\n\n    if ( upperCaseIdentifiersCheck != null ) {\n      upperCaseIdentifiersCheck.setChecked( meta.isForcingIdentifiersToUpperCase() );\n    }\n\n    if ( preserveReservedCaseCheck != null ) {\n      preserveReservedCaseCheck.setChecked( meta.preserveReservedCase() );\n    }\n\n    if ( preferredSchemaName != null ) {\n      preferredSchemaName.setValue( Const.NVL( meta.getPreferredSchemaName(), \"\" ) );\n    }\n\n    if ( sqlBox != null ) {\n      sqlBox.setValue( meta.getConnectSQL() == null ? \"\" : meta.getConnectSQL() );\n    }\n\n    // Clustering panel settings\n\n    if ( clusteringCheck != null ) {\n      clusteringCheck.setChecked( meta.isPartitioned() );\n    }\n\n    setClusterData( meta.getPartitioningInformation() );\n\n    // Pooling panel settings\n\n    if ( poolingCheck != null ) {\n      poolingCheck.setChecked( meta.isUsingConnectionPool() );\n    }\n\n    if ( meta.isUsingConnectionPool() ) {\n      if ( poolSizeBox != null ) {\n        poolSizeBox.setValue( Integer.toString( meta.getInitialPoolSize() ) );\n      }\n\n      if ( maxPoolSizeBox != null ) {\n        maxPoolSizeBox.setValue( Integer.toString( meta.getMaximumPoolSize() ) );\n      }\n\n      setPoolProperties( meta.getConnectionPoolingProperties() );\n    }\n\n    setReadOnly( meta.isReadOnly() );\n\n    setDeckChildIndex();\n    onPoolingCheck();\n    onClusterCheck();\n  }","id":90847,"modified_method":"private void setInfo( DatabaseMeta meta ) {\n\n    if ( meta == null ) {\n      return;\n    }\n\n    getControls();\n\n    // Name:\n    if ( connectionNameBox != null ) {\n      connectionNameBox.setValue( meta.getDisplayName() );\n    }\n\n    PluginRegistry registry = PluginRegistry.getInstance();\n    PluginInterface dInterface = registry.getPlugin( DatabasePluginType.class, meta.getPluginId() );\n\n    // Connection type:\n    int index = ( dInterface == null ? -1 : new ArrayList<>( connectionMap.keySet() ).indexOf( dInterface.getName() ) );\n    if ( index >= 0 ) {\n      connectionBox.setSelectedIndex( index );\n    } else {\n      LogChannel.GENERAL.logError( \"Unable to find database type \"\n        + ( dInterface == null ? \"null\" : dInterface.getName() ) + \" in our connection map\" );\n    }\n\n    // Access type:\n    accessBox.setSelectedItem( DatabaseMeta.getAccessTypeDescLong( meta.getAccessType() ) );\n\n    // this is broken out so we can set the cache information only when caching\n    // connection values\n    setConnectionSpecificInfo( meta );\n    loadAccessData();\n\n    // Port number:\n    if ( portNumberBox != null ) {\n      portNumberBox.setValue( meta.getDatabasePortNumberString() );\n    }\n\n    // Options Parameters:\n\n    setOptionsData( meta.getExtraOptions() );\n\n    // Advanced panel settings:\n\n    if ( supportBooleanDataType != null ) {\n      supportBooleanDataType.setChecked( meta.supportsBooleanDataType() );\n    }\n\n    if ( supportTimestampDataType != null ) {\n      supportTimestampDataType.setChecked( meta.supportsTimestampDataType() );\n    }\n\n    if ( quoteIdentifiersCheck != null ) {\n      quoteIdentifiersCheck.setChecked( meta.isQuoteAllFields() );\n    }\n\n    if ( lowerCaseIdentifiersCheck != null ) {\n      lowerCaseIdentifiersCheck.setChecked( meta.isForcingIdentifiersToLowerCase() );\n    }\n\n    if ( upperCaseIdentifiersCheck != null ) {\n      upperCaseIdentifiersCheck.setChecked( meta.isForcingIdentifiersToUpperCase() );\n    }\n\n    if ( preserveReservedCaseCheck != null ) {\n      preserveReservedCaseCheck.setChecked( meta.preserveReservedCase() );\n    }\n\n    if ( preferredSchemaName != null ) {\n      preferredSchemaName.setValue( Const.NVL( meta.getPreferredSchemaName(), \"\" ) );\n    }\n\n    if ( sqlBox != null ) {\n      sqlBox.setValue( meta.getConnectSQL() == null ? \"\" : meta.getConnectSQL() );\n    }\n\n    // Clustering panel settings\n\n    if ( clusteringCheck != null ) {\n      clusteringCheck.setChecked( meta.isPartitioned() );\n    }\n\n    setClusterData( meta.getPartitioningInformation() );\n\n    // Pooling panel settings\n\n    if ( poolingCheck != null ) {\n      poolingCheck.setChecked( meta.isUsingConnectionPool() );\n    }\n\n    if ( meta.isUsingConnectionPool() ) {\n      if ( poolSizeBox != null ) {\n        poolSizeBox.setValue( Integer.toString( meta.getInitialPoolSize() ) );\n      }\n\n      if ( maxPoolSizeBox != null ) {\n        maxPoolSizeBox.setValue( Integer.toString( meta.getMaximumPoolSize() ) );\n      }\n\n      setPoolProperties( meta.getConnectionPoolingProperties() );\n    }\n\n    setReadOnly( meta.isReadOnly() );\n\n    setDeckChildIndex();\n    onPoolingCheck();\n    onClusterCheck();\n  }","commit_id":"f6b72b8dabd54fa8df946e8060c2d530d7f02aa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void clearOptionsData() {\n    getControls();\n    optionsParameterTree.getRootChildren().removeAll();\n  }","id":90848,"modified_method":"public void clearOptionsData() {\n    getControls();\n    if ( optionsParameterTree != null ) {\n      optionsParameterTree.getRootChildren().removeAll();\n    }\n  }","commit_id":"f6b72b8dabd54fa8df946e8060c2d530d7f02aa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override public void pluginAdded( Object serviceObject ) {\n      PluginInterface plugin = (PluginInterface) serviceObject;\n      String pluginName = plugin.getName();\n      try {\n        DatabaseInterface databaseInterface = (DatabaseInterface) registry.loadClass( plugin );\n        databaseInterface.setPluginId( plugin.getIds()[0] );\n        databaseInterface.setName( pluginName );\n        databaseTypeAdded( pluginName, databaseInterface );\n      } catch ( KettleException e ) {\n        System.out.println( \"Could not create connection entry for \"\n          + pluginName + \".  \" + e.getCause().getClass().getName() );\n        LogChannel.GENERAL.logError( \"Could not create connection entry for \"\n          + pluginName + \".  \" + e.getCause().getClass().getName() );\n      }\n    }","id":90849,"modified_method":"@Override\n    public void pluginAdded( Object serviceObject ) {\n      PluginInterface plugin = (PluginInterface) serviceObject;\n      String pluginName = plugin.getName();\n      try {\n        DatabaseInterface databaseInterface = (DatabaseInterface) registry.loadClass( plugin );\n        databaseInterface.setPluginId( plugin.getIds()[0] );\n        databaseInterface.setName( pluginName );\n        databaseTypeAdded( pluginName, databaseInterface );\n      } catch ( KettleException e ) {\n        Throwable t = e;\n        if ( e.getCause() != null ) {\n          t = e.getCause();\n        }\n        System.out.println( \"Could not create connection entry for \"\n          + pluginName + \".  \" + t.getClass().getName() );\n        LogChannel.GENERAL.logError( \"Could not create connection entry for \"\n          + pluginName + \".  \" + t.getClass().getName() );\n      }\n    }","commit_id":"f6b72b8dabd54fa8df946e8060c2d530d7f02aa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void setReadOnly( boolean readonly ) {\n    // set the readonly status of EVERYTHING!\n    traverseDomSetReadOnly( document.getRootElement(), readonly );\n    noticeLabel.setVisible( readonly );\n\n    if ( readonly ) {\n      // now turn back on the cancel and test buttons\n      if ( cancelButton != null ) {\n        cancelButton.setDisabled( false );\n      }\n      if ( testButton != null ) {\n        testButton.setDisabled( false );\n      }\n      noticeLabel.setValue( Messages.getString( \"DatabaseDialog.label.ConnectionIsReadOnly\" ) );\n    }\n  }","id":90850,"modified_method":"private void setReadOnly( boolean readonly ) {\n    // set the readonly status of EVERYTHING!\n    traverseDomSetReadOnly( document.getRootElement(), readonly );\n    if ( noticeLabel != null ) {\n      noticeLabel.setVisible( readonly );\n    }\n\n    if ( readonly ) {\n      // now turn back on the cancel and test buttons\n      if ( cancelButton != null ) {\n        cancelButton.setDisabled( false );\n      }\n      if ( testButton != null ) {\n        testButton.setDisabled( false );\n      }\n      noticeLabel.setValue( Messages.getString( \"DatabaseDialog.label.ConnectionIsReadOnly\" ) );\n    }\n  }","commit_id":"f6b72b8dabd54fa8df946e8060c2d530d7f02aa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public void setDeckChildIndex() {\n\n    getControls();\n\n    // if pooling selected, check the parameter validity before allowing\n    // a deck panel switch...\n    int originalSelection = dialogDeck.getSelectedIndex();\n\n    boolean passed = true;\n    if ( originalSelection == 3 ) {\n      passed = checkPoolingParameters();\n    }\n\n    if ( passed ) {\n      int selected = deckOptionsBox.getSelectedIndex();\n      if ( selected < 0 ) {\n        selected = 0;\n        deckOptionsBox.setSelectedIndex( 0 );\n      }\n      dialogDeck.setSelectedIndex( selected );\n    } else {\n      dialogDeck.setSelectedIndex( originalSelection );\n      deckOptionsBox.setSelectedIndex( originalSelection );\n    }\n\n  }","id":90851,"modified_method":"public void setDeckChildIndex() {\n\n    getControls();\n\n    // if pooling selected, check the parameter validity before allowing\n    // a deck panel switch...\n    int originalSelection = ( dialogDeck == null ? -1 : dialogDeck.getSelectedIndex() );\n\n    boolean passed = true;\n    if ( originalSelection == 3 ) {\n      passed = checkPoolingParameters();\n    }\n\n    if ( passed ) {\n      int selected = deckOptionsBox.getSelectedIndex();\n      if ( selected < 0 ) {\n        selected = 0;\n        deckOptionsBox.setSelectedIndex( 0 );\n      }\n      dialogDeck.setSelectedIndex( selected );\n    } else {\n      dialogDeck.setSelectedIndex( originalSelection );\n      deckOptionsBox.setSelectedIndex( originalSelection );\n    }\n\n  }","commit_id":"f6b72b8dabd54fa8df946e8060c2d530d7f02aa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private String getFragment( DatabaseInterface database, String dbName, String extension, String defaultFragment ) {\n    String fragment;\n    if ( database.getXulOverlayFile() != null ) {\n      fragment = packagePath.concat( database.getXulOverlayFile() ).concat( extension );\n    } else {\n      fragment = packagePath.concat( dbName ).concat( extension );\n    }\n    InputStream in = getClass().getClassLoader().getResourceAsStream( fragment.toLowerCase() );\n    if ( in == null ) {\n      fragment = packagePath.concat( defaultFragment );\n    }\n    return fragment;\n  }","id":90852,"modified_method":"protected String getFragment( DatabaseInterface database, String dbName, String extension, String defaultFragment ) {\n    String fragment;\n    String ext = ( extension == null ? \"\" : extension );\n    String databaseName = ( dbName == null ? \"\" : dbName );\n    String defaultFrag = ( defaultFragment == null ? \"\" : defaultFragment );\n    if ( database.getXulOverlayFile() != null ) {\n      fragment = packagePath.concat( database.getXulOverlayFile() ).concat( ext );\n    } else {\n      fragment = packagePath.concat( databaseName ).concat( ext );\n    }\n    InputStream in = getClass().getClassLoader().getResourceAsStream( fragment.toLowerCase() );\n    if ( in == null ) {\n      fragment = packagePath.concat( defaultFrag );\n    }\n    return fragment;\n  }","commit_id":"f6b72b8dabd54fa8df946e8060c2d530d7f02aa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void showMessage( String message ) {\n    try {\n      XulMessageBox box = (XulMessageBox) document.createElement( \"messagebox\" );\n      box.setMessage( message );\n      box.open();\n    } catch ( XulException e ) {\n      System.out.println( \"Error creating messagebox \" + e.getMessage() );\n    }\n  }","id":90853,"modified_method":"protected void showMessage( String message ) {\n    try {\n      XulMessageBox box = (XulMessageBox) document.createElement( \"messagebox\" );\n      box.setMessage( message );\n      box.open();\n    } catch ( XulException e ) {\n      System.out.println( \"Error creating messagebox \" + e.getMessage() );\n    }\n  }","commit_id":"f6b72b8dabd54fa8df946e8060c2d530d7f02aa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void loadDatabaseOptionsFragment( String fragmentUri ) throws XulException {\n\n    XulComponent groupElement = document.getElementById( \"database-options-box\" );\n    XulComponent parentElement = groupElement.getParent();\n\n    XulDomContainer fragmentContainer = null;\n\n    try {\n\n      // Get new group box fragment ...\n      // This will effectively set up the SWT parent child relationship...\n\n      fragmentContainer = this.xulDomContainer.loadFragment( fragmentUri, Messages.getBundle() );\n      XulComponent newGroup = fragmentContainer.getDocumentRoot().getFirstChild();\n      parentElement.replaceChild( groupElement, newGroup );\n\n    } catch ( XulException e ) {\n      e.printStackTrace();\n      throw e;\n    }\n  }","id":90854,"modified_method":"protected void loadDatabaseOptionsFragment( String fragmentUri ) throws XulException {\n\n    XulComponent groupElement = document.getElementById( \"database-options-box\" );\n    XulComponent parentElement = groupElement.getParent();\n\n    XulDomContainer fragmentContainer;\n\n    try {\n\n      // Get new group box fragment ...\n      // This will effectively set up the SWT parent child relationship...\n\n      fragmentContainer = this.xulDomContainer.loadFragment( fragmentUri, Messages.getBundle() );\n      XulComponent newGroup = fragmentContainer.getDocumentRoot().getFirstChild();\n      parentElement.replaceChild( groupElement, newGroup );\n\n    } catch ( XulException e ) {\n      e.printStackTrace();\n      throw e;\n    }\n  }","commit_id":"f6b72b8dabd54fa8df946e8060c2d530d7f02aa9","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"void affectMethodUsages(final MethodRepr method,\n                            final Collection<DependencyContext.S> subclasses,\n                            final UsageRepr.Usage rootUsage,\n                            final Set<UsageRepr.Usage> affectedUsages,\n                            final Set<DependencyContext.S> dependents) {\n      affectedUsages.add(rootUsage);\n\n      for (DependencyContext.S p : subclasses) {\n        final Collection<DependencyContext.S> deps = myClassToClassDependency.get(p);\n\n        if (deps != null) {\n          dependents.addAll(deps);\n        }\n\n        affectedUsages\n          .add(rootUsage instanceof UsageRepr.MetaMethodUsage ? method.createMetaUsage(myContext, p) : method.createUsage(myContext, p));\n      }\n    }","id":90855,"modified_method":"void affectMethodUsages(final MethodRepr method,\n                            final Collection<DependencyContext.S> subclasses,\n                            final UsageRepr.Usage rootUsage,\n                            final Set<UsageRepr.Usage> affectedUsages,\n                            final Set<DependencyContext.S> dependents) {\n      affectedUsages.add(rootUsage);\n\n      for (DependencyContext.S p : subclasses) {\n        final Collection<DependencyContext.S> deps = myClassToClassDependency.get(p);\n\n        if (deps != null) {\n          dependents.addAll(deps);\n        }\n\n        debug(\"Affect method usage referenced of class \", p);\n\n        affectedUsages\n          .add(rootUsage instanceof UsageRepr.MetaMethodUsage ? method.createMetaUsage(myContext, p) : method.createUsage(myContext, p));\n      }\n    }","commit_id":"13f7e623f933dcb097049e57a0c5974c9e3cf38d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void affectFieldUsages(final FieldRepr field,\n                           final Collection<DependencyContext.S> subclasses,\n                           final UsageRepr.Usage rootUsage,\n                           final Set<UsageRepr.Usage> affectedUsages,\n                           final Set<DependencyContext.S> dependents) {\n      affectedUsages.add(rootUsage);\n\n      for (DependencyContext.S p : subclasses) {\n        final Collection<DependencyContext.S> deps = myClassToClassDependency.get(p);\n\n        if (deps != null) {\n          dependents.addAll(deps);\n        }\n\n        affectedUsages\n          .add(rootUsage instanceof UsageRepr.FieldAssignUsage ? field.createAssignUsage(myContext, p) : field.createUsage(myContext, p));\n      }\n    }","id":90856,"modified_method":"void affectFieldUsages(final FieldRepr field,\n                           final Collection<DependencyContext.S> subclasses,\n                           final UsageRepr.Usage rootUsage,\n                           final Set<UsageRepr.Usage> affectedUsages,\n                           final Set<DependencyContext.S> dependents) {\n      affectedUsages.add(rootUsage);\n\n      for (DependencyContext.S p : subclasses) {\n        final Collection<DependencyContext.S> deps = myClassToClassDependency.get(p);\n\n        if (deps != null) {\n          dependents.addAll(deps);\n        }\n\n        debug(\"Affect field usage referenced of class \", p);\n        affectedUsages\n          .add(rootUsage instanceof UsageRepr.FieldAssignUsage ? field.createAssignUsage(myContext, p) : field.createUsage(myContext, p));\n      }\n    }","commit_id":"13f7e623f933dcb097049e57a0c5974c9e3cf38d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean differentiate(final Mappings delta,\n                               final Collection<String> removed,\n                               final Collection<File> filesToCompile,\n                               final Collection<File> compiledFiles,\n                               final Collection<File> affectedFiles) {\n    debug(\"Begin of Differentiate:\");\n    \n    delta.compensateRemovedContent(filesToCompile);\n\n    final Util u = new Util(delta);\n    final Util self = new Util(this);\n    final Util o = new Util();\n\n    if (removed != null) {\n      for (String file : removed) {\n        final Collection<ClassRepr> classes = mySourceFileToClasses.get(myContext.get(file));\n\n        if (classes != null) {\n          for (ClassRepr c : classes) {\n            u.affectAll(c.name, affectedFiles);\n          }\n        }\n      }\n    }\n\n    for (DependencyContext.S fileName : delta.mySourceFileToClasses.keyCollection()) {\n      final Set<ClassRepr> classes = (Set<ClassRepr>)delta.mySourceFileToClasses.get(fileName);\n      final Set<ClassRepr> pastClasses = (Set<ClassRepr>)mySourceFileToClasses.get(fileName);\n      final Set<DependencyContext.S> dependants = new HashSet<DependencyContext.S>();\n\n      self.appendDependents(pastClasses, dependants);\n\n      final Set<UsageRepr.Usage> affectedUsages = new HashSet<UsageRepr.Usage>();\n      final Set<UsageRepr.AnnotationUsage> annotationQuery = new HashSet<UsageRepr.AnnotationUsage>();\n      final Map<UsageRepr.Usage, Util.UsageConstraint> usageConstraints = new HashMap<UsageRepr.Usage, Util.UsageConstraint>();\n\n      final Difference.Specifier<ClassRepr> classDiff = Difference.make(pastClasses, classes);\n\n      debug(\"Processing changed classes:\");\n      for (Pair<ClassRepr, Difference> changed : classDiff.changed()) {\n        final ClassRepr it = changed.first;\n        final ClassRepr.Diff diff = (ClassRepr.Diff)changed.second;\n\n        debug(\"Changed: \", it.name);\n\n        final int addedModifiers = diff.addedModifiers();\n        final int removedModifiers = diff.removedModifiers();\n\n        final boolean superClassChanged = (diff.base() & Difference.SUPERCLASS) > 0;\n        final boolean interfacesChanged = !diff.interfaces().unchanged();\n        final boolean signatureChanged = (diff.base() & Difference.SIGNATURE) > 0;\n\n        if (superClassChanged || interfacesChanged || signatureChanged) {\n          debug(\"Superclass changed: \" + superClassChanged);\n          debug(\"Interfaces changed: \" + interfacesChanged);\n          debug(\"Signature changed \" + signatureChanged);\n          \n          final boolean extendsChanged = superClassChanged && !diff.extendsAdded();\n          final boolean interfacesRemoved = interfacesChanged && !diff.interfaces().removed().isEmpty();\n\n          debug(\"Extends changed: \" + extendsChanged);\n          debug(\"Interfaces removed: \" + interfacesRemoved);          \n          \n          u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, extendsChanged || interfacesRemoved || signatureChanged);\n        }\n\n        if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 || (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n          debug(\"Class-to-interface or interface-to-class conversion detected, added class usage to affected usages\");\n          affectedUsages.add(it.createUsage());\n        }\n\n        if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {\n          debug(\"Annotation, retention policy = SOURCE => a switch to non-incremental mode requested\");\n          if (!incrementalDecision(it.outerClassName, it, affectedFiles)) {\n            debug(\"End of Differentiate, returning false\");            \n            return false;\n          }\n        }\n\n        if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {\n          debug(\"Introduction of 'protected' modifier detected, adding class usage + inheritance constraint to affected usages\");\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n        }\n\n        if (diff.packageLocalOn()) {\n          debug(\"Introduction of 'package local' access detected, adding class usage + package constraint to affected usages\");\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_FINAL) > 0 || (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {\n          debug(\"Introduction of 'private' or 'final' modifier(s) detected, adding class usage to affected usages\");\n          affectedUsages.add(it.createUsage());\n        }\n\n        if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0 || (addedModifiers & Opcodes.ACC_STATIC) > 0) {\n          debug(\"Introduction of 'abstract' or 'static' modifier(s) detected, adding class new usage to affected usages\");\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if (it.isAnnotation()) {\n          debug(\"Class is annotation, performing annotation-specific analysis\");\n          \n          if (diff.retentionChanged()) {\n            debug(\"Retention policy change detected, adding class usage to affected usages\");\n            affectedUsages.add(it.createUsage());\n          }\n          else {\n            final Collection<ElementType> removedtargets = diff.targets().removed();\n\n            if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {\n              debug(\"Removed target contains LOCAL_VARIABLE => a switch to non-incremental mode requested\");\n              if (!incrementalDecision(it.outerClassName, it, affectedFiles)) {\n                debug(\"End of Differentiate, returning false\");                \n                return false;\n              }\n            }\n\n            if (!removedtargets.isEmpty()) {\n              debug(\"Removed some annotation targets, adding annotation query\");\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), null, removedtargets));\n            }\n\n            for (MethodRepr m : diff.methods().added()) {\n              if (!m.hasValue()) {\n                debug(\"Added method with no default value: \" + m.name);\n                debug(\"Adding class usage to affected usages\");\n                affectedUsages.add(it.createUsage());\n              }\n            }\n          }\n          \n          debug(\"End of annotation-specific analysis\");\n        }\n\n        debug(\"Processing added methods: \");\n        for (MethodRepr m : diff.methods().added()) {\n          debug(\"Method: \", m.name);\n          \n          if (it.isAnnotation()) {\n            debug(\"Class is annotation, skipping method analysis\");\n            continue;\n          }\n\n          if ((it.access & Opcodes.ACC_INTERFACE) > 0 ||\n              (it.access & Opcodes.ACC_ABSTRACT) > 0 ||\n              (m.access & Opcodes.ACC_ABSTRACT) > 0) {\n            debug(\"Class is abstract, or is interface, or added method in abstract => affecting all subclasses\");\n            u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n          }\n\n          Collection<DependencyContext.S> propagated = null;\n\n          if ((m.access & Opcodes.ACC_PRIVATE) == 0 && !myContext.getValue(m.name).equals(\"<init>\")) {\n            final ClassRepr oldIt = getReprByName(it.name);\n\n            if (oldIt != null && self.findOverridenMethods(m, oldIt).size() > 0) {\n\n            }\n            else {\n              propagated = u.propagateMethodAccess(m.name, it.name);\n              debug(\"Conservative case on overriding methods, affecting method usages\");\n              u.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), affectedUsages, dependants);\n            }\n          }\n\n          if ((m.access & Opcodes.ACC_PRIVATE) == 0) {\n            final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = u.findAllMethodsBySpecificity(m, it);\n            final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m);\n\n            if (propagated == null) {\n              propagated = u.propagateMethodAccess(m.name, it.name);\n            }\n\n            final Collection<MethodRepr> lessSpecific = it.findMethods(u.lessSpecific(m));\n\n            for (MethodRepr mm : lessSpecific) {\n              if (!mm.equals(m)) {\n                debug(\"Found less specific method, affecting method usages\");\n                u.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n            }\n\n            debug(\"Processing affected by specificity methods\");\n            for (Pair<MethodRepr, ClassRepr> p : affectedMethods) {\n              final MethodRepr mm = p.first;\n              final ClassRepr cc = p.second;\n\n              if (cc == myMockClass) {\n\n              }\n              else {\n                debug(\"Method: \", mm.name);\n                debug(\"Class : \", cc.name);\n                \n                if (overrides.satisfy(mm)) {\n                  debug(\"Current method overrides that found\");\n                  \n                  final Option<Boolean> subtypeOf = u.isSubtypeOf(mm.type, m.type);\n\n                  if (weakerAccess(mm.access, m.access) ||\n                      ((m.access & Opcodes.ACC_STATIC) > 0 && (mm.access & Opcodes.ACC_STATIC) == 0) ||\n                      ((m.access & Opcodes.ACC_STATIC) == 0 && (mm.access & Opcodes.ACC_STATIC) > 0) ||\n                      ((m.access & Opcodes.ACC_FINAL) > 0) ||\n                      !m.exceptions.equals(mm.exceptions) ||\n                      (subtypeOf.isNone() || !subtypeOf.value()) ||\n                      !empty(mm.signature) || !empty(m.signature)) {\n                    final DependencyContext.S file = myClassToSourceFile.get(cc.name);\n\n                    if (file != null) {\n                      final String f = myContext.getValue(file);                      \n                      debug(\"Complex condition is satisfied, affecting file \" + f);\n                      affectedFiles.add(new File(f));\n                    }\n                  }\n                }\n                else {\n                  debug(\"Current method does not override that found\");\n                  \n                  final Collection<DependencyContext.S> yetPropagated = self.propagateMethodAccess(mm.name, cc.name);\n                  final Collection<DependencyContext.S> deps = myClassToClassDependency.get(cc.name);\n\n                  if (deps != null) {\n                    dependants.addAll(deps);\n                  }\n\n                  debug(\"Affecting method usages for that found\");\n                  u.affectMethodUsages(mm, yetPropagated, mm.createUsage(myContext, cc.name), affectedUsages, dependants);\n                }\n              }\n            }\n\n            final Collection<DependencyContext.S> subClasses = getAllSubclasses(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  final DependencyContext.S outerClass = r.outerClassName;\n\n                  if (u.methodVisible(outerClass, m)) {                                     \n                    final String f = myContext.getValue(sourceFileName);\n                    debug(\"Affecting file \" + f + \" due to local overriding\");\n                    affectedFiles.add(new File(f));\n                  }\n                }\n              }\n            }\n          }\n        }\n        debug(\"End of added methods processing\");\n        \n        debug(\"Processing removed methods:\");        \n        for (MethodRepr m : diff.methods().removed()) {\n          debug(\"Method \", m.name);\n          \n          final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = u.findOverridenMethods(m, it);\n          final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n          if (overridenMethods.size() == 0) {\n            debug(\"No overridden methods found, affecting method usages\");\n            u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n          }\n          else {\n            boolean clear = true;\n\n            loop:\n            for (Pair<MethodRepr, ClassRepr> overriden : overridenMethods) {\n              final MethodRepr mm = overriden.first;\n\n              if (mm == myMockMethod || !mm.type.equals(m.type) || !empty(mm.signature) || !empty(m.signature)) {\n                clear = false;\n                break loop;\n              }\n            }\n\n            if (!clear) {\n              debug(\"No clearly overridden methods found, affecting method usages\");\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n          }\n\n          if ((m.access & Opcodes.ACC_ABSTRACT) == 0) {\n            for (DependencyContext.S p : propagated) {\n              final ClassRepr s = u.reprByName(p);\n\n              if (s != null) {\n                final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = u.findOverridenMethods(m, s);\n\n                overridenInS.addAll(overridenMethods);\n\n                boolean allAbstract = true;\n                boolean visited = false;\n\n                for (Pair<MethodRepr, ClassRepr> pp : overridenInS) {\n                  final ClassRepr cc = pp.second;\n\n                  if (cc == myMockClass) {\n                    visited = true;\n                    continue;\n                  }\n\n                  if (cc.name.equals(it.name)) {\n                    continue;\n                  }\n\n                  visited = true;\n                  allAbstract = ((pp.first.access & Opcodes.ACC_ABSTRACT) > 0) || ((cc.access & Opcodes.ACC_INTERFACE) > 0);\n\n                  if (!allAbstract) {\n                    break;\n                  }\n                }\n\n                if (allAbstract && visited) {\n                  final DependencyContext.S source = myClassToSourceFile.get(p);\n\n                  if (source != null) {\n                    final String f = myContext.getValue(source);\n                    debug(\"Removed method is not abstract & is overrides some abstract method which is not then over-overriden in subclass \", p);\n                    debug(\"Affecting subclass source file \" + f);\n                    affectedFiles.add(new File(f));\n                  }\n                }\n              }\n            }\n          }\n        }\n        debug(\"End of removed methods processing\");        \n        \n        debug(\"Processing changed methods:\");\n        for (Pair<MethodRepr, Difference> mr : diff.methods().changed()) {\n          final MethodRepr m = mr.first;\n          final MethodRepr.Diff d = (MethodRepr.Diff)mr.second;\n          final boolean throwsChanged = (d.exceptions().added().size() > 0) || (d.exceptions().changed().size() > 0);\n\n          debug(\"Method: \", m.name);\n          \n          if (it.isAnnotation()) {\n            if (d.defaultRemoved()) {\n              debug(\"Class is annotation, default value is removed => adding annotation query\");\n              final List<DependencyContext.S> l = new LinkedList<DependencyContext.S>();\n              l.add(m.name);\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null));\n            }\n          }\n          else if (d.base() != Difference.NONE || throwsChanged) {\n            final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n            boolean affected = false;\n            boolean constrained = false;\n\n            final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n\n            if (d.packageLocalOn()) {\n              debug(\"Method became package-local, affecting method usages outside the package\");\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n\n              for (UsageRepr.Usage usage : usages) {\n                usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n              }\n\n              affectedUsages.addAll(usages);\n              affected = true;\n              constrained = true;\n            }\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) {\n              if (!affected) {\n                debug(\"Return type, throws list or signature changed --- affecting method usages\");\n                u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                affectedUsages.addAll(usages);\n              }\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) {\n                if (!affected) {\n                  debug(\"Added static or private specifier or removed static specifier --- affecting method usages\");\n                  u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                  affectedUsages.addAll(usages);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) {\n                  debug(\"Added static specifier --- affecting subclasses\");\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n              }\n              else {\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) {\n                  debug(\"Added final, public or abstract specifier --- affecting subclasses\");\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) {\n                  if (!constrained) {\n                    debug(\"Added public or package-local method became protected --- affect method usages with protected constraint\");\n                    if (!affected) {\n                      u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                      affectedUsages.addAll(usages);\n                    }\n\n                    for (UsageRepr.Usage usage : usages) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        debug(\"End of changed methods processing\");        \n        \n        final int mask = Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;\n\n        debug(\"Processing added fields\");\n        for (FieldRepr f : diff.fields().added()) {\n          debug(\"Field: \", f.name);\n\n          final boolean fPrivate = (f.access & Opcodes.ACC_PRIVATE) > 0;\n          final boolean fProtected = (f.access & Opcodes.ACC_PROTECTED) > 0;\n          final boolean fPublic = (f.access & Opcodes.ACC_PUBLIC) > 0;\n          final boolean fPLocal = !fPrivate && !fProtected && !fPublic;\n\n          if (!fPrivate) {\n            final Collection<DependencyContext.S> subClasses = getAllSubclasses(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  if (r.isLocal) {\n                    affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                  }\n                  else {\n                    final DependencyContext.S outerClass = r.outerClassName;\n\n                    if (!empty(outerClass) && u.fieldVisible(outerClass, f)) {\n                      affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                    }\n                  }\n                }\n\n                final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, subClass);\n                u.affectFieldUsages(f, propagated, f.createUsage(myContext, subClass), affectedUsages, dependants);\n\n                final Collection<DependencyContext.S> deps = myClassToClassDependency.get(subClass);\n\n                if (deps != null) {\n                  dependants.addAll(deps);\n                }\n              }\n            }\n          }\n\n          final Collection<Pair<FieldRepr, ClassRepr>> overridden = u.findOverridenFields(f, it);\n\n          for (Pair<FieldRepr, ClassRepr> p : overridden) {\n            final FieldRepr ff = p.first;\n            final ClassRepr cc = p.second;\n\n            final boolean ffPrivate = (ff.access & Opcodes.ACC_PRIVATE) > 0;\n            final boolean ffProtected = (ff.access & Opcodes.ACC_PROTECTED) > 0;\n            final boolean ffPublic = (ff.access & Opcodes.ACC_PUBLIC) > 0;\n            final boolean ffPLocal = isPackageLocal(ff.access);\n\n            if (!ffPrivate) {\n              final Collection<DependencyContext.S> propagated = o.propagateFieldAccess(ff.name, cc.name);\n              final Set<UsageRepr.Usage> localUsages = new HashSet<UsageRepr.Usage>();\n\n              u.affectFieldUsages(ff, propagated, ff.createUsage(myContext, cc.name), localUsages, dependants);\n\n              if (fPrivate || (fPublic && (ffPublic || ffPLocal)) || (fProtected && ffProtected) || (fPLocal && ffPLocal)) {\n\n              }\n              else {\n                Util.UsageConstraint constaint;\n\n                if ((ffProtected && fPublic) || (fProtected && ffPublic) || (ffPLocal && fProtected)) {\n                  constaint = u.new NegationConstraint(u.new InheritanceConstraint(cc.name));\n                }\n                else if (ffPublic && ffPLocal) {\n                  constaint = u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName()));\n                }\n                else {\n                  constaint = u.new IntersectionConstraint(u.new NegationConstraint(u.new InheritanceConstraint(cc.name)),\n                                                           u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName())));\n                }\n\n                for (UsageRepr.Usage usage : localUsages) {\n                  usageConstraints.put(usage, constaint);\n                }\n              }\n\n              affectedUsages.addAll(localUsages);\n            }\n          }\n        }\n        debug(\"End of added fields processing\");\n        \n        debug(\"Processing removed fields:\");\n        for (FieldRepr f : diff.fields().removed()) {\n          debug(\"Field: \", it.name);\n\n          if ((f.access & Opcodes.ACC_PRIVATE) == 0 && (f.access & mask) == mask && f.hasValue()) {\n            debug(\"Field had value and was (non-private) final static => a switch to non-incremental mode requested\");\n            if (!incrementalDecision(it.name, f, affectedFiles)) {\n              debug(\"End of Differentiate, returning false\");              \n              return false;\n            }\n          }\n\n          final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, it.name);\n          u.affectFieldUsages(f, propagated, f.createUsage(myContext, it.name), affectedUsages, dependants);\n        }\n        debug(\"End of removed fields processing\");\n\n        debug(\"Processing changed fields:\");\n        for (Pair<FieldRepr, Difference> f : diff.fields().changed()) {\n          final Difference d = f.second;\n          final FieldRepr field = f.first;\n\n          debug(\"Field: \", it.name);\n\n          if ((field.access & Opcodes.ACC_PRIVATE) == 0 && (field.access & mask) == mask) {\n            if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {\n              debug(\"Inline field changed it's access or value => a switch to non-incremental mode requested\");\n              if (!incrementalDecision(it.name, field, affectedFiles)){\n                debug(\"End of Differentiate, returning false\");                \n                return false;\n              }\n            }\n          }\n\n          if (d.base() != Difference.NONE) {\n            final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(field.name, it.name);\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0) {\n              debug(\"Type or signature changed --- affecting field usages\");\n              u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_VOLATILE) > 0) {\n                debug(\"Added/removed static modifier or added private/volatile modifier --- affecting field usages\");\n                u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n              else {\n                boolean affected = false;\n                final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {\n                  debug(\"Added final modifier --- affecting field assign usages\");\n                  u.affectFieldUsages(field, propagated, field.createAssignUsage(myContext, it.name), usages, dependants);\n                  affectedUsages.addAll(usages);\n                  affected = true;\n                }\n\n                if ((d.removedModifiers() & Opcodes.ACC_PUBLIC) > 0) {\n                  debug(\"Removed public modifier, affecting field usages with appropriate constraint\");\n                  if (!affected) {\n                    u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), usages, dependants);\n                    affectedUsages.addAll(usages);\n                  }\n\n                  for (UsageRepr.Usage usage : usages) {\n                    if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                    else {\n                      usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        debug(\"End of changed fields processing\");        \n      }\n      debug(\"End of changed classes processing\");\n      \n      debug(\"Processing removed classes:\");\n      for (ClassRepr c : classDiff.removed()) {\n        debug(\"Adding usages of class \", c.name);\n        affectedUsages.add(c.createUsage());\n      }\n      debug(\"End of removed classes processing.\");\n\n      debug(\"Processing added classes:\");\n      for (ClassRepr c : classDiff.added()) {\n        final Collection<DependencyContext.S> depClasses = myClassToClassDependency.get(c.name);\n\n        if (depClasses != null) {\n          for (DependencyContext.S depClass : depClasses) {\n            final DependencyContext.S fName = myClassToSourceFile.get(depClass);\n\n            if (fName != null) {\n              final String f = myContext.getValue(fName);\n              debug(\"Adding dependent file \" + f); \n              affectedFiles.add(new File(f));\n            }\n          }\n        }\n      }\n      debug(\"End of added classes processing.\");\n\n      debug(\"Checking dependent files:\");\n      if (dependants != null) {\n        final Set<DependencyContext.S> dependentFiles = new HashSet<DependencyContext.S>();\n\n        for (DependencyContext.S depClass : dependants) {\n          final DependencyContext.S file = myClassToSourceFile.get(depClass);\n\n          if (file != null) {\n            dependentFiles.add(file);\n          }\n        }\n\n        filewise:\n        for (DependencyContext.S depFile : dependentFiles) {\n          final File theFile = new File(myContext.getValue(depFile));\n\n          if (affectedFiles.contains(theFile) || compiledFiles.contains(theFile)) {\n            continue filewise;\n          }\n\n          debug(\"Dependent file: \" + theFile.getAbsolutePath());\n\n          final Collection<UsageRepr.Cluster> depClusters = mySourceFileToUsages.get(depFile);\n\n          for (UsageRepr.Cluster depCluster : depClusters) {\n            final Set<UsageRepr.Usage> depUsages = depCluster.getUsages();\n\n            if (depUsages != null) {\n              final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>(depUsages);\n\n              usages.retainAll(affectedUsages);\n\n              if (!usages.isEmpty()) {\n                for (UsageRepr.Usage usage : usages) {\n                  final Util.UsageConstraint constraint = usageConstraints.get(usage);\n\n                  if (constraint == null) {\n                    debug(\"Added file with no constraints\");\n                    affectedFiles.add(theFile);\n                    continue filewise;\n                  }\n                  else {\n                    final Set<DependencyContext.S> residenceClasses = depCluster.getResidence(usage);\n                    for (DependencyContext.S residentName : residenceClasses) {\n                      if (constraint.checkResidence(residentName)) {\n                        debug(\"Added file with satisfied constraint\");\n                        affectedFiles.add(theFile);\n                        continue filewise;\n                      }\n                    }\n\n                  }\n                }\n              }\n\n              if (annotationQuery.size() > 0) {\n                final Collection<UsageRepr.Usage> annotationUsages = mySourceFileToAnnotationUsages.get(depFile);\n\n                for (UsageRepr.Usage usage : annotationUsages) {\n                  for (UsageRepr.AnnotationUsage query : annotationQuery) {\n                    if (query.satisfies(usage)) {\n                      debug(\"Added file due to annotation query\");\n                      affectedFiles.add(theFile);\n                      continue filewise;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    final Collection<File> removedFiles = new HashSet<File>();\n    \n    for (String r : removed) {\n      removedFiles.add(new File(r));\n    }\n\n    affectedFiles.removeAll(removedFiles);\n\n    debug(\"End of Differentiate, returning true\");    \n    return true;\n  }","id":90857,"modified_method":"public boolean differentiate(final Mappings delta,\n                               final Collection<String> removed,\n                               final Collection<File> filesToCompile,\n                               final Collection<File> compiledFiles,\n                               final Collection<File> affectedFiles) {\n    debug(\"Begin of Differentiate:\");\n\n    delta.compensateRemovedContent(filesToCompile);\n\n    final Util u = new Util(delta);\n    final Util self = new Util(this);\n    final Util o = new Util();\n\n    if (removed != null) {\n      for (String file : removed) {\n        final Collection<ClassRepr> classes = mySourceFileToClasses.get(myContext.get(file));\n\n        if (classes != null) {\n          for (ClassRepr c : classes) {\n            u.affectAll(c.name, affectedFiles);\n          }\n        }\n      }\n    }\n\n    for (DependencyContext.S fileName : delta.mySourceFileToClasses.keyCollection()) {\n      final Set<ClassRepr> classes = (Set<ClassRepr>)delta.mySourceFileToClasses.get(fileName);\n      final Set<ClassRepr> pastClasses = (Set<ClassRepr>)mySourceFileToClasses.get(fileName);\n      final Set<DependencyContext.S> dependants = new HashSet<DependencyContext.S>();\n\n      self.appendDependents(pastClasses, dependants);\n\n      final Set<UsageRepr.Usage> affectedUsages = new HashSet<UsageRepr.Usage>();\n      final Set<UsageRepr.AnnotationUsage> annotationQuery = new HashSet<UsageRepr.AnnotationUsage>();\n      final Map<UsageRepr.Usage, Util.UsageConstraint> usageConstraints = new HashMap<UsageRepr.Usage, Util.UsageConstraint>();\n\n      final Difference.Specifier<ClassRepr> classDiff = Difference.make(pastClasses, classes);\n\n      debug(\"Processing changed classes:\");\n      for (Pair<ClassRepr, Difference> changed : classDiff.changed()) {\n        final ClassRepr it = changed.first;\n        final ClassRepr.Diff diff = (ClassRepr.Diff)changed.second;\n\n        debug(\"Changed: \", it.name);\n\n        final int addedModifiers = diff.addedModifiers();\n        final int removedModifiers = diff.removedModifiers();\n\n        final boolean superClassChanged = (diff.base() & Difference.SUPERCLASS) > 0;\n        final boolean interfacesChanged = !diff.interfaces().unchanged();\n        final boolean signatureChanged = (diff.base() & Difference.SIGNATURE) > 0;\n\n        if (superClassChanged || interfacesChanged || signatureChanged) {\n          debug(\"Superclass changed: \" + superClassChanged);\n          debug(\"Interfaces changed: \" + interfacesChanged);\n          debug(\"Signature changed \" + signatureChanged);\n\n          final boolean extendsChanged = superClassChanged && !diff.extendsAdded();\n          final boolean interfacesRemoved = interfacesChanged && !diff.interfaces().removed().isEmpty();\n\n          debug(\"Extends changed: \" + extendsChanged);\n          debug(\"Interfaces removed: \" + interfacesRemoved);\n\n          u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, extendsChanged || interfacesRemoved || signatureChanged);\n        }\n\n        if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 || (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n          debug(\"Class-to-interface or interface-to-class conversion detected, added class usage to affected usages\");\n          affectedUsages.add(it.createUsage());\n        }\n\n        if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {\n          debug(\"Annotation, retention policy = SOURCE => a switch to non-incremental mode requested\");\n          if (!incrementalDecision(it.outerClassName, it, affectedFiles)) {\n            debug(\"End of Differentiate, returning false\");\n            return false;\n          }\n        }\n\n        if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {\n          debug(\"Introduction of 'protected' modifier detected, adding class usage + inheritance constraint to affected usages\");\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n        }\n\n        if (diff.packageLocalOn()) {\n          debug(\"Introduction of 'package local' access detected, adding class usage + package constraint to affected usages\");\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_FINAL) > 0 || (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {\n          debug(\"Introduction of 'private' or 'final' modifier(s) detected, adding class usage to affected usages\");\n          affectedUsages.add(it.createUsage());\n        }\n\n        if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0 || (addedModifiers & Opcodes.ACC_STATIC) > 0) {\n          debug(\"Introduction of 'abstract' or 'static' modifier(s) detected, adding class new usage to affected usages\");\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if (it.isAnnotation()) {\n          debug(\"Class is annotation, performing annotation-specific analysis\");\n\n          if (diff.retentionChanged()) {\n            debug(\"Retention policy change detected, adding class usage to affected usages\");\n            affectedUsages.add(it.createUsage());\n          }\n          else {\n            final Collection<ElementType> removedtargets = diff.targets().removed();\n\n            if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {\n              debug(\"Removed target contains LOCAL_VARIABLE => a switch to non-incremental mode requested\");\n              if (!incrementalDecision(it.outerClassName, it, affectedFiles)) {\n                debug(\"End of Differentiate, returning false\");\n                return false;\n              }\n            }\n\n            if (!removedtargets.isEmpty()) {\n              debug(\"Removed some annotation targets, adding annotation query\");\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), null, removedtargets));\n            }\n\n            for (MethodRepr m : diff.methods().added()) {\n              if (!m.hasValue()) {\n                debug(\"Added method with no default value: \" + m.name);\n                debug(\"Adding class usage to affected usages\");\n                affectedUsages.add(it.createUsage());\n              }\n            }\n          }\n\n          debug(\"End of annotation-specific analysis\");\n        }\n\n        debug(\"Processing added methods: \");\n        for (MethodRepr m : diff.methods().added()) {\n          debug(\"Method: \", m.name);\n\n          if (it.isAnnotation()) {\n            debug(\"Class is annotation, skipping method analysis\");\n            continue;\n          }\n\n          if ((it.access & Opcodes.ACC_INTERFACE) > 0 ||\n              (it.access & Opcodes.ACC_ABSTRACT) > 0 ||\n              (m.access & Opcodes.ACC_ABSTRACT) > 0) {\n            debug(\"Class is abstract, or is interface, or added method in abstract => affecting all subclasses\");\n            u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n          }\n\n          Collection<DependencyContext.S> propagated = null;\n\n          if ((m.access & Opcodes.ACC_PRIVATE) == 0 && !myContext.getValue(m.name).equals(\"<init>\")) {\n            final ClassRepr oldIt = getReprByName(it.name);\n\n            if (oldIt != null && self.findOverridenMethods(m, oldIt).size() > 0) {\n\n            }\n            else {\n              propagated = u.propagateMethodAccess(m.name, it.name);\n              debug(\"Conservative case on overriding methods, affecting method usages\");\n              u.affectMethodUsages(m, propagated, m.createMetaUsage(myContext, it.name), affectedUsages, dependants);\n            }\n          }\n\n          if ((m.access & Opcodes.ACC_PRIVATE) == 0) {\n            final Collection<Pair<MethodRepr, ClassRepr>> affectedMethods = u.findAllMethodsBySpecificity(m, it);\n            final MethodRepr.Predicate overrides = MethodRepr.equalByJavaRules(m);\n\n            if (propagated == null) {\n              propagated = u.propagateMethodAccess(m.name, it.name);\n            }\n\n            final Collection<MethodRepr> lessSpecific = it.findMethods(u.lessSpecific(m));\n\n            for (MethodRepr mm : lessSpecific) {\n              if (!mm.equals(m)) {\n                debug(\"Found less specific method, affecting method usages\");\n                u.affectMethodUsages(mm, propagated, mm.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n            }\n\n            debug(\"Processing affected by specificity methods\");\n            for (Pair<MethodRepr, ClassRepr> p : affectedMethods) {\n              final MethodRepr mm = p.first;\n              final ClassRepr cc = p.second;\n\n              if (cc == myMockClass) {\n\n              }\n              else {\n                debug(\"Method: \", mm.name);\n                debug(\"Class : \", cc.name);\n\n                if (overrides.satisfy(mm)) {\n                  debug(\"Current method overrides that found\");\n\n                  final Option<Boolean> subtypeOf = u.isSubtypeOf(mm.type, m.type);\n\n                  if (weakerAccess(mm.access, m.access) ||\n                      ((m.access & Opcodes.ACC_STATIC) > 0 && (mm.access & Opcodes.ACC_STATIC) == 0) ||\n                      ((m.access & Opcodes.ACC_STATIC) == 0 && (mm.access & Opcodes.ACC_STATIC) > 0) ||\n                      ((m.access & Opcodes.ACC_FINAL) > 0) ||\n                      !m.exceptions.equals(mm.exceptions) ||\n                      (subtypeOf.isNone() || !subtypeOf.value()) ||\n                      !empty(mm.signature) || !empty(m.signature)) {\n                    final DependencyContext.S file = myClassToSourceFile.get(cc.name);\n\n                    if (file != null) {\n                      final String f = myContext.getValue(file);\n                      debug(\"Complex condition is satisfied, affecting file \" + f);\n                      affectedFiles.add(new File(f));\n                    }\n                  }\n                }\n                else {\n                  debug(\"Current method does not override that found\");\n\n                  final Collection<DependencyContext.S> yetPropagated = self.propagateMethodAccess(mm.name, cc.name);\n                  final Collection<DependencyContext.S> deps = myClassToClassDependency.get(cc.name);\n\n                  if (deps != null) {\n                    dependants.addAll(deps);\n                  }\n\n                  debug(\"Affecting method usages for that found\");\n                  u.affectMethodUsages(mm, yetPropagated, mm.createUsage(myContext, cc.name), affectedUsages, dependants);\n                }\n              }\n            }\n\n            final Collection<DependencyContext.S> subClasses = getAllSubclasses(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  final DependencyContext.S outerClass = r.outerClassName;\n\n                  if (u.methodVisible(outerClass, m)) {\n                    final String f = myContext.getValue(sourceFileName);\n                    debug(\"Affecting file \" + f + \" due to local overriding\");\n                    affectedFiles.add(new File(f));\n                  }\n                }\n              }\n            }\n          }\n        }\n        debug(\"End of added methods processing\");\n\n        debug(\"Processing removed methods:\");\n        for (MethodRepr m : diff.methods().removed()) {\n          debug(\"Method \", m.name);\n\n          final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = u.findOverridenMethods(m, it);\n          final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n          if (overridenMethods.size() == 0) {\n            debug(\"No overridden methods found, affecting method usages\");\n            u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n          }\n          else {\n            boolean clear = true;\n\n            loop:\n            for (Pair<MethodRepr, ClassRepr> overriden : overridenMethods) {\n              final MethodRepr mm = overriden.first;\n\n              if (mm == myMockMethod || !mm.type.equals(m.type) || !empty(mm.signature) || !empty(m.signature)) {\n                clear = false;\n                break loop;\n              }\n            }\n\n            if (!clear) {\n              debug(\"No clearly overridden methods found, affecting method usages\");\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n          }\n\n          if ((m.access & Opcodes.ACC_ABSTRACT) == 0) {\n            for (DependencyContext.S p : propagated) {\n              final ClassRepr s = u.reprByName(p);\n\n              if (s != null) {\n                final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = u.findOverridenMethods(m, s);\n\n                overridenInS.addAll(overridenMethods);\n\n                boolean allAbstract = true;\n                boolean visited = false;\n\n                for (Pair<MethodRepr, ClassRepr> pp : overridenInS) {\n                  final ClassRepr cc = pp.second;\n\n                  if (cc == myMockClass) {\n                    visited = true;\n                    continue;\n                  }\n\n                  if (cc.name.equals(it.name)) {\n                    continue;\n                  }\n\n                  visited = true;\n                  allAbstract = ((pp.first.access & Opcodes.ACC_ABSTRACT) > 0) || ((cc.access & Opcodes.ACC_INTERFACE) > 0);\n\n                  if (!allAbstract) {\n                    break;\n                  }\n                }\n\n                if (allAbstract && visited) {\n                  final DependencyContext.S source = myClassToSourceFile.get(p);\n\n                  if (source != null) {\n                    final String f = myContext.getValue(source);\n                    debug(\n                      \"Removed method is not abstract & is overrides some abstract method which is not then over-overriden in subclass \",\n                      p);\n                    debug(\"Affecting subclass source file \" + f);\n                    affectedFiles.add(new File(f));\n                  }\n                }\n              }\n            }\n          }\n        }\n        debug(\"End of removed methods processing\");\n\n        debug(\"Processing changed methods:\");\n        for (Pair<MethodRepr, Difference> mr : diff.methods().changed()) {\n          final MethodRepr m = mr.first;\n          final MethodRepr.Diff d = (MethodRepr.Diff)mr.second;\n          final boolean throwsChanged = (d.exceptions().added().size() > 0) || (d.exceptions().changed().size() > 0);\n\n          debug(\"Method: \", m.name);\n\n          if (it.isAnnotation()) {\n            if (d.defaultRemoved()) {\n              debug(\"Class is annotation, default value is removed => adding annotation query\");\n              final List<DependencyContext.S> l = new LinkedList<DependencyContext.S>();\n              l.add(m.name);\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null));\n            }\n          }\n          else if (d.base() != Difference.NONE || throwsChanged) {\n            final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n            boolean affected = false;\n            boolean constrained = false;\n\n            final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n\n            if (d.packageLocalOn()) {\n              debug(\"Method became package-local, affecting method usages outside the package\");\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n\n              for (UsageRepr.Usage usage : usages) {\n                usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n              }\n\n              affectedUsages.addAll(usages);\n              affected = true;\n              constrained = true;\n            }\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) {\n              if (!affected) {\n                debug(\"Return type, throws list or signature changed --- affecting method usages\");\n                u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                affectedUsages.addAll(usages);\n              }\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) {\n                if (!affected) {\n                  debug(\"Added static or private specifier or removed static specifier --- affecting method usages\");\n                  u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                  affectedUsages.addAll(usages);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) {\n                  debug(\"Added static specifier --- affecting subclasses\");\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n              }\n              else {\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) {\n                  debug(\"Added final, public or abstract specifier --- affecting subclasses\");\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) {\n                  if (!constrained) {\n                    debug(\"Added public or package-local method became protected --- affect method usages with protected constraint\");\n                    if (!affected) {\n                      u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n                      affectedUsages.addAll(usages);\n                    }\n\n                    for (UsageRepr.Usage usage : usages) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        debug(\"End of changed methods processing\");\n\n        final int mask = Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;\n\n        debug(\"Processing added fields\");\n        for (FieldRepr f : diff.fields().added()) {\n          debug(\"Field: \", f.name);\n\n          final boolean fPrivate = (f.access & Opcodes.ACC_PRIVATE) > 0;\n          final boolean fProtected = (f.access & Opcodes.ACC_PROTECTED) > 0;\n          final boolean fPublic = (f.access & Opcodes.ACC_PUBLIC) > 0;\n          final boolean fPLocal = !fPrivate && !fProtected && !fPublic;\n\n          if (!fPrivate) {\n            final Collection<DependencyContext.S> subClasses = getAllSubclasses(it.name);\n\n            // if (subClasses != null) {\n            for (final DependencyContext.S subClass : subClasses) {\n              final ClassRepr r = u.reprByName(subClass);\n              final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n              if (r != null && sourceFileName != null) {\n                if (r.isLocal) {\n                  debug(\"Affecting local subclass (introduced field can potentially hide surrounding method parameters/local variables): \",\n                        sourceFileName);\n                  affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                }\n                else {\n                  final DependencyContext.S outerClass = r.outerClassName;\n\n                  if (!empty(outerClass) && u.fieldVisible(outerClass, f)) {\n                    debug(\"Affecting inner subclass (introduced field can potentially hide surrounding class fields): \", sourceFileName);\n                    affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                  }\n                }\n              }\n\n              debug(\"Affecting field usages referenced from subclass \", subClass);\n              final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, subClass);\n              u.affectFieldUsages(f, propagated, f.createUsage(myContext, subClass), affectedUsages, dependants);\n\n              final Collection<DependencyContext.S> deps = myClassToClassDependency.get(subClass);\n\n              if (deps != null) {\n                dependants.addAll(deps);\n              }\n            }\n            // }\n          }\n\n          final Collection<Pair<FieldRepr, ClassRepr>> overridden = u.findOverridenFields(f, it);\n\n          for (Pair<FieldRepr, ClassRepr> p : overridden) {\n            final FieldRepr ff = p.first;\n            final ClassRepr cc = p.second;\n\n            final boolean ffPrivate = (ff.access & Opcodes.ACC_PRIVATE) > 0;\n            final boolean ffProtected = (ff.access & Opcodes.ACC_PROTECTED) > 0;\n            final boolean ffPublic = (ff.access & Opcodes.ACC_PUBLIC) > 0;\n            final boolean ffPLocal = isPackageLocal(ff.access);\n\n            if (!ffPrivate) {\n              final Collection<DependencyContext.S> propagated = o.propagateFieldAccess(ff.name, cc.name);\n              final Set<UsageRepr.Usage> localUsages = new HashSet<UsageRepr.Usage>();\n\n              debug(\"Affecting usages of overridden field in class \", cc.name);\n              u.affectFieldUsages(ff, propagated, ff.createUsage(myContext, cc.name), localUsages, dependants);\n\n              if (fPrivate || (fPublic && (ffPublic || ffPLocal)) || (fProtected && ffProtected) || (fPLocal && ffPLocal)) {\n\n              }\n              else {\n                Util.UsageConstraint constaint;\n\n                if ((ffProtected && fPublic) || (fProtected && ffPublic) || (ffPLocal && fProtected)) {\n                  constaint = u.new NegationConstraint(u.new InheritanceConstraint(cc.name));\n                }\n                else if (ffPublic && ffPLocal) {\n                  constaint = u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName()));\n                }\n                else {\n                  constaint = u.new IntersectionConstraint(u.new NegationConstraint(u.new InheritanceConstraint(cc.name)),\n                                                           u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName())));\n                }\n\n                for (UsageRepr.Usage usage : localUsages) {\n                  usageConstraints.put(usage, constaint);\n                }\n              }\n\n              affectedUsages.addAll(localUsages);\n            }\n          }\n        }\n        debug(\"End of added fields processing\");\n\n        debug(\"Processing removed fields:\");\n        for (FieldRepr f : diff.fields().removed()) {\n          debug(\"Field: \", it.name);\n\n          if ((f.access & Opcodes.ACC_PRIVATE) == 0 && (f.access & mask) == mask && f.hasValue()) {\n            debug(\"Field had value and was (non-private) final static => a switch to non-incremental mode requested\");\n            if (!incrementalDecision(it.name, f, affectedFiles)) {\n              debug(\"End of Differentiate, returning false\");\n              return false;\n            }\n          }\n\n          final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, it.name);\n          u.affectFieldUsages(f, propagated, f.createUsage(myContext, it.name), affectedUsages, dependants);\n        }\n        debug(\"End of removed fields processing\");\n\n        debug(\"Processing changed fields:\");\n        for (Pair<FieldRepr, Difference> f : diff.fields().changed()) {\n          final Difference d = f.second;\n          final FieldRepr field = f.first;\n\n          debug(\"Field: \", it.name);\n\n          if ((field.access & Opcodes.ACC_PRIVATE) == 0 && (field.access & mask) == mask) {\n            if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {\n              debug(\"Inline field changed it's access or value => a switch to non-incremental mode requested\");\n              if (!incrementalDecision(it.name, field, affectedFiles)) {\n                debug(\"End of Differentiate, returning false\");\n                return false;\n              }\n            }\n          }\n\n          if (d.base() != Difference.NONE) {\n            final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(field.name, it.name);\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0) {\n              debug(\"Type or signature changed --- affecting field usages\");\n              u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_VOLATILE) > 0) {\n                debug(\"Added/removed static modifier or added private/volatile modifier --- affecting field usages\");\n                u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n              else {\n                boolean affected = false;\n                final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {\n                  debug(\"Added final modifier --- affecting field assign usages\");\n                  u.affectFieldUsages(field, propagated, field.createAssignUsage(myContext, it.name), usages, dependants);\n                  affectedUsages.addAll(usages);\n                  affected = true;\n                }\n\n                if ((d.removedModifiers() & Opcodes.ACC_PUBLIC) > 0) {\n                  debug(\"Removed public modifier, affecting field usages with appropriate constraint\");\n                  if (!affected) {\n                    u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), usages, dependants);\n                    affectedUsages.addAll(usages);\n                  }\n\n                  for (UsageRepr.Usage usage : usages) {\n                    if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                    else {\n                      usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        debug(\"End of changed fields processing\");\n      }\n      debug(\"End of changed classes processing\");\n\n      debug(\"Processing removed classes:\");\n      for (ClassRepr c : classDiff.removed()) {\n        debug(\"Adding usages of class \", c.name);\n        affectedUsages.add(c.createUsage());\n      }\n      debug(\"End of removed classes processing.\");\n\n      debug(\"Processing added classes:\");\n      for (ClassRepr c : classDiff.added()) {\n        final Collection<DependencyContext.S> depClasses = myClassToClassDependency.get(c.name);\n\n        if (depClasses != null) {\n          for (DependencyContext.S depClass : depClasses) {\n            final DependencyContext.S fName = myClassToSourceFile.get(depClass);\n\n            if (fName != null) {\n              final String f = myContext.getValue(fName);\n              debug(\"Adding dependent file \" + f);\n              affectedFiles.add(new File(f));\n            }\n          }\n        }\n      }\n      debug(\"End of added classes processing.\");\n\n      debug(\"Checking dependent files:\");\n      if (dependants != null) {\n        final Set<DependencyContext.S> dependentFiles = new HashSet<DependencyContext.S>();\n\n        for (DependencyContext.S depClass : dependants) {\n          final DependencyContext.S file = myClassToSourceFile.get(depClass);\n\n          if (file != null) {\n            dependentFiles.add(file);\n          }\n        }\n\n        filewise:\n        for (DependencyContext.S depFile : dependentFiles) {\n          final File theFile = new File(myContext.getValue(depFile));\n\n          if (affectedFiles.contains(theFile) || compiledFiles.contains(theFile)) {\n            continue filewise;\n          }\n\n          debug(\"Dependent file: \" + theFile.getAbsolutePath());\n\n          final Collection<UsageRepr.Cluster> depClusters = mySourceFileToUsages.get(depFile);\n\n          for (UsageRepr.Cluster depCluster : depClusters) {\n            final Set<UsageRepr.Usage> depUsages = depCluster.getUsages();\n\n            if (depUsages != null) {\n              final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>(depUsages);\n\n              usages.retainAll(affectedUsages);\n\n              if (!usages.isEmpty()) {\n                for (UsageRepr.Usage usage : usages) {\n                  final Util.UsageConstraint constraint = usageConstraints.get(usage);\n\n                  if (constraint == null) {\n                    debug(\"Added file with no constraints\");\n                    affectedFiles.add(theFile);\n                    continue filewise;\n                  }\n                  else {\n                    final Set<DependencyContext.S> residenceClasses = depCluster.getResidence(usage);\n                    for (DependencyContext.S residentName : residenceClasses) {\n                      if (constraint.checkResidence(residentName)) {\n                        debug(\"Added file with satisfied constraint\");\n                        affectedFiles.add(theFile);\n                        continue filewise;\n                      }\n                    }\n\n                  }\n                }\n              }\n\n              if (annotationQuery.size() > 0) {\n                final Collection<UsageRepr.Usage> annotationUsages = mySourceFileToAnnotationUsages.get(depFile);\n\n                for (UsageRepr.Usage usage : annotationUsages) {\n                  for (UsageRepr.AnnotationUsage query : annotationQuery) {\n                    if (query.satisfies(usage)) {\n                      debug(\"Added file due to annotation query\");\n                      affectedFiles.add(theFile);\n                      continue filewise;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    final Collection<File> removedFiles = new HashSet<File>();\n\n    if (removed != null) {\n      for (String r : removed) {\n        removedFiles.add(new File(r));\n      }\n\n      affectedFiles.removeAll(removedFiles);\n    }\n\n    debug(\"End of Differentiate, returning true\");\n    return true;\n  }","commit_id":"13f7e623f933dcb097049e57a0c5974c9e3cf38d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void removeAll()\n    {\n        this.cache.removeAll();\n        this.mappingCache.removeAll();\n    }","id":90858,"modified_method":"@Override\n    public void removeAll()\n    {\n        if (this.cache != null) {\n            this.cache.removeAll();\n        }\n        if (this.mappingCache != null) {\n            this.mappingCache.removeAll();\n        }\n    }","commit_id":"b7164ea9352f8b9e79bccaba178be01313efd713","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Grabs and displays the error messages after all download threads have finished.\n     */\n    public void run() {\n        progressMonitor.finishTask();\n        String errors = \"\";\n\n        for(DownloadTask dt : osmTasks) {\n            String err = dt.getErrorMessage();\n            if(err.equals(\"\")) {\n                continue;\n            }\n            errors += \"<br>* \" + err;\n        }\n\n        if(! errors.equals(\"\")) {\n            OptionPaneUtil.showMessageDialog(\n                    Main.parent,\n                    \"<html>\"+tr(\"The following errors occurred during mass download:{0}\", errors)\n                    +\"<\/html>\",\n                    tr(\"Errors during Download\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        // FIXME: this is a hack. We assume that the user canceled the whole download if at least\n        // one task was canceled or if it failed\n        //\n        for (DownloadTask task: osmTasks) {\n            if (task instanceof DownloadOsmTask) {\n                DownloadOsmTask osmTask = (DownloadOsmTask)task;\n                if (osmTask.isCanceled() || osmTask.isFailed())\n                    return;\n            }\n        }\n        Set<Long> myPrimitiveIds = Main.map.mapView.getEditLayer().data.getCompletePrimitiveIds();\n        Set<Long> downloadedIds = getDownloadedIds();\n        myPrimitiveIds.removeAll(downloadedIds);\n        myPrimitiveIds.remove(new Long(0)); // ignore new primitives\n        if (! myPrimitiveIds.isEmpty()) {\n            handlePotentiallyDeletedPrimitives(myPrimitiveIds);\n        }\n    }","id":90859,"modified_method":"/**\n     * Grabs and displays the error messages after all download threads have finished.\n     */\n    public void run() {\n        progressMonitor.finishTask();\n        String errors = \"\";\n\n        for(DownloadTask dt : osmTasks) {\n            String err = dt.getErrorMessage();\n            if(err.equals(\"\")) {\n                continue;\n            }\n            errors += \"<br>* \" + err;\n        }\n\n        if(! errors.equals(\"\")) {\n            OptionPaneUtil.showMessageDialog(\n                    Main.parent,\n                    \"<html>\"+tr(\"The following errors occurred during mass download:{0}\", errors)\n                    +\"<\/html>\",\n                    tr(\"Errors during Download\"),\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        // FIXME: this is a hack. We assume that the user canceled the whole download if at least\n        // one task was canceled or if it failed\n        //\n        for (DownloadTask task: osmTasks) {\n            if (task instanceof DownloadOsmTask) {\n                DownloadOsmTask osmTask = (DownloadOsmTask)task;\n                if (osmTask.isCanceled() || osmTask.isFailed())\n                    return;\n            }\n        }\n        final OsmDataLayer editLayer = Main.map.mapView.getEditLayer();\n        if (editLayer != null) {\n            Set<Long> myPrimitiveIds = editLayer.data.getCompletePrimitiveIds();\n            Set<Long> downloadedIds = getDownloadedIds();\n            myPrimitiveIds.removeAll(downloadedIds);\n            myPrimitiveIds.remove(new Long(0)); // ignore new primitives\n            if (! myPrimitiveIds.isEmpty()) {\n                handlePotentiallyDeletedPrimitives(myPrimitiveIds);\n            }\n        }\n    }","commit_id":"7add9cd3a0cd548025606146d78399a81bf435f5","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Set up the VCF writer, the sample expressions and regexs, and the JEXL matcher\n     */\n    public void initialize() {\n        // Get list of samples to include in the output\n        List<String> rodNames = Arrays.asList(variantCollection.variants.getName());\n\n        Map<String, VCFHeader> vcfRods = VCFUtils.getVCFHeadersFromRods(getToolkit(), rodNames);\n        TreeSet<String> vcfSamples = new TreeSet<String>(SampleUtils.getSampleList(vcfRods, VariantContextUtils.GenotypeMergeType.REQUIRE_UNIQUE));\n\n        Collection<String> samplesFromFile = SampleUtils.getSamplesFromFiles(sampleFiles);\n        Collection<String> samplesFromExpressions = SampleUtils.matchSamplesExpressions(vcfSamples, sampleExpressions);\n\n        // first, add any requested samples\n        samples.addAll(samplesFromFile);\n        samples.addAll(samplesFromExpressions);\n        samples.addAll(sampleNames);\n\n        // if none were requested, we want all of them\n        if ( samples.isEmpty() ) {\n            samples.addAll(vcfSamples);\n            NO_SAMPLES_SPECIFIED = true;\n        }\n\n        // now, exclude any requested samples\n        Collection<String> XLsamplesFromFile = SampleUtils.getSamplesFromFiles(XLsampleFiles);\n        samples.removeAll(XLsamplesFromFile);\n        samples.removeAll(XLsampleNames);\n\n        if ( samples.size() == 0 )\n            throw new UserException(\"All samples requested to be included were also requested to be excluded.\");\n\n        for ( String sample : samples )\n            logger.info(\"Including sample '\" + sample + \"'\");\n\n        // Initialize VCF header\n        Set<VCFHeaderLine> headerLines = VCFUtils.smartMergeHeaders(vcfRods.values(), logger);\n        headerLines.add(new VCFHeaderLine(\"source\", \"SelectVariants\"));\n\n        if (KEEP_ORIGINAL_CHR_COUNTS) {\n            headerLines.add(new VCFFormatHeaderLine(\"AC_Orig\", 1, VCFHeaderLineType.Integer, \"Original AC\"));\n            headerLines.add(new VCFFormatHeaderLine(\"AF_Orig\", 1, VCFHeaderLineType.Float, \"Original AF\"));\n            headerLines.add(new VCFFormatHeaderLine(\"AN_Orig\", 1, VCFHeaderLineType.Integer, \"Original AN\"));\n        }\n        vcfWriter.writeHeader(new VCFHeader(headerLines, samples));\n\n        for (int i = 0; i < SELECT_EXPRESSIONS.size(); i++) {\n            // It's not necessary that the user supply select names for the JEXL expressions, since those\n            // expressions will only be needed for omitting records.  Make up the select names here.\n            selectNames.add(String.format(\"select-%d\", i));\n        }\n\n        jexls = VariantContextUtils.initializeMatchExps(selectNames, SELECT_EXPRESSIONS);\n\n        // Look at the parameters to decide which analysis to perform\n        DISCORDANCE_ONLY = discordanceTrack.isBound();\n        if (DISCORDANCE_ONLY) logger.info(\"Selecting only variants discordant with the track: \" + discordanceTrack.getName());\n\n        CONCORDANCE_ONLY = concordanceTrack.isBound();\n        if (CONCORDANCE_ONLY) logger.info(\"Selecting only variants concordant with the track: \" + concordanceTrack.getName());\n\n        if (MENDELIAN_VIOLATIONS) {\n            if ( FAMILY_STRUCTURE_FILE != null) {\n                try {\n                    for ( final String line : new XReadLines( FAMILY_STRUCTURE_FILE ) ) {\n                        MendelianViolation mv = new MendelianViolation(line, MENDELIAN_VIOLATION_QUAL_THRESHOLD);\n                        if (samples.contains(mv.getSampleChild()) &&  samples.contains(mv.getSampleDad()) && samples.contains(mv.getSampleMom()))\n                            mvSet.add(mv);\n                    }\n                } catch ( FileNotFoundException e ) {\n                    throw new UserException.CouldNotReadInputFile(AF_FILE, e);\n                }\n                if (outMVFile != null)\n                    try {\n                        outMVFileStream = new PrintStream(outMVFile);\n                    }\n                    catch (FileNotFoundException e) {\n                        throw new UserException.CouldNotCreateOutputFile(outMVFile, \"Can't open output file\", e);   }\n            }\n            else\n                mvSet.add(new MendelianViolation(getToolkit(), MENDELIAN_VIOLATION_QUAL_THRESHOLD));\n        }\n        else if (!FAMILY_STRUCTURE.isEmpty()) {\n            mvSet.add(new MendelianViolation(FAMILY_STRUCTURE, MENDELIAN_VIOLATION_QUAL_THRESHOLD));\n            MENDELIAN_VIOLATIONS = true;\n        }\n\n        SELECT_RANDOM_NUMBER = numRandom > 0;\n        if (SELECT_RANDOM_NUMBER) {\n            logger.info(\"Selecting \" + numRandom + \" variants at random from the variant track\");\n            variantArray = new RandomVariantStructure[numRandom];\n        }\n\n        SELECT_RANDOM_FRACTION = fractionRandom > 0;\n        if (SELECT_RANDOM_FRACTION) logger.info(\"Selecting approximately \" + 100.0*fractionRandom + \"% of the variants at random from the variant track\");\n\n\n        if (KEEP_AF_SPECTRUM) {\n            try {\n                afBreakpoints = new ArrayList<Double>();\n                afBoosts = new ArrayList<Double>();\n                logger.info(\"Reading in AF boost table...\");\n                boolean firstLine = false;\n                for ( final String line : new XReadLines( AF_FILE ) ) {\n                    if (!firstLine) {\n                        firstLine = true;\n                        continue;\n                    }\n                    final String[] vals = line.split(\" \");\n\n                    double bkp = Double.valueOf(vals[0]);\n                    double afb = Double.valueOf(vals[1]);\n                    afBreakpoints.add(bkp);\n                    afBoosts.add(afb);\n\n                }\n                bkDelta = afBreakpoints.get(0);\n            } catch ( FileNotFoundException e ) {\n                throw new UserException.CouldNotReadInputFile(AF_FILE, e);\n            }\n\n        }\n    }","id":90860,"modified_method":"/**\n     * Set up the VCF writer, the sample expressions and regexs, and the JEXL matcher\n     */\n    public void initialize() {\n        // Get list of samples to include in the output\n        List<String> rodNames = Arrays.asList(variantCollection.variants.getName());\n\n        Map<String, VCFHeader> vcfRods = VCFUtils.getVCFHeadersFromRods(getToolkit(), rodNames);\n        TreeSet<String> vcfSamples = new TreeSet<String>(SampleUtils.getSampleList(vcfRods, VariantContextUtils.GenotypeMergeType.REQUIRE_UNIQUE));\n\n        Collection<String> samplesFromFile = SampleUtils.getSamplesFromFiles(sampleFiles);\n        Collection<String> samplesFromExpressions = SampleUtils.matchSamplesExpressions(vcfSamples, sampleExpressions);\n\n        // first, add any requested samples\n        samples.addAll(samplesFromFile);\n        samples.addAll(samplesFromExpressions);\n        samples.addAll(sampleNames);\n\n        // if none were requested, we want all of them\n        if ( samples.isEmpty() ) {\n            samples.addAll(vcfSamples);\n            NO_SAMPLES_SPECIFIED = true;\n        }\n\n        // now, exclude any requested samples\n        if (XLsampleFiles != null)\n            if(!XLsampleFiles.isEmpty()) {\n            Collection<String> XLsamplesFromFile = SampleUtils.getSamplesFromFiles(XLsampleFiles);\n            samples.removeAll(XLsamplesFromFile);\n            samples.removeAll(XLsampleNames);\n        }\n        if ( samples.size() == 0 && !NO_SAMPLES_SPECIFIED )\n            throw new UserException(\"All samples requested to be included were also requested to be excluded.\");\n\n        for ( String sample : samples )\n            logger.info(\"Including sample '\" + sample + \"'\");\n\n        // Initialize VCF header\n        Set<VCFHeaderLine> headerLines = VCFUtils.smartMergeHeaders(vcfRods.values(), logger);\n        headerLines.add(new VCFHeaderLine(\"source\", \"SelectVariants\"));\n\n        if (KEEP_ORIGINAL_CHR_COUNTS) {\n            headerLines.add(new VCFFormatHeaderLine(\"AC_Orig\", 1, VCFHeaderLineType.Integer, \"Original AC\"));\n            headerLines.add(new VCFFormatHeaderLine(\"AF_Orig\", 1, VCFHeaderLineType.Float, \"Original AF\"));\n            headerLines.add(new VCFFormatHeaderLine(\"AN_Orig\", 1, VCFHeaderLineType.Integer, \"Original AN\"));\n        }\n        vcfWriter.writeHeader(new VCFHeader(headerLines, samples));\n\n        for (int i = 0; i < SELECT_EXPRESSIONS.size(); i++) {\n            // It's not necessary that the user supply select names for the JEXL expressions, since those\n            // expressions will only be needed for omitting records.  Make up the select names here.\n            selectNames.add(String.format(\"select-%d\", i));\n        }\n\n        jexls = VariantContextUtils.initializeMatchExps(selectNames, SELECT_EXPRESSIONS);\n\n        // Look at the parameters to decide which analysis to perform\n        DISCORDANCE_ONLY = discordanceTrack.isBound();\n        if (DISCORDANCE_ONLY) logger.info(\"Selecting only variants discordant with the track: \" + discordanceTrack.getName());\n\n        CONCORDANCE_ONLY = concordanceTrack.isBound();\n        if (CONCORDANCE_ONLY) logger.info(\"Selecting only variants concordant with the track: \" + concordanceTrack.getName());\n\n        if (MENDELIAN_VIOLATIONS) {\n            if ( FAMILY_STRUCTURE_FILE != null) {\n                try {\n                    for ( final String line : new XReadLines( FAMILY_STRUCTURE_FILE ) ) {\n                        MendelianViolation mv = new MendelianViolation(line, MENDELIAN_VIOLATION_QUAL_THRESHOLD);\n                        if (samples.contains(mv.getSampleChild()) &&  samples.contains(mv.getSampleDad()) && samples.contains(mv.getSampleMom()))\n                            mvSet.add(mv);\n                    }\n                } catch ( FileNotFoundException e ) {\n                    throw new UserException.CouldNotReadInputFile(AF_FILE, e);\n                }\n                if (outMVFile != null)\n                    try {\n                        outMVFileStream = new PrintStream(outMVFile);\n                    }\n                    catch (FileNotFoundException e) {\n                        throw new UserException.CouldNotCreateOutputFile(outMVFile, \"Can't open output file\", e);   }\n            }\n            else\n                mvSet.add(new MendelianViolation(getToolkit(), MENDELIAN_VIOLATION_QUAL_THRESHOLD));\n        }\n        else if (!FAMILY_STRUCTURE.isEmpty()) {\n            mvSet.add(new MendelianViolation(FAMILY_STRUCTURE, MENDELIAN_VIOLATION_QUAL_THRESHOLD));\n            MENDELIAN_VIOLATIONS = true;\n        }\n\n        SELECT_RANDOM_NUMBER = numRandom > 0;\n        if (SELECT_RANDOM_NUMBER) {\n            logger.info(\"Selecting \" + numRandom + \" variants at random from the variant track\");\n            variantArray = new RandomVariantStructure[numRandom];\n        }\n\n        SELECT_RANDOM_FRACTION = fractionRandom > 0;\n        if (SELECT_RANDOM_FRACTION) logger.info(\"Selecting approximately \" + 100.0*fractionRandom + \"% of the variants at random from the variant track\");\n\n\n        if (KEEP_AF_SPECTRUM) {\n            try {\n                afBreakpoints = new ArrayList<Double>();\n                afBoosts = new ArrayList<Double>();\n                logger.info(\"Reading in AF boost table...\");\n                boolean firstLine = false;\n                for ( final String line : new XReadLines( AF_FILE ) ) {\n                    if (!firstLine) {\n                        firstLine = true;\n                        continue;\n                    }\n                    final String[] vals = line.split(\" \");\n\n                    double bkp = Double.valueOf(vals[0]);\n                    double afb = Double.valueOf(vals[1]);\n                    afBreakpoints.add(bkp);\n                    afBoosts.add(afb);\n\n                }\n                bkDelta = afBreakpoints.get(0);\n            } catch ( FileNotFoundException e ) {\n                throw new UserException.CouldNotReadInputFile(AF_FILE, e);\n            }\n\n        }\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsNoCompRod() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"a69dd3f06903b3f374c6d6f010c653e0\")\n        );\n        executeTest(\"testFundamentalsCountVariantsNoCompRod\", spec);\n    }","id":90861,"modified_method":"@Test\n    public void testFundamentalsCountVariantsNoCompRod() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"fa091aa8967893389c51102fd9f0bebb\")\n        );\n        executeTest(\"testFundamentalsCountVariantsNoCompRod\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testEvalTrackWithoutGenotypes() {\n        String extraArgs = \"-T VariantEval -R \" +\n                           b37KGReference +\n                           \" -L 20\" +\n                           \" --dbsnp \" + b37dbSNP132 +\n                           \" --eval:evalBI \" + validationDataLocation + \"VariantEval/ALL.20100201.chr20.bi.sites.vcf\" +\n                           \" -noST -ST Novelty -o %s\";\n        WalkerTestSpec spec = new WalkerTestSpec(extraArgs,1,Arrays.asList(\"cbea5f9f8c046d4c014d261db352c43b\"));\n        executeTestParallel(\"testEvalTrackWithoutGenotypes\",spec);\n    }","id":90862,"modified_method":"@Test\n    public void testEvalTrackWithoutGenotypes() {\n        String extraArgs = \"-T VariantEval -R \" +\n                           b37KGReference +\n                           \" -L 20\" +\n                           \" --dbsnp \" + b37dbSNP132 +\n                           \" --eval:evalBI \" + validationDataLocation + \"VariantEval/ALL.20100201.chr20.bi.sites.vcf\" +\n                           \" -noST -ST Novelty -o %s\";\n        WalkerTestSpec spec = new WalkerTestSpec(extraArgs,1,Arrays.asList(\"18c44636e36d6657110bf984f8eac181\"));\n        executeTestParallel(\"testEvalTrackWithoutGenotypes\",spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithDegeneracy() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST Degeneracy\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"3340587f10ceff83e5567ddfd1a9a60e\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithDegeneracy\", spec);\n    }","id":90863,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithDegeneracy() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST Degeneracy\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"15beaf3823c131cabc5fb0445239f978\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithDegeneracy\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testSelect1() {\n        String extraArgs = \"-L 1:1-10,000,000\";\n        String tests = cmdRoot +\n                \" --dbsnp \" + b36dbSNP129 +\n                \" --eval \" + validationDataLocation + \"yri.trio.gatk_glftrio.intersection.annotated.filtered.chr1.vcf\" +\n                \" --comp:comp_genotypes,VCF3 \" + validationDataLocation + \"yri.trio.gatk.ug.head.vcf\";\n        WalkerTestSpec spec = new WalkerTestSpec(withSelect(tests, \"DP < 50\", \"DP50\") + \" \" + extraArgs + \" -ST CpG -o %s\",\n                1, Arrays.asList(\"125fe0a04b5d933cc14016598b2791cd\"));\n        executeTestParallel(\"testSelect1\", spec);\n    }","id":90864,"modified_method":"@Test\n    public void testSelect1() {\n        String extraArgs = \"-L 1:1-10,000,000\";\n        String tests = cmdRoot +\n                \" --dbsnp \" + b36dbSNP129 +\n                \" --eval \" + validationDataLocation + \"yri.trio.gatk_glftrio.intersection.annotated.filtered.chr1.vcf\" +\n                \" --comp:comp_genotypes,VCF3 \" + validationDataLocation + \"yri.trio.gatk.ug.head.vcf\";\n        WalkerTestSpec spec = new WalkerTestSpec(withSelect(tests, \"DP < 50\", \"DP50\") + \" \" + extraArgs + \" -ST CpG -o %s\",\n                1, Arrays.asList(\"2df4f8911ffc3c8d042298723ed465f8\"));\n        executeTestParallel(\"testSelect1\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndels() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                                buildCommandLine(\n                                        \"-T VariantEval\",\n                                        \"-R \" + b37KGReference,\n                                        \"--dbsnp \" + b37dbSNP132,\n                                        \"--eval \" + fundamentalTestVCF,\n                                        \"-noEV\",\n                                        \"-EV CountVariants\",\n                                        \"-noST\",\n                                        \"-BTI eval\",\n                                        \"-o %s\"\n                                ),\n                                1,\n                                Arrays.asList(\"bced1842c78fbabb089dd12b7087050d\")\n                              );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndels\", spec);\n    }","id":90865,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndels() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                                buildCommandLine(\n                                        \"-T VariantEval\",\n                                        \"-R \" + b37KGReference,\n                                        \"--dbsnp \" + b37dbSNP132,\n                                        \"--eval \" + fundamentalTestVCF,\n                                        \"-noEV\",\n                                        \"-EV CountVariants\",\n                                        \"-noST\",\n                                        \"-BTI eval\",\n                                        \"-o %s\"\n                                ),\n                                1,\n                                Arrays.asList(\"1fefd6cf9c2554d5f886c3998defd4d0\")\n                              );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndels\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithFunctionalClasses() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST FunctionalClass\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"4dabe0658232f6174188515db6dfe112\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithFunctionalClass\", spec);\n    }","id":90866,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithFunctionalClasses() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST FunctionalClass\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"e40b77e7ed6581328e373a24b93cd170\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithFunctionalClass\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithNovelty() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST Novelty\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"06510bd37ffaa39e817ca0dcaf8f8ac2\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithNovelty\", spec);\n    }","id":90867,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithNovelty() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST Novelty\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"d470e00a368b5a0468012818994c6a89\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithNovelty\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithJexlExpression() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST JexlExpression\",\n                        \"-select 'DP < 20'\",\n                        \"-selectName DepthSelect\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"2559ca8f454b03e81561f6947f79df18\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithJexlExpression\", spec);\n    }","id":90868,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithJexlExpression() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST JexlExpression\",\n                        \"-select 'DP < 20'\",\n                        \"-selectName DepthSelect\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"a90f33906a732ef5eb346e559c96ccc1\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithJexlExpression\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithNoveltyAndFilter() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST Novelty\",\n                        \"-ST Filter\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"19c5b1b6396921c5b1059a2849ae4fcc\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithNoveltyAndFilter\", spec);\n    }","id":90869,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithNoveltyAndFilter() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST Novelty\",\n                        \"-ST Filter\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"12856e52c2682328f91594089328596c\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithNoveltyAndFilter\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMultipleEvalTracksWithoutGenotypes() {\n        String extraArgs = \"-T VariantEval -R \" + b37KGReference +\n                \" -L 20\" +\n                \" --dbsnp \" + b37dbSNP132 +\n                \" --eval:evalBI \" + validationDataLocation + \"VariantEval/ALL.20100201.chr20.bi.sites.vcf\" +\n                \" --eval:evalBC \" + validationDataLocation + \"VariantEval/ALL.20100201.chr20.bc.sites.vcf\" +\n                \" -noST -ST Novelty -o %s\";\n        WalkerTestSpec spec = new WalkerTestSpec(extraArgs,1,Arrays.asList(\"d07a246963ae609643620c839b20cd1e\"));\n        executeTestParallel(\"testMultipleEvalTracksWithoutGenotypes\",spec);\n    }","id":90870,"modified_method":"@Test\n    public void testMultipleEvalTracksWithoutGenotypes() {\n        String extraArgs = \"-T VariantEval -R \" + b37KGReference +\n                \" -L 20\" +\n                \" --dbsnp \" + b37dbSNP132 +\n                \" --eval:evalBI \" + validationDataLocation + \"VariantEval/ALL.20100201.chr20.bi.sites.vcf\" +\n                \" --eval:evalBC \" + validationDataLocation + \"VariantEval/ALL.20100201.chr20.bc.sites.vcf\" +\n                \" -noST -ST Novelty -o %s\";\n        WalkerTestSpec spec = new WalkerTestSpec(extraArgs,1,Arrays.asList(\"1b8ae4fd10de0888bd843f833859d990\"));\n        executeTestParallel(\"testMultipleEvalTracksWithoutGenotypes\",spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithSample() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST Sample\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"c730c7ee31c8138cef6efd8dd04fbbfc\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithSample\", spec);\n    }","id":90871,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithSample() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST Sample\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"7ddd4ee74938d229ce5cb7b9b9104abe\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithSample\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testCompVsEvalAC() {\n        String extraArgs = \"-T VariantEval -R \"+b36KGReference+\" -o %s -ST CpG -EV GenotypeConcordance --eval:evalYRI,VCF3 \" + validationDataLocation + \"yri.trio.gatk.ug.very.few.lines.vcf --comp:compYRI,VCF3 \" + validationDataLocation + \"yri.trio.gatk.fake.genotypes.ac.test.vcf\";\n        WalkerTestSpec spec = new WalkerTestSpec(extraArgs,1,Arrays.asList(\"d1932be3748fcf6da77dc51aec323710\"));\n        executeTestParallel(\"testCompVsEvalAC\",spec);\n    }","id":90872,"modified_method":"@Test\n    public void testCompVsEvalAC() {\n        String extraArgs = \"-T VariantEval -R \"+b36KGReference+\" -o %s -ST CpG -EV GenotypeConcordance --eval:evalYRI,VCF3 \" + validationDataLocation + \"yri.trio.gatk.ug.very.few.lines.vcf --comp:compYRI,VCF3 \" + validationDataLocation + \"yri.trio.gatk.fake.genotypes.ac.test.vcf\";\n        WalkerTestSpec spec = new WalkerTestSpec(extraArgs,1,Arrays.asList(\"ed54aa127b173d8ad8b6482f2a929a42\"));\n        executeTestParallel(\"testCompVsEvalAC\",spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithMultipleJexlExpressions() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST JexlExpression\",\n                        \"-select 'DP < 20'\",\n                        \"-selectName DepthLt20\",\n                        \"-select 'DP > 20'\",\n                        \"-selectName DepthGt20\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"23aa5f97641d2fd033095f21c51d2f37\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithMultipleJexlExpressions\", spec);\n    }","id":90873,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithMultipleJexlExpressions() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST JexlExpression\",\n                        \"-select 'DP < 20'\",\n                        \"-selectName DepthLt20\",\n                        \"-select 'DP > 20'\",\n                        \"-selectName DepthGt20\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"2567f90d3d7354850c5a59730ecc6e4f\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithMultipleJexlExpressions\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testAlleleCountStrat() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                                buildCommandLine(\n                                        \"-T VariantEval\",\n                                        \"-R \" + b37KGReference,\n                                        \"--dbsnp \" + b37dbSNP132,\n                                        \"--eval \" + fundamentalTestSNPsVCF,\n                                        \"-noEV\",\n                                        \"-EV CountVariants\",\n                                        \"-noST\",\n                                        \"-ST AlleleCount\",\n                                        \"-BTI eval\",\n                                        \"-o %s\"\n                                ),\n                                1,\n                                Arrays.asList(\"44464fe7c89a56cf128a932ef640f7da\")\n                              );\n        executeTest(\"testAlleleCountStrat\", spec);\n    }","id":90874,"modified_method":"@Test\n    public void testAlleleCountStrat() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                                buildCommandLine(\n                                        \"-T VariantEval\",\n                                        \"-R \" + b37KGReference,\n                                        \"--dbsnp \" + b37dbSNP132,\n                                        \"--eval \" + fundamentalTestSNPsVCF,\n                                        \"-noEV\",\n                                        \"-EV CountVariants\",\n                                        \"-noST\",\n                                        \"-ST AlleleCount\",\n                                        \"-BTI eval\",\n                                        \"-o %s\"\n                                ),\n                                1,\n                                Arrays.asList(\"da65fc8f0d0eeaf0a0b06a07f444bb8e\")\n                              );\n        executeTest(\"testAlleleCountStrat\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithCpG() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST CpG\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"a71f8d81cf166cd97ac628092650964a\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithCpG\", spec);\n    }","id":90875,"modified_method":"@Test\n    public void testFundamentalsCountVariantsSNPsAndIndelsWithCpG() {\n        WalkerTestSpec spec = new WalkerTestSpec(\n                buildCommandLine(\n                        \"-T VariantEval\",\n                        \"-R \" + b37KGReference,\n                        \"--dbsnp \" + b37dbSNP132,\n                        \"--eval \" + fundamentalTestVCF,\n                        \"-noEV\",\n                        \"-EV CountVariants\",\n                        \"-noST\",\n                        \"-ST CpG\",\n                        \"-BTI eval\",\n                        \"-o %s\"\n                ),\n                1,\n                Arrays.asList(\"91610b9240f64e0eb03cfd2602cf57af\")\n        );\n        executeTest(\"testFundamentalsCountVariantsSNPsandIndelsWithCpG\", spec);\n    }","commit_id":"782453235a808acf04ea37298a2e6ebd911c6f9a","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void removeTransientNotificationEvents(\n\t\tCollection<NotificationEvent> notificationEvents) {\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tTreeSet<NotificationEvent> notificationEventsSet =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tnotificationEventsSet.removeAll(notificationEvents);\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":90876,"modified_method":"public void removeTransientNotificationEvents(\n\t\tCollection<NotificationEvent> notificationEvents) {\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tif (_notificationEvents != null) {\n\t\t\t\t_notificationEvents.removeAll(notificationEvents);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"e4488cc904b61b321fb48bdb19f02c08e36eb6a5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void flush(long timestamp) {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tIterator<NotificationEvent> itr = notificationEvents.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr.next();\n\n\t\t\t\tif (notificationEvent.getTimestamp() < timestamp) {\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":90877,"modified_method":"public void flush(long timestamp) {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tif (_notificationEvents == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIterator<NotificationEvent> itr = _notificationEvents.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr.next();\n\n\t\t\t\tif (notificationEvent.getTimestamp() < timestamp) {\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"e4488cc904b61b321fb48bdb19f02c08e36eb6a5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void removeTransientNotificationEventsByUuid(\n\t\tCollection<String> notificationEventUuids) {\n\n\t\tSet<String> notificationEventUuidsSet = new HashSet<String>(\n\t\t\tnotificationEventUuids);\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tIterator<NotificationEvent> itr = notificationEvents.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr.next();\n\n\t\t\t\tif (notificationEventUuidsSet.contains(\n\t\t\t\t\t\tnotificationEvent.getUuid())) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":90878,"modified_method":"public void removeTransientNotificationEventsByUuid(\n\t\tCollection<String> notificationEventUuids) {\n\n\t\tSet<String> notificationEventUuidsSet = new HashSet<String>(\n\t\t\tnotificationEventUuids);\n\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tif (_notificationEvents == null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tIterator<NotificationEvent> itr = _notificationEvents.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tNotificationEvent notificationEvent = itr.next();\n\n\t\t\t\tif (notificationEventUuidsSet.contains(\n\t\t\t\t\t\tnotificationEvent.getUuid())) {\n\n\t\t\t\t\titr.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"e4488cc904b61b321fb48bdb19f02c08e36eb6a5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void flush() {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tTreeSet<NotificationEvent> notificationEvents =\n\t\t\t\t_getNotificationEvents();\n\n\t\t\tnotificationEvents.clear();\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","id":90879,"modified_method":"public void flush() {\n\t\t_reentrantLock.lock();\n\n\t\ttry {\n\t\t\tif (_notificationEvents != null) {\n\t\t\t\t_notificationEvents.clear();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t_reentrantLock.unlock();\n\t\t}\n\t}","commit_id":"e4488cc904b61b321fb48bdb19f02c08e36eb6a5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Rebuilds own menuitems according to {@link OtrContactMenu#sessionStatus}\n     * and the {@link OtrPolicy} for {@link OtrContactMenu#contact}.\n     */\n    private void buildMenu()\n    {\n        separateMenu.removeAll();\n\n        OtrPolicy policy = OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n        JMenuItem endOtr = new JMenuItem();\n        endOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.END_OTR\"));\n        endOtr.setActionCommand(ACTION_COMMAND_END_OTR);\n        endOtr.addActionListener(this);\n\n        JMenuItem startOtr = new JMenuItem();\n        startOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.START_OTR\"));\n        startOtr.setEnabled(policy.getEnableManual());\n        startOtr.setActionCommand(ACTION_COMMAND_START_OTR);\n        startOtr.addActionListener(this);\n\n        switch (this.sessionStatus)\n        {\n        case ENCRYPTED:\n            JMenuItem refreshOtr = new JMenuItem();\n            refreshOtr.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.REFRESH_OTR\"));\n            refreshOtr.setEnabled(policy.getEnableManual());\n            refreshOtr.setActionCommand(ACTION_COMMAND_REFRESH_OTR);\n            refreshOtr.addActionListener(this);\n\n            JMenuItem authBuddy = new JMenuItem();\n            authBuddy.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.AUTHENTICATE_BUDDY\"));\n            authBuddy.setActionCommand(ACTION_COMMAND_AUTHENTICATE_BUDDY);\n            authBuddy.addActionListener(this);\n\n            if (separateMenu != null)\n            {\n                separateMenu.add(endOtr);\n                separateMenu.add(refreshOtr);\n                separateMenu.add(authBuddy);\n            }\n            else\n            {\n                parentMenu.add(endOtr);\n                parentMenu.add(refreshOtr);\n                parentMenu.add(authBuddy);\n            }\n\n            break;\n\n        case FINISHED:\n            if (separateMenu != null)\n            {\n                separateMenu.add(endOtr);\n                separateMenu.add(startOtr);\n            }\n            else\n            {\n                parentMenu.add(endOtr);\n                parentMenu.add(startOtr);\n            }\n            break;\n\n        case PLAINTEXT:\n            if (separateMenu != null)\n                separateMenu.add(startOtr);\n            else\n                parentMenu.add(startOtr);\n\n            break;\n        }\n\n        JCheckBoxMenuItem cbEnable = new JCheckBoxMenuItem();\n        cbEnable.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_ENABLE\"));\n        cbEnable.setSelected(policy.getEnableManual());\n        cbEnable.setActionCommand(ACTION_COMMAND_CB_ENABLE);\n        cbEnable.addActionListener(this);\n\n        JCheckBoxMenuItem cbAlways = new JCheckBoxMenuItem();\n        cbAlways.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_AUTO\"));\n        cbAlways.setEnabled(policy.getEnableManual());\n\n        String autoInitPropValue\n            = OtrActivator.configService.getString(\n                OtrActivator.AUTO_INIT_OTR_PROP);\n        boolean isAutoInit = policy.getEnableAlways();\n        if (autoInitPropValue != null)\n            isAutoInit = Boolean.parseBoolean(autoInitPropValue);\n\n        cbAlways.setSelected(isAutoInit);\n\n        cbAlways.setActionCommand(ACTION_COMMAND_CB_AUTO);\n        cbAlways.addActionListener(this);\n\n        JCheckBoxMenuItem cbRequire = new JCheckBoxMenuItem();\n        cbRequire.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_REQUIRE\"));\n        cbRequire.setEnabled(policy.getEnableManual());\n\n        String otrMandatoryPropValue\n            = OtrActivator.configService.getString(\n                OtrActivator.OTR_MANDATORY_PROP);\n        String defaultOtrPropValue\n            = OtrActivator.resourceService.getSettingsString(\n                OtrActivator.OTR_MANDATORY_PROP);\n\n        boolean isMandatory = policy.getRequireEncryption();\n        if (otrMandatoryPropValue != null)\n            isMandatory = Boolean.parseBoolean(otrMandatoryPropValue);\n        else if (!isMandatory && defaultOtrPropValue != null)\n            isMandatory = Boolean.parseBoolean(defaultOtrPropValue);\n\n        cbRequire.setSelected(isMandatory);\n\n        cbRequire.setActionCommand(ACTION_COMMAND_CB_REQUIRE);\n        cbRequire.addActionListener(this);\n\n        JMenuItem cbReset = new JMenuItem();\n        cbReset.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_RESET\"));\n        cbReset.setActionCommand(ACTION_COMMAND_CB_RESET);\n        cbReset.addActionListener(this);\n\n        if (separateMenu != null)\n        {\n            separateMenu.addSeparator();\n            separateMenu.add(cbEnable);\n            separateMenu.add(cbAlways);\n            separateMenu.add(cbRequire);\n            separateMenu.addSeparator();\n            separateMenu.add(cbReset);\n\n            parentMenu.add(separateMenu);\n        }\n        else\n        {\n            parentMenu.addSeparator();\n            parentMenu.add(cbEnable);\n            parentMenu.add(cbAlways);\n            parentMenu.add(cbRequire);\n            parentMenu.addSeparator();\n            parentMenu.add(cbReset);\n        }\n    }","id":90880,"modified_method":"/**\n     * Rebuilds own menuitems according to {@link OtrContactMenu#sessionStatus}\n     * and the {@link OtrPolicy} for {@link OtrContactMenu#contact}.\n     */\n    private void buildMenu()\n    {\n        if(separateMenu != null)\n            separateMenu.removeAll();\n\n        OtrPolicy policy = OtrActivator.scOtrEngine.getContactPolicy(contact);\n\n        JMenuItem endOtr = new JMenuItem();\n        endOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.END_OTR\"));\n        endOtr.setActionCommand(ACTION_COMMAND_END_OTR);\n        endOtr.addActionListener(this);\n\n        JMenuItem startOtr = new JMenuItem();\n        startOtr.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.START_OTR\"));\n        startOtr.setEnabled(policy.getEnableManual());\n        startOtr.setActionCommand(ACTION_COMMAND_START_OTR);\n        startOtr.addActionListener(this);\n\n        switch (this.sessionStatus)\n        {\n        case ENCRYPTED:\n            JMenuItem refreshOtr = new JMenuItem();\n            refreshOtr.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.REFRESH_OTR\"));\n            refreshOtr.setEnabled(policy.getEnableManual());\n            refreshOtr.setActionCommand(ACTION_COMMAND_REFRESH_OTR);\n            refreshOtr.addActionListener(this);\n\n            JMenuItem authBuddy = new JMenuItem();\n            authBuddy.setText(OtrActivator.resourceService\n                .getI18NString(\"plugin.otr.menu.AUTHENTICATE_BUDDY\"));\n            authBuddy.setActionCommand(ACTION_COMMAND_AUTHENTICATE_BUDDY);\n            authBuddy.addActionListener(this);\n\n            if (separateMenu != null)\n            {\n                separateMenu.add(endOtr);\n                separateMenu.add(refreshOtr);\n                separateMenu.add(authBuddy);\n            }\n            else\n            {\n                parentMenu.add(endOtr);\n                parentMenu.add(refreshOtr);\n                parentMenu.add(authBuddy);\n            }\n\n            break;\n\n        case FINISHED:\n            if (separateMenu != null)\n            {\n                separateMenu.add(endOtr);\n                separateMenu.add(startOtr);\n            }\n            else\n            {\n                parentMenu.add(endOtr);\n                parentMenu.add(startOtr);\n            }\n            break;\n\n        case PLAINTEXT:\n            if (separateMenu != null)\n                separateMenu.add(startOtr);\n            else\n                parentMenu.add(startOtr);\n\n            break;\n        }\n\n        JCheckBoxMenuItem cbEnable = new JCheckBoxMenuItem();\n        cbEnable.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_ENABLE\"));\n        cbEnable.setSelected(policy.getEnableManual());\n        cbEnable.setActionCommand(ACTION_COMMAND_CB_ENABLE);\n        cbEnable.addActionListener(this);\n\n        JCheckBoxMenuItem cbAlways = new JCheckBoxMenuItem();\n        cbAlways.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_AUTO\"));\n        cbAlways.setEnabled(policy.getEnableManual());\n\n        String autoInitPropValue\n            = OtrActivator.configService.getString(\n                OtrActivator.AUTO_INIT_OTR_PROP);\n        boolean isAutoInit = policy.getEnableAlways();\n        if (autoInitPropValue != null)\n            isAutoInit = Boolean.parseBoolean(autoInitPropValue);\n\n        cbAlways.setSelected(isAutoInit);\n\n        cbAlways.setActionCommand(ACTION_COMMAND_CB_AUTO);\n        cbAlways.addActionListener(this);\n\n        JCheckBoxMenuItem cbRequire = new JCheckBoxMenuItem();\n        cbRequire.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_REQUIRE\"));\n        cbRequire.setEnabled(policy.getEnableManual());\n\n        String otrMandatoryPropValue\n            = OtrActivator.configService.getString(\n                OtrActivator.OTR_MANDATORY_PROP);\n        String defaultOtrPropValue\n            = OtrActivator.resourceService.getSettingsString(\n                OtrActivator.OTR_MANDATORY_PROP);\n\n        boolean isMandatory = policy.getRequireEncryption();\n        if (otrMandatoryPropValue != null)\n            isMandatory = Boolean.parseBoolean(otrMandatoryPropValue);\n        else if (!isMandatory && defaultOtrPropValue != null)\n            isMandatory = Boolean.parseBoolean(defaultOtrPropValue);\n\n        cbRequire.setSelected(isMandatory);\n\n        cbRequire.setActionCommand(ACTION_COMMAND_CB_REQUIRE);\n        cbRequire.addActionListener(this);\n\n        JMenuItem cbReset = new JMenuItem();\n        cbReset.setText(OtrActivator.resourceService\n            .getI18NString(\"plugin.otr.menu.CB_RESET\"));\n        cbReset.setActionCommand(ACTION_COMMAND_CB_RESET);\n        cbReset.addActionListener(this);\n\n        if (separateMenu != null)\n        {\n            separateMenu.addSeparator();\n            separateMenu.add(cbEnable);\n            separateMenu.add(cbAlways);\n            separateMenu.add(cbRequire);\n            separateMenu.addSeparator();\n            separateMenu.add(cbReset);\n\n            parentMenu.add(separateMenu);\n        }\n        else\n        {\n            parentMenu.addSeparator();\n            parentMenu.add(cbEnable);\n            parentMenu.add(cbAlways);\n            parentMenu.add(cbRequire);\n            parentMenu.addSeparator();\n            parentMenu.add(cbReset);\n        }\n    }","commit_id":"0ea9b7f99567b549e366bf28c653920bfff9248f","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void rebuildTree(Collection<BreakpointItem> items) {\n    List<BreakpointItem> selectedBreakpoints = getSelectedBreakpoints();\n    TreePath path = myTreeView.getSelectionPath();\n    buildTree(items);\n    if (myTreeView.getRowForPath(path) == -1 && !selectedBreakpoints.isEmpty()) {\n      selectBreakpointItem(selectedBreakpoints.get(0), path);\n    }\n    else {\n      selectBreakpointItem(null, path);\n    }\n  }","id":90881,"modified_method":"public void rebuildTree(Collection<BreakpointItem> items) {\n    List<BreakpointItem> selectedBreakpoints = getSelectedBreakpoints(false);\n    TreePath path = myTreeView.getSelectionPath();\n    buildTree(items);\n    if (myTreeView.getRowForPath(path) == -1 && !selectedBreakpoints.isEmpty()) {\n      selectBreakpointItem(selectedBreakpoints.get(0), path);\n    }\n    else {\n      selectBreakpointItem(null, path);\n    }\n  }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void removeSelectedBreakpoints(Project project) {\n    final TreePath[] paths = myTreeView.getSelectionPaths();\n    if (paths == null) return;\n    final List<BreakpointItem> breakpoints = getSelectedBreakpoints();\n    for (TreePath path : paths) {\n      final Object node = path.getLastPathComponent();\n      if (node instanceof BreakpointItemNode) {\n        final BreakpointItem item = ((BreakpointItemNode)node).getBreakpointItem();\n        if (!item.allowedToRemove()) {\n          TreeUtil.unselect(myTreeView, (DefaultMutableTreeNode)node);\n          breakpoints.remove(item);\n        }\n      }\n    }\n    if (breakpoints.isEmpty()) return;\n    TreeUtil.removeSelected(myTreeView);\n    for (BreakpointItem breakpoint : breakpoints) {\n      breakpoint.removed(project);\n    }\n  }","id":90882,"modified_method":"public void removeSelectedBreakpoints(Project project) {\n    final TreePath[] paths = myTreeView.getSelectionPaths();\n    if (paths == null) return;\n    final List<BreakpointItem> breakpoints = getSelectedBreakpoints(true);\n    for (TreePath path : paths) {\n      final Object node = path.getLastPathComponent();\n      if (node instanceof BreakpointItemNode) {\n        final BreakpointItem item = ((BreakpointItemNode)node).getBreakpointItem();\n        if (!item.allowedToRemove()) {\n          TreeUtil.unselect(myTreeView, (DefaultMutableTreeNode)node);\n          breakpoints.remove(item);\n        }\n      }\n    }\n    if (breakpoints.isEmpty()) return;\n    TreeUtil.removeSelected(myTreeView);\n    for (BreakpointItem breakpoint : breakpoints) {\n      breakpoint.removed(project);\n    }\n  }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<BreakpointItem> getSelectedBreakpoints() {\n    TreePath[] selectionPaths = myTreeView.getSelectionPaths();\n    if (selectionPaths == null || selectionPaths.length == 0) return Collections.emptyList();\n\n    final ArrayList<BreakpointItem> list = new ArrayList<BreakpointItem>();\n    for (TreePath selectionPath : selectionPaths) {\n      TreeUtil.traverseDepth((TreeNode)selectionPath.getLastPathComponent(), new TreeUtil.Traverse() {\n        public boolean accept(final Object node) {\n          if (node instanceof BreakpointItemNode) {\n            list.add(((BreakpointItemNode)node).getBreakpointItem());\n          }\n          return true;\n        }\n      });\n    }\n\n    return list;\n  }","id":90883,"modified_method":"public List<BreakpointItem> getSelectedBreakpoints(boolean traverse) {\n    TreePath[] selectionPaths = myTreeView.getSelectionPaths();\n    if (selectionPaths == null || selectionPaths.length == 0) return Collections.emptyList();\n\n    final ArrayList<BreakpointItem> list = new ArrayList<BreakpointItem>();\n    for (TreePath selectionPath : selectionPaths) {\n      TreeNode startNode = (TreeNode)selectionPath.getLastPathComponent();\n      if (traverse) {\n        TreeUtil.traverseDepth(startNode, new TreeUtil.Traverse() {\n          public boolean accept(final Object node) {\n            if (node instanceof BreakpointItemNode) {\n              list.add(((BreakpointItemNode)node).getBreakpointItem());\n            }\n            return true;\n          }\n        });\n      }\n      else {\n        if (startNode instanceof BreakpointItemNode) {\n          list.add(((BreakpointItemNode)startNode).getBreakpointItem());\n        }\n      }\n    }\n\n    return list;\n  }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void initSelection(Collection<BreakpointItem> breakpoints) {\n    XBreakpointsDialogState settings = (getBreakpointManager()).getBreakpointsDialogSettings();\n    if (settings != null && settings.getTreeState() != null) {\n      settings.getTreeState().applyTo(myTreeController.getTreeView());\n    }\n    else {\n      TreeUtil.expandAll(myTreeController.getTreeView());\n    }\n    selectBreakpoint(myInitialBreakpoint);\n  }","id":90884,"modified_method":"void initSelection(Collection<BreakpointItem> breakpoints) {\n    XBreakpointsDialogState settings = (getBreakpointManager()).getBreakpointsDialogSettings();\n    if (settings != null && settings.getTreeState() != null) {\n      settings.getTreeState().applyTo(myTreeController.getTreeView());\n      if (myTreeController.getTreeView().getSelectionCount() == 0) {\n        myTreeController.selectFirstBreakpointItem();\n      }\n    }\n    else {\n      TreeUtil.expandAll(myTreeController.getTreeView());\n      myTreeController.selectFirstBreakpointItem();\n    }\n    selectBreakpoint(myInitialBreakpoint);\n  }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createMasterView() {\n    myTreeController = new BreakpointItemsTreeController(myRulesEnabled) {\n      @Override\n      public void nodeStateWillChangeImpl(CheckedTreeNode node) {\n        if (node instanceof BreakpointItemNode) {\n          ((BreakpointItemNode)node).getBreakpointItem().saveState();\n        }\n        super.nodeStateWillChangeImpl(node);\n      }\n\n      @Override\n      public void nodeStateDidChangeImpl(CheckedTreeNode node) {\n        super.nodeStateDidChangeImpl(node);\n        if (node instanceof BreakpointItemNode) {\n          myDetailController.doUpdateDetailView(true);\n        }\n      }\n\n      @Override\n      protected void selectionChangedImpl() {\n        super.selectionChangedImpl();\n        saveCurrentItem();\n        myDetailController.updateDetailView();\n      }\n    };\n    final JTree tree = new BreakpointsCheckboxTree(myProject, myTreeController) {\n      @Override\n      protected void onDoubleClick(CheckedTreeNode node) {\n        if (node instanceof BreakpointsGroupNode) {\n          TreePath path = TreeUtil.getPathFromRoot(node);\n          if (isExpanded(path)) {\n            collapsePath(path);\n          }\n          else {\n            expandPath(path);\n          }\n        }\n        else {\n          navigate(false);\n        }\n      }\n    };\n\n    PopupHandler.installPopupHandler(tree, new ActionGroup() {\n      @NotNull\n      @Override\n      public AnAction[] getChildren(@Nullable AnActionEvent e) {\n        ActionGroup group = new ActionGroup(\"Move to group\", true) {\n          @NotNull\n          @Override\n          public AnAction[] getChildren(@Nullable AnActionEvent e) {\n            Set<String> groups = getBreakpointManager().getAllGroups();\n            AnAction[] res = new AnAction[groups.size()+3];\n            int i = 0;\n            res[i++] = new MoveToGroupAction(null);\n            for (String group : groups) {\n              res[i++] = new MoveToGroupAction(group);\n            }\n            res[i++] = new Separator();\n            res[i] = new MoveToGroupAction();\n            return res;\n          }\n        };\n        List<AnAction> res = new ArrayList<AnAction>();\n        res.add(group);\n        Object component = tree.getLastSelectedPathComponent();\n        if (tree.getSelectionCount() == 1 && component instanceof BreakpointsGroupNode &&\n            ((BreakpointsGroupNode)component).getGroup() instanceof XBreakpointCustomGroup) {\n          res.add(new SetAsDefaultGroupAction((XBreakpointCustomGroup)((BreakpointsGroupNode)component).getGroup()));\n        }\n        if (tree.getSelectionCount() == 1 && component instanceof BreakpointItemNode) {\n          res.add(new EditDescriptionAction((XBreakpointBase)((BreakpointItemNode)component).getBreakpointItem().getBreakpoint()));\n        }\n        return res.toArray(new AnAction[res.size()]);\n      }\n    }, ActionPlaces.UNKNOWN, ActionManager.getInstance());\n\n    new AnAction(\"BreakpointDialog.GoToSource\") {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        navigate(true);\n        close(OK_EXIT_CODE);\n      }\n    }.registerCustomShortcutSet(CommonShortcuts.ENTER, tree);\n\n    new AnAction(\"BreakpointDialog.ShowSource\") {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        navigate(true);\n        close(OK_EXIT_CODE);\n      }\n    }.registerCustomShortcutSet(ActionManager.getInstance().getAction(IdeActions.ACTION_EDIT_SOURCE).getShortcutSet(), tree);\n\n    final DefaultActionGroup breakpointTypes = new DefaultActionGroup();\n    for (XBreakpointType<?, ?> type : XBreakpointUtil.getBreakpointTypes()) {\n      if (type.isAddBreakpointButtonVisible()) {\n        breakpointTypes.addAll(new AddXBreakpointAction(type));\n      }\n    }\n\n    ToolbarDecorator decorator = ToolbarDecorator.createDecorator(tree).\n      setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          JBPopupFactory.getInstance()\n            .createActionGroupPopup(null, breakpointTypes, DataManager.getInstance().getDataContext(button.getContextComponent()),\n                                    JBPopupFactory.ActionSelectionAid.NUMBERING, false)\n            .show(button.getPreferredPopupPoint());\n        }\n      }).\n      setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          myTreeController.removeSelectedBreakpoints(myProject);\n        }\n      }).\n      setRemoveActionUpdater(new AnActionButtonUpdater() {\n        @Override\n        public boolean isEnabled(AnActionEvent e) {\n          boolean enabled = false;\n          final ItemWrapper[] items = myMasterController.getSelectedItems();\n          for (ItemWrapper item : items) {\n            if (item.allowedToRemove()) {\n              enabled = true;\n            }\n          }\n          return enabled;\n        }\n      }).\n      setToolbarPosition(ActionToolbarPosition.TOP).\n      setToolbarBorder(IdeBorderFactory.createEmptyBorder());\n\n    tree.setBorder(IdeBorderFactory.createBorder());\n\n    for (ToggleActionButton action : myToggleRuleActions) {\n      decorator.addExtraAction(action);\n    }\n\n    JPanel decoratedTree = decorator.createPanel();\n    decoratedTree.setBorder(IdeBorderFactory.createEmptyBorder());\n\n    myTreeController.setTreeView(tree);\n\n    myTreeController.buildTree(myBreakpointItems);\n\n    initSelection(myBreakpointItems);\n\n    final BreakpointPanelProvider.BreakpointsListener listener = new BreakpointPanelProvider.BreakpointsListener() {\n      @Override\n      public void breakpointsChanged() {\n        myRebuildAlarm.cancelAndRequest();\n      }\n    };\n\n    for (BreakpointPanelProvider provider : myBreakpointsPanelProviders) {\n      provider.addListener(listener, myProject, myListenerDisposable);\n    }\n\n    return decoratedTree;\n  }","id":90885,"modified_method":"private JComponent createMasterView() {\n    myTreeController = new BreakpointItemsTreeController(myRulesEnabled) {\n      @Override\n      public void nodeStateWillChangeImpl(CheckedTreeNode node) {\n        if (node instanceof BreakpointItemNode) {\n          ((BreakpointItemNode)node).getBreakpointItem().saveState();\n        }\n        super.nodeStateWillChangeImpl(node);\n      }\n\n      @Override\n      public void nodeStateDidChangeImpl(CheckedTreeNode node) {\n        super.nodeStateDidChangeImpl(node);\n        if (node instanceof BreakpointItemNode) {\n          myDetailController.doUpdateDetailView(true);\n        }\n      }\n\n      @Override\n      protected void selectionChangedImpl() {\n        super.selectionChangedImpl();\n        saveCurrentItem();\n        myDetailController.updateDetailView();\n      }\n    };\n    final JTree tree = new BreakpointsCheckboxTree(myProject, myTreeController) {\n      @Override\n      protected void onDoubleClick(CheckedTreeNode node) {\n        if (node instanceof BreakpointsGroupNode) {\n          TreePath path = TreeUtil.getPathFromRoot(node);\n          if (isExpanded(path)) {\n            collapsePath(path);\n          }\n          else {\n            expandPath(path);\n          }\n        }\n        else {\n          navigate(false);\n        }\n      }\n    };\n\n    PopupHandler.installPopupHandler(tree, new ActionGroup() {\n      @NotNull\n      @Override\n      public AnAction[] getChildren(@Nullable AnActionEvent e) {\n        ActionGroup group = new ActionGroup(\"Move to group\", true) {\n          @NotNull\n          @Override\n          public AnAction[] getChildren(@Nullable AnActionEvent e) {\n            Set<String> groups = getBreakpointManager().getAllGroups();\n            AnAction[] res = new AnAction[groups.size()+3];\n            int i = 0;\n            res[i++] = new MoveToGroupAction(null);\n            for (String group : groups) {\n              res[i++] = new MoveToGroupAction(group);\n            }\n            res[i++] = new Separator();\n            res[i] = new MoveToGroupAction();\n            return res;\n          }\n        };\n        List<AnAction> res = new ArrayList<AnAction>();\n        res.add(group);\n        Object component = tree.getLastSelectedPathComponent();\n        if (tree.getSelectionCount() == 1 && component instanceof BreakpointsGroupNode &&\n            ((BreakpointsGroupNode)component).getGroup() instanceof XBreakpointCustomGroup) {\n          res.add(new SetAsDefaultGroupAction((XBreakpointCustomGroup)((BreakpointsGroupNode)component).getGroup()));\n        }\n        if (tree.getSelectionCount() == 1 && component instanceof BreakpointItemNode) {\n          res.add(new EditDescriptionAction((XBreakpointBase)((BreakpointItemNode)component).getBreakpointItem().getBreakpoint()));\n        }\n        return res.toArray(new AnAction[res.size()]);\n      }\n    }, ActionPlaces.UNKNOWN, ActionManager.getInstance());\n\n    new AnAction(\"BreakpointDialog.GoToSource\") {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        navigate(true);\n        close(OK_EXIT_CODE);\n      }\n    }.registerCustomShortcutSet(CommonShortcuts.ENTER, tree);\n\n    new AnAction(\"BreakpointDialog.ShowSource\") {\n      @Override\n      public void actionPerformed(AnActionEvent e) {\n        navigate(true);\n        close(OK_EXIT_CODE);\n      }\n    }.registerCustomShortcutSet(ActionManager.getInstance().getAction(IdeActions.ACTION_EDIT_SOURCE).getShortcutSet(), tree);\n\n    final DefaultActionGroup breakpointTypes = new DefaultActionGroup();\n    for (XBreakpointType<?, ?> type : XBreakpointUtil.getBreakpointTypes()) {\n      if (type.isAddBreakpointButtonVisible()) {\n        breakpointTypes.addAll(new AddXBreakpointAction(type));\n      }\n    }\n\n    ToolbarDecorator decorator = ToolbarDecorator.createDecorator(tree).\n      setAddAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          JBPopupFactory.getInstance()\n            .createActionGroupPopup(null, breakpointTypes, DataManager.getInstance().getDataContext(button.getContextComponent()),\n                                    JBPopupFactory.ActionSelectionAid.NUMBERING, false)\n            .show(button.getPreferredPopupPoint());\n        }\n      }).\n      setRemoveAction(new AnActionButtonRunnable() {\n        @Override\n        public void run(AnActionButton button) {\n          myTreeController.removeSelectedBreakpoints(myProject);\n        }\n      }).\n      setRemoveActionUpdater(new AnActionButtonUpdater() {\n        @Override\n        public boolean isEnabled(AnActionEvent e) {\n          for (BreakpointItem item : myTreeController.getSelectedBreakpoints(true)) {\n            if (item.allowedToRemove()) {\n              return true;\n            }\n          }\n          return false;\n        }\n      }).\n      setToolbarPosition(ActionToolbarPosition.TOP).\n      setToolbarBorder(IdeBorderFactory.createEmptyBorder());\n\n    tree.setBorder(IdeBorderFactory.createBorder());\n\n    for (ToggleActionButton action : myToggleRuleActions) {\n      decorator.addExtraAction(action);\n    }\n\n    JPanel decoratedTree = decorator.createPanel();\n    decoratedTree.setBorder(IdeBorderFactory.createEmptyBorder());\n\n    myTreeController.setTreeView(tree);\n\n    myTreeController.buildTree(myBreakpointItems);\n\n    initSelection(myBreakpointItems);\n\n    final BreakpointPanelProvider.BreakpointsListener listener = new BreakpointPanelProvider.BreakpointsListener() {\n      @Override\n      public void breakpointsChanged() {\n        myRebuildAlarm.cancelAndRequest();\n      }\n    };\n\n    for (BreakpointPanelProvider provider : myBreakpointsPanelProviders) {\n      provider.addListener(listener, myProject, myListenerDisposable);\n    }\n\n    return decoratedTree;\n  }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createDetailView() {\n    DetailViewImpl detailView = new DetailViewImpl(myProject);\n    myDetailController.setDetailView(detailView);\n\n    return detailView;\n  }","id":90886,"modified_method":"private JComponent createDetailView() {\n    DetailViewImpl detailView = new DetailViewImpl(myProject);\n    detailView.setEmptyLabel(XDebuggerBundle.message(\"xbreakpoint.label.empty\"));\n    myDetailController.setDetailView(detailView);\n\n    return detailView;\n  }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void navigate(final boolean requestFocus) {\n    List<BreakpointItem> breakpoints = myTreeController.getSelectedBreakpoints();\n    if (!breakpoints.isEmpty()) {\n      breakpoints.get(0).navigate(requestFocus);\n    }\n  }","id":90887,"modified_method":"private void navigate(final boolean requestFocus) {\n    List<BreakpointItem> breakpoints = myTreeController.getSelectedBreakpoints(false);\n    if (!breakpoints.isEmpty()) {\n      breakpoints.get(0).navigate(requestFocus);\n    }\n  }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void actionPerformed(AnActionEvent e) {\n      String groupName = myGroup;\n      if (myNewGroup) {\n        groupName = Messages.showInputDialog(\"New group name\", \"New Group\", AllIcons.Nodes.NewFolder);\n        if (groupName == null) {\n          return;\n        }\n      }\n      for (BreakpointItem item : myTreeController.getSelectedBreakpoints()) {\n        Object breakpoint = item.getBreakpoint();\n        if (breakpoint instanceof XBreakpointBase) {\n          ((XBreakpointBase)breakpoint).setGroup(groupName);\n        }\n      }\n      myTreeController.rebuildTree(myBreakpointItems);\n    }","id":90888,"modified_method":"@Override\n    public void actionPerformed(AnActionEvent e) {\n      String groupName = myGroup;\n      if (myNewGroup) {\n        groupName = Messages.showInputDialog(\"New group name\", \"New Group\", AllIcons.Nodes.NewFolder);\n        if (groupName == null) {\n          return;\n        }\n      }\n      for (BreakpointItem item : myTreeController.getSelectedBreakpoints(true)) {\n        Object breakpoint = item.getBreakpoint();\n        if (breakpoint instanceof XBreakpointBase) {\n          ((XBreakpointBase)breakpoint).setGroup(groupName);\n        }\n      }\n      myTreeController.rebuildTree(myBreakpointItems);\n    }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void setPropertiesPanel(@Nullable final JPanel panel) {\n    if (panel == myDetailPanel) return;\n\n    if (panel != null) {\n      if (myDetailPanelWrapper == null) {\n        myDetailPanelWrapper = new JPanel(new GridLayout(1, 1));\n        myDetailPanelWrapper.setBorder(IdeBorderFactory.createEmptyBorder(5, 5, 5, 5));\n        myDetailPanelWrapper.add(panel);\n\n        add(myDetailPanelWrapper, BorderLayout.NORTH);\n      } else {\n        myDetailPanelWrapper.removeAll();\n        myDetailPanelWrapper.add(panel);\n      }\n    }\n    else {\n      myDetailPanelWrapper.removeAll();\n      myLabel.setText(\"Nothing to show\");\n      add(myLabel, BorderLayout.CENTER);\n    }\n    myDetailPanel = panel;\n    revalidate();\n  }","id":90889,"modified_method":"@Override\n  public void setPropertiesPanel(@Nullable final JPanel panel) {\n    if (panel == null) {\n      if (myDetailPanelWrapper != null) {\n        myDetailPanelWrapper.removeAll();\n      }\n      myLabel.setText(myEmptyLabel);\n      add(myLabel, BorderLayout.CENTER);\n    }\n    else if (panel != myDetailPanel) {\n      if (myDetailPanelWrapper == null) {\n        myDetailPanelWrapper = new JPanel(new GridLayout(1, 1));\n        myDetailPanelWrapper.setBorder(IdeBorderFactory.createEmptyBorder(5, 5, 5, 5));\n        myDetailPanelWrapper.add(panel);\n\n        add(myDetailPanelWrapper, BorderLayout.NORTH);\n      } else {\n        myDetailPanelWrapper.removeAll();\n        myDetailPanelWrapper.add(panel);\n      }\n    }\n    myDetailPanel = panel;\n    revalidate();\n  }","commit_id":"91859436217e2e87ea79986ed2ec0798ce0b2f47","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void dispose() {\n    myWidgetMap.clear();\n    myChildren.clear();\n\n    myLeftPanel.removeAll();\n    myRightPanel.removeAll();\n    myCenterPanel.removeAll();\n  }","id":90890,"modified_method":"public void dispose() {\n    myWidgetMap.clear();\n    myChildren.clear();\n\n    if (myLeftPanel != null) myLeftPanel.removeAll();\n    if (myRightPanel != null) myRightPanel.removeAll();\n    if (myCenterPanel != null) myCenterPanel.removeAll();\n  }","commit_id":"eaef6ec632875c1439ec426c355b43db1fd7eb5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void main(String args[]) throws Exception {\n        ClientProxyFactoryBean factory = new ClientProxyFactoryBean();\n        factory.setServiceClass(HelloWorld.class);\n        if (args != null && args.length > 0 && !\"\".equals(args[0])) {\n            factory.setAddress(args[0]);\n        } else {\n            factory.setAddress(\"http://localhost:9000/Hello\");\n        }\n        //factory.getServiceFactory().setDataBinding(new AegisDatabinding());\n        HelloWorld client = (HelloWorld)factory.create();\n        System.out.println(\"Invoke sayHi()....\");\n        System.out.println(client.sayHi(System.getProperty(\"user.name\")));\n        System.exit(0);\n    }","id":90891,"modified_method":"public static void main(String args[]) throws Exception {\n        ClientProxyFactoryBean factory = new ClientProxyFactoryBean();\n        if (args != null && args.length > 0 && !\"\".equals(args[0])) {\n            factory.setAddress(args[0]);\n        } else {\n            factory.setAddress(\"http://localhost:9000/Hello\");\n        }\n        HelloWorld client = factory.create(HelloWorld.class);\n        System.out.println(\"Invoke sayHi()....\");\n        System.out.println(client.sayHi(System.getProperty(\"user.name\")));\n        System.exit(0);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"public static void main(String args[]) throws Exception {\n        ClientProxyFactoryBean factory = new ClientProxyFactoryBean();\n        factory.setServiceClass(HelloWorld.class);\n        if (args != null && args.length > 0 && !\"\".equals(args[0])) {\n            factory.setAddress(args[0]);\n        } else {\n            factory.setAddress(\"http://localhost:9000/Hello\");\n        }\n        factory.getServiceFactory().setDataBinding(new AegisDatabinding());\n        HelloWorld client = (HelloWorld)factory.create();\n        System.out.println(\"Invoke sayHi()....\");\n        System.out.println(client.sayHi(System.getProperty(\"user.name\")));\n        Document doc = client.getADocument();\n        Element e = (Element) doc.getFirstChild();\n        System.out.println(e.getTagName());\n        Text t = (Text) e.getFirstChild();\n        System.out.println(t);\n    }","id":90892,"modified_method":"public static void main(String args[]) throws Exception {\n        ClientProxyFactoryBean factory = new ClientProxyFactoryBean();\n        if (args != null && args.length > 0 && !\"\".equals(args[0])) {\n            factory.setAddress(args[0]);\n        } else {\n            factory.setAddress(\"http://localhost:9000/Hello\");\n        }\n        factory.getServiceFactory().setDataBinding(new AegisDatabinding());\n        HelloWorld client = factory.create(HelloWorld.class);\n        System.out.println(\"Invoke sayHi()....\");\n        System.out.println(client.sayHi(System.getProperty(\"user.name\")));\n        Document doc = client.getADocument();\n        Element e = (Element) doc.getFirstChild();\n        System.out.println(e.getTagName());\n        Text t = (Text) e.getFirstChild();\n        System.out.println(t);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"public static void main(String args[]) throws Exception {\n        ClientProxyFactoryBean factory = new ClientProxyFactoryBean();\n        factory.setServiceClass(HelloWorld.class);\n        String serviceURL;\n        if (args != null && args.length > 0 && !\"\".equals(args[0])) {\n            serviceURL = args[0];\n        } else {\n            serviceURL = \"http://localhost:9000/Hello\";\n        }\n        factory.setServiceName(new QName(\"http://server.hw.demo/\", \"HelloWorldService\"));\n        factory.setAddress(serviceURL);\n        factory.setWsdlURL(serviceURL + \"?wsdl\");\n        factory.getServiceFactory().setDataBinding(new AegisDatabinding());\n        HelloWorld client = (HelloWorld)factory.create();\n        System.out.println(\"Invoke sayHi()....\");\n        System.out.println(client.sayHi(System.getProperty(\"user.name\")));\n        System.exit(0);\n    }","id":90893,"modified_method":"public static void main(String args[]) throws Exception {\n        ClientProxyFactoryBean factory = new ClientProxyFactoryBean();\n        String serviceURL;\n        if (args != null && args.length > 0 && !\"\".equals(args[0])) {\n            serviceURL = args[0];\n        } else {\n            serviceURL = \"http://localhost:9000/Hello\";\n        }\n        factory.setServiceName(new QName(\"http://server.hw.demo/\", \"HelloWorldService\"));\n        factory.setAddress(serviceURL);\n        factory.setWsdlURL(serviceURL + \"?wsdl\");\n        factory.getServiceFactory().setDataBinding(new AegisDatabinding());\n        HelloWorld client = factory.create(HelloWorld.class);\n        System.out.println(\"Invoke sayHi()....\");\n        System.out.println(client.sayHi(System.getProperty(\"user.name\")));\n        System.exit(0);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"public static void main(String args[]) throws Exception {\n        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();\n        factory.getInInterceptors().add(new LoggingInInterceptor());\n        factory.getOutInterceptors().add(new LoggingOutInterceptor());\n        factory.setServiceClass(HelloWorld.class);\n        factory.setAddress(\"http://localhost:9000/helloWorld\");\n        HelloWorld client = (HelloWorld) factory.create();\n        System.out.println(client.sayHi(\"World\"));\n    }","id":90894,"modified_method":"public static void main(String args[]) throws Exception {\n        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();\n        factory.getInInterceptors().add(new LoggingInInterceptor());\n        factory.getOutInterceptors().add(new LoggingOutInterceptor());\n        factory.setAddress(\"http://localhost:9000/helloWorld\");\n        HelloWorld client = factory.create(HelloWorld.class);\n        System.out.println(client.sayHi(\"World\"));\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"private static HelloWorld createClientCxf() {\n        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();\n        factory.setServiceClass(HelloWorld.class);\n        factory.setTransportId(JMSSpecConstants.SOAP_JMS_SPECIFICATION_TRANSPORTID);\n        factory.setAddress(JMS_ENDPOINT_URI);\n        HelloWorld client = (HelloWorld)factory.create();\n        return client;\n    }","id":90895,"modified_method":"private static HelloWorld createClientCxf() {\n        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();\n        factory.setTransportId(JMSSpecConstants.SOAP_JMS_SPECIFICATION_TRANSPORTID);\n        factory.setAddress(JMS_ENDPOINT_URI);\n        HelloWorld client = factory.create(HelloWorld.class);\n        return client;\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void ordinaryParamNameTest() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        ReflectionServiceFactoryBean factory = new ReflectionServiceFactoryBean();\n        proxyFac.setServiceFactory(factory);\n        proxyFac.setDataBinding(new AegisDatabinding());\n\n        proxyFac.setAddress(\"local://Echo\");\n        proxyFac.setServiceClass(Echo.class);\n        proxyFac.setBus(getBus());\n\n        Echo echo = (Echo)proxyFac.create();\n        String boing = echo.simpleEcho(\"reflection\");\n        assertEquals(\"reflection\", boing);\n    }","id":90896,"modified_method":"@Test\n    public void ordinaryParamNameTest() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        ReflectionServiceFactoryBean factory = new ReflectionServiceFactoryBean();\n        proxyFac.setServiceFactory(factory);\n        proxyFac.setDataBinding(new AegisDatabinding());\n\n        proxyFac.setAddress(\"local://Echo\");\n        proxyFac.setBus(getBus());\n\n        Echo echo = proxyFac.create(Echo.class);\n        String boing = echo.simpleEcho(\"reflection\");\n        assertEquals(\"reflection\", boing);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void talkToJaxWsHolder() throws Exception {\n        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();\n        factory.setServiceClass(Echo.class);\n        factory.setDataBinding(new AegisDatabinding());\n        factory.setAddress(\"local://JaxWsEcho\");\n        Echo client = (Echo) factory.create();\n        Holder<String> sholder = new Holder<String>();\n        client.echo(\"Channa Doll\", sholder);\n        assertEquals(\"Channa Doll\", sholder.value);\n    }","id":90897,"modified_method":"@Test\n    public void talkToJaxWsHolder() throws Exception {\n        JaxWsProxyFactoryBean factory = new JaxWsProxyFactoryBean();\n        factory.setDataBinding(new AegisDatabinding());\n        factory.setAddress(\"local://JaxWsEcho\");\n        Echo client = (Echo) factory.create(Echo.class);\n        Holder<String> sholder = new Holder<String>();\n        client.echo(\"Channa Doll\", sholder);\n        assertEquals(\"Channa Doll\", sholder.value);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Before\n    public void before() {\n        impl = new CollectionService();\n        createService(CollectionServiceInterface.class, impl, null);\n        \n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.getServiceFactory().getServiceConfigurations().add(0, \n                                                              new XFireCompatibilityServiceConfiguration());\n        proxyFac.setServiceClass(CollectionServiceInterface.class);\n        proxyFac.setDataBinding(new AegisDatabinding());\n        proxyFac.setAddress(\"local://CollectionServiceInterface\");\n        proxyFac.setBus(getBus());\n\n        csi = (CollectionServiceInterface)proxyFac.create();\n    }","id":90898,"modified_method":"@Before\n    public void before() {\n        impl = new CollectionService();\n        createService(CollectionServiceInterface.class, impl, null);\n\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.getServiceFactory().getServiceConfigurations().add(0,\n                                                              new XFireCompatibilityServiceConfiguration());\n        proxyFac.setDataBinding(new AegisDatabinding());\n        proxyFac.setAddress(\"local://CollectionServiceInterface\");\n        proxyFac.setBus(getBus());\n\n        csi = proxyFac.create(CollectionServiceInterface.class);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Before \n    public void setUp() throws Exception {\n        super.setUp();\n        createService(DocumentService.class, \"DocService\");\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        ReflectionServiceFactoryBean factory = new ReflectionServiceFactoryBean();\n        factory.getServiceConfigurations()\n            .add(0, new org.apache.cxf.aegis.databinding.XFireCompatibilityServiceConfiguration());\n        proxyFac.setServiceFactory(factory);\n        proxyFac.setDataBinding(new AegisDatabinding());\n\n        proxyFac.setAddress(\"local://DocService\");\n        proxyFac.setServiceClass(IDocumentService.class);\n        proxyFac.setBus(getBus());\n\n        Object proxyObj = proxyFac.create();\n        docClient = (IDocumentService)proxyObj;\n        Client client = ClientProxy.getClient(proxyObj);\n        ClientImpl clientImpl = (ClientImpl)client;\n        clientImpl.setSynchronousTimeout(1000000000);\n    }","id":90899,"modified_method":"@Before\n    public void setUp() throws Exception {\n        super.setUp();\n        createService(DocumentService.class, \"DocService\");\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        ReflectionServiceFactoryBean factory = new ReflectionServiceFactoryBean();\n        factory.getServiceConfigurations()\n            .add(0, new org.apache.cxf.aegis.databinding.XFireCompatibilityServiceConfiguration());\n        proxyFac.setServiceFactory(factory);\n        proxyFac.setDataBinding(new AegisDatabinding());\n\n        proxyFac.setAddress(\"local://DocService\");\n        proxyFac.setBus(getBus());\n\n        Object proxyObj = proxyFac.create(IDocumentService.class);\n        docClient = (IDocumentService)proxyObj;\n        Client client = ClientProxy.getClient(proxyObj);\n        ClientImpl clientImpl = (ClientImpl)client;\n        clientImpl.setSynchronousTimeout(1000000000);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"public void setUp() throws Exception {\n        super.setUp();\n        \n        AegisContext globalContext = new AegisContext();\n        globalContext.setWriteXsiTypes(true);\n\n        Set<String> l = new HashSet<String>();\n        l.add(SimpleBean.class.getName());\n        l.add(WS1ExtendedException.class.getName());\n        globalContext.setRootClassNames(l);\n        AegisDatabinding binding = new AegisDatabinding();\n        binding.setAegisContext(globalContext);\n\n        ClientProxyFactoryBean pf = new ClientProxyFactoryBean();\n        setupAegis(pf.getClientFactoryBean(), binding);\n        pf.setServiceClass(WS1.class);\n        pf.getServiceFactory().setProperties(props);\n        pf.setAddress(\"local://WS1\");\n        pf.setProperties(props);\n        \n        client = (WS1) pf.create();\n\n        Server server = createService(WS1.class, new WS1Impl(), \"WS1\", binding);\n        new LoggingFeature().initialize(server, null);\n        server.getEndpoint().getService().setInvoker(new BeanInvoker(new WS1Impl()));\n    }","id":90900,"modified_method":"public void setUp() throws Exception {\n        super.setUp();\n\n        AegisContext globalContext = new AegisContext();\n        globalContext.setWriteXsiTypes(true);\n\n        Set<String> l = new HashSet<String>();\n        l.add(SimpleBean.class.getName());\n        l.add(WS1ExtendedException.class.getName());\n        globalContext.setRootClassNames(l);\n        AegisDatabinding binding = new AegisDatabinding();\n        binding.setAegisContext(globalContext);\n\n        ClientProxyFactoryBean pf = new ClientProxyFactoryBean();\n        setupAegis(pf.getClientFactoryBean(), binding);\n        pf.getServiceFactory().setProperties(props);\n        pf.setAddress(\"local://WS1\");\n        pf.setProperties(props);\n\n        client = pf.create(WS1.class);\n\n        Server server = createService(WS1.class, new WS1Impl(), \"WS1\", binding);\n        new LoggingFeature().initialize(server, null);\n        server.getEndpoint().getService().setInvoker(new BeanInvoker(new WS1Impl()));\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test(expected = HelloException.class)\n    public void testJaxws() throws Exception {\n        JaxWsServerFactoryBean sfbean = new JaxWsServerFactoryBean();\n        sfbean.setServiceClass(ExceptionService.class);\n        setupAegis(sfbean);\n        sfbean.setAddress(\"local://ExceptionService4\");\n        Server server = sfbean.create();\n        Service service = server.getEndpoint().getService();\n        service.setInvoker(new BeanInvoker(new ExceptionServiceImpl()));\n        \n        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n        proxyFac.setAddress(\"local://ExceptionService4\");\n        proxyFac.setServiceClass(ExceptionService.class);\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n        ExceptionService clientInterface = (ExceptionService)proxyFac.create();\n        \n        clientInterface.sayHiWithException();\n    }","id":90901,"modified_method":"@Test(expected = HelloException.class)\n    public void testJaxws() throws Exception {\n        JaxWsServerFactoryBean sfbean = new JaxWsServerFactoryBean();\n        sfbean.setServiceClass(ExceptionService.class);\n        setupAegis(sfbean);\n        sfbean.setAddress(\"local://ExceptionService4\");\n        Server server = sfbean.create();\n        Service service = server.getEndpoint().getService();\n        service.setInvoker(new BeanInvoker(new ExceptionServiceImpl()));\n\n        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n        proxyFac.setAddress(\"local://ExceptionService4\");\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n        ExceptionService clientInterface = proxyFac.create(ExceptionService.class);\n\n        clientInterface.sayHiWithException();\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test(expected = HelloException.class)\n    @Ignore(\"Not working yet due to namespace things\")\n    public void testJaxwsServerSimpleClient() throws Exception {\n        JaxWsServerFactoryBean sfbean = new JaxWsServerFactoryBean();\n        sfbean.setServiceClass(ExceptionService.class);\n        sfbean.setDataBinding(new AegisDatabinding());\n        sfbean.setAddress(\"local://ExceptionServiceJaxWs1\");\n        Server server = sfbean.create();\n        Service service = server.getEndpoint().getService();\n        service.setInvoker(new BeanInvoker(new ExceptionServiceImpl()));\n        \n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://ExceptionServiceJaxWs1\");\n        proxyFac.setServiceClass(ExceptionService.class);\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n        \n        ExceptionService clientInterface = (ExceptionService)proxyFac.create();\n        \n        clientInterface.sayHiWithException();\n    }","id":90902,"modified_method":"@Test(expected = HelloException.class)\n    @Ignore(\"Not working yet due to namespace things\")\n    public void testJaxwsServerSimpleClient() throws Exception {\n        JaxWsServerFactoryBean sfbean = new JaxWsServerFactoryBean();\n        sfbean.setServiceClass(ExceptionService.class);\n        sfbean.setDataBinding(new AegisDatabinding());\n        sfbean.setAddress(\"local://ExceptionServiceJaxWs1\");\n        Server server = sfbean.create();\n        Service service = server.getEndpoint().getService();\n        service.setInvoker(new BeanInvoker(new ExceptionServiceImpl()));\n\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://ExceptionServiceJaxWs1\");\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n\n        ExceptionService clientInterface = proxyFac.create(ExceptionService.class);\n\n        clientInterface.sayHiWithException();\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testHeaders() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://ExceptionService\");\n        proxyFac.setServiceClass(ExceptionService.class);\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n        \n        ExceptionService client = (ExceptionService)proxyFac.create();\n        \n        try {\n            client.sayHiWithException();\n            fail(\"Must throw exception!\");\n        } catch (HelloException e) {\n            // nothing\n        }\n\n        //check to make sure the fault is an element\n        Document wsdl = getWSDLDocument(\"ExceptionService\");\n        addNamespace(\"tns\", \"http://exception.aegis.cxf.apache.org\");\n        assertValid(\"//wsdl:message[@name='HelloException']/wsdl:part[@name='HelloException']\"\n                    + \"[@element='tns:String']\",\n                     wsdl);\n    }","id":90903,"modified_method":"@Test\n    public void testHeaders() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://ExceptionService\");\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n\n        ExceptionService client = proxyFac.create(ExceptionService.class);\n\n        try {\n            client.sayHiWithException();\n            fail(\"Must throw exception!\");\n        } catch (HelloException e) {\n            // nothing\n        }\n\n        //check to make sure the fault is an element\n        Document wsdl = getWSDLDocument(\"ExceptionService\");\n        addNamespace(\"tns\", \"http://exception.aegis.cxf.apache.org\");\n        assertValid(\"//wsdl:message[@name='HelloException']/wsdl:part[@name='HelloException']\"\n                    + \"[@element='tns:String']\",\n                     wsdl);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testFlatCollection() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setDataBinding(new AegisDatabinding());\n        proxyFac.setAddress(\"local://FlatArray\");\n        proxyFac.setServiceClass(FlatArrayServiceInterface.class);\n        proxyFac.setBus(getBus());\n\n        Object proxyObj = proxyFac.create();\n        FlatArrayServiceInterface client = (FlatArrayServiceInterface)proxyObj;\n        BeanWithFlatCollection bwfc = new BeanWithFlatCollection();\n        bwfc.getValues().add(1);\n        bwfc.getValues().add(2);\n        bwfc.getValues().add(3);\n        bwfc = client.echoBeanWithFlatCollection(bwfc);\n        assertEquals(3, bwfc.getValues().size());\n        assertEquals(Integer.valueOf(1), bwfc.getValues().get(0));\n        assertEquals(Integer.valueOf(2), bwfc.getValues().get(1));\n        assertEquals(Integer.valueOf(3), bwfc.getValues().get(2));\n    }","id":90904,"modified_method":"@Test\n    public void testFlatCollection() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setDataBinding(new AegisDatabinding());\n        proxyFac.setAddress(\"local://FlatArray\");\n        proxyFac.setBus(getBus());\n\n        FlatArrayServiceInterface client = proxyFac.create(FlatArrayServiceInterface.class);\n        BeanWithFlatCollection bwfc = new BeanWithFlatCollection();\n        bwfc.getValues().add(1);\n        bwfc.getValues().add(2);\n        bwfc.getValues().add(3);\n        bwfc = client.echoBeanWithFlatCollection(bwfc);\n        assertEquals(3, bwfc.getValues().size());\n        assertEquals(Integer.valueOf(1), bwfc.getValues().get(0));\n        assertEquals(Integer.valueOf(2), bwfc.getValues().get(1));\n        assertEquals(Integer.valueOf(3), bwfc.getValues().get(2));\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testDataMovementPart() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setDataBinding(new AegisDatabinding());\n        proxyFac.setAddress(\"local://FlatArray\");\n        proxyFac.setServiceClass(FlatArrayServiceInterface.class);\n        proxyFac.setBus(getBus());\n\n        Object proxyObj = proxyFac.create();\n        FlatArrayServiceInterface client = (FlatArrayServiceInterface)proxyObj;\n        client.submitStringArray(STRING_ARRAY);\n        assertArrayEquals(STRING_ARRAY, service.stringArrayValue);\n    }","id":90905,"modified_method":"@Test\n    public void testDataMovementPart() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setDataBinding(new AegisDatabinding());\n        proxyFac.setAddress(\"local://FlatArray\");\n        proxyFac.setBus(getBus());\n\n        FlatArrayServiceInterface client = proxyFac.create(FlatArrayServiceInterface.class);\n        client.submitStringArray(STRING_ARRAY);\n        assertArrayEquals(STRING_ARRAY, service.stringArrayValue);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testDataMovementBean() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setDataBinding(new AegisDatabinding());\n        proxyFac.setAddress(\"local://FlatArray\");\n        proxyFac.setServiceClass(FlatArrayServiceInterface.class);\n        proxyFac.setBus(getBus());\n\n        Object proxyObj = proxyFac.create();\n        FlatArrayServiceInterface client = (FlatArrayServiceInterface)proxyObj;\n        BeanWithFlatArray bwfa = new BeanWithFlatArray();\n        bwfa.setValues(INT_ARRAY);\n        client.takeBeanWithFlatArray(bwfa);\n        assertArrayEquals(INT_ARRAY, service.beanWithFlatArrayValue.getValues());\n    }","id":90906,"modified_method":"@Test\n    public void testDataMovementBean() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setDataBinding(new AegisDatabinding());\n        proxyFac.setAddress(\"local://FlatArray\");\n        proxyFac.setBus(getBus());\n\n        FlatArrayServiceInterface client = proxyFac.create(FlatArrayServiceInterface.class);\n        BeanWithFlatArray bwfa = new BeanWithFlatArray();\n        bwfa.setValues(INT_ARRAY);\n        client.takeBeanWithFlatArray(bwfa);\n        assertArrayEquals(INT_ARRAY, service.beanWithFlatArrayValue.getValues());\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testClient() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://IInterfaceService\");\n        proxyFac.setServiceClass(IInterfaceService.class);\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n\n        IInterfaceService client = (IInterfaceService)proxyFac.create();\n\n        IChild child = client.getChild();\n        assertNotNull(child);\n        assertEquals(\"child\", child.getChildName());\n        assertEquals(\"parent\", child.getParentName());\n\n        IParent parent = client.getChildViaParent();\n        assertEquals(\"parent\", parent.getParentName());\n        assertFalse(parent instanceof IChild);\n\n        IGrandChild grandChild = client.getGrandChild();\n        assertEquals(\"parent\", grandChild.getParentName());\n\n        Document wsdl = getWSDLDocument(\"IInterfaceService\");\n        assertValid(\"//xsd:complexType[@name='IGrandChild']\", wsdl);\n        assertValid(\"//xsd:complexType[@name='IGrandChild']//xsd:element[@name='grandChildName']\", wsdl);\n        assertValid(\"//xsd:complexType[@name='IGrandChild']//xsd:element[@name='childName'][1]\", wsdl);\n        assertInvalid(\"//xsd:complexType[@name='IGrandChild']//xsd:element[@name='childName'][2]\", wsdl);\n        assertValid(\"//xsd:complexType[@name='IChild']\", wsdl);\n        assertValid(\"//xsd:complexType[@name='IParent']\", wsdl);\n        assertInvalid(\"//xsd:complexType[@name='IChild'][@abstract='true']\", wsdl);\n    }","id":90907,"modified_method":"@Test\n    public void testClient() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://IInterfaceService\");\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n\n        IInterfaceService client = proxyFac.create(IInterfaceService.class);\n\n        IChild child = client.getChild();\n        assertNotNull(child);\n        assertEquals(\"child\", child.getChildName());\n        assertEquals(\"parent\", child.getParentName());\n\n        IParent parent = client.getChildViaParent();\n        assertEquals(\"parent\", parent.getParentName());\n        assertFalse(parent instanceof IChild);\n\n        IGrandChild grandChild = client.getGrandChild();\n        assertEquals(\"parent\", grandChild.getParentName());\n\n        Document wsdl = getWSDLDocument(\"IInterfaceService\");\n        assertValid(\"//xsd:complexType[@name='IGrandChild']\", wsdl);\n        assertValid(\"//xsd:complexType[@name='IGrandChild']//xsd:element[@name='grandChildName']\", wsdl);\n        assertValid(\"//xsd:complexType[@name='IGrandChild']//xsd:element[@name='childName'][1]\", wsdl);\n        assertInvalid(\"//xsd:complexType[@name='IGrandChild']//xsd:element[@name='childName'][2]\", wsdl);\n        assertValid(\"//xsd:complexType[@name='IChild']\", wsdl);\n        assertValid(\"//xsd:complexType[@name='IParent']\", wsdl);\n        assertInvalid(\"//xsd:complexType[@name='IChild'][@abstract='true']\", wsdl);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testClientProxyFactory() {\n        JaxWsProxyFactoryBean cf = new JaxWsProxyFactoryBean(); \n        cf.setAddress(\"http://localhost:9000/test\");\n        cf.setServiceClass(Greeter.class);\n        Greeter greeter = (Greeter) cf.create();\n        Greeter greeter2 = (Greeter) cf.create();\n        Greeter greeter3 = (Greeter) cf.create();\n        \n        Client c = ClientProxy.getClient(greeter);\n        Client c2 = ClientProxy.getClient(greeter2);\n        Client c3 = ClientProxy.getClient(greeter3);\n        assertNotSame(c, c2);\n        assertNotSame(c, c3);\n        assertNotSame(c3, c2);\n        assertNotSame(c.getEndpoint(), c2.getEndpoint());\n        assertNotSame(c.getEndpoint(), c3.getEndpoint());\n        assertNotSame(c3.getEndpoint(), c2.getEndpoint());\n        \n        ((BindingProvider)greeter).getRequestContext().put(\"test\", \"manny\"); \n        ((BindingProvider)greeter2).getRequestContext().put(\"test\", \"moe\"); \n        ((BindingProvider)greeter3).getRequestContext().put(\"test\", \"jack\");\n        \n        assertEquals(\"manny\", ((BindingProvider)greeter).getRequestContext().get(\"test\"));\n        assertEquals(\"moe\", ((BindingProvider)greeter2).getRequestContext().get(\"test\"));\n        assertEquals(\"jack\", ((BindingProvider)greeter3).getRequestContext().get(\"test\"));\n    }","id":90908,"modified_method":"@Test\n    public void testClientProxyFactory() {\n        JaxWsProxyFactoryBean cf = new JaxWsProxyFactoryBean();\n        cf.setAddress(\"http://localhost:9000/test\");\n        Greeter greeter = cf.create(Greeter.class);\n        /*  .n.b. don't call call create with an argument and change the SEI. */\n        Greeter greeter2 = (Greeter) cf.create();\n        Greeter greeter3 = (Greeter) cf.create();\n\n        Client c = ClientProxy.getClient(greeter);\n        Client c2 = ClientProxy.getClient(greeter2);\n        Client c3 = ClientProxy.getClient(greeter3);\n        assertNotSame(c, c2);\n        assertNotSame(c, c3);\n        assertNotSame(c3, c2);\n        assertNotSame(c.getEndpoint(), c2.getEndpoint());\n        assertNotSame(c.getEndpoint(), c3.getEndpoint());\n        assertNotSame(c3.getEndpoint(), c2.getEndpoint());\n\n        ((BindingProvider)greeter).getRequestContext().put(\"test\", \"manny\");\n        ((BindingProvider)greeter2).getRequestContext().put(\"test\", \"moe\");\n        ((BindingProvider)greeter3).getRequestContext().put(\"test\", \"jack\");\n\n        assertEquals(\"manny\", ((BindingProvider)greeter).getRequestContext().get(\"test\"));\n        assertEquals(\"moe\", ((BindingProvider)greeter2).getRequestContext().get(\"test\"));\n        assertEquals(\"jack\", ((BindingProvider)greeter3).getRequestContext().get(\"test\"));\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testProxy() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://HelloProxyService\");\n        proxyFac.setServiceClass(HelloProxyService.class);\n        proxyFac.setBus(getBus());\n        AegisContext aegisContext = new AegisContext();\n        aegisContext.getBeanImplementationMap().put(Hello.class, MyHello.class.getName());\n        AegisDatabinding binding = new AegisDatabinding();\n        binding.setAegisContext(aegisContext);\n        \n        setupAegis(proxyFac.getClientFactoryBean(), binding);\n        HelloProxyService client = (HelloProxyService)proxyFac.create();\n        \n        Hello h = client.sayHiWithProxy();\n        assertTrue(h instanceof MyHello);\n    }","id":90909,"modified_method":"@Test\n    public void testProxy() throws Exception {\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://HelloProxyService\");\n        proxyFac.setBus(getBus());\n        AegisContext aegisContext = new AegisContext();\n        aegisContext.getBeanImplementationMap().put(Hello.class, MyHello.class.getName());\n        AegisDatabinding binding = new AegisDatabinding();\n        binding.setAegisContext(aegisContext);\n\n        setupAegis(proxyFac.getClientFactoryBean(), binding);\n        HelloProxyService client = proxyFac.create(HelloProxyService.class);\n\n        Hello h = client.sayHiWithProxy();\n        assertTrue(h instanceof MyHello);\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test \n    public void testReturnMapDocLiteral() throws Exception {\n\n        JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();\n        sf.setServiceClass(StudentServiceDocLiteral.class);\n        sf.setServiceBean(new StudentServiceDocLiteralImpl());\n        sf.setAddress(\"local://StudentServiceDocLiteral\");\n        setupAegis(sf);\n        Server server = sf.create();\n        server.getEndpoint().getInInterceptors().add(new LoggingInInterceptor());\n        server.getEndpoint().getOutInterceptors().add(new LoggingOutInterceptor());\n        server.start();\n        \n        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n        proxyFac.setAddress(\"local://StudentServiceDocLiteral\");\n        proxyFac.setServiceClass(StudentServiceDocLiteral.class);\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n        \n        proxyFac.getInInterceptors().add(new LoggingInInterceptor());\n        proxyFac.getOutInterceptors().add(new LoggingOutInterceptor());\n\n        StudentServiceDocLiteral clientInterface = (StudentServiceDocLiteral)proxyFac.create();\n        Map<Long, Student> fullMap = clientInterface.getStudentsMap();\n        assertNotNull(fullMap);\n        Student one = fullMap.get(Long.valueOf(1));\n        assertNotNull(one);\n        assertEquals(\"Student1\", one.getName());\n        \n    }","id":90910,"modified_method":"@Test\n    public void testReturnMapDocLiteral() throws Exception {\n\n        JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();\n        sf.setServiceClass(StudentServiceDocLiteral.class);\n        sf.setServiceBean(new StudentServiceDocLiteralImpl());\n        sf.setAddress(\"local://StudentServiceDocLiteral\");\n        setupAegis(sf);\n        Server server = sf.create();\n        server.getEndpoint().getInInterceptors().add(new LoggingInInterceptor());\n        server.getEndpoint().getOutInterceptors().add(new LoggingOutInterceptor());\n        server.start();\n\n        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n        proxyFac.setAddress(\"local://StudentServiceDocLiteral\");\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n\n        proxyFac.getInInterceptors().add(new LoggingInInterceptor());\n        proxyFac.getOutInterceptors().add(new LoggingOutInterceptor());\n\n        StudentServiceDocLiteral clientInterface = proxyFac.create(StudentServiceDocLiteral.class);\n        Map<Long, Student> fullMap = clientInterface.getStudentsMap();\n        assertNotNull(fullMap);\n        Student one = fullMap.get(Long.valueOf(1));\n        assertNotNull(one);\n        assertEquals(\"Student1\", one.getName());\n\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test \n    public void testMapMap() throws Exception {\n\n        ServerFactoryBean sf = new ServerFactoryBean();\n        sf.setServiceClass(StudentServiceDocLiteral.class);\n        sf.setServiceBean(new StudentServiceDocLiteralImpl());\n        sf.setAddress(\"local://StudentServiceDocLiteral\");\n        setupAegis(sf);\n        Server server = sf.create();\n        server.getEndpoint().getInInterceptors().add(new LoggingInInterceptor());\n        server.getEndpoint().getOutInterceptors().add(new LoggingOutInterceptor());\n        server.start();\n        \n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://StudentServiceDocLiteral\");\n        proxyFac.setServiceClass(StudentServiceDocLiteral.class);\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n        //CHECKSTYLE:OFF\n        HashMap<String, Student> mss = new HashMap<String, Student>();\n        mss.put(\"Alice\", new Student());\n        HashMap<String, HashMap<String, Student>> mmss = new HashMap<String, HashMap<String, Student>>();\n        mmss.put(\"Bob\", mss);\n        \n        StudentServiceDocLiteral clientInterface = (StudentServiceDocLiteral)proxyFac.create();\n        clientInterface.takeMapMap(mmss);\n        //CHECKSTYLE:ON\n    }","id":90911,"modified_method":"@Test\n    public void testMapMap() throws Exception {\n\n        ServerFactoryBean sf = new ServerFactoryBean();\n        sf.setServiceClass(StudentServiceDocLiteral.class);\n        sf.setServiceBean(new StudentServiceDocLiteralImpl());\n        sf.setAddress(\"local://StudentServiceDocLiteral\");\n        setupAegis(sf);\n        Server server = sf.create();\n        server.start();\n\n        ClientProxyFactoryBean proxyFac = new ClientProxyFactoryBean();\n        proxyFac.setAddress(\"local://StudentServiceDocLiteral\");\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n        //CHECKSTYLE:OFF\n        HashMap<String, Student> mss = new HashMap<String, Student>();\n        mss.put(\"Alice\", new Student());\n        HashMap<String, HashMap<String, Student>> mmss = new HashMap<String, HashMap<String, Student>>();\n        mmss.put(\"Bob\", mss);\n\n        StudentServiceDocLiteral clientInterface = proxyFac.create(StudentServiceDocLiteral.class);\n        clientInterface.takeMapMap(mmss);\n        //CHECKSTYLE:ON\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"@Test \n    public void testReturnMap() throws Exception {\n\n        JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();\n        sf.setServiceClass(StudentService.class);\n        sf.setServiceBean(new StudentServiceImpl());\n        sf.setAddress(\"local://StudentService\");\n        setupAegis(sf);\n        Server server = sf.create();\n        server.start();\n        \n        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n        proxyFac.setAddress(\"local://StudentService\");\n        proxyFac.setServiceClass(StudentService.class);\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n\n        StudentService clientInterface = (StudentService)proxyFac.create();\n        Map<Long, Student> fullMap = clientInterface.getStudentsMap();\n        assertNotNull(fullMap);\n        Student one = fullMap.get(Long.valueOf(1));\n        assertNotNull(one);\n        assertEquals(\"Student1\", one.getName());\n        \n        Map<String, ?> wildMap = clientInterface.getWildcardMap();\n        assertEquals(\"valuestring\", wildMap.get(\"keystring\"));\n    }","id":90912,"modified_method":"@Test\n    public void testReturnMap() throws Exception {\n\n        JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();\n        sf.setServiceClass(StudentService.class);\n        sf.setServiceBean(new StudentServiceImpl());\n        sf.setAddress(\"local://StudentService\");\n        setupAegis(sf);\n        Server server = sf.create();\n        server.start();\n\n        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n        proxyFac.setAddress(\"local://StudentService\");\n        proxyFac.setBus(getBus());\n        setupAegis(proxyFac.getClientFactoryBean());\n\n        StudentService clientInterface = proxyFac.create(StudentService.class);\n        Map<Long, Student> fullMap = clientInterface.getStudentsMap();\n        assertNotNull(fullMap);\n        Student one = fullMap.get(Long.valueOf(1));\n        assertNotNull(one);\n        assertEquals(\"Student1\", one.getName());\n\n        Map<String, ?> wildMap = clientInterface.getWildcardMap();\n        assertEquals(\"valuestring\", wildMap.get(\"keystring\"));\n    }","commit_id":"a8f8785460845ae534d3cf7865820d48ed42644e","url":"https://github.com/apache/cxf"},{"original_method":"/**\n\t * @see wicket.Component#detachModel()\n\t */\n\t@Override\n\tprotected void detachModel()\n\t{\n\t\tsuper.detachModel();\n\n\t\tchoices.detach();\n\t}","id":90913,"modified_method":"/**\n\t * @see wicket.Component#detachModel()\n\t */\n\t@Override\n\tprotected void detachModel()\n\t{\n\t\tsuper.detachModel();\n\n\t\tif (choices != null)\n\t\t{\n\t\t\tchoices.detach();\n\t\t}\n\t}","commit_id":"1ef30fd495e3b62875714ed6a6a26a06d80518b5","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return The collection of object that this choice has\n\t */\n\tpublic List<E> getChoices()\n\t{\n\t\tList<E> choices = this.choices.getObject();\n\t\tif (choices == null)\n\t\t{\n\t\t\tthrow new NullPointerException(\n\t\t\t\t\t\"List of choices is null - Was the supplied 'Choices' model empty?\");\n\t\t}\n\t\treturn choices;\n\t}","id":90914,"modified_method":"/**\n\t * @return The collection of object that this choice has\n\t */\n\tpublic List<E> getChoices()\n\t{\n\t\tList<E> choices = (this.choices != null) ? this.choices.getObject() : null;\n\t\tif (choices == null)\n\t\t{\n\t\t\tthrow new NullPointerException(\n\t\t\t\t\t\"List of choices is null - Was the supplied 'Choices' model empty?\");\n\t\t}\n\t\treturn choices;\n\t}","commit_id":"1ef30fd495e3b62875714ed6a6a26a06d80518b5","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Gets the list of choices.\n\t * \n\t * @return The list of choices\n\t */\n\tpublic IChoiceList getChoices()\n\t{\n\t\tchoices.attach();\n\t\treturn this.choices;\n\t}","id":90915,"modified_method":"/**\n\t * Gets the list of choices.\n\t * \n\t * @return The list of choices\n\t */\n\tpublic IChoiceList getChoices()\n\t{\n\t\tif(choices != null) choices.attach();\n\t\treturn this.choices;\n\t}","commit_id":"4d69cb7ba84b579d276c6d249df0994c3734a0c7","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @see wicket.Component#detachModel()\n\t */\n\tprotected void detachModel()\n\t{\n\t\tsuper.detachModel();\n\t\tchoices.detach();\n\t}","id":90916,"modified_method":"/**\n\t * @see wicket.Component#detachModel()\n\t */\n\tprotected void detachModel()\n\t{\n\t\tsuper.detachModel();\n\t\tif(choices != null) choices.detach();\n\t}","commit_id":"4d69cb7ba84b579d276c6d249df0994c3734a0c7","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic void respond(IRequestCycle requestCycle)\n\t{\n\t\tif (hasData.get())\n\t\t{\n\t\t\tupdate.writeTo(requestCycle.getResponse(), \"UTF-8\");\n\t\t}\n\t}","id":90917,"modified_method":"@Override\n\tpublic void respond(IRequestCycle requestCycle)\n\t{\n\t\tif (update != null)\n\t\t{\n\t\t\tupdate.writeTo(requestCycle.getResponse(), \"UTF-8\");\n\t\t}\n\t}","commit_id":"976f3ba0cc2b4a22b71c49b1463254fb8d91f8e7","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic void detach(IRequestCycle requestCycle)\n\t{\n\t\tif (logData == null)\n\t\t{\n\t\t\tlogData = new PageLogData(page);\n\t\t}\n\n\t\tupdate.detach(requestCycle);\n\t\thasData.set(false);\n\t}","id":90918,"modified_method":"@Override\n\tpublic void detach(IRequestCycle requestCycle)\n\t{\n\t\tif (logData == null)\n\t\t{\n\t\t\tlogData = new PageLogData(page);\n\t\t}\n\n\t\tif (update != null) {\n\t\t\tupdate.detach(requestCycle);\n\t\t\tupdate = null;\n\t\t}\n\t}","commit_id":"976f3ba0cc2b4a22b71c49b1463254fb8d91f8e7","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic void add(Component component, String markupId)\n\t{\n\t\thasData.set(true);\n\t\tupdate.add(component, markupId);\n\t}","id":90919,"modified_method":"@Override\n\tpublic void add(Component component, String markupId)\n\t{\n\t\tgetUpdate().add(component, markupId);\n\t}","commit_id":"976f3ba0cc2b4a22b71c49b1463254fb8d91f8e7","url":"https://github.com/apache/wicket"},{"original_method":"public WebSocketRequestHandler(final Component component, final IWebSocketConnection connection)\n\t{\n\t\tthis.page = Args.notNull(component, \"component\").getPage();\n\t\tthis.connection = Args.notNull(connection, \"connection\");\n\t\tthis.update = new XmlPartialPageUpdate(page);\n\t}","id":90920,"modified_method":"public WebSocketRequestHandler(final Component component, final IWebSocketConnection connection)\n\t{\n\t\tthis.page = Args.notNull(component, \"component\").getPage();\n\t\tthis.connection = Args.notNull(connection, \"connection\");\n\t}","commit_id":"976f3ba0cc2b4a22b71c49b1463254fb8d91f8e7","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic void prependJavaScript(CharSequence javascript)\n\t{\n\t\thasData.set(true);\n\t\tupdate.prependJavaScript(javascript);\n\t}","id":90921,"modified_method":"@Override\n\tpublic void prependJavaScript(CharSequence javascript)\n\t{\n\t\tgetUpdate().prependJavaScript(javascript);\n\t}","commit_id":"976f3ba0cc2b4a22b71c49b1463254fb8d91f8e7","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic IHeaderResponse getHeaderResponse()\n\t{\n\t\thasData.set(true);\n\t\treturn update.getHeaderResponse();\n\t}","id":90922,"modified_method":"@Override\n\tpublic IHeaderResponse getHeaderResponse()\n\t{\n\t\treturn getUpdate().getHeaderResponse();\n\t}","commit_id":"976f3ba0cc2b4a22b71c49b1463254fb8d91f8e7","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic void appendJavaScript(CharSequence javascript)\n\t{\n\t\thasData.set(true);\n\t\tupdate.appendJavaScript(javascript);\n\t}","id":90923,"modified_method":"@Override\n\tpublic void appendJavaScript(CharSequence javascript)\n\t{\n\t\tgetUpdate().appendJavaScript(javascript);\n\t}","commit_id":"976f3ba0cc2b4a22b71c49b1463254fb8d91f8e7","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\tpublic Collection<? extends Component> getComponents()\n\t{\n\t\treturn update.getComponents();\n\t}","id":90924,"modified_method":"@Override\n\tpublic Collection<? extends Component> getComponents()\n\t{\n\t\tif (update == null) {\n\t\t\treturn Collections.emptyList();\n\t\t} else {\n\t\t\treturn update.getComponents();\n\t\t}\n\t}","commit_id":"976f3ba0cc2b4a22b71c49b1463254fb8d91f8e7","url":"https://github.com/apache/wicket"},{"original_method":"private RepositoryVirtualFiles findRepoFiles(SModel m) {\n      if (m.getRepository() == null) {\n        return null;\n      }\n      // FIXME won't work as all out models belong to same global repository, while RVF is per project's repository (another instance, !=)\n      return findForRepository(m.getRepository());\n    }","id":90925,"modified_method":"private RepositoryVirtualFiles findRepoFiles(SModel m) {\n      if (m.getRepository() == null) {\n        return null;\n      }\n      // FIXME use of a repository this listener has been associated with to work around the fact the only repository that sends\n      // events now is the global one.\n      return findForRepository(myRepository);\n    }","commit_id":"c19a2a651f3e621744ba3421d7984fffa3e06892","url":"https://github.com/JetBrains/MPS"},{"original_method":"public NodeVirtualFileSystem(MPSCoreComponents coreComponents) {\n    // FIXME this component shall be ProjectComponent, pass MPSProject.getRepository(); initialize in projectOpened()\n    SRepository myRepository = coreComponents.getModuleRepository();\n    myGlobalRepoFiles = new RepositoryVirtualFiles(this, myRepository);\n    myRepositoryListener = new MyRepositoryListener();\n  }","id":90926,"modified_method":"public NodeVirtualFileSystem(MPSCoreComponents coreComponents) {\n    // FIXME this component shall be ProjectComponent, pass MPSProject.getRepository(); initialize in projectOpened()\n    SRepository myRepository = coreComponents.getModuleRepository();\n    myGlobalRepoFiles = new RepositoryVirtualFiles(this, myRepository);\n    myRepositoryListener = new MyRepositoryListener(myRepository);\n  }","commit_id":"c19a2a651f3e621744ba3421d7984fffa3e06892","url":"https://github.com/JetBrains/MPS"},{"original_method":"synchronized void register(@NotNull RepositoryVirtualFiles repoFiles) {\n    // assert not more than 1 file container per repository\n    RepositoryVirtualFiles existing = findForRepository(repoFiles.getRepository());\n    if (existing != null) {\n      throw new IllegalArgumentException(\"Attempt to register another VirtualFile container for the same repository\");\n    }\n    // sort of stack, most recent first. just for fun, no hidden assumptions.\n    myPerRepositoryFiles.add(0, repoFiles);\n    new RepoListenerRegistrar(repoFiles.getRepository(), myRepositoryListener).attach();\n  }","id":90927,"modified_method":"void register(@NotNull RepositoryVirtualFiles repoFiles) {\n    MyRepositoryListener listener;\n    synchronized (this) {\n      // assert not more than 1 file container per repository\n      RepositoryVirtualFiles existing = findForRepository(repoFiles.getRepository());\n      if (existing != null) {\n        throw new IllegalArgumentException(\"Attempt to register another VirtualFile container for the same repository\");\n      }\n      // sort of stack, most recent first. just for fun, no hidden assumptions.\n      myPerRepositoryFiles.add(0, repoFiles);\n      listener = new MyRepositoryListener(repoFiles.getRepository());\n      myFiles2ListenerMap.put(repoFiles, listener);\n    }\n    new RepoListenerRegistrar(repoFiles.getRepository(), listener).attach();\n  }","commit_id":"c19a2a651f3e621744ba3421d7984fffa3e06892","url":"https://github.com/JetBrains/MPS"},{"original_method":"synchronized void unregister(@NotNull RepositoryVirtualFiles repoFiles) {\n    new RepoListenerRegistrar(repoFiles.getRepository(), myRepositoryListener).detach();\n    myPerRepositoryFiles.remove(repoFiles);\n  }","id":90928,"modified_method":"void unregister(@NotNull RepositoryVirtualFiles repoFiles) {\n    MyRepositoryListener listener;\n    synchronized (this) {\n      myPerRepositoryFiles.remove(repoFiles);\n      listener = myFiles2ListenerMap.remove(repoFiles);\n    }\n    if (listener != null) {\n      new RepoListenerRegistrar(repoFiles.getRepository(), listener).detach();\n    }\n  }","commit_id":"c19a2a651f3e621744ba3421d7984fffa3e06892","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean hasVirtualFileFor(@NotNull SRepository repo, SNodeReference nodePointer) {\n    return myGlobalRepoFiles.hasVirtualFileFor(nodePointer);\n  }","id":90929,"modified_method":"public boolean hasVirtualFileFor(@NotNull SRepository repo, SNodeReference nodePointer) {\n    final RepositoryVirtualFiles rvf = findForRepository(repo);\n    return rvf != null ? rvf.hasVirtualFileFor(nodePointer) : myGlobalRepoFiles.hasVirtualFileFor(nodePointer);\n  }","commit_id":"c19a2a651f3e621744ba3421d7984fffa3e06892","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n\t * @see wicket.Component#detachModel()\n\t */\n\tprotected void detachModel()\n\t{\n\t\tsuper.detachModel();\n\n\t\tchoices.detach();\n\t}","id":90930,"modified_method":"/**\n\t * @see wicket.Component#detachModel()\n\t */\n\tprotected void detachModel()\n\t{\n\t\tsuper.detachModel();\n\n\t\tif (choices != null)\n\t\t{\n\t\t\tchoices.detach();\n\t\t}\n\t}","commit_id":"c218704669e23b0978636608616828134f72084d","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * @return The collection of object that this choice has\n\t */\n\tpublic List getChoices()\n\t{\n\t\tList choices = (List)this.choices.getObject(this);\n\t\tif (choices == null)\n\t\t{\n\t\t\tthrow new NullPointerException(\"List of choices is null - Was the supplied 'Choices' model empty?\");\n\t\t}\n\t\treturn choices;\n\t}","id":90931,"modified_method":"/**\n\t * @return The collection of object that this choice has\n\t */\n\tpublic List getChoices()\n\t{\n\t\tList choices = (this.choices != null) ? (List)this.choices.getObject(this) : null;\n\t\tif (choices == null)\n\t\t{\n\t\t\tthrow new NullPointerException(\n\t\t\t\t\t\"List of choices is null - Was the supplied 'Choices' model empty?\");\n\t\t}\n\t\treturn choices;\n\t}","commit_id":"c218704669e23b0978636608616828134f72084d","url":"https://github.com/apache/wicket"},{"original_method":"@Test\n\tpublic void transform() throws Exception {\n\t\tResource mainCss = new ClassPathResource(\"test/main.css\", getClass());\n\t\tResource resource = this.transformerChain.transform(this.request, mainCss);\n\t\tTransformedResource transformedResource = (TransformedResource) resource;\n\n\t\tString expected = \"\\n\" +\n\t\t\t\t\"@import url(\\\"bar-11e16cf79faee7ac698c805cf28248d2.css\\\");\\n\" +\n\t\t\t\t\"@import url('bar-11e16cf79faee7ac698c805cf28248d2.css');\\n\" +\n\t\t\t\t\"@import url(bar-11e16cf79faee7ac698c805cf28248d2.css);\\n\\n\" +\n\t\t\t\t\"@import \\\"foo-e36d2e05253c6c7085a91522ce43a0b4.css\\\";\\n\" +\n\t\t\t\t\"@import 'foo-e36d2e05253c6c7085a91522ce43a0b4.css';\\n\\n\" +\n\t\t\t\t\"body { background: url(\\\"images/image-f448cd1d5dba82b774f3202c878230b3.png\\\") }\\n\";\n\n\t\tString result = new String(transformedResource.getByteArray(), \"UTF-8\");\n\t\tresult = StringUtils.deleteAny(result, \"\\r\");\n\t\tassertEquals(expected, result);\n\t}","id":90932,"modified_method":"@Test\n\tpublic void transform() throws Exception {\n\t\tResource css = new ClassPathResource(\"test/main.css\", getClass());\n\t\tTransformedResource actual = (TransformedResource) this.transformerChain.transform(this.request, css);\n\n\t\tString expected = \"\\n\" +\n\t\t\t\t\"@import url(\\\"bar-11e16cf79faee7ac698c805cf28248d2.css\\\");\\n\" +\n\t\t\t\t\"@import url('bar-11e16cf79faee7ac698c805cf28248d2.css');\\n\" +\n\t\t\t\t\"@import url(bar-11e16cf79faee7ac698c805cf28248d2.css);\\n\\n\" +\n\t\t\t\t\"@import \\\"foo-e36d2e05253c6c7085a91522ce43a0b4.css\\\";\\n\" +\n\t\t\t\t\"@import 'foo-e36d2e05253c6c7085a91522ce43a0b4.css';\\n\\n\" +\n\t\t\t\t\"body { background: url(\\\"images/image-f448cd1d5dba82b774f3202c878230b3.png\\\") }\\n\";\n\n\t\tString result = new String(actual.getByteArray(), \"UTF-8\");\n\t\tresult = StringUtils.deleteAny(result, \"\\r\");\n\t\tassertEquals(expected, result);\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setUp() {\n\t\tMap<String, VersionStrategy> versionStrategyMap = new HashMap<>();\n\t\tversionStrategyMap.put(\"/**\", new ContentVersionStrategy());\n\t\tVersionResourceResolver versionResolver = new VersionResourceResolver();\n\t\tversionResolver.setStrategyMap(versionStrategyMap);\n\n\t\tList<ResourceResolver> resolvers = new ArrayList<ResourceResolver>();\n\t\tresolvers.add(versionResolver);\n\t\tresolvers.add(new PathResourceResolver());\n\t\tResourceResolverChain resolverChain = new DefaultResourceResolverChain(resolvers);\n\n\t\tList<ResourceTransformer> transformers = new ArrayList<>();\n\t\ttransformers.add(new CssLinkResourceTransformer());\n\t\tthis.transformerChain = new DefaultResourceTransformerChain(resolverChain, transformers);\n\n\t\tthis.request = new MockHttpServletRequest();\n\t}","id":90933,"modified_method":"@Before\n\tpublic void setUp() {\n\t\tVersionResourceResolver resolver = new VersionResourceResolver();\n\t\tresolver.setStrategyMap(Collections.singletonMap(\"/**\", new ContentVersionStrategy()));\n\n\t\tList<ResourceResolver> resolvers = Arrays.asList(resolver, new PathResourceResolver());\n\t\tList<ResourceTransformer> transformers = Arrays.asList(new CssLinkResourceTransformer());\n\n\t\tResourceResolverChain resolverChain = new DefaultResourceResolverChain(resolvers);\n\t\tthis.transformerChain = new DefaultResourceTransformerChain(resolverChain, transformers);\n\n\t\tthis.request = new MockHttpServletRequest();\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void resourceNotFound() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/not-there.css\");\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(404, response.getStatus());\n\t}","id":90934,"modified_method":"@Test\n\tpublic void resourceNotFound() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/not-there.css\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t\tassertEquals(404, this.response.getStatus());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void getResourceFromSubDirectory() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/js/foo.js\");\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(\"text/javascript\", response.getContentType());\n\t\tassertEquals(\"function foo() { console.log(\\\"hello world\\\"); }\", response.getContentAsString());\n\t}","id":90935,"modified_method":"@Test\n\tpublic void getResourceFromSubDirectory() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/js/foo.js\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\n\t\tassertEquals(\"text/javascript\", this.response.getContentType());\n\t\tassertEquals(\"function foo() { console.log(\\\"hello world\\\"); }\", this.response.getContentAsString());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void notModified() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.css\");\n\t\trequest.addHeader(\"If-Modified-Since\", new ClassPathResource(\"test/foo.css\", getClass()).getFile().lastModified());\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(HttpServletResponse.SC_NOT_MODIFIED, response.getStatus());\n\t}","id":90936,"modified_method":"@Test\n\tpublic void notModified() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.css\");\n\t\tthis.request.addHeader(\"If-Modified-Since\", resourceLastModified(\"test/foo.css\"));\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t\tassertEquals(HttpServletResponse.SC_NOT_MODIFIED, this.response.getStatus());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void getResourceFromSubDirectoryOfAlternatePath() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/js/baz.js\");\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(\"text/javascript\", response.getContentType());\n\t\tassertEquals(\"function foo() { console.log(\\\"hello world\\\"); }\", response.getContentAsString());\n\t}","id":90937,"modified_method":"@Test\n\tpublic void getResourceFromSubDirectoryOfAlternatePath() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/js/baz.js\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\n\t\tassertEquals(\"text/javascript\", this.response.getContentType());\n\t\tassertEquals(\"function foo() { console.log(\\\"hello world\\\"); }\", this.response.getContentAsString());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test(expected=IllegalStateException.class)\n\tpublic void noPathWithinHandlerMappingAttribute() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t}","id":90938,"modified_method":"@Test(expected=IllegalStateException.class)\n\tpublic void noPathWithinHandlerMappingAttribute() throws Exception {\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void getResourceFromAlternatePath() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/baz.css\");\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(\"text/css\", response.getContentType());\n\t\tassertEquals(17, response.getContentLength());\n\t\tassertTrue(Long.valueOf(response.getHeader(\"Expires\")) >= System.currentTimeMillis() - 1000 + (3600 * 1000));\n\t\tassertEquals(\"max-age=3600, must-revalidate\", response.getHeader(\"Cache-Control\"));\n\t\tassertTrue(response.containsHeader(\"Last-Modified\"));\n\t\tassertEquals(Long.valueOf(response.getHeader(\"Last-Modified\")).longValue(),\n\t\t\t\tnew ClassPathResource(\"testalternatepath/baz.css\", getClass()).getFile().lastModified());\n\t\tassertEquals(\"h1 { color:red; }\", response.getContentAsString());\n\t}","id":90939,"modified_method":"@Test\n\tpublic void getResourceFromAlternatePath() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/baz.css\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\n\t\tassertEquals(\"text/css\", this.response.getContentType());\n\t\tassertEquals(17, this.response.getContentLength());\n\t\tassertTrue(headerAsLong(\"Expires\") >= System.currentTimeMillis() - 1000 + (3600 * 1000));\n\t\tassertEquals(\"max-age=3600, must-revalidate\", this.response.getHeader(\"Cache-Control\"));\n\t\tassertTrue(this.response.containsHeader(\"Last-Modified\"));\n\t\tassertEquals(headerAsLong(\"Last-Modified\"), resourceLastModified(\"testalternatepath/baz.css\"));\n\t\tassertEquals(\"h1 { color:red; }\", this.response.getContentAsString());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test(expected=HttpRequestMethodNotSupportedException.class)\n\tpublic void unsupportedHttpMethod() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.css\");\n\t\trequest.setMethod(\"POST\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t}","id":90940,"modified_method":"@Test(expected=HttpRequestMethodNotSupportedException.class)\n\tpublic void unsupportedHttpMethod() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.css\");\n\t\tthis.request.setMethod(\"POST\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void missingResourcePath() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"\");\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(404, response.getStatus());\n\t}","id":90941,"modified_method":"@Test\n\tpublic void missingResourcePath() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t\tassertEquals(404, this.response.getStatus());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void getResourceViaDirectoryTraversal() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setMethod(\"GET\");\n\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"../testsecret/secret.txt\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(404, response.getStatus());\n\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"test/../../testsecret/secret.txt\");\n\t\tresponse = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(404, response.getStatus());\n\n\t\thandler.setLocations(Arrays.<Resource>asList(new ClassPathResource(\"testsecret/\", getClass())));\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"secret.txt\");\n\t\tresponse = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(200, response.getStatus());\n\t\tassertEquals(\"text/plain\", response.getContentType());\n\t\tassertEquals(\"big secret\", response.getContentAsString());\n\t}","id":90942,"modified_method":"@Test\n\tpublic void getResourceViaDirectoryTraversal() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"../testsecret/secret.txt\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t\tassertEquals(404, this.response.getStatus());\n\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"test/../../testsecret/secret.txt\");\n\t\tthis.response = new MockHttpServletResponse();\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t\tassertEquals(404, this.response.getStatus());\n\n\t\tthis.handler.setLocations(Arrays.<Resource>asList(new ClassPathResource(\"testsecret/\", getClass())));\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"secret.txt\");\n\t\tthis.response = new MockHttpServletResponse();\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t\tassertEquals(200, this.response.getStatus());\n\t\tassertEquals(\"text/plain\", this.response.getContentType());\n\t\tassertEquals(\"big secret\", this.response.getContentAsString());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void getResource() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.css\");\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(\"text/css\", response.getContentType());\n\t\tassertEquals(17, response.getContentLength());\n\t\tassertTrue(Long.valueOf(response.getHeader(\"Expires\")) >= System.currentTimeMillis() - 1000 + (3600 * 1000));\n\t\tassertEquals(\"max-age=3600, must-revalidate\", response.getHeader(\"Cache-Control\"));\n\t\tassertTrue(response.containsHeader(\"Last-Modified\"));\n\t\tassertEquals(Long.valueOf(response.getHeader(\"Last-Modified\")).longValue(),\n\t\t\t\tnew ClassPathResource(\"test/foo.css\", getClass()).getFile().lastModified());\n\t\tassertEquals(\"h1 { color:red; }\", response.getContentAsString());\n\t}","id":90943,"modified_method":"@Test\n\tpublic void getResource() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.css\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\n\t\tassertEquals(\"text/css\", this.response.getContentType());\n\t\tassertEquals(17, this.response.getContentLength());\n\t\tassertTrue(headerAsLong(\"Expires\") >= System.currentTimeMillis() - 1000 + (3600 * 1000));\n\t\tassertEquals(\"max-age=3600, must-revalidate\", this.response.getHeader(\"Cache-Control\"));\n\t\tassertTrue(this.response.containsHeader(\"Last-Modified\"));\n\t\tassertEquals(headerAsLong(\"Last-Modified\"), resourceLastModified(\"test/foo.css\"));\n\t\tassertEquals(\"h1 { color:red; }\", this.response.getContentAsString());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void directory() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/js/\");\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(404, response.getStatus());\n\t}","id":90944,"modified_method":"@Test\n\tpublic void directory() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/js/\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t\tassertEquals(404, this.response.getStatus());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tList<Resource> resourcePaths = new ArrayList<Resource>();\n\t\tresourcePaths.add(new ClassPathResource(\"test/\", getClass()));\n\t\tresourcePaths.add(new ClassPathResource(\"testalternatepath/\", getClass()));\n\t\thandler = new ResourceHttpRequestHandler();\n\t\thandler.setLocations(resourcePaths);\n\t\thandler.setCacheSeconds(3600);\n\t\thandler.setServletContext(new TestServletContext());\n\t\thandler.afterPropertiesSet();\n\t}","id":90945,"modified_method":"@Before\n\tpublic void setUp() throws Exception {\n\t\tList<Resource> paths = new ArrayList<>(2);\n\t\tpaths.add(new ClassPathResource(\"test/\", getClass()));\n\t\tpaths.add(new ClassPathResource(\"testalternatepath/\", getClass()));\n\n\t\tthis.handler = new ResourceHttpRequestHandler();\n\t\tthis.handler.setLocations(paths);\n\t\tthis.handler.setCacheSeconds(3600);\n\t\tthis.handler.setServletContext(new TestServletContext());\n\t\tthis.handler.afterPropertiesSet();\n\n\t\tthis.request = new MockHttpServletRequest(\"GET\", \"\");\n\t\tthis.response = new MockHttpServletResponse();\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void getResourceWithHtmlMediaType() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.html\");\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(\"text/html\", response.getContentType());\n\t\tassertTrue(Long.valueOf(response.getHeader(\"Expires\")) >= System.currentTimeMillis() - 1000 + (3600 * 1000));\n\t\tassertEquals(\"max-age=3600, must-revalidate\", response.getHeader(\"Cache-Control\"));\n\t\tassertTrue(response.containsHeader(\"Last-Modified\"));\n\t\tassertEquals(Long.valueOf(response.getHeader(\"Last-Modified\")).longValue(),\n\t\t\t\tnew ClassPathResource(\"test/foo.html\", getClass()).getFile().lastModified());\n\t}","id":90946,"modified_method":"@Test\n\tpublic void getResourceWithHtmlMediaType() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.html\");\n\t\tthis.handler.handleRequest(this.request, this.response);\n\n\t\tassertEquals(\"text/html\", this.response.getContentType());\n\t\tassertTrue(headerAsLong(\"Expires\") >= System.currentTimeMillis() - 1000 + (3600 * 1000));\n\t\tassertEquals(\"max-age=3600, must-revalidate\", this.response.getHeader(\"Cache-Control\"));\n\t\tassertTrue(this.response.containsHeader(\"Last-Modified\"));\n\t\tassertEquals(headerAsLong(\"Last-Modified\"), resourceLastModified(\"test/foo.html\"));\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void modified() throws Exception {\n\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n\t\trequest.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.css\");\n\t\trequest.addHeader(\"If-Modified-Since\",\n\t\t\t\tnew ClassPathResource(\"test/foo.css\", getClass()).getFile().lastModified() / 1000 * 1000 - 1);\n\t\trequest.setMethod(\"GET\");\n\t\tMockHttpServletResponse response = new MockHttpServletResponse();\n\t\thandler.handleRequest(request, response);\n\t\tassertEquals(HttpServletResponse.SC_OK, response.getStatus());\n\t\tassertEquals(\"h1 { color:red; }\", response.getContentAsString());\n\t}","id":90947,"modified_method":"@Test\n\tpublic void modified() throws Exception {\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/foo.css\");\n\t\tthis.request.addHeader(\"If-Modified-Since\", resourceLastModified(\"test/foo.css\") / 1000 * 1000 - 1);\n\t\tthis.handler.handleRequest(this.request, this.response);\n\t\tassertEquals(HttpServletResponse.SC_OK, this.response.getStatus());\n\t\tassertEquals(\"h1 { color:red; }\", this.response.getContentAsString());\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * A transformer can use this method when a resource being transformed\n\t * contains links to other resources. Such links need to be replaced with the\n\t * public facing link as determined by the resource resolver chain (e.g. the\n\t * public URL may have a version inserted).\n\t *\n\t * @param resourcePath the path to a resource that needs to be re-written\n\t * @param request the current request\n\t * @param resource the resource being transformed\n\t * @param transformerChain the transformer chain\n\t * @return the resolved URL or null\n\t */\n\tprotected String resolveUrlPath(String resourcePath, HttpServletRequest request,\n\t\t\tResource resource, ResourceTransformerChain transformerChain) {\n\n\t\tif (!resourcePath.startsWith(\"/\")) {\n\t\t\t// try resolving as relative path\n\t\t\treturn transformerChain.getResolverChain().resolveUrlPath(resourcePath, Arrays.asList(resource));\n\t\t}\n\t\telse {\n\t\t\t// full resource path\n\t\t\tResourceUrlProvider urlProvider = findResourceUrlProvider(request);\n\t\t\treturn (urlProvider != null ? urlProvider.getForRequestUrl(request, resourcePath) : null);\n\t\t}\n\t}","id":90948,"modified_method":"/**\n\t * A transformer can use this method when a resource being transformed\n\t * contains links to other resources. Such links need to be replaced with the\n\t * public facing link as determined by the resource resolver chain (e.g. the\n\t * public URL may have a version inserted).\n\t *\n\t * @param resourcePath the path to a resource that needs to be re-written\n\t * @param request the current request\n\t * @param resource the resource being transformed\n\t * @param transformerChain the transformer chain\n\t * @return the resolved URL or null\n\t */\n\tprotected String resolveUrlPath(String resourcePath, HttpServletRequest request,\n\t\t\tResource resource, ResourceTransformerChain transformerChain) {\n\n\t\tif (resourcePath.startsWith(\"/\")) {\n\t\t\t// full resource path\n\t\t\tResourceUrlProvider urlProvider = findResourceUrlProvider(request);\n\t\t\treturn (urlProvider != null ? urlProvider.getForRequestUrl(request, resourcePath) : null);\n\t\t}\n\t\telse {\n\t\t\t// try resolving as relative path\n\t\t\treturn transformerChain.getResolverChain().resolveUrlPath(resourcePath, Arrays.asList(resource));\n\t\t}\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\tpublic void setUp() {\n\t\tVersionResourceResolver versionResolver = new VersionResourceResolver();\n\t\tversionResolver.setStrategyMap(Collections.singletonMap(\"/**\", new ContentVersionStrategy()));\n\n\t\tList<ResourceResolver> resolvers = new ArrayList<>();\n\t\tresolvers.add(versionResolver);\n\t\tresolvers.add(new PathResourceResolver());\n\t\tthis.transformerChain = new DefaultResourceTransformerChain(new DefaultResourceResolverChain(resolvers), null);\n\n\t\tList<Resource> locations = new ArrayList<>();\n\t\tlocations.add(new ClassPathResource(\"test/\", getClass()));\n\n\t\tResourceHttpRequestHandler handler = new ResourceHttpRequestHandler();\n\t\thandler.setLocations(locations);\n\t\thandler.setResourceResolvers(resolvers);\n\n\t\tResourceUrlProvider urlProvider = new ResourceUrlProvider();\n\t\turlProvider.setHandlerMap(Collections.singletonMap(\"/resources/**\", handler));\n\n\t\tthis.transformer = new TestResourceTransformerSupport();\n\t\tthis.transformer.setResourceUrlProvider(urlProvider);\n\n\t\tthis.request = new MockHttpServletRequest();\n\t}","id":90949,"modified_method":"@Before\n\tpublic void setUp() {\n\t\tVersionResourceResolver resolver = new VersionResourceResolver();\n\t\tresolver.setStrategyMap(Collections.singletonMap(\"/**\", new ContentVersionStrategy()));\n\t\tList<ResourceResolver> resolvers = Arrays.asList(resolver, new PathResourceResolver());\n\t\tthis.transformerChain = new DefaultResourceTransformerChain(new DefaultResourceResolverChain(resolvers), null);\n\n\t\tthis.transformer = new TestResourceTransformerSupport();\n\t\tthis.transformer.setResourceUrlProvider(createResourceUrlProvider(resolvers));\n\n\t\tthis.request = new MockHttpServletRequest(\"GET\", \"\");\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void rewriteRelativePath() throws Exception {\n\t\tthis.request.setRequestURI(\"/servlet/context/resources/main.css\");\n\t\tthis.request.setMethod(\"GET\");\n\t\tthis.request.setServletPath(\"/servlet\");\n\t\tthis.request.setContextPath(\"/context\");\n\t\tthis.request.setAttribute(HandlerMapping.PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE, \"/resources/main.css\");\n\n\t\tResource mainCss = new ClassPathResource(\"test/main.css\", getClass());\n\t\tString actual = this.transformer.resolveUrlPath(\"bar.css\", this.request, mainCss, this.transformerChain);\n\t\tassertEquals(\"bar-11e16cf79faee7ac698c805cf28248d2.css\", actual);\n\t}","id":90950,"modified_method":"@Test\n\tpublic void resolveUrlPathWithRelativePath() throws Exception {\n\t\tthis.request.setRequestURI(\"/context/servlet/resources/main.css\");\n\t\tResource css = new ClassPathResource(\"test/main.css\", getClass());\n\t\tString actual = this.transformer.resolveUrlPath(\"bar.css\", this.request, css, this.transformerChain);\n\t\tassertEquals(\"bar-11e16cf79faee7ac698c805cf28248d2.css\", actual);\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Before\n\t@SuppressWarnings(\"resource\")\n\tpublic void setup() throws Exception {\n\n\t\tthis.filterChain = new MockFilterChain(this.servlet, new ResourceUrlEncodingFilter());\n\n\t\tAnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\n\t\tctx.setServletContext(new MockServletContext());\n\t\tctx.register(WebConfig.class);\n\t\tctx.refresh();\n\n\t\tResourceUrlProvider urlProvider = ctx.getBean(ResourceUrlProvider.class);\n\n\t\tthis.request = new MockHttpServletRequest(\"GET\", \"/\");\n\t\trequest.setAttribute(ResourceUrlProviderExposingInterceptor.RESOURCE_URL_PROVIDER_ATTR, urlProvider);\n\t}","id":90951,"modified_method":"@Before\n\t@SuppressWarnings(\"resource\")\n\tpublic void setup() throws Exception {\n\t\tthis.filterChain = new MockFilterChain(this.servlet, new ResourceUrlEncodingFilter());\n\n\t\tAnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n\t\tcontext.setServletContext(new MockServletContext());\n\t\tcontext.register(WebConfig.class);\n\t\tcontext.refresh();\n\n\t\tthis.request = new MockHttpServletRequest(\"GET\", \"/\");\n\t\tthis.request.setContextPath(\"/myapp\");\n\t\tthis.response = new MockHttpServletResponse();\n\n\t\tObject urlProvider = context.getBean(ResourceUrlProvider.class);\n\t\tthis.request.setAttribute(ResourceUrlProviderExposingInterceptor.RESOURCE_URL_PROVIDER_ATTR, urlProvider);\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void rootServletMapping() throws Exception {\n\n\t\tthis.request.setRequestURI(\"/\");\n\t\tthis.request.setMethod(\"GET\");\n\t\tthis.request.setRequestURI(\"/myapp/index.html\");\n\t\tthis.request.setContextPath(\"/myapp\");\n\t\tthis.request.setServletPath(\"/index.html\");\n\t\tthis.filterChain.doFilter(request, new MockHttpServletResponse());\n\n\t\tString actual = this.servlet.response.encodeURL(\"/myapp/resources/foo.css\");\n\t\tassertEquals(\"/myapp/resources/foo-e36d2e05253c6c7085a91522ce43a0b4.css\", actual);\n\t}","id":90952,"modified_method":"@Test\n\tpublic void resolvePathWithRootServletMapping() throws Exception {\n\t\tthis.request.setRequestURI(\"/myapp/index\");\n\t\tthis.request.setServletPath(\"/index\");\n\t\tthis.filterChain.doFilter(this.request, this.response);\n\n\t\tassertEquals(\"/myapp/resources/foo-e36d2e05253c6c7085a91522ce43a0b4.css\",\n\t\t\t\tresolvePublicResourceUrlPath(\"/myapp/resources/foo.css\"));\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void prefixServletMapping() throws Exception {\n\n\t\tthis.request.setRequestURI(\"/myapp/myservlet/index.html\");\n\t\tthis.request.setContextPath(\"/myapp\");\n\t\tthis.request.setServletPath(\"/myservlet\");\n\t\tthis.filterChain.doFilter(request, new MockHttpServletResponse());\n\n\t\tString actual = this.servlet.response.encodeURL(\"/myapp/myservlet/resources/foo.css\");\n\t\tassertEquals(\"/myapp/myservlet/resources/foo-e36d2e05253c6c7085a91522ce43a0b4.css\", actual);\n\t}","id":90953,"modified_method":"@Test\n\tpublic void resolvePathWithPrefixServletMapping() throws Exception {\n\t\tthis.request.setRequestURI(\"/myapp/myservlet/index\");\n\t\tthis.request.setServletPath(\"/myservlet\");\n\t\tthis.filterChain.doFilter(this.request, this.response);\n\n\t\tassertEquals(\"/myapp/myservlet/resources/foo-e36d2e05253c6c7085a91522ce43a0b4.css\",\n\t\t\t\tresolvePublicResourceUrlPath(\"/myapp/myservlet/resources/foo.css\"));\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void extensionServletMapping() throws Exception {\n\n\t\tthis.request.setRequestURI(\"/myapp/index.html\");\n\t\tthis.request.setContextPath(\"/myapp\");\n\t\tthis.request.setServletPath(\"/index.html\");\n\t\tthis.filterChain.doFilter(request, new MockHttpServletResponse());\n\n\t\tString actual = this.servlet.response.encodeURL(\"/myapp/resources/foo.css\");\n\t\tassertEquals(\"/myapp/resources/foo-e36d2e05253c6c7085a91522ce43a0b4.css\", actual);\n\t}","id":90954,"modified_method":"@Test\n\tpublic void resolvePathWithExtensionServletMapping() throws Exception {\n\t\tthis.request.setRequestURI(\"/myapp/index.html\");\n\t\tthis.request.setServletPath(\"/index.html\");\n\t\tthis.filterChain.doFilter(this.request, this.response);\n\n\t\tassertEquals(\"/myapp/resources/foo-e36d2e05253c6c7085a91522ce43a0b4.css\",\n\t\t\t\tresolvePublicResourceUrlPath(\"/myapp/resources/foo.css\"));\n\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\t\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\t\t\tthis.response = response;\n\t\t}","id":90955,"modified_method":"@Override\n\t\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) {\n\t\t\tthis.wrappedResponse = response;\n\t\t}","commit_id":"fa4ba2a82bc5bad00010dbd96b43dd4019243859","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public static DefaultScopesProvider getInstance(Project project) {\n    for (CustomScopesProvider provider : Extensions.getExtensions(CUSTOM_SCOPES_PROVIDER, project)) {\n      if (provider instanceof DefaultScopesProvider) return (DefaultScopesProvider)provider;\n    }\n    return null;\n  }","id":90956,"modified_method":"public static DefaultScopesProvider getInstance(Project project) {\n    return Extensions.findExtension(CUSTOM_SCOPES_PROVIDER, project, DefaultScopesProvider.class);\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public List<NamedScope> getCustomScopes() {\n    final List<NamedScope> list = new ArrayList<NamedScope>();\n    list.add(getProblemsScope());\n    list.add(getAllScope());\n    list.add(getNonProjectFilesScope());\n    return list;\n  }","id":90957,"modified_method":"@NotNull\n  public List<NamedScope> getCustomScopes() {\n    return Arrays.asList(getProblemsScope(), getAllScope());\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NamedScope getProblemsScope() {\n    if (myProblemsScope == null) {\n      myProblemsScope = new NamedScope(IdeBundle.message(\"predefined.scope.problems.name\"), new PackageSet() {\n        public boolean contains(PsiFile file, NamedScopesHolder holder) {\n          return file.getProject() == myProject && WolfTheProblemSolver.getInstance(myProject).isProblemFile(file.getVirtualFile());\n        }\n\n        public PackageSet createCopy() {\n          return this;\n        }\n\n        public String getText() {\n          return FilePatternPackageSet.SCOPE_FILE + \":*//*\";\n        }\n\n        public int getNodePriority() {\n          return 1;\n        }\n      });\n    }\n    return myProblemsScope;\n  }","id":90958,"modified_method":"public NamedScope getProblemsScope() {\n    return myProblemsScope;\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DefaultScopesProvider(Project project) {\n    myProject = project;\n  }","id":90959,"modified_method":"public DefaultScopesProvider(Project project) {\n    myProject = project;\n    final String text = FilePatternPackageSet.SCOPE_FILE + \":*//*\";\n    myProblemsScope = new NamedScope(IdeBundle.message(\"predefined.scope.problems.name\"), new AbstractPackageSet(text, myProject) {\n      public boolean contains(PsiFile file, NamedScopesHolder holder) {\n        return file.getProject() == myProject\n               && WolfTheProblemSolver.getInstance(myProject).isProblemFile(file.getVirtualFile());\n      }\n    });\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static NamedScope getAllScope() {\n    return NamedScopeHolder.myAllScope;\n  }","id":90960,"modified_method":"public static NamedScope getAllScope() {\n    return AllScopeHolder.ALL;\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PackagesScopesProvider(Project project) {\n    myProject = project;\n  }","id":90961,"modified_method":"public PackagesScopesProvider(Project project) {\n    myProjectTestScope = new TestsScope(project);\n    myProjectProductionScope = new ProjectProductionScope(project);\n    myNonProjectScope = new NonProjectFilesScope(project);\n    myScopes = Arrays.asList(myProjectProductionScope, myNonProjectScope, myProjectTestScope);\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static PackagesScopesProvider getInstance(Project project) {\n    for (CustomScopesProvider provider : Extensions.getExtensions(CUSTOM_SCOPES_PROVIDER, project)) {\n      if (provider instanceof PackagesScopesProvider) return (PackagesScopesProvider)provider;\n    }\n    return null;\n  }","id":90962,"modified_method":"public static PackagesScopesProvider getInstance(Project project) {\n    return Extensions.findExtension(CUSTOM_SCOPES_PROVIDER, project, PackagesScopesProvider.class);\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public List<NamedScope> getCustomScopes() {\n    final List<NamedScope> list = new ArrayList<NamedScope>();\n    list.add(getProjectProductionScope());\n    list.add(getProjectTestScope());\n    return list;\n  }","id":90963,"modified_method":"@NotNull\n  public List<NamedScope> getCustomScopes() {\n    return myScopes;\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NamedScope getProjectProductionScope() {\n    if (myProjectProductionScope == null) {\n      final ProjectFileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n      myProjectProductionScope = new NamedScope(IdeBundle.message(\"predefined.scope.production.name\"), new PackageSet() {\n        public boolean contains(PsiFile file, NamedScopesHolder holder) {\n          final VirtualFile virtualFile = file.getVirtualFile();\n          return file.getProject() == myProject\n                 && virtualFile != null\n                 && !index.isInTestSourceContent(virtualFile)\n                 && !index.isInLibraryClasses(virtualFile)\n                 && !index.isInLibrarySource(virtualFile)\n            ;\n        }\n\n        public PackageSet createCopy() {\n          return this;\n        }\n\n        public String getText() {\n          return PatternPackageSet.SCOPE_SOURCE+\":*..*\";\n        }\n\n        public int getNodePriority() {\n          return 0;\n        }\n      });\n    }\n    return myProjectProductionScope;\n  }","id":90964,"modified_method":"public NamedScope getProjectProductionScope() {\n    return myProjectProductionScope;\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public NamedScope getProjectTestScope() {\n    if (myProjectTestScope == null) {\n      final ProjectFileIndex index = ProjectRootManager.getInstance(myProject).getFileIndex();\n      myProjectTestScope = new NamedScope(IdeBundle.message(\"predefined.scope.tests.name\"), new PackageSet() {\n        public boolean contains(PsiFile file, NamedScopesHolder holder) {\n          final VirtualFile virtualFile = file.getVirtualFile();\n          return file.getProject() == myProject && virtualFile != null && index.isInTestSourceContent(virtualFile);\n        }\n\n        public PackageSet createCopy() {\n          return this;\n        }\n\n        public String getText() {\n          return PatternPackageSet.SCOPE_TEST+\":*..*\";\n        }\n\n        public int getNodePriority() {\n          return 0;\n        }\n      });\n    }\n    return myProjectTestScope;\n  }","id":90965,"modified_method":"public NamedScope getProjectTestScope() {\n    return myProjectTestScope;\n  }","commit_id":"e310487092e1e9251302ec518c186a587d8fccb4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Various geometry-related checks:<ul>\n     * <li>{@link #NON_CLOSED_WAY}: Multipolygon is not closed<\/li>\n     * <li>{@link #INNER_WAY_OUTSIDE}: Multipolygon inner way is outside<\/li>\n     * <li>{@link #CROSSING_WAYS}: Intersection between multipolygon ways<\/li>\n     * <\/ul>\n     * @param r relation\n     * @param polygon multipolygon\n     */\n    private void checkGeometry(Relation r, Multipolygon polygon) {\n        List<Node> openNodes = polygon.getOpenEnds();\n        if (!openNodes.isEmpty()) {\n            List<OsmPrimitive> primitives = new LinkedList<>();\n            primitives.add(r);\n            primitives.addAll(openNodes);\n            Arrays.asList(openNodes, r);\n            addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon is not closed\"), NON_CLOSED_WAY,\n                    primitives, openNodes));\n        }\n\n        // For painting is used Polygon class which works with ints only. For validation we need more precision\n        List<GeneralPath> outerPolygons = createPolygons(polygon.getOuterPolygons());\n        for (Multipolygon.PolyData pdInner : polygon.getInnerPolygons()) {\n            boolean outside = true;\n            boolean crossing = false;\n            Multipolygon.PolyData outerWay = null;\n            for (int i = 0; i < polygon.getOuterPolygons().size(); i++) {\n                GeneralPath outer = outerPolygons.get(i);\n                Intersection intersection = getPolygonIntersection(outer, pdInner.getNodes());\n                outside = outside & intersection == Intersection.OUTSIDE;\n                if (intersection == Intersection.CROSSING) {\n                    crossing = true;\n                    outerWay = polygon.getOuterPolygons().get(i);\n                }\n            }\n            if (outside || crossing) {\n                List<List<Node>> highlights = new ArrayList<>();\n                highlights.add(pdInner.getNodes());\n                if (outside) {\n                    addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon inner way is outside\"),\n                            INNER_WAY_OUTSIDE, Collections.singletonList(r), highlights));\n                } else if (outerWay != null) {\n                    highlights.add(outerWay.getNodes());\n                    addError(r, new TestError(this, Severity.WARNING, tr(\"Intersection between multipolygon ways\"),\n                            CROSSING_WAYS, Collections.singletonList(r), highlights));\n                }\n            }\n        }\n    }","id":90966,"modified_method":"/**\n     * Various geometry-related checks:<ul>\n     * <li>{@link #NON_CLOSED_WAY}: Multipolygon is not closed<\/li>\n     * <li>{@link #INNER_WAY_OUTSIDE}: Multipolygon inner way is outside<\/li>\n     * <li>{@link #CROSSING_WAYS}: Intersection between multipolygon ways<\/li>\n     * <\/ul>\n     * @param r relation\n     * @param polygon multipolygon\n     */\n    private void checkGeometry(Relation r, Multipolygon polygon) {\n        List<Node> openNodes = polygon.getOpenEnds();\n        if (!openNodes.isEmpty()) {\n            List<OsmPrimitive> primitives = new LinkedList<>();\n            primitives.add(r);\n            primitives.addAll(openNodes);\n            addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon is not closed\"), NON_CLOSED_WAY,\n                    primitives, openNodes));\n        }\n\n        // For painting is used Polygon class which works with ints only. For validation we need more precision\n        List<GeneralPath> outerPolygons = createPolygons(polygon.getOuterPolygons());\n        for (Multipolygon.PolyData pdInner : polygon.getInnerPolygons()) {\n            boolean outside = true;\n            for (int i = 0; i < polygon.getOuterPolygons().size(); i++) {\n                Intersection intersection = getPolygonIntersection(outerPolygons.get(i), pdInner.getNodes());\n                outside = outside & intersection == Intersection.OUTSIDE;\n                if (intersection == Intersection.CROSSING) {\n                    Multipolygon.PolyData outerWay = polygon.getOuterPolygons().get(i);\n                    if (outerWay != null) {\n                        addError(r, new TestError(this, Severity.WARNING, tr(\"Intersection between multipolygon ways\"),\n                                CROSSING_WAYS, Collections.singletonList(r), Arrays.asList(pdInner.getNodes(), outerWay.getNodes())));\n                    }\n                }\n            }\n            if (outside) {\n                addError(r, new TestError(this, Severity.WARNING, tr(\"Multipolygon inner way is outside\"),\n                        INNER_WAY_OUTSIDE, Collections.singletonList(r), Arrays.asList(pdInner.getNodes())));\n            }\n        }\n    }","commit_id":"67a397898cd6a5f6dca4d0563546c804494829e4","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n\tpublic void clear() {\n\t\tif(ctx != null && ctx.getSettings() != null) {\n\t\t\tctx.getSettings().APPLICATION_MODE.removeListener(this);\n\t\t\tabandonAudioFocus();\n\t\t}\n\t\tctx = null;\n\t\tprologSystem = null;\n\t}","id":90967,"modified_method":"@Override\n\tpublic void clear() {\n\t\tif(ctx != null && ctx.getSettings() != null) {\n\t\t\tctx.getSettings().APPLICATION_MODE.removeListener(this);\n\t\t}\n\t\tabandonAudioFocus();\n\t\tctx = null;\n\t\tprologSystem = null;\n\t}","commit_id":"61aa580dec24d3f497b028c9c82243ca409ece19","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected synchronized void abandonAudioFocus() {\n\t\tlog.debug(\"abandonAudioFocus\");\n\t\tif ((ctx.getSettings().AUDIO_STREAM_GUIDANCE.get() == 0) || (btScoStatus == true)) {\n\t\t\ttoggleBtSco(false);\n\t\t}\n\t\tif (mAudioFocusHelper != null) {\n\t\t\tmAudioFocusHelper.abandonFocus(ctx, streamType);\n\t\t\tmAudioFocusHelper = null;\n\t\t}\n\t}","id":90968,"modified_method":"protected synchronized void abandonAudioFocus() {\n\t\tlog.debug(\"abandonAudioFocus\");\n\t\tif ((ctx != null && ctx.getSettings().AUDIO_STREAM_GUIDANCE.get() == 0) || (btScoStatus == true)) {\n\t\t\ttoggleBtSco(false);\n\t\t}\n\t\tif (ctx != null && mAudioFocusHelper != null) {\n\t\t\tmAudioFocusHelper.abandonFocus(ctx, streamType);\n\t\t}\n\t\tmAudioFocusHelper = null;\n\t}","commit_id":"61aa580dec24d3f497b028c9c82243ca409ece19","url":"https://github.com/osmandapp/Osmand"},{"original_method":"protected synchronized void requestAudioFocus() {\n\t\tlog.debug(\"requestAudioFocus\");\n\t\tif (android.os.Build.VERSION.SDK_INT >= 8) {\n\t\t\tmAudioFocusHelper = getAudioFocus();\n\t\t}\n\t\tif (mAudioFocusHelper != null && ctx != null) {\n\t\t\tmAudioFocusHelper.requestFocus(ctx, streamType);\n\t\t}\n\t\t// If AudioManager.STREAM_VOICE_CALL try using BT SCO:\n\t\tif (ctx != null && ctx.getSettings().AUDIO_STREAM_GUIDANCE.get() == 0) {\n\t\t\ttoggleBtSco(true);\n\t\t}\n\t}","id":90969,"modified_method":"protected synchronized void requestAudioFocus() {\n\t\tlog.debug(\"requestAudioFocus\");\n\t\tif (android.os.Build.VERSION.SDK_INT >= 8) {\n\t\t\tmAudioFocusHelper = getAudioFocus();\n\t\t}\n\t\tif (mAudioFocusHelper != null && ctx != null) {\n\t\t\tboolean audioFocusGranted = mAudioFocusHelper.requestFocus(ctx, streamType);\n\t\t\t// If AudioManager.STREAM_VOICE_CALL try using BT SCO:\n\t\t\tif (audioFocusGranted && ctx.getSettings().AUDIO_STREAM_GUIDANCE.get() == 0) {\n\t\t\t\ttoggleBtSco(true);\n\t\t\t}\n\t\t}\n\t}","commit_id":"61aa580dec24d3f497b028c9c82243ca409ece19","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void stop(){\n\t\tif (filesToPlay != null){\n\t\t\tfilesToPlay.clear();\n\t\t}\n\t\tif (mediaPlayer != null){\n\t\t\tmediaPlayer.stop();\n\t\t}\n\t\t// TODO: Issue #2810: Audio focus issues when \"off route\" is detected during an ongoing prompt (then stop() is called here)\n\t\tif (ctx != null) {\n\t\t\tabandonAudioFocus();\n\t\t}\n\t}","id":90970,"modified_method":"@Override\n\tpublic void stop(){\n\t\tif (filesToPlay != null){\n\t\t\tfilesToPlay.clear();\n\t\t}\n\t\tif (mediaPlayer != null){\n\t\t\tmediaPlayer.stop();\n\t\t}\n\t\tabandonAudioFocus();\n\t}","commit_id":"61aa580dec24d3f497b028c9c82243ca409ece19","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic synchronized void playCommands(CommandBuilder builder) {\n\t\tfinal List<String> execute = builder.execute(); //list of strings, the speech text, play it\n\t\tStringBuilder bld = new StringBuilder();\n\t\tfor (String s : execute) {\n\t\t\tbld.append(s).append(' ');\n\t\t}\n\t\tsendAlertToPebble(bld.toString());\n\t\tif (mTts != null && !vrt.isMute() && speechAllowed) {\n\t\t\tif (ttsRequests++ == 0) {\n\t\t\t\trequestAudioFocus();\n\t\t\t\t// Delay first prompt of each batch to allow BT SCO connection being established\n\t\t\t\tif (ctx.getSettings().AUDIO_STREAM_GUIDANCE.get() == 0) {\n\t\t\t\t\tttsRequests++;\n\t\t\t\t\tif (android.os.Build.VERSION.SDK_INT < 21) {\n\t\t\t\t\t\tparams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID,\"\"+System.currentTimeMillis());\n\t\t\t\t\t\tmTts.playSilence(BT_SCO_DELAY, TextToSpeech.QUEUE_ADD, params);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmTts.playSilentUtterance(BT_SCO_DELAY, TextToSpeech.QUEUE_ADD, \"\"+System.currentTimeMillis());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.debug(\"ttsRequests=\"+ttsRequests);\n\t\t\tparams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID,\"\"+System.currentTimeMillis());\n\t\t\tmTts.speak(bld.toString(), TextToSpeech.QUEUE_ADD, params);\n\t\t\t// Audio focus will be released when onUtteranceCompleted() completed is called by the TTS engine.\n\t\t} else if (ctx != null) {\n\t\t\tsendAlertToAndroidWear(ctx, bld.toString());\n\t\t}\n\t}","id":90971,"modified_method":"@Override\n\tpublic synchronized void playCommands(CommandBuilder builder) {\n\t\tfinal List<String> execute = builder.execute(); //list of strings, the speech text, play it\n\t\tStringBuilder bld = new StringBuilder();\n\t\tfor (String s : execute) {\n\t\t\tbld.append(s).append(' ');\n\t\t}\n\t\tsendAlertToPebble(bld.toString());\n\t\tif (mTts != null && !vrt.isMute() && speechAllowed) {\n\t\t\tif (ttsRequests++ == 0) {\n\t\t\t\trequestAudioFocus();\n\t\t\t\t// Delay first prompt of each batch to allow BT SCO connection being established\n\t\t\t\tif (ctx.getSettings().AUDIO_STREAM_GUIDANCE.get() == 0) {\n\t\t\t\t\tttsRequests++;\n\t\t\t\t\tif (android.os.Build.VERSION.SDK_INT < 21) {\n\t\t\t\t\t\tparams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID,\"\"+System.currentTimeMillis());\n\t\t\t\t\t\tmTts.playSilence(BT_SCO_DELAY, TextToSpeech.QUEUE_ADD, params);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmTts.playSilentUtterance(BT_SCO_DELAY, TextToSpeech.QUEUE_ADD, \"\"+System.currentTimeMillis());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlog.debug(\"ttsRequests=\"+ttsRequests);\n\t\t\tparams.put(TextToSpeech.Engine.KEY_PARAM_UTTERANCE_ID,\"\"+System.currentTimeMillis());\n\t\t\tmTts.speak(bld.toString(), TextToSpeech.QUEUE_ADD, params);\n\t\t\t// Audio focus will be released when onUtteranceCompleted() completed is called by the TTS engine.\n\t\t} else if (ctx != null && vrt.isMute()) {\n\t\t\tsendAlertToAndroidWear(ctx, bld.toString());\n\t\t}\n\t}","commit_id":"61aa580dec24d3f497b028c9c82243ca409ece19","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void internalClear() {\n\t\tttsRequests = 0;\n\t\tspeechAllowed = false;\n\t\tif (mTts != null) {\n\t\t\tmTts.shutdown();\n\t\t\tmTts = null;\n\t\t}\n\t\tmTtsContext = null;\n\t\tif (ctx != null) {\n\t\t\tabandonAudioFocus();\n\t\t}\n\t}","id":90972,"modified_method":"private void internalClear() {\n\t\tttsRequests = 0;\n\t\tspeechAllowed = false;\n\t\tif (mTts != null) {\n\t\t\tmTts.shutdown();\n\t\t\tmTts = null;\n\t\t}\n\t\tabandonAudioFocus();\n\t\tmTtsContext = null;\n\t}","commit_id":"61aa580dec24d3f497b028c9c82243ca409ece19","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void stop(){\n\t\tttsRequests = 0;\n\t\tif (mTts != null){\n\t\t\tmTts.stop();\n\t\t}\n\t\t// TODO: Issue #2810: Audio focus issues when \"off route\" is detected during an ongoing prompt (then stop() is called here)\n\t\tif (ctx != null) {\n\t\t\tabandonAudioFocus();\n\t\t}\n\t}","id":90973,"modified_method":"@Override\n\tpublic void stop(){\n\t\tttsRequests = 0;\n\t\tif (mTts != null){\n\t\t\tmTts.stop();\n\t\t}\n\t\tabandonAudioFocus();\n\t}","commit_id":"61aa580dec24d3f497b028c9c82243ca409ece19","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n     * Sets the initial explorer selection on {@link #init(Object, AsyncCallback)} time, to be overwritten by subclasses\n     * to perform specific actions. By default, the reference of the passed {@link LinkConfig}, if any, is set in the\n     * explorer.\n     */\n    protected void initializeExplorerSelection()\n    {\n        if (!StringUtils.isEmpty(linkData.getReference())) {\n            explorer.setValue(linkData.getReference());\n        }\n        // else leave the tree where the last selection was\n    }","id":90974,"modified_method":"/**\n     * Initializes the selection on {@link #init(Object, AsyncCallback)} time.\n     */\n    protected void initializeSelection()\n    {\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void init(Object data, AsyncCallback< ? > cb)\n    {\n        linkData = (LinkConfig) data;\n        initializeExplorerSelection();\n        cb.onSuccess(null);\n    }","id":90975,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void init(Object data, AsyncCallback< ? > cb)\n    {\n        linkData = (LinkConfig) data;\n        initializeSelection();\n        cb.onSuccess(null);\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void onSubmit(AsyncCallback<Boolean> async)\n    {\n        // get selected file, get its URL and add it\n        String attachment = getExplorer().getSelectedAttachment();\n        if (StringUtils.isEmpty(attachment) && !getExplorer().isNewAttachment()) {\n            Window.alert(Strings.INSTANCE.linkNoAttachmentSelectedError());\n            async.onSuccess(false);\n        } else if (getExplorer().isNewAttachment()) {\n            // prepare the link config for the uplaod attachment step\n            getLinkData().setWiki(getExplorer().getSelectedWiki());\n            getLinkData().setSpace(getExplorer().getSelectedSpace());\n            getLinkData().setPage(getExplorer().getSelectedPage());\n            async.onSuccess(true);\n        } else {\n            String attachmentRef = \"attach:\" + getExplorer().getValue();\n            String attachmentURL = getExplorer().getSelectedResourceURL();\n            getLinkData().setReference(attachmentRef);\n            getLinkData().setUrl(attachmentURL);\n            async.onSuccess(true);\n        }\n    }","id":90976,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void onSubmit(AsyncCallback<Boolean> async)\n    {\n        getCurrentStep().onSubmit(async);\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Creates an attachment selection wizard step with the specified default selection. The selection will be used to\n     * position the attachment selection tree on the resource named by it, unless specified otherwise by the\n     * initialization data.\n     * \n     * @param defaultSelection the default selection of the wiki explorer\n     */\n    public AttachmentSelectorWizardStep(String defaultSelection)\n    {\n        super(false, true, true, defaultSelection);\n        this.defaultSelection = defaultSelection;\n    }","id":90977,"modified_method":"/**\n     * Creates a new attachment selector wizard step from the passed configuration.\n     * \n     * @param editedResource the currently edited resource\n     */\n    public AttachmentSelectorWizardStep(ResourceName editedResource)\n    {\n        this.editedResource = editedResource;\n\n        // instantiate the currentPage\n        mainPanel.addStyleName(\"xLinkStep\");\n\n        Panel buttonsStrip = new FlowPanel();\n        buttonsStrip.addStyleName(\"xToggleButtons\");\n\n        setCurrentPageButton.addClickListener(new ClickListener()\n        {\n            public void onClick(Widget sender)\n            {\n                if (!isCurrentPage) {\n                    toggleCurrentStep();\n                }\n            }\n        });\n\n        setAllPagesButton.addClickListener(new ClickListener()\n        {\n            public void onClick(Widget sender)\n            {\n                if (isCurrentPage) {\n                    toggleCurrentStep();\n                }\n            }\n        });\n        buttonsStrip.add(setCurrentPageButton);\n        buttonsStrip.add(setAllPagesButton);\n\n        mainPanel.add(buttonsStrip);\n\n        // put the current page in by default. Will be toggled on init if necessary, else it will be initialized\n        isCurrentPage = true;\n        setCurrentPageButton.addStyleName(STYLE_SELECTED_BUTTON);\n        setAllPagesButton.removeStyleName(STYLE_SELECTED_BUTTON);\n        mainPanel.add(getCurrentPageStep().display());\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public String getNextStep()\n    {\n        if (getExplorer().isNewAttachment()) {\n            // if a new attachment will be uploaded, invalidate the explorer cache so that the new attachment shows up\n            // in the tree when it will be loaded next. Even if the upload dialog could be canceled and then this is\n            // useless, there is no further point where we could access the explorer to invalidate it.\n            invalidateExplorerData();\n            return LinkWizardSteps.ATTACHUPLOAD.toString();\n        }\n        return LinkWizardSteps.WIKIPAGECONFIG.toString();\n    }","id":90978,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public String getNextStep()\n    {\n        return getCurrentStep().getNextStep();\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void onCancel(AsyncCallback<Boolean> async)\n    {\n        // nothing to do here, just return\n        async.onSuccess(true);\n    }","id":90979,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void onCancel(AsyncCallback<Boolean> async)\n    {\n        getCurrentStep().onCancel(async);\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Gets a document name from the passed parameters, handling the empty wiki, empty space or empty page name.\n     * \n     * @param wiki the wiki of the document\n     * @param space the space of the document\n     * @param page the page name of the targeted document\n     * @return the completed {@link DocumentName} corresponding to the passed parameters, with all the missing values\n     *         completed with defaults\n     */\n    protected DocumentName prepareDocumentName(String wiki, String space, String page)\n    {\n        String newPageName = clearXWikiName(page);\n        String newSpaceName = clearXWikiName(space);\n        String newWikiName = clearXWikiName(wiki);\n        if (StringUtils.isEmpty(wiki)) {\n            newWikiName = getXWikiContext().getDoc().getWikiName();\n        }\n        if (StringUtils.isEmpty(page)) {\n            newPageName = \"WebHome\";\n        }\n        // if we have no space, link to the current doc's space\n        if (StringUtils.isEmpty(space)) {\n            if ((StringUtils.isEmpty(page)) && !StringUtils.isEmpty(wiki)) {\n                // if we have no space set and no page but we have a wiki, then create a link to the mainpage of the\n                // wiki\n                newSpaceName = \"Main\";\n            } else if (StringUtils.isEmpty(wiki)) {\n                // if all are empty, create a link to the current document\n                newSpaceName = getXWikiContext().getDoc().getSpace();\n                newPageName = getXWikiContext().getDoc().getPageName();\n            }\n        }\n        return new DocumentName(newWikiName, newSpaceName, newPageName);\n    }","id":90980,"modified_method":"/**\n     * Gets a document name from the passed parameters, handling the empty wiki, empty space or empty page name.\n     * \n     * @param wiki the wiki of the document\n     * @param space the space of the document\n     * @param page the page name of the targeted document\n     * @return the completed {@link DocumentName} corresponding to the passed parameters, with all the missing values\n     *         completed with defaults\n     */\n    protected DocumentName prepareDocumentName(String wiki, String space, String page)\n    {\n        String newPageName = StringUtils.isEmpty(page) ? page : clearXWikiName(page);\n        String newSpaceName = StringUtils.isEmpty(space) ? space : clearXWikiName(space);\n        String newWikiName = StringUtils.isEmpty(wiki) ? wiki : clearXWikiName(wiki);\n        if (StringUtils.isEmpty(wiki)) {\n            newWikiName = getXWikiContext().getDoc().getWikiName();\n        }\n        if (StringUtils.isEmpty(page)) {\n            newPageName = \"WebHome\";\n        }\n        // if we have no space, link to the current doc's space\n        if (StringUtils.isEmpty(space)) {\n            if ((StringUtils.isEmpty(page)) && !StringUtils.isEmpty(wiki)) {\n                // if we have no space set and no page but we have a wiki, then create a link to the mainpage of the\n                // wiki\n                newSpaceName = \"Main\";\n            } else if (StringUtils.isEmpty(wiki)) {\n                // if all are empty, create a link to the current document\n                newSpaceName = getXWikiContext().getDoc().getSpace();\n                newPageName = getXWikiContext().getDoc().getPageName();\n            }\n        }\n        return new DocumentName(newWikiName, newSpaceName, newPageName);\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see WysiwygService#getAttachmentLink(String, String, String, String)\n     */\n    public LinkConfig getAttachmentLink(String wikiName, String spaceName, String pageName, String attachmentName)\n    {\n        LinkConfig linkConfig = new LinkConfig();\n\n        XWikiContext context = getXWikiContext();\n        // clean attachment filename to be synchronized with all attachment operations\n        String cleanedFileName = context.getWiki().clearName(attachmentName, false, true, context);\n        DocumentName docName = prepareDocumentName(wikiName, spaceName, pageName);\n        DocumentNameSerializer serializer = (DocumentNameSerializer) Utils.getComponent(DocumentNameSerializer.class);\n        String docReference = serializer.serialize(docName);\n        XWikiDocument doc = null;\n        try {\n            doc = context.getWiki().getDocument(docReference, context);\n        } catch (XWikiException e) {\n            // there was a problem with getting the document on the server\n            return null;\n        }\n        if (doc.isNew()) {\n            // the document does not exist, therefore nor does the attachment. Return null\n            return null;\n        }\n        // check for the existence of the attachment\n        if (doc.getAttachment(cleanedFileName) == null) {\n            // attachment is not there, something bad must have happened\n            return null;\n        }\n        // all right, now set the reference and url and return\n        // FIXME: this should not be created like this but got from a serializer\n        String attachmentReference = docReference + \"@\" + cleanedFileName;\n        linkConfig.setReference(attachmentReference);\n        linkConfig.setUrl(doc.getAttachmentURL(cleanedFileName, context));\n\n        return linkConfig;\n    }","id":90981,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see WysiwygService#getAttachmentLink(String, String, String, String)\n     */\n    public LinkConfig getAttachmentLink(String wikiName, String spaceName, String pageName, String attachmentName)\n    {\n        LinkConfig linkConfig = new LinkConfig();\n\n        XWikiContext context = getXWikiContext();\n        // clean attachment filename to be synchronized with all attachment operations\n        String cleanedFileName = context.getWiki().clearName(attachmentName, false, true, context);\n        DocumentName docName = prepareDocumentName(wikiName, spaceName, pageName);\n        DocumentNameSerializer serializer = (DocumentNameSerializer) Utils.getComponent(DocumentNameSerializer.class);\n        String docReference = serializer.serialize(docName);\n        XWikiDocument doc = null;\n        try {\n            doc = context.getWiki().getDocument(docReference, context);\n        } catch (XWikiException e) {\n            // there was a problem with getting the document on the server\n            return null;\n        }\n        if (doc.isNew()) {\n            // the document does not exist, therefore nor does the attachment. Return null\n            return null;\n        }\n        // check for the existence of the attachment\n        if (doc.getAttachment(cleanedFileName) == null) {\n            // attachment is not there, something bad must have happened\n            return null;\n        }\n        // all right, now set the reference and url and return\n        String attachmentReference = getAttachmentReference(docReference, cleanedFileName);\n        linkConfig.setReference(attachmentReference);\n        linkConfig.setUrl(doc.getAttachmentURL(cleanedFileName, context));\n\n        return linkConfig;\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * Builds a {@link LinkWizard} from the passed {@link Config}. The configuration is used to get WYSIWYG editor\n     * specific information for this wizard, such as the current page, etc.\n     * \n     * @param config the context configuration for this {@link LinkWizard}\n     */\n    public LinkWizard(Config config)\n    {\n        super(Strings.INSTANCE.link(), Images.INSTANCE.link().createImage());\n        editedResource = config.getParameter(\"documentName\");\n        this.setProvider(this);\n    }","id":90982,"modified_method":"/**\n     * Builds a {@link LinkWizard} from the passed {@link Config}. The configuration is used to get WYSIWYG editor\n     * specific information for this wizard, such as the current page, etc.\n     * \n     * @param config the context configuration for this {@link LinkWizard}\n     */\n    public LinkWizard(Config config)\n    {\n        super(Strings.INSTANCE.link(), Images.INSTANCE.link().createImage());\n        this.config = config;\n        this.setProvider(this);\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"/**\n     * {@inheritDoc}\n     * \n     * @see WizardStepProvider#getStep(String)\n     */\n    public WizardStep getStep(String name)\n    {\n        LinkWizardSteps requestedStep = parseStepName(name);\n        WizardStep step = stepsMap.get(requestedStep);\n        if (step == null) {\n            switch (requestedStep) {\n                case EMAIL:\n                    step = new EmailAddressLinkWizardStep();\n                    break;\n                case WIKIPAGE:\n                    step = new WikipageSelectorWizardStep(editedResource);\n                    break;\n                case WIKIPAGECREATOR:\n                    step = new CreateNewPageWizardStep();\n                    break;\n                case ATTACHMENT:\n                    step = new AttachmentSelectorWizardStep(editedResource);\n                    break;\n                case ATTACHUPLOAD:\n                    step = new AttachmentUploadWizardStep();\n                    break;\n                case WIKIPAGECONFIG:\n                    step = new LinkConfigWizardStep();\n                    break;\n                case WEBPAGE:\n                    step = new WebPageLinkWizardStep();\n                    break;\n                default:\n                    // nothing here, leave it null\n                    break;\n            }\n            // if something has been created, add it in the map\n            if (step != null) {\n                stepsMap.put(requestedStep, step);\n            }\n        }\n        // return the found or newly created step\n        return step;\n    }","id":90983,"modified_method":"/**\n     * {@inheritDoc}\n     * \n     * @see WizardStepProvider#getStep(String)\n     */\n    public WizardStep getStep(String name)\n    {\n        LinkWizardSteps requestedStep = parseStepName(name);\n        WizardStep step = stepsMap.get(requestedStep);\n        if (step == null) {\n            switch (requestedStep) {\n                case EMAIL:\n                    step = new EmailAddressLinkWizardStep();\n                    break;\n                case WIKIPAGE:\n                    step = new WikipageExplorerWizardStep(getEditedResource());\n                    break;\n                case WIKIPAGECREATOR:\n                    step = new CreateNewPageWizardStep();\n                    break;\n                case ATTACHMENT:\n                    step = dispatchAttachmentSelectorStep();\n                    break;\n                case ATTACHUPLOAD:\n                    step = new AttachmentUploadWizardStep();\n                    break;\n                case WIKIPAGECONFIG:\n                    step = new LinkConfigWizardStep();\n                    break;\n                case WEBPAGE:\n                    step = new WebPageLinkWizardStep();\n                    break;\n                default:\n                    // nothing here, leave it null\n                    break;\n            }\n            // if something has been created, add it in the map\n            if (step != null) {\n                stepsMap.put(requestedStep, step);\n            }\n        }\n        // return the found or newly created step\n        return step;\n    }","commit_id":"af1bee09c7436bc744d32c42424ad84bfd6eca6f","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"public ObjectColor getColor() {\n        ObjectColor color = new ObjectColor();\n        switch (choice) {\n            case \"Black\":\n                color.setBlack(true);\n                break;\n            case \"Blue\":\n                color.setBlue(true);\n                break;\n            case \"Green\":\n                color.setGreen(true);\n                break;\n            case \"Red\":\n                color.setRed(true);\n                break;\n            case \"White\":\n                color.setWhite(true);\n                break;\n        }\n        return color;\n    }","id":90984,"modified_method":"public ObjectColor getColor() {\n        if (choice == null) {\n            return null;\n        }\n        ObjectColor color = new ObjectColor();\n        switch (choice) {\n            case \"Black\":\n                color.setBlack(true);\n                break;\n            case \"Blue\":\n                color.setBlue(true);\n                break;\n            case \"Green\":\n                color.setGreen(true);\n                break;\n            case \"Red\":\n                color.setRed(true);\n                break;\n            case \"White\":\n                color.setWhite(true);\n                break;\n        }\n        return color;\n    }","commit_id":"a3505b6dba4ea9684349d3d8d63243cf9d5c353d","url":"https://github.com/magefree/mage"},{"original_method":"private boolean isInactive(T effect, Game game) {\n        HashSet<Ability> set = effectAbilityMap.get(effect.getId());\n        Iterator<Ability> it = set.iterator();\n        while (it.hasNext()) {\n            Ability ability = it.next();\n            if (ability == null) {\n                it.remove();\n            } else  if (effect.isDiscarded()) {\n                it.remove();\n            } else {\n                switch(effect.getDuration()) {\n                    case WhileOnBattlefield:\n                        if (game.getObject(ability.getSourceId()) == null) {//TODO: does this really works?? object is returned across the game\n                            it.remove();                                \n                        }\n                        break;\n                    case OneUse:\n                        if (effect.isUsed()) {\n                            it.remove();\n                        }\n                        break;\n                    case Custom:\n                    case UntilYourNextTurn:\n                        if (effect.isInactive(ability , game)) {\n                               it.remove();\n                        }\n                }\n            }\n        }\n        return set.isEmpty();\n    }","id":90985,"modified_method":"private boolean isInactive(T effect, Game game) {\n        HashSet<Ability> set = effectAbilityMap.get(effect.getId());\n        if (set == null) {\n            logger.debug(\"No abilities for effect found: \" + effect.toString());\n            return false;\n        }\n        Iterator<Ability> it = set.iterator();\n        while (it.hasNext()) {\n            Ability ability = it.next();\n            if (ability == null) {\n                it.remove();\n            } else  if (effect.isDiscarded()) {\n                it.remove();\n            } else {\n                switch(effect.getDuration()) {\n                    case WhileOnBattlefield:\n                        if (game.getObject(ability.getSourceId()) == null) {//TODO: does this really works?? object is returned across the game\n                            it.remove();                                \n                        }\n                        break;\n                    case OneUse:\n                        if (effect.isUsed()) {\n                            it.remove();\n                        }\n                        break;\n                    case Custom:\n                    case UntilYourNextTurn:\n                        if (effect.isInactive(ability , game)) {\n                               it.remove();\n                        }\n                }\n            }\n        }\n        return set.isEmpty();\n    }","commit_id":"a3505b6dba4ea9684349d3d8d63243cf9d5c353d","url":"https://github.com/magefree/mage"},{"original_method":"private synchronized void startDraft() {\n        for (final Entry<UUID, DraftSession> entry: draftSessions.entrySet()) {\n            if (!entry.getValue().init()) {\n                logger.fatal(\"Unable to initialize client\");\n                //TODO: generate client error message\n                return;\n            }\n        }\n        draft.start();\n    }","id":90986,"modified_method":"private synchronized void startDraft() {\n        for (final Entry<UUID, DraftSession> entry: draftSessions.entrySet()) {\n            if (!entry.getValue().init()) {\n                logger.fatal(\"Unable to initialize client for playerId \" + entry.getKey());\n                //TODO: generate client error message\n                return;\n            }\n        }\n        draft.start();\n    }","commit_id":"a3505b6dba4ea9684349d3d8d63243cf9d5c353d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        boolean isMountain = false;\r\n        Card sourceCard = game.getCard(source.getSourceId());\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        \r\n        if (player == null || sourceCard == null) {\r\n            return false;\r\n        }\r\n        Cards cards = new CardsImpl(Zone.PICK);\r\n        while (player.getLibrary().size() > 0) {\r\n            Card card = player.getLibrary().removeFromTop(game);\r\n            if (card != null) {\r\n                cards.add(card);\r\n                if(card.getCardType().contains(CardType.LAND)){\r\n                    if(card.getSubtype().contains(\"Mountain\")){\r\n                        isMountain = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n        }\r\n        player.revealCards(sourceCard.getName(), cards, game);\r\n        int damage = cards.size();\r\n        if(isMountain == true){\r\n            damage *= 2;\r\n        }\r\n        \r\n        Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));\r\n        if (permanent != null) {\r\n            permanent.damage(damage, source.getSourceId(), game, false, true);\r\n        }\r\n        else{\r\n            Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));\r\n            if (targetPlayer != null) {\r\n                targetPlayer.damage(damage, source.getSourceId(), game, false, true);\r\n            }\r\n        }\r\n        \r\n        TargetCard target = new TargetCard(Zone.PICK, new FilterCard(\"card to put on the bottom of your library\"));\r\n        while (player.isInGame() && cards.size() > 1) {\r\n            player.choose(Outcome.Neutral, cards, target, game);\r\n            Card card = cards.get(target.getFirstTarget(), game);\r\n            if (card != null) {\r\n                cards.remove(card);\r\n                card.moveToZone(Zone.PICK, source.getSourceId(), game, false);\r\n            }\r\n            target.clearChosen();\r\n        }\r\n       \r\n        return true;\r\n    }","id":90987,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        boolean isMountain = false;\r\n        Card sourceCard = game.getCard(source.getSourceId());\r\n        Player player = game.getPlayer(source.getControllerId());\r\n        \r\n        if (player == null || sourceCard == null) {\r\n            return false;\r\n        }\r\n        Cards cards = new CardsImpl();\r\n        while (player.getLibrary().size() > 0) {\r\n            Card card = player.getLibrary().removeFromTop(game);\r\n            if (card != null) {\r\n                cards.add(card);\r\n                if(card.getCardType().contains(CardType.LAND)){\r\n                    if(card.getSubtype().contains(\"Mountain\")){\r\n                        isMountain = true;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n            else{\r\n                break;\r\n            }\r\n        }\r\n        player.revealCards(sourceCard.getName(), cards, game);\r\n        int damage = cards.size();\r\n        if(isMountain == true){\r\n            damage *= 2;\r\n        }\r\n        \r\n        Permanent permanent = game.getPermanent(targetPointer.getFirst(game, source));\r\n        if (permanent != null) {\r\n            permanent.damage(damage, source.getSourceId(), game, false, true);\r\n        }\r\n        else{\r\n            Player targetPlayer = game.getPlayer(targetPointer.getFirst(game, source));\r\n            if (targetPlayer != null) {\r\n                targetPlayer.damage(damage, source.getSourceId(), game, false, true);\r\n            }\r\n        }\r\n        \r\n        TargetCard target = new TargetCard(Zone.LIBRARY, new FilterCard(\"card to put on the bottom of your library\"));\r\n        while (player.isInGame() && cards.size() > 1) {\r\n            player.choose(Outcome.Neutral, cards, target, game);\r\n            Card card = cards.get(target.getFirstTarget(), game);\r\n            if (card != null) {\r\n                player.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.LIBRARY, false, true);\r\n            }\r\n            target.clearChosen();\r\n        }\r\n       \r\n        return true;\r\n    }","commit_id":"a3505b6dba4ea9684349d3d8d63243cf9d5c353d","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        boolean result = false;\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            for (UUID targetId : targetPointer.getTargets(game, source)) {\n                switch (game.getState().getZone(targetId)) {\n                    case BATTLEFIELD:\n                        Permanent permanent = game.getPermanent(targetId);\n                        if (permanent != null) {\n                            result |= controller.moveCardToLibraryWithInfo(permanent, source.getSourceId(), game, Zone.BATTLEFIELD, onTop, true);\n                        }\n                    case GRAVEYARD:\n                        Card card = game.getCard(targetId);\n                        if (card != null && game.getState().getZone(targetId).equals(Zone.GRAVEYARD)) {\n                            result |= controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.GRAVEYARD, onTop, true);\n                        }\n                }\n            }\n        }\n        return result;\n\n    }","id":90988,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        boolean result = false;\n        Player controller = game.getPlayer(source.getControllerId());\n        if (controller != null) {\n            for (UUID targetId : targetPointer.getTargets(game, source)) {\n                switch (game.getState().getZone(targetId)) {\n                    case BATTLEFIELD:\n                        Permanent permanent = game.getPermanent(targetId);\n                        if (permanent != null) {\n                            result |= controller.moveCardToLibraryWithInfo(permanent, source.getSourceId(), game, Zone.BATTLEFIELD, onTop, true);\n                        }\n                        break;\n                    case GRAVEYARD:\n                        Card card = game.getCard(targetId);\n                        if (card != null && game.getState().getZone(targetId).equals(Zone.GRAVEYARD)) {\n                            result |= controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.GRAVEYARD, onTop, true);\n                        }\n                        break;\n                }\n            }\n        }\n        return result;\n\n    }","commit_id":"8de37b2bfa0d18853b4e7bbeb164c5f2a108437f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player shuffler = game.getPlayer(this.getTargetPointer().getFirst(game, source));\r\n        if (shuffler != null) {\r\n            if (shuffler.getHand().size() > 0) {\r\n                TargetCardInHand target = new TargetCardInHand();\r\n                target.setTargetName(\"a card from your hand to put on top of your library\");\r\n                shuffler.choose(Outcome.Detriment, target, source.getSourceId(), game);\r\n                Card card = shuffler.getHand().get(target.getFirstTarget(), game);\r\n                if (card != null) {\r\n                    return card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":90989,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player shuffler = game.getPlayer(this.getTargetPointer().getFirst(game, source));\r\n        if (shuffler != null) {\r\n            if (shuffler.getHand().size() > 0) {\r\n                TargetCardInHand target = new TargetCardInHand();\r\n                target.setTargetName(\"a card from your hand to put on top of your library\");\r\n                shuffler.choose(Outcome.Detriment, target, source.getSourceId(), game);\r\n                Card card = shuffler.getHand().get(target.getFirstTarget(), game);\r\n                if (card != null) {\r\n                    shuffler.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.HAND, true, false);\r\n\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"8de37b2bfa0d18853b4e7bbeb164c5f2a108437f","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (controller != null && sourceObject != null) {\r\n            TargetCardInLibrary target = new TargetCardInLibrary(0, 3, new FilterCreatureCard(\"creature cards\"));\r\n            if (controller.searchLibrary(target, game)) {\r\n                if (target.getTargets().size() > 0) {\r\n                    Cards revealed = new CardsImpl();\r\n                    for (UUID cardId : (List<UUID>) target.getTargets()) {\r\n                        Card card = controller.getLibrary().getCard(cardId, game);\r\n                        revealed.add(card);\r\n                    }\r\n                    controller.revealCards(sourceObject.getName(), revealed, game);\r\n\r\n                    controller.shuffleLibrary(game);\r\n\r\n                    TargetCard targetToLib = new TargetCard(Zone.PICK, new FilterCard(textTop));\r\n                    target.setRequired(true);\r\n                    while (revealed.size() > 1) {\r\n                        controller.choose(Outcome.Neutral, revealed, target, game);\r\n                        Card card = revealed.get(targetToLib.getFirstTarget(), game);\r\n                        if (card != null) {\r\n                            revealed.remove(card);\r\n                            card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                        }\r\n                        targetToLib.clearChosen();\r\n                    }\r\n                    if (revealed.size() == 1) {\r\n                        Card card = revealed.get(revealed.iterator().next(), game);\r\n                        card.moveToZone(Zone.LIBRARY, source.getSourceId(), game, true);\r\n                    }\r\n\r\n                }\r\n\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","id":90990,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (controller != null && sourceObject != null) {\r\n            TargetCardInLibrary target = new TargetCardInLibrary(0, 3, new FilterCreatureCard(\"creature cards\"));\r\n            if (controller.searchLibrary(target, game)) {\r\n                if (target.getTargets().size() > 0) {\r\n                    Cards revealed = new CardsImpl();\r\n                    for (UUID cardId : (List<UUID>) target.getTargets()) {\r\n                        Card card = controller.getLibrary().remove(cardId, game);\r\n                        revealed.add(card);\r\n                    }\r\n                    controller.revealCards(sourceObject.getName(), revealed, game);\r\n                    controller.shuffleLibrary(game);\r\n\r\n                    TargetCard targetToLib = new TargetCard(Zone.PICK, new FilterCard(textTop));\r\n                    target.setRequired(true);\r\n\r\n                    while (revealed.size() > 1 && controller.isInGame()) {\r\n                        controller.choose(Outcome.Neutral, revealed, targetToLib, game);\r\n                        Card card = revealed.get(targetToLib.getFirstTarget(), game);\r\n                        if (card != null) {\r\n                            revealed.remove(card);\r\n                            controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.LIBRARY, true, false);\r\n\r\n                        }\r\n                        targetToLib.clearChosen();\r\n                    }\r\n\r\n                    if (revealed.size() == 1) {\r\n                        Card card = revealed.get(revealed.iterator().next(), game);\r\n                        controller.moveCardToLibraryWithInfo(card, source.getSourceId(), game, Zone.LIBRARY, true, false);\r\n                    }\r\n\r\n                }\r\n\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"6b817b0669c2f362c3ad4d0e8eff3d78bf48e019","url":"https://github.com/magefree/mage"},{"original_method":"/**\n    * Load a document into the editor\n    * \n    * @param selectDocId id of the document to select\n    */\n   private void loadDocument(DocumentId selectDocId)\n   {\n      if (!selectDocId.equals(documentId))\n      {\n         documentId = selectDocId;\n         initialiseTransUnitList();\n\n         dispatcher.execute(new GetTransUnitsNavigation(documentId.getValue(), findMessage, filterViewConfirmationPanel.isFilterUntranslated(), filterViewConfirmationPanel.isFilterNeedReview(), filterViewConfirmationPanel.isFilterTranslated()), new AsyncCallback<GetTransUnitsNavigationResult>()\n         {\n            @Override\n            public void onSuccess(GetTransUnitsNavigationResult result)\n            {\n               transUnitModel.init(result.getTransIdStateList(), result.getIdIndexList());\n            }\n\n            @Override\n            public void onFailure(Throwable caught)\n            {\n               Log.error(\"GetTransUnitsStates failure \" + caught, caught);\n            }\n         });\n      }\n   }","id":90991,"modified_method":"/**\n    * Load a document into the editor\n    * \n    * @param selectDocId id of the document to select\n    */\n   private void loadDocument(DocumentId selectDocId)\n   {\n      if (!selectDocId.equals(documentId))\n      {\n         documentId = selectDocId;\n         initialiseTransUnitList();\n      }\n   }","commit_id":"98cc0b81997ade712e577110b7ee3634a9d4bba6","url":"https://github.com/zanata/zanata-server"},{"original_method":"/**\n    * Clear all current transUnit list and re-query from server. Force to run\n    * requestRows@TableModelHandler\n    */\n   private void initialiseTransUnitList()\n   {\n      display.getTableModel().clearCache();\n      display.getTableModel().setRowCount(TableModel.UNKNOWN_ROW_COUNT);\n      display.gotoPage(0, true);\n   }","id":90992,"modified_method":"/**\n    * Clear all current transUnit list and re-query from server. Force to run\n    * requestRows@TableModelHandler\n    */\n   private void initialiseTransUnitList()\n   {\n      display.getTableModel().clearCache();\n      display.getTableModel().setRowCount(TableModel.UNKNOWN_ROW_COUNT);\n      display.gotoPage(0, true);\n      initialiseTransUnitsNavigation();\n   }","commit_id":"98cc0b81997ade712e577110b7ee3634a9d4bba6","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void gotoPrevState(boolean isNewState, boolean isFuzzyState)\n   {\n      if (isNewState && isFuzzyState)\n      {\n         Log.info(\"go to Prev Fuzzy Or Untranslated State\");\n         // Clean the cache for Next Fuzzy to avoid issues about cache is\n         // obsolete\n         display.getTargetCellEditor().cancelEdit();\n      }\n      else if (isNewState)\n      {\n         Log.info(\"go to Prev Untranslated State\");\n         // Clean the cache for Next Fuzzy to avoid issues about cache is\n         // obsolete\n         display.getTargetCellEditor().cancelEdit();\n      }\n      else if (isFuzzyState)\n      {\n         Log.info(\"go to Prev Fuzzy State\");\n         // Clean the cache for Next Fuzzy to avoid issues about cache is\n         // obsolete\n         display.getTargetCellEditor().cancelEdit();\n      }\n   \n   }","id":90993,"modified_method":"private void gotoPrevState(boolean isNewState, boolean isFuzzyState)\n   {\n      Log.info(\"=============gotoPrevState: New-\" + isNewState + \" Fuzzy-\" + isFuzzyState);\n\n      display.getTargetCellEditor().cancelEdit();\n\n      int prevRowIndex = getPreviousStateRowIndex(isNewState, isFuzzyState);\n      Log.info(\"go to Prev State:\" + prevRowIndex);\n      tableModelHandler.gotoRow(prevRowIndex, true);\n   }","commit_id":"98cc0b81997ade712e577110b7ee3634a9d4bba6","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void gotoNextState(boolean isNewState, boolean isFuzzyState)\n   {\n      if (isNewState && isFuzzyState)\n      {\n         Log.info(\"go to Next Fuzzy Or Untranslated State\");\n\n         display.getTargetCellEditor().cancelEdit();\n         // tableModelHandler.gotoRow(newRowIndex, true);\n      }\n      else if (isNewState)\n      {\n         Log.info(\"go to Next Untranslated State\");\n         display.getTargetCellEditor().cancelEdit();\n      }\n      else if (isFuzzyState)\n      {\n         Log.info(\"go to Next Fuzzy State\");\n         display.getTargetCellEditor().cancelEdit();\n      }\n   }","id":90994,"modified_method":"private void gotoNextState(boolean isNewState, boolean isFuzzyState)\n   {\n      Log.info(\"==========gotoNextState: New-\" + isNewState + \" Fuzzy-\" + isFuzzyState);\n\n      display.getTargetCellEditor().cancelEdit();\n\n      int nextRowIndex = getNextStateRowIndex(isNewState, isFuzzyState);\n      Log.info(\"go to Next State:\" + nextRowIndex);\n      tableModelHandler.gotoRow(nextRowIndex, true);\n   }","commit_id":"98cc0b81997ade712e577110b7ee3634a9d4bba6","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      display.setTableModelHandler(tableModelHandler);\n      display.setPageSize(TableConstants.PAGE_SIZE);\n\n      registerHandler(filterViewConfirmationPanel.getSaveChangesAndFilterButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            saveChangesAndFilter();\n         }\n      }));\n\n      registerHandler(filterViewConfirmationPanel.getSaveFuzzyAndFilterButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            saveFuzzyAndFilter();\n         }\n      }));\n\n      registerHandler(filterViewConfirmationPanel.getDiscardChangesAndFilterButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            discardChangesAndFilter();\n         }\n      }));\n\n      registerHandler(filterViewConfirmationPanel.getCancelFilterButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            cancelFilter();\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(FilterViewEvent.getType(), new FilterViewEventHandler()\n      {\n         @Override\n         public void onFilterView(FilterViewEvent event)\n         {\n            filterTransUnitsView(event);\n         }\n      }));\n\n      registerHandler(display.getSelectionHandlers().addSelectionHandler(new SelectionHandler<TransUnit>()\n      {\n         @Override\n         public void onSelection(SelectionEvent<TransUnit> event)\n         {\n            if (event.getSelectedItem() != null)\n            {\n               display.getTargetCellEditor().savePendingChange(true);\n               selectTransUnit(event.getSelectedItem(), true);\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler()\n      {\n         @Override\n         public void onDocumentSelected(DocumentSelectionEvent event)\n         {\n            loadDocument(event.getDocumentId());\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(FindMessageEvent.getType(), new FindMessageHandler()\n      {\n\n         @Override\n         public void onFindMessage(FindMessageEvent event)\n         {\n            Log.info(\"Find Message Event: \" + event.getMessage());\n            display.getTargetCellEditor().savePendingChange(true);\n            if (selectedTransUnit != null)\n            {\n               Log.info(\"cancelling selection\");\n               display.getTargetCellEditor().clearSelection();\n            }\n            findMessage = event.getMessage();\n            display.setFindMessage(findMessage);\n            if (selectedTransUnit != null)\n            {\n               targetTransUnitId = selectedTransUnit.getId();\n            }\n            initialiseTransUnitList();\n         }\n\n      }));\n\n      registerHandler(eventBus.addHandler(TransUnitUpdatedEvent.getType(), new TransUnitUpdatedEventHandler()\n      {\n         @Override\n         public void onTransUnitUpdated(TransUnitUpdatedEvent event)\n         {\n            // assume update was successful\n            if (documentId != null && documentId.equals(event.getUpdateInfo().getDocumentId()))\n            {\n               // if its different user,\n               if (!event.getSessionId().equals(identity.getSessionId()))\n               {\n                  if (selectedTransUnit != null && selectedTransUnit.getId().equals(event.getUpdateInfo().getTransUnit().getId()))\n                  {\n                     Log.info(\"selected TU updated; clear selection\");\n                     eventBus.fireEvent(new RequestValidationEvent());\n                  }\n\n                  // - add TU index to model\n                  Integer rowIndex = getRowIndex(event.getUpdateInfo().getTransUnit());\n                  if (rowIndex != null)\n                  {\n                     Log.info(\"onTransUnitUpdated - update row:\" + rowIndex);\n                     display.getTableModel().setRowValueOverride(rowIndex, event.getUpdateInfo().getTransUnit());\n                  }\n               }\n               else\n               {\n                  Integer rowIndex = getRowIndex(event.getUpdateInfo().getTransUnit());\n                  if (rowIndex != null)\n                  {\n                     display.getRowValue(rowIndex).OverrideWith(event.getUpdateInfo().getTransUnit());\n                     display.getTableModel().clearCache();\n                  }\n               }\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(NavTransUnitEvent.getType(), new NavTransUnitHandler()\n      {\n         @Override\n         public void onNavTransUnit(NavTransUnitEvent event)\n         {\n            if (selectedTransUnit != null)\n            {\n               // int step = event.getStep();\n               // Send message to server to stop editing current\n               // selection\n               // stopEditing(selectedTransUnit);\n\n               // If goto Next or Prev Fuzzy/New Trans Unit\n               if (event.getRowType() == NavigationType.PrevEntry)\n               {\n                  targetContentsPresenter.saveAsApprovedAndMovePrevious();\n               }\n\n               if (event.getRowType() == NavigationType.NextEntry)\n               {\n                  targetContentsPresenter.saveAsApprovedAndMoveNext();\n               }\n\n               if (event.getRowType() == NavigationType.PrevState)\n               {\n                  targetContentsPresenter.moveToNextState(NavigationType.PrevEntry);\n               }\n\n               if (event.getRowType() == NavigationType.NextState)\n               {\n                  targetContentsPresenter.moveToNextState(NavigationType.NextEntry);\n               }\n\n               if (event.getRowType() == NavigationType.FirstEntry)\n               {\n                  targetContentsPresenter.saveAndMoveRow(NavigationType.FirstEntry);\n               }\n\n               if (event.getRowType() == NavigationType.LastEntry)\n               {\n                  targetContentsPresenter.saveAndMoveRow(NavigationType.LastEntry);\n               }\n\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(OpenEditorEvent.getType(), new OpenEditorEventHandler()\n      {\n         @Override\n         public void onOpenEditor(OpenEditorEvent event)\n         {\n            tableModelHandler.gotoRowInCurrentPage(event.getRowNum(), true);\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            boolean readOnly = event.isReadOnly();\n            workspaceContext.setReadOnly(readOnly);\n            configHolder.setDisplayButtons(false);\n            eventBus.fireEvent(new UserConfigChangeEvent());\n            display.getTargetCellEditor().setReadOnly(readOnly);\n\n            if (readOnly)\n            {\n               eventBus.fireEvent(new NotificationEvent(Severity.Info, messages.notifyReadOnlyWorkspace()));\n            }\n            else\n            {\n               eventBus.fireEvent(new NotificationEvent(Severity.Info, messages.notifyEditableWorkspace()));\n            }\n         }\n      }));\n\n      display.gotoFirstPage();\n\n      History.fireCurrentHistoryState();\n   }","id":90995,"modified_method":"@Override\n   protected void onBind()\n   {\n      display.setTableModelHandler(tableModelHandler);\n      display.setPageSize(TableConstants.PAGE_SIZE);\n\n      registerHandler(filterViewConfirmationPanel.getSaveChangesAndFilterButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            saveChangesAndFilter();\n         }\n      }));\n\n      registerHandler(filterViewConfirmationPanel.getSaveFuzzyAndFilterButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            saveFuzzyAndFilter();\n         }\n      }));\n\n      registerHandler(filterViewConfirmationPanel.getDiscardChangesAndFilterButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            discardChangesAndFilter();\n         }\n      }));\n\n      registerHandler(filterViewConfirmationPanel.getCancelFilterButton().addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            cancelFilter();\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(FilterViewEvent.getType(), new FilterViewEventHandler()\n      {\n         @Override\n         public void onFilterView(FilterViewEvent event)\n         {\n            filterTransUnitsView(event);\n         }\n      }));\n\n      registerHandler(display.getSelectionHandlers().addSelectionHandler(new SelectionHandler<TransUnit>()\n      {\n         @Override\n         public void onSelection(SelectionEvent<TransUnit> event)\n         {\n            if (event.getSelectedItem() != null)\n            {\n               display.getTargetCellEditor().savePendingChange(true);\n               selectTransUnit(event.getSelectedItem(), true);\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(DocumentSelectionEvent.getType(), new DocumentSelectionHandler()\n      {\n         @Override\n         public void onDocumentSelected(DocumentSelectionEvent event)\n         {\n            loadDocument(event.getDocumentId());\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(FindMessageEvent.getType(), new FindMessageHandler()\n      {\n\n         @Override\n         public void onFindMessage(FindMessageEvent event)\n         {\n            Log.info(\"Find Message Event: \" + event.getMessage());\n            display.getTargetCellEditor().savePendingChange(true);\n            if (selectedTransUnit != null)\n            {\n               Log.info(\"cancelling selection\");\n               display.getTargetCellEditor().clearSelection();\n            }\n            findMessage = event.getMessage();\n            display.setFindMessage(findMessage);\n            if (selectedTransUnit != null)\n            {\n               targetTransUnitId = selectedTransUnit.getId();\n            }\n            initialiseTransUnitList();\n         }\n\n      }));\n\n      registerHandler(eventBus.addHandler(TransUnitUpdatedEvent.getType(), new TransUnitUpdatedEventHandler()\n      {\n         @Override\n         public void onTransUnitUpdated(TransUnitUpdatedEvent event)\n         {\n            transIdStateList.put(event.getUpdateInfo().getTransUnit().getId().getId(), event.getUpdateInfo().getTransUnit().getStatus());\n            // assume update was successful\n            if (documentId != null && documentId.equals(event.getUpdateInfo().getDocumentId()))\n            {\n               // if its different user,\n               if (!event.getSessionId().equals(identity.getSessionId()))\n               {\n                  if (selectedTransUnit != null && selectedTransUnit.getId().equals(event.getUpdateInfo().getTransUnit().getId()))\n                  {\n                     Log.info(\"selected TU updated; clear selection\");\n                     eventBus.fireEvent(new RequestValidationEvent());\n                  }\n\n                  // - add TU index to model\n                  Integer rowIndex = getRowIndex(event.getUpdateInfo().getTransUnit());\n                  if (rowIndex != null)\n                  {\n                     Log.info(\"onTransUnitUpdated - update row:\" + rowIndex);\n                     display.getTableModel().setRowValueOverride(rowIndex, event.getUpdateInfo().getTransUnit());\n                  }\n               }\n               else\n               {\n                  Integer rowIndex = getRowIndex(event.getUpdateInfo().getTransUnit());\n                  if (rowIndex != null)\n                  {\n                     display.getRowValue(rowIndex).OverrideWith(event.getUpdateInfo().getTransUnit());\n                     display.getTableModel().clearCache();\n                  }\n               }\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(NavTransUnitEvent.getType(), new NavTransUnitHandler()\n      {\n         @Override\n         public void onNavTransUnit(NavTransUnitEvent event)\n         {\n            if (selectedTransUnit != null)\n            {\n               // int step = event.getStep();\n               // Send message to server to stop editing current\n               // selection\n               // stopEditing(selectedTransUnit);\n\n               // If goto Next or Prev Fuzzy/New Trans Unit\n               if (event.getRowType() == NavigationType.PrevEntry)\n               {\n                  targetContentsPresenter.saveAsApprovedAndMovePrevious();\n               }\n\n               if (event.getRowType() == NavigationType.NextEntry)\n               {\n                  targetContentsPresenter.saveAsApprovedAndMoveNext();\n               }\n\n               if (event.getRowType() == NavigationType.PrevState)\n               {\n                  targetContentsPresenter.moveToNextState(NavigationType.PrevEntry);\n               }\n\n               if (event.getRowType() == NavigationType.NextState)\n               {\n                  targetContentsPresenter.moveToNextState(NavigationType.NextEntry);\n               }\n\n               if (event.getRowType() == NavigationType.FirstEntry)\n               {\n                  targetContentsPresenter.saveAndMoveRow(NavigationType.FirstEntry);\n               }\n\n               if (event.getRowType() == NavigationType.LastEntry)\n               {\n                  targetContentsPresenter.saveAndMoveRow(NavigationType.LastEntry);\n               }\n\n            }\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(OpenEditorEvent.getType(), new OpenEditorEventHandler()\n      {\n         @Override\n         public void onOpenEditor(OpenEditorEvent event)\n         {\n            tableModelHandler.gotoRowInCurrentPage(event.getRowNum(), true);\n         }\n      }));\n\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), new WorkspaceContextUpdateEventHandler()\n      {\n         @Override\n         public void onWorkspaceContextUpdated(WorkspaceContextUpdateEvent event)\n         {\n            boolean readOnly = event.isReadOnly();\n            workspaceContext.setReadOnly(readOnly);\n            configHolder.setDisplayButtons(false);\n            eventBus.fireEvent(new UserConfigChangeEvent());\n            display.getTargetCellEditor().setReadOnly(readOnly);\n\n            if (readOnly)\n            {\n               eventBus.fireEvent(new NotificationEvent(Severity.Info, messages.notifyReadOnlyWorkspace()));\n            }\n            else\n            {\n               eventBus.fireEvent(new NotificationEvent(Severity.Info, messages.notifyEditableWorkspace()));\n            }\n         }\n      }));\n\n      display.gotoFirstPage();\n\n      History.fireCurrentHistoryState();\n   }","commit_id":"98cc0b81997ade712e577110b7ee3634a9d4bba6","url":"https://github.com/zanata/zanata-server"},{"original_method":"/** {@inheritDoc} */\n        @Override public void startEdit() {\n            String item = getItem();\n\n            if (item == null || item.isEmpty())\n                return;\n\n            super.startEdit();\n\n            rowVal = getTableView().getSelectionModel().getSelectedItem();\n\n            curTxt = \"\";\n\n            hardCancel = false;\n\n            Node g = getGraphic();\n\n            if (g != null) {\n                final TextField tf = (TextField)g;\n\n                tf.textProperty().addListener(new ChangeListener<String>() {\n                    @Override public void changed(ObservableValue<? extends String> val, String oldVal, String newVal) {\n                        curTxt = newVal;\n                    }\n                });\n\n                tf.setOnKeyPressed(new EventHandler<KeyEvent>() {\n                    @Override public void handle(KeyEvent evt) {\n                        if (KeyCode.ENTER == evt.getCode())\n                            cancelEdit();\n                        else if (KeyCode.ESCAPE == evt.getCode()) {\n                            hardCancel = true;\n\n                            cancelEdit();\n                        }\n                    }\n                });\n\n                tf.setOnKeyReleased(new EventHandler<KeyEvent>() {\n                    @Override public void handle(KeyEvent evt) {\n                        // No-op to overwrite JavaFX implementation.\n                    }\n                });\n\n                // Special hack for editable TextFieldTableCell.\n                // Cancel edit when focus lost from text field, but do not cancel if focus lost to VirtualFlow.\n                tf.focusedProperty().addListener(new ChangeListener<Boolean>() {\n                    @Override public void changed(ObservableValue<? extends Boolean> val, Boolean oldVal, Boolean newVal) {\n                        Node fo = getScene().getFocusOwner();\n\n                        if (!newVal) {\n                            if (fo instanceof VirtualFlow) {\n                                if (fo.getParent().getParent() != getTableView())\n                                    cancelEdit();\n                            }\n                            else\n                                cancelEdit();\n                        }\n                    }\n                });\n\n                Platform.runLater(new Runnable() {\n                    @Override public void run() {\n                        tf.requestFocus();\n                    }\n                });\n            }\n        }","id":90996,"modified_method":"/** {@inheritDoc} */\n        @Override public void startEdit() {\n            String item = getItem();\n\n            if (item == null || item.isEmpty())\n                return;\n\n            super.startEdit();\n\n            rowVal = getTableView().getSelectionModel().getSelectedItem();\n\n            Node g = getGraphic();\n\n            if (g != null) {\n                final TextField tf = (TextField)g;\n\n                curTxt = tf.getText();\n\n                tf.textProperty().addListener(new ChangeListener<String>() {\n                    @Override public void changed(ObservableValue<? extends String> val, String oldVal, String newVal) {\n                        curTxt = newVal;\n                    }\n                });\n\n                tf.setOnKeyPressed(new EventHandler<KeyEvent>() {\n                    @Override public void handle(KeyEvent evt) {\n                        if (KeyCode.ENTER == evt.getCode() || KeyCode.ESCAPE == evt.getCode())\n                            cancelEdit();\n                    }\n                });\n\n                tf.setOnKeyReleased(new EventHandler<KeyEvent>() {\n                    @Override public void handle(KeyEvent evt) {\n                        // No-op to overwrite JavaFX implementation.\n                    }\n                });\n\n                // Special hack for editable TextFieldTableCell.\n                // Cancel edit when focus lost from text field, but do not cancel if focus lost to VirtualFlow.\n                tf.focusedProperty().addListener(new ChangeListener<Boolean>() {\n                    @Override public void changed(ObservableValue<? extends Boolean> val, Boolean oldVal, Boolean newVal) {\n                        Node fo = getScene().getFocusOwner();\n\n                        if (!newVal) {\n                            if (fo instanceof VirtualFlow) {\n                                if (fo.getParent().getParent() != getTableView())\n                                    cancelEdit();\n                            }\n                            else\n                                cancelEdit();\n                        }\n                    }\n                });\n\n                Platform.runLater(new Runnable() {\n                    @Override public void run() {\n                        tf.requestFocus();\n                    }\n                });\n            }\n        }","commit_id":"1356a20627be5aa0405a8a04823e5ee0af47ba5a","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n        @Override public void cancelEdit() {\n            if (cancelling)\n                super.cancelEdit();\n            else\n                try {\n                    cancelling = true;\n\n                    if (hardCancel || curTxt.trim().isEmpty())\n                        super.cancelEdit();\n                    else if (validator.valid(rowVal, curTxt))\n                        commitEdit(curTxt);\n                    else\n                        super.cancelEdit();\n                }\n                finally {\n                    cancelling = false;\n                }\n        }","id":90997,"modified_method":"/** {@inheritDoc} */\n        @Override public void cancelEdit() {\n            boolean editing = isEditing();\n\n            super.cancelEdit();\n\n            if (editing && validator.valid(rowVal, curTxt))\n                updateItem(curTxt, false);\n        }","commit_id":"1356a20627be5aa0405a8a04823e5ee0af47ba5a","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * Text field cell constructor.\n         *\n         * @param validator Input text validator.\n         */\n        private TextFieldTableCellEx(TextColumnValidator<S> validator) {\n            this.validator = validator;\n        }","id":90998,"modified_method":"/**\n         * Text field cell constructor.\n         *\n         * @param validator Input text validator.\n         */\n        private TextFieldTableCellEx(TextColumnValidator<S> validator) {\n            super(new DefaultStringConverter());\n\n            this.validator = validator;\n        }","commit_id":"1356a20627be5aa0405a8a04823e5ee0af47ba5a","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Create generate pane with controls.\n     */\n    private void createGeneratePane() {\n        genPnl = paneEx(10, 10, 0, 10);\n\n        genPnl.addColumn();\n        genPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        genPnl.addColumn(35, 35, 35, Priority.NEVER);\n\n        genPnl.addRow(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        genPnl.addRows(7);\n\n        TableColumn<PojoDescriptor, Boolean> useCol = customColumn(\"Schema / Table\", \"use\",\n            \"If checked then this table will be used for XML and POJOs generation\", PojoDescriptorCell.cellFactory());\n\n        TableColumn<PojoDescriptor, String> keyClsCol = textColumn(\"Key Class Name\", \"keyClassName\", \"Key class name\",\n            new TextColumnValidator<PojoDescriptor>() {\n                @Override public boolean valid(PojoDescriptor rowVal, String newVal) {\n                    boolean valid = checkClassName(rowVal, newVal, true);\n\n                    if (valid)\n                        rowVal.keyClassName(newVal);\n\n                    return valid;\n                }\n            });\n\n        TableColumn<PojoDescriptor, String> valClsCol = textColumn(\"Value Class Name\", \"valueClassName\", \"Value class name\",\n            new TextColumnValidator<PojoDescriptor>() {\n                @Override public boolean valid(PojoDescriptor rowVal, String newVal) {\n                    boolean valid = checkClassName(rowVal, newVal, true);\n\n                    if (valid)\n                        rowVal.valueClassName(newVal);\n\n                    return valid;\n                }\n            });\n\n        pojosTbl = tableView(\"Tables not found in database\", useCol, keyClsCol, valClsCol);\n\n        TableColumn<PojoField, Boolean> useFldCol = customColumn(\"Use\", \"use\",\n            \"Check to use this field for XML and POJO generation\\n\" +\n            \"Note that NOT NULL columns cannot be unchecked\", PojoFieldUseCell.cellFactory());\n        useFldCol.setMinWidth(50);\n        useFldCol.setMaxWidth(50);\n\n        TableColumn<PojoField, Boolean> keyCol = booleanColumn(\"Key\", \"key\",\n            \"Check to include this field into key object\");\n\n        TableColumn<PojoField, Boolean> akCol = booleanColumn(\"AK\", \"affinityKey\",\n            \"Check to annotate key filed with @CacheAffinityKeyMapped annotation in generated POJO class\\n\" +\n            \"Note that a class can have only ONE key field annotated with @CacheAffinityKeyMapped annotation\");\n\n        TableColumn<PojoField, String> dbNameCol = tableColumn(\"DB Name\", \"dbName\", \"Field name in database\");\n\n        TableColumn<PojoField, String> dbTypeNameCol = tableColumn(\"DB Type\", \"dbTypeName\", \"Field type in database\");\n\n        TableColumn<PojoField, String> javaNameCol = textColumn(\"Java Name\", \"javaName\", \"Field name in POJO class\",\n            new TextColumnValidator<PojoField>() {\n                @Override public boolean valid(PojoField rowVal, String newVal) {\n                    for (PojoField field : curPojo.fields())\n                        if (rowVal != field && newVal.equals(field.javaName())) {\n                            MessageBox.warningDialog(owner, \"Java name must be unique!\");\n\n                            return false;\n                        }\n\n                    rowVal.javaName(newVal);\n\n                    return true;\n                }\n            });\n\n        TableColumn<PojoField, String> javaTypeNameCol = customColumn(\"Java Type\", \"javaTypeName\",\n            \"Field java type in POJO class\", JavaTypeCell.cellFactory());\n\n        fieldsTbl = tableView(\"Select table to see table columns\",\n            useFldCol, keyCol, akCol, dbNameCol, dbTypeNameCol, javaNameCol, javaTypeNameCol);\n\n        genPnl.add(splitPane(pojosTbl, fieldsTbl, 0.6), 3);\n\n        final GridPaneEx keyValPnl = paneEx(0, 0, 0, 0);\n        keyValPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        keyValPnl.addColumn();\n        keyValPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        keyValPnl.addColumn();\n\n        pkgTf = genPnl.addLabeled(\"Package:\", textField(\"Package that will be used for POJOs generation\"), 2);\n\n        outFolderTf = genPnl.addLabeled(\"Output Folder:\", textField(\"Output folder for XML and POJOs files\"));\n\n        genPnl.add(button(\"...\", \"Select output folder\", new EventHandler<ActionEvent>() {\n            @Override public void handle(ActionEvent evt) {\n                DirectoryChooser dc = new DirectoryChooser();\n\n                try {\n                    File outFolder = new File(outFolderTf.getText());\n\n                    if (outFolder.exists())\n                        dc.setInitialDirectory(outFolder);\n                }\n                catch (Throwable ignored) {\n                    // No-op.\n                }\n\n                File folder = dc.showDialog(owner);\n\n                if (folder != null)\n                    outFolderTf.setText(folder.getAbsolutePath());\n            }\n        }));\n\n        pojoIncludeKeysCh = genPnl.add(checkBox(\"Include key fields into value POJOs\",\n            \"If selected then include key fields into value object\", true), 3);\n\n        pojoConstructorCh = genPnl.add(checkBox(\"Generate constructors for POJOs\",\n            \"If selected then generate empty and full constructors for POJOs\", false), 3);\n\n        xmlSingleFileCh = genPnl.add(checkBox(\"Write all configurations to a single XML file\",\n            \"If selected then all configurations will be saved into the file 'Ignite.xml'\", true), 3);\n\n        GridPaneEx regexPnl = paneEx(5, 5, 5, 5);\n        regexPnl.addColumn();\n        regexPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        regexPnl.addColumn();\n        regexPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n\n        regexTf = regexPnl.addLabeled(\"  Regexp:\", textField(\"Regular expression. For example: (\\\\w+)\"));\n\n        replaceTf = regexPnl.addLabeled(\"  Replace with:\", textField(\"Replace text. For example: $1_SomeText\"));\n\n        final ComboBox<String> replaceCb = regexPnl.addLabeled(\"  Replace:\", comboBox(\"Replacement target\",\n            \"Key class names\", \"Value class names\", \"Java names\"));\n\n        regexPnl.add(buttonsPane(Pos.CENTER_LEFT, false,\n            button(\"Rename Selected\", \"Replaces each substring of this string that matches the given regular expression\" +\n                    \" with the given replacement.\",\n                new EventHandler<ActionEvent>() {\n                    @Override public void handle(ActionEvent evt) {\n                        if (checkInput(regexTf, false, \"Regular expression should not be empty!\"))\n                            return;\n\n                        String sel = replaceCb.getSelectionModel().getSelectedItem();\n\n                        boolean isFields = \"Java names\".equals(sel) && curTbl == fieldsTbl;\n\n                        String src = isFields ? \"fields\" : \"tables\";\n\n                        String target = \"\\\"\" + sel + \"\\\"\";\n\n                        Collection<PojoDescriptor> selPojos = pojosTbl.getSelectionModel().getSelectedItems();\n\n                        Collection<PojoField> selFields = fieldsTbl.getSelectionModel().getSelectedItems();\n\n                        boolean isEmpty = isFields ? selFields.isEmpty() : selPojos.isEmpty();\n\n                        if (isEmpty) {\n                            MessageBox.warningDialog(owner, \"Please select \" + src + \" to rename \" + target + \"!\");\n\n                            return;\n                        }\n\n                        if (!MessageBox.confirmDialog(owner, \"Are you sure you want to rename \" + target +\n                            \" for all selected \" + src + \"?\"))\n                            return;\n\n                        String regex = regexTf.getText();\n\n                        String replace = replaceTf.getText();\n\n                        try {\n                            switch (replaceCb.getSelectionModel().getSelectedIndex()) {\n                                case 0:\n                                    renameKeyClassNames(selPojos, regex, replace);\n                                    break;\n\n                                case 1:\n                                    renameValueClassNames(selPojos, regex, replace);\n                                    break;\n\n                                default:\n                                    if (isFields)\n                                        renameFieldsJavaNames(selFields, regex, replace);\n                                    else\n                                        renamePojosJavaNames(selPojos, regex, replace);\n                            }\n                        }\n                        catch (Exception e) {\n                            MessageBox.errorDialog(owner, \"Failed to rename \" + target + \"!\", e);\n                        }\n                    }\n                }),\n            button(\"Reset Selected\", \"Revert changes for selected items to initial auto-generated values\", new EventHandler<ActionEvent>() {\n                @Override public void handle(ActionEvent evt) {\n                    String sel = replaceCb.getSelectionModel().getSelectedItem();\n\n                    boolean isFields = \"Java names\".equals(sel) && curTbl == fieldsTbl;\n\n                    String src = isFields ? \"fields\" : \"tables\";\n\n                    String target = \"\\\"\" + sel + \"\\\"\";\n\n                    Collection<PojoDescriptor> selPojos = pojosTbl.getSelectionModel().getSelectedItems();\n\n                    Collection<PojoField> selFields = fieldsTbl.getSelectionModel().getSelectedItems();\n\n                    boolean isEmpty = isFields ? selFields.isEmpty() : selPojos.isEmpty();\n\n                    if (isEmpty) {\n                        MessageBox.warningDialog(owner, \"Please select \" + src + \"to revert \" + target + \"!\");\n\n                        return;\n                    }\n\n                    if (!MessageBox.confirmDialog(owner,\n                        \"Are you sure you want to revert \" + target + \" for all selected \" + src + \"?\"))\n                        return;\n\n                    switch (replaceCb.getSelectionModel().getSelectedIndex()) {\n                        case 0:\n                            revertKeyClassNames(selPojos);\n                            break;\n\n                        case 1:\n                            revertValueClassNames(selPojos);\n                            break;\n\n                        default:\n                            if (isFields)\n                                revertFieldsJavaNames(selFields);\n                            else\n                                revertPojosJavaNames(selPojos);\n                    }\n                }\n            })\n        ), 2).setPadding(new Insets(0, 0, 0, 10));\n\n        pojosTbl.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<PojoDescriptor>() {\n            @Override public void changed(ObservableValue<? extends PojoDescriptor> val,\n                PojoDescriptor oldVal, PojoDescriptor newItem) {\n                if (newItem != null && newItem.parent() != null) {\n                    curPojo = newItem;\n\n                    fieldsTbl.setItems(curPojo.fields());\n                    fieldsTbl.getSelectionModel().clearSelection();\n\n                    keyValPnl.setDisable(false);\n                }\n                else {\n                    curPojo = null;\n                    fieldsTbl.setItems(NO_FIELDS);\n\n                    keyValPnl.setDisable(true);\n                }\n            }\n        });\n\n        pojosTbl.focusedProperty().addListener(new ChangeListener<Boolean>() {\n            @Override public void changed(ObservableValue<? extends Boolean> val, Boolean oldVal, Boolean newVal) {\n                if (newVal)\n                    curTbl = pojosTbl;\n            }\n        });\n\n        fieldsTbl.getSelectionModel().selectedIndexProperty().addListener(new ChangeListener<Number>() {\n            @Override public void changed(ObservableValue<? extends Number> val, Number oldVal, Number newVal) {\n                if (curPojo != null) {\n                    TableView.TableViewSelectionModel<PojoDescriptor> selMdl = pojosTbl.getSelectionModel();\n\n                    List<Integer> idxs = new ArrayList<>(selMdl.getSelectedIndices());\n\n                    if (idxs.size() > 1) {\n                        for (Integer idx : idxs) {\n                            if (pojos.get(idx) != curPojo)\n                                selMdl.clearSelection(idx);\n                        }\n                    }\n                }\n            }\n        });\n\n        fieldsTbl.focusedProperty().addListener(new ChangeListener<Boolean>() {\n            @Override public void changed(ObservableValue<? extends Boolean> val, Boolean oldVal, Boolean newVal) {\n                if (newVal)\n                    curTbl = fieldsTbl;\n            }\n        });\n\n        genPnl.add(titledPane(\"Rename \\\"Key class name\\\", \\\"Value class name\\\" or  \\\"Java name\\\" for selected tables\",\n            regexPnl), 3);\n\n        genLayerPnl = stackPane(genPnl);\n    }","id":90999,"modified_method":"/**\n     * Create generate pane with controls.\n     */\n    private void createGeneratePane() {\n        genPnl = paneEx(10, 10, 0, 10);\n\n        genPnl.addColumn();\n        genPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        genPnl.addColumn(35, 35, 35, Priority.NEVER);\n\n        genPnl.addRow(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        genPnl.addRows(7);\n\n        TableColumn<PojoDescriptor, Boolean> useCol = customColumn(\"Schema / Table\", \"use\",\n            \"If checked then this table will be used for XML and POJOs generation\", PojoDescriptorCell.cellFactory());\n\n        TableColumn<PojoDescriptor, String> keyClsCol = textColumn(\"Key Class Name\", \"keyClassName\", \"Key class name\",\n            new TextColumnValidator<PojoDescriptor>() {\n                @Override public boolean valid(PojoDescriptor rowVal, String newVal) {\n                    boolean valid = checkClassName(rowVal, newVal, true);\n\n                    if (valid)\n                        rowVal.keyClassName(newVal);\n\n                    return valid;\n                }\n            });\n\n        TableColumn<PojoDescriptor, String> valClsCol = textColumn(\"Value Class Name\", \"valueClassName\", \"Value class name\",\n            new TextColumnValidator<PojoDescriptor>() {\n                @Override public boolean valid(PojoDescriptor rowVal, String newVal) {\n                    boolean valid = checkClassName(rowVal, newVal, false);\n\n                    if (valid)\n                        rowVal.valueClassName(newVal);\n\n                    return valid;\n                }\n            });\n\n        pojosTbl = tableView(\"Tables not found in database\", useCol, keyClsCol, valClsCol);\n\n        TableColumn<PojoField, Boolean> useFldCol = customColumn(\"Use\", \"use\",\n            \"Check to use this field for XML and POJO generation\\n\" +\n            \"Note that NOT NULL columns cannot be unchecked\", PojoFieldUseCell.cellFactory());\n        useFldCol.setMinWidth(50);\n        useFldCol.setMaxWidth(50);\n\n        TableColumn<PojoField, Boolean> keyCol = booleanColumn(\"Key\", \"key\",\n            \"Check to include this field into key object\");\n\n        TableColumn<PojoField, Boolean> akCol = booleanColumn(\"AK\", \"affinityKey\",\n            \"Check to annotate key filed with @CacheAffinityKeyMapped annotation in generated POJO class\\n\" +\n            \"Note that a class can have only ONE key field annotated with @CacheAffinityKeyMapped annotation\");\n\n        TableColumn<PojoField, String> dbNameCol = tableColumn(\"DB Name\", \"dbName\", \"Field name in database\");\n\n        TableColumn<PojoField, String> dbTypeNameCol = tableColumn(\"DB Type\", \"dbTypeName\", \"Field type in database\");\n\n        TableColumn<PojoField, String> javaNameCol = textColumn(\"Java Name\", \"javaName\", \"Field name in POJO class\",\n            new TextColumnValidator<PojoField>() {\n                @Override public boolean valid(PojoField rowVal, String newVal) {\n                    if (newVal.trim().isEmpty()) {\n                        MessageBox.warningDialog(owner, \"Java name must be non empty!\");\n\n                        return false;\n                    }\n\n                    for (PojoField field : curPojo.fields())\n                        if (rowVal != field && newVal.equals(field.javaName())) {\n                            MessageBox.warningDialog(owner, \"Java name must be unique!\");\n\n                            return false;\n                        }\n\n                    rowVal.javaName(newVal);\n\n                    return true;\n                }\n            });\n\n        TableColumn<PojoField, String> javaTypeNameCol = customColumn(\"Java Type\", \"javaTypeName\",\n            \"Field java type in POJO class\", JavaTypeCell.cellFactory());\n\n        fieldsTbl = tableView(\"Select table to see table columns\",\n            useFldCol, keyCol, akCol, dbNameCol, dbTypeNameCol, javaNameCol, javaTypeNameCol);\n\n        genPnl.add(splitPane(pojosTbl, fieldsTbl, 0.6), 3);\n\n        final GridPaneEx keyValPnl = paneEx(0, 0, 0, 0);\n        keyValPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        keyValPnl.addColumn();\n        keyValPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        keyValPnl.addColumn();\n\n        pkgTf = genPnl.addLabeled(\"Package:\", textField(\"Package that will be used for POJOs generation\"), 2);\n\n        outFolderTf = genPnl.addLabeled(\"Output Folder:\", textField(\"Output folder for XML and POJOs files\"));\n\n        genPnl.add(button(\"...\", \"Select output folder\", new EventHandler<ActionEvent>() {\n            @Override public void handle(ActionEvent evt) {\n                DirectoryChooser dc = new DirectoryChooser();\n\n                try {\n                    File outFolder = new File(outFolderTf.getText());\n\n                    if (outFolder.exists())\n                        dc.setInitialDirectory(outFolder);\n                }\n                catch (Throwable ignored) {\n                    // No-op.\n                }\n\n                File folder = dc.showDialog(owner);\n\n                if (folder != null)\n                    outFolderTf.setText(folder.getAbsolutePath());\n            }\n        }));\n\n        pojoIncludeKeysCh = genPnl.add(checkBox(\"Include key fields into value POJOs\",\n            \"If selected then include key fields into value object\", true), 3);\n\n        pojoConstructorCh = genPnl.add(checkBox(\"Generate constructors for POJOs\",\n            \"If selected then generate empty and full constructors for POJOs\", false), 3);\n\n        xmlSingleFileCh = genPnl.add(checkBox(\"Write all configurations to a single XML file\",\n            \"If selected then all configurations will be saved into the file 'Ignite.xml'\", true), 3);\n\n        GridPaneEx regexPnl = paneEx(5, 5, 5, 5);\n        regexPnl.addColumn();\n        regexPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n        regexPnl.addColumn();\n        regexPnl.addColumn(100, 100, Double.MAX_VALUE, Priority.ALWAYS);\n\n        regexTf = regexPnl.addLabeled(\"  Regexp:\", textField(\"Regular expression. For example: (\\\\w+)\"));\n\n        replaceTf = regexPnl.addLabeled(\"  Replace with:\", textField(\"Replace text. For example: $1_SomeText\"));\n\n        final ComboBox<String> replaceCb = regexPnl.addLabeled(\"  Replace:\", comboBox(\"Replacement target\",\n            \"Key class names\", \"Value class names\", \"Java names\"));\n\n        regexPnl.add(buttonsPane(Pos.CENTER_LEFT, false,\n            button(\"Rename Selected\", \"Replaces each substring of this string that matches the given regular expression\" +\n                    \" with the given replacement.\",\n                new EventHandler<ActionEvent>() {\n                    @Override public void handle(ActionEvent evt) {\n                        if (checkInput(regexTf, false, \"Regular expression should not be empty!\"))\n                            return;\n\n                        String sel = replaceCb.getSelectionModel().getSelectedItem();\n\n                        boolean isFields = \"Java names\".equals(sel) && curTbl == fieldsTbl;\n\n                        String src = isFields ? \"fields\" : \"tables\";\n\n                        String target = \"\\\"\" + sel + \"\\\"\";\n\n                        Collection<PojoDescriptor> selPojos = pojosTbl.getSelectionModel().getSelectedItems();\n\n                        Collection<PojoField> selFields = fieldsTbl.getSelectionModel().getSelectedItems();\n\n                        boolean isEmpty = isFields ? selFields.isEmpty() : selPojos.isEmpty();\n\n                        if (isEmpty) {\n                            MessageBox.warningDialog(owner, \"Please select \" + src + \" to rename \" + target + \"!\");\n\n                            return;\n                        }\n\n                        if (!MessageBox.confirmDialog(owner, \"Are you sure you want to rename \" + target +\n                            \" for all selected \" + src + \"?\"))\n                            return;\n\n                        String regex = regexTf.getText();\n\n                        String replace = replaceTf.getText();\n\n                        try {\n                            switch (replaceCb.getSelectionModel().getSelectedIndex()) {\n                                case 0:\n                                    renameKeyClassNames(selPojos, regex, replace);\n                                    break;\n\n                                case 1:\n                                    renameValueClassNames(selPojos, regex, replace);\n                                    break;\n\n                                default:\n                                    if (isFields)\n                                        renameFieldsJavaNames(selFields, regex, replace);\n                                    else\n                                        renamePojosJavaNames(selPojos, regex, replace);\n                            }\n                        }\n                        catch (Exception e) {\n                            MessageBox.errorDialog(owner, \"Failed to rename \" + target + \"!\", e);\n                        }\n                    }\n                }),\n            button(\"Reset Selected\", \"Revert changes for selected items to initial auto-generated values\", new EventHandler<ActionEvent>() {\n                @Override public void handle(ActionEvent evt) {\n                    String sel = replaceCb.getSelectionModel().getSelectedItem();\n\n                    boolean isFields = \"Java names\".equals(sel) && curTbl == fieldsTbl;\n\n                    String src = isFields ? \"fields\" : \"tables\";\n\n                    String target = \"\\\"\" + sel + \"\\\"\";\n\n                    Collection<PojoDescriptor> selPojos = pojosTbl.getSelectionModel().getSelectedItems();\n\n                    Collection<PojoField> selFields = fieldsTbl.getSelectionModel().getSelectedItems();\n\n                    boolean isEmpty = isFields ? selFields.isEmpty() : selPojos.isEmpty();\n\n                    if (isEmpty) {\n                        MessageBox.warningDialog(owner, \"Please select \" + src + \"to revert \" + target + \"!\");\n\n                        return;\n                    }\n\n                    if (!MessageBox.confirmDialog(owner,\n                        \"Are you sure you want to revert \" + target + \" for all selected \" + src + \"?\"))\n                        return;\n\n                    switch (replaceCb.getSelectionModel().getSelectedIndex()) {\n                        case 0:\n                            revertKeyClassNames(selPojos);\n                            break;\n\n                        case 1:\n                            revertValueClassNames(selPojos);\n                            break;\n\n                        default:\n                            if (isFields)\n                                revertFieldsJavaNames(selFields);\n                            else\n                                revertPojosJavaNames(selPojos);\n                    }\n                }\n            })\n        ), 2).setPadding(new Insets(0, 0, 0, 10));\n\n        pojosTbl.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<PojoDescriptor>() {\n            @Override public void changed(ObservableValue<? extends PojoDescriptor> val,\n                PojoDescriptor oldVal, PojoDescriptor newItem) {\n                if (newItem != null && newItem.parent() != null) {\n                    curPojo = newItem;\n\n                    fieldsTbl.setItems(curPojo.fields());\n                    fieldsTbl.getSelectionModel().clearSelection();\n\n                    keyValPnl.setDisable(false);\n                }\n                else {\n                    curPojo = null;\n                    fieldsTbl.setItems(NO_FIELDS);\n\n                    keyValPnl.setDisable(true);\n                }\n            }\n        });\n\n        pojosTbl.focusedProperty().addListener(new ChangeListener<Boolean>() {\n            @Override public void changed(ObservableValue<? extends Boolean> val, Boolean oldVal, Boolean newVal) {\n                if (newVal)\n                    curTbl = pojosTbl;\n            }\n        });\n\n        fieldsTbl.getSelectionModel().selectedIndexProperty().addListener(new ChangeListener<Number>() {\n            @Override public void changed(ObservableValue<? extends Number> val, Number oldVal, Number newVal) {\n                if (curPojo != null) {\n                    TableView.TableViewSelectionModel<PojoDescriptor> selMdl = pojosTbl.getSelectionModel();\n\n                    List<Integer> idxs = new ArrayList<>(selMdl.getSelectedIndices());\n\n                    if (idxs.size() > 1) {\n                        for (Integer idx : idxs) {\n                            if (pojos.get(idx) != curPojo)\n                                selMdl.clearSelection(idx);\n                        }\n                    }\n                }\n            }\n        });\n\n        fieldsTbl.focusedProperty().addListener(new ChangeListener<Boolean>() {\n            @Override public void changed(ObservableValue<? extends Boolean> val, Boolean oldVal, Boolean newVal) {\n                if (newVal)\n                    curTbl = fieldsTbl;\n            }\n        });\n\n        genPnl.add(titledPane(\"Rename \\\"Key class name\\\", \\\"Value class name\\\" or  \\\"Java name\\\" for selected tables\",\n            regexPnl), 3);\n\n        genLayerPnl = stackPane(genPnl);\n    }","commit_id":"1356a20627be5aa0405a8a04823e5ee0af47ba5a","url":"https://github.com/apache/ignite"}]